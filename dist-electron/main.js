var my = Object.defineProperty;
var gy = (r, e, t) => e in r ? my(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t;
var b = (r, e, t) => gy(r, typeof e != "symbol" ? e + "" : e, t);
import { app as Bt, webContents as Vs, BrowserWindow as xu, ipcMain as Ge } from "electron";
import { URL as _y, fileURLToPath as yy } from "node:url";
import Ie from "node:path";
import nn, { randomFillSync as wy, randomUUID as vy } from "node:crypto";
import Do from "keytar";
import by from "fs";
import If from "path";
import Sy from "os";
import gs from "crypto";
import { AsyncLocalStorage as Ty } from "node:async_hooks";
import Xe from "node:fs/promises";
import Ey from "better-sqlite3";
const mt = [];
for (let r = 0; r < 256; ++r)
  mt.push((r + 256).toString(16).slice(1));
function xy(r, e = 0) {
  return (mt[r[e + 0]] + mt[r[e + 1]] + mt[r[e + 2]] + mt[r[e + 3]] + "-" + mt[r[e + 4]] + mt[r[e + 5]] + "-" + mt[r[e + 6]] + mt[r[e + 7]] + "-" + mt[r[e + 8]] + mt[r[e + 9]] + "-" + mt[r[e + 10]] + mt[r[e + 11]] + mt[r[e + 12]] + mt[r[e + 13]] + mt[r[e + 14]] + mt[r[e + 15]]).toLowerCase();
}
const Ka = new Uint8Array(256);
let ba = Ka.length;
function ky() {
  return ba > Ka.length - 16 && (wy(Ka), ba = 0), Ka.slice(ba, ba += 16);
}
const Wl = { randomUUID: vy };
function Iy(r, e, t) {
  var s;
  r = r || {};
  const n = r.random ?? ((s = r.rng) == null ? void 0 : s.call(r)) ?? ky();
  if (n.length < 16)
    throw new Error("Random bytes length must be >= 16");
  return n[6] = n[6] & 15 | 64, n[8] = n[8] & 63 | 128, xy(n);
}
function Pe(r, e, t) {
  return Wl.randomUUID && !r ? Wl.randomUUID() : Iy(r);
}
class Oy {
  constructor() {
    b(this, "serviceName", "EnterpriseAgenticBrowser");
  }
  async setSecret(e, t) {
    await Do.setPassword(this.serviceName, e, t);
  }
  async getSecret(e) {
    return await Do.getPassword(this.serviceName, e);
  }
  async deleteSecret(e) {
    return await Do.deletePassword(this.serviceName, e);
  }
}
const Ps = new Oy();
function Sa(r, e) {
  return r.lc_error_code = e, r.message = `${r.message}

Troubleshooting URL: https://docs.langchain.com/oss/javascript/langchain/errors/${e}/
`, r;
}
function fe(r, e, t, n, s) {
  if (typeof e == "function" ? r !== e || !0 : !e.has(r))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return e.set(r, t), t;
}
function I(r, e, t, n) {
  if (t === "a" && !n)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof e == "function" ? r !== e || !n : !e.has(r))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return t === "m" ? n : t === "a" ? n.call(r) : n ? n.value : e.get(r);
}
let Of = function() {
  const { crypto: r } = globalThis;
  if (r != null && r.randomUUID)
    return Of = r.randomUUID.bind(r), r.randomUUID();
  const e = new Uint8Array(1), t = r ? () => r.getRandomValues(e)[0] : () => Math.random() * 255 & 255;
  return "10000000-1000-4000-8000-100000000000".replace(/[018]/g, (n) => (+n ^ t() & 15 >> +n / 4).toString(16));
};
function vc(r) {
  return typeof r == "object" && r !== null && // Spec-compliant fetch implementations
  ("name" in r && r.name === "AbortError" || // Expo fetch
  "message" in r && String(r.message).includes("FetchRequestCanceledException"));
}
const bc = (r) => {
  if (r instanceof Error)
    return r;
  if (typeof r == "object" && r !== null) {
    try {
      if (Object.prototype.toString.call(r) === "[object Error]") {
        const e = new Error(r.message, r.cause ? { cause: r.cause } : {});
        return r.stack && (e.stack = r.stack), r.cause && !e.cause && (e.cause = r.cause), r.name && (e.name = r.name), e;
      }
    } catch {
    }
    try {
      return new Error(JSON.stringify(r));
    } catch {
    }
  }
  return new Error(r);
};
class ce extends Error {
}
class St extends ce {
  constructor(e, t, n, s) {
    super(`${St.makeMessage(e, t, n)}`), this.status = e, this.headers = s, this.requestID = s == null ? void 0 : s.get("x-request-id"), this.error = t;
    const a = t;
    this.code = a == null ? void 0 : a.code, this.param = a == null ? void 0 : a.param, this.type = a == null ? void 0 : a.type;
  }
  static makeMessage(e, t, n) {
    const s = t != null && t.message ? typeof t.message == "string" ? t.message : JSON.stringify(t.message) : t ? JSON.stringify(t) : n;
    return e && s ? `${e} ${s}` : e ? `${e} status code (no body)` : s || "(no status code or body)";
  }
  static generate(e, t, n, s) {
    if (!e || !s)
      return new Wi({ message: n, cause: bc(t) });
    const a = t == null ? void 0 : t.error;
    return e === 400 ? new Af(e, a, n, s) : e === 401 ? new $f(e, a, n, s) : e === 403 ? new Cf(e, a, n, s) : e === 404 ? new Rf(e, a, n, s) : e === 409 ? new Nf(e, a, n, s) : e === 422 ? new Pf(e, a, n, s) : e === 429 ? new Lf(e, a, n, s) : e >= 500 ? new Mf(e, a, n, s) : new St(e, a, n, s);
  }
}
class Ut extends St {
  constructor({ message: e } = {}) {
    super(void 0, void 0, e || "Request was aborted.", void 0);
  }
}
class Wi extends St {
  constructor({ message: e, cause: t }) {
    super(void 0, void 0, e || "Connection error.", void 0), t && (this.cause = t);
  }
}
class Ki extends Wi {
  constructor({ message: e } = {}) {
    super({ message: e ?? "Request timed out." });
  }
}
class Af extends St {
}
class $f extends St {
}
class Cf extends St {
}
class Rf extends St {
}
class Nf extends St {
}
class Pf extends St {
}
class Lf extends St {
}
class Mf extends St {
}
class Df extends ce {
  constructor() {
    super("Could not parse response content as the length limit was reached");
  }
}
class jf extends ce {
  constructor() {
    super("Could not parse response content as the request was rejected by the content filter");
  }
}
class _s extends Error {
  constructor(e) {
    super(e);
  }
}
const Ay = /^[a-z][a-z0-9+.-]*:/i, $y = (r) => Ay.test(r);
let Rt = (r) => (Rt = Array.isArray, Rt(r)), Kl = Rt;
function Ff(r) {
  return typeof r != "object" ? {} : r ?? {};
}
function Cy(r) {
  if (!r)
    return !0;
  for (const e in r)
    return !1;
  return !0;
}
function Ry(r, e) {
  return Object.prototype.hasOwnProperty.call(r, e);
}
function jo(r) {
  return r != null && typeof r == "object" && !Array.isArray(r);
}
const Ny = (r, e) => {
  if (typeof e != "number" || !Number.isInteger(e))
    throw new ce(`${r} must be an integer`);
  if (e < 0)
    throw new ce(`${r} must be a positive integer`);
  return e;
}, Py = (r) => {
  try {
    return JSON.parse(r);
  } catch {
    return;
  }
}, na = (r) => new Promise((e) => setTimeout(e, r)), Dn = "6.10.0", Ly = () => (
  // @ts-ignore
  typeof window < "u" && // @ts-ignore
  typeof window.document < "u" && // @ts-ignore
  typeof navigator < "u"
);
function My() {
  return typeof Deno < "u" && Deno.build != null ? "deno" : typeof EdgeRuntime < "u" ? "edge" : Object.prototype.toString.call(typeof globalThis.process < "u" ? globalThis.process : 0) === "[object process]" ? "node" : "unknown";
}
const Dy = () => {
  var t;
  const r = My();
  if (r === "deno")
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": Dn,
      "X-Stainless-OS": Xl(Deno.build.os),
      "X-Stainless-Arch": Yl(Deno.build.arch),
      "X-Stainless-Runtime": "deno",
      "X-Stainless-Runtime-Version": typeof Deno.version == "string" ? Deno.version : ((t = Deno.version) == null ? void 0 : t.deno) ?? "unknown"
    };
  if (typeof EdgeRuntime < "u")
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": Dn,
      "X-Stainless-OS": "Unknown",
      "X-Stainless-Arch": `other:${EdgeRuntime}`,
      "X-Stainless-Runtime": "edge",
      "X-Stainless-Runtime-Version": globalThis.process.version
    };
  if (r === "node")
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": Dn,
      "X-Stainless-OS": Xl(globalThis.process.platform ?? "unknown"),
      "X-Stainless-Arch": Yl(globalThis.process.arch ?? "unknown"),
      "X-Stainless-Runtime": "node",
      "X-Stainless-Runtime-Version": globalThis.process.version ?? "unknown"
    };
  const e = jy();
  return e ? {
    "X-Stainless-Lang": "js",
    "X-Stainless-Package-Version": Dn,
    "X-Stainless-OS": "Unknown",
    "X-Stainless-Arch": "unknown",
    "X-Stainless-Runtime": `browser:${e.browser}`,
    "X-Stainless-Runtime-Version": e.version
  } : {
    "X-Stainless-Lang": "js",
    "X-Stainless-Package-Version": Dn,
    "X-Stainless-OS": "Unknown",
    "X-Stainless-Arch": "unknown",
    "X-Stainless-Runtime": "unknown",
    "X-Stainless-Runtime-Version": "unknown"
  };
};
function jy() {
  if (typeof navigator > "u" || !navigator)
    return null;
  const r = [
    { key: "edge", pattern: /Edge(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "ie", pattern: /MSIE(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "ie", pattern: /Trident(?:.*rv\:(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "chrome", pattern: /Chrome(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "firefox", pattern: /Firefox(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "safari", pattern: /(?:Version\W+(\d+)\.(\d+)(?:\.(\d+))?)?(?:\W+Mobile\S*)?\W+Safari/ }
  ];
  for (const { key: e, pattern: t } of r) {
    const n = t.exec(navigator.userAgent);
    if (n) {
      const s = n[1] || 0, a = n[2] || 0, i = n[3] || 0;
      return { browser: e, version: `${s}.${a}.${i}` };
    }
  }
  return null;
}
const Yl = (r) => r === "x32" ? "x32" : r === "x86_64" || r === "x64" ? "x64" : r === "arm" ? "arm" : r === "aarch64" || r === "arm64" ? "arm64" : r ? `other:${r}` : "unknown", Xl = (r) => (r = r.toLowerCase(), r.includes("ios") ? "iOS" : r === "android" ? "Android" : r === "darwin" ? "MacOS" : r === "win32" ? "Windows" : r === "freebsd" ? "FreeBSD" : r === "openbsd" ? "OpenBSD" : r === "linux" ? "Linux" : r ? `Other:${r}` : "Unknown");
let Ql;
const Fy = () => Ql ?? (Ql = Dy());
function Uy() {
  if (typeof fetch < "u")
    return fetch;
  throw new Error("`fetch` is not defined as a global; Either pass `fetch` to the client, `new OpenAI({ fetch })` or polyfill the global, `globalThis.fetch = fetch`");
}
function Uf(...r) {
  const e = globalThis.ReadableStream;
  if (typeof e > "u")
    throw new Error("`ReadableStream` is not defined as a global; You will need to polyfill it, `globalThis.ReadableStream = ReadableStream`");
  return new e(...r);
}
function zf(r) {
  let e = Symbol.asyncIterator in r ? r[Symbol.asyncIterator]() : r[Symbol.iterator]();
  return Uf({
    start() {
    },
    async pull(t) {
      const { done: n, value: s } = await e.next();
      n ? t.close() : t.enqueue(s);
    },
    async cancel() {
      var t;
      await ((t = e.return) == null ? void 0 : t.call(e));
    }
  });
}
function Bf(r) {
  if (r[Symbol.asyncIterator])
    return r;
  const e = r.getReader();
  return {
    async next() {
      try {
        const t = await e.read();
        return t != null && t.done && e.releaseLock(), t;
      } catch (t) {
        throw e.releaseLock(), t;
      }
    },
    async return() {
      const t = e.cancel();
      return e.releaseLock(), await t, { done: !0, value: void 0 };
    },
    [Symbol.asyncIterator]() {
      return this;
    }
  };
}
async function zy(r) {
  var n, s;
  if (r === null || typeof r != "object")
    return;
  if (r[Symbol.asyncIterator]) {
    await ((s = (n = r[Symbol.asyncIterator]()).return) == null ? void 0 : s.call(n));
    return;
  }
  const e = r.getReader(), t = e.cancel();
  e.releaseLock(), await t;
}
const By = ({ headers: r, body: e }) => ({
  bodyHeaders: {
    "content-type": "application/json"
  },
  body: JSON.stringify(e)
}), Zf = "RFC3986", Vf = (r) => String(r), ed = {
  RFC1738: (r) => String(r).replace(/%20/g, "+"),
  RFC3986: Vf
}, Zy = "RFC1738";
let Sc = (r, e) => (Sc = Object.hasOwn ?? Function.prototype.call.bind(Object.prototype.hasOwnProperty), Sc(r, e));
const pr = /* @__PURE__ */ (() => {
  const r = [];
  for (let e = 0; e < 256; ++e)
    r.push("%" + ((e < 16 ? "0" : "") + e.toString(16)).toUpperCase());
  return r;
})(), Fo = 1024, Vy = (r, e, t, n, s) => {
  if (r.length === 0)
    return r;
  let a = r;
  if (typeof r == "symbol" ? a = Symbol.prototype.toString.call(r) : typeof r != "string" && (a = String(r)), t === "iso-8859-1")
    return escape(a).replace(/%u[0-9a-f]{4}/gi, function(o) {
      return "%26%23" + parseInt(o.slice(2), 16) + "%3B";
    });
  let i = "";
  for (let o = 0; o < a.length; o += Fo) {
    const c = a.length >= Fo ? a.slice(o, o + Fo) : a, u = [];
    for (let l = 0; l < c.length; ++l) {
      let d = c.charCodeAt(l);
      if (d === 45 || // -
      d === 46 || // .
      d === 95 || // _
      d === 126 || // ~
      d >= 48 && d <= 57 || // 0-9
      d >= 65 && d <= 90 || // a-z
      d >= 97 && d <= 122 || // A-Z
      s === Zy && (d === 40 || d === 41)) {
        u[u.length] = c.charAt(l);
        continue;
      }
      if (d < 128) {
        u[u.length] = pr[d];
        continue;
      }
      if (d < 2048) {
        u[u.length] = pr[192 | d >> 6] + pr[128 | d & 63];
        continue;
      }
      if (d < 55296 || d >= 57344) {
        u[u.length] = pr[224 | d >> 12] + pr[128 | d >> 6 & 63] + pr[128 | d & 63];
        continue;
      }
      l += 1, d = 65536 + ((d & 1023) << 10 | c.charCodeAt(l) & 1023), u[u.length] = pr[240 | d >> 18] + pr[128 | d >> 12 & 63] + pr[128 | d >> 6 & 63] + pr[128 | d & 63];
    }
    i += u.join("");
  }
  return i;
};
function qy(r) {
  return !r || typeof r != "object" ? !1 : !!(r.constructor && r.constructor.isBuffer && r.constructor.isBuffer(r));
}
function td(r, e) {
  if (Rt(r)) {
    const t = [];
    for (let n = 0; n < r.length; n += 1)
      t.push(e(r[n]));
    return t;
  }
  return e(r);
}
const qf = {
  brackets(r) {
    return String(r) + "[]";
  },
  comma: "comma",
  indices(r, e) {
    return String(r) + "[" + e + "]";
  },
  repeat(r) {
    return String(r);
  }
}, Jf = function(r, e) {
  Array.prototype.push.apply(r, Rt(e) ? e : [e]);
};
let rd;
const ot = {
  addQueryPrefix: !1,
  allowDots: !1,
  allowEmptyArrays: !1,
  arrayFormat: "indices",
  charset: "utf-8",
  charsetSentinel: !1,
  delimiter: "&",
  encode: !0,
  encodeDotInKeys: !1,
  encoder: Vy,
  encodeValuesOnly: !1,
  format: Zf,
  formatter: Vf,
  /** @deprecated */
  indices: !1,
  serializeDate(r) {
    return (rd ?? (rd = Function.prototype.call.bind(Date.prototype.toISOString)))(r);
  },
  skipNulls: !1,
  strictNullHandling: !1
};
function Jy(r) {
  return typeof r == "string" || typeof r == "number" || typeof r == "boolean" || typeof r == "symbol" || typeof r == "bigint";
}
const Uo = {};
function Hf(r, e, t, n, s, a, i, o, c, u, l, d, h, f, p, y, m, v) {
  let g = r, w = v, T = 0, x = !1;
  for (; (w = w.get(Uo)) !== void 0 && !x; ) {
    const ne = w.get(r);
    if (T += 1, typeof ne < "u") {
      if (ne === T)
        throw new RangeError("Cyclic object value");
      x = !0;
    }
    typeof w.get(Uo) > "u" && (T = 0);
  }
  if (typeof u == "function" ? g = u(e, g) : g instanceof Date ? g = h == null ? void 0 : h(g) : t === "comma" && Rt(g) && (g = td(g, function(ne) {
    return ne instanceof Date ? h == null ? void 0 : h(ne) : ne;
  })), g === null) {
    if (a)
      return c && !y ? (
        // @ts-expect-error
        c(e, ot.encoder, m, "key", f)
      ) : e;
    g = "";
  }
  if (Jy(g) || qy(g)) {
    if (c) {
      const ne = y ? e : c(e, ot.encoder, m, "key", f);
      return [
        (p == null ? void 0 : p(ne)) + "=" + // @ts-expect-error
        (p == null ? void 0 : p(c(g, ot.encoder, m, "value", f)))
      ];
    }
    return [(p == null ? void 0 : p(e)) + "=" + (p == null ? void 0 : p(String(g)))];
  }
  const O = [];
  if (typeof g > "u")
    return O;
  let R;
  if (t === "comma" && Rt(g))
    y && c && (g = td(g, c)), R = [{ value: g.length > 0 ? g.join(",") || null : void 0 }];
  else if (Rt(u))
    R = u;
  else {
    const ne = Object.keys(g);
    R = l ? ne.sort(l) : ne;
  }
  const E = o ? String(e).replace(/\./g, "%2E") : String(e), V = n && Rt(g) && g.length === 1 ? E + "[]" : E;
  if (s && Rt(g) && g.length === 0)
    return V + "[]";
  for (let ne = 0; ne < R.length; ++ne) {
    const z = R[ne], Te = (
      // @ts-ignore
      typeof z == "object" && typeof z.value < "u" ? z.value : g[z]
    );
    if (i && Te === null)
      continue;
    const Oe = d && o ? z.replace(/\./g, "%2E") : z, Z = Rt(g) ? typeof t == "function" ? t(V, Oe) : V : V + (d ? "." + Oe : "[" + Oe + "]");
    v.set(r, T);
    const D = /* @__PURE__ */ new WeakMap();
    D.set(Uo, v), Jf(O, Hf(
      Te,
      Z,
      t,
      n,
      s,
      a,
      i,
      o,
      // @ts-ignore
      t === "comma" && y && Rt(g) ? null : c,
      u,
      l,
      d,
      h,
      f,
      p,
      y,
      m,
      D
    ));
  }
  return O;
}
function Hy(r = ot) {
  if (typeof r.allowEmptyArrays < "u" && typeof r.allowEmptyArrays != "boolean")
    throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
  if (typeof r.encodeDotInKeys < "u" && typeof r.encodeDotInKeys != "boolean")
    throw new TypeError("`encodeDotInKeys` option can only be `true` or `false`, when provided");
  if (r.encoder !== null && typeof r.encoder < "u" && typeof r.encoder != "function")
    throw new TypeError("Encoder has to be a function.");
  const e = r.charset || ot.charset;
  if (typeof r.charset < "u" && r.charset !== "utf-8" && r.charset !== "iso-8859-1")
    throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
  let t = Zf;
  if (typeof r.format < "u") {
    if (!Sc(ed, r.format))
      throw new TypeError("Unknown format option provided.");
    t = r.format;
  }
  const n = ed[t];
  let s = ot.filter;
  (typeof r.filter == "function" || Rt(r.filter)) && (s = r.filter);
  let a;
  if (r.arrayFormat && r.arrayFormat in qf ? a = r.arrayFormat : "indices" in r ? a = r.indices ? "indices" : "repeat" : a = ot.arrayFormat, "commaRoundTrip" in r && typeof r.commaRoundTrip != "boolean")
    throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
  const i = typeof r.allowDots > "u" ? r.encodeDotInKeys ? !0 : ot.allowDots : !!r.allowDots;
  return {
    addQueryPrefix: typeof r.addQueryPrefix == "boolean" ? r.addQueryPrefix : ot.addQueryPrefix,
    // @ts-ignore
    allowDots: i,
    allowEmptyArrays: typeof r.allowEmptyArrays == "boolean" ? !!r.allowEmptyArrays : ot.allowEmptyArrays,
    arrayFormat: a,
    charset: e,
    charsetSentinel: typeof r.charsetSentinel == "boolean" ? r.charsetSentinel : ot.charsetSentinel,
    commaRoundTrip: !!r.commaRoundTrip,
    delimiter: typeof r.delimiter > "u" ? ot.delimiter : r.delimiter,
    encode: typeof r.encode == "boolean" ? r.encode : ot.encode,
    encodeDotInKeys: typeof r.encodeDotInKeys == "boolean" ? r.encodeDotInKeys : ot.encodeDotInKeys,
    encoder: typeof r.encoder == "function" ? r.encoder : ot.encoder,
    encodeValuesOnly: typeof r.encodeValuesOnly == "boolean" ? r.encodeValuesOnly : ot.encodeValuesOnly,
    filter: s,
    format: t,
    formatter: n,
    serializeDate: typeof r.serializeDate == "function" ? r.serializeDate : ot.serializeDate,
    skipNulls: typeof r.skipNulls == "boolean" ? r.skipNulls : ot.skipNulls,
    // @ts-ignore
    sort: typeof r.sort == "function" ? r.sort : null,
    strictNullHandling: typeof r.strictNullHandling == "boolean" ? r.strictNullHandling : ot.strictNullHandling
  };
}
function Gy(r, e = {}) {
  let t = r;
  const n = Hy(e);
  let s, a;
  typeof n.filter == "function" ? (a = n.filter, t = a("", t)) : Rt(n.filter) && (a = n.filter, s = a);
  const i = [];
  if (typeof t != "object" || t === null)
    return "";
  const o = qf[n.arrayFormat], c = o === "comma" && n.commaRoundTrip;
  s || (s = Object.keys(t)), n.sort && s.sort(n.sort);
  const u = /* @__PURE__ */ new WeakMap();
  for (let h = 0; h < s.length; ++h) {
    const f = s[h];
    n.skipNulls && t[f] === null || Jf(i, Hf(
      t[f],
      f,
      // @ts-expect-error
      o,
      c,
      n.allowEmptyArrays,
      n.strictNullHandling,
      n.skipNulls,
      n.encodeDotInKeys,
      n.encode ? n.encoder : null,
      n.filter,
      n.sort,
      n.allowDots,
      n.serializeDate,
      n.format,
      n.formatter,
      n.encodeValuesOnly,
      n.charset,
      u
    ));
  }
  const l = i.join(n.delimiter);
  let d = n.addQueryPrefix === !0 ? "?" : "";
  return n.charsetSentinel && (n.charset === "iso-8859-1" ? d += "utf8=%26%2310003%3B&" : d += "utf8=%E2%9C%93&"), l.length > 0 ? d + l : "";
}
function Wy(r) {
  let e = 0;
  for (const s of r)
    e += s.length;
  const t = new Uint8Array(e);
  let n = 0;
  for (const s of r)
    t.set(s, n), n += s.length;
  return t;
}
let nd;
function ku(r) {
  let e;
  return (nd ?? (e = new globalThis.TextEncoder(), nd = e.encode.bind(e)))(r);
}
let sd;
function ad(r) {
  let e;
  return (sd ?? (e = new globalThis.TextDecoder(), sd = e.decode.bind(e)))(r);
}
var Mt, Dt;
class Yi {
  constructor() {
    Mt.set(this, void 0), Dt.set(this, void 0), fe(this, Mt, new Uint8Array()), fe(this, Dt, null);
  }
  decode(e) {
    if (e == null)
      return [];
    const t = e instanceof ArrayBuffer ? new Uint8Array(e) : typeof e == "string" ? ku(e) : e;
    fe(this, Mt, Wy([I(this, Mt, "f"), t]));
    const n = [];
    let s;
    for (; (s = Ky(I(this, Mt, "f"), I(this, Dt, "f"))) != null; ) {
      if (s.carriage && I(this, Dt, "f") == null) {
        fe(this, Dt, s.index);
        continue;
      }
      if (I(this, Dt, "f") != null && (s.index !== I(this, Dt, "f") + 1 || s.carriage)) {
        n.push(ad(I(this, Mt, "f").subarray(0, I(this, Dt, "f") - 1))), fe(this, Mt, I(this, Mt, "f").subarray(I(this, Dt, "f"))), fe(this, Dt, null);
        continue;
      }
      const a = I(this, Dt, "f") !== null ? s.preceding - 1 : s.preceding, i = ad(I(this, Mt, "f").subarray(0, a));
      n.push(i), fe(this, Mt, I(this, Mt, "f").subarray(s.index)), fe(this, Dt, null);
    }
    return n;
  }
  flush() {
    return I(this, Mt, "f").length ? this.decode(`
`) : [];
  }
}
Mt = /* @__PURE__ */ new WeakMap(), Dt = /* @__PURE__ */ new WeakMap();
Yi.NEWLINE_CHARS = /* @__PURE__ */ new Set([`
`, "\r"]);
Yi.NEWLINE_REGEXP = /\r\n|[\n\r]/g;
function Ky(r, e) {
  for (let s = e ?? 0; s < r.length; s++) {
    if (r[s] === 10)
      return { preceding: s, index: s + 1, carriage: !1 };
    if (r[s] === 13)
      return { preceding: s, index: s + 1, carriage: !0 };
  }
  return null;
}
function Yy(r) {
  for (let n = 0; n < r.length - 1; n++) {
    if (r[n] === 10 && r[n + 1] === 10 || r[n] === 13 && r[n + 1] === 13)
      return n + 2;
    if (r[n] === 13 && r[n + 1] === 10 && n + 3 < r.length && r[n + 2] === 13 && r[n + 3] === 10)
      return n + 4;
  }
  return -1;
}
const hi = {
  off: 0,
  error: 200,
  warn: 300,
  info: 400,
  debug: 500
}, id = (r, e, t) => {
  if (r) {
    if (Ry(hi, r))
      return r;
    wt(t).warn(`${e} was set to ${JSON.stringify(r)}, expected one of ${JSON.stringify(Object.keys(hi))}`);
  }
};
function ys() {
}
function Ta(r, e, t) {
  return !e || hi[r] > hi[t] ? ys : e[r].bind(e);
}
const Xy = {
  error: ys,
  warn: ys,
  info: ys,
  debug: ys
};
let od = /* @__PURE__ */ new WeakMap();
function wt(r) {
  const e = r.logger, t = r.logLevel ?? "off";
  if (!e)
    return Xy;
  const n = od.get(e);
  if (n && n[0] === t)
    return n[1];
  const s = {
    error: Ta("error", e, t),
    warn: Ta("warn", e, t),
    info: Ta("info", e, t),
    debug: Ta("debug", e, t)
  };
  return od.set(e, [t, s]), s;
}
const pn = (r) => (r.options && (r.options = { ...r.options }, delete r.options.headers), r.headers && (r.headers = Object.fromEntries((r.headers instanceof Headers ? [...r.headers] : Object.entries(r.headers)).map(([e, t]) => [
  e,
  e.toLowerCase() === "authorization" || e.toLowerCase() === "cookie" || e.toLowerCase() === "set-cookie" ? "***" : t
]))), "retryOfRequestLogID" in r && (r.retryOfRequestLogID && (r.retryOf = r.retryOfRequestLogID), delete r.retryOfRequestLogID), r);
var ps;
class vr {
  constructor(e, t, n) {
    this.iterator = e, ps.set(this, void 0), this.controller = t, fe(this, ps, n);
  }
  static fromSSEResponse(e, t, n) {
    let s = !1;
    const a = n ? wt(n) : console;
    async function* i() {
      if (s)
        throw new ce("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
      s = !0;
      let o = !1;
      try {
        for await (const c of Qy(e, t))
          if (!o) {
            if (c.data.startsWith("[DONE]")) {
              o = !0;
              continue;
            }
            if (c.event === null || !c.event.startsWith("thread.")) {
              let u;
              try {
                u = JSON.parse(c.data);
              } catch (l) {
                throw a.error("Could not parse message into JSON:", c.data), a.error("From chunk:", c.raw), l;
              }
              if (u && u.error)
                throw new St(void 0, u.error, void 0, e.headers);
              yield u;
            } else {
              let u;
              try {
                u = JSON.parse(c.data);
              } catch (l) {
                throw console.error("Could not parse message into JSON:", c.data), console.error("From chunk:", c.raw), l;
              }
              if (c.event == "error")
                throw new St(void 0, u.error, u.message, void 0);
              yield { event: c.event, data: u };
            }
          }
        o = !0;
      } catch (c) {
        if (vc(c))
          return;
        throw c;
      } finally {
        o || t.abort();
      }
    }
    return new vr(i, t, n);
  }
  /**
   * Generates a Stream from a newline-separated ReadableStream
   * where each item is a JSON value.
   */
  static fromReadableStream(e, t, n) {
    let s = !1;
    async function* a() {
      const o = new Yi(), c = Bf(e);
      for await (const u of c)
        for (const l of o.decode(u))
          yield l;
      for (const u of o.flush())
        yield u;
    }
    async function* i() {
      if (s)
        throw new ce("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
      s = !0;
      let o = !1;
      try {
        for await (const c of a())
          o || c && (yield JSON.parse(c));
        o = !0;
      } catch (c) {
        if (vc(c))
          return;
        throw c;
      } finally {
        o || t.abort();
      }
    }
    return new vr(i, t, n);
  }
  [(ps = /* @__PURE__ */ new WeakMap(), Symbol.asyncIterator)]() {
    return this.iterator();
  }
  /**
   * Splits the stream into two streams which can be
   * independently read from at different speeds.
   */
  tee() {
    const e = [], t = [], n = this.iterator(), s = (a) => ({
      next: () => {
        if (a.length === 0) {
          const i = n.next();
          e.push(i), t.push(i);
        }
        return a.shift();
      }
    });
    return [
      new vr(() => s(e), this.controller, I(this, ps, "f")),
      new vr(() => s(t), this.controller, I(this, ps, "f"))
    ];
  }
  /**
   * Converts this stream to a newline-separated ReadableStream of
   * JSON stringified values in the stream
   * which can be turned back into a Stream with `Stream.fromReadableStream()`.
   */
  toReadableStream() {
    const e = this;
    let t;
    return Uf({
      async start() {
        t = e[Symbol.asyncIterator]();
      },
      async pull(n) {
        try {
          const { value: s, done: a } = await t.next();
          if (a)
            return n.close();
          const i = ku(JSON.stringify(s) + `
`);
          n.enqueue(i);
        } catch (s) {
          n.error(s);
        }
      },
      async cancel() {
        var n;
        await ((n = t.return) == null ? void 0 : n.call(t));
      }
    });
  }
}
async function* Qy(r, e) {
  if (!r.body)
    throw e.abort(), typeof globalThis.navigator < "u" && globalThis.navigator.product === "ReactNative" ? new ce("The default react-native fetch implementation does not support streaming. Please use expo/fetch: https://docs.expo.dev/versions/latest/sdk/expo/#expofetch-api") : new ce("Attempted to iterate over a response with no body");
  const t = new tw(), n = new Yi(), s = Bf(r.body);
  for await (const a of ew(s))
    for (const i of n.decode(a)) {
      const o = t.decode(i);
      o && (yield o);
    }
  for (const a of n.flush()) {
    const i = t.decode(a);
    i && (yield i);
  }
}
async function* ew(r) {
  let e = new Uint8Array();
  for await (const t of r) {
    if (t == null)
      continue;
    const n = t instanceof ArrayBuffer ? new Uint8Array(t) : typeof t == "string" ? ku(t) : t;
    let s = new Uint8Array(e.length + n.length);
    s.set(e), s.set(n, e.length), e = s;
    let a;
    for (; (a = Yy(e)) !== -1; )
      yield e.slice(0, a), e = e.slice(a);
  }
  e.length > 0 && (yield e);
}
class tw {
  constructor() {
    this.event = null, this.data = [], this.chunks = [];
  }
  decode(e) {
    if (e.endsWith("\r") && (e = e.substring(0, e.length - 1)), !e) {
      if (!this.event && !this.data.length)
        return null;
      const a = {
        event: this.event,
        data: this.data.join(`
`),
        raw: this.chunks
      };
      return this.event = null, this.data = [], this.chunks = [], a;
    }
    if (this.chunks.push(e), e.startsWith(":"))
      return null;
    let [t, n, s] = rw(e, ":");
    return s.startsWith(" ") && (s = s.substring(1)), t === "event" ? this.event = s : t === "data" && this.data.push(s), null;
  }
}
function rw(r, e) {
  const t = r.indexOf(e);
  return t !== -1 ? [r.substring(0, t), e, r.substring(t + e.length)] : [r, "", ""];
}
async function Gf(r, e) {
  const { response: t, requestLogID: n, retryOfRequestLogID: s, startTime: a } = e, i = await (async () => {
    var d;
    if (e.options.stream)
      return wt(r).debug("response", t.status, t.url, t.headers, t.body), e.options.__streamClass ? e.options.__streamClass.fromSSEResponse(t, e.controller, r) : vr.fromSSEResponse(t, e.controller, r);
    if (t.status === 204)
      return null;
    if (e.options.__binaryResponse)
      return t;
    const o = t.headers.get("content-type"), c = (d = o == null ? void 0 : o.split(";")[0]) == null ? void 0 : d.trim();
    if ((c == null ? void 0 : c.includes("application/json")) || (c == null ? void 0 : c.endsWith("+json"))) {
      const h = await t.json();
      return Wf(h, t);
    }
    return await t.text();
  })();
  return wt(r).debug(`[${n}] response parsed`, pn({
    retryOfRequestLogID: s,
    url: t.url,
    status: t.status,
    body: i,
    durationMs: Date.now() - a
  })), i;
}
function Wf(r, e) {
  return !r || typeof r != "object" || Array.isArray(r) ? r : Object.defineProperty(r, "_request_id", {
    value: e.headers.get("x-request-id"),
    enumerable: !1
  });
}
var ws;
class Xi extends Promise {
  constructor(e, t, n = Gf) {
    super((s) => {
      s(null);
    }), this.responsePromise = t, this.parseResponse = n, ws.set(this, void 0), fe(this, ws, e);
  }
  _thenUnwrap(e) {
    return new Xi(I(this, ws, "f"), this.responsePromise, async (t, n) => Wf(e(await this.parseResponse(t, n), n), n.response));
  }
  /**
   * Gets the raw `Response` instance instead of parsing the response
   * data.
   *
   * If you want to parse the response body but still get the `Response`
   * instance, you can use {@link withResponse()}.
   *
   * ðŸ‘‹ Getting the wrong TypeScript type for `Response`?
   * Try setting `"moduleResolution": "NodeNext"` or add `"lib": ["DOM"]`
   * to your `tsconfig.json`.
   */
  asResponse() {
    return this.responsePromise.then((e) => e.response);
  }
  /**
   * Gets the parsed response data, the raw `Response` instance and the ID of the request,
   * returned via the X-Request-ID header which is useful for debugging requests and reporting
   * issues to OpenAI.
   *
   * If you just want to get the raw `Response` instance without parsing it,
   * you can use {@link asResponse()}.
   *
   * ðŸ‘‹ Getting the wrong TypeScript type for `Response`?
   * Try setting `"moduleResolution": "NodeNext"` or add `"lib": ["DOM"]`
   * to your `tsconfig.json`.
   */
  async withResponse() {
    const [e, t] = await Promise.all([this.parse(), this.asResponse()]);
    return { data: e, response: t, request_id: t.headers.get("x-request-id") };
  }
  parse() {
    return this.parsedPromise || (this.parsedPromise = this.responsePromise.then((e) => this.parseResponse(I(this, ws, "f"), e))), this.parsedPromise;
  }
  then(e, t) {
    return this.parse().then(e, t);
  }
  catch(e) {
    return this.parse().catch(e);
  }
  finally(e) {
    return this.parse().finally(e);
  }
}
ws = /* @__PURE__ */ new WeakMap();
var Ea;
class Iu {
  constructor(e, t, n, s) {
    Ea.set(this, void 0), fe(this, Ea, e), this.options = s, this.response = t, this.body = n;
  }
  hasNextPage() {
    return this.getPaginatedItems().length ? this.nextPageRequestOptions() != null : !1;
  }
  async getNextPage() {
    const e = this.nextPageRequestOptions();
    if (!e)
      throw new ce("No next page expected; please check `.hasNextPage()` before calling `.getNextPage()`.");
    return await I(this, Ea, "f").requestAPIList(this.constructor, e);
  }
  async *iterPages() {
    let e = this;
    for (yield e; e.hasNextPage(); )
      e = await e.getNextPage(), yield e;
  }
  async *[(Ea = /* @__PURE__ */ new WeakMap(), Symbol.asyncIterator)]() {
    for await (const e of this.iterPages())
      for (const t of e.getPaginatedItems())
        yield t;
  }
}
class nw extends Xi {
  constructor(e, t, n) {
    super(e, t, async (s, a) => new n(s, a.response, await Gf(s, a), a.options));
  }
  /**
   * Allow auto-paginating iteration on an unawaited list call, eg:
   *
   *    for await (const item of client.items.list()) {
   *      console.log(item)
   *    }
   */
  async *[Symbol.asyncIterator]() {
    const e = await this;
    for await (const t of e)
      yield t;
  }
}
class Qi extends Iu {
  constructor(e, t, n, s) {
    super(e, t, n, s), this.data = n.data || [], this.object = n.object;
  }
  getPaginatedItems() {
    return this.data ?? [];
  }
  nextPageRequestOptions() {
    return null;
  }
}
class nt extends Iu {
  constructor(e, t, n, s) {
    super(e, t, n, s), this.data = n.data || [], this.has_more = n.has_more || !1;
  }
  getPaginatedItems() {
    return this.data ?? [];
  }
  hasNextPage() {
    return this.has_more === !1 ? !1 : super.hasNextPage();
  }
  nextPageRequestOptions() {
    var n;
    const e = this.getPaginatedItems(), t = (n = e[e.length - 1]) == null ? void 0 : n.id;
    return t ? {
      ...this.options,
      query: {
        ...Ff(this.options.query),
        after: t
      }
    } : null;
  }
}
class fi extends Iu {
  constructor(e, t, n, s) {
    super(e, t, n, s), this.data = n.data || [], this.has_more = n.has_more || !1, this.last_id = n.last_id || "";
  }
  getPaginatedItems() {
    return this.data ?? [];
  }
  hasNextPage() {
    return this.has_more === !1 ? !1 : super.hasNextPage();
  }
  nextPageRequestOptions() {
    const e = this.last_id;
    return e ? {
      ...this.options,
      query: {
        ...Ff(this.options.query),
        after: e
      }
    } : null;
  }
}
const Kf = () => {
  var r;
  if (typeof File > "u") {
    const { process: e } = globalThis, t = typeof ((r = e == null ? void 0 : e.versions) == null ? void 0 : r.node) == "string" && parseInt(e.versions.node.split(".")) < 20;
    throw new Error("`File` is not defined as a global, which is required for file uploads." + (t ? " Update to Node 20 LTS or newer, or set `globalThis.File` to `import('node:buffer').File`." : ""));
  }
};
function Ls(r, e, t) {
  return Kf(), new File(r, e ?? "unknown_file", t);
}
function Ya(r) {
  return (typeof r == "object" && r !== null && ("name" in r && r.name && String(r.name) || "url" in r && r.url && String(r.url) || "filename" in r && r.filename && String(r.filename) || "path" in r && r.path && String(r.path)) || "").split(/[\\/]/).pop() || void 0;
}
const Ou = (r) => r != null && typeof r == "object" && typeof r[Symbol.asyncIterator] == "function", cd = async (r, e) => Tc(r.body) ? { ...r, body: await Yf(r.body, e) } : r, xn = async (r, e) => ({ ...r, body: await Yf(r.body, e) }), ud = /* @__PURE__ */ new WeakMap();
function sw(r) {
  const e = typeof r == "function" ? r : r.fetch, t = ud.get(e);
  if (t)
    return t;
  const n = (async () => {
    try {
      const s = "Response" in e ? e.Response : (await e("data:,")).constructor, a = new FormData();
      return a.toString() !== await new s(a).text();
    } catch {
      return !0;
    }
  })();
  return ud.set(e, n), n;
}
const Yf = async (r, e) => {
  if (!await sw(e))
    throw new TypeError("The provided fetch function does not support file uploads with the current global FormData class.");
  const t = new FormData();
  return await Promise.all(Object.entries(r || {}).map(([n, s]) => Ec(t, n, s))), t;
}, Xf = (r) => r instanceof Blob && "name" in r, aw = (r) => typeof r == "object" && r !== null && (r instanceof Response || Ou(r) || Xf(r)), Tc = (r) => {
  if (aw(r))
    return !0;
  if (Array.isArray(r))
    return r.some(Tc);
  if (r && typeof r == "object") {
    for (const e in r)
      if (Tc(r[e]))
        return !0;
  }
  return !1;
}, Ec = async (r, e, t) => {
  if (t !== void 0) {
    if (t == null)
      throw new TypeError(`Received null for "${e}"; to pass null in FormData, you must use the string 'null'`);
    if (typeof t == "string" || typeof t == "number" || typeof t == "boolean")
      r.append(e, String(t));
    else if (t instanceof Response)
      r.append(e, Ls([await t.blob()], Ya(t)));
    else if (Ou(t))
      r.append(e, Ls([await new Response(zf(t)).blob()], Ya(t)));
    else if (Xf(t))
      r.append(e, t, Ya(t));
    else if (Array.isArray(t))
      await Promise.all(t.map((n) => Ec(r, e + "[]", n)));
    else if (typeof t == "object")
      await Promise.all(Object.entries(t).map(([n, s]) => Ec(r, `${e}[${n}]`, s)));
    else
      throw new TypeError(`Invalid value given to form, expected a string, number, boolean, object, Array, File or Blob but got ${t} instead`);
  }
}, Qf = (r) => r != null && typeof r == "object" && typeof r.size == "number" && typeof r.type == "string" && typeof r.text == "function" && typeof r.slice == "function" && typeof r.arrayBuffer == "function", iw = (r) => r != null && typeof r == "object" && typeof r.name == "string" && typeof r.lastModified == "number" && Qf(r), ow = (r) => r != null && typeof r == "object" && typeof r.url == "string" && typeof r.blob == "function";
async function cw(r, e, t) {
  if (Kf(), r = await r, iw(r))
    return r instanceof File ? r : Ls([await r.arrayBuffer()], r.name);
  if (ow(r)) {
    const s = await r.blob();
    return e || (e = new URL(r.url).pathname.split(/[\\/]/).pop()), Ls(await xc(s), e, t);
  }
  const n = await xc(r);
  if (e || (e = Ya(r)), !(t != null && t.type)) {
    const s = n.find((a) => typeof a == "object" && "type" in a && a.type);
    typeof s == "string" && (t = { ...t, type: s });
  }
  return Ls(n, e, t);
}
async function xc(r) {
  var t;
  let e = [];
  if (typeof r == "string" || ArrayBuffer.isView(r) || // includes Uint8Array, Buffer, etc.
  r instanceof ArrayBuffer)
    e.push(r);
  else if (Qf(r))
    e.push(r instanceof Blob ? r : await r.arrayBuffer());
  else if (Ou(r))
    for await (const n of r)
      e.push(...await xc(n));
  else {
    const n = (t = r == null ? void 0 : r.constructor) == null ? void 0 : t.name;
    throw new Error(`Unexpected data type: ${typeof r}${n ? `; constructor: ${n}` : ""}${uw(r)}`);
  }
  return e;
}
function uw(r) {
  return typeof r != "object" || r === null ? "" : `; props: [${Object.getOwnPropertyNames(r).map((t) => `"${t}"`).join(", ")}]`;
}
class ie {
  constructor(e) {
    this._client = e;
  }
}
function ep(r) {
  return r.replace(/[^A-Za-z0-9\-._~!$&'()*+,;=:@]+/g, encodeURIComponent);
}
const ld = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.create(null)), lw = (r = ep) => function(t, ...n) {
  if (t.length === 1)
    return t[0];
  let s = !1;
  const a = [], i = t.reduce((l, d, h) => {
    var y;
    /[?#]/.test(d) && (s = !0);
    const f = n[h];
    let p = (s ? encodeURIComponent : r)("" + f);
    return h !== n.length && (f == null || typeof f == "object" && // handle values from other realms
    f.toString === ((y = Object.getPrototypeOf(Object.getPrototypeOf(f.hasOwnProperty ?? ld) ?? ld)) == null ? void 0 : y.toString)) && (p = f + "", a.push({
      start: l.length + d.length,
      length: p.length,
      error: `Value of type ${Object.prototype.toString.call(f).slice(8, -1)} is not a valid path parameter`
    })), l + d + (h === n.length ? "" : p);
  }, ""), o = i.split(/[?#]/, 1)[0], c = new RegExp("(?<=^|\\/)(?:\\.|%2e){1,2}(?=\\/|$)", "gi");
  let u;
  for (; (u = c.exec(o)) !== null; )
    a.push({
      start: u.index,
      length: u[0].length,
      error: `Value "${u[0]}" can't be safely passed as a path parameter`
    });
  if (a.sort((l, d) => l.start - d.start), a.length > 0) {
    let l = 0;
    const d = a.reduce((h, f) => {
      const p = " ".repeat(f.start - l), y = "^".repeat(f.length);
      return l = f.start + f.length, h + p + y;
    }, "");
    throw new ce(`Path parameters result in path with invalid segments:
${a.map((h) => h.error).join(`
`)}
${i}
${d}`);
  }
  return i;
}, F = /* @__PURE__ */ lw(ep);
let tp = class extends ie {
  /**
   * Get the messages in a stored chat completion. Only Chat Completions that have
   * been created with the `store` parameter set to `true` will be returned.
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const chatCompletionStoreMessage of client.chat.completions.messages.list(
   *   'completion_id',
   * )) {
   *   // ...
   * }
   * ```
   */
  list(e, t = {}, n) {
    return this._client.getAPIList(F`/chat/completions/${e}/messages`, nt, { query: t, ...n });
  }
};
function pi(r) {
  return r !== void 0 && "function" in r && r.function !== void 0;
}
function dw(r, e) {
  const t = { ...r };
  return Object.defineProperties(t, {
    $brand: {
      value: "auto-parseable-response-format",
      enumerable: !1
    },
    $parseRaw: {
      value: e,
      enumerable: !1
    }
  }), t;
}
function Au(r) {
  return (r == null ? void 0 : r.$brand) === "auto-parseable-response-format";
}
function sa(r) {
  return (r == null ? void 0 : r.$brand) === "auto-parseable-tool";
}
function hw(r, e) {
  return !e || !rp(e) ? {
    ...r,
    choices: r.choices.map((t) => (np(t.message.tool_calls), {
      ...t,
      message: {
        ...t.message,
        parsed: null,
        ...t.message.tool_calls ? {
          tool_calls: t.message.tool_calls
        } : void 0
      }
    }))
  } : $u(r, e);
}
function $u(r, e) {
  const t = r.choices.map((n) => {
    var s;
    if (n.finish_reason === "length")
      throw new Df();
    if (n.finish_reason === "content_filter")
      throw new jf();
    return np(n.message.tool_calls), {
      ...n,
      message: {
        ...n.message,
        ...n.message.tool_calls ? {
          tool_calls: ((s = n.message.tool_calls) == null ? void 0 : s.map((a) => pw(e, a))) ?? void 0
        } : void 0,
        parsed: n.message.content && !n.message.refusal ? fw(e, n.message.content) : null
      }
    };
  });
  return { ...r, choices: t };
}
function fw(r, e) {
  var t, n;
  return ((t = r.response_format) == null ? void 0 : t.type) !== "json_schema" ? null : ((n = r.response_format) == null ? void 0 : n.type) === "json_schema" ? "$parseRaw" in r.response_format ? r.response_format.$parseRaw(e) : JSON.parse(e) : null;
}
function pw(r, e) {
  var n;
  const t = (n = r.tools) == null ? void 0 : n.find((s) => {
    var a;
    return pi(s) && ((a = s.function) == null ? void 0 : a.name) === e.function.name;
  });
  return {
    ...e,
    function: {
      ...e.function,
      parsed_arguments: sa(t) ? t.$parseRaw(e.function.arguments) : t != null && t.function.strict ? JSON.parse(e.function.arguments) : null
    }
  };
}
function mw(r, e) {
  var n;
  if (!r || !("tools" in r) || !r.tools)
    return !1;
  const t = (n = r.tools) == null ? void 0 : n.find((s) => {
    var a;
    return pi(s) && ((a = s.function) == null ? void 0 : a.name) === e.function.name;
  });
  return pi(t) && (sa(t) || (t == null ? void 0 : t.function.strict) || !1);
}
function rp(r) {
  var e;
  return Au(r.response_format) ? !0 : ((e = r.tools) == null ? void 0 : e.some((t) => sa(t) || t.type === "function" && t.function.strict === !0)) ?? !1;
}
function np(r) {
  for (const e of r || [])
    if (e.type !== "function")
      throw new ce(`Currently only \`function\` tool calls are supported; Received \`${e.type}\``);
}
function gw(r) {
  for (const e of r ?? []) {
    if (e.type !== "function")
      throw new ce(`Currently only \`function\` tool types support auto-parsing; Received \`${e.type}\``);
    if (e.function.strict !== !0)
      throw new ce(`The \`${e.function.name}\` tool is not marked with \`strict: true\`. Only strict function tools can be auto-parsed`);
  }
}
const mi = (r) => (r == null ? void 0 : r.role) === "assistant", sp = (r) => (r == null ? void 0 : r.role) === "tool";
var kc, Xa, Qa, vs, bs, ei, Ss, Rr, Ts, gi, _i, jn, ap;
class Cu {
  constructor() {
    kc.add(this), this.controller = new AbortController(), Xa.set(this, void 0), Qa.set(this, () => {
    }), vs.set(this, () => {
    }), bs.set(this, void 0), ei.set(this, () => {
    }), Ss.set(this, () => {
    }), Rr.set(this, {}), Ts.set(this, !1), gi.set(this, !1), _i.set(this, !1), jn.set(this, !1), fe(this, Xa, new Promise((e, t) => {
      fe(this, Qa, e, "f"), fe(this, vs, t, "f");
    })), fe(this, bs, new Promise((e, t) => {
      fe(this, ei, e, "f"), fe(this, Ss, t, "f");
    })), I(this, Xa, "f").catch(() => {
    }), I(this, bs, "f").catch(() => {
    });
  }
  _run(e) {
    setTimeout(() => {
      e().then(() => {
        this._emitFinal(), this._emit("end");
      }, I(this, kc, "m", ap).bind(this));
    }, 0);
  }
  _connected() {
    this.ended || (I(this, Qa, "f").call(this), this._emit("connect"));
  }
  get ended() {
    return I(this, Ts, "f");
  }
  get errored() {
    return I(this, gi, "f");
  }
  get aborted() {
    return I(this, _i, "f");
  }
  abort() {
    this.controller.abort();
  }
  /**
   * Adds the listener function to the end of the listeners array for the event.
   * No checks are made to see if the listener has already been added. Multiple calls passing
   * the same combination of event and listener will result in the listener being added, and
   * called, multiple times.
   * @returns this ChatCompletionStream, so that calls can be chained
   */
  on(e, t) {
    return (I(this, Rr, "f")[e] || (I(this, Rr, "f")[e] = [])).push({ listener: t }), this;
  }
  /**
   * Removes the specified listener from the listener array for the event.
   * off() will remove, at most, one instance of a listener from the listener array. If any single
   * listener has been added multiple times to the listener array for the specified event, then
   * off() must be called multiple times to remove each instance.
   * @returns this ChatCompletionStream, so that calls can be chained
   */
  off(e, t) {
    const n = I(this, Rr, "f")[e];
    if (!n)
      return this;
    const s = n.findIndex((a) => a.listener === t);
    return s >= 0 && n.splice(s, 1), this;
  }
  /**
   * Adds a one-time listener function for the event. The next time the event is triggered,
   * this listener is removed and then invoked.
   * @returns this ChatCompletionStream, so that calls can be chained
   */
  once(e, t) {
    return (I(this, Rr, "f")[e] || (I(this, Rr, "f")[e] = [])).push({ listener: t, once: !0 }), this;
  }
  /**
   * This is similar to `.once()`, but returns a Promise that resolves the next time
   * the event is triggered, instead of calling a listener callback.
   * @returns a Promise that resolves the next time given event is triggered,
   * or rejects if an error is emitted.  (If you request the 'error' event,
   * returns a promise that resolves with the error).
   *
   * Example:
   *
   *   const message = await stream.emitted('message') // rejects if the stream errors
   */
  emitted(e) {
    return new Promise((t, n) => {
      fe(this, jn, !0), e !== "error" && this.once("error", n), this.once(e, t);
    });
  }
  async done() {
    fe(this, jn, !0), await I(this, bs, "f");
  }
  _emit(e, ...t) {
    if (I(this, Ts, "f"))
      return;
    e === "end" && (fe(this, Ts, !0), I(this, ei, "f").call(this));
    const n = I(this, Rr, "f")[e];
    if (n && (I(this, Rr, "f")[e] = n.filter((s) => !s.once), n.forEach(({ listener: s }) => s(...t))), e === "abort") {
      const s = t[0];
      !I(this, jn, "f") && !(n != null && n.length) && Promise.reject(s), I(this, vs, "f").call(this, s), I(this, Ss, "f").call(this, s), this._emit("end");
      return;
    }
    if (e === "error") {
      const s = t[0];
      !I(this, jn, "f") && !(n != null && n.length) && Promise.reject(s), I(this, vs, "f").call(this, s), I(this, Ss, "f").call(this, s), this._emit("end");
    }
  }
  _emitFinal() {
  }
}
Xa = /* @__PURE__ */ new WeakMap(), Qa = /* @__PURE__ */ new WeakMap(), vs = /* @__PURE__ */ new WeakMap(), bs = /* @__PURE__ */ new WeakMap(), ei = /* @__PURE__ */ new WeakMap(), Ss = /* @__PURE__ */ new WeakMap(), Rr = /* @__PURE__ */ new WeakMap(), Ts = /* @__PURE__ */ new WeakMap(), gi = /* @__PURE__ */ new WeakMap(), _i = /* @__PURE__ */ new WeakMap(), jn = /* @__PURE__ */ new WeakMap(), kc = /* @__PURE__ */ new WeakSet(), ap = function(e) {
  if (fe(this, gi, !0), e instanceof Error && e.name === "AbortError" && (e = new Ut()), e instanceof Ut)
    return fe(this, _i, !0), this._emit("abort", e);
  if (e instanceof ce)
    return this._emit("error", e);
  if (e instanceof Error) {
    const t = new ce(e.message);
    return t.cause = e, this._emit("error", t);
  }
  return this._emit("error", new ce(String(e)));
};
function _w(r) {
  return typeof r.parse == "function";
}
var It, Ic, yi, Oc, Ac, $c, ip, op;
const yw = 10;
class cp extends Cu {
  constructor() {
    super(...arguments), It.add(this), this._chatCompletions = [], this.messages = [];
  }
  _addChatCompletion(e) {
    var n;
    this._chatCompletions.push(e), this._emit("chatCompletion", e);
    const t = (n = e.choices[0]) == null ? void 0 : n.message;
    return t && this._addMessage(t), e;
  }
  _addMessage(e, t = !0) {
    if ("content" in e || (e.content = null), this.messages.push(e), t) {
      if (this._emit("message", e), sp(e) && e.content)
        this._emit("functionToolCallResult", e.content);
      else if (mi(e) && e.tool_calls)
        for (const n of e.tool_calls)
          n.type === "function" && this._emit("functionToolCall", n.function);
    }
  }
  /**
   * @returns a promise that resolves with the final ChatCompletion, or rejects
   * if an error occurred or the stream ended prematurely without producing a ChatCompletion.
   */
  async finalChatCompletion() {
    await this.done();
    const e = this._chatCompletions[this._chatCompletions.length - 1];
    if (!e)
      throw new ce("stream ended without producing a ChatCompletion");
    return e;
  }
  /**
   * @returns a promise that resolves with the content of the final ChatCompletionMessage, or rejects
   * if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.
   */
  async finalContent() {
    return await this.done(), I(this, It, "m", Ic).call(this);
  }
  /**
   * @returns a promise that resolves with the the final assistant ChatCompletionMessage response,
   * or rejects if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.
   */
  async finalMessage() {
    return await this.done(), I(this, It, "m", yi).call(this);
  }
  /**
   * @returns a promise that resolves with the content of the final FunctionCall, or rejects
   * if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.
   */
  async finalFunctionToolCall() {
    return await this.done(), I(this, It, "m", Oc).call(this);
  }
  async finalFunctionToolCallResult() {
    return await this.done(), I(this, It, "m", Ac).call(this);
  }
  async totalUsage() {
    return await this.done(), I(this, It, "m", $c).call(this);
  }
  allChatCompletions() {
    return [...this._chatCompletions];
  }
  _emitFinal() {
    const e = this._chatCompletions[this._chatCompletions.length - 1];
    e && this._emit("finalChatCompletion", e);
    const t = I(this, It, "m", yi).call(this);
    t && this._emit("finalMessage", t);
    const n = I(this, It, "m", Ic).call(this);
    n && this._emit("finalContent", n);
    const s = I(this, It, "m", Oc).call(this);
    s && this._emit("finalFunctionToolCall", s);
    const a = I(this, It, "m", Ac).call(this);
    a != null && this._emit("finalFunctionToolCallResult", a), this._chatCompletions.some((i) => i.usage) && this._emit("totalUsage", I(this, It, "m", $c).call(this));
  }
  async _createChatCompletion(e, t, n) {
    const s = n == null ? void 0 : n.signal;
    s && (s.aborted && this.controller.abort(), s.addEventListener("abort", () => this.controller.abort())), I(this, It, "m", ip).call(this, t);
    const a = await e.chat.completions.create({ ...t, stream: !1 }, { ...n, signal: this.controller.signal });
    return this._connected(), this._addChatCompletion($u(a, t));
  }
  async _runChatCompletion(e, t, n) {
    for (const s of t.messages)
      this._addMessage(s, !1);
    return await this._createChatCompletion(e, t, n);
  }
  async _runTools(e, t, n) {
    var f, p, y;
    const s = "tool", { tool_choice: a = "auto", stream: i, ...o } = t, c = typeof a != "string" && a.type === "function" && ((f = a == null ? void 0 : a.function) == null ? void 0 : f.name), { maxChatCompletions: u = yw } = n || {}, l = t.tools.map((m) => {
      if (sa(m)) {
        if (!m.$callback)
          throw new ce("Tool given to `.runTools()` that does not have an associated function");
        return {
          type: "function",
          function: {
            function: m.$callback,
            name: m.function.name,
            description: m.function.description || "",
            parameters: m.function.parameters,
            parse: m.$parseRaw,
            strict: !0
          }
        };
      }
      return m;
    }), d = {};
    for (const m of l)
      m.type === "function" && (d[m.function.name || m.function.function.name] = m.function);
    const h = "tools" in t ? l.map((m) => m.type === "function" ? {
      type: "function",
      function: {
        name: m.function.name || m.function.function.name,
        parameters: m.function.parameters,
        description: m.function.description,
        strict: m.function.strict
      }
    } : m) : void 0;
    for (const m of t.messages)
      this._addMessage(m, !1);
    for (let m = 0; m < u; ++m) {
      const g = (p = (await this._createChatCompletion(e, {
        ...o,
        tool_choice: a,
        tools: h,
        messages: [...this.messages]
      }, n)).choices[0]) == null ? void 0 : p.message;
      if (!g)
        throw new ce("missing message in ChatCompletion response");
      if (!((y = g.tool_calls) != null && y.length))
        return;
      for (const w of g.tool_calls) {
        if (w.type !== "function")
          continue;
        const T = w.id, { name: x, arguments: O } = w.function, R = d[x];
        if (R) {
          if (c && c !== x) {
            const z = `Invalid tool_call: ${JSON.stringify(x)}. ${JSON.stringify(c)} requested. Please try again`;
            this._addMessage({ role: s, tool_call_id: T, content: z });
            continue;
          }
        } else {
          const z = `Invalid tool_call: ${JSON.stringify(x)}. Available options are: ${Object.keys(d).map((Te) => JSON.stringify(Te)).join(", ")}. Please try again`;
          this._addMessage({ role: s, tool_call_id: T, content: z });
          continue;
        }
        let E;
        try {
          E = _w(R) ? await R.parse(O) : O;
        } catch (z) {
          const Te = z instanceof Error ? z.message : String(z);
          this._addMessage({ role: s, tool_call_id: T, content: Te });
          continue;
        }
        const V = await R.function(E, this), ne = I(this, It, "m", op).call(this, V);
        if (this._addMessage({ role: s, tool_call_id: T, content: ne }), c)
          return;
      }
    }
  }
}
It = /* @__PURE__ */ new WeakSet(), Ic = function() {
  return I(this, It, "m", yi).call(this).content ?? null;
}, yi = function() {
  let e = this.messages.length;
  for (; e-- > 0; ) {
    const t = this.messages[e];
    if (mi(t))
      return {
        ...t,
        content: t.content ?? null,
        refusal: t.refusal ?? null
      };
  }
  throw new ce("stream ended without producing a ChatCompletionMessage with role=assistant");
}, Oc = function() {
  var e, t;
  for (let n = this.messages.length - 1; n >= 0; n--) {
    const s = this.messages[n];
    if (mi(s) && ((e = s == null ? void 0 : s.tool_calls) != null && e.length))
      return (t = s.tool_calls.filter((a) => a.type === "function").at(-1)) == null ? void 0 : t.function;
  }
}, Ac = function() {
  for (let e = this.messages.length - 1; e >= 0; e--) {
    const t = this.messages[e];
    if (sp(t) && t.content != null && typeof t.content == "string" && this.messages.some((n) => {
      var s;
      return n.role === "assistant" && ((s = n.tool_calls) == null ? void 0 : s.some((a) => a.type === "function" && a.id === t.tool_call_id));
    }))
      return t.content;
  }
}, $c = function() {
  const e = {
    completion_tokens: 0,
    prompt_tokens: 0,
    total_tokens: 0
  };
  for (const { usage: t } of this._chatCompletions)
    t && (e.completion_tokens += t.completion_tokens, e.prompt_tokens += t.prompt_tokens, e.total_tokens += t.total_tokens);
  return e;
}, ip = function(e) {
  if (e.n != null && e.n > 1)
    throw new ce("ChatCompletion convenience helpers only support n=1 at this time. To use n>1, please use chat.completions.create() directly.");
}, op = function(e) {
  return typeof e == "string" ? e : e === void 0 ? "undefined" : JSON.stringify(e);
};
class Ru extends cp {
  static runTools(e, t, n) {
    const s = new Ru(), a = {
      ...n,
      headers: { ...n == null ? void 0 : n.headers, "X-Stainless-Helper-Method": "runTools" }
    };
    return s._run(() => s._runTools(e, t, a)), s;
  }
  _addMessage(e, t = !0) {
    super._addMessage(e, t), mi(e) && e.content && this._emit("content", e.content);
  }
}
const up = 1, lp = 2, dp = 4, hp = 8, fp = 16, pp = 32, mp = 64, gp = 128, _p = 256, yp = gp | _p, wp = fp | pp | yp | mp, vp = up | lp | wp, bp = dp | hp, ww = vp | bp, ht = {
  STR: up,
  NUM: lp,
  ARR: dp,
  OBJ: hp,
  NULL: fp,
  BOOL: pp,
  NAN: mp,
  INFINITY: gp,
  MINUS_INFINITY: _p,
  INF: yp,
  SPECIAL: wp,
  ATOM: vp,
  COLLECTION: bp,
  ALL: ww
};
class vw extends Error {
}
class bw extends Error {
}
function Sw(r, e = ht.ALL) {
  if (typeof r != "string")
    throw new TypeError(`expecting str, got ${typeof r}`);
  if (!r.trim())
    throw new Error(`${r} is empty`);
  return Tw(r.trim(), e);
}
const Tw = (r, e) => {
  const t = r.length;
  let n = 0;
  const s = (h) => {
    throw new vw(`${h} at position ${n}`);
  }, a = (h) => {
    throw new bw(`${h} at position ${n}`);
  }, i = () => (d(), n >= t && s("Unexpected end of input"), r[n] === '"' ? o() : r[n] === "{" ? c() : r[n] === "[" ? u() : r.substring(n, n + 4) === "null" || ht.NULL & e && t - n < 4 && "null".startsWith(r.substring(n)) ? (n += 4, null) : r.substring(n, n + 4) === "true" || ht.BOOL & e && t - n < 4 && "true".startsWith(r.substring(n)) ? (n += 4, !0) : r.substring(n, n + 5) === "false" || ht.BOOL & e && t - n < 5 && "false".startsWith(r.substring(n)) ? (n += 5, !1) : r.substring(n, n + 8) === "Infinity" || ht.INFINITY & e && t - n < 8 && "Infinity".startsWith(r.substring(n)) ? (n += 8, 1 / 0) : r.substring(n, n + 9) === "-Infinity" || ht.MINUS_INFINITY & e && 1 < t - n && t - n < 9 && "-Infinity".startsWith(r.substring(n)) ? (n += 9, -1 / 0) : r.substring(n, n + 3) === "NaN" || ht.NAN & e && t - n < 3 && "NaN".startsWith(r.substring(n)) ? (n += 3, NaN) : l()), o = () => {
    const h = n;
    let f = !1;
    for (n++; n < t && (r[n] !== '"' || f && r[n - 1] === "\\"); )
      f = r[n] === "\\" ? !f : !1, n++;
    if (r.charAt(n) == '"')
      try {
        return JSON.parse(r.substring(h, ++n - Number(f)));
      } catch (p) {
        a(String(p));
      }
    else if (ht.STR & e)
      try {
        return JSON.parse(r.substring(h, n - Number(f)) + '"');
      } catch {
        return JSON.parse(r.substring(h, r.lastIndexOf("\\")) + '"');
      }
    s("Unterminated string literal");
  }, c = () => {
    n++, d();
    const h = {};
    try {
      for (; r[n] !== "}"; ) {
        if (d(), n >= t && ht.OBJ & e)
          return h;
        const f = o();
        d(), n++;
        try {
          const p = i();
          Object.defineProperty(h, f, { value: p, writable: !0, enumerable: !0, configurable: !0 });
        } catch (p) {
          if (ht.OBJ & e)
            return h;
          throw p;
        }
        d(), r[n] === "," && n++;
      }
    } catch {
      if (ht.OBJ & e)
        return h;
      s("Expected '}' at end of object");
    }
    return n++, h;
  }, u = () => {
    n++;
    const h = [];
    try {
      for (; r[n] !== "]"; )
        h.push(i()), d(), r[n] === "," && n++;
    } catch {
      if (ht.ARR & e)
        return h;
      s("Expected ']' at end of array");
    }
    return n++, h;
  }, l = () => {
    if (n === 0) {
      r === "-" && ht.NUM & e && s("Not sure what '-' is");
      try {
        return JSON.parse(r);
      } catch (f) {
        if (ht.NUM & e)
          try {
            return r[r.length - 1] === "." ? JSON.parse(r.substring(0, r.lastIndexOf("."))) : JSON.parse(r.substring(0, r.lastIndexOf("e")));
          } catch {
          }
        a(String(f));
      }
    }
    const h = n;
    for (r[n] === "-" && n++; r[n] && !",]}".includes(r[n]); )
      n++;
    n == t && !(ht.NUM & e) && s("Unterminated number literal");
    try {
      return JSON.parse(r.substring(h, n));
    } catch {
      r.substring(h, n) === "-" && ht.NUM & e && s("Not sure what '-' is");
      try {
        return JSON.parse(r.substring(h, r.lastIndexOf("e")));
      } catch (p) {
        a(String(p));
      }
    }
  }, d = () => {
    for (; n < t && ` 
\r	`.includes(r[n]); )
      n++;
  };
  return i();
}, dd = (r) => Sw(r, ht.ALL ^ ht.NUM);
var it, $r, Rn, Hr, zo, xa, Bo, Zo, Vo, ka, qo, hd;
class qs extends cp {
  constructor(e) {
    super(), it.add(this), $r.set(this, void 0), Rn.set(this, void 0), Hr.set(this, void 0), fe(this, $r, e), fe(this, Rn, []);
  }
  get currentChatCompletionSnapshot() {
    return I(this, Hr, "f");
  }
  /**
   * Intended for use on the frontend, consuming a stream produced with
   * `.toReadableStream()` on the backend.
   *
   * Note that messages sent to the model do not appear in `.on('message')`
   * in this context.
   */
  static fromReadableStream(e) {
    const t = new qs(null);
    return t._run(() => t._fromReadableStream(e)), t;
  }
  static createChatCompletion(e, t, n) {
    const s = new qs(t);
    return s._run(() => s._runChatCompletion(e, { ...t, stream: !0 }, { ...n, headers: { ...n == null ? void 0 : n.headers, "X-Stainless-Helper-Method": "stream" } })), s;
  }
  async _createChatCompletion(e, t, n) {
    var i;
    super._createChatCompletion;
    const s = n == null ? void 0 : n.signal;
    s && (s.aborted && this.controller.abort(), s.addEventListener("abort", () => this.controller.abort())), I(this, it, "m", zo).call(this);
    const a = await e.chat.completions.create({ ...t, stream: !0 }, { ...n, signal: this.controller.signal });
    this._connected();
    for await (const o of a)
      I(this, it, "m", Bo).call(this, o);
    if ((i = a.controller.signal) != null && i.aborted)
      throw new Ut();
    return this._addChatCompletion(I(this, it, "m", ka).call(this));
  }
  async _fromReadableStream(e, t) {
    var i;
    const n = t == null ? void 0 : t.signal;
    n && (n.aborted && this.controller.abort(), n.addEventListener("abort", () => this.controller.abort())), I(this, it, "m", zo).call(this), this._connected();
    const s = vr.fromReadableStream(e, this.controller);
    let a;
    for await (const o of s)
      a && a !== o.id && this._addChatCompletion(I(this, it, "m", ka).call(this)), I(this, it, "m", Bo).call(this, o), a = o.id;
    if ((i = s.controller.signal) != null && i.aborted)
      throw new Ut();
    return this._addChatCompletion(I(this, it, "m", ka).call(this));
  }
  [($r = /* @__PURE__ */ new WeakMap(), Rn = /* @__PURE__ */ new WeakMap(), Hr = /* @__PURE__ */ new WeakMap(), it = /* @__PURE__ */ new WeakSet(), zo = function() {
    this.ended || fe(this, Hr, void 0);
  }, xa = function(t) {
    let n = I(this, Rn, "f")[t.index];
    return n || (n = {
      content_done: !1,
      refusal_done: !1,
      logprobs_content_done: !1,
      logprobs_refusal_done: !1,
      done_tool_calls: /* @__PURE__ */ new Set(),
      current_tool_call_index: null
    }, I(this, Rn, "f")[t.index] = n, n);
  }, Bo = function(t) {
    var s, a, i, o, c, u, l, d, h, f, p, y, m, v, g;
    if (this.ended)
      return;
    const n = I(this, it, "m", hd).call(this, t);
    this._emit("chunk", t, n);
    for (const w of t.choices) {
      const T = n.choices[w.index];
      w.delta.content != null && ((s = T.message) == null ? void 0 : s.role) === "assistant" && ((a = T.message) != null && a.content) && (this._emit("content", w.delta.content, T.message.content), this._emit("content.delta", {
        delta: w.delta.content,
        snapshot: T.message.content,
        parsed: T.message.parsed
      })), w.delta.refusal != null && ((i = T.message) == null ? void 0 : i.role) === "assistant" && ((o = T.message) != null && o.refusal) && this._emit("refusal.delta", {
        delta: w.delta.refusal,
        snapshot: T.message.refusal
      }), ((c = w.logprobs) == null ? void 0 : c.content) != null && ((u = T.message) == null ? void 0 : u.role) === "assistant" && this._emit("logprobs.content.delta", {
        content: (l = w.logprobs) == null ? void 0 : l.content,
        snapshot: ((d = T.logprobs) == null ? void 0 : d.content) ?? []
      }), ((h = w.logprobs) == null ? void 0 : h.refusal) != null && ((f = T.message) == null ? void 0 : f.role) === "assistant" && this._emit("logprobs.refusal.delta", {
        refusal: (p = w.logprobs) == null ? void 0 : p.refusal,
        snapshot: ((y = T.logprobs) == null ? void 0 : y.refusal) ?? []
      });
      const x = I(this, it, "m", xa).call(this, T);
      T.finish_reason && (I(this, it, "m", Vo).call(this, T), x.current_tool_call_index != null && I(this, it, "m", Zo).call(this, T, x.current_tool_call_index));
      for (const O of w.delta.tool_calls ?? [])
        x.current_tool_call_index !== O.index && (I(this, it, "m", Vo).call(this, T), x.current_tool_call_index != null && I(this, it, "m", Zo).call(this, T, x.current_tool_call_index)), x.current_tool_call_index = O.index;
      for (const O of w.delta.tool_calls ?? []) {
        const R = (m = T.message.tool_calls) == null ? void 0 : m[O.index];
        R != null && R.type && ((R == null ? void 0 : R.type) === "function" ? this._emit("tool_calls.function.arguments.delta", {
          name: (v = R.function) == null ? void 0 : v.name,
          index: O.index,
          arguments: R.function.arguments,
          parsed_arguments: R.function.parsed_arguments,
          arguments_delta: ((g = O.function) == null ? void 0 : g.arguments) ?? ""
        }) : (R == null || R.type, void 0));
      }
    }
  }, Zo = function(t, n) {
    var i, o, c;
    if (I(this, it, "m", xa).call(this, t).done_tool_calls.has(n))
      return;
    const a = (i = t.message.tool_calls) == null ? void 0 : i[n];
    if (!a)
      throw new Error("no tool call snapshot");
    if (!a.type)
      throw new Error("tool call snapshot missing `type`");
    if (a.type === "function") {
      const u = (c = (o = I(this, $r, "f")) == null ? void 0 : o.tools) == null ? void 0 : c.find((l) => pi(l) && l.function.name === a.function.name);
      this._emit("tool_calls.function.arguments.done", {
        name: a.function.name,
        index: n,
        arguments: a.function.arguments,
        parsed_arguments: sa(u) ? u.$parseRaw(a.function.arguments) : u != null && u.function.strict ? JSON.parse(a.function.arguments) : null
      });
    } else
      a.type;
  }, Vo = function(t) {
    var s, a;
    const n = I(this, it, "m", xa).call(this, t);
    if (t.message.content && !n.content_done) {
      n.content_done = !0;
      const i = I(this, it, "m", qo).call(this);
      this._emit("content.done", {
        content: t.message.content,
        parsed: i ? i.$parseRaw(t.message.content) : null
      });
    }
    t.message.refusal && !n.refusal_done && (n.refusal_done = !0, this._emit("refusal.done", { refusal: t.message.refusal })), (s = t.logprobs) != null && s.content && !n.logprobs_content_done && (n.logprobs_content_done = !0, this._emit("logprobs.content.done", { content: t.logprobs.content })), (a = t.logprobs) != null && a.refusal && !n.logprobs_refusal_done && (n.logprobs_refusal_done = !0, this._emit("logprobs.refusal.done", { refusal: t.logprobs.refusal }));
  }, ka = function() {
    if (this.ended)
      throw new ce("stream has ended, this shouldn't happen");
    const t = I(this, Hr, "f");
    if (!t)
      throw new ce("request ended without sending any chunks");
    return fe(this, Hr, void 0), fe(this, Rn, []), Ew(t, I(this, $r, "f"));
  }, qo = function() {
    var n;
    const t = (n = I(this, $r, "f")) == null ? void 0 : n.response_format;
    return Au(t) ? t : null;
  }, hd = function(t) {
    var n, s, a, i;
    let o = I(this, Hr, "f");
    const { choices: c, ...u } = t;
    o ? Object.assign(o, u) : o = fe(this, Hr, {
      ...u,
      choices: []
    });
    for (const { delta: l, finish_reason: d, index: h, logprobs: f = null, ...p } of t.choices) {
      let y = o.choices[h];
      if (y || (y = o.choices[h] = { finish_reason: d, index: h, message: {}, logprobs: f, ...p }), f)
        if (!y.logprobs)
          y.logprobs = Object.assign({}, f);
        else {
          const { content: O, refusal: R, ...E } = f;
          Object.assign(y.logprobs, E), O && ((n = y.logprobs).content ?? (n.content = []), y.logprobs.content.push(...O)), R && ((s = y.logprobs).refusal ?? (s.refusal = []), y.logprobs.refusal.push(...R));
        }
      if (d && (y.finish_reason = d, I(this, $r, "f") && rp(I(this, $r, "f")))) {
        if (d === "length")
          throw new Df();
        if (d === "content_filter")
          throw new jf();
      }
      if (Object.assign(y, p), !l)
        continue;
      const { content: m, refusal: v, function_call: g, role: w, tool_calls: T, ...x } = l;
      if (Object.assign(y.message, x), v && (y.message.refusal = (y.message.refusal || "") + v), w && (y.message.role = w), g && (y.message.function_call ? (g.name && (y.message.function_call.name = g.name), g.arguments && ((a = y.message.function_call).arguments ?? (a.arguments = ""), y.message.function_call.arguments += g.arguments)) : y.message.function_call = g), m && (y.message.content = (y.message.content || "") + m, !y.message.refusal && I(this, it, "m", qo).call(this) && (y.message.parsed = dd(y.message.content))), T) {
        y.message.tool_calls || (y.message.tool_calls = []);
        for (const { index: O, id: R, type: E, function: V, ...ne } of T) {
          const z = (i = y.message.tool_calls)[O] ?? (i[O] = {});
          Object.assign(z, ne), R && (z.id = R), E && (z.type = E), V && (z.function ?? (z.function = { name: V.name ?? "", arguments: "" })), V != null && V.name && (z.function.name = V.name), V != null && V.arguments && (z.function.arguments += V.arguments, mw(I(this, $r, "f"), z) && (z.function.parsed_arguments = dd(z.function.arguments)));
        }
      }
    }
    return o;
  }, Symbol.asyncIterator)]() {
    const e = [], t = [];
    let n = !1;
    return this.on("chunk", (s) => {
      const a = t.shift();
      a ? a.resolve(s) : e.push(s);
    }), this.on("end", () => {
      n = !0;
      for (const s of t)
        s.resolve(void 0);
      t.length = 0;
    }), this.on("abort", (s) => {
      n = !0;
      for (const a of t)
        a.reject(s);
      t.length = 0;
    }), this.on("error", (s) => {
      n = !0;
      for (const a of t)
        a.reject(s);
      t.length = 0;
    }), {
      next: async () => e.length ? { value: e.shift(), done: !1 } : n ? { value: void 0, done: !0 } : new Promise((a, i) => t.push({ resolve: a, reject: i })).then((a) => a ? { value: a, done: !1 } : { value: void 0, done: !0 }),
      return: async () => (this.abort(), { value: void 0, done: !0 })
    };
  }
  toReadableStream() {
    return new vr(this[Symbol.asyncIterator].bind(this), this.controller).toReadableStream();
  }
}
function Ew(r, e) {
  const { id: t, choices: n, created: s, model: a, system_fingerprint: i, ...o } = r, c = {
    ...o,
    id: t,
    choices: n.map(({ message: u, finish_reason: l, index: d, logprobs: h, ...f }) => {
      if (!l)
        throw new ce(`missing finish_reason for choice ${d}`);
      const { content: p = null, function_call: y, tool_calls: m, ...v } = u, g = u.role;
      if (!g)
        throw new ce(`missing role for choice ${d}`);
      if (y) {
        const { arguments: w, name: T } = y;
        if (w == null)
          throw new ce(`missing function_call.arguments for choice ${d}`);
        if (!T)
          throw new ce(`missing function_call.name for choice ${d}`);
        return {
          ...f,
          message: {
            content: p,
            function_call: { arguments: w, name: T },
            role: g,
            refusal: u.refusal ?? null
          },
          finish_reason: l,
          index: d,
          logprobs: h
        };
      }
      return m ? {
        ...f,
        index: d,
        finish_reason: l,
        logprobs: h,
        message: {
          ...v,
          role: g,
          content: p,
          refusal: u.refusal ?? null,
          tool_calls: m.map((w, T) => {
            const { function: x, type: O, id: R, ...E } = w, { arguments: V, name: ne, ...z } = x || {};
            if (R == null)
              throw new ce(`missing choices[${d}].tool_calls[${T}].id
${Ia(r)}`);
            if (O == null)
              throw new ce(`missing choices[${d}].tool_calls[${T}].type
${Ia(r)}`);
            if (ne == null)
              throw new ce(`missing choices[${d}].tool_calls[${T}].function.name
${Ia(r)}`);
            if (V == null)
              throw new ce(`missing choices[${d}].tool_calls[${T}].function.arguments
${Ia(r)}`);
            return { ...E, id: R, type: O, function: { ...z, name: ne, arguments: V } };
          })
        }
      } : {
        ...f,
        message: { ...v, content: p, role: g, refusal: u.refusal ?? null },
        finish_reason: l,
        index: d,
        logprobs: h
      };
    }),
    created: s,
    model: a,
    object: "chat.completion",
    ...i ? { system_fingerprint: i } : {}
  };
  return hw(c, e);
}
function Ia(r) {
  return JSON.stringify(r);
}
class wi extends qs {
  static fromReadableStream(e) {
    const t = new wi(null);
    return t._run(() => t._fromReadableStream(e)), t;
  }
  static runTools(e, t, n) {
    const s = new wi(
      // @ts-expect-error TODO these types are incompatible
      t
    ), a = {
      ...n,
      headers: { ...n == null ? void 0 : n.headers, "X-Stainless-Helper-Method": "runTools" }
    };
    return s._run(() => s._runTools(e, t, a)), s;
  }
}
let Nu = class extends ie {
  constructor() {
    super(...arguments), this.messages = new tp(this._client);
  }
  create(e, t) {
    return this._client.post("/chat/completions", { body: e, ...t, stream: e.stream ?? !1 });
  }
  /**
   * Get a stored chat completion. Only Chat Completions that have been created with
   * the `store` parameter set to `true` will be returned.
   *
   * @example
   * ```ts
   * const chatCompletion =
   *   await client.chat.completions.retrieve('completion_id');
   * ```
   */
  retrieve(e, t) {
    return this._client.get(F`/chat/completions/${e}`, t);
  }
  /**
   * Modify a stored chat completion. Only Chat Completions that have been created
   * with the `store` parameter set to `true` can be modified. Currently, the only
   * supported modification is to update the `metadata` field.
   *
   * @example
   * ```ts
   * const chatCompletion = await client.chat.completions.update(
   *   'completion_id',
   *   { metadata: { foo: 'string' } },
   * );
   * ```
   */
  update(e, t, n) {
    return this._client.post(F`/chat/completions/${e}`, { body: t, ...n });
  }
  /**
   * List stored Chat Completions. Only Chat Completions that have been stored with
   * the `store` parameter set to `true` will be returned.
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const chatCompletion of client.chat.completions.list()) {
   *   // ...
   * }
   * ```
   */
  list(e = {}, t) {
    return this._client.getAPIList("/chat/completions", nt, { query: e, ...t });
  }
  /**
   * Delete a stored chat completion. Only Chat Completions that have been created
   * with the `store` parameter set to `true` can be deleted.
   *
   * @example
   * ```ts
   * const chatCompletionDeleted =
   *   await client.chat.completions.delete('completion_id');
   * ```
   */
  delete(e, t) {
    return this._client.delete(F`/chat/completions/${e}`, t);
  }
  parse(e, t) {
    return gw(e.tools), this._client.chat.completions.create(e, {
      ...t,
      headers: {
        ...t == null ? void 0 : t.headers,
        "X-Stainless-Helper-Method": "chat.completions.parse"
      }
    })._thenUnwrap((n) => $u(n, e));
  }
  runTools(e, t) {
    return e.stream ? wi.runTools(this._client, e, t) : Ru.runTools(this._client, e, t);
  }
  /**
   * Creates a chat completion stream
   */
  stream(e, t) {
    return qs.createChatCompletion(this._client, e, t);
  }
};
Nu.Messages = tp;
class Pu extends ie {
  constructor() {
    super(...arguments), this.completions = new Nu(this._client);
  }
}
Pu.Completions = Nu;
const Sp = /* @__PURE__ */ Symbol("brand.privateNullableHeaders");
function* xw(r) {
  if (!r)
    return;
  if (Sp in r) {
    const { values: n, nulls: s } = r;
    yield* n.entries();
    for (const a of s)
      yield [a, null];
    return;
  }
  let e = !1, t;
  r instanceof Headers ? t = r.entries() : Kl(r) ? t = r : (e = !0, t = Object.entries(r ?? {}));
  for (let n of t) {
    const s = n[0];
    if (typeof s != "string")
      throw new TypeError("expected header name to be a string");
    const a = Kl(n[1]) ? n[1] : [n[1]];
    let i = !1;
    for (const o of a)
      o !== void 0 && (e && !i && (i = !0, yield [s, null]), yield [s, o]);
  }
}
const Y = (r) => {
  const e = new Headers(), t = /* @__PURE__ */ new Set();
  for (const n of r) {
    const s = /* @__PURE__ */ new Set();
    for (const [a, i] of xw(n)) {
      const o = a.toLowerCase();
      s.has(o) || (e.delete(a), s.add(o)), i === null ? (e.delete(a), t.add(o)) : (e.append(a, i), t.delete(o));
    }
  }
  return { [Sp]: !0, values: e, nulls: t };
};
class Tp extends ie {
  /**
   * Generates audio from the input text.
   *
   * @example
   * ```ts
   * const speech = await client.audio.speech.create({
   *   input: 'input',
   *   model: 'string',
   *   voice: 'ash',
   * });
   *
   * const content = await speech.blob();
   * console.log(content);
   * ```
   */
  create(e, t) {
    return this._client.post("/audio/speech", {
      body: e,
      ...t,
      headers: Y([{ Accept: "application/octet-stream" }, t == null ? void 0 : t.headers]),
      __binaryResponse: !0
    });
  }
}
class Ep extends ie {
  create(e, t) {
    return this._client.post("/audio/transcriptions", xn({
      body: e,
      ...t,
      stream: e.stream ?? !1,
      __metadata: { model: e.model }
    }, this._client));
  }
}
class xp extends ie {
  create(e, t) {
    return this._client.post("/audio/translations", xn({ body: e, ...t, __metadata: { model: e.model } }, this._client));
  }
}
class aa extends ie {
  constructor() {
    super(...arguments), this.transcriptions = new Ep(this._client), this.translations = new xp(this._client), this.speech = new Tp(this._client);
  }
}
aa.Transcriptions = Ep;
aa.Translations = xp;
aa.Speech = Tp;
class kp extends ie {
  /**
   * Creates and executes a batch from an uploaded file of requests
   */
  create(e, t) {
    return this._client.post("/batches", { body: e, ...t });
  }
  /**
   * Retrieves a batch.
   */
  retrieve(e, t) {
    return this._client.get(F`/batches/${e}`, t);
  }
  /**
   * List your organization's batches.
   */
  list(e = {}, t) {
    return this._client.getAPIList("/batches", nt, { query: e, ...t });
  }
  /**
   * Cancels an in-progress batch. The batch will be in status `cancelling` for up to
   * 10 minutes, before changing to `cancelled`, where it will have partial results
   * (if any) available in the output file.
   */
  cancel(e, t) {
    return this._client.post(F`/batches/${e}/cancel`, t);
  }
}
class Ip extends ie {
  /**
   * Create an assistant with a model and instructions.
   *
   * @example
   * ```ts
   * const assistant = await client.beta.assistants.create({
   *   model: 'gpt-4o',
   * });
   * ```
   */
  create(e, t) {
    return this._client.post("/assistants", {
      body: e,
      ...t,
      headers: Y([{ "OpenAI-Beta": "assistants=v2" }, t == null ? void 0 : t.headers])
    });
  }
  /**
   * Retrieves an assistant.
   *
   * @example
   * ```ts
   * const assistant = await client.beta.assistants.retrieve(
   *   'assistant_id',
   * );
   * ```
   */
  retrieve(e, t) {
    return this._client.get(F`/assistants/${e}`, {
      ...t,
      headers: Y([{ "OpenAI-Beta": "assistants=v2" }, t == null ? void 0 : t.headers])
    });
  }
  /**
   * Modifies an assistant.
   *
   * @example
   * ```ts
   * const assistant = await client.beta.assistants.update(
   *   'assistant_id',
   * );
   * ```
   */
  update(e, t, n) {
    return this._client.post(F`/assistants/${e}`, {
      body: t,
      ...n,
      headers: Y([{ "OpenAI-Beta": "assistants=v2" }, n == null ? void 0 : n.headers])
    });
  }
  /**
   * Returns a list of assistants.
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const assistant of client.beta.assistants.list()) {
   *   // ...
   * }
   * ```
   */
  list(e = {}, t) {
    return this._client.getAPIList("/assistants", nt, {
      query: e,
      ...t,
      headers: Y([{ "OpenAI-Beta": "assistants=v2" }, t == null ? void 0 : t.headers])
    });
  }
  /**
   * Delete an assistant.
   *
   * @example
   * ```ts
   * const assistantDeleted =
   *   await client.beta.assistants.delete('assistant_id');
   * ```
   */
  delete(e, t) {
    return this._client.delete(F`/assistants/${e}`, {
      ...t,
      headers: Y([{ "OpenAI-Beta": "assistants=v2" }, t == null ? void 0 : t.headers])
    });
  }
}
let Op = class extends ie {
  /**
   * Create an ephemeral API token for use in client-side applications with the
   * Realtime API. Can be configured with the same session parameters as the
   * `session.update` client event.
   *
   * It responds with a session object, plus a `client_secret` key which contains a
   * usable ephemeral API token that can be used to authenticate browser clients for
   * the Realtime API.
   *
   * @example
   * ```ts
   * const session =
   *   await client.beta.realtime.sessions.create();
   * ```
   */
  create(e, t) {
    return this._client.post("/realtime/sessions", {
      body: e,
      ...t,
      headers: Y([{ "OpenAI-Beta": "assistants=v2" }, t == null ? void 0 : t.headers])
    });
  }
};
class Ap extends ie {
  /**
   * Create an ephemeral API token for use in client-side applications with the
   * Realtime API specifically for realtime transcriptions. Can be configured with
   * the same session parameters as the `transcription_session.update` client event.
   *
   * It responds with a session object, plus a `client_secret` key which contains a
   * usable ephemeral API token that can be used to authenticate browser clients for
   * the Realtime API.
   *
   * @example
   * ```ts
   * const transcriptionSession =
   *   await client.beta.realtime.transcriptionSessions.create();
   * ```
   */
  create(e, t) {
    return this._client.post("/realtime/transcription_sessions", {
      body: e,
      ...t,
      headers: Y([{ "OpenAI-Beta": "assistants=v2" }, t == null ? void 0 : t.headers])
    });
  }
}
let eo = class extends ie {
  constructor() {
    super(...arguments), this.sessions = new Op(this._client), this.transcriptionSessions = new Ap(this._client);
  }
};
eo.Sessions = Op;
eo.TranscriptionSessions = Ap;
class $p extends ie {
  /**
   * Create a ChatKit session
   *
   * @example
   * ```ts
   * const chatSession =
   *   await client.beta.chatkit.sessions.create({
   *     user: 'x',
   *     workflow: { id: 'id' },
   *   });
   * ```
   */
  create(e, t) {
    return this._client.post("/chatkit/sessions", {
      body: e,
      ...t,
      headers: Y([{ "OpenAI-Beta": "chatkit_beta=v1" }, t == null ? void 0 : t.headers])
    });
  }
  /**
   * Cancel a ChatKit session
   *
   * @example
   * ```ts
   * const chatSession =
   *   await client.beta.chatkit.sessions.cancel('cksess_123');
   * ```
   */
  cancel(e, t) {
    return this._client.post(F`/chatkit/sessions/${e}/cancel`, {
      ...t,
      headers: Y([{ "OpenAI-Beta": "chatkit_beta=v1" }, t == null ? void 0 : t.headers])
    });
  }
}
let Cp = class extends ie {
  /**
   * Retrieve a ChatKit thread
   *
   * @example
   * ```ts
   * const chatkitThread =
   *   await client.beta.chatkit.threads.retrieve('cthr_123');
   * ```
   */
  retrieve(e, t) {
    return this._client.get(F`/chatkit/threads/${e}`, {
      ...t,
      headers: Y([{ "OpenAI-Beta": "chatkit_beta=v1" }, t == null ? void 0 : t.headers])
    });
  }
  /**
   * List ChatKit threads
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const chatkitThread of client.beta.chatkit.threads.list()) {
   *   // ...
   * }
   * ```
   */
  list(e = {}, t) {
    return this._client.getAPIList("/chatkit/threads", fi, {
      query: e,
      ...t,
      headers: Y([{ "OpenAI-Beta": "chatkit_beta=v1" }, t == null ? void 0 : t.headers])
    });
  }
  /**
   * Delete a ChatKit thread
   *
   * @example
   * ```ts
   * const thread = await client.beta.chatkit.threads.delete(
   *   'cthr_123',
   * );
   * ```
   */
  delete(e, t) {
    return this._client.delete(F`/chatkit/threads/${e}`, {
      ...t,
      headers: Y([{ "OpenAI-Beta": "chatkit_beta=v1" }, t == null ? void 0 : t.headers])
    });
  }
  /**
   * List ChatKit thread items
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const thread of client.beta.chatkit.threads.listItems(
   *   'cthr_123',
   * )) {
   *   // ...
   * }
   * ```
   */
  listItems(e, t = {}, n) {
    return this._client.getAPIList(F`/chatkit/threads/${e}/items`, fi, { query: t, ...n, headers: Y([{ "OpenAI-Beta": "chatkit_beta=v1" }, n == null ? void 0 : n.headers]) });
  }
};
class to extends ie {
  constructor() {
    super(...arguments), this.sessions = new $p(this._client), this.threads = new Cp(this._client);
  }
}
to.Sessions = $p;
to.Threads = Cp;
class Rp extends ie {
  /**
   * Create a message.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  create(e, t, n) {
    return this._client.post(F`/threads/${e}/messages`, {
      body: t,
      ...n,
      headers: Y([{ "OpenAI-Beta": "assistants=v2" }, n == null ? void 0 : n.headers])
    });
  }
  /**
   * Retrieve a message.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  retrieve(e, t, n) {
    const { thread_id: s } = t;
    return this._client.get(F`/threads/${s}/messages/${e}`, {
      ...n,
      headers: Y([{ "OpenAI-Beta": "assistants=v2" }, n == null ? void 0 : n.headers])
    });
  }
  /**
   * Modifies a message.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  update(e, t, n) {
    const { thread_id: s, ...a } = t;
    return this._client.post(F`/threads/${s}/messages/${e}`, {
      body: a,
      ...n,
      headers: Y([{ "OpenAI-Beta": "assistants=v2" }, n == null ? void 0 : n.headers])
    });
  }
  /**
   * Returns a list of messages for a given thread.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  list(e, t = {}, n) {
    return this._client.getAPIList(F`/threads/${e}/messages`, nt, {
      query: t,
      ...n,
      headers: Y([{ "OpenAI-Beta": "assistants=v2" }, n == null ? void 0 : n.headers])
    });
  }
  /**
   * Deletes a message.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  delete(e, t, n) {
    const { thread_id: s } = t;
    return this._client.delete(F`/threads/${s}/messages/${e}`, {
      ...n,
      headers: Y([{ "OpenAI-Beta": "assistants=v2" }, n == null ? void 0 : n.headers])
    });
  }
}
class Np extends ie {
  /**
   * Retrieves a run step.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  retrieve(e, t, n) {
    const { thread_id: s, run_id: a, ...i } = t;
    return this._client.get(F`/threads/${s}/runs/${a}/steps/${e}`, {
      query: i,
      ...n,
      headers: Y([{ "OpenAI-Beta": "assistants=v2" }, n == null ? void 0 : n.headers])
    });
  }
  /**
   * Returns a list of run steps belonging to a run.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  list(e, t, n) {
    const { thread_id: s, ...a } = t;
    return this._client.getAPIList(F`/threads/${s}/runs/${e}/steps`, nt, {
      query: a,
      ...n,
      headers: Y([{ "OpenAI-Beta": "assistants=v2" }, n == null ? void 0 : n.headers])
    });
  }
}
const kw = (r) => {
  if (typeof Buffer < "u") {
    const e = Buffer.from(r, "base64");
    return Array.from(new Float32Array(e.buffer, e.byteOffset, e.length / Float32Array.BYTES_PER_ELEMENT));
  } else {
    const e = atob(r), t = e.length, n = new Uint8Array(t);
    for (let s = 0; s < t; s++)
      n[s] = e.charCodeAt(s);
    return Array.from(new Float32Array(n.buffer));
  }
}, Nn = (r) => {
  var e, t, n, s, a;
  if (typeof globalThis.process < "u")
    return ((t = (e = globalThis.process.env) == null ? void 0 : e[r]) == null ? void 0 : t.trim()) ?? void 0;
  if (typeof globalThis.Deno < "u")
    return (a = (s = (n = globalThis.Deno.env) == null ? void 0 : n.get) == null ? void 0 : s.call(n, r)) == null ? void 0 : a.trim();
};
var vt, wn, Cc, yr, ti, ir, vn, Zn, yn, vi, Ft, ri, ni, Ms, Es, xs, fd, pd, md, gd, _d, yd, wd;
class Ds extends Cu {
  constructor() {
    super(...arguments), vt.add(this), Cc.set(this, []), yr.set(this, {}), ti.set(this, {}), ir.set(this, void 0), vn.set(this, void 0), Zn.set(this, void 0), yn.set(this, void 0), vi.set(this, void 0), Ft.set(this, void 0), ri.set(this, void 0), ni.set(this, void 0), Ms.set(this, void 0);
  }
  [(Cc = /* @__PURE__ */ new WeakMap(), yr = /* @__PURE__ */ new WeakMap(), ti = /* @__PURE__ */ new WeakMap(), ir = /* @__PURE__ */ new WeakMap(), vn = /* @__PURE__ */ new WeakMap(), Zn = /* @__PURE__ */ new WeakMap(), yn = /* @__PURE__ */ new WeakMap(), vi = /* @__PURE__ */ new WeakMap(), Ft = /* @__PURE__ */ new WeakMap(), ri = /* @__PURE__ */ new WeakMap(), ni = /* @__PURE__ */ new WeakMap(), Ms = /* @__PURE__ */ new WeakMap(), vt = /* @__PURE__ */ new WeakSet(), Symbol.asyncIterator)]() {
    const e = [], t = [];
    let n = !1;
    return this.on("event", (s) => {
      const a = t.shift();
      a ? a.resolve(s) : e.push(s);
    }), this.on("end", () => {
      n = !0;
      for (const s of t)
        s.resolve(void 0);
      t.length = 0;
    }), this.on("abort", (s) => {
      n = !0;
      for (const a of t)
        a.reject(s);
      t.length = 0;
    }), this.on("error", (s) => {
      n = !0;
      for (const a of t)
        a.reject(s);
      t.length = 0;
    }), {
      next: async () => e.length ? { value: e.shift(), done: !1 } : n ? { value: void 0, done: !0 } : new Promise((a, i) => t.push({ resolve: a, reject: i })).then((a) => a ? { value: a, done: !1 } : { value: void 0, done: !0 }),
      return: async () => (this.abort(), { value: void 0, done: !0 })
    };
  }
  static fromReadableStream(e) {
    const t = new wn();
    return t._run(() => t._fromReadableStream(e)), t;
  }
  async _fromReadableStream(e, t) {
    var a;
    const n = t == null ? void 0 : t.signal;
    n && (n.aborted && this.controller.abort(), n.addEventListener("abort", () => this.controller.abort())), this._connected();
    const s = vr.fromReadableStream(e, this.controller);
    for await (const i of s)
      I(this, vt, "m", Es).call(this, i);
    if ((a = s.controller.signal) != null && a.aborted)
      throw new Ut();
    return this._addRun(I(this, vt, "m", xs).call(this));
  }
  toReadableStream() {
    return new vr(this[Symbol.asyncIterator].bind(this), this.controller).toReadableStream();
  }
  static createToolAssistantStream(e, t, n, s) {
    const a = new wn();
    return a._run(() => a._runToolAssistantStream(e, t, n, {
      ...s,
      headers: { ...s == null ? void 0 : s.headers, "X-Stainless-Helper-Method": "stream" }
    })), a;
  }
  async _createToolAssistantStream(e, t, n, s) {
    var c;
    const a = s == null ? void 0 : s.signal;
    a && (a.aborted && this.controller.abort(), a.addEventListener("abort", () => this.controller.abort()));
    const i = { ...n, stream: !0 }, o = await e.submitToolOutputs(t, i, {
      ...s,
      signal: this.controller.signal
    });
    this._connected();
    for await (const u of o)
      I(this, vt, "m", Es).call(this, u);
    if ((c = o.controller.signal) != null && c.aborted)
      throw new Ut();
    return this._addRun(I(this, vt, "m", xs).call(this));
  }
  static createThreadAssistantStream(e, t, n) {
    const s = new wn();
    return s._run(() => s._threadAssistantStream(e, t, {
      ...n,
      headers: { ...n == null ? void 0 : n.headers, "X-Stainless-Helper-Method": "stream" }
    })), s;
  }
  static createAssistantStream(e, t, n, s) {
    const a = new wn();
    return a._run(() => a._runAssistantStream(e, t, n, {
      ...s,
      headers: { ...s == null ? void 0 : s.headers, "X-Stainless-Helper-Method": "stream" }
    })), a;
  }
  currentEvent() {
    return I(this, ri, "f");
  }
  currentRun() {
    return I(this, ni, "f");
  }
  currentMessageSnapshot() {
    return I(this, ir, "f");
  }
  currentRunStepSnapshot() {
    return I(this, Ms, "f");
  }
  async finalRunSteps() {
    return await this.done(), Object.values(I(this, yr, "f"));
  }
  async finalMessages() {
    return await this.done(), Object.values(I(this, ti, "f"));
  }
  async finalRun() {
    if (await this.done(), !I(this, vn, "f"))
      throw Error("Final run was not received.");
    return I(this, vn, "f");
  }
  async _createThreadAssistantStream(e, t, n) {
    var o;
    const s = n == null ? void 0 : n.signal;
    s && (s.aborted && this.controller.abort(), s.addEventListener("abort", () => this.controller.abort()));
    const a = { ...t, stream: !0 }, i = await e.createAndRun(a, { ...n, signal: this.controller.signal });
    this._connected();
    for await (const c of i)
      I(this, vt, "m", Es).call(this, c);
    if ((o = i.controller.signal) != null && o.aborted)
      throw new Ut();
    return this._addRun(I(this, vt, "m", xs).call(this));
  }
  async _createAssistantStream(e, t, n, s) {
    var c;
    const a = s == null ? void 0 : s.signal;
    a && (a.aborted && this.controller.abort(), a.addEventListener("abort", () => this.controller.abort()));
    const i = { ...n, stream: !0 }, o = await e.create(t, i, { ...s, signal: this.controller.signal });
    this._connected();
    for await (const u of o)
      I(this, vt, "m", Es).call(this, u);
    if ((c = o.controller.signal) != null && c.aborted)
      throw new Ut();
    return this._addRun(I(this, vt, "m", xs).call(this));
  }
  static accumulateDelta(e, t) {
    for (const [n, s] of Object.entries(t)) {
      if (!e.hasOwnProperty(n)) {
        e[n] = s;
        continue;
      }
      let a = e[n];
      if (a == null) {
        e[n] = s;
        continue;
      }
      if (n === "index" || n === "type") {
        e[n] = s;
        continue;
      }
      if (typeof a == "string" && typeof s == "string")
        a += s;
      else if (typeof a == "number" && typeof s == "number")
        a += s;
      else if (jo(a) && jo(s))
        a = this.accumulateDelta(a, s);
      else if (Array.isArray(a) && Array.isArray(s)) {
        if (a.every((i) => typeof i == "string" || typeof i == "number")) {
          a.push(...s);
          continue;
        }
        for (const i of s) {
          if (!jo(i))
            throw new Error(`Expected array delta entry to be an object but got: ${i}`);
          const o = i.index;
          if (o == null)
            throw console.error(i), new Error("Expected array delta entry to have an `index` property");
          if (typeof o != "number")
            throw new Error(`Expected array delta entry \`index\` property to be a number but got ${o}`);
          const c = a[o];
          c == null ? a.push(i) : a[o] = this.accumulateDelta(c, i);
        }
        continue;
      } else
        throw Error(`Unhandled record type: ${n}, deltaValue: ${s}, accValue: ${a}`);
      e[n] = a;
    }
    return e;
  }
  _addRun(e) {
    return e;
  }
  async _threadAssistantStream(e, t, n) {
    return await this._createThreadAssistantStream(t, e, n);
  }
  async _runAssistantStream(e, t, n, s) {
    return await this._createAssistantStream(t, e, n, s);
  }
  async _runToolAssistantStream(e, t, n, s) {
    return await this._createToolAssistantStream(t, e, n, s);
  }
}
wn = Ds, Es = function(e) {
  if (!this.ended)
    switch (fe(this, ri, e), I(this, vt, "m", md).call(this, e), e.event) {
      case "thread.created":
        break;
      case "thread.run.created":
      case "thread.run.queued":
      case "thread.run.in_progress":
      case "thread.run.requires_action":
      case "thread.run.completed":
      case "thread.run.incomplete":
      case "thread.run.failed":
      case "thread.run.cancelling":
      case "thread.run.cancelled":
      case "thread.run.expired":
        I(this, vt, "m", wd).call(this, e);
        break;
      case "thread.run.step.created":
      case "thread.run.step.in_progress":
      case "thread.run.step.delta":
      case "thread.run.step.completed":
      case "thread.run.step.failed":
      case "thread.run.step.cancelled":
      case "thread.run.step.expired":
        I(this, vt, "m", pd).call(this, e);
        break;
      case "thread.message.created":
      case "thread.message.in_progress":
      case "thread.message.delta":
      case "thread.message.completed":
      case "thread.message.incomplete":
        I(this, vt, "m", fd).call(this, e);
        break;
      case "error":
        throw new Error("Encountered an error event in event processing - errors should be processed earlier");
    }
}, xs = function() {
  if (this.ended)
    throw new ce("stream has ended, this shouldn't happen");
  if (!I(this, vn, "f"))
    throw Error("Final run has not been received");
  return I(this, vn, "f");
}, fd = function(e) {
  const [t, n] = I(this, vt, "m", _d).call(this, e, I(this, ir, "f"));
  fe(this, ir, t), I(this, ti, "f")[t.id] = t;
  for (const s of n) {
    const a = t.content[s.index];
    (a == null ? void 0 : a.type) == "text" && this._emit("textCreated", a.text);
  }
  switch (e.event) {
    case "thread.message.created":
      this._emit("messageCreated", e.data);
      break;
    case "thread.message.in_progress":
      break;
    case "thread.message.delta":
      if (this._emit("messageDelta", e.data.delta, t), e.data.delta.content)
        for (const s of e.data.delta.content) {
          if (s.type == "text" && s.text) {
            let a = s.text, i = t.content[s.index];
            if (i && i.type == "text")
              this._emit("textDelta", a, i.text);
            else
              throw Error("The snapshot associated with this text delta is not text or missing");
          }
          if (s.index != I(this, Zn, "f")) {
            if (I(this, yn, "f"))
              switch (I(this, yn, "f").type) {
                case "text":
                  this._emit("textDone", I(this, yn, "f").text, I(this, ir, "f"));
                  break;
                case "image_file":
                  this._emit("imageFileDone", I(this, yn, "f").image_file, I(this, ir, "f"));
                  break;
              }
            fe(this, Zn, s.index);
          }
          fe(this, yn, t.content[s.index]);
        }
      break;
    case "thread.message.completed":
    case "thread.message.incomplete":
      if (I(this, Zn, "f") !== void 0) {
        const s = e.data.content[I(this, Zn, "f")];
        if (s)
          switch (s.type) {
            case "image_file":
              this._emit("imageFileDone", s.image_file, I(this, ir, "f"));
              break;
            case "text":
              this._emit("textDone", s.text, I(this, ir, "f"));
              break;
          }
      }
      I(this, ir, "f") && this._emit("messageDone", e.data), fe(this, ir, void 0);
  }
}, pd = function(e) {
  const t = I(this, vt, "m", gd).call(this, e);
  switch (fe(this, Ms, t), e.event) {
    case "thread.run.step.created":
      this._emit("runStepCreated", e.data);
      break;
    case "thread.run.step.delta":
      const n = e.data.delta;
      if (n.step_details && n.step_details.type == "tool_calls" && n.step_details.tool_calls && t.step_details.type == "tool_calls")
        for (const a of n.step_details.tool_calls)
          a.index == I(this, vi, "f") ? this._emit("toolCallDelta", a, t.step_details.tool_calls[a.index]) : (I(this, Ft, "f") && this._emit("toolCallDone", I(this, Ft, "f")), fe(this, vi, a.index), fe(this, Ft, t.step_details.tool_calls[a.index]), I(this, Ft, "f") && this._emit("toolCallCreated", I(this, Ft, "f")));
      this._emit("runStepDelta", e.data.delta, t);
      break;
    case "thread.run.step.completed":
    case "thread.run.step.failed":
    case "thread.run.step.cancelled":
    case "thread.run.step.expired":
      fe(this, Ms, void 0), e.data.step_details.type == "tool_calls" && I(this, Ft, "f") && (this._emit("toolCallDone", I(this, Ft, "f")), fe(this, Ft, void 0)), this._emit("runStepDone", e.data, t);
      break;
  }
}, md = function(e) {
  I(this, Cc, "f").push(e), this._emit("event", e);
}, gd = function(e) {
  switch (e.event) {
    case "thread.run.step.created":
      return I(this, yr, "f")[e.data.id] = e.data, e.data;
    case "thread.run.step.delta":
      let t = I(this, yr, "f")[e.data.id];
      if (!t)
        throw Error("Received a RunStepDelta before creation of a snapshot");
      let n = e.data;
      if (n.delta) {
        const s = wn.accumulateDelta(t, n.delta);
        I(this, yr, "f")[e.data.id] = s;
      }
      return I(this, yr, "f")[e.data.id];
    case "thread.run.step.completed":
    case "thread.run.step.failed":
    case "thread.run.step.cancelled":
    case "thread.run.step.expired":
    case "thread.run.step.in_progress":
      I(this, yr, "f")[e.data.id] = e.data;
      break;
  }
  if (I(this, yr, "f")[e.data.id])
    return I(this, yr, "f")[e.data.id];
  throw new Error("No snapshot available");
}, _d = function(e, t) {
  let n = [];
  switch (e.event) {
    case "thread.message.created":
      return [e.data, n];
    case "thread.message.delta":
      if (!t)
        throw Error("Received a delta with no existing snapshot (there should be one from message creation)");
      let s = e.data;
      if (s.delta.content)
        for (const a of s.delta.content)
          if (a.index in t.content) {
            let i = t.content[a.index];
            t.content[a.index] = I(this, vt, "m", yd).call(this, a, i);
          } else
            t.content[a.index] = a, n.push(a);
      return [t, n];
    case "thread.message.in_progress":
    case "thread.message.completed":
    case "thread.message.incomplete":
      if (t)
        return [t, n];
      throw Error("Received thread message event with no existing snapshot");
  }
  throw Error("Tried to accumulate a non-message event");
}, yd = function(e, t) {
  return wn.accumulateDelta(t, e);
}, wd = function(e) {
  switch (fe(this, ni, e.data), e.event) {
    case "thread.run.created":
      break;
    case "thread.run.queued":
      break;
    case "thread.run.in_progress":
      break;
    case "thread.run.requires_action":
    case "thread.run.cancelled":
    case "thread.run.failed":
    case "thread.run.completed":
    case "thread.run.expired":
    case "thread.run.incomplete":
      fe(this, vn, e.data), I(this, Ft, "f") && (this._emit("toolCallDone", I(this, Ft, "f")), fe(this, Ft, void 0));
      break;
  }
};
let Lu = class extends ie {
  constructor() {
    super(...arguments), this.steps = new Np(this._client);
  }
  create(e, t, n) {
    const { include: s, ...a } = t;
    return this._client.post(F`/threads/${e}/runs`, {
      query: { include: s },
      body: a,
      ...n,
      headers: Y([{ "OpenAI-Beta": "assistants=v2" }, n == null ? void 0 : n.headers]),
      stream: t.stream ?? !1
    });
  }
  /**
   * Retrieves a run.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  retrieve(e, t, n) {
    const { thread_id: s } = t;
    return this._client.get(F`/threads/${s}/runs/${e}`, {
      ...n,
      headers: Y([{ "OpenAI-Beta": "assistants=v2" }, n == null ? void 0 : n.headers])
    });
  }
  /**
   * Modifies a run.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  update(e, t, n) {
    const { thread_id: s, ...a } = t;
    return this._client.post(F`/threads/${s}/runs/${e}`, {
      body: a,
      ...n,
      headers: Y([{ "OpenAI-Beta": "assistants=v2" }, n == null ? void 0 : n.headers])
    });
  }
  /**
   * Returns a list of runs belonging to a thread.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  list(e, t = {}, n) {
    return this._client.getAPIList(F`/threads/${e}/runs`, nt, {
      query: t,
      ...n,
      headers: Y([{ "OpenAI-Beta": "assistants=v2" }, n == null ? void 0 : n.headers])
    });
  }
  /**
   * Cancels a run that is `in_progress`.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  cancel(e, t, n) {
    const { thread_id: s } = t;
    return this._client.post(F`/threads/${s}/runs/${e}/cancel`, {
      ...n,
      headers: Y([{ "OpenAI-Beta": "assistants=v2" }, n == null ? void 0 : n.headers])
    });
  }
  /**
   * A helper to create a run an poll for a terminal state. More information on Run
   * lifecycles can be found here:
   * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
   */
  async createAndPoll(e, t, n) {
    const s = await this.create(e, t, n);
    return await this.poll(s.id, { thread_id: e }, n);
  }
  /**
   * Create a Run stream
   *
   * @deprecated use `stream` instead
   */
  createAndStream(e, t, n) {
    return Ds.createAssistantStream(e, this._client.beta.threads.runs, t, n);
  }
  /**
   * A helper to poll a run status until it reaches a terminal state. More
   * information on Run lifecycles can be found here:
   * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
   */
  async poll(e, t, n) {
    var a;
    const s = Y([
      n == null ? void 0 : n.headers,
      {
        "X-Stainless-Poll-Helper": "true",
        "X-Stainless-Custom-Poll-Interval": ((a = n == null ? void 0 : n.pollIntervalMs) == null ? void 0 : a.toString()) ?? void 0
      }
    ]);
    for (; ; ) {
      const { data: i, response: o } = await this.retrieve(e, t, {
        ...n,
        headers: { ...n == null ? void 0 : n.headers, ...s }
      }).withResponse();
      switch (i.status) {
        case "queued":
        case "in_progress":
        case "cancelling":
          let c = 5e3;
          if (n != null && n.pollIntervalMs)
            c = n.pollIntervalMs;
          else {
            const u = o.headers.get("openai-poll-after-ms");
            if (u) {
              const l = parseInt(u);
              isNaN(l) || (c = l);
            }
          }
          await na(c);
          break;
        case "requires_action":
        case "incomplete":
        case "cancelled":
        case "completed":
        case "failed":
        case "expired":
          return i;
      }
    }
  }
  /**
   * Create a Run stream
   */
  stream(e, t, n) {
    return Ds.createAssistantStream(e, this._client.beta.threads.runs, t, n);
  }
  submitToolOutputs(e, t, n) {
    const { thread_id: s, ...a } = t;
    return this._client.post(F`/threads/${s}/runs/${e}/submit_tool_outputs`, {
      body: a,
      ...n,
      headers: Y([{ "OpenAI-Beta": "assistants=v2" }, n == null ? void 0 : n.headers]),
      stream: t.stream ?? !1
    });
  }
  /**
   * A helper to submit a tool output to a run and poll for a terminal run state.
   * More information on Run lifecycles can be found here:
   * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
   */
  async submitToolOutputsAndPoll(e, t, n) {
    const s = await this.submitToolOutputs(e, t, n);
    return await this.poll(s.id, t, n);
  }
  /**
   * Submit the tool outputs from a previous run and stream the run to a terminal
   * state. More information on Run lifecycles can be found here:
   * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
   */
  submitToolOutputsStream(e, t, n) {
    return Ds.createToolAssistantStream(e, this._client.beta.threads.runs, t, n);
  }
};
Lu.Steps = Np;
class ro extends ie {
  constructor() {
    super(...arguments), this.runs = new Lu(this._client), this.messages = new Rp(this._client);
  }
  /**
   * Create a thread.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  create(e = {}, t) {
    return this._client.post("/threads", {
      body: e,
      ...t,
      headers: Y([{ "OpenAI-Beta": "assistants=v2" }, t == null ? void 0 : t.headers])
    });
  }
  /**
   * Retrieves a thread.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  retrieve(e, t) {
    return this._client.get(F`/threads/${e}`, {
      ...t,
      headers: Y([{ "OpenAI-Beta": "assistants=v2" }, t == null ? void 0 : t.headers])
    });
  }
  /**
   * Modifies a thread.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  update(e, t, n) {
    return this._client.post(F`/threads/${e}`, {
      body: t,
      ...n,
      headers: Y([{ "OpenAI-Beta": "assistants=v2" }, n == null ? void 0 : n.headers])
    });
  }
  /**
   * Delete a thread.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  delete(e, t) {
    return this._client.delete(F`/threads/${e}`, {
      ...t,
      headers: Y([{ "OpenAI-Beta": "assistants=v2" }, t == null ? void 0 : t.headers])
    });
  }
  createAndRun(e, t) {
    return this._client.post("/threads/runs", {
      body: e,
      ...t,
      headers: Y([{ "OpenAI-Beta": "assistants=v2" }, t == null ? void 0 : t.headers]),
      stream: e.stream ?? !1
    });
  }
  /**
   * A helper to create a thread, start a run and then poll for a terminal state.
   * More information on Run lifecycles can be found here:
   * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
   */
  async createAndRunPoll(e, t) {
    const n = await this.createAndRun(e, t);
    return await this.runs.poll(n.id, { thread_id: n.thread_id }, t);
  }
  /**
   * Create a thread and stream the run back
   */
  createAndRunStream(e, t) {
    return Ds.createThreadAssistantStream(e, this._client.beta.threads, t);
  }
}
ro.Runs = Lu;
ro.Messages = Rp;
class cs extends ie {
  constructor() {
    super(...arguments), this.realtime = new eo(this._client), this.chatkit = new to(this._client), this.assistants = new Ip(this._client), this.threads = new ro(this._client);
  }
}
cs.Realtime = eo;
cs.ChatKit = to;
cs.Assistants = Ip;
cs.Threads = ro;
class Pp extends ie {
  create(e, t) {
    return this._client.post("/completions", { body: e, ...t, stream: e.stream ?? !1 });
  }
}
class Lp extends ie {
  /**
   * Retrieve Container File Content
   */
  retrieve(e, t, n) {
    const { container_id: s } = t;
    return this._client.get(F`/containers/${s}/files/${e}/content`, {
      ...n,
      headers: Y([{ Accept: "application/binary" }, n == null ? void 0 : n.headers]),
      __binaryResponse: !0
    });
  }
}
let Mu = class extends ie {
  constructor() {
    super(...arguments), this.content = new Lp(this._client);
  }
  /**
   * Create a Container File
   *
   * You can send either a multipart/form-data request with the raw file content, or
   * a JSON request with a file ID.
   */
  create(e, t, n) {
    return this._client.post(F`/containers/${e}/files`, xn({ body: t, ...n }, this._client));
  }
  /**
   * Retrieve Container File
   */
  retrieve(e, t, n) {
    const { container_id: s } = t;
    return this._client.get(F`/containers/${s}/files/${e}`, n);
  }
  /**
   * List Container files
   */
  list(e, t = {}, n) {
    return this._client.getAPIList(F`/containers/${e}/files`, nt, {
      query: t,
      ...n
    });
  }
  /**
   * Delete Container File
   */
  delete(e, t, n) {
    const { container_id: s } = t;
    return this._client.delete(F`/containers/${s}/files/${e}`, {
      ...n,
      headers: Y([{ Accept: "*/*" }, n == null ? void 0 : n.headers])
    });
  }
};
Mu.Content = Lp;
class Du extends ie {
  constructor() {
    super(...arguments), this.files = new Mu(this._client);
  }
  /**
   * Create Container
   */
  create(e, t) {
    return this._client.post("/containers", { body: e, ...t });
  }
  /**
   * Retrieve Container
   */
  retrieve(e, t) {
    return this._client.get(F`/containers/${e}`, t);
  }
  /**
   * List Containers
   */
  list(e = {}, t) {
    return this._client.getAPIList("/containers", nt, { query: e, ...t });
  }
  /**
   * Delete Container
   */
  delete(e, t) {
    return this._client.delete(F`/containers/${e}`, {
      ...t,
      headers: Y([{ Accept: "*/*" }, t == null ? void 0 : t.headers])
    });
  }
}
Du.Files = Mu;
class Mp extends ie {
  /**
   * Create items in a conversation with the given ID.
   */
  create(e, t, n) {
    const { include: s, ...a } = t;
    return this._client.post(F`/conversations/${e}/items`, {
      query: { include: s },
      body: a,
      ...n
    });
  }
  /**
   * Get a single item from a conversation with the given IDs.
   */
  retrieve(e, t, n) {
    const { conversation_id: s, ...a } = t;
    return this._client.get(F`/conversations/${s}/items/${e}`, { query: a, ...n });
  }
  /**
   * List all items for a conversation with the given ID.
   */
  list(e, t = {}, n) {
    return this._client.getAPIList(F`/conversations/${e}/items`, fi, { query: t, ...n });
  }
  /**
   * Delete an item from a conversation with the given IDs.
   */
  delete(e, t, n) {
    const { conversation_id: s } = t;
    return this._client.delete(F`/conversations/${s}/items/${e}`, n);
  }
}
class ju extends ie {
  constructor() {
    super(...arguments), this.items = new Mp(this._client);
  }
  /**
   * Create a conversation.
   */
  create(e = {}, t) {
    return this._client.post("/conversations", { body: e, ...t });
  }
  /**
   * Get a conversation
   */
  retrieve(e, t) {
    return this._client.get(F`/conversations/${e}`, t);
  }
  /**
   * Update a conversation
   */
  update(e, t, n) {
    return this._client.post(F`/conversations/${e}`, { body: t, ...n });
  }
  /**
   * Delete a conversation. Items in the conversation will not be deleted.
   */
  delete(e, t) {
    return this._client.delete(F`/conversations/${e}`, t);
  }
}
ju.Items = Mp;
let Dp = class extends ie {
  /**
   * Creates an embedding vector representing the input text.
   *
   * @example
   * ```ts
   * const createEmbeddingResponse =
   *   await client.embeddings.create({
   *     input: 'The quick brown fox jumped over the lazy dog',
   *     model: 'text-embedding-3-small',
   *   });
   * ```
   */
  create(e, t) {
    const n = !!e.encoding_format;
    let s = n ? e.encoding_format : "base64";
    n && wt(this._client).debug("embeddings/user defined encoding_format:", e.encoding_format);
    const a = this._client.post("/embeddings", {
      body: {
        ...e,
        encoding_format: s
      },
      ...t
    });
    return n ? a : (wt(this._client).debug("embeddings/decoding base64 embeddings from base64"), a._thenUnwrap((i) => (i && i.data && i.data.forEach((o) => {
      const c = o.embedding;
      o.embedding = kw(c);
    }), i)));
  }
};
class jp extends ie {
  /**
   * Get an evaluation run output item by ID.
   */
  retrieve(e, t, n) {
    const { eval_id: s, run_id: a } = t;
    return this._client.get(F`/evals/${s}/runs/${a}/output_items/${e}`, n);
  }
  /**
   * Get a list of output items for an evaluation run.
   */
  list(e, t, n) {
    const { eval_id: s, ...a } = t;
    return this._client.getAPIList(F`/evals/${s}/runs/${e}/output_items`, nt, { query: a, ...n });
  }
}
class Fu extends ie {
  constructor() {
    super(...arguments), this.outputItems = new jp(this._client);
  }
  /**
   * Kicks off a new run for a given evaluation, specifying the data source, and what
   * model configuration to use to test. The datasource will be validated against the
   * schema specified in the config of the evaluation.
   */
  create(e, t, n) {
    return this._client.post(F`/evals/${e}/runs`, { body: t, ...n });
  }
  /**
   * Get an evaluation run by ID.
   */
  retrieve(e, t, n) {
    const { eval_id: s } = t;
    return this._client.get(F`/evals/${s}/runs/${e}`, n);
  }
  /**
   * Get a list of runs for an evaluation.
   */
  list(e, t = {}, n) {
    return this._client.getAPIList(F`/evals/${e}/runs`, nt, {
      query: t,
      ...n
    });
  }
  /**
   * Delete an eval run.
   */
  delete(e, t, n) {
    const { eval_id: s } = t;
    return this._client.delete(F`/evals/${s}/runs/${e}`, n);
  }
  /**
   * Cancel an ongoing evaluation run.
   */
  cancel(e, t, n) {
    const { eval_id: s } = t;
    return this._client.post(F`/evals/${s}/runs/${e}`, n);
  }
}
Fu.OutputItems = jp;
class Uu extends ie {
  constructor() {
    super(...arguments), this.runs = new Fu(this._client);
  }
  /**
   * Create the structure of an evaluation that can be used to test a model's
   * performance. An evaluation is a set of testing criteria and the config for a
   * data source, which dictates the schema of the data used in the evaluation. After
   * creating an evaluation, you can run it on different models and model parameters.
   * We support several types of graders and datasources. For more information, see
   * the [Evals guide](https://platform.openai.com/docs/guides/evals).
   */
  create(e, t) {
    return this._client.post("/evals", { body: e, ...t });
  }
  /**
   * Get an evaluation by ID.
   */
  retrieve(e, t) {
    return this._client.get(F`/evals/${e}`, t);
  }
  /**
   * Update certain properties of an evaluation.
   */
  update(e, t, n) {
    return this._client.post(F`/evals/${e}`, { body: t, ...n });
  }
  /**
   * List evaluations for a project.
   */
  list(e = {}, t) {
    return this._client.getAPIList("/evals", nt, { query: e, ...t });
  }
  /**
   * Delete an evaluation.
   */
  delete(e, t) {
    return this._client.delete(F`/evals/${e}`, t);
  }
}
Uu.Runs = Fu;
let Fp = class extends ie {
  /**
   * Upload a file that can be used across various endpoints. Individual files can be
   * up to 512 MB, and the size of all files uploaded by one organization can be up
   * to 1 TB.
   *
   * - The Assistants API supports files up to 2 million tokens and of specific file
   *   types. See the
   *   [Assistants Tools guide](https://platform.openai.com/docs/assistants/tools)
   *   for details.
   * - The Fine-tuning API only supports `.jsonl` files. The input also has certain
   *   required formats for fine-tuning
   *   [chat](https://platform.openai.com/docs/api-reference/fine-tuning/chat-input)
   *   or
   *   [completions](https://platform.openai.com/docs/api-reference/fine-tuning/completions-input)
   *   models.
   * - The Batch API only supports `.jsonl` files up to 200 MB in size. The input
   *   also has a specific required
   *   [format](https://platform.openai.com/docs/api-reference/batch/request-input).
   *
   * Please [contact us](https://help.openai.com/) if you need to increase these
   * storage limits.
   */
  create(e, t) {
    return this._client.post("/files", xn({ body: e, ...t }, this._client));
  }
  /**
   * Returns information about a specific file.
   */
  retrieve(e, t) {
    return this._client.get(F`/files/${e}`, t);
  }
  /**
   * Returns a list of files.
   */
  list(e = {}, t) {
    return this._client.getAPIList("/files", nt, { query: e, ...t });
  }
  /**
   * Delete a file and remove it from all vector stores.
   */
  delete(e, t) {
    return this._client.delete(F`/files/${e}`, t);
  }
  /**
   * Returns the contents of the specified file.
   */
  content(e, t) {
    return this._client.get(F`/files/${e}/content`, {
      ...t,
      headers: Y([{ Accept: "application/binary" }, t == null ? void 0 : t.headers]),
      __binaryResponse: !0
    });
  }
  /**
   * Waits for the given file to be processed, default timeout is 30 mins.
   */
  async waitForProcessing(e, { pollInterval: t = 5e3, maxWait: n = 30 * 60 * 1e3 } = {}) {
    const s = /* @__PURE__ */ new Set(["processed", "error", "deleted"]), a = Date.now();
    let i = await this.retrieve(e);
    for (; !i.status || !s.has(i.status); )
      if (await na(t), i = await this.retrieve(e), Date.now() - a > n)
        throw new Ki({
          message: `Giving up on waiting for file ${e} to finish processing after ${n} milliseconds.`
        });
    return i;
  }
};
class Up extends ie {
}
let zp = class extends ie {
  /**
   * Run a grader.
   *
   * @example
   * ```ts
   * const response = await client.fineTuning.alpha.graders.run({
   *   grader: {
   *     input: 'input',
   *     name: 'name',
   *     operation: 'eq',
   *     reference: 'reference',
   *     type: 'string_check',
   *   },
   *   model_sample: 'model_sample',
   * });
   * ```
   */
  run(e, t) {
    return this._client.post("/fine_tuning/alpha/graders/run", { body: e, ...t });
  }
  /**
   * Validate a grader.
   *
   * @example
   * ```ts
   * const response =
   *   await client.fineTuning.alpha.graders.validate({
   *     grader: {
   *       input: 'input',
   *       name: 'name',
   *       operation: 'eq',
   *       reference: 'reference',
   *       type: 'string_check',
   *     },
   *   });
   * ```
   */
  validate(e, t) {
    return this._client.post("/fine_tuning/alpha/graders/validate", { body: e, ...t });
  }
};
class zu extends ie {
  constructor() {
    super(...arguments), this.graders = new zp(this._client);
  }
}
zu.Graders = zp;
class Bp extends ie {
  /**
   * **NOTE:** Calling this endpoint requires an [admin API key](../admin-api-keys).
   *
   * This enables organization owners to share fine-tuned models with other projects
   * in their organization.
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const permissionCreateResponse of client.fineTuning.checkpoints.permissions.create(
   *   'ft:gpt-4o-mini-2024-07-18:org:weather:B7R9VjQd',
   *   { project_ids: ['string'] },
   * )) {
   *   // ...
   * }
   * ```
   */
  create(e, t, n) {
    return this._client.getAPIList(F`/fine_tuning/checkpoints/${e}/permissions`, Qi, { body: t, method: "post", ...n });
  }
  /**
   * **NOTE:** This endpoint requires an [admin API key](../admin-api-keys).
   *
   * Organization owners can use this endpoint to view all permissions for a
   * fine-tuned model checkpoint.
   *
   * @example
   * ```ts
   * const permission =
   *   await client.fineTuning.checkpoints.permissions.retrieve(
   *     'ft-AF1WoRqd3aJAHsqc9NY7iL8F',
   *   );
   * ```
   */
  retrieve(e, t = {}, n) {
    return this._client.get(F`/fine_tuning/checkpoints/${e}/permissions`, {
      query: t,
      ...n
    });
  }
  /**
   * **NOTE:** This endpoint requires an [admin API key](../admin-api-keys).
   *
   * Organization owners can use this endpoint to delete a permission for a
   * fine-tuned model checkpoint.
   *
   * @example
   * ```ts
   * const permission =
   *   await client.fineTuning.checkpoints.permissions.delete(
   *     'cp_zc4Q7MP6XxulcVzj4MZdwsAB',
   *     {
   *       fine_tuned_model_checkpoint:
   *         'ft:gpt-4o-mini-2024-07-18:org:weather:B7R9VjQd',
   *     },
   *   );
   * ```
   */
  delete(e, t, n) {
    const { fine_tuned_model_checkpoint: s } = t;
    return this._client.delete(F`/fine_tuning/checkpoints/${s}/permissions/${e}`, n);
  }
}
let Bu = class extends ie {
  constructor() {
    super(...arguments), this.permissions = new Bp(this._client);
  }
};
Bu.Permissions = Bp;
class Zp extends ie {
  /**
   * List checkpoints for a fine-tuning job.
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const fineTuningJobCheckpoint of client.fineTuning.jobs.checkpoints.list(
   *   'ft-AF1WoRqd3aJAHsqc9NY7iL8F',
   * )) {
   *   // ...
   * }
   * ```
   */
  list(e, t = {}, n) {
    return this._client.getAPIList(F`/fine_tuning/jobs/${e}/checkpoints`, nt, { query: t, ...n });
  }
}
class Zu extends ie {
  constructor() {
    super(...arguments), this.checkpoints = new Zp(this._client);
  }
  /**
   * Creates a fine-tuning job which begins the process of creating a new model from
   * a given dataset.
   *
   * Response includes details of the enqueued job including job status and the name
   * of the fine-tuned models once complete.
   *
   * [Learn more about fine-tuning](https://platform.openai.com/docs/guides/model-optimization)
   *
   * @example
   * ```ts
   * const fineTuningJob = await client.fineTuning.jobs.create({
   *   model: 'gpt-4o-mini',
   *   training_file: 'file-abc123',
   * });
   * ```
   */
  create(e, t) {
    return this._client.post("/fine_tuning/jobs", { body: e, ...t });
  }
  /**
   * Get info about a fine-tuning job.
   *
   * [Learn more about fine-tuning](https://platform.openai.com/docs/guides/model-optimization)
   *
   * @example
   * ```ts
   * const fineTuningJob = await client.fineTuning.jobs.retrieve(
   *   'ft-AF1WoRqd3aJAHsqc9NY7iL8F',
   * );
   * ```
   */
  retrieve(e, t) {
    return this._client.get(F`/fine_tuning/jobs/${e}`, t);
  }
  /**
   * List your organization's fine-tuning jobs
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const fineTuningJob of client.fineTuning.jobs.list()) {
   *   // ...
   * }
   * ```
   */
  list(e = {}, t) {
    return this._client.getAPIList("/fine_tuning/jobs", nt, { query: e, ...t });
  }
  /**
   * Immediately cancel a fine-tune job.
   *
   * @example
   * ```ts
   * const fineTuningJob = await client.fineTuning.jobs.cancel(
   *   'ft-AF1WoRqd3aJAHsqc9NY7iL8F',
   * );
   * ```
   */
  cancel(e, t) {
    return this._client.post(F`/fine_tuning/jobs/${e}/cancel`, t);
  }
  /**
   * Get status updates for a fine-tuning job.
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const fineTuningJobEvent of client.fineTuning.jobs.listEvents(
   *   'ft-AF1WoRqd3aJAHsqc9NY7iL8F',
   * )) {
   *   // ...
   * }
   * ```
   */
  listEvents(e, t = {}, n) {
    return this._client.getAPIList(F`/fine_tuning/jobs/${e}/events`, nt, { query: t, ...n });
  }
  /**
   * Pause a fine-tune job.
   *
   * @example
   * ```ts
   * const fineTuningJob = await client.fineTuning.jobs.pause(
   *   'ft-AF1WoRqd3aJAHsqc9NY7iL8F',
   * );
   * ```
   */
  pause(e, t) {
    return this._client.post(F`/fine_tuning/jobs/${e}/pause`, t);
  }
  /**
   * Resume a fine-tune job.
   *
   * @example
   * ```ts
   * const fineTuningJob = await client.fineTuning.jobs.resume(
   *   'ft-AF1WoRqd3aJAHsqc9NY7iL8F',
   * );
   * ```
   */
  resume(e, t) {
    return this._client.post(F`/fine_tuning/jobs/${e}/resume`, t);
  }
}
Zu.Checkpoints = Zp;
class us extends ie {
  constructor() {
    super(...arguments), this.methods = new Up(this._client), this.jobs = new Zu(this._client), this.checkpoints = new Bu(this._client), this.alpha = new zu(this._client);
  }
}
us.Methods = Up;
us.Jobs = Zu;
us.Checkpoints = Bu;
us.Alpha = zu;
class Vp extends ie {
}
class Vu extends ie {
  constructor() {
    super(...arguments), this.graderModels = new Vp(this._client);
  }
}
Vu.GraderModels = Vp;
class qp extends ie {
  /**
   * Creates a variation of a given image. This endpoint only supports `dall-e-2`.
   *
   * @example
   * ```ts
   * const imagesResponse = await client.images.createVariation({
   *   image: fs.createReadStream('otter.png'),
   * });
   * ```
   */
  createVariation(e, t) {
    return this._client.post("/images/variations", xn({ body: e, ...t }, this._client));
  }
  edit(e, t) {
    return this._client.post("/images/edits", xn({ body: e, ...t, stream: e.stream ?? !1 }, this._client));
  }
  generate(e, t) {
    return this._client.post("/images/generations", { body: e, ...t, stream: e.stream ?? !1 });
  }
}
class Jp extends ie {
  /**
   * Retrieves a model instance, providing basic information about the model such as
   * the owner and permissioning.
   */
  retrieve(e, t) {
    return this._client.get(F`/models/${e}`, t);
  }
  /**
   * Lists the currently available models, and provides basic information about each
   * one such as the owner and availability.
   */
  list(e) {
    return this._client.getAPIList("/models", Qi, e);
  }
  /**
   * Delete a fine-tuned model. You must have the Owner role in your organization to
   * delete a model.
   */
  delete(e, t) {
    return this._client.delete(F`/models/${e}`, t);
  }
}
class Hp extends ie {
  /**
   * Classifies if text and/or image inputs are potentially harmful. Learn more in
   * the [moderation guide](https://platform.openai.com/docs/guides/moderation).
   */
  create(e, t) {
    return this._client.post("/moderations", { body: e, ...t });
  }
}
class Gp extends ie {
  /**
   * Accept an incoming SIP call and configure the realtime session that will handle
   * it.
   *
   * @example
   * ```ts
   * await client.realtime.calls.accept('call_id', {
   *   type: 'realtime',
   * });
   * ```
   */
  accept(e, t, n) {
    return this._client.post(F`/realtime/calls/${e}/accept`, {
      body: t,
      ...n,
      headers: Y([{ Accept: "*/*" }, n == null ? void 0 : n.headers])
    });
  }
  /**
   * End an active Realtime API call, whether it was initiated over SIP or WebRTC.
   *
   * @example
   * ```ts
   * await client.realtime.calls.hangup('call_id');
   * ```
   */
  hangup(e, t) {
    return this._client.post(F`/realtime/calls/${e}/hangup`, {
      ...t,
      headers: Y([{ Accept: "*/*" }, t == null ? void 0 : t.headers])
    });
  }
  /**
   * Transfer an active SIP call to a new destination using the SIP REFER verb.
   *
   * @example
   * ```ts
   * await client.realtime.calls.refer('call_id', {
   *   target_uri: 'tel:+14155550123',
   * });
   * ```
   */
  refer(e, t, n) {
    return this._client.post(F`/realtime/calls/${e}/refer`, {
      body: t,
      ...n,
      headers: Y([{ Accept: "*/*" }, n == null ? void 0 : n.headers])
    });
  }
  /**
   * Decline an incoming SIP call by returning a SIP status code to the caller.
   *
   * @example
   * ```ts
   * await client.realtime.calls.reject('call_id');
   * ```
   */
  reject(e, t = {}, n) {
    return this._client.post(F`/realtime/calls/${e}/reject`, {
      body: t,
      ...n,
      headers: Y([{ Accept: "*/*" }, n == null ? void 0 : n.headers])
    });
  }
}
class Wp extends ie {
  /**
   * Create a Realtime client secret with an associated session configuration.
   *
   * @example
   * ```ts
   * const clientSecret =
   *   await client.realtime.clientSecrets.create();
   * ```
   */
  create(e, t) {
    return this._client.post("/realtime/client_secrets", { body: e, ...t });
  }
}
class no extends ie {
  constructor() {
    super(...arguments), this.clientSecrets = new Wp(this._client), this.calls = new Gp(this._client);
  }
}
no.ClientSecrets = Wp;
no.Calls = Gp;
function Iw(r, e) {
  return !e || !Aw(e) ? {
    ...r,
    output_parsed: null,
    output: r.output.map((t) => t.type === "function_call" ? {
      ...t,
      parsed_arguments: null
    } : t.type === "message" ? {
      ...t,
      content: t.content.map((n) => ({
        ...n,
        parsed: null
      }))
    } : t)
  } : Kp(r, e);
}
function Kp(r, e) {
  const t = r.output.map((s) => {
    if (s.type === "function_call")
      return {
        ...s,
        parsed_arguments: Rw(e, s)
      };
    if (s.type === "message") {
      const a = s.content.map((i) => i.type === "output_text" ? {
        ...i,
        parsed: Ow(e, i.text)
      } : i);
      return {
        ...s,
        content: a
      };
    }
    return s;
  }), n = Object.assign({}, r, { output: t });
  return Object.getOwnPropertyDescriptor(r, "output_text") || Rc(n), Object.defineProperty(n, "output_parsed", {
    enumerable: !0,
    get() {
      for (const s of n.output)
        if (s.type === "message") {
          for (const a of s.content)
            if (a.type === "output_text" && a.parsed !== null)
              return a.parsed;
        }
      return null;
    }
  }), n;
}
function Ow(r, e) {
  var t, n, s, a;
  return ((n = (t = r.text) == null ? void 0 : t.format) == null ? void 0 : n.type) !== "json_schema" ? null : "$parseRaw" in ((s = r.text) == null ? void 0 : s.format) ? ((a = r.text) == null ? void 0 : a.format).$parseRaw(e) : JSON.parse(e);
}
function Aw(r) {
  var e;
  return !!Au((e = r.text) == null ? void 0 : e.format);
}
function $w(r) {
  return (r == null ? void 0 : r.$brand) === "auto-parseable-tool";
}
function Cw(r, e) {
  return r.find((t) => t.type === "function" && t.name === e);
}
function Rw(r, e) {
  const t = Cw(r.tools ?? [], e.name);
  return {
    ...e,
    ...e,
    parsed_arguments: $w(t) ? t.$parseRaw(e.arguments) : t != null && t.strict ? JSON.parse(e.arguments) : null
  };
}
function Rc(r) {
  const e = [];
  for (const t of r.output)
    if (t.type === "message")
      for (const n of t.content)
        n.type === "output_text" && e.push(n.text);
  r.output_text = e.join("");
}
var Pn, Oa, Gr, Aa, vd, bd, Sd, Td;
class qu extends Cu {
  constructor(e) {
    super(), Pn.add(this), Oa.set(this, void 0), Gr.set(this, void 0), Aa.set(this, void 0), fe(this, Oa, e);
  }
  static createResponse(e, t, n) {
    const s = new qu(t);
    return s._run(() => s._createOrRetrieveResponse(e, t, {
      ...n,
      headers: { ...n == null ? void 0 : n.headers, "X-Stainless-Helper-Method": "stream" }
    })), s;
  }
  async _createOrRetrieveResponse(e, t, n) {
    var o;
    const s = n == null ? void 0 : n.signal;
    s && (s.aborted && this.controller.abort(), s.addEventListener("abort", () => this.controller.abort())), I(this, Pn, "m", vd).call(this);
    let a, i = null;
    "response_id" in t ? (a = await e.responses.retrieve(t.response_id, { stream: !0 }, { ...n, signal: this.controller.signal, stream: !0 }), i = t.starting_after ?? null) : a = await e.responses.create({ ...t, stream: !0 }, { ...n, signal: this.controller.signal }), this._connected();
    for await (const c of a)
      I(this, Pn, "m", bd).call(this, c, i);
    if ((o = a.controller.signal) != null && o.aborted)
      throw new Ut();
    return I(this, Pn, "m", Sd).call(this);
  }
  [(Oa = /* @__PURE__ */ new WeakMap(), Gr = /* @__PURE__ */ new WeakMap(), Aa = /* @__PURE__ */ new WeakMap(), Pn = /* @__PURE__ */ new WeakSet(), vd = function() {
    this.ended || fe(this, Gr, void 0);
  }, bd = function(t, n) {
    if (this.ended)
      return;
    const s = (i, o) => {
      (n == null || o.sequence_number > n) && this._emit(i, o);
    }, a = I(this, Pn, "m", Td).call(this, t);
    switch (s("event", t), t.type) {
      case "response.output_text.delta": {
        const i = a.output[t.output_index];
        if (!i)
          throw new ce(`missing output at index ${t.output_index}`);
        if (i.type === "message") {
          const o = i.content[t.content_index];
          if (!o)
            throw new ce(`missing content at index ${t.content_index}`);
          if (o.type !== "output_text")
            throw new ce(`expected content to be 'output_text', got ${o.type}`);
          s("response.output_text.delta", {
            ...t,
            snapshot: o.text
          });
        }
        break;
      }
      case "response.function_call_arguments.delta": {
        const i = a.output[t.output_index];
        if (!i)
          throw new ce(`missing output at index ${t.output_index}`);
        i.type === "function_call" && s("response.function_call_arguments.delta", {
          ...t,
          snapshot: i.arguments
        });
        break;
      }
      default:
        s(t.type, t);
        break;
    }
  }, Sd = function() {
    if (this.ended)
      throw new ce("stream has ended, this shouldn't happen");
    const t = I(this, Gr, "f");
    if (!t)
      throw new ce("request ended without sending any events");
    fe(this, Gr, void 0);
    const n = Nw(t, I(this, Oa, "f"));
    return fe(this, Aa, n), n;
  }, Td = function(t) {
    var s;
    let n = I(this, Gr, "f");
    if (!n) {
      if (t.type !== "response.created")
        throw new ce(`When snapshot hasn't been set yet, expected 'response.created' event, got ${t.type}`);
      return n = fe(this, Gr, t.response), n;
    }
    switch (t.type) {
      case "response.output_item.added": {
        n.output.push(t.item);
        break;
      }
      case "response.content_part.added": {
        const a = n.output[t.output_index];
        if (!a)
          throw new ce(`missing output at index ${t.output_index}`);
        const i = a.type, o = t.part;
        i === "message" && o.type !== "reasoning_text" ? a.content.push(o) : i === "reasoning" && o.type === "reasoning_text" && (a.content || (a.content = []), a.content.push(o));
        break;
      }
      case "response.output_text.delta": {
        const a = n.output[t.output_index];
        if (!a)
          throw new ce(`missing output at index ${t.output_index}`);
        if (a.type === "message") {
          const i = a.content[t.content_index];
          if (!i)
            throw new ce(`missing content at index ${t.content_index}`);
          if (i.type !== "output_text")
            throw new ce(`expected content to be 'output_text', got ${i.type}`);
          i.text += t.delta;
        }
        break;
      }
      case "response.function_call_arguments.delta": {
        const a = n.output[t.output_index];
        if (!a)
          throw new ce(`missing output at index ${t.output_index}`);
        a.type === "function_call" && (a.arguments += t.delta);
        break;
      }
      case "response.reasoning_text.delta": {
        const a = n.output[t.output_index];
        if (!a)
          throw new ce(`missing output at index ${t.output_index}`);
        if (a.type === "reasoning") {
          const i = (s = a.content) == null ? void 0 : s[t.content_index];
          if (!i)
            throw new ce(`missing content at index ${t.content_index}`);
          if (i.type !== "reasoning_text")
            throw new ce(`expected content to be 'reasoning_text', got ${i.type}`);
          i.text += t.delta;
        }
        break;
      }
      case "response.completed": {
        fe(this, Gr, t.response);
        break;
      }
    }
    return n;
  }, Symbol.asyncIterator)]() {
    const e = [], t = [];
    let n = !1;
    return this.on("event", (s) => {
      const a = t.shift();
      a ? a.resolve(s) : e.push(s);
    }), this.on("end", () => {
      n = !0;
      for (const s of t)
        s.resolve(void 0);
      t.length = 0;
    }), this.on("abort", (s) => {
      n = !0;
      for (const a of t)
        a.reject(s);
      t.length = 0;
    }), this.on("error", (s) => {
      n = !0;
      for (const a of t)
        a.reject(s);
      t.length = 0;
    }), {
      next: async () => e.length ? { value: e.shift(), done: !1 } : n ? { value: void 0, done: !0 } : new Promise((a, i) => t.push({ resolve: a, reject: i })).then((a) => a ? { value: a, done: !1 } : { value: void 0, done: !0 }),
      return: async () => (this.abort(), { value: void 0, done: !0 })
    };
  }
  /**
   * @returns a promise that resolves with the final Response, or rejects
   * if an error occurred or the stream ended prematurely without producing a REsponse.
   */
  async finalResponse() {
    await this.done();
    const e = I(this, Aa, "f");
    if (!e)
      throw new ce("stream ended without producing a ChatCompletion");
    return e;
  }
}
function Nw(r, e) {
  return Iw(r, e);
}
class Yp extends ie {
  /**
   * Returns a list of input items for a given response.
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const responseItem of client.responses.inputItems.list(
   *   'response_id',
   * )) {
   *   // ...
   * }
   * ```
   */
  list(e, t = {}, n) {
    return this._client.getAPIList(F`/responses/${e}/input_items`, nt, { query: t, ...n });
  }
}
class Xp extends ie {
  /**
   * Get input token counts
   *
   * @example
   * ```ts
   * const response = await client.responses.inputTokens.count();
   * ```
   */
  count(e = {}, t) {
    return this._client.post("/responses/input_tokens", { body: e, ...t });
  }
}
class so extends ie {
  constructor() {
    super(...arguments), this.inputItems = new Yp(this._client), this.inputTokens = new Xp(this._client);
  }
  create(e, t) {
    return this._client.post("/responses", { body: e, ...t, stream: e.stream ?? !1 })._thenUnwrap((n) => ("object" in n && n.object === "response" && Rc(n), n));
  }
  retrieve(e, t = {}, n) {
    return this._client.get(F`/responses/${e}`, {
      query: t,
      ...n,
      stream: (t == null ? void 0 : t.stream) ?? !1
    })._thenUnwrap((s) => ("object" in s && s.object === "response" && Rc(s), s));
  }
  /**
   * Deletes a model response with the given ID.
   *
   * @example
   * ```ts
   * await client.responses.delete(
   *   'resp_677efb5139a88190b512bc3fef8e535d',
   * );
   * ```
   */
  delete(e, t) {
    return this._client.delete(F`/responses/${e}`, {
      ...t,
      headers: Y([{ Accept: "*/*" }, t == null ? void 0 : t.headers])
    });
  }
  parse(e, t) {
    return this._client.responses.create(e, t)._thenUnwrap((n) => Kp(n, e));
  }
  /**
   * Creates a model response stream
   */
  stream(e, t) {
    return qu.createResponse(this._client, e, t);
  }
  /**
   * Cancels a model response with the given ID. Only responses created with the
   * `background` parameter set to `true` can be cancelled.
   * [Learn more](https://platform.openai.com/docs/guides/background).
   *
   * @example
   * ```ts
   * const response = await client.responses.cancel(
   *   'resp_677efb5139a88190b512bc3fef8e535d',
   * );
   * ```
   */
  cancel(e, t) {
    return this._client.post(F`/responses/${e}/cancel`, t);
  }
  /**
   * Compact conversation
   *
   * @example
   * ```ts
   * const compactedResponse = await client.responses.compact();
   * ```
   */
  compact(e = {}, t) {
    return this._client.post("/responses/compact", { body: e, ...t });
  }
}
so.InputItems = Yp;
so.InputTokens = Xp;
class Qp extends ie {
  /**
   * Adds a
   * [Part](https://platform.openai.com/docs/api-reference/uploads/part-object) to an
   * [Upload](https://platform.openai.com/docs/api-reference/uploads/object) object.
   * A Part represents a chunk of bytes from the file you are trying to upload.
   *
   * Each Part can be at most 64 MB, and you can add Parts until you hit the Upload
   * maximum of 8 GB.
   *
   * It is possible to add multiple Parts in parallel. You can decide the intended
   * order of the Parts when you
   * [complete the Upload](https://platform.openai.com/docs/api-reference/uploads/complete).
   */
  create(e, t, n) {
    return this._client.post(F`/uploads/${e}/parts`, xn({ body: t, ...n }, this._client));
  }
}
class Ju extends ie {
  constructor() {
    super(...arguments), this.parts = new Qp(this._client);
  }
  /**
   * Creates an intermediate
   * [Upload](https://platform.openai.com/docs/api-reference/uploads/object) object
   * that you can add
   * [Parts](https://platform.openai.com/docs/api-reference/uploads/part-object) to.
   * Currently, an Upload can accept at most 8 GB in total and expires after an hour
   * after you create it.
   *
   * Once you complete the Upload, we will create a
   * [File](https://platform.openai.com/docs/api-reference/files/object) object that
   * contains all the parts you uploaded. This File is usable in the rest of our
   * platform as a regular File object.
   *
   * For certain `purpose` values, the correct `mime_type` must be specified. Please
   * refer to documentation for the
   * [supported MIME types for your use case](https://platform.openai.com/docs/assistants/tools/file-search#supported-files).
   *
   * For guidance on the proper filename extensions for each purpose, please follow
   * the documentation on
   * [creating a File](https://platform.openai.com/docs/api-reference/files/create).
   */
  create(e, t) {
    return this._client.post("/uploads", { body: e, ...t });
  }
  /**
   * Cancels the Upload. No Parts may be added after an Upload is cancelled.
   */
  cancel(e, t) {
    return this._client.post(F`/uploads/${e}/cancel`, t);
  }
  /**
   * Completes the
   * [Upload](https://platform.openai.com/docs/api-reference/uploads/object).
   *
   * Within the returned Upload object, there is a nested
   * [File](https://platform.openai.com/docs/api-reference/files/object) object that
   * is ready to use in the rest of the platform.
   *
   * You can specify the order of the Parts by passing in an ordered list of the Part
   * IDs.
   *
   * The number of bytes uploaded upon completion must match the number of bytes
   * initially specified when creating the Upload object. No Parts may be added after
   * an Upload is completed.
   */
  complete(e, t, n) {
    return this._client.post(F`/uploads/${e}/complete`, { body: t, ...n });
  }
}
Ju.Parts = Qp;
const Pw = async (r) => {
  const e = await Promise.allSettled(r), t = e.filter((s) => s.status === "rejected");
  if (t.length) {
    for (const s of t)
      console.error(s.reason);
    throw new Error(`${t.length} promise(s) failed - see the above errors`);
  }
  const n = [];
  for (const s of e)
    s.status === "fulfilled" && n.push(s.value);
  return n;
};
class em extends ie {
  /**
   * Create a vector store file batch.
   */
  create(e, t, n) {
    return this._client.post(F`/vector_stores/${e}/file_batches`, {
      body: t,
      ...n,
      headers: Y([{ "OpenAI-Beta": "assistants=v2" }, n == null ? void 0 : n.headers])
    });
  }
  /**
   * Retrieves a vector store file batch.
   */
  retrieve(e, t, n) {
    const { vector_store_id: s } = t;
    return this._client.get(F`/vector_stores/${s}/file_batches/${e}`, {
      ...n,
      headers: Y([{ "OpenAI-Beta": "assistants=v2" }, n == null ? void 0 : n.headers])
    });
  }
  /**
   * Cancel a vector store file batch. This attempts to cancel the processing of
   * files in this batch as soon as possible.
   */
  cancel(e, t, n) {
    const { vector_store_id: s } = t;
    return this._client.post(F`/vector_stores/${s}/file_batches/${e}/cancel`, {
      ...n,
      headers: Y([{ "OpenAI-Beta": "assistants=v2" }, n == null ? void 0 : n.headers])
    });
  }
  /**
   * Create a vector store batch and poll until all files have been processed.
   */
  async createAndPoll(e, t, n) {
    const s = await this.create(e, t);
    return await this.poll(e, s.id, n);
  }
  /**
   * Returns a list of vector store files in a batch.
   */
  listFiles(e, t, n) {
    const { vector_store_id: s, ...a } = t;
    return this._client.getAPIList(F`/vector_stores/${s}/file_batches/${e}/files`, nt, { query: a, ...n, headers: Y([{ "OpenAI-Beta": "assistants=v2" }, n == null ? void 0 : n.headers]) });
  }
  /**
   * Wait for the given file batch to be processed.
   *
   * Note: this will return even if one of the files failed to process, you need to
   * check batch.file_counts.failed_count to handle this case.
   */
  async poll(e, t, n) {
    var a;
    const s = Y([
      n == null ? void 0 : n.headers,
      {
        "X-Stainless-Poll-Helper": "true",
        "X-Stainless-Custom-Poll-Interval": ((a = n == null ? void 0 : n.pollIntervalMs) == null ? void 0 : a.toString()) ?? void 0
      }
    ]);
    for (; ; ) {
      const { data: i, response: o } = await this.retrieve(t, { vector_store_id: e }, {
        ...n,
        headers: s
      }).withResponse();
      switch (i.status) {
        case "in_progress":
          let c = 5e3;
          if (n != null && n.pollIntervalMs)
            c = n.pollIntervalMs;
          else {
            const u = o.headers.get("openai-poll-after-ms");
            if (u) {
              const l = parseInt(u);
              isNaN(l) || (c = l);
            }
          }
          await na(c);
          break;
        case "failed":
        case "cancelled":
        case "completed":
          return i;
      }
    }
  }
  /**
   * Uploads the given files concurrently and then creates a vector store file batch.
   *
   * The concurrency limit is configurable using the `maxConcurrency` parameter.
   */
  async uploadAndPoll(e, { files: t, fileIds: n = [] }, s) {
    if (t == null || t.length == 0)
      throw new Error("No `files` provided to process. If you've already uploaded files you should use `.createAndPoll()` instead");
    const a = (s == null ? void 0 : s.maxConcurrency) ?? 5, i = Math.min(a, t.length), o = this._client, c = t.values(), u = [...n];
    async function l(h) {
      for (let f of h) {
        const p = await o.files.create({ file: f, purpose: "assistants" }, s);
        u.push(p.id);
      }
    }
    const d = Array(i).fill(c).map(l);
    return await Pw(d), await this.createAndPoll(e, {
      file_ids: u
    });
  }
}
class tm extends ie {
  /**
   * Create a vector store file by attaching a
   * [File](https://platform.openai.com/docs/api-reference/files) to a
   * [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object).
   */
  create(e, t, n) {
    return this._client.post(F`/vector_stores/${e}/files`, {
      body: t,
      ...n,
      headers: Y([{ "OpenAI-Beta": "assistants=v2" }, n == null ? void 0 : n.headers])
    });
  }
  /**
   * Retrieves a vector store file.
   */
  retrieve(e, t, n) {
    const { vector_store_id: s } = t;
    return this._client.get(F`/vector_stores/${s}/files/${e}`, {
      ...n,
      headers: Y([{ "OpenAI-Beta": "assistants=v2" }, n == null ? void 0 : n.headers])
    });
  }
  /**
   * Update attributes on a vector store file.
   */
  update(e, t, n) {
    const { vector_store_id: s, ...a } = t;
    return this._client.post(F`/vector_stores/${s}/files/${e}`, {
      body: a,
      ...n,
      headers: Y([{ "OpenAI-Beta": "assistants=v2" }, n == null ? void 0 : n.headers])
    });
  }
  /**
   * Returns a list of vector store files.
   */
  list(e, t = {}, n) {
    return this._client.getAPIList(F`/vector_stores/${e}/files`, nt, {
      query: t,
      ...n,
      headers: Y([{ "OpenAI-Beta": "assistants=v2" }, n == null ? void 0 : n.headers])
    });
  }
  /**
   * Delete a vector store file. This will remove the file from the vector store but
   * the file itself will not be deleted. To delete the file, use the
   * [delete file](https://platform.openai.com/docs/api-reference/files/delete)
   * endpoint.
   */
  delete(e, t, n) {
    const { vector_store_id: s } = t;
    return this._client.delete(F`/vector_stores/${s}/files/${e}`, {
      ...n,
      headers: Y([{ "OpenAI-Beta": "assistants=v2" }, n == null ? void 0 : n.headers])
    });
  }
  /**
   * Attach a file to the given vector store and wait for it to be processed.
   */
  async createAndPoll(e, t, n) {
    const s = await this.create(e, t, n);
    return await this.poll(e, s.id, n);
  }
  /**
   * Wait for the vector store file to finish processing.
   *
   * Note: this will return even if the file failed to process, you need to check
   * file.last_error and file.status to handle these cases
   */
  async poll(e, t, n) {
    var a;
    const s = Y([
      n == null ? void 0 : n.headers,
      {
        "X-Stainless-Poll-Helper": "true",
        "X-Stainless-Custom-Poll-Interval": ((a = n == null ? void 0 : n.pollIntervalMs) == null ? void 0 : a.toString()) ?? void 0
      }
    ]);
    for (; ; ) {
      const i = await this.retrieve(t, {
        vector_store_id: e
      }, { ...n, headers: s }).withResponse(), o = i.data;
      switch (o.status) {
        case "in_progress":
          let c = 5e3;
          if (n != null && n.pollIntervalMs)
            c = n.pollIntervalMs;
          else {
            const u = i.response.headers.get("openai-poll-after-ms");
            if (u) {
              const l = parseInt(u);
              isNaN(l) || (c = l);
            }
          }
          await na(c);
          break;
        case "failed":
        case "completed":
          return o;
      }
    }
  }
  /**
   * Upload a file to the `files` API and then attach it to the given vector store.
   *
   * Note the file will be asynchronously processed (you can use the alternative
   * polling helper method to wait for processing to complete).
   */
  async upload(e, t, n) {
    const s = await this._client.files.create({ file: t, purpose: "assistants" }, n);
    return this.create(e, { file_id: s.id }, n);
  }
  /**
   * Add a file to a vector store and poll until processing is complete.
   */
  async uploadAndPoll(e, t, n) {
    const s = await this.upload(e, t, n);
    return await this.poll(e, s.id, n);
  }
  /**
   * Retrieve the parsed contents of a vector store file.
   */
  content(e, t, n) {
    const { vector_store_id: s } = t;
    return this._client.getAPIList(F`/vector_stores/${s}/files/${e}/content`, Qi, { ...n, headers: Y([{ "OpenAI-Beta": "assistants=v2" }, n == null ? void 0 : n.headers]) });
  }
}
class ao extends ie {
  constructor() {
    super(...arguments), this.files = new tm(this._client), this.fileBatches = new em(this._client);
  }
  /**
   * Create a vector store.
   */
  create(e, t) {
    return this._client.post("/vector_stores", {
      body: e,
      ...t,
      headers: Y([{ "OpenAI-Beta": "assistants=v2" }, t == null ? void 0 : t.headers])
    });
  }
  /**
   * Retrieves a vector store.
   */
  retrieve(e, t) {
    return this._client.get(F`/vector_stores/${e}`, {
      ...t,
      headers: Y([{ "OpenAI-Beta": "assistants=v2" }, t == null ? void 0 : t.headers])
    });
  }
  /**
   * Modifies a vector store.
   */
  update(e, t, n) {
    return this._client.post(F`/vector_stores/${e}`, {
      body: t,
      ...n,
      headers: Y([{ "OpenAI-Beta": "assistants=v2" }, n == null ? void 0 : n.headers])
    });
  }
  /**
   * Returns a list of vector stores.
   */
  list(e = {}, t) {
    return this._client.getAPIList("/vector_stores", nt, {
      query: e,
      ...t,
      headers: Y([{ "OpenAI-Beta": "assistants=v2" }, t == null ? void 0 : t.headers])
    });
  }
  /**
   * Delete a vector store.
   */
  delete(e, t) {
    return this._client.delete(F`/vector_stores/${e}`, {
      ...t,
      headers: Y([{ "OpenAI-Beta": "assistants=v2" }, t == null ? void 0 : t.headers])
    });
  }
  /**
   * Search a vector store for relevant chunks based on a query and file attributes
   * filter.
   */
  search(e, t, n) {
    return this._client.getAPIList(F`/vector_stores/${e}/search`, Qi, {
      body: t,
      method: "post",
      ...n,
      headers: Y([{ "OpenAI-Beta": "assistants=v2" }, n == null ? void 0 : n.headers])
    });
  }
}
ao.Files = tm;
ao.FileBatches = em;
class rm extends ie {
  /**
   * Create a video
   */
  create(e, t) {
    return this._client.post("/videos", cd({ body: e, ...t }, this._client));
  }
  /**
   * Retrieve a video
   */
  retrieve(e, t) {
    return this._client.get(F`/videos/${e}`, t);
  }
  /**
   * List videos
   */
  list(e = {}, t) {
    return this._client.getAPIList("/videos", fi, { query: e, ...t });
  }
  /**
   * Delete a video
   */
  delete(e, t) {
    return this._client.delete(F`/videos/${e}`, t);
  }
  /**
   * Download video content
   */
  downloadContent(e, t = {}, n) {
    return this._client.get(F`/videos/${e}/content`, {
      query: t,
      ...n,
      headers: Y([{ Accept: "application/binary" }, n == null ? void 0 : n.headers]),
      __binaryResponse: !0
    });
  }
  /**
   * Create a video remix
   */
  remix(e, t, n) {
    return this._client.post(F`/videos/${e}/remix`, cd({ body: t, ...n }, this._client));
  }
}
var Fn, nm, si;
class sm extends ie {
  constructor() {
    super(...arguments), Fn.add(this);
  }
  /**
   * Validates that the given payload was sent by OpenAI and parses the payload.
   */
  async unwrap(e, t, n = this._client.webhookSecret, s = 300) {
    return await this.verifySignature(e, t, n, s), JSON.parse(e);
  }
  /**
   * Validates whether or not the webhook payload was sent by OpenAI.
   *
   * An error will be raised if the webhook payload was not sent by OpenAI.
   *
   * @param payload - The webhook payload
   * @param headers - The webhook headers
   * @param secret - The webhook secret (optional, will use client secret if not provided)
   * @param tolerance - Maximum age of the webhook in seconds (default: 300 = 5 minutes)
   */
  async verifySignature(e, t, n = this._client.webhookSecret, s = 300) {
    if (typeof crypto > "u" || typeof crypto.subtle.importKey != "function" || typeof crypto.subtle.verify != "function")
      throw new Error("Webhook signature verification is only supported when the `crypto` global is defined");
    I(this, Fn, "m", nm).call(this, n);
    const a = Y([t]).values, i = I(this, Fn, "m", si).call(this, a, "webhook-signature"), o = I(this, Fn, "m", si).call(this, a, "webhook-timestamp"), c = I(this, Fn, "m", si).call(this, a, "webhook-id"), u = parseInt(o, 10);
    if (isNaN(u))
      throw new _s("Invalid webhook timestamp format");
    const l = Math.floor(Date.now() / 1e3);
    if (l - u > s)
      throw new _s("Webhook timestamp is too old");
    if (u > l + s)
      throw new _s("Webhook timestamp is too new");
    const d = i.split(" ").map((y) => y.startsWith("v1,") ? y.substring(3) : y), h = n.startsWith("whsec_") ? Buffer.from(n.replace("whsec_", ""), "base64") : Buffer.from(n, "utf-8"), f = c ? `${c}.${o}.${e}` : `${o}.${e}`, p = await crypto.subtle.importKey("raw", h, { name: "HMAC", hash: "SHA-256" }, !1, ["verify"]);
    for (const y of d)
      try {
        const m = Buffer.from(y, "base64");
        if (await crypto.subtle.verify("HMAC", p, m, new TextEncoder().encode(f)))
          return;
      } catch {
        continue;
      }
    throw new _s("The given webhook signature does not match the expected signature");
  }
}
Fn = /* @__PURE__ */ new WeakSet(), nm = function(e) {
  if (typeof e != "string" || e.length === 0)
    throw new Error("The webhook secret must either be set using the env var, OPENAI_WEBHOOK_SECRET, on the client class, OpenAI({ webhookSecret: '123' }), or passed to this function");
}, si = function(e, t) {
  if (!e)
    throw new Error("Headers are required");
  const n = e.get(t);
  if (n == null)
    throw new Error(`Missing required header: ${t}`);
  return n;
};
var Nc, Hu, ai, am;
class xe {
  /**
   * API Client for interfacing with the OpenAI API.
   *
   * @param {string | undefined} [opts.apiKey=process.env['OPENAI_API_KEY'] ?? undefined]
   * @param {string | null | undefined} [opts.organization=process.env['OPENAI_ORG_ID'] ?? null]
   * @param {string | null | undefined} [opts.project=process.env['OPENAI_PROJECT_ID'] ?? null]
   * @param {string | null | undefined} [opts.webhookSecret=process.env['OPENAI_WEBHOOK_SECRET'] ?? null]
   * @param {string} [opts.baseURL=process.env['OPENAI_BASE_URL'] ?? https://api.openai.com/v1] - Override the default base URL for the API.
   * @param {number} [opts.timeout=10 minutes] - The maximum amount of time (in milliseconds) the client will wait for a response before timing out.
   * @param {MergedRequestInit} [opts.fetchOptions] - Additional `RequestInit` options to be passed to `fetch` calls.
   * @param {Fetch} [opts.fetch] - Specify a custom `fetch` function implementation.
   * @param {number} [opts.maxRetries=2] - The maximum number of times the client will retry a request.
   * @param {HeadersLike} opts.defaultHeaders - Default headers to include with every request to the API.
   * @param {Record<string, string | undefined>} opts.defaultQuery - Default query parameters to include with every request to the API.
   * @param {boolean} [opts.dangerouslyAllowBrowser=false] - By default, client-side use of this library is not allowed, as it risks exposing your secret API credentials to attackers.
   */
  constructor({ baseURL: e = Nn("OPENAI_BASE_URL"), apiKey: t = Nn("OPENAI_API_KEY"), organization: n = Nn("OPENAI_ORG_ID") ?? null, project: s = Nn("OPENAI_PROJECT_ID") ?? null, webhookSecret: a = Nn("OPENAI_WEBHOOK_SECRET") ?? null, ...i } = {}) {
    if (Nc.add(this), ai.set(this, void 0), this.completions = new Pp(this), this.chat = new Pu(this), this.embeddings = new Dp(this), this.files = new Fp(this), this.images = new qp(this), this.audio = new aa(this), this.moderations = new Hp(this), this.models = new Jp(this), this.fineTuning = new us(this), this.graders = new Vu(this), this.vectorStores = new ao(this), this.webhooks = new sm(this), this.beta = new cs(this), this.batches = new kp(this), this.uploads = new Ju(this), this.responses = new so(this), this.realtime = new no(this), this.conversations = new ju(this), this.evals = new Uu(this), this.containers = new Du(this), this.videos = new rm(this), t === void 0)
      throw new ce("Missing credentials. Please pass an `apiKey`, or set the `OPENAI_API_KEY` environment variable.");
    const o = {
      apiKey: t,
      organization: n,
      project: s,
      webhookSecret: a,
      ...i,
      baseURL: e || "https://api.openai.com/v1"
    };
    if (!o.dangerouslyAllowBrowser && Ly())
      throw new ce(`It looks like you're running in a browser-like environment.

This is disabled by default, as it risks exposing your secret API credentials to attackers.
If you understand the risks and have appropriate mitigations in place,
you can set the \`dangerouslyAllowBrowser\` option to \`true\`, e.g.,

new OpenAI({ apiKey, dangerouslyAllowBrowser: true });

https://help.openai.com/en/articles/5112595-best-practices-for-api-key-safety
`);
    this.baseURL = o.baseURL, this.timeout = o.timeout ?? Hu.DEFAULT_TIMEOUT, this.logger = o.logger ?? console;
    const c = "warn";
    this.logLevel = c, this.logLevel = id(o.logLevel, "ClientOptions.logLevel", this) ?? id(Nn("OPENAI_LOG"), "process.env['OPENAI_LOG']", this) ?? c, this.fetchOptions = o.fetchOptions, this.maxRetries = o.maxRetries ?? 2, this.fetch = o.fetch ?? Uy(), fe(this, ai, By), this._options = o, this.apiKey = typeof t == "string" ? t : "Missing Key", this.organization = n, this.project = s, this.webhookSecret = a;
  }
  /**
   * Create a new client instance re-using the same options given to the current client with optional overriding.
   */
  withOptions(e) {
    return new this.constructor({
      ...this._options,
      baseURL: this.baseURL,
      maxRetries: this.maxRetries,
      timeout: this.timeout,
      logger: this.logger,
      logLevel: this.logLevel,
      fetch: this.fetch,
      fetchOptions: this.fetchOptions,
      apiKey: this.apiKey,
      organization: this.organization,
      project: this.project,
      webhookSecret: this.webhookSecret,
      ...e
    });
  }
  defaultQuery() {
    return this._options.defaultQuery;
  }
  validateHeaders({ values: e, nulls: t }) {
  }
  async authHeaders(e) {
    return Y([{ Authorization: `Bearer ${this.apiKey}` }]);
  }
  stringifyQuery(e) {
    return Gy(e, { arrayFormat: "brackets" });
  }
  getUserAgent() {
    return `${this.constructor.name}/JS ${Dn}`;
  }
  defaultIdempotencyKey() {
    return `stainless-node-retry-${Of()}`;
  }
  makeStatusError(e, t, n, s) {
    return St.generate(e, t, n, s);
  }
  async _callApiKey() {
    const e = this._options.apiKey;
    if (typeof e != "function")
      return !1;
    let t;
    try {
      t = await e();
    } catch (n) {
      throw n instanceof ce ? n : new ce(
        `Failed to get token from 'apiKey' function: ${n.message}`,
        // @ts-ignore
        { cause: n }
      );
    }
    if (typeof t != "string" || !t)
      throw new ce(`Expected 'apiKey' function argument to return a string but it returned ${t}`);
    return this.apiKey = t, !0;
  }
  buildURL(e, t, n) {
    const s = !I(this, Nc, "m", am).call(this) && n || this.baseURL, a = $y(e) ? new URL(e) : new URL(s + (s.endsWith("/") && e.startsWith("/") ? e.slice(1) : e)), i = this.defaultQuery();
    return Cy(i) || (t = { ...i, ...t }), typeof t == "object" && t && !Array.isArray(t) && (a.search = this.stringifyQuery(t)), a.toString();
  }
  /**
   * Used as a callback for mutating the given `FinalRequestOptions` object.
   */
  async prepareOptions(e) {
    await this._callApiKey();
  }
  /**
   * Used as a callback for mutating the given `RequestInit` object.
   *
   * This is useful for cases where you want to add certain headers based off of
   * the request properties, e.g. `method` or `url`.
   */
  async prepareRequest(e, { url: t, options: n }) {
  }
  get(e, t) {
    return this.methodRequest("get", e, t);
  }
  post(e, t) {
    return this.methodRequest("post", e, t);
  }
  patch(e, t) {
    return this.methodRequest("patch", e, t);
  }
  put(e, t) {
    return this.methodRequest("put", e, t);
  }
  delete(e, t) {
    return this.methodRequest("delete", e, t);
  }
  methodRequest(e, t, n) {
    return this.request(Promise.resolve(n).then((s) => ({ method: e, path: t, ...s })));
  }
  request(e, t = null) {
    return new Xi(this, this.makeRequest(e, t, void 0));
  }
  async makeRequest(e, t, n) {
    var v, g;
    const s = await e, a = s.maxRetries ?? this.maxRetries;
    t == null && (t = a), await this.prepareOptions(s);
    const { req: i, url: o, timeout: c } = await this.buildRequest(s, {
      retryCount: a - t
    });
    await this.prepareRequest(i, { url: o, options: s });
    const u = "log_" + (Math.random() * (1 << 24) | 0).toString(16).padStart(6, "0"), l = n === void 0 ? "" : `, retryOf: ${n}`, d = Date.now();
    if (wt(this).debug(`[${u}] sending request`, pn({
      retryOfRequestLogID: n,
      method: s.method,
      url: o,
      options: s,
      headers: i.headers
    })), (v = s.signal) != null && v.aborted)
      throw new Ut();
    const h = new AbortController(), f = await this.fetchWithTimeout(o, i, c, h).catch(bc), p = Date.now();
    if (f instanceof globalThis.Error) {
      const w = `retrying, ${t} attempts remaining`;
      if ((g = s.signal) != null && g.aborted)
        throw new Ut();
      const T = vc(f) || /timed? ?out/i.test(String(f) + ("cause" in f ? String(f.cause) : ""));
      if (t)
        return wt(this).info(`[${u}] connection ${T ? "timed out" : "failed"} - ${w}`), wt(this).debug(`[${u}] connection ${T ? "timed out" : "failed"} (${w})`, pn({
          retryOfRequestLogID: n,
          url: o,
          durationMs: p - d,
          message: f.message
        })), this.retryRequest(s, t, n ?? u);
      throw wt(this).info(`[${u}] connection ${T ? "timed out" : "failed"} - error; no more retries left`), wt(this).debug(`[${u}] connection ${T ? "timed out" : "failed"} (error; no more retries left)`, pn({
        retryOfRequestLogID: n,
        url: o,
        durationMs: p - d,
        message: f.message
      })), T ? new Ki() : new Wi({ cause: f });
    }
    const y = [...f.headers.entries()].filter(([w]) => w === "x-request-id").map(([w, T]) => ", " + w + ": " + JSON.stringify(T)).join(""), m = `[${u}${l}${y}] ${i.method} ${o} ${f.ok ? "succeeded" : "failed"} with status ${f.status} in ${p - d}ms`;
    if (!f.ok) {
      const w = await this.shouldRetry(f);
      if (t && w) {
        const V = `retrying, ${t} attempts remaining`;
        return await zy(f.body), wt(this).info(`${m} - ${V}`), wt(this).debug(`[${u}] response error (${V})`, pn({
          retryOfRequestLogID: n,
          url: f.url,
          status: f.status,
          headers: f.headers,
          durationMs: p - d
        })), this.retryRequest(s, t, n ?? u, f.headers);
      }
      const T = w ? "error; no more retries left" : "error; not retryable";
      wt(this).info(`${m} - ${T}`);
      const x = await f.text().catch((V) => bc(V).message), O = Py(x), R = O ? void 0 : x;
      throw wt(this).debug(`[${u}] response error (${T})`, pn({
        retryOfRequestLogID: n,
        url: f.url,
        status: f.status,
        headers: f.headers,
        message: R,
        durationMs: Date.now() - d
      })), this.makeStatusError(f.status, O, R, f.headers);
    }
    return wt(this).info(m), wt(this).debug(`[${u}] response start`, pn({
      retryOfRequestLogID: n,
      url: f.url,
      status: f.status,
      headers: f.headers,
      durationMs: p - d
    })), { response: f, options: s, controller: h, requestLogID: u, retryOfRequestLogID: n, startTime: d };
  }
  getAPIList(e, t, n) {
    return this.requestAPIList(t, { method: "get", path: e, ...n });
  }
  requestAPIList(e, t) {
    const n = this.makeRequest(t, null, void 0);
    return new nw(this, n, e);
  }
  async fetchWithTimeout(e, t, n, s) {
    const { signal: a, method: i, ...o } = t || {};
    a && a.addEventListener("abort", () => s.abort());
    const c = setTimeout(() => s.abort(), n), u = globalThis.ReadableStream && o.body instanceof globalThis.ReadableStream || typeof o.body == "object" && o.body !== null && Symbol.asyncIterator in o.body, l = {
      signal: s.signal,
      ...u ? { duplex: "half" } : {},
      method: "GET",
      ...o
    };
    i && (l.method = i.toUpperCase());
    try {
      return await this.fetch.call(void 0, e, l);
    } finally {
      clearTimeout(c);
    }
  }
  async shouldRetry(e) {
    const t = e.headers.get("x-should-retry");
    return t === "true" ? !0 : t === "false" ? !1 : e.status === 408 || e.status === 409 || e.status === 429 || e.status >= 500;
  }
  async retryRequest(e, t, n, s) {
    let a;
    const i = s == null ? void 0 : s.get("retry-after-ms");
    if (i) {
      const c = parseFloat(i);
      Number.isNaN(c) || (a = c);
    }
    const o = s == null ? void 0 : s.get("retry-after");
    if (o && !a) {
      const c = parseFloat(o);
      Number.isNaN(c) ? a = Date.parse(o) - Date.now() : a = c * 1e3;
    }
    if (!(a && 0 <= a && a < 60 * 1e3)) {
      const c = e.maxRetries ?? this.maxRetries;
      a = this.calculateDefaultRetryTimeoutMillis(t, c);
    }
    return await na(a), this.makeRequest(e, t - 1, n);
  }
  calculateDefaultRetryTimeoutMillis(e, t) {
    const a = t - e, i = Math.min(0.5 * Math.pow(2, a), 8), o = 1 - Math.random() * 0.25;
    return i * o * 1e3;
  }
  async buildRequest(e, { retryCount: t = 0 } = {}) {
    const n = { ...e }, { method: s, path: a, query: i, defaultBaseURL: o } = n, c = this.buildURL(a, i, o);
    "timeout" in n && Ny("timeout", n.timeout), n.timeout = n.timeout ?? this.timeout;
    const { bodyHeaders: u, body: l } = this.buildBody({ options: n }), d = await this.buildHeaders({ options: e, method: s, bodyHeaders: u, retryCount: t });
    return { req: {
      method: s,
      headers: d,
      ...n.signal && { signal: n.signal },
      ...globalThis.ReadableStream && l instanceof globalThis.ReadableStream && { duplex: "half" },
      ...l && { body: l },
      ...this.fetchOptions ?? {},
      ...n.fetchOptions ?? {}
    }, url: c, timeout: n.timeout };
  }
  async buildHeaders({ options: e, method: t, bodyHeaders: n, retryCount: s }) {
    let a = {};
    this.idempotencyHeader && t !== "get" && (e.idempotencyKey || (e.idempotencyKey = this.defaultIdempotencyKey()), a[this.idempotencyHeader] = e.idempotencyKey);
    const i = Y([
      a,
      {
        Accept: "application/json",
        "User-Agent": this.getUserAgent(),
        "X-Stainless-Retry-Count": String(s),
        ...e.timeout ? { "X-Stainless-Timeout": String(Math.trunc(e.timeout / 1e3)) } : {},
        ...Fy(),
        "OpenAI-Organization": this.organization,
        "OpenAI-Project": this.project
      },
      await this.authHeaders(e),
      this._options.defaultHeaders,
      n,
      e.headers
    ]);
    return this.validateHeaders(i), i.values;
  }
  buildBody({ options: { body: e, headers: t } }) {
    if (!e)
      return { bodyHeaders: void 0, body: void 0 };
    const n = Y([t]);
    return (
      // Pass raw type verbatim
      ArrayBuffer.isView(e) || e instanceof ArrayBuffer || e instanceof DataView || typeof e == "string" && // Preserve legacy string encoding behavior for now
      n.values.has("content-type") || // `Blob` is superset of `File`
      globalThis.Blob && e instanceof globalThis.Blob || // `FormData` -> `multipart/form-data`
      e instanceof FormData || // `URLSearchParams` -> `application/x-www-form-urlencoded`
      e instanceof URLSearchParams || // Send chunked stream (each chunk has own `length`)
      globalThis.ReadableStream && e instanceof globalThis.ReadableStream ? { bodyHeaders: void 0, body: e } : typeof e == "object" && (Symbol.asyncIterator in e || Symbol.iterator in e && "next" in e && typeof e.next == "function") ? { bodyHeaders: void 0, body: zf(e) } : I(this, ai, "f").call(this, { body: e, headers: n })
    );
  }
}
Hu = xe, ai = /* @__PURE__ */ new WeakMap(), Nc = /* @__PURE__ */ new WeakSet(), am = function() {
  return this.baseURL !== "https://api.openai.com/v1";
};
xe.OpenAI = Hu;
xe.DEFAULT_TIMEOUT = 6e5;
xe.OpenAIError = ce;
xe.APIError = St;
xe.APIConnectionError = Wi;
xe.APIConnectionTimeoutError = Ki;
xe.APIUserAbortError = Ut;
xe.NotFoundError = Rf;
xe.ConflictError = Nf;
xe.RateLimitError = Lf;
xe.BadRequestError = Af;
xe.AuthenticationError = $f;
xe.InternalServerError = Mf;
xe.PermissionDeniedError = Cf;
xe.UnprocessableEntityError = Pf;
xe.InvalidWebhookSignatureError = _s;
xe.toFile = cw;
xe.Completions = Pp;
xe.Chat = Pu;
xe.Embeddings = Dp;
xe.Files = Fp;
xe.Images = qp;
xe.Audio = aa;
xe.Moderations = Hp;
xe.Models = Jp;
xe.FineTuning = us;
xe.Graders = Vu;
xe.VectorStores = ao;
xe.Webhooks = sm;
xe.Beta = cs;
xe.Batches = kp;
xe.Uploads = Ju;
xe.Responses = so;
xe.Realtime = no;
xe.Conversations = ju;
xe.Evals = Uu;
xe.Containers = Du;
xe.Videos = rm;
function im(r) {
  if (!r || typeof r != "object") return r;
  let e;
  return r.constructor.name === Ki.name && "message" in r && typeof r.message == "string" ? (e = new Error(r.message), e.name = "TimeoutError") : r.constructor.name === Ut.name && "message" in r && typeof r.message == "string" ? (e = new Error(r.message), e.name = "AbortError") : "status" in r && r.status === 400 && "message" in r && typeof r.message == "string" && r.message.includes("tool_calls") ? e = Sa(r, "INVALID_TOOL_RESULTS") : "status" in r && r.status === 401 ? e = Sa(r, "MODEL_AUTHENTICATION") : "status" in r && r.status === 429 ? e = Sa(r, "MODEL_RATE_LIMIT") : "status" in r && r.status === 404 ? e = Sa(r, "MODEL_NOT_FOUND") : e = r, e;
}
var Lw = Object.defineProperty, Ae = (r, e) => {
  for (var t in e) Lw(r, t, {
    get: e[t],
    enumerable: !0
  });
};
function kr(r) {
  return typeof r == "object" && r !== null && "type" in r && typeof r.type == "string" && "source_type" in r && (r.source_type === "url" || r.source_type === "base64" || r.source_type === "text" || r.source_type === "id");
}
function Gu(r) {
  return kr(r) && r.source_type === "url" && "url" in r && typeof r.url == "string";
}
function Wu(r) {
  return kr(r) && r.source_type === "base64" && "data" in r && typeof r.data == "string";
}
function Mw(r) {
  return kr(r) && r.source_type === "text" && "text" in r && typeof r.text == "string";
}
function om(r) {
  return kr(r) && r.source_type === "id" && "id" in r && typeof r.id == "string";
}
function cm(r) {
  if (kr(r)) {
    if (r.source_type === "url") return {
      type: "image_url",
      image_url: { url: r.url }
    };
    if (r.source_type === "base64") {
      if (!r.mime_type) throw new Error("mime_type key is required for base64 data.");
      return {
        type: "image_url",
        image_url: { url: `data:${r.mime_type};base64,${r.data}` }
      };
    }
  }
  throw new Error("Unsupported source type. Only 'url' and 'base64' are supported.");
}
function Pc(r) {
  const e = r.split(";")[0].split("/");
  if (e.length !== 2) throw new Error(`Invalid mime type: "${r}" - does not match type/subtype format.`);
  const t = e[0].trim(), n = e[1].trim();
  if (t === "" || n === "") throw new Error(`Invalid mime type: "${r}" - type or subtype is empty.`);
  const s = {};
  for (const a of r.split(";").slice(1)) {
    const i = a.split("=");
    if (i.length !== 2) throw new Error(`Invalid parameter syntax in mime type: "${r}".`);
    const o = i[0].trim(), c = i[1].trim();
    if (o === "") throw new Error(`Invalid parameter syntax in mime type: "${r}".`);
    s[o] = c;
  }
  return {
    type: t,
    subtype: n,
    parameters: s
  };
}
function Js({ dataUrl: r, asTypedArray: e = !1 }) {
  const t = r.match(/^data:(\w+\/\w+);base64,([A-Za-z0-9+/]+=*)$/);
  let n;
  if (t) {
    n = t[1].toLowerCase();
    const s = e ? Uint8Array.from(atob(t[2]), (a) => a.charCodeAt(0)) : t[2];
    return {
      mime_type: n,
      data: s
    };
  }
}
function Ku(r, e) {
  if (r.type === "text") {
    if (!e.fromStandardTextBlock) throw new Error(`Converter for ${e.providerName} does not implement \`fromStandardTextBlock\` method.`);
    return e.fromStandardTextBlock(r);
  }
  if (r.type === "image") {
    if (!e.fromStandardImageBlock) throw new Error(`Converter for ${e.providerName} does not implement \`fromStandardImageBlock\` method.`);
    return e.fromStandardImageBlock(r);
  }
  if (r.type === "audio") {
    if (!e.fromStandardAudioBlock) throw new Error(`Converter for ${e.providerName} does not implement \`fromStandardAudioBlock\` method.`);
    return e.fromStandardAudioBlock(r);
  }
  if (r.type === "file") {
    if (!e.fromStandardFileBlock) throw new Error(`Converter for ${e.providerName} does not implement \`fromStandardFileBlock\` method.`);
    return e.fromStandardFileBlock(r);
  }
  throw new Error(`Unable to convert content block type '${r.type}' to provider-specific format: not recognized.`);
}
function um(r) {
  return typeof r == "object" && r !== null && "type" in r && "content" in r && (typeof r.content == "string" || Array.isArray(r.content));
}
function Yu(r) {
  return r && r.__esModule && Object.prototype.hasOwnProperty.call(r, "default") ? r.default : r;
}
var Dw = function(r, e) {
  if (typeof r != "string")
    throw new TypeError("Expected a string");
  return e = typeof e > "u" ? "_" : e, r.replace(/([a-z\d])([A-Z])/g, "$1" + e + "$2").replace(/([A-Z]+)([A-Z][a-z\d]+)/g, "$1" + e + "$2").toLowerCase();
};
const jw = /* @__PURE__ */ Yu(Dw);
var lm = { exports: {} };
const Fw = /[\p{Lu}]/u, Uw = /[\p{Ll}]/u, Ed = /^[\p{Lu}](?![\p{Lu}])/gu, dm = /([\p{Alpha}\p{N}_]|$)/u, hm = /[_.\- ]+/, zw = new RegExp("^" + hm.source), xd = new RegExp(hm.source + dm.source, "gu"), kd = new RegExp("\\d+" + dm.source, "gu"), Bw = (r, e, t) => {
  let n = !1, s = !1, a = !1;
  for (let i = 0; i < r.length; i++) {
    const o = r[i];
    n && Fw.test(o) ? (r = r.slice(0, i) + "-" + r.slice(i), n = !1, a = s, s = !0, i++) : s && a && Uw.test(o) ? (r = r.slice(0, i - 1) + "-" + r.slice(i - 1), a = s, s = !1, n = !0) : (n = e(o) === o && t(o) !== o, a = s, s = t(o) === o && e(o) !== o);
  }
  return r;
}, Zw = (r, e) => (Ed.lastIndex = 0, r.replace(Ed, (t) => e(t))), Vw = (r, e) => (xd.lastIndex = 0, kd.lastIndex = 0, r.replace(xd, (t, n) => e(n)).replace(kd, (t) => e(t))), fm = (r, e) => {
  if (!(typeof r == "string" || Array.isArray(r)))
    throw new TypeError("Expected the input to be `string | string[]`");
  if (e = {
    pascalCase: !1,
    preserveConsecutiveUppercase: !1,
    ...e
  }, Array.isArray(r) ? r = r.map((a) => a.trim()).filter((a) => a.length).join("-") : r = r.trim(), r.length === 0)
    return "";
  const t = e.locale === !1 ? (a) => a.toLowerCase() : (a) => a.toLocaleLowerCase(e.locale), n = e.locale === !1 ? (a) => a.toUpperCase() : (a) => a.toLocaleUpperCase(e.locale);
  return r.length === 1 ? e.pascalCase ? n(r) : t(r) : (r !== t(r) && (r = Bw(r, t, n)), r = r.replace(zw, ""), e.preserveConsecutiveUppercase ? r = Zw(r, t) : r = t(r), e.pascalCase && (r = n(r.charAt(0)) + r.slice(1)), Vw(r, n));
};
lm.exports = fm;
lm.exports.default = fm;
function qw(r, e) {
  return (e == null ? void 0 : e[r]) || jw(r);
}
function Jw(r, e, t) {
  const n = {};
  for (const s in r) Object.hasOwn(r, s) && (n[e(s, t)] = r[s]);
  return n;
}
var Hw = {};
Ae(Hw, {
  Serializable: () => Yn,
  get_lc_unique_name: () => Xu
});
function Id(r) {
  return Array.isArray(r) ? [...r] : { ...r };
}
function Gw(r, e) {
  const t = Id(r);
  for (const [n, s] of Object.entries(e)) {
    const [a, ...i] = n.split(".").reverse();
    let o = t;
    for (const c of i.reverse()) {
      if (o[c] === void 0) break;
      o[c] = Id(o[c]), o = o[c];
    }
    o[a] !== void 0 && (o[a] = {
      lc: 1,
      type: "secret",
      id: [s]
    });
  }
  return t;
}
function Xu(r) {
  const e = Object.getPrototypeOf(r);
  return typeof r.lc_name == "function" && (typeof e.lc_name != "function" || r.lc_name() !== e.lc_name()) ? r.lc_name() : r.name;
}
var Yn = class pm {
  constructor(e, ...t) {
    b(this, "lc_serializable", !1);
    b(this, "lc_kwargs");
    this.lc_serializable_keys !== void 0 ? this.lc_kwargs = Object.fromEntries(Object.entries(e || {}).filter(([n]) => {
      var s;
      return (s = this.lc_serializable_keys) == null ? void 0 : s.includes(n);
    })) : this.lc_kwargs = e ?? {};
  }
  /**
  * The name of the serializable. Override to provide an alias or
  * to preserve the serialized module name in minified environments.
  *
  * Implemented as a static method to support loading logic.
  */
  static lc_name() {
    return this.name;
  }
  /**
  * The final serialized identifier for the module.
  */
  get lc_id() {
    return [...this.lc_namespace, Xu(this.constructor)];
  }
  /**
  * A map of secrets, which will be omitted from serialization.
  * Keys are paths to the secret in constructor args, e.g. "foo.bar.baz".
  * Values are the secret ids, which will be used when deserializing.
  */
  get lc_secrets() {
  }
  /**
  * A map of additional attributes to merge with constructor args.
  * Keys are the attribute names, e.g. "foo".
  * Values are the attribute values, which will be serialized.
  * These attributes need to be accepted by the constructor as arguments.
  */
  get lc_attributes() {
  }
  /**
  * A map of aliases for constructor args.
  * Keys are the attribute names, e.g. "foo".
  * Values are the alias that will replace the key in serialization.
  * This is used to eg. make argument names match Python.
  */
  get lc_aliases() {
  }
  /**
  * A manual list of keys that should be serialized.
  * If not overridden, all fields passed into the constructor will be serialized.
  */
  get lc_serializable_keys() {
  }
  toJSON() {
    if (!this.lc_serializable) return this.toJSONNotImplemented();
    if (this.lc_kwargs instanceof pm || typeof this.lc_kwargs != "object" || Array.isArray(this.lc_kwargs)) return this.toJSONNotImplemented();
    const e = {}, t = {}, n = Object.keys(this.lc_kwargs).reduce((s, a) => (s[a] = a in this ? this[a] : this.lc_kwargs[a], s), {});
    for (let s = Object.getPrototypeOf(this); s; s = Object.getPrototypeOf(s))
      Object.assign(e, Reflect.get(s, "lc_aliases", this)), Object.assign(t, Reflect.get(s, "lc_secrets", this)), Object.assign(n, Reflect.get(s, "lc_attributes", this));
    return Object.keys(t).forEach((s) => {
      let a = this, i = n;
      const [o, ...c] = s.split(".").reverse();
      for (const u of c.reverse()) {
        if (!(u in a) || a[u] === void 0) return;
        (!(u in i) || i[u] === void 0) && (typeof a[u] == "object" && a[u] != null ? i[u] = {} : Array.isArray(a[u]) && (i[u] = [])), a = a[u], i = i[u];
      }
      o in a && a[o] !== void 0 && (i[o] = i[o] || a[o]);
    }), {
      lc: 1,
      type: "constructor",
      id: this.lc_id,
      kwargs: Jw(Object.keys(t).length ? Gw(n, t) : n, qw, e)
    };
  }
  toJSONNotImplemented() {
    return {
      lc: 1,
      type: "not_implemented",
      id: this.lc_id
    };
  }
};
function ue(r, e) {
  return be(r) && r.type === e;
}
function be(r) {
  return typeof r == "object" && r !== null;
}
function Tr(r) {
  return Array.isArray(r);
}
function K(r) {
  return typeof r == "string";
}
function or(r) {
  return typeof r == "number";
}
function Qu(r) {
  return r instanceof Uint8Array;
}
function Od(r) {
  try {
    return JSON.parse(r);
  } catch {
    return;
  }
}
const Hs = (r) => r();
function Ww(r) {
  if (r.type === "char_location" && K(r.document_title) && or(r.start_char_index) && or(r.end_char_index) && K(r.cited_text)) {
    const { document_title: e, start_char_index: t, end_char_index: n, cited_text: s, ...a } = r;
    return {
      ...a,
      type: "citation",
      source: "char",
      title: e ?? void 0,
      startIndex: t,
      endIndex: n,
      citedText: s
    };
  }
  if (r.type === "page_location" && K(r.document_title) && or(r.start_page_number) && or(r.end_page_number) && K(r.cited_text)) {
    const { document_title: e, start_page_number: t, end_page_number: n, cited_text: s, ...a } = r;
    return {
      ...a,
      type: "citation",
      source: "page",
      title: e ?? void 0,
      startIndex: t,
      endIndex: n,
      citedText: s
    };
  }
  if (r.type === "content_block_location" && K(r.document_title) && or(r.start_block_index) && or(r.end_block_index) && K(r.cited_text)) {
    const { document_title: e, start_block_index: t, end_block_index: n, cited_text: s, ...a } = r;
    return {
      ...a,
      type: "citation",
      source: "block",
      title: e ?? void 0,
      startIndex: t,
      endIndex: n,
      citedText: s
    };
  }
  if (r.type === "web_search_result_location" && K(r.url) && K(r.title) && K(r.encrypted_index) && K(r.cited_text)) {
    const { url: e, title: t, encrypted_index: n, cited_text: s, ...a } = r;
    return {
      ...a,
      type: "citation",
      source: "url",
      url: e,
      title: t,
      startIndex: Number(n),
      endIndex: Number(n),
      citedText: s
    };
  }
  if (r.type === "search_result_location" && K(r.source) && K(r.title) && or(r.start_block_index) && or(r.end_block_index) && K(r.cited_text)) {
    const { source: e, title: t, start_block_index: n, end_block_index: s, cited_text: a, ...i } = r;
    return {
      ...i,
      type: "citation",
      source: "search",
      url: e,
      title: t ?? void 0,
      startIndex: n,
      endIndex: s,
      citedText: a
    };
  }
}
function mm(r) {
  if (ue(r, "document") && be(r.source) && "type" in r.source) {
    if (r.source.type === "base64" && K(r.source.media_type) && K(r.source.data)) return {
      type: "file",
      mimeType: r.source.media_type,
      data: r.source.data
    };
    if (r.source.type === "url" && K(r.source.url)) return {
      type: "file",
      url: r.source.url
    };
    if (r.source.type === "file" && K(r.source.file_id)) return {
      type: "file",
      fileId: r.source.file_id
    };
    if (r.source.type === "text" && K(r.source.data)) return {
      type: "file",
      mimeType: String(r.source.media_type ?? "text/plain"),
      data: r.source.data
    };
  } else if (ue(r, "image") && be(r.source) && "type" in r.source) {
    if (r.source.type === "base64" && K(r.source.media_type) && K(r.source.data)) return {
      type: "image",
      mimeType: r.source.media_type,
      data: r.source.data
    };
    if (r.source.type === "url" && K(r.source.url)) return {
      type: "image",
      url: r.source.url
    };
    if (r.source.type === "file" && K(r.source.file_id)) return {
      type: "image",
      fileId: r.source.file_id
    };
  }
}
function Kw(r) {
  function* e() {
    for (const t of r) {
      const n = mm(t);
      n ? yield n : yield t;
    }
  }
  return Array.from(e());
}
function Ad(r) {
  function* e() {
    var n;
    const t = typeof r.content == "string" ? [{
      type: "text",
      text: r.content
    }] : r.content;
    for (const s of t) {
      if (ue(s, "text") && K(s.text)) {
        const { text: a, citations: i, ...o } = s;
        if (Tr(i) && i.length) {
          const c = i.reduce((u, l) => {
            const d = Ww(l);
            return d ? [...u, d] : u;
          }, []);
          yield {
            ...o,
            type: "text",
            text: a,
            annotations: c
          };
          continue;
        } else {
          yield {
            ...o,
            type: "text",
            text: a
          };
          continue;
        }
      } else if (ue(s, "thinking") && K(s.thinking)) {
        const { thinking: a, signature: i, ...o } = s;
        yield {
          ...o,
          type: "reasoning",
          reasoning: a,
          signature: i
        };
        continue;
      } else if (ue(s, "redacted_thinking")) {
        yield {
          type: "non_standard",
          value: s
        };
        continue;
      } else if (ue(s, "tool_use") && K(s.name) && K(s.id)) {
        yield {
          type: "tool_call",
          id: s.id,
          name: s.name,
          args: s.input
        };
        continue;
      } else if (ue(s, "input_json_delta")) {
        if (Xw(r) && ((n = r.tool_call_chunks) != null && n.length)) {
          const a = r.tool_call_chunks[0];
          yield {
            type: "tool_call_chunk",
            id: a.id,
            name: a.name,
            args: a.args,
            index: a.index
          };
          continue;
        }
      } else if (ue(s, "server_tool_use") && K(s.name) && K(s.id)) {
        const { name: a, id: i } = s;
        if (a === "web_search") {
          const o = Hs(() => {
            if (typeof s.input == "string") return s.input;
            if (be(s.input) && K(s.input.query)) return s.input.query;
            if (K(s.partial_json)) {
              const c = Od(s.partial_json);
              if (c != null && c.query) return c.query;
            }
            return "";
          });
          yield {
            id: i,
            type: "server_tool_call",
            name: "web_search",
            args: { query: o }
          };
          continue;
        } else if (s.name === "code_execution") {
          const o = Hs(() => {
            if (typeof s.input == "string") return s.input;
            if (be(s.input) && K(s.input.code)) return s.input.code;
            if (K(s.partial_json)) {
              const c = Od(s.partial_json);
              if (c != null && c.code) return c.code;
            }
            return "";
          });
          yield {
            id: i,
            type: "server_tool_call",
            name: "code_execution",
            args: { code: o }
          };
          continue;
        }
      } else if (ue(s, "web_search_tool_result") && K(s.tool_use_id) && Tr(s.content)) {
        const { content: a, tool_use_id: i } = s, o = a.reduce((c, u) => ue(u, "web_search_result") ? [...c, u.url] : c, []);
        yield {
          type: "server_tool_call_result",
          name: "web_search",
          toolCallId: i,
          status: "success",
          output: { urls: o }
        };
        continue;
      } else if (ue(s, "code_execution_tool_result") && K(s.tool_use_id) && be(s.content)) {
        yield {
          type: "server_tool_call_result",
          name: "code_execution",
          toolCallId: s.tool_use_id,
          status: "success",
          output: s.content
        };
        continue;
      } else if (ue(s, "mcp_tool_use")) {
        yield {
          id: s.id,
          type: "server_tool_call",
          name: "mcp_tool_use",
          args: s.input
        };
        continue;
      } else if (ue(s, "mcp_tool_result") && K(s.tool_use_id) && be(s.content)) {
        yield {
          type: "server_tool_call_result",
          name: "mcp_tool_use",
          toolCallId: s.tool_use_id,
          status: "success",
          output: s.content
        };
        continue;
      } else if (ue(s, "container_upload")) {
        yield {
          type: "server_tool_call",
          name: "container_upload",
          args: s.input
        };
        continue;
      } else if (ue(s, "search_result")) {
        yield {
          id: s.id,
          type: "non_standard",
          value: s
        };
        continue;
      } else if (ue(s, "tool_result")) {
        yield {
          id: s.id,
          type: "non_standard",
          value: s
        };
        continue;
      } else {
        const a = mm(s);
        if (a) {
          yield a;
          continue;
        }
      }
      yield {
        type: "non_standard",
        value: s
      };
    }
  }
  return Array.from(e());
}
const Yw = {
  translateContent: Ad,
  translateContentChunk: Ad
};
function Xw(r) {
  return typeof (r == null ? void 0 : r._getType) == "function" && typeof r.concat == "function" && r._getType() === "ai";
}
function Qw(r) {
  return Gu(r) ? {
    type: r.type,
    mimeType: r.mime_type,
    url: r.url,
    metadata: r.metadata
  } : Wu(r) ? {
    type: r.type,
    mimeType: r.mime_type ?? "application/octet-stream",
    data: r.data,
    metadata: r.metadata
  } : om(r) ? {
    type: r.type,
    mimeType: r.mime_type,
    fileId: r.id,
    metadata: r.metadata
  } : r;
}
function ev(r) {
  return r.map(Qw);
}
function tv(r) {
  return !!(ue(r, "image_url") && be(r.image_url) || ue(r, "input_audio") && be(r.input_audio) || ue(r, "file") && be(r.file));
}
function rv(r) {
  if (ue(r, "image_url") && be(r.image_url) && K(r.image_url.url)) {
    const e = Js({ dataUrl: r.image_url.url });
    return e ? {
      type: "image",
      mimeType: e.mime_type,
      data: e.data
    } : {
      type: "image",
      url: r.image_url.url
    };
  } else {
    if (ue(r, "input_audio") && be(r.input_audio) && K(r.input_audio.data) && K(r.input_audio.format)) return {
      type: "audio",
      data: r.input_audio.data,
      mimeType: `audio/${r.input_audio.format}`
    };
    if (ue(r, "file") && be(r.file) && K(r.file.data)) {
      const e = Js({ dataUrl: r.file.data });
      if (e) return {
        type: "file",
        data: e.data,
        mimeType: e.mime_type
      };
      if (K(r.file.file_id)) return {
        type: "file",
        fileId: r.file.file_id
      };
    }
  }
  return r;
}
function nv(r) {
  const e = [];
  typeof r.content == "string" ? e.push({
    type: "text",
    text: r.content
  }) : e.push(...el(r.content));
  for (const t of r.tool_calls ?? []) e.push({
    type: "tool_call",
    id: t.id,
    name: t.name,
    args: t.args
  });
  return e;
}
function sv(r) {
  const e = [];
  typeof r.content == "string" ? e.push({
    type: "text",
    text: r.content
  }) : e.push(...el(r.content));
  for (const t of r.tool_calls ?? []) e.push({
    type: "tool_call",
    id: t.id,
    name: t.name,
    args: t.args
  });
  return e;
}
function el(r) {
  const e = [];
  for (const t of r) tv(t) ? e.push(rv(t)) : e.push(t);
  return e;
}
function av(r) {
  if (r.type === "url_citation") {
    const { url: e, title: t, start_index: n, end_index: s } = r;
    return {
      type: "citation",
      url: e,
      title: t,
      startIndex: n,
      endIndex: s
    };
  }
  if (r.type === "file_citation") {
    const { file_id: e, filename: t, index: n } = r;
    return {
      type: "citation",
      title: t,
      startIndex: n,
      endIndex: n,
      fileId: e
    };
  }
  return r;
}
function gm(r) {
  function* e() {
    var n;
    be((n = r.additional_kwargs) == null ? void 0 : n.reasoning) && Tr(r.additional_kwargs.reasoning.summary) && (yield {
      type: "reasoning",
      reasoning: r.additional_kwargs.reasoning.summary.reduce((a, i) => be(i) && K(i.text) ? `${a}${i.text}` : a, "")
    });
    const t = typeof r.content == "string" ? [{
      type: "text",
      text: r.content
    }] : r.content;
    for (const s of t) if (ue(s, "text")) {
      const { text: a, annotations: i, ...o } = s;
      Array.isArray(i) ? yield {
        ...o,
        type: "text",
        text: String(a),
        annotations: i.map(av)
      } : yield {
        ...o,
        type: "text",
        text: String(a)
      };
    }
    for (const s of r.tool_calls ?? []) yield {
      type: "tool_call",
      id: s.id,
      name: s.name,
      args: s.args
    };
    if (be(r.additional_kwargs) && Tr(r.additional_kwargs.tool_outputs)) for (const s of r.additional_kwargs.tool_outputs) {
      if (ue(s, "web_search_call")) {
        yield {
          id: s.id,
          type: "server_tool_call",
          name: "web_search",
          args: { query: s.query }
        };
        continue;
      } else if (ue(s, "file_search_call")) {
        yield {
          id: s.id,
          type: "server_tool_call",
          name: "file_search",
          args: { query: s.query }
        };
        continue;
      } else if (ue(s, "computer_call")) {
        yield {
          type: "non_standard",
          value: s
        };
        continue;
      } else if (ue(s, "code_interpreter_call")) {
        if (K(s.code) && (yield {
          id: s.id,
          type: "server_tool_call",
          name: "code_interpreter",
          args: { code: s.code }
        }), Tr(s.outputs)) {
          const a = Hs(() => {
            if (s.status !== "in_progress") {
              if (s.status === "completed") return 0;
              if (s.status === "incomplete") return 127;
              if (s.status !== "interpreting" && s.status === "failed")
                return 1;
            }
          });
          for (const i of s.outputs) if (ue(i, "logs")) {
            yield {
              type: "server_tool_call_result",
              toolCallId: s.id ?? "",
              status: "success",
              output: {
                type: "code_interpreter_output",
                returnCode: a ?? 0,
                stderr: [0, void 0].includes(a) ? void 0 : String(i.logs),
                stdout: [0, void 0].includes(a) ? String(i.logs) : void 0
              }
            };
            continue;
          }
        }
        continue;
      } else if (ue(s, "mcp_call")) {
        yield {
          id: s.id,
          type: "server_tool_call",
          name: "mcp_call",
          args: s.input
        };
        continue;
      } else if (ue(s, "mcp_list_tools")) {
        yield {
          id: s.id,
          type: "server_tool_call",
          name: "mcp_list_tools",
          args: s.input
        };
        continue;
      } else if (ue(s, "mcp_approval_request")) {
        yield {
          type: "non_standard",
          value: s
        };
        continue;
      } else if (ue(s, "image_generation_call")) {
        yield {
          type: "non_standard",
          value: s
        };
        continue;
      }
      be(s) && (yield {
        type: "non_standard",
        value: s
      });
    }
  }
  return Array.from(e());
}
function iv(r) {
  function* e() {
    yield* gm(r);
    for (const t of r.tool_call_chunks ?? []) yield {
      type: "tool_call_chunk",
      id: t.id,
      name: t.name,
      args: t.args
    };
  }
  return Array.from(e());
}
const ov = {
  translateContent: (r) => typeof r.content == "string" ? nv(r) : gm(r),
  translateContentChunk: (r) => typeof r.content == "string" ? sv(r) : iv(r)
};
function cv(r, e = "pretty") {
  return e === "pretty" ? uv(r) : JSON.stringify(r);
}
function uv(r) {
  const e = [], t = ` ${r.type.charAt(0).toUpperCase() + r.type.slice(1)} Message `, n = Math.floor((80 - t.length) / 2), s = "=".repeat(n), a = t.length % 2 === 0 ? s : `${s}=`;
  if (e.push(`${s}${t}${a}`), r.type === "ai") {
    const i = r;
    if (i.tool_calls && i.tool_calls.length > 0) {
      e.push("Tool Calls:");
      for (const o of i.tool_calls) {
        e.push(`  ${o.name} (${o.id})`), e.push(` Call ID: ${o.id}`), e.push("  Args:");
        for (const [c, u] of Object.entries(o.args)) e.push(`    ${c}: ${u}`);
      }
    }
  }
  if (r.type === "tool") {
    const i = r;
    i.name && e.push(`Name: ${i.name}`);
  }
  return typeof r.content == "string" && r.content.trim() && (e.length > 1 && e.push(""), e.push(r.content)), e.join(`
`);
}
const Jo = Symbol.for("langchain.message");
function Fr(r, e) {
  return typeof r == "string" ? r === "" ? e : typeof e == "string" ? r + e : Array.isArray(e) && e.length === 0 ? r : Array.isArray(e) && e.some((t) => kr(t)) ? [{
    type: "text",
    source_type: "text",
    text: r
  }, ...e] : [{
    type: "text",
    text: r
  }, ...e] : Array.isArray(e) ? ia(r, e) ?? [...r, ...e] : e === "" ? r : Array.isArray(r) && r.some((t) => kr(t)) ? [...r, {
    type: "file",
    source_type: "text",
    text: e
  }] : [...r, {
    type: "text",
    text: e
  }];
}
function _m(r, e) {
  return r === "error" || e === "error" ? "error" : "success";
}
function lv(r, e) {
  function t(n, s) {
    if (typeof n != "object" || n === null || n === void 0) return n;
    if (s >= e)
      return Array.isArray(n) ? "[Array]" : "[Object]";
    if (Array.isArray(n)) return n.map((i) => t(i, s + 1));
    const a = {};
    for (const i of Object.keys(n)) a[i] = t(n[i], s + 1);
    return a;
  }
  return JSON.stringify(t(r, 0), null, 2);
}
var kf, Vr = class extends Yn {
  constructor(e) {
    const t = typeof e == "string" || Array.isArray(e) ? { content: e } : e;
    t.additional_kwargs || (t.additional_kwargs = {}), t.response_metadata || (t.response_metadata = {});
    super(t);
    b(this, "lc_namespace", ["langchain_core", "messages"]);
    b(this, "lc_serializable", !0);
    b(this, kf, !0);
    b(this, "id");
    b(this, "name");
    b(this, "content");
    b(this, "additional_kwargs");
    b(this, "response_metadata");
    this.name = t.name, t.content === void 0 && t.contentBlocks !== void 0 ? (this.content = t.contentBlocks, this.response_metadata = {
      output_version: "v1",
      ...t.response_metadata
    }) : t.content !== void 0 ? (this.content = t.content ?? [], this.response_metadata = t.response_metadata) : (this.content = [], this.response_metadata = t.response_metadata), this.additional_kwargs = t.additional_kwargs, this.id = t.id;
  }
  get lc_aliases() {
    return {
      additional_kwargs: "additional_kwargs",
      response_metadata: "response_metadata"
    };
  }
  /**
  * @deprecated Use .getType() instead or import the proper typeguard.
  * For example:
  *
  * ```ts
  * import { isAIMessage } from "@langchain/core/messages";
  *
  * const message = new AIMessage("Hello!");
  * isAIMessage(message); // true
  * ```
  */
  _getType() {
    return this.type;
  }
  /**
  * @deprecated Use .type instead
  * The type of the message.
  */
  getType() {
    return this._getType();
  }
  /** Get text content of the message. */
  get text() {
    return typeof this.content == "string" ? this.content : Array.isArray(this.content) ? this.content.map((e) => typeof e == "string" ? e : e.type === "text" ? e.text : "").join("") : "";
  }
  get contentBlocks() {
    const e = typeof this.content == "string" ? [{
      type: "text",
      text: this.content
    }] : this.content;
    return [
      ev,
      el,
      Kw
    ].reduce((s, a) => a(s), e);
  }
  toDict() {
    return {
      type: this.getType(),
      data: this.toJSON().kwargs
    };
  }
  static lc_name() {
    return "BaseMessage";
  }
  get _printableFields() {
    return {
      id: this.id,
      content: this.content,
      name: this.name,
      additional_kwargs: this.additional_kwargs,
      response_metadata: this.response_metadata
    };
  }
  static isInstance(e) {
    return typeof e == "object" && e !== null && Jo in e && e[Jo] === !0 && um(e);
  }
  _updateId(e) {
    this.id = e, this.lc_kwargs.id = e;
  }
  get [(kf = Jo, Symbol.toStringTag)]() {
    return this.constructor.lc_name();
  }
  [Symbol.for("nodejs.util.inspect.custom")](e) {
    if (e === null) return this;
    const t = lv(this._printableFields, Math.max(4, e));
    return `${this.constructor.lc_name()} ${t}`;
  }
  toFormattedString(e = "pretty") {
    return cv(this, e);
  }
};
function dv(r) {
  return Array.isArray(r) && r.every((e) => typeof e.index == "number");
}
function Tt(r = {}, e = {}) {
  const t = { ...r };
  for (const [n, s] of Object.entries(e)) if (t[n] == null) t[n] = s;
  else {
    if (s == null) continue;
    if (typeof t[n] != typeof s || Array.isArray(t[n]) !== Array.isArray(s)) throw new Error(`field[${n}] already exists in the message chunk, but with a different type.`);
    if (typeof t[n] == "string") {
      if (n === "type") continue;
      [
        "id",
        "name",
        "output_version",
        "model_provider"
      ].includes(n) ? s && (t[n] = s) : t[n] += s;
    } else if (typeof t[n] == "object" && !Array.isArray(t[n])) t[n] = Tt(t[n], s);
    else if (Array.isArray(t[n])) t[n] = ia(t[n], s);
    else {
      if (t[n] === s) continue;
      console.warn(`field[${n}] already exists in this message chunk and value has unsupported type.`);
    }
  }
  return t;
}
function ia(r, e) {
  if (!(r === void 0 && e === void 0)) {
    if (r === void 0 || e === void 0) return r || e;
    {
      const t = [...r];
      for (const n of e) if (typeof n == "object" && n !== null && "index" in n && typeof n.index == "number") {
        const s = t.findIndex((a) => {
          const i = typeof a == "object", o = "index" in a && a.index === n.index, c = "id" in a && "id" in n && (a == null ? void 0 : a.id) === (n == null ? void 0 : n.id), u = !("id" in a) || !(a != null && a.id) || !("id" in n) || !(n != null && n.id);
          return i && o && (c || u);
        });
        s !== -1 && typeof t[s] == "object" && t[s] !== null ? t[s] = Tt(t[s], n) : t.push(n);
      } else {
        if (typeof n == "object" && n !== null && "text" in n && n.text === "") continue;
        t.push(n);
      }
      return t;
    }
  }
}
function ym(r, e) {
  if (!r && !e) throw new Error("Cannot merge two undefined objects.");
  if (!r || !e) return r || e;
  if (typeof r != typeof e) throw new Error(`Cannot merge objects of different types.
Left ${typeof r}
Right ${typeof e}`);
  if (typeof r == "string" && typeof e == "string") return r + e;
  if (Array.isArray(r) && Array.isArray(e)) return ia(r, e);
  if (typeof r == "object" && typeof e == "object") return Tt(r, e);
  if (r === e) return r;
  throw new Error(`Can not merge objects of different types.
Left ${r}
Right ${e}`);
}
var dn = class wm extends Vr {
  static isInstance(e) {
    if (!super.isInstance(e)) return !1;
    let t = Object.getPrototypeOf(e);
    for (; t !== null; ) {
      if (t === wm.prototype) return !0;
      t = Object.getPrototypeOf(t);
    }
    return !1;
  }
};
function vm(r) {
  return typeof r.role == "string";
}
function Xr(r) {
  return typeof (r == null ? void 0 : r._getType) == "function";
}
function tl(r) {
  return dn.isInstance(r);
}
function bm(r, e) {
  return Tt(r ?? {}, e ?? {});
}
function Sm(r, e) {
  const t = {};
  return ((r == null ? void 0 : r.audio) !== void 0 || (e == null ? void 0 : e.audio) !== void 0) && (t.audio = ((r == null ? void 0 : r.audio) ?? 0) + ((e == null ? void 0 : e.audio) ?? 0)), ((r == null ? void 0 : r.image) !== void 0 || (e == null ? void 0 : e.image) !== void 0) && (t.image = ((r == null ? void 0 : r.image) ?? 0) + ((e == null ? void 0 : e.image) ?? 0)), ((r == null ? void 0 : r.video) !== void 0 || (e == null ? void 0 : e.video) !== void 0) && (t.video = ((r == null ? void 0 : r.video) ?? 0) + ((e == null ? void 0 : e.video) ?? 0)), ((r == null ? void 0 : r.document) !== void 0 || (e == null ? void 0 : e.document) !== void 0) && (t.document = ((r == null ? void 0 : r.document) ?? 0) + ((e == null ? void 0 : e.document) ?? 0)), ((r == null ? void 0 : r.text) !== void 0 || (e == null ? void 0 : e.text) !== void 0) && (t.text = ((r == null ? void 0 : r.text) ?? 0) + ((e == null ? void 0 : e.text) ?? 0)), t;
}
function hv(r, e) {
  const t = { ...Sm(r, e) };
  return ((r == null ? void 0 : r.cache_read) !== void 0 || (e == null ? void 0 : e.cache_read) !== void 0) && (t.cache_read = ((r == null ? void 0 : r.cache_read) ?? 0) + ((e == null ? void 0 : e.cache_read) ?? 0)), ((r == null ? void 0 : r.cache_creation) !== void 0 || (e == null ? void 0 : e.cache_creation) !== void 0) && (t.cache_creation = ((r == null ? void 0 : r.cache_creation) ?? 0) + ((e == null ? void 0 : e.cache_creation) ?? 0)), t;
}
function fv(r, e) {
  const t = { ...Sm(r, e) };
  return ((r == null ? void 0 : r.reasoning) !== void 0 || (e == null ? void 0 : e.reasoning) !== void 0) && (t.reasoning = ((r == null ? void 0 : r.reasoning) ?? 0) + ((e == null ? void 0 : e.reasoning) ?? 0)), t;
}
function Tm(r, e) {
  return {
    input_tokens: ((r == null ? void 0 : r.input_tokens) ?? 0) + ((e == null ? void 0 : e.input_tokens) ?? 0),
    output_tokens: ((r == null ? void 0 : r.output_tokens) ?? 0) + ((e == null ? void 0 : e.output_tokens) ?? 0),
    total_tokens: ((r == null ? void 0 : r.total_tokens) ?? 0) + ((e == null ? void 0 : e.total_tokens) ?? 0),
    input_token_details: hv(r == null ? void 0 : r.input_token_details, e == null ? void 0 : e.input_token_details),
    output_token_details: fv(r == null ? void 0 : r.output_token_details, e == null ? void 0 : e.output_token_details)
  };
}
var pv = {};
Ae(pv, {
  ToolMessage: () => Ir,
  ToolMessageChunk: () => oa,
  defaultToolCallParser: () => nl,
  isDirectToolOutput: () => rl,
  isToolMessage: () => Em,
  isToolMessageChunk: () => xm
});
function rl(r) {
  return r != null && typeof r == "object" && "lc_direct_tool_output" in r && r.lc_direct_tool_output === !0;
}
var Ir = class extends Vr {
  constructor(e, t, n) {
    const s = typeof e == "string" || Array.isArray(e) ? {
      content: e,
      name: n,
      tool_call_id: t
    } : e;
    super(s);
    b(this, "lc_direct_tool_output", !0);
    b(this, "type", "tool");
    /**
    * Status of the tool invocation.
    * @version 0.2.19
    */
    b(this, "status");
    b(this, "tool_call_id");
    b(this, "metadata");
    /**
    * Artifact of the Tool execution which is not meant to be sent to the model.
    *
    * Should only be specified if it is different from the message content, e.g. if only
    * a subset of the full tool output is being passed as message content but the full
    * output is needed in other parts of the code.
    */
    b(this, "artifact");
    this.tool_call_id = s.tool_call_id, this.artifact = s.artifact, this.status = s.status, this.metadata = s.metadata;
  }
  static lc_name() {
    return "ToolMessage";
  }
  get lc_aliases() {
    return { tool_call_id: "tool_call_id" };
  }
  static isInstance(e) {
    return super.isInstance(e) && e.type === "tool";
  }
  get _printableFields() {
    return {
      ...super._printableFields,
      tool_call_id: this.tool_call_id,
      artifact: this.artifact
    };
  }
}, oa = class extends dn {
  constructor(e) {
    super(e);
    b(this, "type", "tool");
    b(this, "tool_call_id");
    /**
    * Status of the tool invocation.
    * @version 0.2.19
    */
    b(this, "status");
    /**
    * Artifact of the Tool execution which is not meant to be sent to the model.
    *
    * Should only be specified if it is different from the message content, e.g. if only
    * a subset of the full tool output is being passed as message content but the full
    * output is needed in other parts of the code.
    */
    b(this, "artifact");
    this.tool_call_id = e.tool_call_id, this.artifact = e.artifact, this.status = e.status;
  }
  static lc_name() {
    return "ToolMessageChunk";
  }
  concat(e) {
    const t = this.constructor;
    return new t({
      content: Fr(this.content, e.content),
      additional_kwargs: Tt(this.additional_kwargs, e.additional_kwargs),
      response_metadata: Tt(this.response_metadata, e.response_metadata),
      artifact: ym(this.artifact, e.artifact),
      tool_call_id: this.tool_call_id,
      id: this.id ?? e.id,
      status: _m(this.status, e.status)
    });
  }
  get _printableFields() {
    return {
      ...super._printableFields,
      tool_call_id: this.tool_call_id,
      artifact: this.artifact
    };
  }
};
function nl(r) {
  const e = [], t = [];
  for (const n of r) if (n.function) {
    const s = n.function.name;
    try {
      const a = JSON.parse(n.function.arguments);
      e.push({
        name: s || "",
        args: a || {},
        id: n.id
      });
    } catch {
      t.push({
        name: s,
        args: n.function.arguments,
        id: n.id,
        error: "Malformed args."
      });
    }
  } else
    continue;
  return [e, t];
}
function Em(r) {
  return typeof r == "object" && r !== null && "getType" in r && typeof r.getType == "function" && r.getType() === "tool";
}
function xm(r) {
  return r._getType() === "tool";
}
var In = class km extends Vr {
  constructor(t, n) {
    (typeof t == "string" || Array.isArray(t)) && (t = {
      content: t,
      role: n
    });
    super(t);
    b(this, "type", "generic");
    b(this, "role");
    this.role = t.role;
  }
  static lc_name() {
    return "ChatMessage";
  }
  static _chatMessageClass() {
    return km;
  }
  static isInstance(t) {
    return super.isInstance(t) && t.type === "generic";
  }
  get _printableFields() {
    return {
      ...super._printableFields,
      role: this.role
    };
  }
}, ca = class extends dn {
  constructor(e, t) {
    (typeof e == "string" || Array.isArray(e)) && (e = {
      content: e,
      role: t
    });
    super(e);
    b(this, "type", "generic");
    b(this, "role");
    this.role = e.role;
  }
  static lc_name() {
    return "ChatMessageChunk";
  }
  concat(e) {
    const t = this.constructor;
    return new t({
      content: Fr(this.content, e.content),
      additional_kwargs: Tt(this.additional_kwargs, e.additional_kwargs),
      response_metadata: Tt(this.response_metadata, e.response_metadata),
      role: this.role,
      id: this.id ?? e.id
    });
  }
  static isInstance(e) {
    return super.isInstance(e) && e.type === "generic";
  }
  get _printableFields() {
    return {
      ...super._printableFields,
      role: this.role
    };
  }
};
function mv(r) {
  return r._getType() === "generic";
}
function gv(r) {
  return r._getType() === "generic";
}
var io = class extends Vr {
  constructor(e) {
    super(e);
    b(this, "type", "function");
    b(this, "name");
    this.name = e.name;
  }
  static lc_name() {
    return "FunctionMessage";
  }
}, ua = class extends dn {
  constructor() {
    super(...arguments);
    b(this, "type", "function");
  }
  static lc_name() {
    return "FunctionMessageChunk";
  }
  concat(e) {
    const t = this.constructor;
    return new t({
      content: Fr(this.content, e.content),
      additional_kwargs: Tt(this.additional_kwargs, e.additional_kwargs),
      response_metadata: Tt(this.response_metadata, e.response_metadata),
      name: this.name ?? "",
      id: this.id ?? e.id
    });
  }
};
function _v(r) {
  return r._getType() === "function";
}
function yv(r) {
  return r._getType() === "function";
}
var zt = class extends Vr {
  constructor(e) {
    super(e);
    b(this, "type", "human");
  }
  static lc_name() {
    return "HumanMessage";
  }
  static isInstance(e) {
    return super.isInstance(e) && e.type === "human";
  }
}, la = class extends dn {
  constructor(e) {
    super(e);
    b(this, "type", "human");
  }
  static lc_name() {
    return "HumanMessageChunk";
  }
  concat(e) {
    const t = this.constructor;
    return new t({
      content: Fr(this.content, e.content),
      additional_kwargs: Tt(this.additional_kwargs, e.additional_kwargs),
      response_metadata: Tt(this.response_metadata, e.response_metadata),
      id: this.id ?? e.id
    });
  }
  static isInstance(e) {
    return super.isInstance(e) && e.type === "human";
  }
};
function wv(r) {
  return r.getType() === "human";
}
function vv(r) {
  return r.getType() === "human";
}
var bi = class extends Vr {
  constructor(e) {
    super({
      ...e,
      content: []
    });
    b(this, "type", "remove");
    /**
    * The ID of the message to remove.
    */
    b(this, "id");
    this.id = e.id;
  }
  get _printableFields() {
    return {
      ...super._printableFields,
      id: this.id
    };
  }
  static isInstance(e) {
    return super.isInstance(e) && e.type === "remove";
  }
}, ct = class ii extends Vr {
  constructor(t) {
    super(t);
    b(this, "type", "system");
  }
  static lc_name() {
    return "SystemMessage";
  }
  /**
  * Concatenates a string or another system message with the current system message.
  * @param chunk - The chunk to concatenate with the system message.
  * @returns A new system message with the concatenated content.
  */
  concat(t) {
    if (typeof t == "string") return new ii({
      ...this,
      content: Fr(this.content, t)
    });
    if (ii.isInstance(t)) return new ii({
      ...this,
      additional_kwargs: {
        ...this.additional_kwargs,
        ...t.additional_kwargs
      },
      response_metadata: {
        ...this.response_metadata,
        ...t.response_metadata
      },
      content: Fr(this.content, t.content)
    });
    throw new Error("Unexpected chunk type for system message");
  }
  static isInstance(t) {
    return super.isInstance(t) && t.type === "system";
  }
}, sn = class extends dn {
  constructor(e) {
    super(e);
    b(this, "type", "system");
  }
  static lc_name() {
    return "SystemMessageChunk";
  }
  concat(e) {
    const t = this.constructor;
    return new t({
      content: Fr(this.content, e.content),
      additional_kwargs: Tt(this.additional_kwargs, e.additional_kwargs),
      response_metadata: Tt(this.response_metadata, e.response_metadata),
      id: this.id ?? e.id
    });
  }
  static isInstance(e) {
    return super.isInstance(e) && e.type === "system";
  }
};
function bv(r) {
  return r._getType() === "system";
}
function Sv(r) {
  return r._getType() === "system";
}
function Im(r, e) {
  return r.lc_error_code = e, r.message = `${r.message}

Troubleshooting URL: https://docs.langchain.com/oss/javascript/langchain/errors/${e}/
`, r;
}
function js(r) {
  return !!(r && typeof r == "object" && "type" in r && r.type === "tool_call");
}
function Tv(r) {
  return !!(r && typeof r == "object" && "toolCall" in r && r.toolCall != null && typeof r.toolCall == "object" && "id" in r.toolCall && typeof r.toolCall.id == "string");
}
var Si = class extends Error {
  constructor(e, t) {
    super(e);
    b(this, "output");
    this.output = t;
  }
};
function Lc(r, e = oo) {
  r = r.trim();
  const t = r.indexOf("```");
  if (t === -1) return e(r);
  let n = r.substring(t + 3);
  n.startsWith(`json
`) ? n = n.substring(5) : n.startsWith("json") ? n = n.substring(4) : n.startsWith(`
`) && (n = n.substring(1));
  const s = n.indexOf("```");
  let a = n;
  return s !== -1 && (a = n.substring(0, s)), e(a.trim());
}
function Ev(r) {
  try {
    return JSON.parse(r);
  } catch {
  }
  const e = r.trim();
  if (e.length === 0) throw new Error("Unexpected end of JSON input");
  let t = 0;
  function n() {
    for (; t < e.length && /\s/.test(e[t]); ) t += 1;
  }
  function s() {
    if (e[t] !== '"') throw new Error(`Expected '"' at position ${t}, got '${e[t]}'`);
    t += 1;
    let l = "", d = !1;
    for (; t < e.length; ) {
      const h = e[t];
      if (d) {
        if (h === "n") l += `
`;
        else if (h === "t") l += "	";
        else if (h === "r") l += "\r";
        else if (h === "\\") l += "\\";
        else if (h === '"') l += '"';
        else if (h === "b") l += "\b";
        else if (h === "f") l += "\f";
        else if (h === "/") l += "/";
        else if (h === "u") {
          const f = e.substring(t + 1, t + 5);
          if (/^[0-9A-Fa-f]{0,4}$/.test(f))
            f.length === 4 ? l += String.fromCharCode(Number.parseInt(f, 16)) : l += `u${f}`, t += f.length;
          else throw new Error(`Invalid unicode escape sequence '\\u${f}' at position ${t}`);
        } else throw new Error(`Invalid escape sequence '\\${h}' at position ${t}`);
        d = !1;
      } else if (h === "\\") d = !0;
      else {
        if (h === '"')
          return t += 1, l;
        l += h;
      }
      t += 1;
    }
    return d && (l += "\\"), l;
  }
  function a() {
    const l = t;
    let d = "";
    if (e[t] === "-" && (d += "-", t += 1), t < e.length && e[t] === "0" && (d += "0", t += 1, e[t] >= "0" && e[t] <= "9"))
      throw new Error(`Invalid number at position ${l}`);
    if (t < e.length && e[t] >= "1" && e[t] <= "9") for (; t < e.length && e[t] >= "0" && e[t] <= "9"; )
      d += e[t], t += 1;
    if (t < e.length && e[t] === ".")
      for (d += ".", t += 1; t < e.length && e[t] >= "0" && e[t] <= "9"; )
        d += e[t], t += 1;
    if (t < e.length && (e[t] === "e" || e[t] === "E"))
      for (d += e[t], t += 1, t < e.length && (e[t] === "+" || e[t] === "-") && (d += e[t], t += 1); t < e.length && e[t] >= "0" && e[t] <= "9"; )
        d += e[t], t += 1;
    if (d === "-") return -0;
    const h = Number.parseFloat(d);
    if (Number.isNaN(h))
      throw t = l, new Error(`Invalid number '${d}' at position ${l}`);
    return h;
  }
  function i() {
    if (n(), t >= e.length) throw new Error(`Unexpected end of input at position ${t}`);
    const l = e[t];
    if (l === "{") return c();
    if (l === "[") return o();
    if (l === '"') return s();
    if ("null".startsWith(e.substring(t, t + 4)))
      return t += Math.min(4, e.length - t), null;
    if ("true".startsWith(e.substring(t, t + 4)))
      return t += Math.min(4, e.length - t), !0;
    if ("false".startsWith(e.substring(t, t + 5)))
      return t += Math.min(5, e.length - t), !1;
    if (l === "-" || l >= "0" && l <= "9") return a();
    throw new Error(`Unexpected character '${l}' at position ${t}`);
  }
  function o() {
    if (e[t] !== "[") throw new Error(`Expected '[' at position ${t}, got '${e[t]}'`);
    const l = [];
    if (t += 1, n(), t >= e.length) return l;
    if (e[t] === "]")
      return t += 1, l;
    for (; t < e.length; ) {
      if (n(), t >= e.length || (l.push(i()), n(), t >= e.length)) return l;
      if (e[t] === "]")
        return t += 1, l;
      if (e[t] === ",") {
        t += 1;
        continue;
      }
      throw new Error(`Expected ',' or ']' at position ${t}, got '${e[t]}'`);
    }
    return l;
  }
  function c() {
    if (e[t] !== "{") throw new Error(`Expected '{' at position ${t}, got '${e[t]}'`);
    const l = {};
    if (t += 1, n(), t >= e.length) return l;
    if (e[t] === "}")
      return t += 1, l;
    for (; t < e.length; ) {
      if (n(), t >= e.length) return l;
      const d = s();
      if (n(), t >= e.length) return l;
      if (e[t] !== ":") throw new Error(`Expected ':' at position ${t}, got '${e[t]}'`);
      if (t += 1, n(), t >= e.length || (l[d] = i(), n(), t >= e.length)) return l;
      if (e[t] === "}")
        return t += 1, l;
      if (e[t] === ",") {
        t += 1;
        continue;
      }
      throw new Error(`Expected ',' or '}' at position ${t}, got '${e[t]}'`);
    }
    return l;
  }
  const u = i();
  if (n(), t < e.length) throw new Error(`Unexpected character '${e[t]}' at position ${t}`);
  return u;
}
function oo(r) {
  try {
    return typeof r > "u" ? null : Ev(r);
  } catch {
    return null;
  }
}
function sl(r) {
  switch (r) {
    case "csv":
      return "text/csv";
    case "doc":
      return "application/vnd.openxmlformats-officedocument.wordprocessingml.document";
    case "docx":
      return "application/vnd.openxmlformats-officedocument.wordprocessingml.document";
    case "html":
      return "text/html";
    case "md":
      return "text/markdown";
    case "pdf":
      return "application/pdf";
    case "txt":
      return "text/plain";
    case "xls":
      return "application/vnd.ms-excel";
    case "xlsx":
      return "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet";
    case "gif":
      return "image/gif";
    case "jpeg":
      return "image/jpeg";
    case "jpg":
      return "image/jpeg";
    case "png":
      return "image/png";
    case "webp":
      return "image/webp";
    case "flv":
      return "video/flv";
    case "mkv":
      return "video/mkv";
    case "mov":
      return "video/mov";
    case "mp4":
      return "video/mp4";
    case "mpeg":
      return "video/mpeg";
    case "mpg":
      return "video/mpg";
    case "three_gp":
      return "video/three_gp";
    case "webm":
      return "video/webm";
    case "wmv":
      return "video/wmv";
    default:
      return "application/octet-stream";
  }
}
function xv(r) {
  if (be(r.document) && be(r.document.source)) {
    const e = be(r.document) && K(r.document.format) ? r.document.format : "", t = sl(e);
    if (be(r.document.source)) {
      if (be(r.document.source.s3Location) && K(r.document.source.s3Location.uri)) return {
        type: "file",
        mimeType: t,
        fileId: r.document.source.s3Location.uri
      };
      if (Qu(r.document.source.bytes)) return {
        type: "file",
        mimeType: t,
        data: r.document.source.bytes
      };
      if (K(r.document.source.text)) return {
        type: "file",
        mimeType: t,
        data: Buffer.from(r.document.source.text).toString("base64")
      };
      if (Tr(r.document.source.content)) {
        const n = r.document.source.content.reduce((s, a) => be(a) && K(a.text) ? s + a.text : s, "");
        return {
          type: "file",
          mimeType: t,
          data: n
        };
      }
    }
  }
  return {
    type: "non_standard",
    value: r
  };
}
function kv(r) {
  if (ue(r, "image") && be(r.image)) {
    const e = be(r.image) && K(r.image.format) ? r.image.format : "", t = sl(e);
    if (be(r.image.source)) {
      if (be(r.image.source.s3Location) && K(r.image.source.s3Location.uri)) return {
        type: "image",
        mimeType: t,
        fileId: r.image.source.s3Location.uri
      };
      if (Qu(r.image.source.bytes)) return {
        type: "image",
        mimeType: t,
        data: r.image.source.bytes
      };
    }
  }
  return {
    type: "non_standard",
    value: r
  };
}
function Iv(r) {
  if (ue(r, "video") && be(r.video)) {
    const e = be(r.video) && K(r.video.format) ? r.video.format : "", t = sl(e);
    if (be(r.video.source)) {
      if (be(r.video.source.s3Location) && K(r.video.source.s3Location.uri)) return {
        type: "video",
        mimeType: t,
        fileId: r.video.source.s3Location.uri
      };
      if (Qu(r.video.source.bytes)) return {
        type: "video",
        mimeType: t,
        data: r.video.source.bytes
      };
    }
  }
  return {
    type: "non_standard",
    value: r
  };
}
function $d(r) {
  function* e() {
    const t = typeof r.content == "string" ? [{
      type: "text",
      text: r.content
    }] : r.content;
    for (const n of t) {
      if (ue(n, "cache_point")) {
        yield {
          type: "non_standard",
          value: n
        };
        continue;
      } else if (ue(n, "citations_content") && be(n.citationsContent)) {
        const s = Tr(n.citationsContent.content) ? n.citationsContent.content.reduce((i, o) => be(o) && K(o.text) ? i + o.text : i, "") : "", a = Tr(n.citationsContent.citations) ? n.citationsContent.citations.reduce((i, o) => {
          if (be(o)) {
            const c = Tr(o.sourceContent) ? o.sourceContent.reduce((l, d) => be(d) && K(d.text) ? l + d.text : l, "") : "", u = Hs(() => {
              if (be(o.location)) {
                const l = o.location.documentChar || o.location.documentPage || o.location.documentChunk;
                if (be(l)) return {
                  source: or(l.documentIndex) ? l.documentIndex.toString() : void 0,
                  startIndex: or(l.start) ? l.start : void 0,
                  endIndex: or(l.end) ? l.end : void 0
                };
              }
              return {};
            });
            i.push({
              type: "citation",
              citedText: c,
              ...u
            });
          }
          return i;
        }, []) : [];
        yield {
          type: "text",
          text: s,
          annotations: a
        };
        continue;
      } else if (ue(n, "document") && be(n.document)) {
        yield xv(n);
        continue;
      } else if (ue(n, "guard_content")) {
        yield {
          type: "non_standard",
          value: n
        };
        continue;
      } else if (ue(n, "image") && be(n.image)) {
        yield kv(n);
        continue;
      } else if (ue(n, "reasoning_content") && K(n.reasoningText)) {
        yield {
          type: "reasoning",
          reasoning: n.reasoningText
        };
        continue;
      } else if (ue(n, "text") && K(n.text)) {
        yield {
          type: "text",
          text: n.text
        };
        continue;
      } else if (ue(n, "tool_result")) {
        yield {
          type: "non_standard",
          value: n
        };
        continue;
      } else {
        if (ue(n, "tool_call")) continue;
        if (ue(n, "video") && be(n.video)) {
          yield Iv(n);
          continue;
        }
      }
      yield {
        type: "non_standard",
        value: n
      };
    }
  }
  return Array.from(e());
}
const Ov = {
  translateContent: $d,
  translateContentChunk: $d
};
function Cd(r) {
  function* e() {
    const t = typeof r.content == "string" ? [{
      type: "text",
      text: r.content
    }] : r.content;
    for (const n of t) {
      if (ue(n, "text") && K(n.text)) {
        yield {
          type: "text",
          text: n.text
        };
        continue;
      } else if (ue(n, "inlineData") && be(n.inlineData) && K(n.inlineData.mimeType) && K(n.inlineData.data)) {
        yield {
          type: "file",
          mimeType: n.inlineData.mimeType,
          data: n.inlineData.data
        };
        continue;
      } else if (ue(n, "functionCall") && be(n.functionCall) && K(n.functionCall.name) && be(n.functionCall.args)) {
        yield {
          type: "tool_call",
          id: r.id,
          name: n.functionCall.name,
          args: n.functionCall.args
        };
        continue;
      } else if (ue(n, "functionResponse")) {
        yield {
          type: "non_standard",
          value: n
        };
        continue;
      } else if (ue(n, "fileData") && be(n.fileData) && K(n.fileData.mimeType) && K(n.fileData.fileUri)) {
        yield {
          type: "file",
          mimeType: n.fileData.mimeType,
          fileId: n.fileData.fileUri
        };
        continue;
      } else if (ue(n, "executableCode")) {
        yield {
          type: "non_standard",
          value: n
        };
        continue;
      } else if (ue(n, "codeExecutionResult")) {
        yield {
          type: "non_standard",
          value: n
        };
        continue;
      }
      yield {
        type: "non_standard",
        value: n
      };
    }
  }
  return Array.from(e());
}
const Av = {
  translateContent: Cd,
  translateContentChunk: Cd
};
function Rd(r) {
  function* e() {
    const t = typeof r.content == "string" ? [{
      type: "text",
      text: r.content
    }] : r.content;
    for (const n of t) {
      if (ue(n, "reasoning") && K(n.reasoning)) {
        const s = Hs(() => {
          var i;
          const a = t.indexOf(n);
          if (Tr((i = r.additional_kwargs) == null ? void 0 : i.signatures) && a >= 0) return r.additional_kwargs.signatures.at(a);
        });
        K(s) ? yield {
          type: "reasoning",
          reasoning: n.reasoning,
          signature: s
        } : yield {
          type: "reasoning",
          reasoning: n.reasoning
        };
        continue;
      } else if (ue(n, "text") && K(n.text)) {
        yield {
          type: "text",
          text: n.text
        };
        continue;
      } else if (ue(n, "image_url")) {
        if (K(n.image_url)) if (n.image_url.startsWith("data:")) {
          const s = /^data:([^;]+);base64,(.+)$/, a = n.image_url.match(s);
          a ? yield {
            type: "image",
            data: a[2],
            mimeType: a[1]
          } : yield {
            type: "image",
            url: n.image_url
          };
        } else yield {
          type: "image",
          url: n.image_url
        };
        continue;
      } else if (ue(n, "media") && K(n.mimeType) && K(n.data)) {
        yield {
          type: "file",
          mimeType: n.mimeType,
          data: n.data
        };
        continue;
      }
      yield {
        type: "non_standard",
        value: n
      };
    }
  }
  return Array.from(e());
}
const $v = {
  translateContent: Rd,
  translateContentChunk: Rd
};
globalThis.lc_block_translators_registry ?? (globalThis.lc_block_translators_registry = /* @__PURE__ */ new Map([
  ["anthropic", Yw],
  ["bedrock-converse", Ov],
  ["google-genai", Av],
  ["google-vertexai", $v],
  ["openai", ov]
]));
function Om(r) {
  return globalThis.lc_block_translators_registry.get(r);
}
var Fe = class extends Vr {
  constructor(e) {
    var n;
    let t;
    if (typeof e == "string" || Array.isArray(e)) t = {
      content: e,
      tool_calls: [],
      invalid_tool_calls: [],
      additional_kwargs: {}
    };
    else {
      t = e;
      const s = (n = t.additional_kwargs) == null ? void 0 : n.tool_calls, a = t.tool_calls;
      s != null && s.length > 0 && (a === void 0 || a.length === 0) && console.warn([
        "New LangChain packages are available that more efficiently handle",
        `tool calling.

Please upgrade your packages to versions that set`,
        "message tool calls. e.g., `pnpm install @langchain/anthropic`,",
        "pnpm install @langchain/openai`, etc."
      ].join(" "));
      try {
        if (s != null && a === void 0) {
          const [i, o] = nl(s);
          t.tool_calls = i ?? [], t.invalid_tool_calls = o ?? [];
        } else
          t.tool_calls = t.tool_calls ?? [], t.invalid_tool_calls = t.invalid_tool_calls ?? [];
      } catch {
        t.tool_calls = [], t.invalid_tool_calls = [];
      }
      if (t.response_metadata !== void 0 && "output_version" in t.response_metadata && t.response_metadata.output_version === "v1" && (t.contentBlocks = t.content, t.content = void 0), t.contentBlocks !== void 0) {
        t.contentBlocks.push(...t.tool_calls.map((o) => ({
          type: "tool_call",
          id: o.id,
          name: o.name,
          args: o.args
        })));
        const i = t.contentBlocks.filter((o) => o.type === "tool_call").filter((o) => {
          var c;
          return !((c = t.tool_calls) != null && c.some((u) => u.id === o.id && u.name === o.name));
        });
        i.length > 0 && (t.tool_calls = i.map((o) => ({
          type: "tool_call",
          id: o.id,
          name: o.name,
          args: o.args
        })));
      }
    }
    super(t);
    b(this, "type", "ai");
    b(this, "tool_calls", []);
    b(this, "invalid_tool_calls", []);
    b(this, "usage_metadata");
    typeof t != "string" && (this.tool_calls = t.tool_calls ?? this.tool_calls, this.invalid_tool_calls = t.invalid_tool_calls ?? this.invalid_tool_calls), this.usage_metadata = t.usage_metadata;
  }
  get lc_aliases() {
    return {
      ...super.lc_aliases,
      tool_calls: "tool_calls",
      invalid_tool_calls: "invalid_tool_calls"
    };
  }
  static lc_name() {
    return "AIMessage";
  }
  get contentBlocks() {
    if (this.response_metadata && "output_version" in this.response_metadata && this.response_metadata.output_version === "v1") return this.content;
    if (this.response_metadata && "model_provider" in this.response_metadata && typeof this.response_metadata.model_provider == "string") {
      const t = Om(this.response_metadata.model_provider);
      if (t) return t.translateContent(this);
    }
    const e = super.contentBlocks;
    if (this.tool_calls) {
      const t = this.tool_calls.filter((n) => !e.some((s) => s.id === n.id && s.name === n.name));
      e.push(...t.map((n) => ({
        ...n,
        type: "tool_call",
        id: n.id,
        name: n.name,
        args: n.args
      })));
    }
    return e;
  }
  get _printableFields() {
    return {
      ...super._printableFields,
      tool_calls: this.tool_calls,
      invalid_tool_calls: this.invalid_tool_calls,
      usage_metadata: this.usage_metadata
    };
  }
  static isInstance(e) {
    return super.isInstance(e) && e.type === "ai";
  }
};
function co(r) {
  return r._getType() === "ai";
}
function Mc(r) {
  return r._getType() === "ai";
}
var Ar = class extends dn {
  constructor(e) {
    let t;
    typeof e == "string" || Array.isArray(e) ? t = {
      content: e,
      tool_calls: [],
      invalid_tool_calls: [],
      tool_call_chunks: []
    } : e.tool_call_chunks === void 0 || e.tool_call_chunks.length === 0 ? t = {
      ...e,
      tool_calls: e.tool_calls ?? [],
      invalid_tool_calls: [],
      tool_call_chunks: [],
      usage_metadata: e.usage_metadata !== void 0 ? e.usage_metadata : void 0
    } : t = {
      ...e,
      ...$m(e.tool_call_chunks ?? []),
      usage_metadata: e.usage_metadata !== void 0 ? e.usage_metadata : void 0
    };
    super(t);
    b(this, "type", "ai");
    b(this, "tool_calls", []);
    b(this, "invalid_tool_calls", []);
    b(this, "tool_call_chunks", []);
    b(this, "usage_metadata");
    this.tool_call_chunks = t.tool_call_chunks ?? this.tool_call_chunks, this.tool_calls = t.tool_calls ?? this.tool_calls, this.invalid_tool_calls = t.invalid_tool_calls ?? this.invalid_tool_calls, this.usage_metadata = t.usage_metadata;
  }
  get lc_aliases() {
    return {
      ...super.lc_aliases,
      tool_calls: "tool_calls",
      invalid_tool_calls: "invalid_tool_calls",
      tool_call_chunks: "tool_call_chunks"
    };
  }
  static lc_name() {
    return "AIMessageChunk";
  }
  get contentBlocks() {
    if (this.response_metadata && "output_version" in this.response_metadata && this.response_metadata.output_version === "v1") return this.content;
    if (this.response_metadata && "model_provider" in this.response_metadata && typeof this.response_metadata.model_provider == "string") {
      const t = Om(this.response_metadata.model_provider);
      if (t) return t.translateContent(this);
    }
    const e = super.contentBlocks;
    if (this.tool_calls && typeof this.content != "string") {
      const t = this.content.filter((n) => n.type === "tool_call").map((n) => n.id);
      for (const n of this.tool_calls) n.id && !t.includes(n.id) && e.push({
        ...n,
        type: "tool_call",
        id: n.id,
        name: n.name,
        args: n.args
      });
    }
    return e;
  }
  get _printableFields() {
    return {
      ...super._printableFields,
      tool_calls: this.tool_calls,
      tool_call_chunks: this.tool_call_chunks,
      invalid_tool_calls: this.invalid_tool_calls,
      usage_metadata: this.usage_metadata
    };
  }
  concat(e) {
    const t = {
      content: Fr(this.content, e.content),
      additional_kwargs: Tt(this.additional_kwargs, e.additional_kwargs),
      response_metadata: bm(this.response_metadata, e.response_metadata),
      tool_call_chunks: [],
      id: this.id ?? e.id
    };
    if (this.tool_call_chunks !== void 0 || e.tool_call_chunks !== void 0) {
      const s = ia(this.tool_call_chunks, e.tool_call_chunks);
      s !== void 0 && s.length > 0 && (t.tool_call_chunks = s);
    }
    (this.usage_metadata !== void 0 || e.usage_metadata !== void 0) && (t.usage_metadata = Tm(this.usage_metadata, e.usage_metadata));
    const n = this.constructor;
    return new n(t);
  }
  static isInstance(e) {
    return super.isInstance(e) && e.type === "ai";
  }
};
const Am = (r) => r();
function Cv(r) {
  return js(r) ? r : typeof r.id == "string" && r.type === "function" && typeof r.function == "object" && r.function !== null && "arguments" in r.function && typeof r.function.arguments == "string" && "name" in r.function && typeof r.function.name == "string" ? {
    id: r.id,
    args: JSON.parse(r.function.arguments),
    name: r.function.name,
    type: "tool_call"
  } : r;
}
function Rv(r) {
  return typeof r == "object" && r != null && r.lc === 1 && Array.isArray(r.id) && r.kwargs != null && typeof r.kwargs == "object";
}
function Ho(r) {
  let e, t;
  if (Rv(r)) {
    const n = r.id.at(-1);
    n === "HumanMessage" || n === "HumanMessageChunk" ? e = "user" : n === "AIMessage" || n === "AIMessageChunk" ? e = "assistant" : n === "SystemMessage" || n === "SystemMessageChunk" ? e = "system" : n === "FunctionMessage" || n === "FunctionMessageChunk" ? e = "function" : n === "ToolMessage" || n === "ToolMessageChunk" ? e = "tool" : e = "unknown", t = r.kwargs;
  } else {
    const { type: n, ...s } = r;
    e = n, t = s;
  }
  if (e === "human" || e === "user") return new zt(t);
  if (e === "ai" || e === "assistant") {
    const { tool_calls: n, ...s } = t;
    if (!Array.isArray(n)) return new Fe(t);
    const a = n.map(Cv);
    return new Fe({
      ...s,
      tool_calls: a
    });
  } else {
    if (e === "system") return new ct(t);
    if (e === "developer") return new ct({
      ...t,
      additional_kwargs: {
        ...t.additional_kwargs,
        __openai_role__: "developer"
      }
    });
    if (e === "tool" && "tool_call_id" in t) return new Ir({
      ...t,
      content: t.content,
      tool_call_id: t.tool_call_id,
      name: t.name
    });
    if (e === "remove" && "id" in t && typeof t.id == "string") return new bi({
      ...t,
      id: t.id
    });
    throw Im(/* @__PURE__ */ new Error(`Unable to coerce message from array: only human, AI, system, developer, or tool message coercion is currently supported.

Received: ${JSON.stringify(r, null, 2)}`), "MESSAGE_COERCION_FAILURE");
  }
}
function Fs(r) {
  if (typeof r == "string") return new zt(r);
  if (Xr(r)) return r;
  if (Array.isArray(r)) {
    const [e, t] = r;
    return Ho({
      type: e,
      content: t
    });
  } else if (vm(r)) {
    const { role: e, ...t } = r;
    return Ho({
      ...t,
      type: e
    });
  } else return Ho(r);
}
function al(r, e = "Human", t = "AI") {
  const n = [];
  for (const s of r) {
    let a;
    if (s._getType() === "human") a = e;
    else if (s._getType() === "ai") a = t;
    else if (s._getType() === "system") a = "System";
    else if (s._getType() === "tool") a = "Tool";
    else if (s._getType() === "generic") a = s.role;
    else throw new Error(`Got unsupported message type: ${s._getType()}`);
    const i = s.name ? `${s.name}, ` : "", o = typeof s.content == "string" ? s.content : JSON.stringify(s.content, null, 2);
    n.push(`${a}: ${i}${o}`);
  }
  return n.join(`
`);
}
function Nv(r) {
  if (r.data !== void 0) return r;
  {
    const e = r;
    return {
      type: e.type,
      data: {
        content: e.text,
        role: e.role,
        name: void 0,
        tool_call_id: void 0
      }
    };
  }
}
function il(r) {
  const e = Nv(r);
  switch (e.type) {
    case "human":
      return new zt(e.data);
    case "ai":
      return new Fe(e.data);
    case "system":
      return new ct(e.data);
    case "function":
      if (e.data.name === void 0) throw new Error("Name must be defined for function messages");
      return new io(e.data);
    case "tool":
      if (e.data.tool_call_id === void 0) throw new Error("Tool call ID must be defined for tool messages");
      return new Ir(e.data);
    case "generic":
      if (e.data.role === void 0) throw new Error("Role must be defined for chat messages");
      return new In(e.data);
    default:
      throw new Error(`Got unexpected type: ${e.type}`);
  }
}
function Pv(r) {
  return r.map(il);
}
function Lv(r) {
  return r.map((e) => e.toDict());
}
function Ti(r) {
  var t;
  const e = r._getType();
  if (e === "human") return new la({ ...r });
  if (e === "ai") {
    let n = { ...r };
    return "tool_calls" in n && (n = {
      ...n,
      tool_call_chunks: (t = n.tool_calls) == null ? void 0 : t.map((s) => ({
        ...s,
        type: "tool_call_chunk",
        index: void 0,
        args: JSON.stringify(s.args)
      }))
    }), new Ar({ ...n });
  } else {
    if (e === "system") return new sn({ ...r });
    if (e === "function") return new ua({ ...r });
    if (In.isInstance(r)) return new ca({ ...r });
    throw new Error("Unknown message type.");
  }
}
function $m(r) {
  var s, a;
  const e = r.reduce((i, o) => {
    const c = i.findIndex(([u]) => "id" in o && o.id && "index" in o && o.index !== void 0 ? o.id === u.id && o.index === u.index : "id" in o && o.id ? o.id === u.id : "index" in o && o.index !== void 0 ? o.index === u.index : !1);
    return c !== -1 ? i[c].push(o) : i.push([o]), i;
  }, []), t = [], n = [];
  for (const i of e) {
    let o = null;
    const c = ((s = i[0]) == null ? void 0 : s.name) ?? "", u = i.map((h) => h.args || "").join("").trim(), l = u.length ? u : "{}", d = (a = i[0]) == null ? void 0 : a.id;
    try {
      if (o = oo(l), !d || o === null || typeof o != "object" || Array.isArray(o)) throw new Error("Malformed tool call chunk args.");
      t.push({
        name: c,
        args: o,
        id: d,
        type: "tool_call"
      });
    } catch {
      n.push({
        name: c,
        args: l,
        id: d,
        error: "Malformed args.",
        type: "invalid_tool_call"
      });
    }
  }
  return {
    tool_call_chunks: r,
    tool_calls: t,
    invalid_tool_calls: n
  };
}
const Cm = Symbol.for("ls:tracing_async_local_storage"), Us = Symbol.for("lc:context_variables"), Mv = (r) => {
  globalThis[Cm] = r;
}, Gs = () => globalThis[Cm];
var Dv = {};
Ae(Dv, {
  getEnv: () => ol,
  getEnvironmentVariable: () => Er,
  getRuntimeEnvironment: () => Mm,
  isBrowser: () => Rm,
  isDeno: () => uo,
  isJsDom: () => Pm,
  isNode: () => Lm,
  isWebWorker: () => Nm
});
const Rm = () => typeof window < "u" && typeof window.document < "u", Nm = () => typeof globalThis == "object" && globalThis.constructor && globalThis.constructor.name === "DedicatedWorkerGlobalScope", Pm = () => typeof window < "u" && window.name === "nodejs" || typeof navigator < "u" && navigator.userAgent.includes("jsdom"), uo = () => typeof Deno < "u", Lm = () => typeof process < "u" && typeof process.versions < "u" && typeof process.versions.node < "u" && !uo(), ol = () => {
  let r;
  return Rm() ? r = "browser" : Lm() ? r = "node" : Nm() ? r = "webworker" : Pm() ? r = "jsdom" : uo() ? r = "deno" : r = "other", r;
};
let Go;
function Mm() {
  return Go === void 0 && (Go = {
    library: "langchain-js",
    runtime: ol()
  }), Go;
}
function Er(r) {
  var e;
  try {
    return typeof process < "u" ? (e = process.env) == null ? void 0 : e[r] : uo() ? Deno == null ? void 0 : Deno.env.get(r) : void 0;
  } catch {
    return;
  }
}
const jv = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i;
function oi(r) {
  return typeof r == "string" && jv.test(r);
}
const gt = [];
for (let r = 0; r < 256; ++r)
  gt.push((r + 256).toString(16).slice(1));
function Fv(r, e = 0) {
  return (gt[r[e + 0]] + gt[r[e + 1]] + gt[r[e + 2]] + gt[r[e + 3]] + "-" + gt[r[e + 4]] + gt[r[e + 5]] + "-" + gt[r[e + 6]] + gt[r[e + 7]] + "-" + gt[r[e + 8]] + gt[r[e + 9]] + "-" + gt[r[e + 10]] + gt[r[e + 11]] + gt[r[e + 12]] + gt[r[e + 13]] + gt[r[e + 14]] + gt[r[e + 15]]).toLowerCase();
}
const ci = new Uint8Array(256);
let $a = ci.length;
function Uv() {
  return $a > ci.length - 16 && (nn.randomFillSync(ci), $a = 0), ci.slice($a, $a += 16);
}
const Nd = {
  randomUUID: nn.randomUUID
};
function Lr(r, e, t) {
  if (Nd.randomUUID && !r)
    return Nd.randomUUID();
  r = r || {};
  const n = r.random || (r.rng || Uv)();
  return n[6] = n[6] & 15 | 64, n[8] = n[8] & 63 | 128, Fv(n);
}
var zv = {};
Ae(zv, {
  BaseCallbackHandler: () => da,
  callbackHandlerPrefersStreaming: () => cl,
  isBaseCallbackHandler: () => Dm
});
var Bv = class {
};
function cl(r) {
  return "lc_prefer_streaming" in r && r.lc_prefer_streaming;
}
var da = class extends Bv {
  constructor(e) {
    super();
    b(this, "lc_serializable", !1);
    b(this, "lc_kwargs");
    b(this, "ignoreLLM", !1);
    b(this, "ignoreChain", !1);
    b(this, "ignoreAgent", !1);
    b(this, "ignoreRetriever", !1);
    b(this, "ignoreCustomEvent", !1);
    b(this, "raiseError", !1);
    b(this, "awaitHandlers", Er("LANGCHAIN_CALLBACKS_BACKGROUND") === "false");
    this.lc_kwargs = e || {}, e && (this.ignoreLLM = e.ignoreLLM ?? this.ignoreLLM, this.ignoreChain = e.ignoreChain ?? this.ignoreChain, this.ignoreAgent = e.ignoreAgent ?? this.ignoreAgent, this.ignoreRetriever = e.ignoreRetriever ?? this.ignoreRetriever, this.ignoreCustomEvent = e.ignoreCustomEvent ?? this.ignoreCustomEvent, this.raiseError = e.raiseError ?? this.raiseError, this.awaitHandlers = this.raiseError || (e._awaitHandler ?? this.awaitHandlers));
  }
  get lc_namespace() {
    return [
      "langchain_core",
      "callbacks",
      this.name
    ];
  }
  get lc_secrets() {
  }
  get lc_attributes() {
  }
  get lc_aliases() {
  }
  get lc_serializable_keys() {
  }
  /**
  * The name of the serializable. Override to provide an alias or
  * to preserve the serialized module name in minified environments.
  *
  * Implemented as a static method to support loading logic.
  */
  static lc_name() {
    return this.name;
  }
  /**
  * The final serialized identifier for the module.
  */
  get lc_id() {
    return [...this.lc_namespace, Xu(this.constructor)];
  }
  copy() {
    return new this.constructor(this);
  }
  toJSON() {
    return Yn.prototype.toJSON.call(this);
  }
  toJSONNotImplemented() {
    return Yn.prototype.toJSONNotImplemented.call(this);
  }
  static fromMethods(e) {
    class t extends da {
      constructor() {
        super();
        b(this, "name", Lr());
        Object.assign(this, e);
      }
    }
    return new t();
  }
};
const Dm = (r) => {
  const e = r;
  return e !== void 0 && typeof e.copy == "function" && typeof e.name == "string" && typeof e.awaitHandlers == "boolean";
}, Zv = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i;
function Vv(r) {
  return typeof r == "string" && Zv.test(r);
}
function qv(r) {
  if (!Vv(r))
    throw TypeError("Invalid UUID");
  let e;
  const t = new Uint8Array(16);
  return t[0] = (e = parseInt(r.slice(0, 8), 16)) >>> 24, t[1] = e >>> 16 & 255, t[2] = e >>> 8 & 255, t[3] = e & 255, t[4] = (e = parseInt(r.slice(9, 13), 16)) >>> 8, t[5] = e & 255, t[6] = (e = parseInt(r.slice(14, 18), 16)) >>> 8, t[7] = e & 255, t[8] = (e = parseInt(r.slice(19, 23), 16)) >>> 8, t[9] = e & 255, t[10] = (e = parseInt(r.slice(24, 36), 16)) / 1099511627776 & 255, t[11] = e / 4294967296 & 255, t[12] = e >>> 24 & 255, t[13] = e >>> 16 & 255, t[14] = e >>> 8 & 255, t[15] = e & 255, t;
}
const _t = [];
for (let r = 0; r < 256; ++r)
  _t.push((r + 256).toString(16).slice(1));
function ul(r, e = 0) {
  return (_t[r[e + 0]] + _t[r[e + 1]] + _t[r[e + 2]] + _t[r[e + 3]] + "-" + _t[r[e + 4]] + _t[r[e + 5]] + "-" + _t[r[e + 6]] + _t[r[e + 7]] + "-" + _t[r[e + 8]] + _t[r[e + 9]] + "-" + _t[r[e + 10]] + _t[r[e + 11]] + _t[r[e + 12]] + _t[r[e + 13]] + _t[r[e + 14]] + _t[r[e + 15]]).toLowerCase();
}
const ui = new Uint8Array(256);
let Ca = ui.length;
function jm() {
  return Ca > ui.length - 16 && (nn.randomFillSync(ui), Ca = 0), ui.slice(Ca, Ca += 16);
}
function Jv(r) {
  r = unescape(encodeURIComponent(r));
  const e = [];
  for (let t = 0; t < r.length; ++t)
    e.push(r.charCodeAt(t));
  return e;
}
const Hv = "6ba7b810-9dad-11d1-80b4-00c04fd430c8", Gv = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
function Wv(r, e, t) {
  function n(s, a, i, o) {
    var c;
    if (typeof s == "string" && (s = Jv(s)), typeof a == "string" && (a = qv(a)), ((c = a) === null || c === void 0 ? void 0 : c.length) !== 16)
      throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
    let u = new Uint8Array(16 + s.length);
    if (u.set(a), u.set(s, a.length), u = t(u), u[6] = u[6] & 15 | e, u[8] = u[8] & 63 | 128, i) {
      o = o || 0;
      for (let l = 0; l < 16; ++l)
        i[o + l] = u[l];
      return i;
    }
    return ul(u);
  }
  try {
    n.name = r;
  } catch {
  }
  return n.DNS = Hv, n.URL = Gv, n;
}
const Pd = {
  randomUUID: nn.randomUUID
};
function ms(r, e, t) {
  if (Pd.randomUUID && !r)
    return Pd.randomUUID();
  r = r || {};
  const n = r.random || (r.rng || jm)();
  return n[6] = n[6] & 15 | 64, n[8] = n[8] & 63 | 128, ul(n);
}
function Kv(r) {
  return Array.isArray(r) ? r = Buffer.from(r) : typeof r == "string" && (r = Buffer.from(r, "utf8")), nn.createHash("sha1").update(r).digest();
}
const ks = Wv("v5", 80, Kv);
let Ld = null, Md = null, Xt = 0;
function Yv(r, e, t) {
  r = r || {};
  let n = 0;
  const s = new Uint8Array(16), a = r.random || (r.rng || jm)(), i = r.msecs !== void 0 ? r.msecs : Date.now();
  let o = r.seq !== void 0 ? r.seq : null, c = Md, u = Ld;
  return i > Xt && r.msecs === void 0 && (Xt = i, o !== null && (c = null, u = null)), o !== null && (o > 2147483647 && (o = 2147483647), c = o >>> 19 & 4095, u = o & 524287), (c === null || u === null) && (c = a[6] & 127, c = c << 8 | a[7], u = a[8] & 63, u = u << 8 | a[9], u = u << 5 | a[10] >>> 3), i + 1e4 > Xt && o === null ? ++u > 524287 && (u = 0, ++c > 4095 && (c = 0, Xt++)) : Xt = i, Md = c, Ld = u, s[n++] = Xt / 1099511627776 & 255, s[n++] = Xt / 4294967296 & 255, s[n++] = Xt / 16777216 & 255, s[n++] = Xt / 65536 & 255, s[n++] = Xt / 256 & 255, s[n++] = Xt & 255, s[n++] = c >>> 4 & 15 | 112, s[n++] = c & 255, s[n++] = u >>> 13 & 63 | 128, s[n++] = u >>> 5 & 255, s[n++] = u << 3 & 255 | a[10] & 7, s[n++] = a[11], s[n++] = a[12], s[n++] = a[13], s[n++] = a[14], s[n++] = a[15], e || ul(s);
}
const Xv = "gen_ai.operation.name", Qv = "gen_ai.system", Dd = "gen_ai.request.model", eb = "gen_ai.response.model", jd = "gen_ai.usage.input_tokens", Fd = "gen_ai.usage.output_tokens", Ud = "gen_ai.usage.total_tokens", tb = "gen_ai.request.max_tokens", rb = "gen_ai.request.temperature", nb = "gen_ai.request.top_p", sb = "gen_ai.request.frequency_penalty", ab = "gen_ai.request.presence_penalty", ib = "gen_ai.response.finish_reasons", ob = "gen_ai.prompt", cb = "gen_ai.completion", ub = "gen_ai.request.extra_query", lb = "gen_ai.request.extra_body", db = "gen_ai.serialized.name", hb = "gen_ai.serialized.signature", fb = "gen_ai.serialized.doc", pb = "gen_ai.response.id", mb = "gen_ai.response.service_tier", gb = "gen_ai.response.system_fingerprint", _b = "gen_ai.usage.input_token_details", yb = "gen_ai.usage.output_token_details", wb = "langsmith.trace.session_id", vb = "langsmith.trace.session_name", bb = "langsmith.span.kind", Sb = "langsmith.trace.name", Tb = "langsmith.metadata", zd = "langsmith.span.tags", Eb = "langsmith.request.streaming", xb = "langsmith.request.headers", kb = (...r) => fetch(...r), Fm = Symbol.for("ls:fetch_implementation"), Ib = () => {
  const r = globalThis[Fm];
  return r ? typeof r == "function" && "Headers" in r && "Request" in r && "Response" in r : !1;
}, Ob = (r) => async (...e) => {
  if (r || Nt("DEBUG") === "true") {
    const [n, s] = e;
    console.log(`â†’ ${(s == null ? void 0 : s.method) || "GET"} ${n}`);
  }
  const t = await (globalThis[Fm] ?? kb)(...e);
  return (r || Nt("DEBUG") === "true") && console.log(`â† ${t.status} ${t.statusText} ${t.url}`), t;
}, Um = () => Nt("PROJECT") ?? Or("LANGCHAIN_SESSION") ?? // TODO: Deprecate
"default", Bd = {};
function Dc(r) {
  Bd[r] || (console.warn(r), Bd[r] = !0);
}
const Ab = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
function ve(r, e) {
  if (!Ab.test(r)) {
    const t = e !== void 0 ? `Invalid UUID for ${e}: ${r}` : `Invalid UUID: ${r}`;
    throw new Error(t);
  }
  return r;
}
function $b(r) {
  const e = typeof r == "string" ? Date.parse(r) : r;
  return Yv({ msecs: e, seq: 0 });
}
const zm = "0.3.84";
let mr;
const Cb = () => typeof window < "u" && typeof window.document < "u", Rb = () => typeof globalThis == "object" && globalThis.constructor && globalThis.constructor.name === "DedicatedWorkerGlobalScope", Nb = () => typeof window < "u" && window.name === "nodejs" || typeof navigator < "u" && navigator.userAgent.includes("jsdom"), Bm = () => typeof Deno < "u", Pb = () => typeof process < "u" && typeof process.versions < "u" && typeof process.versions.node < "u" && !Bm(), Zm = () => mr || (typeof Bun < "u" ? mr = "bun" : Cb() ? mr = "browser" : Pb() ? mr = "node" : Rb() ? mr = "webworker" : Nb() ? mr = "jsdom" : Bm() ? mr = "deno" : mr = "other", mr);
let Wo;
function Vm() {
  if (Wo === void 0) {
    const r = Zm(), e = Mb();
    Wo = {
      library: "langsmith",
      runtime: r,
      sdk: "langsmith-js",
      sdk_version: zm,
      ...e
    };
  }
  return Wo;
}
function qm() {
  const r = Lb(), e = {}, t = [
    "LANGCHAIN_API_KEY",
    "LANGCHAIN_ENDPOINT",
    "LANGCHAIN_TRACING_V2",
    "LANGCHAIN_PROJECT",
    "LANGCHAIN_SESSION",
    "LANGSMITH_API_KEY",
    "LANGSMITH_ENDPOINT",
    "LANGSMITH_TRACING_V2",
    "LANGSMITH_PROJECT",
    "LANGSMITH_SESSION"
  ];
  for (const [n, s] of Object.entries(r))
    typeof s == "string" && !t.includes(n) && !n.toLowerCase().includes("key") && !n.toLowerCase().includes("secret") && !n.toLowerCase().includes("token") && (n === "LANGCHAIN_REVISION_ID" ? e.revision_id = s : e[n] = s);
  return e;
}
function Lb() {
  const r = {};
  try {
    if (typeof process < "u" && process.env)
      for (const [e, t] of Object.entries(process.env))
        (e.startsWith("LANGCHAIN_") || e.startsWith("LANGSMITH_")) && t != null && ((e.toLowerCase().includes("key") || e.toLowerCase().includes("secret") || e.toLowerCase().includes("token")) && typeof t == "string" ? r[e] = t.slice(0, 2) + "*".repeat(t.length - 4) + t.slice(-2) : r[e] = t);
  } catch {
  }
  return r;
}
function Or(r) {
  var e;
  try {
    return typeof process < "u" ? (
      // eslint-disable-next-line no-process-env
      (e = process.env) == null ? void 0 : e[r]
    ) : void 0;
  } catch {
    return;
  }
}
function Nt(r) {
  return Or(`LANGSMITH_${r}`) || Or(`LANGCHAIN_${r}`);
}
let Ko;
function Mb() {
  if (Ko !== void 0)
    return Ko;
  const r = [
    "VERCEL_GIT_COMMIT_SHA",
    "NEXT_PUBLIC_VERCEL_GIT_COMMIT_SHA",
    "COMMIT_REF",
    "RENDER_GIT_COMMIT",
    "CI_COMMIT_SHA",
    "CIRCLE_SHA1",
    "CF_PAGES_COMMIT_SHA",
    "REACT_APP_GIT_SHA",
    "SOURCE_VERSION",
    "GITHUB_SHA",
    "TRAVIS_COMMIT",
    "GIT_COMMIT",
    "BUILD_VCS_NUMBER",
    "bamboo_planRepository_revision",
    "Build.SourceVersion",
    "BITBUCKET_COMMIT",
    "DRONE_COMMIT_SHA",
    "SEMAPHORE_GIT_SHA",
    "BUILDKITE_COMMIT"
  ], e = {};
  for (const t of r) {
    const n = Or(t);
    n !== void 0 && (e[t] = n);
  }
  return Ko = e, e;
}
function Jm() {
  return Or("OTEL_ENABLED") === "true" || Nt("OTEL_ENABLED") === "true";
}
class Db {
  constructor() {
    Object.defineProperty(this, "hasWarned", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    });
  }
  startActiveSpan(e, ...t) {
    !this.hasWarned && Jm() && (console.warn('You have enabled OTEL export via the `OTEL_ENABLED` or `LANGSMITH_OTEL_ENABLED` environment variable, but have not initialized the required OTEL instances. Please add:\n```\nimport { initializeOTEL } from "langsmith/experimental/otel/setup";\ninitializeOTEL();\n```\nat the beginning of your code.'), this.hasWarned = !0);
    let n;
    if (t.length === 1 && typeof t[0] == "function" ? n = t[0] : t.length === 2 && typeof t[1] == "function" ? n = t[1] : t.length === 3 && typeof t[2] == "function" && (n = t[2]), typeof n == "function")
      return n();
  }
}
class jb {
  constructor() {
    Object.defineProperty(this, "mockTracer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new Db()
    });
  }
  getTracer(e, t) {
    return this.mockTracer;
  }
  getActiveSpan() {
  }
  setSpan(e, t) {
    return e;
  }
  getSpan(e) {
  }
  setSpanContext(e, t) {
    return e;
  }
  getTracerProvider() {
  }
  setGlobalTracerProvider(e) {
    return !1;
  }
}
class Fb {
  active() {
    return {};
  }
  with(e, t) {
    return t();
  }
}
const Yo = Symbol.for("ls:otel_trace"), Xo = Symbol.for("ls:otel_context"), Zd = Symbol.for("ls:otel_get_default_otlp_tracer_provider"), Ub = new jb(), zb = new Fb();
class Bb {
  getTraceInstance() {
    return globalThis[Yo] ?? Ub;
  }
  getContextInstance() {
    return globalThis[Xo] ?? zb;
  }
  initializeGlobalInstances(e) {
    globalThis[Yo] === void 0 && (globalThis[Yo] = e.trace), globalThis[Xo] === void 0 && (globalThis[Xo] = e.context);
  }
  setDefaultOTLPTracerComponents(e) {
    globalThis[Zd] = e;
  }
  getDefaultOTLPTracerComponents() {
    return globalThis[Zd] ?? void 0;
  }
}
const ll = new Bb();
function Hm() {
  return ll.getTraceInstance();
}
function Zb() {
  return ll.getContextInstance();
}
function Vb() {
  return ll.getDefaultOTLPTracerComponents();
}
const qb = {
  llm: "chat",
  tool: "execute_tool",
  retriever: "embeddings",
  embedding: "embeddings",
  prompt: "chat"
};
function Jb(r) {
  return qb[r] || r;
}
class Hb {
  constructor() {
    Object.defineProperty(this, "spans", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: /* @__PURE__ */ new Map()
    });
  }
  exportBatch(e, t) {
    for (const n of e)
      try {
        if (!n.run)
          continue;
        if (n.operation === "post") {
          const s = this.createSpanForRun(n, n.run, t.get(n.id));
          s && !n.run.end_time && this.spans.set(n.id, s);
        } else
          this.updateSpanForRun(n, n.run);
      } catch (s) {
        console.error(`Error processing operation ${n.id}:`, s);
      }
  }
  createSpanForRun(e, t, n) {
    const s = n && Hm().getSpan(n);
    if (s)
      try {
        return this.finishSpanSetup(s, t, e);
      } catch (a) {
        console.error(`Failed to create span for run ${e.id}:`, a);
        return;
      }
  }
  finishSpanSetup(e, t, n) {
    return this.setSpanAttributes(e, t, n), t.error ? (e.setStatus({ code: 2 }), e.recordException(new Error(t.error))) : e.setStatus({ code: 1 }), t.end_time && e.end(new Date(t.end_time)), e;
  }
  updateSpanForRun(e, t) {
    try {
      const n = this.spans.get(e.id);
      if (!n) {
        console.debug(`No span found for run ${e.id} during update`);
        return;
      }
      this.setSpanAttributes(n, t, e), t.error ? (n.setStatus({ code: 2 }), n.recordException(new Error(t.error))) : n.setStatus({ code: 1 });
      const s = t.end_time;
      s && (n.end(new Date(s)), this.spans.delete(e.id));
    } catch (n) {
      console.error(`Failed to update span for run ${e.id}:`, n);
    }
  }
  extractModelName(e) {
    var t;
    if ((t = e.extra) != null && t.metadata) {
      const n = e.extra.metadata;
      if (n.ls_model_name)
        return n.ls_model_name;
      if (n.invocation_params) {
        const s = n.invocation_params;
        if (s.model)
          return s.model;
        if (s.model_name)
          return s.model_name;
      }
    }
  }
  setSpanAttributes(e, t, n) {
    var o;
    if ("run_type" in t && t.run_type) {
      e.setAttribute(bb, t.run_type);
      const c = Jb(t.run_type || "chain");
      e.setAttribute(Xv, c);
    }
    "name" in t && t.name && e.setAttribute(Sb, t.name), "session_id" in t && t.session_id && e.setAttribute(wb, t.session_id), "session_name" in t && t.session_name && e.setAttribute(vb, t.session_name), this.setGenAiSystem(e, t);
    const s = this.extractModelName(t);
    s && e.setAttribute(Dd, s), "prompt_tokens" in t && typeof t.prompt_tokens == "number" && e.setAttribute(jd, t.prompt_tokens), "completion_tokens" in t && typeof t.completion_tokens == "number" && e.setAttribute(Fd, t.completion_tokens), "total_tokens" in t && typeof t.total_tokens == "number" && e.setAttribute(Ud, t.total_tokens), this.setInvocationParameters(e, t);
    const a = ((o = t.extra) == null ? void 0 : o.metadata) || {};
    for (const [c, u] of Object.entries(a))
      u != null && e.setAttribute(`${Tb}.${c}`, String(u));
    const i = t.tags;
    if (i && Array.isArray(i) ? e.setAttribute(zd, i.join(", ")) : i && e.setAttribute(zd, String(i)), "serialized" in t && typeof t.serialized == "object") {
      const c = t.serialized;
      c.name && e.setAttribute(db, String(c.name)), c.signature && e.setAttribute(hb, String(c.signature)), c.doc && e.setAttribute(fb, String(c.doc));
    }
    this.setIOAttributes(e, n);
  }
  setGenAiSystem(e, t) {
    let n = "langchain";
    const s = this.extractModelName(t);
    if (s) {
      const a = s.toLowerCase();
      a.includes("anthropic") || a.startsWith("claude") ? n = "anthropic" : a.includes("bedrock") ? n = "aws.bedrock" : a.includes("azure") && a.includes("openai") ? n = "az.ai.openai" : a.includes("azure") && a.includes("inference") ? n = "az.ai.inference" : a.includes("cohere") ? n = "cohere" : a.includes("deepseek") ? n = "deepseek" : a.includes("gemini") ? n = "gemini" : a.includes("groq") ? n = "groq" : a.includes("watson") || a.includes("ibm") ? n = "ibm.watsonx.ai" : a.includes("mistral") ? n = "mistral_ai" : a.includes("gpt") || a.includes("openai") ? n = "openai" : a.includes("perplexity") || a.includes("sonar") ? n = "perplexity" : a.includes("vertex") ? n = "vertex_ai" : (a.includes("xai") || a.includes("grok")) && (n = "xai");
    }
    e.setAttribute(Qv, n);
  }
  setInvocationParameters(e, t) {
    var s, a;
    if (!((a = (s = t.extra) == null ? void 0 : s.metadata) != null && a.invocation_params))
      return;
    const n = t.extra.metadata.invocation_params;
    n.max_tokens !== void 0 && e.setAttribute(tb, n.max_tokens), n.temperature !== void 0 && e.setAttribute(rb, n.temperature), n.top_p !== void 0 && e.setAttribute(nb, n.top_p), n.frequency_penalty !== void 0 && e.setAttribute(sb, n.frequency_penalty), n.presence_penalty !== void 0 && e.setAttribute(ab, n.presence_penalty);
  }
  setIOAttributes(e, t) {
    if (t.run.inputs)
      try {
        const n = t.run.inputs;
        typeof n == "object" && n !== null && (n.model && Array.isArray(n.messages) && e.setAttribute(Dd, n.model), n.stream !== void 0 && e.setAttribute(Eb, n.stream), n.extra_headers && e.setAttribute(xb, JSON.stringify(n.extra_headers)), n.extra_query && e.setAttribute(ub, JSON.stringify(n.extra_query)), n.extra_body && e.setAttribute(lb, JSON.stringify(n.extra_body))), e.setAttribute(ob, JSON.stringify(n));
      } catch (n) {
        console.debug(`Failed to process inputs for run ${t.id}`, n);
      }
    if (t.run.outputs)
      try {
        const n = t.run.outputs, s = this.getUnifiedRunTokens(n);
        if (s && (e.setAttribute(jd, s[0]), e.setAttribute(Fd, s[1]), e.setAttribute(Ud, s[0] + s[1])), n && typeof n == "object") {
          if (n.model && e.setAttribute(eb, String(n.model)), n.id && e.setAttribute(pb, n.id), n.choices && Array.isArray(n.choices)) {
            const a = n.choices.map((i) => i.finish_reason).filter((i) => i).map(String);
            a.length > 0 && e.setAttribute(ib, a.join(", "));
          }
          if (n.service_tier && e.setAttribute(mb, n.service_tier), n.system_fingerprint && e.setAttribute(gb, n.system_fingerprint), n.usage_metadata && typeof n.usage_metadata == "object") {
            const a = n.usage_metadata;
            a.input_token_details && e.setAttribute(_b, JSON.stringify(a.input_token_details)), a.output_token_details && e.setAttribute(yb, JSON.stringify(a.output_token_details));
          }
        }
        e.setAttribute(cb, JSON.stringify(n));
      } catch (n) {
        console.debug(`Failed to process outputs for run ${t.id}`, n);
      }
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  getUnifiedRunTokens(e) {
    if (!e)
      return null;
    let t = this.extractUnifiedRunTokens(e.usage_metadata);
    if (t)
      return t;
    const n = Object.keys(e);
    for (const i of n) {
      const o = e[i];
      if (!(!o || typeof o != "object") && (t = this.extractUnifiedRunTokens(o.usage_metadata), t || o.lc === 1 && o.kwargs && typeof o.kwargs == "object" && (t = this.extractUnifiedRunTokens(o.kwargs.usage_metadata), t)))
        return t;
    }
    const s = e.generations || [];
    if (!Array.isArray(s))
      return null;
    const a = Array.isArray(s[0]) ? s.flat() : s;
    for (const i of a)
      if (typeof i == "object" && i.message && typeof i.message == "object" && i.message.kwargs && typeof i.message.kwargs == "object" && (t = this.extractUnifiedRunTokens(i.message.kwargs.usage_metadata), t))
        return t;
    return null;
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  extractUnifiedRunTokens(e) {
    return !e || typeof e != "object" || typeof e.input_tokens != "number" || typeof e.output_tokens != "number" ? null : [e.input_tokens, e.output_tokens];
  }
}
const Gb = Object.prototype.toString, Wb = (r) => Gb.call(r) === "[object Error]", Kb = /* @__PURE__ */ new Set([
  "network error",
  // Chrome
  "Failed to fetch",
  // Chrome
  "NetworkError when attempting to fetch resource.",
  // Firefox
  "The Internet connection appears to be offline.",
  // Safari 16
  "Network request failed",
  // `cross-fetch`
  "fetch failed",
  // Undici (Node.js)
  "terminated",
  // Undici (Node.js)
  " A network error occurred.",
  // Bun (WebKit)
  "Network connection lost"
  // Cloudflare Workers (fetch)
]);
function Yb(r) {
  if (!(r && Wb(r) && r.name === "TypeError" && typeof r.message == "string"))
    return !1;
  const { message: t, stack: n } = r;
  return t === "Load failed" ? n === void 0 || // Sentry adds its own stack trace to the fetch error, so also check for that
  "__sentry_captured__" in r : t.startsWith("error sending request for url") ? !0 : Kb.has(t);
}
function Xb(r) {
  if (typeof r == "number") {
    if (r < 0)
      throw new TypeError("Expected `retries` to be a non-negative number.");
    if (Number.isNaN(r))
      throw new TypeError("Expected `retries` to be a valid number or Infinity, got NaN.");
  } else if (r !== void 0)
    throw new TypeError("Expected `retries` to be a number or Infinity.");
}
function Ra(r, e, { min: t = 0, allowInfinity: n = !1 } = {}) {
  if (e !== void 0) {
    if (typeof e != "number" || Number.isNaN(e))
      throw new TypeError(`Expected \`${r}\` to be a number${n ? " or Infinity" : ""}.`);
    if (!n && !Number.isFinite(e))
      throw new TypeError(`Expected \`${r}\` to be a finite number.`);
    if (e < t)
      throw new TypeError(`Expected \`${r}\` to be â‰¥ ${t}.`);
  }
}
let Qb = class extends Error {
  constructor(e) {
    super(), e instanceof Error ? (this.originalError = e, { message: e } = e) : (this.originalError = new Error(e), this.originalError.stack = this.stack), this.name = "AbortError", this.message = e;
  }
};
function e0(r, e) {
  const t = Math.max(1, r + 1), n = e.randomize ? Math.random() + 1 : 1;
  let s = Math.round(n * e.minTimeout * e.factor ** (t - 1));
  return s = Math.min(s, e.maxTimeout), s;
}
function Vd(r, e) {
  return Number.isFinite(e) ? e - (performance.now() - r) : e;
}
async function t0({ error: r, attemptNumber: e, retriesConsumed: t, startTime: n, options: s }) {
  var f, p, y;
  const a = r instanceof Error ? r : new TypeError(`Non-error was thrown: "${r}". You should only throw errors.`);
  if (a instanceof Qb)
    throw a.originalError;
  const i = Number.isFinite(s.retries) ? Math.max(0, s.retries - t) : s.retries, o = s.maxRetryTime ?? Number.POSITIVE_INFINITY, c = Object.freeze({
    error: a,
    attemptNumber: e,
    retriesLeft: i,
    retriesConsumed: t
  });
  if (await s.onFailedAttempt(c), Vd(n, o) <= 0)
    throw a;
  const u = await s.shouldConsumeRetry(c), l = Vd(n, o);
  if (l <= 0 || i <= 0)
    throw a;
  if (a instanceof TypeError && !Yb(a)) {
    if (u)
      throw a;
    return (f = s.signal) == null || f.throwIfAborted(), !1;
  }
  if (!await s.shouldRetry(c))
    throw a;
  if (!u)
    return (p = s.signal) == null || p.throwIfAborted(), !1;
  const d = e0(t, s), h = Math.min(d, l);
  return h > 0 && await new Promise((m, v) => {
    var T, x;
    const g = () => {
      var O;
      clearTimeout(w), (O = s.signal) == null || O.removeEventListener("abort", g), v(s.signal.reason);
    }, w = setTimeout(() => {
      var O;
      (O = s.signal) == null || O.removeEventListener("abort", g), m();
    }, h);
    s.unref && ((T = w.unref) == null || T.call(w)), (x = s.signal) == null || x.addEventListener("abort", g, { once: !0 });
  }), (y = s.signal) == null || y.throwIfAborted(), !0;
}
async function r0(r, e = {}) {
  var a, i, o;
  if (e = { ...e }, Xb(e.retries), Object.hasOwn(e, "forever"))
    throw new Error("The `forever` option is no longer supported. For many use-cases, you can set `retries: Infinity` instead.");
  e.retries ?? (e.retries = 10), e.factor ?? (e.factor = 2), e.minTimeout ?? (e.minTimeout = 1e3), e.maxTimeout ?? (e.maxTimeout = Number.POSITIVE_INFINITY), e.maxRetryTime ?? (e.maxRetryTime = Number.POSITIVE_INFINITY), e.randomize ?? (e.randomize = !1), e.onFailedAttempt ?? (e.onFailedAttempt = () => {
  }), e.shouldRetry ?? (e.shouldRetry = () => !0), e.shouldConsumeRetry ?? (e.shouldConsumeRetry = () => !0), Ra("factor", e.factor, {
    min: 0,
    allowInfinity: !1
  }), Ra("minTimeout", e.minTimeout, {
    min: 0,
    allowInfinity: !1
  }), Ra("maxTimeout", e.maxTimeout, {
    min: 0,
    allowInfinity: !0
  }), Ra("maxRetryTime", e.maxRetryTime, {
    min: 0,
    allowInfinity: !0
  }), e.factor > 0 || (e.factor = 1), (a = e.signal) == null || a.throwIfAborted();
  let t = 0, n = 0;
  const s = performance.now();
  for (; !Number.isFinite(e.retries) || n <= e.retries; ) {
    t++;
    try {
      (i = e.signal) == null || i.throwIfAborted();
      const c = await r(t);
      return (o = e.signal) == null || o.throwIfAborted(), c;
    } catch (c) {
      await t0({
        error: c,
        attemptNumber: t,
        retriesConsumed: n,
        startTime: s,
        options: e
      }) && n++;
    }
  }
  throw new Error("Retry attempts exhausted without throwing an error.");
}
var Gm = {}, Wm = { exports: {} };
(function(r) {
  var e = Object.prototype.hasOwnProperty, t = "~";
  function n() {
  }
  Object.create && (n.prototype = /* @__PURE__ */ Object.create(null), new n().__proto__ || (t = !1));
  function s(c, u, l) {
    this.fn = c, this.context = u, this.once = l || !1;
  }
  function a(c, u, l, d, h) {
    if (typeof l != "function")
      throw new TypeError("The listener must be a function");
    var f = new s(l, d || c, h), p = t ? t + u : u;
    return c._events[p] ? c._events[p].fn ? c._events[p] = [c._events[p], f] : c._events[p].push(f) : (c._events[p] = f, c._eventsCount++), c;
  }
  function i(c, u) {
    --c._eventsCount === 0 ? c._events = new n() : delete c._events[u];
  }
  function o() {
    this._events = new n(), this._eventsCount = 0;
  }
  o.prototype.eventNames = function() {
    var u = [], l, d;
    if (this._eventsCount === 0) return u;
    for (d in l = this._events)
      e.call(l, d) && u.push(t ? d.slice(1) : d);
    return Object.getOwnPropertySymbols ? u.concat(Object.getOwnPropertySymbols(l)) : u;
  }, o.prototype.listeners = function(u) {
    var l = t ? t + u : u, d = this._events[l];
    if (!d) return [];
    if (d.fn) return [d.fn];
    for (var h = 0, f = d.length, p = new Array(f); h < f; h++)
      p[h] = d[h].fn;
    return p;
  }, o.prototype.listenerCount = function(u) {
    var l = t ? t + u : u, d = this._events[l];
    return d ? d.fn ? 1 : d.length : 0;
  }, o.prototype.emit = function(u, l, d, h, f, p) {
    var y = t ? t + u : u;
    if (!this._events[y]) return !1;
    var m = this._events[y], v = arguments.length, g, w;
    if (m.fn) {
      switch (m.once && this.removeListener(u, m.fn, void 0, !0), v) {
        case 1:
          return m.fn.call(m.context), !0;
        case 2:
          return m.fn.call(m.context, l), !0;
        case 3:
          return m.fn.call(m.context, l, d), !0;
        case 4:
          return m.fn.call(m.context, l, d, h), !0;
        case 5:
          return m.fn.call(m.context, l, d, h, f), !0;
        case 6:
          return m.fn.call(m.context, l, d, h, f, p), !0;
      }
      for (w = 1, g = new Array(v - 1); w < v; w++)
        g[w - 1] = arguments[w];
      m.fn.apply(m.context, g);
    } else {
      var T = m.length, x;
      for (w = 0; w < T; w++)
        switch (m[w].once && this.removeListener(u, m[w].fn, void 0, !0), v) {
          case 1:
            m[w].fn.call(m[w].context);
            break;
          case 2:
            m[w].fn.call(m[w].context, l);
            break;
          case 3:
            m[w].fn.call(m[w].context, l, d);
            break;
          case 4:
            m[w].fn.call(m[w].context, l, d, h);
            break;
          default:
            if (!g) for (x = 1, g = new Array(v - 1); x < v; x++)
              g[x - 1] = arguments[x];
            m[w].fn.apply(m[w].context, g);
        }
    }
    return !0;
  }, o.prototype.on = function(u, l, d) {
    return a(this, u, l, d, !1);
  }, o.prototype.once = function(u, l, d) {
    return a(this, u, l, d, !0);
  }, o.prototype.removeListener = function(u, l, d, h) {
    var f = t ? t + u : u;
    if (!this._events[f]) return this;
    if (!l)
      return i(this, f), this;
    var p = this._events[f];
    if (p.fn)
      p.fn === l && (!h || p.once) && (!d || p.context === d) && i(this, f);
    else {
      for (var y = 0, m = [], v = p.length; y < v; y++)
        (p[y].fn !== l || h && !p[y].once || d && p[y].context !== d) && m.push(p[y]);
      m.length ? this._events[f] = m.length === 1 ? m[0] : m : i(this, f);
    }
    return this;
  }, o.prototype.removeAllListeners = function(u) {
    var l;
    return u ? (l = t ? t + u : u, this._events[l] && i(this, l)) : (this._events = new n(), this._eventsCount = 0), this;
  }, o.prototype.off = o.prototype.removeListener, o.prototype.addListener = o.prototype.on, o.prefixed = t, o.EventEmitter = o, r.exports = o;
})(Wm);
var n0 = Wm.exports, lo = { exports: {} }, s0 = (r, e) => (e = e || (() => {
}), r.then(
  (t) => new Promise((n) => {
    n(e());
  }).then(() => t),
  (t) => new Promise((n) => {
    n(e());
  }).then(() => {
    throw t;
  })
));
const a0 = s0;
class Km extends Error {
  constructor(e) {
    super(e), this.name = "TimeoutError";
  }
}
const Ym = (r, e, t) => new Promise((n, s) => {
  if (typeof e != "number" || e < 0)
    throw new TypeError("Expected `milliseconds` to be a positive number");
  if (e === 1 / 0) {
    n(r);
    return;
  }
  const a = setTimeout(() => {
    if (typeof t == "function") {
      try {
        n(t());
      } catch (c) {
        s(c);
      }
      return;
    }
    const i = typeof t == "string" ? t : `Promise timed out after ${e} milliseconds`, o = t instanceof Error ? t : new Km(i);
    typeof r.cancel == "function" && r.cancel(), s(o);
  }, e);
  a0(
    // eslint-disable-next-line promise/prefer-await-to-then
    r.then(n, s),
    () => {
      clearTimeout(a);
    }
  );
});
lo.exports = Ym;
lo.exports.default = Ym;
lo.exports.TimeoutError = Km;
var i0 = lo.exports, dl = {}, hl = {};
Object.defineProperty(hl, "__esModule", { value: !0 });
function o0(r, e, t) {
  let n = 0, s = r.length;
  for (; s > 0; ) {
    const a = s / 2 | 0;
    let i = n + a;
    t(r[i], e) <= 0 ? (n = ++i, s -= a + 1) : s = a;
  }
  return n;
}
hl.default = o0;
Object.defineProperty(dl, "__esModule", { value: !0 });
const c0 = hl;
class u0 {
  constructor() {
    this._queue = [];
  }
  enqueue(e, t) {
    t = Object.assign({ priority: 0 }, t);
    const n = {
      priority: t.priority,
      run: e
    };
    if (this.size && this._queue[this.size - 1].priority >= t.priority) {
      this._queue.push(n);
      return;
    }
    const s = c0.default(this._queue, n, (a, i) => i.priority - a.priority);
    this._queue.splice(s, 0, n);
  }
  dequeue() {
    const e = this._queue.shift();
    return e == null ? void 0 : e.run;
  }
  filter(e) {
    return this._queue.filter((t) => t.priority === e.priority).map((t) => t.run);
  }
  get size() {
    return this._queue.length;
  }
}
dl.default = u0;
Object.defineProperty(Gm, "__esModule", { value: !0 });
const l0 = n0, Xm = i0, d0 = dl, Na = () => {
}, h0 = new Xm.TimeoutError();
class f0 extends l0 {
  constructor(e) {
    var t, n, s, a;
    if (super(), this._intervalCount = 0, this._intervalEnd = 0, this._pendingCount = 0, this._resolveEmpty = Na, this._resolveIdle = Na, e = Object.assign({ carryoverConcurrencyCount: !1, intervalCap: 1 / 0, interval: 0, concurrency: 1 / 0, autoStart: !0, queueClass: d0.default }, e), !(typeof e.intervalCap == "number" && e.intervalCap >= 1))
      throw new TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${(n = (t = e.intervalCap) === null || t === void 0 ? void 0 : t.toString()) !== null && n !== void 0 ? n : ""}\` (${typeof e.intervalCap})`);
    if (e.interval === void 0 || !(Number.isFinite(e.interval) && e.interval >= 0))
      throw new TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${(a = (s = e.interval) === null || s === void 0 ? void 0 : s.toString()) !== null && a !== void 0 ? a : ""}\` (${typeof e.interval})`);
    this._carryoverConcurrencyCount = e.carryoverConcurrencyCount, this._isIntervalIgnored = e.intervalCap === 1 / 0 || e.interval === 0, this._intervalCap = e.intervalCap, this._interval = e.interval, this._queue = new e.queueClass(), this._queueClass = e.queueClass, this.concurrency = e.concurrency, this._timeout = e.timeout, this._throwOnTimeout = e.throwOnTimeout === !0, this._isPaused = e.autoStart === !1;
  }
  get _doesIntervalAllowAnother() {
    return this._isIntervalIgnored || this._intervalCount < this._intervalCap;
  }
  get _doesConcurrentAllowAnother() {
    return this._pendingCount < this._concurrency;
  }
  _next() {
    this._pendingCount--, this._tryToStartAnother(), this.emit("next");
  }
  _resolvePromises() {
    this._resolveEmpty(), this._resolveEmpty = Na, this._pendingCount === 0 && (this._resolveIdle(), this._resolveIdle = Na, this.emit("idle"));
  }
  _onResumeInterval() {
    this._onInterval(), this._initializeIntervalIfNeeded(), this._timeoutId = void 0;
  }
  _isIntervalPaused() {
    const e = Date.now();
    if (this._intervalId === void 0) {
      const t = this._intervalEnd - e;
      if (t < 0)
        this._intervalCount = this._carryoverConcurrencyCount ? this._pendingCount : 0;
      else
        return this._timeoutId === void 0 && (this._timeoutId = setTimeout(() => {
          this._onResumeInterval();
        }, t)), !0;
    }
    return !1;
  }
  _tryToStartAnother() {
    if (this._queue.size === 0)
      return this._intervalId && clearInterval(this._intervalId), this._intervalId = void 0, this._resolvePromises(), !1;
    if (!this._isPaused) {
      const e = !this._isIntervalPaused();
      if (this._doesIntervalAllowAnother && this._doesConcurrentAllowAnother) {
        const t = this._queue.dequeue();
        return t ? (this.emit("active"), t(), e && this._initializeIntervalIfNeeded(), !0) : !1;
      }
    }
    return !1;
  }
  _initializeIntervalIfNeeded() {
    this._isIntervalIgnored || this._intervalId !== void 0 || (this._intervalId = setInterval(() => {
      this._onInterval();
    }, this._interval), this._intervalEnd = Date.now() + this._interval);
  }
  _onInterval() {
    this._intervalCount === 0 && this._pendingCount === 0 && this._intervalId && (clearInterval(this._intervalId), this._intervalId = void 0), this._intervalCount = this._carryoverConcurrencyCount ? this._pendingCount : 0, this._processQueue();
  }
  /**
  Executes all queued functions until it reaches the limit.
  */
  _processQueue() {
    for (; this._tryToStartAnother(); )
      ;
  }
  get concurrency() {
    return this._concurrency;
  }
  set concurrency(e) {
    if (!(typeof e == "number" && e >= 1))
      throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${e}\` (${typeof e})`);
    this._concurrency = e, this._processQueue();
  }
  /**
  Adds a sync or async task to the queue. Always returns a promise.
  */
  async add(e, t = {}) {
    return new Promise((n, s) => {
      const a = async () => {
        this._pendingCount++, this._intervalCount++;
        try {
          const i = this._timeout === void 0 && t.timeout === void 0 ? e() : Xm.default(Promise.resolve(e()), t.timeout === void 0 ? this._timeout : t.timeout, () => {
            (t.throwOnTimeout === void 0 ? this._throwOnTimeout : t.throwOnTimeout) && s(h0);
          });
          n(await i);
        } catch (i) {
          s(i);
        }
        this._next();
      };
      this._queue.enqueue(a, t), this._tryToStartAnother(), this.emit("add");
    });
  }
  /**
      Same as `.add()`, but accepts an array of sync or async functions.
  
      @returns A promise that resolves when all functions are resolved.
      */
  async addAll(e, t) {
    return Promise.all(e.map(async (n) => this.add(n, t)));
  }
  /**
  Start (or resume) executing enqueued tasks within concurrency limit. No need to call this if queue is not paused (via `options.autoStart = false` or by `.pause()` method.)
  */
  start() {
    return this._isPaused ? (this._isPaused = !1, this._processQueue(), this) : this;
  }
  /**
  Put queue execution on hold.
  */
  pause() {
    this._isPaused = !0;
  }
  /**
  Clear the queue.
  */
  clear() {
    this._queue = new this._queueClass();
  }
  /**
      Can be called multiple times. Useful if you for example add additional items at a later time.
  
      @returns A promise that settles when the queue becomes empty.
      */
  async onEmpty() {
    if (this._queue.size !== 0)
      return new Promise((e) => {
        const t = this._resolveEmpty;
        this._resolveEmpty = () => {
          t(), e();
        };
      });
  }
  /**
      The difference with `.onEmpty` is that `.onIdle` guarantees that all work from the queue has finished. `.onEmpty` merely signals that the queue is empty, but it could mean that some promises haven't completed yet.
  
      @returns A promise that settles when the queue becomes empty, and all promises have completed; `queue.size === 0 && queue.pending === 0`.
      */
  async onIdle() {
    if (!(this._pendingCount === 0 && this._queue.size === 0))
      return new Promise((e) => {
        const t = this._resolveIdle;
        this._resolveIdle = () => {
          t(), e();
        };
      });
  }
  /**
  Size of the queue.
  */
  get size() {
    return this._queue.size;
  }
  /**
      Size of the queue, filtered by the given options.
  
      For example, this can be used to find the number of items remaining in the queue with a specific priority level.
      */
  sizeBy(e) {
    return this._queue.filter(e).length;
  }
  /**
  Number of pending promises.
  */
  get pending() {
    return this._pendingCount;
  }
  /**
  Whether the queue is currently paused.
  */
  get isPaused() {
    return this._isPaused;
  }
  get timeout() {
    return this._timeout;
  }
  /**
  Set the timeout for future operations.
  */
  set timeout(e) {
    this._timeout = e;
  }
}
var Dr = Gm.default = f0;
const p0 = [
  408,
  // Request Timeout
  425,
  // Too Early
  429,
  // Too Many Requests
  500,
  // Internal Server Error
  502,
  // Bad Gateway
  503,
  // Service Unavailable
  504
  // Gateway Timeout
];
let qd = class {
  constructor(e) {
    Object.defineProperty(this, "maxConcurrency", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "maxRetries", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "maxQueueSizeBytes", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "queue", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "onFailedResponseHook", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "queueSizeBytes", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), this.maxConcurrency = e.maxConcurrency ?? 1 / 0, this.maxRetries = e.maxRetries ?? 6, this.maxQueueSizeBytes = e.maxQueueSizeBytes, "default" in Dr ? this.queue = new Dr.default({
      concurrency: this.maxConcurrency
    }) : this.queue = new Dr({ concurrency: this.maxConcurrency }), this.onFailedResponseHook = e == null ? void 0 : e.onFailedResponseHook;
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  call(e, ...t) {
    return this.callWithOptions({}, e, ...t);
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  callWithOptions(e, t, ...n) {
    const s = e.sizeBytes ?? 0;
    if (this.maxQueueSizeBytes !== void 0 && s > 0 && this.queueSizeBytes + s > this.maxQueueSizeBytes)
      return Promise.reject(new Error(`Queue size limit (${this.maxQueueSizeBytes} bytes) exceeded. Current queue size: ${this.queueSizeBytes} bytes, attempted addition: ${s} bytes.`));
    s > 0 && (this.queueSizeBytes += s);
    const a = this.onFailedResponseHook;
    let i = this.queue.add(() => r0(() => t(...n).catch((o) => {
      throw o instanceof Error ? o : new Error(o);
    }), {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      async onFailedAttempt({ error: o }) {
        if (o.message.startsWith("Cancel") || o.message.startsWith("TimeoutError") || o.name === "TimeoutError" || o.message.startsWith("AbortError") || (o == null ? void 0 : o.code) === "ECONNABORTED")
          throw o;
        const c = o == null ? void 0 : o.response;
        if (a && await a(c))
          return;
        const u = (c == null ? void 0 : c.status) ?? (o == null ? void 0 : o.status);
        if (u && !p0.includes(+u))
          throw o;
      },
      retries: this.maxRetries,
      randomize: !0
    }), { throwOnTimeout: !0 });
    return s > 0 && (i = i.finally(() => {
      this.queueSizeBytes -= s;
    })), e.signal ? Promise.race([
      i,
      new Promise((o, c) => {
        var u;
        (u = e.signal) == null || u.addEventListener("abort", () => {
          c(new Error("AbortError"));
        });
      })
    ]) : i;
  }
};
function Jd(r) {
  return typeof (r == null ? void 0 : r._getType) == "function";
}
function Hd(r) {
  const e = {
    type: r._getType(),
    data: { content: r.content }
  };
  return r != null && r.additional_kwargs && Object.keys(r.additional_kwargs).length > 0 && (e.data.additional_kwargs = { ...r.additional_kwargs }), e;
}
var jc = { exports: {} };
const m0 = "2.0.0", Qm = 256, g0 = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
9007199254740991, _0 = 16, y0 = Qm - 6, w0 = [
  "major",
  "premajor",
  "minor",
  "preminor",
  "patch",
  "prepatch",
  "prerelease"
];
var ho = {
  MAX_LENGTH: Qm,
  MAX_SAFE_COMPONENT_LENGTH: _0,
  MAX_SAFE_BUILD_LENGTH: y0,
  MAX_SAFE_INTEGER: g0,
  RELEASE_TYPES: w0,
  SEMVER_SPEC_VERSION: m0,
  FLAG_INCLUDE_PRERELEASE: 1,
  FLAG_LOOSE: 2
};
const v0 = typeof process == "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...r) => console.error("SEMVER", ...r) : () => {
};
var fo = v0;
(function(r, e) {
  const {
    MAX_SAFE_COMPONENT_LENGTH: t,
    MAX_SAFE_BUILD_LENGTH: n,
    MAX_LENGTH: s
  } = ho, a = fo;
  e = r.exports = {};
  const i = e.re = [], o = e.safeRe = [], c = e.src = [], u = e.safeSrc = [], l = e.t = {};
  let d = 0;
  const h = "[a-zA-Z0-9-]", f = [
    ["\\s", 1],
    ["\\d", s],
    [h, n]
  ], p = (m) => {
    for (const [v, g] of f)
      m = m.split(`${v}*`).join(`${v}{0,${g}}`).split(`${v}+`).join(`${v}{1,${g}}`);
    return m;
  }, y = (m, v, g) => {
    const w = p(v), T = d++;
    a(m, T, v), l[m] = T, c[T] = v, u[T] = w, i[T] = new RegExp(v, g ? "g" : void 0), o[T] = new RegExp(w, g ? "g" : void 0);
  };
  y("NUMERICIDENTIFIER", "0|[1-9]\\d*"), y("NUMERICIDENTIFIERLOOSE", "\\d+"), y("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${h}*`), y("MAINVERSION", `(${c[l.NUMERICIDENTIFIER]})\\.(${c[l.NUMERICIDENTIFIER]})\\.(${c[l.NUMERICIDENTIFIER]})`), y("MAINVERSIONLOOSE", `(${c[l.NUMERICIDENTIFIERLOOSE]})\\.(${c[l.NUMERICIDENTIFIERLOOSE]})\\.(${c[l.NUMERICIDENTIFIERLOOSE]})`), y("PRERELEASEIDENTIFIER", `(?:${c[l.NONNUMERICIDENTIFIER]}|${c[l.NUMERICIDENTIFIER]})`), y("PRERELEASEIDENTIFIERLOOSE", `(?:${c[l.NONNUMERICIDENTIFIER]}|${c[l.NUMERICIDENTIFIERLOOSE]})`), y("PRERELEASE", `(?:-(${c[l.PRERELEASEIDENTIFIER]}(?:\\.${c[l.PRERELEASEIDENTIFIER]})*))`), y("PRERELEASELOOSE", `(?:-?(${c[l.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${c[l.PRERELEASEIDENTIFIERLOOSE]})*))`), y("BUILDIDENTIFIER", `${h}+`), y("BUILD", `(?:\\+(${c[l.BUILDIDENTIFIER]}(?:\\.${c[l.BUILDIDENTIFIER]})*))`), y("FULLPLAIN", `v?${c[l.MAINVERSION]}${c[l.PRERELEASE]}?${c[l.BUILD]}?`), y("FULL", `^${c[l.FULLPLAIN]}$`), y("LOOSEPLAIN", `[v=\\s]*${c[l.MAINVERSIONLOOSE]}${c[l.PRERELEASELOOSE]}?${c[l.BUILD]}?`), y("LOOSE", `^${c[l.LOOSEPLAIN]}$`), y("GTLT", "((?:<|>)?=?)"), y("XRANGEIDENTIFIERLOOSE", `${c[l.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`), y("XRANGEIDENTIFIER", `${c[l.NUMERICIDENTIFIER]}|x|X|\\*`), y("XRANGEPLAIN", `[v=\\s]*(${c[l.XRANGEIDENTIFIER]})(?:\\.(${c[l.XRANGEIDENTIFIER]})(?:\\.(${c[l.XRANGEIDENTIFIER]})(?:${c[l.PRERELEASE]})?${c[l.BUILD]}?)?)?`), y("XRANGEPLAINLOOSE", `[v=\\s]*(${c[l.XRANGEIDENTIFIERLOOSE]})(?:\\.(${c[l.XRANGEIDENTIFIERLOOSE]})(?:\\.(${c[l.XRANGEIDENTIFIERLOOSE]})(?:${c[l.PRERELEASELOOSE]})?${c[l.BUILD]}?)?)?`), y("XRANGE", `^${c[l.GTLT]}\\s*${c[l.XRANGEPLAIN]}$`), y("XRANGELOOSE", `^${c[l.GTLT]}\\s*${c[l.XRANGEPLAINLOOSE]}$`), y("COERCEPLAIN", `(^|[^\\d])(\\d{1,${t}})(?:\\.(\\d{1,${t}}))?(?:\\.(\\d{1,${t}}))?`), y("COERCE", `${c[l.COERCEPLAIN]}(?:$|[^\\d])`), y("COERCEFULL", c[l.COERCEPLAIN] + `(?:${c[l.PRERELEASE]})?(?:${c[l.BUILD]})?(?:$|[^\\d])`), y("COERCERTL", c[l.COERCE], !0), y("COERCERTLFULL", c[l.COERCEFULL], !0), y("LONETILDE", "(?:~>?)"), y("TILDETRIM", `(\\s*)${c[l.LONETILDE]}\\s+`, !0), e.tildeTrimReplace = "$1~", y("TILDE", `^${c[l.LONETILDE]}${c[l.XRANGEPLAIN]}$`), y("TILDELOOSE", `^${c[l.LONETILDE]}${c[l.XRANGEPLAINLOOSE]}$`), y("LONECARET", "(?:\\^)"), y("CARETTRIM", `(\\s*)${c[l.LONECARET]}\\s+`, !0), e.caretTrimReplace = "$1^", y("CARET", `^${c[l.LONECARET]}${c[l.XRANGEPLAIN]}$`), y("CARETLOOSE", `^${c[l.LONECARET]}${c[l.XRANGEPLAINLOOSE]}$`), y("COMPARATORLOOSE", `^${c[l.GTLT]}\\s*(${c[l.LOOSEPLAIN]})$|^$`), y("COMPARATOR", `^${c[l.GTLT]}\\s*(${c[l.FULLPLAIN]})$|^$`), y("COMPARATORTRIM", `(\\s*)${c[l.GTLT]}\\s*(${c[l.LOOSEPLAIN]}|${c[l.XRANGEPLAIN]})`, !0), e.comparatorTrimReplace = "$1$2$3", y("HYPHENRANGE", `^\\s*(${c[l.XRANGEPLAIN]})\\s+-\\s+(${c[l.XRANGEPLAIN]})\\s*$`), y("HYPHENRANGELOOSE", `^\\s*(${c[l.XRANGEPLAINLOOSE]})\\s+-\\s+(${c[l.XRANGEPLAINLOOSE]})\\s*$`), y("STAR", "(<|>)?=?\\s*\\*"), y("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$"), y("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
})(jc, jc.exports);
var ha = jc.exports;
const b0 = Object.freeze({ loose: !0 }), S0 = Object.freeze({}), T0 = (r) => r ? typeof r != "object" ? b0 : r : S0;
var fl = T0;
const Gd = /^[0-9]+$/, eg = (r, e) => {
  if (typeof r == "number" && typeof e == "number")
    return r === e ? 0 : r < e ? -1 : 1;
  const t = Gd.test(r), n = Gd.test(e);
  return t && n && (r = +r, e = +e), r === e ? 0 : t && !n ? -1 : n && !t ? 1 : r < e ? -1 : 1;
}, E0 = (r, e) => eg(e, r);
var tg = {
  compareIdentifiers: eg,
  rcompareIdentifiers: E0
};
const Pa = fo, { MAX_LENGTH: Wd, MAX_SAFE_INTEGER: La } = ho, { safeRe: Ma, t: Da } = ha, x0 = fl, { compareIdentifiers: Qo } = tg;
let k0 = class _r {
  constructor(e, t) {
    if (t = x0(t), e instanceof _r) {
      if (e.loose === !!t.loose && e.includePrerelease === !!t.includePrerelease)
        return e;
      e = e.version;
    } else if (typeof e != "string")
      throw new TypeError(`Invalid version. Must be a string. Got type "${typeof e}".`);
    if (e.length > Wd)
      throw new TypeError(
        `version is longer than ${Wd} characters`
      );
    Pa("SemVer", e, t), this.options = t, this.loose = !!t.loose, this.includePrerelease = !!t.includePrerelease;
    const n = e.trim().match(t.loose ? Ma[Da.LOOSE] : Ma[Da.FULL]);
    if (!n)
      throw new TypeError(`Invalid Version: ${e}`);
    if (this.raw = e, this.major = +n[1], this.minor = +n[2], this.patch = +n[3], this.major > La || this.major < 0)
      throw new TypeError("Invalid major version");
    if (this.minor > La || this.minor < 0)
      throw new TypeError("Invalid minor version");
    if (this.patch > La || this.patch < 0)
      throw new TypeError("Invalid patch version");
    n[4] ? this.prerelease = n[4].split(".").map((s) => {
      if (/^[0-9]+$/.test(s)) {
        const a = +s;
        if (a >= 0 && a < La)
          return a;
      }
      return s;
    }) : this.prerelease = [], this.build = n[5] ? n[5].split(".") : [], this.format();
  }
  format() {
    return this.version = `${this.major}.${this.minor}.${this.patch}`, this.prerelease.length && (this.version += `-${this.prerelease.join(".")}`), this.version;
  }
  toString() {
    return this.version;
  }
  compare(e) {
    if (Pa("SemVer.compare", this.version, this.options, e), !(e instanceof _r)) {
      if (typeof e == "string" && e === this.version)
        return 0;
      e = new _r(e, this.options);
    }
    return e.version === this.version ? 0 : this.compareMain(e) || this.comparePre(e);
  }
  compareMain(e) {
    return e instanceof _r || (e = new _r(e, this.options)), this.major < e.major ? -1 : this.major > e.major ? 1 : this.minor < e.minor ? -1 : this.minor > e.minor ? 1 : this.patch < e.patch ? -1 : this.patch > e.patch ? 1 : 0;
  }
  comparePre(e) {
    if (e instanceof _r || (e = new _r(e, this.options)), this.prerelease.length && !e.prerelease.length)
      return -1;
    if (!this.prerelease.length && e.prerelease.length)
      return 1;
    if (!this.prerelease.length && !e.prerelease.length)
      return 0;
    let t = 0;
    do {
      const n = this.prerelease[t], s = e.prerelease[t];
      if (Pa("prerelease compare", t, n, s), n === void 0 && s === void 0)
        return 0;
      if (s === void 0)
        return 1;
      if (n === void 0)
        return -1;
      if (n === s)
        continue;
      return Qo(n, s);
    } while (++t);
  }
  compareBuild(e) {
    e instanceof _r || (e = new _r(e, this.options));
    let t = 0;
    do {
      const n = this.build[t], s = e.build[t];
      if (Pa("build compare", t, n, s), n === void 0 && s === void 0)
        return 0;
      if (s === void 0)
        return 1;
      if (n === void 0)
        return -1;
      if (n === s)
        continue;
      return Qo(n, s);
    } while (++t);
  }
  // preminor will bump the version up to the next minor release, and immediately
  // down to pre-release. premajor and prepatch work the same way.
  inc(e, t, n) {
    if (e.startsWith("pre")) {
      if (!t && n === !1)
        throw new Error("invalid increment argument: identifier is empty");
      if (t) {
        const s = `-${t}`.match(this.options.loose ? Ma[Da.PRERELEASELOOSE] : Ma[Da.PRERELEASE]);
        if (!s || s[1] !== t)
          throw new Error(`invalid identifier: ${t}`);
      }
    }
    switch (e) {
      case "premajor":
        this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", t, n);
        break;
      case "preminor":
        this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", t, n);
        break;
      case "prepatch":
        this.prerelease.length = 0, this.inc("patch", t, n), this.inc("pre", t, n);
        break;
      case "prerelease":
        this.prerelease.length === 0 && this.inc("patch", t, n), this.inc("pre", t, n);
        break;
      case "release":
        if (this.prerelease.length === 0)
          throw new Error(`version ${this.raw} is not a prerelease`);
        this.prerelease.length = 0;
        break;
      case "major":
        (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) && this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
        break;
      case "minor":
        (this.patch !== 0 || this.prerelease.length === 0) && this.minor++, this.patch = 0, this.prerelease = [];
        break;
      case "patch":
        this.prerelease.length === 0 && this.patch++, this.prerelease = [];
        break;
      case "pre": {
        const s = Number(n) ? 1 : 0;
        if (this.prerelease.length === 0)
          this.prerelease = [s];
        else {
          let a = this.prerelease.length;
          for (; --a >= 0; )
            typeof this.prerelease[a] == "number" && (this.prerelease[a]++, a = -2);
          if (a === -1) {
            if (t === this.prerelease.join(".") && n === !1)
              throw new Error("invalid increment argument: identifier already exists");
            this.prerelease.push(s);
          }
        }
        if (t) {
          let a = [t, s];
          n === !1 && (a = [t]), Qo(this.prerelease[0], t) === 0 ? isNaN(this.prerelease[1]) && (this.prerelease = a) : this.prerelease = a;
        }
        break;
      }
      default:
        throw new Error(`invalid increment argument: ${e}`);
    }
    return this.raw = this.format(), this.build.length && (this.raw += `+${this.build.join(".")}`), this;
  }
};
var pl = k0;
const Kd = pl, I0 = (r, e, t) => new Kd(r, t).compare(new Kd(e, t));
var ls = I0;
const O0 = ls, A0 = (r, e, t) => O0(r, e, t) > 0;
var $0 = A0;
const C0 = ls, R0 = (r, e, t) => C0(r, e, t) < 0;
var N0 = R0;
const P0 = ls, L0 = (r, e, t) => P0(r, e, t) === 0;
var M0 = L0;
const D0 = ls, j0 = (r, e, t) => D0(r, e, t) !== 0;
var F0 = j0;
const U0 = ls, z0 = (r, e, t) => U0(r, e, t) >= 0;
var B0 = z0;
const Z0 = ls, V0 = (r, e, t) => Z0(r, e, t) <= 0;
var q0 = V0;
const J0 = M0, H0 = F0, G0 = $0, W0 = B0, K0 = N0, Y0 = q0, X0 = (r, e, t, n) => {
  switch (e) {
    case "===":
      return typeof r == "object" && (r = r.version), typeof t == "object" && (t = t.version), r === t;
    case "!==":
      return typeof r == "object" && (r = r.version), typeof t == "object" && (t = t.version), r !== t;
    case "":
    case "=":
    case "==":
      return J0(r, t, n);
    case "!=":
      return H0(r, t, n);
    case ">":
      return G0(r, t, n);
    case ">=":
      return W0(r, t, n);
    case "<":
      return K0(r, t, n);
    case "<=":
      return Y0(r, t, n);
    default:
      throw new TypeError(`Invalid operator: ${e}`);
  }
};
var Q0 = X0;
const { safeRe: LR, t: MR } = ha;
class eS {
  constructor() {
    this.max = 1e3, this.map = /* @__PURE__ */ new Map();
  }
  get(e) {
    const t = this.map.get(e);
    if (t !== void 0)
      return this.map.delete(e), this.map.set(e, t), t;
  }
  delete(e) {
    return this.map.delete(e);
  }
  set(e, t) {
    if (!this.delete(e) && t !== void 0) {
      if (this.map.size >= this.max) {
        const s = this.map.keys().next().value;
        this.delete(s);
      }
      this.map.set(e, t);
    }
    return this;
  }
}
var tS = eS, ec, Yd;
function fr() {
  if (Yd) return ec;
  Yd = 1;
  const r = /\s+/g;
  class e {
    constructor(D, U) {
      if (U = s(U), D instanceof e)
        return D.loose === !!U.loose && D.includePrerelease === !!U.includePrerelease ? D : new e(D.raw, U);
      if (D instanceof a)
        return this.raw = D.value, this.set = [[D]], this.formatted = void 0, this;
      if (this.options = U, this.loose = !!U.loose, this.includePrerelease = !!U.includePrerelease, this.raw = D.trim().replace(r, " "), this.set = this.raw.split("||").map((A) => this.parseRange(A.trim())).filter((A) => A.length), !this.set.length)
        throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
      if (this.set.length > 1) {
        const A = this.set[0];
        if (this.set = this.set.filter((P) => !y(P[0])), this.set.length === 0)
          this.set = [A];
        else if (this.set.length > 1) {
          for (const P of this.set)
            if (P.length === 1 && m(P[0])) {
              this.set = [P];
              break;
            }
        }
      }
      this.formatted = void 0;
    }
    get range() {
      if (this.formatted === void 0) {
        this.formatted = "";
        for (let D = 0; D < this.set.length; D++) {
          D > 0 && (this.formatted += "||");
          const U = this.set[D];
          for (let A = 0; A < U.length; A++)
            A > 0 && (this.formatted += " "), this.formatted += U[A].toString().trim();
        }
      }
      return this.formatted;
    }
    format() {
      return this.range;
    }
    toString() {
      return this.range;
    }
    parseRange(D) {
      const A = ((this.options.includePrerelease && f) | (this.options.loose && p)) + ":" + D, P = n.get(A);
      if (P)
        return P;
      const N = this.options.loose, j = N ? c[u.HYPHENRANGELOOSE] : c[u.HYPHENRANGE];
      D = D.replace(j, Te(this.options.includePrerelease)), i("hyphen replace", D), D = D.replace(c[u.COMPARATORTRIM], l), i("comparator trim", D), D = D.replace(c[u.TILDETRIM], d), i("tilde trim", D), D = D.replace(c[u.CARETTRIM], h), i("caret trim", D);
      let M = D.split(" ").map((ae) => g(ae, this.options)).join(" ").split(/\s+/).map((ae) => z(ae, this.options));
      N && (M = M.filter((ae) => (i("loose invalid filter", ae, this.options), !!ae.match(c[u.COMPARATORLOOSE])))), i("range list", M);
      const q = /* @__PURE__ */ new Map(), se = M.map((ae) => new a(ae, this.options));
      for (const ae of se) {
        if (y(ae))
          return [ae];
        q.set(ae.value, ae);
      }
      q.size > 1 && q.has("") && q.delete("");
      const Ee = [...q.values()];
      return n.set(A, Ee), Ee;
    }
    intersects(D, U) {
      if (!(D instanceof e))
        throw new TypeError("a Range is required");
      return this.set.some((A) => v(A, U) && D.set.some((P) => v(P, U) && A.every((N) => P.every((j) => N.intersects(j, U)))));
    }
    // if ANY of the sets match ALL of its comparators, then pass
    test(D) {
      if (!D)
        return !1;
      if (typeof D == "string")
        try {
          D = new o(D, this.options);
        } catch {
          return !1;
        }
      for (let U = 0; U < this.set.length; U++)
        if (Oe(this.set[U], D, this.options))
          return !0;
      return !1;
    }
  }
  ec = e;
  const t = tS, n = new t(), s = fl, a = po(), i = fo, o = pl, {
    safeRe: c,
    t: u,
    comparatorTrimReplace: l,
    tildeTrimReplace: d,
    caretTrimReplace: h
  } = ha, { FLAG_INCLUDE_PRERELEASE: f, FLAG_LOOSE: p } = ho, y = (Z) => Z.value === "<0.0.0-0", m = (Z) => Z.value === "", v = (Z, D) => {
    let U = !0;
    const A = Z.slice();
    let P = A.pop();
    for (; U && A.length; )
      U = A.every((N) => P.intersects(N, D)), P = A.pop();
    return U;
  }, g = (Z, D) => (Z = Z.replace(c[u.BUILD], ""), i("comp", Z, D), Z = O(Z, D), i("caret", Z), Z = T(Z, D), i("tildes", Z), Z = E(Z, D), i("xrange", Z), Z = ne(Z, D), i("stars", Z), Z), w = (Z) => !Z || Z.toLowerCase() === "x" || Z === "*", T = (Z, D) => Z.trim().split(/\s+/).map((U) => x(U, D)).join(" "), x = (Z, D) => {
    const U = D.loose ? c[u.TILDELOOSE] : c[u.TILDE];
    return Z.replace(U, (A, P, N, j, M) => {
      i("tilde", Z, A, P, N, j, M);
      let q;
      return w(P) ? q = "" : w(N) ? q = `>=${P}.0.0 <${+P + 1}.0.0-0` : w(j) ? q = `>=${P}.${N}.0 <${P}.${+N + 1}.0-0` : M ? (i("replaceTilde pr", M), q = `>=${P}.${N}.${j}-${M} <${P}.${+N + 1}.0-0`) : q = `>=${P}.${N}.${j} <${P}.${+N + 1}.0-0`, i("tilde return", q), q;
    });
  }, O = (Z, D) => Z.trim().split(/\s+/).map((U) => R(U, D)).join(" "), R = (Z, D) => {
    i("caret", Z, D);
    const U = D.loose ? c[u.CARETLOOSE] : c[u.CARET], A = D.includePrerelease ? "-0" : "";
    return Z.replace(U, (P, N, j, M, q) => {
      i("caret", Z, P, N, j, M, q);
      let se;
      return w(N) ? se = "" : w(j) ? se = `>=${N}.0.0${A} <${+N + 1}.0.0-0` : w(M) ? N === "0" ? se = `>=${N}.${j}.0${A} <${N}.${+j + 1}.0-0` : se = `>=${N}.${j}.0${A} <${+N + 1}.0.0-0` : q ? (i("replaceCaret pr", q), N === "0" ? j === "0" ? se = `>=${N}.${j}.${M}-${q} <${N}.${j}.${+M + 1}-0` : se = `>=${N}.${j}.${M}-${q} <${N}.${+j + 1}.0-0` : se = `>=${N}.${j}.${M}-${q} <${+N + 1}.0.0-0`) : (i("no pr"), N === "0" ? j === "0" ? se = `>=${N}.${j}.${M}${A} <${N}.${j}.${+M + 1}-0` : se = `>=${N}.${j}.${M}${A} <${N}.${+j + 1}.0-0` : se = `>=${N}.${j}.${M} <${+N + 1}.0.0-0`), i("caret return", se), se;
    });
  }, E = (Z, D) => (i("replaceXRanges", Z, D), Z.split(/\s+/).map((U) => V(U, D)).join(" ")), V = (Z, D) => {
    Z = Z.trim();
    const U = D.loose ? c[u.XRANGELOOSE] : c[u.XRANGE];
    return Z.replace(U, (A, P, N, j, M, q) => {
      i("xRange", Z, A, P, N, j, M, q);
      const se = w(N), Ee = se || w(j), ae = Ee || w(M), S = ae;
      return P === "=" && S && (P = ""), q = D.includePrerelease ? "-0" : "", se ? P === ">" || P === "<" ? A = "<0.0.0-0" : A = "*" : P && S ? (Ee && (j = 0), M = 0, P === ">" ? (P = ">=", Ee ? (N = +N + 1, j = 0, M = 0) : (j = +j + 1, M = 0)) : P === "<=" && (P = "<", Ee ? N = +N + 1 : j = +j + 1), P === "<" && (q = "-0"), A = `${P + N}.${j}.${M}${q}`) : Ee ? A = `>=${N}.0.0${q} <${+N + 1}.0.0-0` : ae && (A = `>=${N}.${j}.0${q} <${N}.${+j + 1}.0-0`), i("xRange return", A), A;
    });
  }, ne = (Z, D) => (i("replaceStars", Z, D), Z.trim().replace(c[u.STAR], "")), z = (Z, D) => (i("replaceGTE0", Z, D), Z.trim().replace(c[D.includePrerelease ? u.GTE0PRE : u.GTE0], "")), Te = (Z) => (D, U, A, P, N, j, M, q, se, Ee, ae, S) => (w(A) ? U = "" : w(P) ? U = `>=${A}.0.0${Z ? "-0" : ""}` : w(N) ? U = `>=${A}.${P}.0${Z ? "-0" : ""}` : j ? U = `>=${U}` : U = `>=${U}${Z ? "-0" : ""}`, w(se) ? q = "" : w(Ee) ? q = `<${+se + 1}.0.0-0` : w(ae) ? q = `<${se}.${+Ee + 1}.0-0` : S ? q = `<=${se}.${Ee}.${ae}-${S}` : Z ? q = `<${se}.${Ee}.${+ae + 1}-0` : q = `<=${q}`, `${U} ${q}`.trim()), Oe = (Z, D, U) => {
    for (let A = 0; A < Z.length; A++)
      if (!Z[A].test(D))
        return !1;
    if (D.prerelease.length && !U.includePrerelease) {
      for (let A = 0; A < Z.length; A++)
        if (i(Z[A].semver), Z[A].semver !== a.ANY && Z[A].semver.prerelease.length > 0) {
          const P = Z[A].semver;
          if (P.major === D.major && P.minor === D.minor && P.patch === D.patch)
            return !0;
        }
      return !1;
    }
    return !0;
  };
  return ec;
}
var tc, Xd;
function po() {
  if (Xd) return tc;
  Xd = 1;
  const r = Symbol("SemVer ANY");
  class e {
    static get ANY() {
      return r;
    }
    constructor(l, d) {
      if (d = t(d), l instanceof e) {
        if (l.loose === !!d.loose)
          return l;
        l = l.value;
      }
      l = l.trim().split(/\s+/).join(" "), i("comparator", l, d), this.options = d, this.loose = !!d.loose, this.parse(l), this.semver === r ? this.value = "" : this.value = this.operator + this.semver.version, i("comp", this);
    }
    parse(l) {
      const d = this.options.loose ? n[s.COMPARATORLOOSE] : n[s.COMPARATOR], h = l.match(d);
      if (!h)
        throw new TypeError(`Invalid comparator: ${l}`);
      this.operator = h[1] !== void 0 ? h[1] : "", this.operator === "=" && (this.operator = ""), h[2] ? this.semver = new o(h[2], this.options.loose) : this.semver = r;
    }
    toString() {
      return this.value;
    }
    test(l) {
      if (i("Comparator.test", l, this.options.loose), this.semver === r || l === r)
        return !0;
      if (typeof l == "string")
        try {
          l = new o(l, this.options);
        } catch {
          return !1;
        }
      return a(l, this.operator, this.semver, this.options);
    }
    intersects(l, d) {
      if (!(l instanceof e))
        throw new TypeError("a Comparator is required");
      return this.operator === "" ? this.value === "" ? !0 : new c(l.value, d).test(this.value) : l.operator === "" ? l.value === "" ? !0 : new c(this.value, d).test(l.semver) : (d = t(d), d.includePrerelease && (this.value === "<0.0.0-0" || l.value === "<0.0.0-0") || !d.includePrerelease && (this.value.startsWith("<0.0.0") || l.value.startsWith("<0.0.0")) ? !1 : !!(this.operator.startsWith(">") && l.operator.startsWith(">") || this.operator.startsWith("<") && l.operator.startsWith("<") || this.semver.version === l.semver.version && this.operator.includes("=") && l.operator.includes("=") || a(this.semver, "<", l.semver, d) && this.operator.startsWith(">") && l.operator.startsWith("<") || a(this.semver, ">", l.semver, d) && this.operator.startsWith("<") && l.operator.startsWith(">")));
    }
  }
  tc = e;
  const t = fl, { safeRe: n, t: s } = ha, a = Q0, i = fo, o = pl, c = fr();
  return tc;
}
fr();
fr();
fr();
fr();
fr();
fr();
const rS = po(), { ANY: DR } = rS;
fr();
fr();
fr();
const ml = po(), { ANY: jR } = ml;
new ml(">=0.0.0-0");
new ml(">=0.0.0");
const rc = ha, Qd = ho, eh = tg;
po();
fr();
rc.re, rc.src, rc.t, Qd.SEMVER_SPEC_VERSION, Qd.RELEASE_TYPES, eh.compareIdentifiers, eh.rcompareIdentifiers;
function Wr(r) {
  if (!r || r.split("/").length > 2 || r.startsWith("/") || r.endsWith("/") || r.split(":").length > 2)
    throw new Error(`Invalid identifier format: ${r}`);
  const [e, t] = r.split(":"), n = t || "latest";
  if (e.includes("/")) {
    const [s, a] = e.split("/", 2);
    if (!s || !a)
      throw new Error(`Invalid identifier format: ${r}`);
    return [s, a, n];
  } else {
    if (!e)
      throw new Error(`Invalid identifier format: ${r}`);
    return ["-", e, n];
  }
}
class nS extends Error {
  constructor(e) {
    super(e), Object.defineProperty(this, "status", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.name = "LangSmithConflictError", this.status = 409;
  }
}
async function re(r, e, t) {
  let n;
  if (r.ok) {
    t && (n = await r.text());
    return;
  }
  if (r.status === 403)
    try {
      const i = await r.json();
      (i == null ? void 0 : i.error) === "org_scoped_key_requires_workspace" && (n = "This API key is org-scoped and requires workspace specification. Please provide 'workspaceId' parameter, or set LANGSMITH_WORKSPACE_ID environment variable.");
    } catch {
      const o = new Error(`${r.status} ${r.statusText}`);
      throw o.status = r == null ? void 0 : r.status, o;
    }
  if (n === void 0)
    try {
      n = await r.text();
    } catch {
      n = "";
    }
  const s = `Failed to ${e}. Received status [${r.status}]: ${r.statusText}. Message: ${n}`;
  if (r.status === 409)
    throw new nS(s);
  const a = new Error(s);
  throw a.status = r.status, a;
}
const rg = "ERR_CONFLICTING_ENDPOINTS";
class sS extends Error {
  constructor() {
    super("You cannot provide both LANGSMITH_ENDPOINT / LANGCHAIN_ENDPOINT and LANGSMITH_RUNS_ENDPOINTS."), Object.defineProperty(this, "code", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: rg
    }), this.name = "ConflictingEndpointsError";
  }
}
function aS(r) {
  return typeof r == "object" && r !== null && r.code === rg;
}
var th = "[...]", iS = { result: "[Circular]" }, Ei = [], Vn = [];
const oS = new TextEncoder();
function cS() {
  return {
    depthLimit: Number.MAX_SAFE_INTEGER,
    edgesLimit: Number.MAX_SAFE_INTEGER
  };
}
function ja(r) {
  return oS.encode(r);
}
function ng(r) {
  if (r && typeof r == "object" && r !== null) {
    if (r instanceof Map)
      return Object.fromEntries(r);
    if (r instanceof Set)
      return Array.from(r);
    if (r instanceof Date)
      return r.toISOString();
    if (r instanceof RegExp)
      return r.toString();
    if (r instanceof Error)
      return {
        name: r.name,
        message: r.message
      };
  } else if (typeof r == "bigint")
    return r.toString();
  return r;
}
function uS(r) {
  return function(e, t) {
    return ng(t);
  };
}
function jt(r, e, t, n, s) {
  var a;
  try {
    const i = JSON.stringify(r, uS(t), n);
    return ja(i);
  } catch (i) {
    if (!((a = i.message) != null && a.includes("Converting circular structure to JSON")))
      return console.warn(`[WARNING]: LangSmith received unserializable value.${e ? `
Context: ${e}` : ""}`), ja("[Unserializable]");
    Nt("SUPPRESS_CIRCULAR_JSON_WARNINGS") !== "true" && console.warn(`[WARNING]: LangSmith received circular JSON. This will decrease tracer performance. ${e ? `
Context: ${e}` : ""}`), typeof s > "u" && (s = cS()), Fc(r, "", 0, [], void 0, 0, s);
    let o;
    try {
      Vn.length === 0 ? o = JSON.stringify(r, t, n) : o = JSON.stringify(r, lS(t), n);
    } catch {
      return ja("[unable to serialize, circular reference is too complex to analyze]");
    } finally {
      for (; Ei.length !== 0; ) {
        const c = Ei.pop();
        c.length === 4 ? Object.defineProperty(c[0], c[1], c[3]) : c[0][c[1]] = c[2];
      }
    }
    return ja(o);
  }
}
function nc(r, e, t, n) {
  var s = Object.getOwnPropertyDescriptor(n, t);
  s.get !== void 0 ? s.configurable ? (Object.defineProperty(n, t, { value: r }), Ei.push([n, t, e, s])) : Vn.push([e, t, r]) : (n[t] = r, Ei.push([n, t, e]));
}
function Fc(r, e, t, n, s, a, i) {
  a += 1;
  var o;
  if (typeof r == "object" && r !== null) {
    for (o = 0; o < n.length; o++)
      if (n[o] === r) {
        nc(iS, r, e, s);
        return;
      }
    if (typeof i.depthLimit < "u" && a > i.depthLimit) {
      nc(th, r, e, s);
      return;
    }
    if (typeof i.edgesLimit < "u" && t + 1 > i.edgesLimit) {
      nc(th, r, e, s);
      return;
    }
    if (n.push(r), Array.isArray(r))
      for (o = 0; o < r.length; o++)
        Fc(r[o], o, o, n, r, a, i);
    else {
      r = ng(r);
      var c = Object.keys(r);
      for (o = 0; o < c.length; o++) {
        var u = c[o];
        Fc(r[u], u, o, n, r, a, i);
      }
    }
    n.pop();
  }
}
function lS(r) {
  return r = typeof r < "u" ? r : function(e, t) {
    return t;
  }, function(e, t) {
    if (Vn.length > 0)
      for (var n = 0; n < Vn.length; n++) {
        var s = Vn[n];
        if (s[1] === e && s[0] === t) {
          t = s[2], Vn.splice(n, 1);
          break;
        }
      }
    return r.call(this, e, t);
  };
}
function rh(r, e) {
  const t = Vm(), n = e ?? qm(), s = r.extra ?? {}, a = s.metadata;
  return r.extra = {
    ...s,
    runtime: {
      ...t,
      ...s == null ? void 0 : s.runtime
    },
    metadata: {
      ...n,
      ...n.revision_id || "revision_id" in r && r.revision_id ? {
        revision_id: ("revision_id" in r ? r.revision_id : void 0) ?? n.revision_id
      } : {},
      ...a
    }
  }, r;
}
const dS = (r) => {
  const e = (r == null ? void 0 : r.toString()) ?? Nt("TRACING_SAMPLING_RATE");
  if (e === void 0)
    return;
  const t = parseFloat(e);
  if (t < 0 || t > 1)
    throw new Error(`LANGSMITH_TRACING_SAMPLING_RATE must be between 0 and 1 if set. Got: ${t}`);
  return t;
}, hS = (r) => {
  const t = r.replace("http://", "").replace("https://", "").split("/")[0].split(":")[0];
  return t === "localhost" || t === "127.0.0.1" || t === "::1";
};
async function fS(r) {
  const e = [];
  for await (const t of r)
    e.push(t);
  return e;
}
function Fa(r) {
  if (r !== void 0)
    return r.trim().replace(/^"(.*)"$/, "$1").replace(/^'(.*)'$/, "$1");
}
const pS = async (r) => {
  if ((r == null ? void 0 : r.status) === 429) {
    const e = parseInt(r.headers.get("retry-after") ?? "10", 10) * 1e3;
    if (e > 0)
      return await new Promise((t) => setTimeout(t, e)), !0;
  }
  return !1;
};
function nh(r) {
  return typeof r == "number" ? Number(r.toFixed(4)) : r;
}
const mS = 24 * 1024 * 1024, sg = 1024 * 1024 * 1024, gS = 1e4, _S = 100, sh = "https://api.smith.langchain.com";
class yS {
  constructor(e) {
    Object.defineProperty(this, "items", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "sizeBytes", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "maxSizeBytes", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.maxSizeBytes = e ?? sg;
  }
  peek() {
    return this.items[0];
  }
  push(e) {
    let t;
    const n = new Promise((a) => {
      t = a;
    }), s = jt(e.item, `Serializing run with id: ${e.item.id}`).length;
    return this.sizeBytes + s > this.maxSizeBytes && this.items.length > 0 ? (console.warn(`AutoBatchQueue size limit (${this.maxSizeBytes} bytes) exceeded. Dropping run with id: ${e.item.id}. Current queue size: ${this.sizeBytes} bytes, attempted addition: ${s} bytes.`), t(), n) : (this.items.push({
      action: e.action,
      payload: e.item,
      otelContext: e.otelContext,
      apiKey: e.apiKey,
      apiUrl: e.apiUrl,
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      itemPromiseResolve: t,
      itemPromise: n,
      size: s
    }), this.sizeBytes += s, n);
  }
  pop({ upToSizeBytes: e, upToSize: t }) {
    var a;
    if (e < 1)
      throw new Error("Number of bytes to pop off may not be less than 1.");
    const n = [];
    let s = 0;
    for (; s + (((a = this.peek()) == null ? void 0 : a.size) ?? 0) < e && this.items.length > 0 && n.length < t; ) {
      const i = this.items.shift();
      i && (n.push(i), s += i.size, this.sizeBytes -= i.size);
    }
    if (n.length === 0 && this.items.length > 0) {
      const i = this.items.shift();
      n.push(i), s += i.size, this.sizeBytes -= i.size;
    }
    return [
      n.map((i) => ({
        action: i.action,
        item: i.payload,
        otelContext: i.otelContext,
        apiKey: i.apiKey,
        apiUrl: i.apiUrl,
        size: i.size
      })),
      () => n.forEach((i) => i.itemPromiseResolve())
    ];
  }
}
class Ws {
  get _fetch() {
    return this.fetchImplementation || Ob(this.debug);
  }
  constructor(e = {}) {
    var s;
    Object.defineProperty(this, "apiKey", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "apiUrl", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "webUrl", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "workspaceId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "caller", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "batchIngestCaller", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "timeout_ms", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_tenantId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: null
    }), Object.defineProperty(this, "hideInputs", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "hideOutputs", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "tracingSampleRate", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "filteredPostUuids", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: /* @__PURE__ */ new Set()
    }), Object.defineProperty(this, "autoBatchTracing", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "autoBatchQueue", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "autoBatchTimeout", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "autoBatchAggregationDelayMs", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 250
    }), Object.defineProperty(this, "batchSizeBytesLimit", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "batchSizeLimit", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "fetchOptions", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "settings", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "blockOnRootRunFinalization", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: Or("LANGSMITH_TRACING_BACKGROUND") === "false"
    }), Object.defineProperty(this, "traceBatchConcurrency", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 5
    }), Object.defineProperty(this, "_serverInfo", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_getServerInfoPromise", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "manualFlushMode", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "langSmithToOTELTranslator", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "fetchImplementation", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "cachedLSEnvVarsForMetadata", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "multipartStreamingDisabled", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "debug", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: Or("LANGSMITH_DEBUG") === "true"
    });
    const t = Ws.getDefaultClientConfig();
    if (this.tracingSampleRate = dS(e.tracingSamplingRate), this.apiUrl = Fa(e.apiUrl ?? t.apiUrl) ?? "", this.apiUrl.endsWith("/") && (this.apiUrl = this.apiUrl.slice(0, -1)), this.apiKey = Fa(e.apiKey ?? t.apiKey), this.webUrl = Fa(e.webUrl ?? t.webUrl), (s = this.webUrl) != null && s.endsWith("/") && (this.webUrl = this.webUrl.slice(0, -1)), this.workspaceId = Fa(e.workspaceId ?? Nt("WORKSPACE_ID")), this.timeout_ms = e.timeout_ms ?? 9e4, this.caller = new qd({
      ...e.callerOptions ?? {},
      maxRetries: 4,
      debug: e.debug ?? this.debug
    }), this.traceBatchConcurrency = e.traceBatchConcurrency ?? this.traceBatchConcurrency, this.traceBatchConcurrency < 1)
      throw new Error("Trace batch concurrency must be positive.");
    this.debug = e.debug ?? this.debug, this.fetchImplementation = e.fetchImplementation;
    const n = e.maxIngestMemoryBytes ?? sg;
    this.batchIngestCaller = new qd({
      maxRetries: 4,
      maxConcurrency: this.traceBatchConcurrency,
      maxQueueSizeBytes: n,
      ...e.callerOptions ?? {},
      onFailedResponseHook: pS,
      debug: e.debug ?? this.debug
    }), this.hideInputs = e.hideInputs ?? e.anonymizer ?? t.hideInputs, this.hideOutputs = e.hideOutputs ?? e.anonymizer ?? t.hideOutputs, this.autoBatchTracing = e.autoBatchTracing ?? this.autoBatchTracing, this.autoBatchQueue = new yS(n), this.blockOnRootRunFinalization = e.blockOnRootRunFinalization ?? this.blockOnRootRunFinalization, this.batchSizeBytesLimit = e.batchSizeBytesLimit, this.batchSizeLimit = e.batchSizeLimit, this.fetchOptions = e.fetchOptions || {}, this.manualFlushMode = e.manualFlushMode ?? this.manualFlushMode, Jm() && (this.langSmithToOTELTranslator = new Hb()), this.cachedLSEnvVarsForMetadata = qm();
  }
  static getDefaultClientConfig() {
    const e = Nt("API_KEY"), t = Nt("ENDPOINT") ?? sh, n = Nt("HIDE_INPUTS") === "true", s = Nt("HIDE_OUTPUTS") === "true";
    return {
      apiUrl: t,
      apiKey: e,
      webUrl: void 0,
      hideInputs: n,
      hideOutputs: s
    };
  }
  getHostUrl() {
    return this.webUrl ? this.webUrl : hS(this.apiUrl) ? (this.webUrl = "http://localhost:3000", this.webUrl) : this.apiUrl.endsWith("/api/v1") ? (this.webUrl = this.apiUrl.replace("/api/v1", ""), this.webUrl) : this.apiUrl.includes("/api") && !this.apiUrl.split(".", 1)[0].endsWith("api") ? (this.webUrl = this.apiUrl.replace("/api", ""), this.webUrl) : this.apiUrl.split(".", 1)[0].includes("dev") ? (this.webUrl = "https://dev.smith.langchain.com", this.webUrl) : this.apiUrl.split(".", 1)[0].includes("eu") ? (this.webUrl = "https://eu.smith.langchain.com", this.webUrl) : this.apiUrl.split(".", 1)[0].includes("beta") ? (this.webUrl = "https://beta.smith.langchain.com", this.webUrl) : (this.webUrl = "https://smith.langchain.com", this.webUrl);
  }
  get headers() {
    const e = {
      "User-Agent": `langsmith-js/${zm}`
    };
    return this.apiKey && (e["x-api-key"] = `${this.apiKey}`), this.workspaceId && (e["x-tenant-id"] = this.workspaceId), e;
  }
  _getPlatformEndpointPath(e) {
    return this.apiUrl.slice(-3) !== "/v1" && this.apiUrl.slice(-4) !== "/v1/" ? `/v1/platform/${e}` : `/platform/${e}`;
  }
  async processInputs(e) {
    return this.hideInputs === !1 ? e : this.hideInputs === !0 ? {} : typeof this.hideInputs == "function" ? this.hideInputs(e) : e;
  }
  async processOutputs(e) {
    return this.hideOutputs === !1 ? e : this.hideOutputs === !0 ? {} : typeof this.hideOutputs == "function" ? this.hideOutputs(e) : e;
  }
  async prepareRunCreateOrUpdateInputs(e) {
    const t = { ...e };
    return t.inputs !== void 0 && (t.inputs = await this.processInputs(t.inputs)), t.outputs !== void 0 && (t.outputs = await this.processOutputs(t.outputs)), t;
  }
  async _getResponse(e, t) {
    const n = (t == null ? void 0 : t.toString()) ?? "", s = `${this.apiUrl}${e}?${n}`;
    return await this.caller.call(async () => {
      const i = await this._fetch(s, {
        method: "GET",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      return await re(i, `fetch ${e}`), i;
    });
  }
  async _get(e, t) {
    return (await this._getResponse(e, t)).json();
  }
  async *_getPaginated(e, t = new URLSearchParams(), n) {
    let s = Number(t.get("offset")) || 0;
    const a = Number(t.get("limit")) || 100;
    for (; ; ) {
      t.set("offset", String(s)), t.set("limit", String(a));
      const i = `${this.apiUrl}${e}?${t}`, o = await this.caller.call(async () => {
        const u = await this._fetch(i, {
          method: "GET",
          headers: this.headers,
          signal: AbortSignal.timeout(this.timeout_ms),
          ...this.fetchOptions
        });
        return await re(u, `fetch ${e}`), u;
      }), c = n ? n(await o.json()) : await o.json();
      if (c.length === 0 || (yield c, c.length < a))
        break;
      s += c.length;
    }
  }
  async *_getCursorPaginatedList(e, t = null, n = "POST", s = "runs") {
    const a = t ? { ...t } : {};
    for (; ; ) {
      const i = JSON.stringify(a), c = await (await this.caller.call(async () => {
        const l = await this._fetch(`${this.apiUrl}${e}`, {
          method: n,
          headers: { ...this.headers, "Content-Type": "application/json" },
          signal: AbortSignal.timeout(this.timeout_ms),
          ...this.fetchOptions,
          body: i
        });
        return await re(l, `fetch ${e}`), l;
      })).json();
      if (!c || !c[s])
        break;
      yield c[s];
      const u = c.cursors;
      if (!u || !u.next)
        break;
      a.cursor = u.next;
    }
  }
  // Allows mocking for tests
  _shouldSample() {
    return this.tracingSampleRate === void 0 ? !0 : Math.random() < this.tracingSampleRate;
  }
  _filterForSampling(e, t = !1) {
    if (this.tracingSampleRate === void 0)
      return e;
    if (t) {
      const n = [];
      for (const s of e)
        this.filteredPostUuids.has(s.trace_id) ? s.id === s.trace_id && this.filteredPostUuids.delete(s.trace_id) : n.push(s);
      return n;
    } else {
      const n = [];
      for (const s of e) {
        const a = s.trace_id ?? s.id;
        this.filteredPostUuids.has(a) || (s.id === a ? this._shouldSample() ? n.push(s) : this.filteredPostUuids.add(a) : n.push(s));
      }
      return n;
    }
  }
  async _getBatchSizeLimitBytes() {
    var t;
    const e = await this._ensureServerInfo();
    return this.batchSizeBytesLimit ?? ((t = e.batch_ingest_config) == null ? void 0 : t.size_limit_bytes) ?? mS;
  }
  /**
   * Get the maximum number of operations to batch in a single request.
   */
  async _getBatchSizeLimit() {
    var t;
    const e = await this._ensureServerInfo();
    return this.batchSizeLimit ?? ((t = e.batch_ingest_config) == null ? void 0 : t.size_limit) ?? _S;
  }
  async _getDatasetExamplesMultiPartSupport() {
    var t;
    return ((t = (await this._ensureServerInfo()).instance_flags) == null ? void 0 : t.dataset_examples_multipart_enabled) ?? !1;
  }
  drainAutoBatchQueue({ batchSizeLimitBytes: e, batchSizeLimit: t }) {
    const n = [];
    for (; this.autoBatchQueue.items.length > 0; ) {
      const [s, a] = this.autoBatchQueue.pop({
        upToSizeBytes: e,
        upToSize: t
      });
      if (!s.length) {
        a();
        break;
      }
      const i = s.reduce((u, l) => {
        const d = l.apiUrl ?? this.apiUrl, h = l.apiKey ?? this.apiKey, p = l.apiKey === this.apiKey && l.apiUrl === this.apiUrl ? "default" : `${d}|${h}`;
        return u[p] || (u[p] = []), u[p].push(l), u;
      }, {}), o = [];
      for (const [u, l] of Object.entries(i)) {
        const d = this._processBatch(l, {
          apiUrl: u === "default" ? void 0 : u.split("|")[0],
          apiKey: u === "default" ? void 0 : u.split("|")[1]
        });
        o.push(d);
      }
      const c = Promise.all(o).finally(a);
      n.push(c);
    }
    return Promise.all(n);
  }
  async _processBatch(e, t) {
    var s, a;
    if (!e.length)
      return;
    const n = e.reduce((i, o) => i + (o.size ?? 0), 0);
    try {
      if (this.langSmithToOTELTranslator !== void 0)
        this._sendBatchToOTELTranslator(e);
      else {
        const i = {
          runCreates: e.filter((c) => c.action === "create").map((c) => c.item),
          runUpdates: e.filter((c) => c.action === "update").map((c) => c.item)
        }, o = await this._ensureServerInfo();
        if ((s = o == null ? void 0 : o.batch_ingest_config) != null && s.use_multipart_endpoint) {
          const c = (a = o == null ? void 0 : o.instance_flags) == null ? void 0 : a.gzip_body_enabled;
          await this.multipartIngestRuns(i, {
            ...t,
            useGzip: c,
            sizeBytes: n
          });
        } else
          await this.batchIngestRuns(i, {
            ...t,
            sizeBytes: n
          });
      }
    } catch (i) {
      console.error("Error exporting batch:", i);
    }
  }
  _sendBatchToOTELTranslator(e) {
    if (this.langSmithToOTELTranslator !== void 0) {
      const t = /* @__PURE__ */ new Map(), n = [];
      for (const s of e)
        s.item.id && s.otelContext && (t.set(s.item.id, s.otelContext), s.action === "create" ? n.push({
          operation: "post",
          id: s.item.id,
          trace_id: s.item.trace_id ?? s.item.id,
          run: s.item
        }) : n.push({
          operation: "patch",
          id: s.item.id,
          trace_id: s.item.trace_id ?? s.item.id,
          run: s.item
        }));
      this.langSmithToOTELTranslator.exportBatch(n, t);
    }
  }
  async processRunOperation(e) {
    clearTimeout(this.autoBatchTimeout), this.autoBatchTimeout = void 0, e.item = rh(e.item, this.cachedLSEnvVarsForMetadata);
    const t = this.autoBatchQueue.push(e);
    if (this.manualFlushMode)
      return t;
    const n = await this._getBatchSizeLimitBytes(), s = await this._getBatchSizeLimit();
    return (this.autoBatchQueue.sizeBytes > n || this.autoBatchQueue.items.length > s) && this.drainAutoBatchQueue({
      batchSizeLimitBytes: n,
      batchSizeLimit: s
    }), this.autoBatchQueue.items.length > 0 && (this.autoBatchTimeout = setTimeout(() => {
      this.autoBatchTimeout = void 0, this.drainAutoBatchQueue({
        batchSizeLimitBytes: n,
        batchSizeLimit: s
      });
    }, this.autoBatchAggregationDelayMs)), t;
  }
  async _getServerInfo() {
    const t = await (await this.caller.call(async () => {
      const n = await this._fetch(`${this.apiUrl}/info`, {
        method: "GET",
        headers: { Accept: "application/json" },
        signal: AbortSignal.timeout(gS),
        ...this.fetchOptions
      });
      return await re(n, "get server info"), n;
    })).json();
    return this.debug && console.log(`
=== LangSmith Server Configuration ===
` + JSON.stringify(t, null, 2) + `
`), t;
  }
  async _ensureServerInfo() {
    return this._getServerInfoPromise === void 0 && (this._getServerInfoPromise = (async () => {
      if (this._serverInfo === void 0)
        try {
          this._serverInfo = await this._getServerInfo();
        } catch (e) {
          console.warn(`[LANGSMITH]: Failed to fetch info on supported operations. Falling back to batch operations and default limits. Info: ${e.status ?? "Unspecified status code"} ${e.message}`);
        }
      return this._serverInfo ?? {};
    })()), this._getServerInfoPromise.then((e) => (this._serverInfo === void 0 && (this._getServerInfoPromise = void 0), e));
  }
  async _getSettings() {
    return this.settings || (this.settings = this._get("/settings")), await this.settings;
  }
  /**
   * Flushes current queued traces.
   */
  async flush() {
    const e = await this._getBatchSizeLimitBytes(), t = await this._getBatchSizeLimit();
    await this.drainAutoBatchQueue({
      batchSizeLimitBytes: e,
      batchSizeLimit: t
    });
  }
  _cloneCurrentOTELContext() {
    const e = Hm(), t = Zb();
    if (this.langSmithToOTELTranslator !== void 0) {
      const n = e.getActiveSpan();
      if (n)
        return e.setSpan(t.active(), n);
    }
  }
  async createRun(e, t) {
    if (!this._filterForSampling([e]).length)
      return;
    const n = {
      ...this.headers,
      "Content-Type": "application/json"
    }, s = e.project_name;
    delete e.project_name;
    const a = await this.prepareRunCreateOrUpdateInputs({
      session_name: s,
      ...e,
      start_time: e.start_time ?? Date.now()
    });
    if (this.autoBatchTracing && a.trace_id !== void 0 && a.dotted_order !== void 0) {
      const c = this._cloneCurrentOTELContext();
      this.processRunOperation({
        action: "create",
        item: a,
        otelContext: c,
        apiKey: t == null ? void 0 : t.apiKey,
        apiUrl: t == null ? void 0 : t.apiUrl
      }).catch(console.error);
      return;
    }
    const i = rh(a, this.cachedLSEnvVarsForMetadata);
    (t == null ? void 0 : t.apiKey) !== void 0 && (n["x-api-key"] = t.apiKey), (t == null ? void 0 : t.workspaceId) !== void 0 && (n["x-tenant-id"] = t.workspaceId);
    const o = jt(i, `Creating run with id: ${i.id}`);
    await this.caller.call(async () => {
      const c = await this._fetch(`${(t == null ? void 0 : t.apiUrl) ?? this.apiUrl}/runs`, {
        method: "POST",
        headers: n,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: o
      });
      return await re(c, "create run", !0), c;
    });
  }
  /**
   * Batch ingest/upsert multiple runs in the Langsmith system.
   * @param runs
   */
  async batchIngestRuns({ runCreates: e, runUpdates: t }, n) {
    if (e === void 0 && t === void 0)
      return;
    let s = await Promise.all((e == null ? void 0 : e.map((c) => this.prepareRunCreateOrUpdateInputs(c))) ?? []), a = await Promise.all((t == null ? void 0 : t.map((c) => this.prepareRunCreateOrUpdateInputs(c))) ?? []);
    if (s.length > 0 && a.length > 0) {
      const c = s.reduce((l, d) => (d.id && (l[d.id] = d), l), {}), u = [];
      for (const l of a)
        l.id !== void 0 && c[l.id] ? c[l.id] = {
          ...c[l.id],
          ...l
        } : u.push(l);
      s = Object.values(c), a = u;
    }
    const i = {
      post: s,
      patch: a
    };
    if (!i.post.length && !i.patch.length)
      return;
    const o = {
      post: [],
      patch: []
    };
    for (const c of ["post", "patch"]) {
      const u = c, l = i[u].reverse();
      let d = l.pop();
      for (; d !== void 0; )
        o[u].push(d), d = l.pop();
    }
    if (o.post.length > 0 || o.patch.length > 0) {
      const c = o.post.map((u) => u.id).concat(o.patch.map((u) => u.id)).join(",");
      await this._postBatchIngestRuns(jt(o, `Ingesting runs with ids: ${c}`), n);
    }
  }
  async _postBatchIngestRuns(e, t) {
    const n = {
      ...this.headers,
      "Content-Type": "application/json",
      Accept: "application/json"
    };
    (t == null ? void 0 : t.apiKey) !== void 0 && (n["x-api-key"] = t.apiKey), await this.batchIngestCaller.callWithOptions({ sizeBytes: t == null ? void 0 : t.sizeBytes }, async () => {
      const s = await this._fetch(`${(t == null ? void 0 : t.apiUrl) ?? this.apiUrl}/runs/batch`, {
        method: "POST",
        headers: n,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: e
      });
      return await re(s, "batch create run", !0), s;
    });
  }
  /**
   * Batch ingest/upsert multiple runs in the Langsmith system.
   * @param runs
   */
  async multipartIngestRuns({ runCreates: e, runUpdates: t }, n) {
    if (e === void 0 && t === void 0)
      return;
    const s = {};
    let a = [];
    for (const d of e ?? []) {
      const h = await this.prepareRunCreateOrUpdateInputs(d);
      h.id !== void 0 && h.attachments !== void 0 && (s[h.id] = h.attachments), delete h.attachments, a.push(h);
    }
    let i = [];
    for (const d of t ?? [])
      i.push(await this.prepareRunCreateOrUpdateInputs(d));
    if (a.find((d) => d.trace_id === void 0 || d.dotted_order === void 0) !== void 0)
      throw new Error('Multipart ingest requires "trace_id" and "dotted_order" to be set when creating a run');
    if (i.find((d) => d.trace_id === void 0 || d.dotted_order === void 0) !== void 0)
      throw new Error('Multipart ingest requires "trace_id" and "dotted_order" to be set when updating a run');
    if (a.length > 0 && i.length > 0) {
      const d = a.reduce((f, p) => (p.id && (f[p.id] = p), f), {}), h = [];
      for (const f of i)
        f.id !== void 0 && d[f.id] ? d[f.id] = {
          ...d[f.id],
          ...f
        } : h.push(f);
      a = Object.values(d), i = h;
    }
    if (a.length === 0 && i.length === 0)
      return;
    const u = [], l = [];
    for (const [d, h] of [
      ["post", a],
      ["patch", i]
    ])
      for (const f of h) {
        const { inputs: p, outputs: y, events: m, extra: v, error: g, serialized: w, attachments: T, ...x } = f, O = { inputs: p, outputs: y, events: m, extra: v, error: g, serialized: w }, R = jt(x, `Serializing for multipart ingestion of run with id: ${x.id}`);
        l.push({
          name: `${d}.${x.id}`,
          payload: new Blob([R], {
            type: `application/json; length=${R.length}`
            // encoding=gzip
          })
        });
        for (const [E, V] of Object.entries(O)) {
          if (V === void 0)
            continue;
          const ne = jt(V, `Serializing ${E} for multipart ingestion of run with id: ${x.id}`);
          l.push({
            name: `${d}.${x.id}.${E}`,
            payload: new Blob([ne], {
              type: `application/json; length=${ne.length}`
            })
          });
        }
        if (x.id !== void 0) {
          const E = s[x.id];
          if (E) {
            delete s[x.id];
            for (const [V, ne] of Object.entries(E)) {
              let z, Te;
              if (Array.isArray(ne) ? [z, Te] = ne : (z = ne.mimeType, Te = ne.data), V.includes(".")) {
                console.warn(`Skipping attachment '${V}' for run ${x.id}: Invalid attachment name. Attachment names must not contain periods ('.'). Please rename the attachment and try again.`);
                continue;
              }
              l.push({
                name: `attachment.${x.id}.${V}`,
                payload: new Blob([Te], {
                  type: `${z}; length=${Te.byteLength}`
                })
              });
            }
          }
        }
        u.push(`trace=${x.trace_id},id=${x.id}`);
      }
    await this._sendMultipartRequest(l, u.join("; "), n);
  }
  async _createNodeFetchBody(e, t) {
    const n = [];
    for (const i of e)
      n.push(new Blob([`--${t}\r
`])), n.push(new Blob([
        `Content-Disposition: form-data; name="${i.name}"\r
`,
        `Content-Type: ${i.payload.type}\r
\r
`
      ])), n.push(i.payload), n.push(new Blob([`\r
`]));
    return n.push(new Blob([`--${t}--\r
`])), await new Blob(n).arrayBuffer();
  }
  async _createMultipartStream(e, t) {
    const n = new TextEncoder();
    return new ReadableStream({
      async start(a) {
        const i = async (o) => {
          typeof o == "string" ? a.enqueue(n.encode(o)) : a.enqueue(o);
        };
        for (const o of e) {
          await i(`--${t}\r
`), await i(`Content-Disposition: form-data; name="${o.name}"\r
`), await i(`Content-Type: ${o.payload.type}\r
\r
`);
          const u = o.payload.stream().getReader();
          try {
            let l;
            for (; !(l = await u.read()).done; )
              a.enqueue(l.value);
          } finally {
            u.releaseLock();
          }
          await i(`\r
`);
        }
        await i(`--${t}--\r
`), a.close();
      }
    });
  }
  async _sendMultipartRequest(e, t, n) {
    const s = "----LangSmithFormBoundary" + Math.random().toString(36).slice(2), a = Ib(), i = () => this._createNodeFetchBody(e, s), o = () => this._createMultipartStream(e, s), c = async (u) => this.batchIngestCaller.callWithOptions({ sizeBytes: n == null ? void 0 : n.sizeBytes }, async () => {
      const l = await u(), d = {
        ...this.headers,
        "Content-Type": `multipart/form-data; boundary=${s}`
      };
      (n == null ? void 0 : n.apiKey) !== void 0 && (d["x-api-key"] = n.apiKey);
      let h = l;
      n != null && n.useGzip && typeof l == "object" && "pipeThrough" in l && (h = l.pipeThrough(new CompressionStream("gzip")), d["Content-Encoding"] = "gzip");
      const f = await this._fetch(`${(n == null ? void 0 : n.apiUrl) ?? this.apiUrl}/runs/multipart`, {
        method: "POST",
        headers: d,
        body: h,
        duplex: "half",
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      return await re(f, "Failed to send multipart request", !0), f;
    });
    try {
      let u, l = !1;
      !a && !this.multipartStreamingDisabled && Zm() !== "bun" ? (l = !0, u = await c(o)) : u = await c(i), (!this.multipartStreamingDisabled || l) && u.status === 422 && ((n == null ? void 0 : n.apiUrl) ?? this.apiUrl) !== sh && (console.warn(`Streaming multipart upload to ${(n == null ? void 0 : n.apiUrl) ?? this.apiUrl}/runs/multipart failed. This usually means the host does not support chunked uploads. Retrying with a buffered upload for operation "${t}".`), this.multipartStreamingDisabled = !0, u = await c(i));
    } catch (u) {
      console.warn(`${u.message.trim()}

Context: ${t}`);
    }
  }
  async updateRun(e, t, n) {
    ve(e), t.inputs && (t.inputs = await this.processInputs(t.inputs)), t.outputs && (t.outputs = await this.processOutputs(t.outputs));
    const s = { ...t, id: e };
    if (!this._filterForSampling([s], !0).length)
      return;
    if (this.autoBatchTracing && s.trace_id !== void 0 && s.dotted_order !== void 0) {
      const o = this._cloneCurrentOTELContext();
      if (t.end_time !== void 0 && s.parent_run_id === void 0 && this.blockOnRootRunFinalization && !this.manualFlushMode) {
        await this.processRunOperation({
          action: "update",
          item: s,
          otelContext: o,
          apiKey: n == null ? void 0 : n.apiKey,
          apiUrl: n == null ? void 0 : n.apiUrl
        }).catch(console.error);
        return;
      } else
        this.processRunOperation({
          action: "update",
          item: s,
          otelContext: o,
          apiKey: n == null ? void 0 : n.apiKey,
          apiUrl: n == null ? void 0 : n.apiUrl
        }).catch(console.error);
      return;
    }
    const a = {
      ...this.headers,
      "Content-Type": "application/json"
    };
    (n == null ? void 0 : n.apiKey) !== void 0 && (a["x-api-key"] = n.apiKey), (n == null ? void 0 : n.workspaceId) !== void 0 && (a["x-tenant-id"] = n.workspaceId);
    const i = jt(t, `Serializing payload to update run with id: ${e}`);
    await this.caller.call(async () => {
      const o = await this._fetch(`${(n == null ? void 0 : n.apiUrl) ?? this.apiUrl}/runs/${e}`, {
        method: "PATCH",
        headers: a,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: i
      });
      return await re(o, "update run", !0), o;
    });
  }
  async readRun(e, { loadChildRuns: t } = { loadChildRuns: !1 }) {
    ve(e);
    let n = await this._get(`/runs/${e}`);
    return t && (n = await this._loadChildRuns(n)), n;
  }
  async getRunUrl({ runId: e, run: t, projectOpts: n }) {
    if (t !== void 0) {
      let s;
      t.session_id ? s = t.session_id : n != null && n.projectName ? s = (await this.readProject({ projectName: n == null ? void 0 : n.projectName })).id : n != null && n.projectId ? s = n == null ? void 0 : n.projectId : s = (await this.readProject({
        projectName: Nt("PROJECT") || "default"
      })).id;
      const a = await this._getTenantId();
      return `${this.getHostUrl()}/o/${a}/projects/p/${s}/r/${t.id}?poll=true`;
    } else if (e !== void 0) {
      const s = await this.readRun(e);
      if (!s.app_path)
        throw new Error(`Run ${e} has no app_path`);
      return `${this.getHostUrl()}${s.app_path}`;
    } else
      throw new Error("Must provide either runId or run");
  }
  async _loadChildRuns(e) {
    var a;
    const t = await fS(this.listRuns({
      isRoot: !1,
      projectId: e.session_id,
      traceId: e.trace_id
    })), n = {}, s = {};
    t.sort((i, o) => ((i == null ? void 0 : i.dotted_order) ?? "").localeCompare((o == null ? void 0 : o.dotted_order) ?? ""));
    for (const i of t) {
      if (i.parent_run_id === null || i.parent_run_id === void 0)
        throw new Error(`Child run ${i.id} has no parent`);
      (a = i.dotted_order) != null && a.startsWith(e.dotted_order ?? "") && i.id !== e.id && (i.parent_run_id in n || (n[i.parent_run_id] = []), n[i.parent_run_id].push(i), s[i.id] = i);
    }
    e.child_runs = n[e.id] || [];
    for (const i in n)
      i !== e.id && (s[i].child_runs = n[i]);
    return e;
  }
  /**
   * List runs from the LangSmith server.
   * @param projectId - The ID of the project to filter by.
   * @param projectName - The name of the project to filter by.
   * @param parentRunId - The ID of the parent run to filter by.
   * @param traceId - The ID of the trace to filter by.
   * @param referenceExampleId - The ID of the reference example to filter by.
   * @param startTime - The start time to filter by.
   * @param isRoot - Indicates whether to only return root runs.
   * @param runType - The run type to filter by.
   * @param error - Indicates whether to filter by error runs.
   * @param id - The ID of the run to filter by.
   * @param query - The query string to filter by.
   * @param filter - The filter string to apply to the run spans.
   * @param traceFilter - The filter string to apply on the root run of the trace.
   * @param treeFilter - The filter string to apply on other runs in the trace.
   * @param limit - The maximum number of runs to retrieve.
   * @returns {AsyncIterable<Run>} - The runs.
   *
   * @example
   * // List all runs in a project
   * const projectRuns = client.listRuns({ projectName: "<your_project>" });
   *
   * @example
   * // List LLM and Chat runs in the last 24 hours
   * const todaysLLMRuns = client.listRuns({
   *   projectName: "<your_project>",
   *   start_time: new Date(Date.now() - 24 * 60 * 60 * 1000),
   *   run_type: "llm",
   * });
   *
   * @example
   * // List traces in a project
   * const rootRuns = client.listRuns({
   *   projectName: "<your_project>",
   *   execution_order: 1,
   * });
   *
   * @example
   * // List runs without errors
   * const correctRuns = client.listRuns({
   *   projectName: "<your_project>",
   *   error: false,
   * });
   *
   * @example
   * // List runs by run ID
   * const runIds = [
   *   "a36092d2-4ad5-4fb4-9c0d-0dba9a2ed836",
   *   "9398e6be-964f-4aa4-8ae9-ad78cd4b7074",
   * ];
   * const selectedRuns = client.listRuns({ run_ids: runIds });
   *
   * @example
   * // List all "chain" type runs that took more than 10 seconds and had `total_tokens` greater than 5000
   * const chainRuns = client.listRuns({
   *   projectName: "<your_project>",
   *   filter: 'and(eq(run_type, "chain"), gt(latency, 10), gt(total_tokens, 5000))',
   * });
   *
   * @example
   * // List all runs called "extractor" whose root of the trace was assigned feedback "user_score" score of 1
   * const goodExtractorRuns = client.listRuns({
   *   projectName: "<your_project>",
   *   filter: 'eq(name, "extractor")',
   *   traceFilter: 'and(eq(feedback_key, "user_score"), eq(feedback_score, 1))',
   * });
   *
   * @example
   * // List all runs that started after a specific timestamp and either have "error" not equal to null or a "Correctness" feedback score equal to 0
   * const complexRuns = client.listRuns({
   *   projectName: "<your_project>",
   *   filter: 'and(gt(start_time, "2023-07-15T12:34:56Z"), or(neq(error, null), and(eq(feedback_key, "Correctness"), eq(feedback_score, 0.0))))',
   * });
   *
   * @example
   * // List all runs where `tags` include "experimental" or "beta" and `latency` is greater than 2 seconds
   * const taggedRuns = client.listRuns({
   *   projectName: "<your_project>",
   *   filter: 'and(or(has(tags, "experimental"), has(tags, "beta")), gt(latency, 2))',
   * });
   */
  async *listRuns(e) {
    const { projectId: t, projectName: n, parentRunId: s, traceId: a, referenceExampleId: i, startTime: o, executionOrder: c, isRoot: u, runType: l, error: d, id: h, query: f, filter: p, traceFilter: y, treeFilter: m, limit: v, select: g, order: w } = e;
    let T = [];
    if (t && (T = Array.isArray(t) ? t : [t]), n) {
      const E = Array.isArray(n) ? n : [n], V = await Promise.all(E.map((ne) => this.readProject({ projectName: ne }).then((z) => z.id)));
      T.push(...V);
    }
    const x = [
      "app_path",
      "completion_cost",
      "completion_tokens",
      "dotted_order",
      "end_time",
      "error",
      "events",
      "extra",
      "feedback_stats",
      "first_token_time",
      "id",
      "inputs",
      "name",
      "outputs",
      "parent_run_id",
      "parent_run_ids",
      "prompt_cost",
      "prompt_tokens",
      "reference_example_id",
      "run_type",
      "session_id",
      "start_time",
      "status",
      "tags",
      "total_cost",
      "total_tokens",
      "trace_id"
    ], O = {
      session: T.length ? T : null,
      run_type: l,
      reference_example: i,
      query: f,
      filter: p,
      trace_filter: y,
      tree_filter: m,
      execution_order: c,
      parent_run: s,
      start_time: o ? o.toISOString() : null,
      error: d,
      id: h,
      limit: v,
      trace: a,
      select: g || x,
      is_root: u,
      order: w
    };
    O.select.includes("child_run_ids") && Dc("Deprecated: 'child_run_ids' in the listRuns select parameter is deprecated and will be removed in a future version.");
    let R = 0;
    for await (const E of this._getCursorPaginatedList("/runs/query", O))
      if (v) {
        if (R >= v)
          break;
        if (E.length + R > v) {
          yield* E.slice(0, v - R);
          break;
        }
        R += E.length, yield* E;
      } else
        yield* E;
  }
  async *listGroupRuns(e) {
    const { projectId: t, projectName: n, groupBy: s, filter: a, startTime: i, endTime: o, limit: c, offset: u } = e, d = {
      session_id: t || (await this.readProject({ projectName: n })).id,
      group_by: s,
      filter: a,
      start_time: i ? i.toISOString() : null,
      end_time: o ? o.toISOString() : null,
      limit: Number(c) || 100
    };
    let h = Number(u) || 0;
    const f = "/runs/group", p = `${this.apiUrl}${f}`;
    for (; ; ) {
      const y = {
        ...d,
        offset: h
      }, m = Object.fromEntries(Object.entries(y).filter(([O, R]) => R !== void 0)), v = JSON.stringify(m), w = await (await this.caller.call(async () => {
        const O = await this._fetch(p, {
          method: "POST",
          headers: { ...this.headers, "Content-Type": "application/json" },
          signal: AbortSignal.timeout(this.timeout_ms),
          ...this.fetchOptions,
          body: v
        });
        return await re(O, `Failed to fetch ${f}`), O;
      })).json(), { groups: T, total: x } = w;
      if (T.length === 0)
        break;
      for (const O of T)
        yield O;
      if (h += T.length, h >= x)
        break;
    }
  }
  async getRunStats({ id: e, trace: t, parentRun: n, runType: s, projectNames: a, projectIds: i, referenceExampleIds: o, startTime: c, endTime: u, error: l, query: d, filter: h, traceFilter: f, treeFilter: p, isRoot: y, dataSourceType: m }) {
    let v = i || [];
    a && (v = [
      ...i || [],
      ...await Promise.all(a.map((R) => this.readProject({ projectName: R }).then((E) => E.id)))
    ]);
    const w = Object.fromEntries(Object.entries({
      id: e,
      trace: t,
      parent_run: n,
      run_type: s,
      session: v,
      reference_example: o,
      start_time: c,
      end_time: u,
      error: l,
      query: d,
      filter: h,
      trace_filter: f,
      tree_filter: p,
      is_root: y,
      data_source_type: m
    }).filter(([R, E]) => E !== void 0)), T = JSON.stringify(w);
    return await (await this.caller.call(async () => {
      const R = await this._fetch(`${this.apiUrl}/runs/stats`, {
        method: "POST",
        headers: { ...this.headers, "Content-Type": "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: T
      });
      return await re(R, "get run stats"), R;
    })).json();
  }
  async shareRun(e, { shareId: t } = {}) {
    const n = {
      run_id: e,
      share_token: t || ms()
    };
    ve(e);
    const s = JSON.stringify(n), i = await (await this.caller.call(async () => {
      const o = await this._fetch(`${this.apiUrl}/runs/${e}/share`, {
        method: "PUT",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: s
      });
      return await re(o, "share run"), o;
    })).json();
    if (i === null || !("share_token" in i))
      throw new Error("Invalid response from server");
    return `${this.getHostUrl()}/public/${i.share_token}/r`;
  }
  async unshareRun(e) {
    ve(e), await this.caller.call(async () => {
      const t = await this._fetch(`${this.apiUrl}/runs/${e}/share`, {
        method: "DELETE",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      return await re(t, "unshare run", !0), t;
    });
  }
  async readRunSharedLink(e) {
    ve(e);
    const n = await (await this.caller.call(async () => {
      const s = await this._fetch(`${this.apiUrl}/runs/${e}/share`, {
        method: "GET",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      return await re(s, "read run shared link"), s;
    })).json();
    if (!(n === null || !("share_token" in n)))
      return `${this.getHostUrl()}/public/${n.share_token}/r`;
  }
  async listSharedRuns(e, { runIds: t } = {}) {
    const n = new URLSearchParams({
      share_token: e
    });
    if (t !== void 0)
      for (const i of t)
        n.append("id", i);
    return ve(e), await (await this.caller.call(async () => {
      const i = await this._fetch(`${this.apiUrl}/public/${e}/runs${n}`, {
        method: "GET",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      return await re(i, "list shared runs"), i;
    })).json();
  }
  async readDatasetSharedSchema(e, t) {
    if (!e && !t)
      throw new Error("Either datasetId or datasetName must be given");
    e || (e = (await this.readDataset({ datasetName: t })).id), ve(e);
    const s = await (await this.caller.call(async () => {
      const a = await this._fetch(`${this.apiUrl}/datasets/${e}/share`, {
        method: "GET",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      return await re(a, "read dataset shared schema"), a;
    })).json();
    return s.url = `${this.getHostUrl()}/public/${s.share_token}/d`, s;
  }
  async shareDataset(e, t) {
    if (!e && !t)
      throw new Error("Either datasetId or datasetName must be given");
    e || (e = (await this.readDataset({ datasetName: t })).id);
    const n = {
      dataset_id: e
    };
    ve(e);
    const s = JSON.stringify(n), i = await (await this.caller.call(async () => {
      const o = await this._fetch(`${this.apiUrl}/datasets/${e}/share`, {
        method: "PUT",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: s
      });
      return await re(o, "share dataset"), o;
    })).json();
    return i.url = `${this.getHostUrl()}/public/${i.share_token}/d`, i;
  }
  async unshareDataset(e) {
    ve(e), await this.caller.call(async () => {
      const t = await this._fetch(`${this.apiUrl}/datasets/${e}/share`, {
        method: "DELETE",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      return await re(t, "unshare dataset", !0), t;
    });
  }
  async readSharedDataset(e) {
    return ve(e), await (await this.caller.call(async () => {
      const s = await this._fetch(`${this.apiUrl}/public/${e}/datasets`, {
        method: "GET",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      return await re(s, "read shared dataset"), s;
    })).json();
  }
  /**
   * Get shared examples.
   *
   * @param {string} shareToken The share token to get examples for. A share token is the UUID (or LangSmith URL, including UUID) generated when explicitly marking an example as public.
   * @param {Object} [options] Additional options for listing the examples.
   * @param {string[] | undefined} [options.exampleIds] A list of example IDs to filter by.
   * @returns {Promise<Example[]>} The shared examples.
   */
  async listSharedExamples(e, t) {
    const n = {};
    t != null && t.exampleIds && (n.id = t.exampleIds);
    const s = new URLSearchParams();
    Object.entries(n).forEach(([o, c]) => {
      Array.isArray(c) ? c.forEach((u) => s.append(o, u)) : s.append(o, c);
    });
    const a = await this.caller.call(async () => {
      const o = await this._fetch(`${this.apiUrl}/public/${e}/examples?${s.toString()}`, {
        method: "GET",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      return await re(o, "list shared examples"), o;
    }), i = await a.json();
    if (!a.ok)
      throw "detail" in i ? new Error(`Failed to list shared examples.
Status: ${a.status}
Message: ${Array.isArray(i.detail) ? i.detail.join(`
`) : "Unspecified error"}`) : new Error(`Failed to list shared examples: ${a.status} ${a.statusText}`);
    return i.map((o) => ({
      ...o,
      _hostUrl: this.getHostUrl()
    }));
  }
  async createProject({ projectName: e, description: t = null, metadata: n = null, upsert: s = !1, projectExtra: a = null, referenceDatasetId: i = null }) {
    const o = s ? "?upsert=true" : "", c = `${this.apiUrl}/sessions${o}`, u = a || {};
    n && (u.metadata = n);
    const l = {
      name: e,
      extra: u,
      description: t
    };
    i !== null && (l.reference_dataset_id = i);
    const d = JSON.stringify(l);
    return await (await this.caller.call(async () => {
      const p = await this._fetch(c, {
        method: "POST",
        headers: { ...this.headers, "Content-Type": "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: d
      });
      return await re(p, "create project"), p;
    })).json();
  }
  async updateProject(e, { name: t = null, description: n = null, metadata: s = null, projectExtra: a = null, endTime: i = null }) {
    const o = `${this.apiUrl}/sessions/${e}`;
    let c = a;
    s && (c = { ...c || {}, metadata: s });
    const u = JSON.stringify({
      name: t,
      extra: c,
      description: n,
      end_time: i ? new Date(i).toISOString() : null
    });
    return await (await this.caller.call(async () => {
      const h = await this._fetch(o, {
        method: "PATCH",
        headers: { ...this.headers, "Content-Type": "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: u
      });
      return await re(h, "update project"), h;
    })).json();
  }
  async hasProject({ projectId: e, projectName: t }) {
    let n = "/sessions";
    const s = new URLSearchParams();
    if (e !== void 0 && t !== void 0)
      throw new Error("Must provide either projectName or projectId, not both");
    if (e !== void 0)
      ve(e), n += `/${e}`;
    else if (t !== void 0)
      s.append("name", t);
    else
      throw new Error("Must provide projectName or projectId");
    const a = await this.caller.call(async () => {
      const i = await this._fetch(`${this.apiUrl}${n}?${s}`, {
        method: "GET",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      return await re(i, "has project"), i;
    });
    try {
      const i = await a.json();
      return a.ok ? Array.isArray(i) ? i.length > 0 : !0 : !1;
    } catch {
      return !1;
    }
  }
  async readProject({ projectId: e, projectName: t, includeStats: n }) {
    let s = "/sessions";
    const a = new URLSearchParams();
    if (e !== void 0 && t !== void 0)
      throw new Error("Must provide either projectName or projectId, not both");
    if (e !== void 0)
      ve(e), s += `/${e}`;
    else if (t !== void 0)
      a.append("name", t);
    else
      throw new Error("Must provide projectName or projectId");
    n !== void 0 && a.append("include_stats", n.toString());
    const i = await this._get(s, a);
    let o;
    if (Array.isArray(i)) {
      if (i.length === 0)
        throw new Error(`Project[id=${e}, name=${t}] not found`);
      o = i[0];
    } else
      o = i;
    return o;
  }
  async getProjectUrl({ projectId: e, projectName: t }) {
    if (e === void 0 && t === void 0)
      throw new Error("Must provide either projectName or projectId");
    const n = await this.readProject({ projectId: e, projectName: t }), s = await this._getTenantId();
    return `${this.getHostUrl()}/o/${s}/projects/p/${n.id}`;
  }
  async getDatasetUrl({ datasetId: e, datasetName: t }) {
    if (e === void 0 && t === void 0)
      throw new Error("Must provide either datasetName or datasetId");
    const n = await this.readDataset({ datasetId: e, datasetName: t }), s = await this._getTenantId();
    return `${this.getHostUrl()}/o/${s}/datasets/${n.id}`;
  }
  async _getTenantId() {
    if (this._tenantId !== null)
      return this._tenantId;
    const e = new URLSearchParams({ limit: "1" });
    for await (const t of this._getPaginated("/sessions", e))
      return this._tenantId = t[0].tenant_id, t[0].tenant_id;
    throw new Error("No projects found to resolve tenant.");
  }
  async *listProjects({ projectIds: e, name: t, nameContains: n, referenceDatasetId: s, referenceDatasetName: a, includeStats: i, datasetVersion: o, referenceFree: c, metadata: u } = {}) {
    const l = new URLSearchParams();
    if (e !== void 0)
      for (const d of e)
        l.append("id", d);
    if (t !== void 0 && l.append("name", t), n !== void 0 && l.append("name_contains", n), s !== void 0)
      l.append("reference_dataset", s);
    else if (a !== void 0) {
      const d = await this.readDataset({
        datasetName: a
      });
      l.append("reference_dataset", d.id);
    }
    i !== void 0 && l.append("include_stats", i.toString()), o !== void 0 && l.append("dataset_version", o), c !== void 0 && l.append("reference_free", c.toString()), u !== void 0 && l.append("metadata", JSON.stringify(u));
    for await (const d of this._getPaginated("/sessions", l))
      yield* d;
  }
  async deleteProject({ projectId: e, projectName: t }) {
    let n;
    if (e === void 0 && t === void 0)
      throw new Error("Must provide projectName or projectId");
    if (e !== void 0 && t !== void 0)
      throw new Error("Must provide either projectName or projectId, not both");
    e === void 0 ? n = (await this.readProject({ projectName: t })).id : n = e, ve(n), await this.caller.call(async () => {
      const s = await this._fetch(`${this.apiUrl}/sessions/${n}`, {
        method: "DELETE",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      return await re(s, `delete session ${n} (${t})`, !0), s;
    });
  }
  async uploadCsv({ csvFile: e, fileName: t, inputKeys: n, outputKeys: s, description: a, dataType: i, name: o }) {
    const c = `${this.apiUrl}/datasets/upload`, u = new FormData();
    return u.append("file", e, t), n.forEach((h) => {
      u.append("input_keys", h);
    }), s.forEach((h) => {
      u.append("output_keys", h);
    }), a && u.append("description", a), i && u.append("data_type", i), o && u.append("name", o), await (await this.caller.call(async () => {
      const h = await this._fetch(c, {
        method: "POST",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: u
      });
      return await re(h, "upload CSV"), h;
    })).json();
  }
  async createDataset(e, { description: t, dataType: n, inputsSchema: s, outputsSchema: a, metadata: i } = {}) {
    const o = {
      name: e,
      description: t,
      extra: i ? { metadata: i } : void 0
    };
    n && (o.data_type = n), s && (o.inputs_schema_definition = s), a && (o.outputs_schema_definition = a);
    const c = JSON.stringify(o);
    return await (await this.caller.call(async () => {
      const d = await this._fetch(`${this.apiUrl}/datasets`, {
        method: "POST",
        headers: { ...this.headers, "Content-Type": "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: c
      });
      return await re(d, "create dataset"), d;
    })).json();
  }
  async readDataset({ datasetId: e, datasetName: t }) {
    let n = "/datasets";
    const s = new URLSearchParams({ limit: "1" });
    if (e && t)
      throw new Error("Must provide either datasetName or datasetId, not both");
    if (e)
      ve(e), n += `/${e}`;
    else if (t)
      s.append("name", t);
    else
      throw new Error("Must provide datasetName or datasetId");
    const a = await this._get(n, s);
    let i;
    if (Array.isArray(a)) {
      if (a.length === 0)
        throw new Error(`Dataset[id=${e}, name=${t}] not found`);
      i = a[0];
    } else
      i = a;
    return i;
  }
  async hasDataset({ datasetId: e, datasetName: t }) {
    try {
      return await this.readDataset({ datasetId: e, datasetName: t }), !0;
    } catch (n) {
      if (
        // eslint-disable-next-line no-instanceof/no-instanceof
        n instanceof Error && n.message.toLocaleLowerCase().includes("not found")
      )
        return !1;
      throw n;
    }
  }
  async diffDatasetVersions({ datasetId: e, datasetName: t, fromVersion: n, toVersion: s }) {
    let a = e;
    if (a === void 0 && t === void 0)
      throw new Error("Must provide either datasetName or datasetId");
    if (a !== void 0 && t !== void 0)
      throw new Error("Must provide either datasetName or datasetId, not both");
    a === void 0 && (a = (await this.readDataset({ datasetName: t })).id);
    const i = new URLSearchParams({
      from_version: typeof n == "string" ? n : n.toISOString(),
      to_version: typeof s == "string" ? s : s.toISOString()
    });
    return await this._get(`/datasets/${a}/versions/diff`, i);
  }
  async readDatasetOpenaiFinetuning({ datasetId: e, datasetName: t }) {
    const n = "/datasets";
    if (e === void 0) if (t !== void 0)
      e = (await this.readDataset({ datasetName: t })).id;
    else
      throw new Error("Must provide either datasetName or datasetId");
    return (await (await this._getResponse(`${n}/${e}/openai_ft`)).text()).trim().split(`
`).map((o) => JSON.parse(o));
  }
  async *listDatasets({ limit: e = 100, offset: t = 0, datasetIds: n, datasetName: s, datasetNameContains: a, metadata: i } = {}) {
    const o = "/datasets", c = new URLSearchParams({
      limit: e.toString(),
      offset: t.toString()
    });
    if (n !== void 0)
      for (const u of n)
        c.append("id", u);
    s !== void 0 && c.append("name", s), a !== void 0 && c.append("name_contains", a), i !== void 0 && c.append("metadata", JSON.stringify(i));
    for await (const u of this._getPaginated(o, c))
      yield* u;
  }
  /**
   * Update a dataset
   * @param props The dataset details to update
   * @returns The updated dataset
   */
  async updateDataset(e) {
    const { datasetId: t, datasetName: n, ...s } = e;
    if (!t && !n)
      throw new Error("Must provide either datasetName or datasetId");
    const a = t ?? (await this.readDataset({ datasetName: n })).id;
    ve(a);
    const i = JSON.stringify(s);
    return await (await this.caller.call(async () => {
      const c = await this._fetch(`${this.apiUrl}/datasets/${a}`, {
        method: "PATCH",
        headers: { ...this.headers, "Content-Type": "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: i
      });
      return await re(c, "update dataset"), c;
    })).json();
  }
  /**
   * Updates a tag on a dataset.
   *
   * If the tag is already assigned to a different version of this dataset,
   * the tag will be moved to the new version. The as_of parameter is used to
   * determine which version of the dataset to apply the new tags to.
   *
   * It must be an exact version of the dataset to succeed. You can
   * use the "readDatasetVersion" method to find the exact version
   * to apply the tags to.
   * @param params.datasetId The ID of the dataset to update. Must be provided if "datasetName" is not provided.
   * @param params.datasetName The name of the dataset to update. Must be provided if "datasetId" is not provided.
   * @param params.asOf The timestamp of the dataset to apply the new tags to.
   * @param params.tag The new tag to apply to the dataset.
   */
  async updateDatasetTag(e) {
    const { datasetId: t, datasetName: n, asOf: s, tag: a } = e;
    if (!t && !n)
      throw new Error("Must provide either datasetName or datasetId");
    const i = t ?? (await this.readDataset({ datasetName: n })).id;
    ve(i);
    const o = JSON.stringify({
      as_of: typeof s == "string" ? s : s.toISOString(),
      tag: a
    });
    await this.caller.call(async () => {
      const c = await this._fetch(`${this.apiUrl}/datasets/${i}/tags`, {
        method: "PUT",
        headers: { ...this.headers, "Content-Type": "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: o
      });
      return await re(c, "update dataset tags", !0), c;
    });
  }
  async deleteDataset({ datasetId: e, datasetName: t }) {
    let n = "/datasets", s = e;
    if (e !== void 0 && t !== void 0)
      throw new Error("Must provide either datasetName or datasetId, not both");
    if (t !== void 0 && (s = (await this.readDataset({ datasetName: t })).id), s !== void 0)
      ve(s), n += `/${s}`;
    else
      throw new Error("Must provide datasetName or datasetId");
    await this.caller.call(async () => {
      const a = await this._fetch(this.apiUrl + n, {
        method: "DELETE",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      return await re(a, `delete ${n}`, !0), a;
    });
  }
  async indexDataset({ datasetId: e, datasetName: t, tag: n }) {
    let s = e;
    if (!s && !t)
      throw new Error("Must provide either datasetName or datasetId");
    if (s && t)
      throw new Error("Must provide either datasetName or datasetId, not both");
    s || (s = (await this.readDataset({ datasetName: t })).id), ve(s);
    const i = JSON.stringify({
      tag: n
    });
    await (await this.caller.call(async () => {
      const c = await this._fetch(`${this.apiUrl}/datasets/${s}/index`, {
        method: "POST",
        headers: { ...this.headers, "Content-Type": "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: i
      });
      return await re(c, "index dataset"), c;
    })).json();
  }
  /**
   * Lets you run a similarity search query on a dataset.
   *
   * Requires the dataset to be indexed. Please see the `indexDataset` method to set up indexing.
   *
   * @param inputs      The input on which to run the similarity search. Must have the
   *                    same schema as the dataset.
   *
   * @param datasetId   The dataset to search for similar examples.
   *
   * @param limit       The maximum number of examples to return. Will return the top `limit` most
   *                    similar examples in order of most similar to least similar. If no similar
   *                    examples are found, random examples will be returned.
   *
   * @param filter      A filter string to apply to the search. Only examples will be returned that
   *                    match the filter string. Some examples of filters
   *
   *                    - eq(metadata.mykey, "value")
   *                    - and(neq(metadata.my.nested.key, "value"), neq(metadata.mykey, "value"))
   *                    - or(eq(metadata.mykey, "value"), eq(metadata.mykey, "othervalue"))
   *
   * @returns           A list of similar examples.
   *
   *
   * @example
   * dataset_id = "123e4567-e89b-12d3-a456-426614174000"
   * inputs = {"text": "How many people live in Berlin?"}
   * limit = 5
   * examples = await client.similarExamples(inputs, dataset_id, limit)
   */
  async similarExamples(e, t, n, { filter: s } = {}) {
    const a = {
      limit: n,
      inputs: e
    };
    s !== void 0 && (a.filter = s), ve(t);
    const i = JSON.stringify(a);
    return (await (await this.caller.call(async () => {
      const u = await this._fetch(`${this.apiUrl}/datasets/${t}/search`, {
        headers: { ...this.headers, "Content-Type": "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        method: "POST",
        body: i
      });
      return await re(u, "fetch similar examples"), u;
    })).json()).examples;
  }
  async createExample(e, t, n) {
    var l;
    if (ah(e) && (t !== void 0 || n !== void 0))
      throw new Error("Cannot provide outputs or options when using ExampleCreate object");
    let s = t ? n == null ? void 0 : n.datasetId : e.dataset_id;
    const a = t ? n == null ? void 0 : n.datasetName : e.dataset_name;
    if (s === void 0 && a === void 0)
      throw new Error("Must provide either datasetName or datasetId");
    if (s !== void 0 && a !== void 0)
      throw new Error("Must provide either datasetName or datasetId, not both");
    s === void 0 && (s = (await this.readDataset({ datasetName: a })).id);
    const i = (t ? n == null ? void 0 : n.createdAt : e.created_at) || /* @__PURE__ */ new Date();
    let o;
    ah(e) ? o = e : o = {
      inputs: e,
      outputs: t,
      created_at: i == null ? void 0 : i.toISOString(),
      id: n == null ? void 0 : n.exampleId,
      metadata: n == null ? void 0 : n.metadata,
      split: n == null ? void 0 : n.split,
      source_run_id: n == null ? void 0 : n.sourceRunId,
      use_source_run_io: n == null ? void 0 : n.useSourceRunIO,
      use_source_run_attachments: n == null ? void 0 : n.useSourceRunAttachments,
      attachments: n == null ? void 0 : n.attachments
    };
    const c = await this._uploadExamplesMultipart(s, [o]);
    return await this.readExample(((l = c.example_ids) == null ? void 0 : l[0]) ?? ms());
  }
  async createExamples(e) {
    if (Array.isArray(e)) {
      if (e.length === 0)
        return [];
      const g = e;
      let w = g[0].dataset_id;
      const T = g[0].dataset_name;
      if (w === void 0 && T === void 0)
        throw new Error("Must provide either datasetName or datasetId");
      if (w !== void 0 && T !== void 0)
        throw new Error("Must provide either datasetName or datasetId, not both");
      w === void 0 && (w = (await this.readDataset({ datasetName: T })).id);
      const x = await this._uploadExamplesMultipart(w, g);
      return await Promise.all(x.example_ids.map((R) => this.readExample(R)));
    }
    const { inputs: t, outputs: n, metadata: s, splits: a, sourceRunIds: i, useSourceRunIOs: o, useSourceRunAttachments: c, attachments: u, exampleIds: l, datasetId: d, datasetName: h } = e;
    if (t === void 0)
      throw new Error("Must provide inputs when using legacy parameters");
    let f = d;
    const p = h;
    if (f === void 0 && p === void 0)
      throw new Error("Must provide either datasetName or datasetId");
    if (f !== void 0 && p !== void 0)
      throw new Error("Must provide either datasetName or datasetId, not both");
    f === void 0 && (f = (await this.readDataset({ datasetName: p })).id);
    const y = t.map((g, w) => ({
      dataset_id: f,
      inputs: g,
      outputs: n == null ? void 0 : n[w],
      metadata: s == null ? void 0 : s[w],
      split: a == null ? void 0 : a[w],
      id: l == null ? void 0 : l[w],
      attachments: u == null ? void 0 : u[w],
      source_run_id: i == null ? void 0 : i[w],
      use_source_run_io: o == null ? void 0 : o[w],
      use_source_run_attachments: c == null ? void 0 : c[w]
    })), m = await this._uploadExamplesMultipart(f, y);
    return await Promise.all(m.example_ids.map((g) => this.readExample(g)));
  }
  async createLLMExample(e, t, n) {
    return this.createExample({ input: e }, { output: t }, n);
  }
  async createChatExample(e, t, n) {
    const s = e.map((i) => Jd(i) ? Hd(i) : i), a = Jd(t) ? Hd(t) : t;
    return this.createExample({ input: s }, { output: a }, n);
  }
  async readExample(e) {
    ve(e);
    const t = `/examples/${e}`, n = await this._get(t), { attachment_urls: s, ...a } = n, i = a;
    return s && (i.attachments = Object.entries(s).reduce((o, [c, u]) => (o[c.slice(11)] = {
      presigned_url: u.presigned_url,
      mime_type: u.mime_type
    }, o), {})), i;
  }
  async *listExamples({ datasetId: e, datasetName: t, exampleIds: n, asOf: s, splits: a, inlineS3Urls: i, metadata: o, limit: c, offset: u, filter: l, includeAttachments: d } = {}) {
    let h;
    if (e !== void 0 && t !== void 0)
      throw new Error("Must provide either datasetName or datasetId, not both");
    if (e !== void 0)
      h = e;
    else if (t !== void 0)
      h = (await this.readDataset({ datasetName: t })).id;
    else
      throw new Error("Must provide a datasetName or datasetId");
    const f = new URLSearchParams({ dataset: h }), p = s ? typeof s == "string" ? s : s == null ? void 0 : s.toISOString() : void 0;
    p && f.append("as_of", p);
    const y = i ?? !0;
    if (f.append("inline_s3_urls", y.toString()), n !== void 0)
      for (const v of n)
        f.append("id", v);
    if (a !== void 0)
      for (const v of a)
        f.append("splits", v);
    if (o !== void 0) {
      const v = JSON.stringify(o);
      f.append("metadata", v);
    }
    c !== void 0 && f.append("limit", c.toString()), u !== void 0 && f.append("offset", u.toString()), l !== void 0 && f.append("filter", l), d === !0 && ["attachment_urls", "outputs", "metadata"].forEach((v) => f.append("select", v));
    let m = 0;
    for await (const v of this._getPaginated("/examples", f)) {
      for (const g of v) {
        const { attachment_urls: w, ...T } = g, x = T;
        w && (x.attachments = Object.entries(w).reduce((O, [R, E]) => (O[R.slice(11)] = {
          presigned_url: E.presigned_url,
          mime_type: E.mime_type || void 0
        }, O), {})), yield x, m++;
      }
      if (c !== void 0 && m >= c)
        break;
    }
  }
  async deleteExample(e) {
    ve(e);
    const t = `/examples/${e}`;
    await this.caller.call(async () => {
      const n = await this._fetch(this.apiUrl + t, {
        method: "DELETE",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      return await re(n, `delete ${t}`, !0), n;
    });
  }
  /**
   * Delete multiple examples by ID.
   * @param exampleIds - The IDs of the examples to delete
   * @param options - Optional settings for deletion
   * @param options.hardDelete - If true, permanently delete examples. If false (default), soft delete them.
   */
  async deleteExamples(e, t) {
    if (e.forEach((n) => ve(n)), t != null && t.hardDelete) {
      const n = this._getPlatformEndpointPath("datasets/examples/delete");
      await this.caller.call(async () => {
        const s = await this._fetch(`${this.apiUrl}${n}`, {
          method: "POST",
          headers: { ...this.headers, "Content-Type": "application/json" },
          body: JSON.stringify({
            example_ids: e,
            hard_delete: !0
          }),
          signal: AbortSignal.timeout(this.timeout_ms),
          ...this.fetchOptions
        });
        return await re(s, "hard delete examples", !0), s;
      });
    } else {
      const n = new URLSearchParams();
      e.forEach((s) => n.append("example_ids", s)), await this.caller.call(async () => {
        const s = await this._fetch(`${this.apiUrl}/examples?${n.toString()}`, {
          method: "DELETE",
          headers: this.headers,
          signal: AbortSignal.timeout(this.timeout_ms),
          ...this.fetchOptions
        });
        return await re(s, "delete examples", !0), s;
      });
    }
  }
  async updateExample(e, t) {
    let n;
    t ? n = e : n = e.id, ve(n);
    let s;
    t ? s = { id: n, ...t } : s = e;
    let a;
    return s.dataset_id !== void 0 ? a = s.dataset_id : a = (await this.readExample(n)).dataset_id, this._updateExamplesMultipart(a, [s]);
  }
  async updateExamples(e) {
    let t;
    return e[0].dataset_id === void 0 ? t = (await this.readExample(e[0].id)).dataset_id : t = e[0].dataset_id, this._updateExamplesMultipart(t, e);
  }
  /**
   * Get dataset version by closest date or exact tag.
   *
   * Use this to resolve the nearest version to a given timestamp or for a given tag.
   *
   * @param options The options for getting the dataset version
   * @param options.datasetId The ID of the dataset
   * @param options.datasetName The name of the dataset
   * @param options.asOf The timestamp of the dataset to retrieve
   * @param options.tag The tag of the dataset to retrieve
   * @returns The dataset version
   */
  async readDatasetVersion({ datasetId: e, datasetName: t, asOf: n, tag: s }) {
    let a;
    if (e ? a = e : a = (await this.readDataset({ datasetName: t })).id, ve(a), n && s || !n && !s)
      throw new Error("Exactly one of asOf and tag must be specified.");
    const i = new URLSearchParams();
    return n !== void 0 && i.append("as_of", typeof n == "string" ? n : n.toISOString()), s !== void 0 && i.append("tag", s), await (await this.caller.call(async () => {
      const c = await this._fetch(`${this.apiUrl}/datasets/${a}/version?${i.toString()}`, {
        method: "GET",
        headers: { ...this.headers },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      return await re(c, "read dataset version"), c;
    })).json();
  }
  async listDatasetSplits({ datasetId: e, datasetName: t, asOf: n }) {
    let s;
    if (e === void 0 && t === void 0)
      throw new Error("Must provide dataset name or ID");
    if (e !== void 0 && t !== void 0)
      throw new Error("Must provide either datasetName or datasetId, not both");
    e === void 0 ? s = (await this.readDataset({ datasetName: t })).id : s = e, ve(s);
    const a = new URLSearchParams(), i = n ? typeof n == "string" ? n : n == null ? void 0 : n.toISOString() : void 0;
    return i && a.append("as_of", i), await this._get(`/datasets/${s}/splits`, a);
  }
  async updateDatasetSplits({ datasetId: e, datasetName: t, splitName: n, exampleIds: s, remove: a = !1 }) {
    let i;
    if (e === void 0 && t === void 0)
      throw new Error("Must provide dataset name or ID");
    if (e !== void 0 && t !== void 0)
      throw new Error("Must provide either datasetName or datasetId, not both");
    e === void 0 ? i = (await this.readDataset({ datasetName: t })).id : i = e, ve(i);
    const o = {
      split_name: n,
      examples: s.map((u) => (ve(u), u)),
      remove: a
    }, c = JSON.stringify(o);
    await this.caller.call(async () => {
      const u = await this._fetch(`${this.apiUrl}/datasets/${i}/splits`, {
        method: "PUT",
        headers: { ...this.headers, "Content-Type": "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: c
      });
      return await re(u, "update dataset splits", !0), u;
    });
  }
  /**
   * @deprecated This method is deprecated and will be removed in future LangSmith versions, use `evaluate` from `langsmith/evaluation` instead.
   */
  async evaluateRun(e, t, { sourceInfo: n, loadChildRuns: s, referenceExample: a } = { loadChildRuns: !1 }) {
    Dc("This method is deprecated and will be removed in future LangSmith versions, use `evaluate` from `langsmith/evaluation` instead.");
    let i;
    if (typeof e == "string")
      i = await this.readRun(e, { loadChildRuns: s });
    else if (typeof e == "object" && "id" in e)
      i = e;
    else
      throw new Error(`Invalid run type: ${typeof e}`);
    i.reference_example_id !== null && i.reference_example_id !== void 0 && (a = await this.readExample(i.reference_example_id));
    const o = await t.evaluateRun(i, a), [c, u] = await this._logEvaluationFeedback(o, i, n);
    return u[0];
  }
  async createFeedback(e, t, { score: n, value: s, correction: a, comment: i, sourceInfo: o, feedbackSourceType: c = "api", sourceRunId: u, feedbackId: l, feedbackConfig: d, projectId: h, comparativeExperimentId: f }) {
    var g;
    if (!e && !h)
      throw new Error("One of runId or projectId must be provided");
    if (e && h)
      throw new Error("Only one of runId or projectId can be provided");
    const p = {
      type: c ?? "api",
      metadata: o ?? {}
    };
    u !== void 0 && (p == null ? void 0 : p.metadata) !== void 0 && !p.metadata.__run && (p.metadata.__run = { run_id: u }), (p == null ? void 0 : p.metadata) !== void 0 && ((g = p.metadata.__run) == null ? void 0 : g.run_id) !== void 0 && ve(p.metadata.__run.run_id);
    const y = {
      id: l ?? ms(),
      run_id: e,
      key: t,
      score: nh(n),
      value: s,
      correction: a,
      comment: i,
      feedback_source: p,
      comparative_experiment_id: f,
      feedbackConfig: d,
      session_id: h
    }, m = JSON.stringify(y), v = `${this.apiUrl}/feedback`;
    return await this.caller.call(async () => {
      const w = await this._fetch(v, {
        method: "POST",
        headers: { ...this.headers, "Content-Type": "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: m
      });
      return await re(w, "create feedback", !0), w;
    }), y;
  }
  async updateFeedback(e, { score: t, value: n, correction: s, comment: a }) {
    const i = {};
    t != null && (i.score = nh(t)), n != null && (i.value = n), s != null && (i.correction = s), a != null && (i.comment = a), ve(e);
    const o = JSON.stringify(i);
    await this.caller.call(async () => {
      const c = await this._fetch(`${this.apiUrl}/feedback/${e}`, {
        method: "PATCH",
        headers: { ...this.headers, "Content-Type": "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: o
      });
      return await re(c, "update feedback", !0), c;
    });
  }
  async readFeedback(e) {
    ve(e);
    const t = `/feedback/${e}`;
    return await this._get(t);
  }
  async deleteFeedback(e) {
    ve(e);
    const t = `/feedback/${e}`;
    await this.caller.call(async () => {
      const n = await this._fetch(this.apiUrl + t, {
        method: "DELETE",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      return await re(n, `delete ${t}`, !0), n;
    });
  }
  async *listFeedback({ runIds: e, feedbackKeys: t, feedbackSourceTypes: n } = {}) {
    const s = new URLSearchParams();
    if (e)
      for (const a of e)
        ve(a), s.append("run", a);
    if (t)
      for (const a of t)
        s.append("key", a);
    if (n)
      for (const a of n)
        s.append("source", a);
    for await (const a of this._getPaginated("/feedback", s))
      yield* a;
  }
  /**
   * Creates a presigned feedback token and URL.
   *
   * The token can be used to authorize feedback metrics without
   * needing an API key. This is useful for giving browser-based
   * applications the ability to submit feedback without needing
   * to expose an API key.
   *
   * @param runId The ID of the run.
   * @param feedbackKey The feedback key.
   * @param options Additional options for the token.
   * @param options.expiration The expiration time for the token.
   *
   * @returns A promise that resolves to a FeedbackIngestToken.
   */
  async createPresignedFeedbackToken(e, t, { expiration: n, feedbackConfig: s } = {}) {
    const a = {
      run_id: e,
      feedback_key: t,
      feedback_config: s
    };
    n ? typeof n == "string" ? a.expires_at = n : (n != null && n.hours || n != null && n.minutes || n != null && n.days) && (a.expires_in = n) : a.expires_in = {
      hours: 3
    };
    const i = JSON.stringify(a);
    return await (await this.caller.call(async () => {
      const c = await this._fetch(`${this.apiUrl}/feedback/tokens`, {
        method: "POST",
        headers: { ...this.headers, "Content-Type": "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: i
      });
      return await re(c, "create presigned feedback token"), c;
    })).json();
  }
  async createComparativeExperiment({ name: e, experimentIds: t, referenceDatasetId: n, createdAt: s, description: a, metadata: i, id: o }) {
    var d;
    if (t.length === 0)
      throw new Error("At least one experiment is required");
    if (n || (n = (await this.readProject({
      projectId: t[0]
    })).reference_dataset_id), !n == null)
      throw new Error("A reference dataset is required");
    const c = {
      id: o,
      name: e,
      experiment_ids: t,
      reference_dataset_id: n,
      description: a,
      created_at: (d = s ?? /* @__PURE__ */ new Date()) == null ? void 0 : d.toISOString(),
      extra: {}
    };
    i && (c.extra.metadata = i);
    const u = JSON.stringify(c);
    return (await this.caller.call(async () => {
      const h = await this._fetch(`${this.apiUrl}/datasets/comparative`, {
        method: "POST",
        headers: { ...this.headers, "Content-Type": "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: u
      });
      return await re(h, "create comparative experiment"), h;
    })).json();
  }
  /**
   * Retrieves a list of presigned feedback tokens for a given run ID.
   * @param runId The ID of the run.
   * @returns An async iterable of FeedbackIngestToken objects.
   */
  async *listPresignedFeedbackTokens(e) {
    ve(e);
    const t = new URLSearchParams({ run_id: e });
    for await (const n of this._getPaginated("/feedback/tokens", t))
      yield* n;
  }
  _selectEvalResults(e) {
    let t;
    return "results" in e ? t = e.results : Array.isArray(e) ? t = e : t = [e], t;
  }
  async _logEvaluationFeedback(e, t, n) {
    const s = this._selectEvalResults(e), a = [];
    for (const i of s) {
      let o = n || {};
      i.evaluatorInfo && (o = { ...i.evaluatorInfo, ...o });
      let c = null;
      i.targetRunId ? c = i.targetRunId : t && (c = t.id), a.push(await this.createFeedback(c, i.key, {
        score: i.score,
        value: i.value,
        comment: i.comment,
        correction: i.correction,
        sourceInfo: o,
        sourceRunId: i.sourceRunId,
        feedbackConfig: i.feedbackConfig,
        feedbackSourceType: "model"
      }));
    }
    return [s, a];
  }
  async logEvaluationFeedback(e, t, n) {
    const [s] = await this._logEvaluationFeedback(e, t, n);
    return s;
  }
  /**
   * API for managing annotation queues
   */
  /**
   * List the annotation queues on the LangSmith API.
   * @param options - The options for listing annotation queues
   * @param options.queueIds - The IDs of the queues to filter by
   * @param options.name - The name of the queue to filter by
   * @param options.nameContains - The substring that the queue name should contain
   * @param options.limit - The maximum number of queues to return
   * @returns An iterator of AnnotationQueue objects
   */
  async *listAnnotationQueues(e = {}) {
    const { queueIds: t, name: n, nameContains: s, limit: a } = e, i = new URLSearchParams();
    t && t.forEach((c, u) => {
      ve(c, `queueIds[${u}]`), i.append("ids", c);
    }), n && i.append("name", n), s && i.append("name_contains", s), i.append("limit", (a !== void 0 ? Math.min(a, 100) : 100).toString());
    let o = 0;
    for await (const c of this._getPaginated("/annotation-queues", i))
      if (yield* c, o++, a !== void 0 && o >= a)
        break;
  }
  /**
   * Create an annotation queue on the LangSmith API.
   * @param options - The options for creating an annotation queue
   * @param options.name - The name of the annotation queue
   * @param options.description - The description of the annotation queue
   * @param options.queueId - The ID of the annotation queue
   * @returns The created AnnotationQueue object
   */
  async createAnnotationQueue(e) {
    const { name: t, description: n, queueId: s, rubricInstructions: a } = e, i = {
      name: t,
      description: n,
      id: s || ms(),
      rubric_instructions: a
    }, o = JSON.stringify(Object.fromEntries(Object.entries(i).filter(([u, l]) => l !== void 0)));
    return (await this.caller.call(async () => {
      const u = await this._fetch(`${this.apiUrl}/annotation-queues`, {
        method: "POST",
        headers: { ...this.headers, "Content-Type": "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: o
      });
      return await re(u, "create annotation queue"), u;
    })).json();
  }
  /**
   * Read an annotation queue with the specified queue ID.
   * @param queueId - The ID of the annotation queue to read
   * @returns The AnnotationQueueWithDetails object
   */
  async readAnnotationQueue(e) {
    return (await this.caller.call(async () => {
      const n = await this._fetch(`${this.apiUrl}/annotation-queues/${ve(e, "queueId")}`, {
        method: "GET",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      return await re(n, "read annotation queue"), n;
    })).json();
  }
  /**
   * Update an annotation queue with the specified queue ID.
   * @param queueId - The ID of the annotation queue to update
   * @param options - The options for updating the annotation queue
   * @param options.name - The new name for the annotation queue
   * @param options.description - The new description for the annotation queue
   */
  async updateAnnotationQueue(e, t) {
    const { name: n, description: s, rubricInstructions: a } = t, i = JSON.stringify({
      name: n,
      description: s,
      rubric_instructions: a
    });
    await this.caller.call(async () => {
      const o = await this._fetch(`${this.apiUrl}/annotation-queues/${ve(e, "queueId")}`, {
        method: "PATCH",
        headers: { ...this.headers, "Content-Type": "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: i
      });
      return await re(o, "update annotation queue", !0), o;
    });
  }
  /**
   * Delete an annotation queue with the specified queue ID.
   * @param queueId - The ID of the annotation queue to delete
   */
  async deleteAnnotationQueue(e) {
    await this.caller.call(async () => {
      const t = await this._fetch(`${this.apiUrl}/annotation-queues/${ve(e, "queueId")}`, {
        method: "DELETE",
        headers: { ...this.headers, Accept: "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      return await re(t, "delete annotation queue", !0), t;
    });
  }
  /**
   * Add runs to an annotation queue with the specified queue ID.
   * @param queueId - The ID of the annotation queue
   * @param runIds - The IDs of the runs to be added to the annotation queue
   */
  async addRunsToAnnotationQueue(e, t) {
    const n = JSON.stringify(t.map((s, a) => ve(s, `runIds[${a}]`).toString()));
    await this.caller.call(async () => {
      const s = await this._fetch(`${this.apiUrl}/annotation-queues/${ve(e, "queueId")}/runs`, {
        method: "POST",
        headers: { ...this.headers, "Content-Type": "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: n
      });
      return await re(s, "add runs to annotation queue", !0), s;
    });
  }
  /**
   * Get a run from an annotation queue at the specified index.
   * @param queueId - The ID of the annotation queue
   * @param index - The index of the run to retrieve
   * @returns A Promise that resolves to a RunWithAnnotationQueueInfo object
   * @throws {Error} If the run is not found at the given index or for other API-related errors
   */
  async getRunFromAnnotationQueue(e, t) {
    const n = `/annotation-queues/${ve(e, "queueId")}/run`;
    return (await this.caller.call(async () => {
      const a = await this._fetch(`${this.apiUrl}${n}/${t}`, {
        method: "GET",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      return await re(a, "get run from annotation queue"), a;
    })).json();
  }
  /**
   * Delete a run from an an annotation queue.
   * @param queueId - The ID of the annotation queue to delete the run from
   * @param queueRunId - The ID of the run to delete from the annotation queue
   */
  async deleteRunFromAnnotationQueue(e, t) {
    await this.caller.call(async () => {
      const n = await this._fetch(`${this.apiUrl}/annotation-queues/${ve(e, "queueId")}/runs/${ve(t, "queueRunId")}`, {
        method: "DELETE",
        headers: { ...this.headers, Accept: "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      return await re(n, "delete run from annotation queue", !0), n;
    });
  }
  /**
   * Get the size of an annotation queue.
   * @param queueId - The ID of the annotation queue
   */
  async getSizeFromAnnotationQueue(e) {
    return (await this.caller.call(async () => {
      const n = await this._fetch(`${this.apiUrl}/annotation-queues/${ve(e, "queueId")}/size`, {
        method: "GET",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      return await re(n, "get size from annotation queue"), n;
    })).json();
  }
  async _currentTenantIsOwner(e) {
    const t = await this._getSettings();
    return e == "-" || t.tenant_handle === e;
  }
  async _ownerConflictError(e, t) {
    const n = await this._getSettings();
    return new Error(`Cannot ${e} for another tenant.

      Current tenant: ${n.tenant_handle}

      Requested tenant: ${t}`);
  }
  async _getLatestCommitHash(e) {
    const n = await (await this.caller.call(async () => {
      const s = await this._fetch(`${this.apiUrl}/commits/${e}/?limit=1&offset=0`, {
        method: "GET",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      return await re(s, "get latest commit hash"), s;
    })).json();
    if (n.commits.length !== 0)
      return n.commits[0].commit_hash;
  }
  async _likeOrUnlikePrompt(e, t) {
    const [n, s, a] = Wr(e), i = JSON.stringify({ like: t });
    return (await this.caller.call(async () => {
      const c = await this._fetch(`${this.apiUrl}/likes/${n}/${s}`, {
        method: "POST",
        headers: { ...this.headers, "Content-Type": "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: i
      });
      return await re(c, `${t ? "like" : "unlike"} prompt`), c;
    })).json();
  }
  async _getPromptUrl(e) {
    const [t, n, s] = Wr(e);
    if (await this._currentTenantIsOwner(t)) {
      const a = await this._getSettings();
      return s !== "latest" ? `${this.getHostUrl()}/prompts/${n}/${s.substring(0, 8)}?organizationId=${a.id}` : `${this.getHostUrl()}/prompts/${n}?organizationId=${a.id}`;
    } else
      return s !== "latest" ? `${this.getHostUrl()}/hub/${t}/${n}/${s.substring(0, 8)}` : `${this.getHostUrl()}/hub/${t}/${n}`;
  }
  async promptExists(e) {
    return !!await this.getPrompt(e);
  }
  async likePrompt(e) {
    return this._likeOrUnlikePrompt(e, !0);
  }
  async unlikePrompt(e) {
    return this._likeOrUnlikePrompt(e, !1);
  }
  async *listCommits(e) {
    for await (const t of this._getPaginated(`/commits/${e}/`, new URLSearchParams(), (n) => n.commits))
      yield* t;
  }
  async *listPrompts(e) {
    const t = new URLSearchParams();
    t.append("sort_field", (e == null ? void 0 : e.sortField) ?? "updated_at"), t.append("sort_direction", "desc"), t.append("is_archived", (!!(e != null && e.isArchived)).toString()), (e == null ? void 0 : e.isPublic) !== void 0 && t.append("is_public", e.isPublic.toString()), e != null && e.query && t.append("query", e.query);
    for await (const n of this._getPaginated("/repos", t, (s) => s.repos))
      yield* n;
  }
  async getPrompt(e) {
    const [t, n, s] = Wr(e), a = await this.caller.call(async () => {
      const o = await this._fetch(`${this.apiUrl}/repos/${t}/${n}`, {
        method: "GET",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      return (o == null ? void 0 : o.status) === 404 ? null : (await re(o, "get prompt"), o);
    }), i = await (a == null ? void 0 : a.json());
    return i != null && i.repo ? i.repo : null;
  }
  async createPrompt(e, t) {
    const n = await this._getSettings();
    if (t != null && t.isPublic && !n.tenant_handle)
      throw new Error(`Cannot create a public prompt without first

        creating a LangChain Hub handle.
        You can add a handle by creating a public prompt at:

        https://smith.langchain.com/prompts`);
    const [s, a, i] = Wr(e);
    if (!await this._currentTenantIsOwner(s))
      throw await this._ownerConflictError("create a prompt", s);
    const o = {
      repo_handle: a,
      ...(t == null ? void 0 : t.description) && { description: t.description },
      ...(t == null ? void 0 : t.readme) && { readme: t.readme },
      ...(t == null ? void 0 : t.tags) && { tags: t.tags },
      is_public: !!(t != null && t.isPublic)
    }, c = JSON.stringify(o), u = await this.caller.call(async () => {
      const d = await this._fetch(`${this.apiUrl}/repos/`, {
        method: "POST",
        headers: { ...this.headers, "Content-Type": "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: c
      });
      return await re(d, "create prompt"), d;
    }), { repo: l } = await u.json();
    return l;
  }
  async createCommit(e, t, n) {
    if (!await this.promptExists(e))
      throw new Error("Prompt does not exist, you must create it first.");
    const [s, a, i] = Wr(e), o = (n == null ? void 0 : n.parentCommitHash) === "latest" || !(n != null && n.parentCommitHash) ? await this._getLatestCommitHash(`${s}/${a}`) : n == null ? void 0 : n.parentCommitHash, c = {
      manifest: JSON.parse(JSON.stringify(t)),
      parent_commit: o
    }, u = JSON.stringify(c), d = await (await this.caller.call(async () => {
      const h = await this._fetch(`${this.apiUrl}/commits/${s}/${a}`, {
        method: "POST",
        headers: { ...this.headers, "Content-Type": "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: u
      });
      return await re(h, "create commit"), h;
    })).json();
    return this._getPromptUrl(`${s}/${a}${d.commit_hash ? `:${d.commit_hash}` : ""}`);
  }
  /**
   * Update examples with attachments using multipart form data.
   * @param updates List of ExampleUpdateWithAttachments objects to upsert
   * @returns Promise with the update response
   */
  async updateExamplesMultipart(e, t = []) {
    return this._updateExamplesMultipart(e, t);
  }
  async _updateExamplesMultipart(e, t = []) {
    var i;
    if (!await this._getDatasetExamplesMultiPartSupport())
      throw new Error("Your LangSmith deployment does not allow using the multipart examples endpoint, please upgrade your deployment to the latest version.");
    const n = new FormData();
    for (const o of t) {
      const c = o.id, u = {
        ...o.metadata && { metadata: o.metadata },
        ...o.split && { split: o.split }
      }, l = jt(u, `Serializing body for example with id: ${c}`), d = new Blob([l], {
        type: "application/json"
      });
      if (n.append(c, d), o.inputs) {
        const h = jt(o.inputs, `Serializing inputs for example with id: ${c}`), f = new Blob([h], {
          type: "application/json"
        });
        n.append(`${c}.inputs`, f);
      }
      if (o.outputs) {
        const h = jt(o.outputs, `Serializing outputs whle updating example with id: ${c}`), f = new Blob([h], {
          type: "application/json"
        });
        n.append(`${c}.outputs`, f);
      }
      if (o.attachments)
        for (const [h, f] of Object.entries(o.attachments)) {
          let p, y;
          Array.isArray(f) ? [p, y] = f : (p = f.mimeType, y = f.data);
          const m = new Blob([y], {
            type: `${p}; length=${y.byteLength}`
          });
          n.append(`${c}.attachment.${h}`, m);
        }
      if (o.attachments_operations) {
        const h = jt(o.attachments_operations, `Serializing attachments while updating example with id: ${c}`), f = new Blob([h], {
          type: "application/json"
        });
        n.append(`${c}.attachments_operations`, f);
      }
    }
    const s = e ?? ((i = t[0]) == null ? void 0 : i.dataset_id);
    return (await this.caller.call(async () => {
      const o = await this._fetch(`${this.apiUrl}${this._getPlatformEndpointPath(`datasets/${s}/examples`)}`, {
        method: "PATCH",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: n
      });
      return await re(o, "update examples"), o;
    })).json();
  }
  /**
   * Upload examples with attachments using multipart form data.
   * @param uploads List of ExampleUploadWithAttachments objects to upload
   * @returns Promise with the upload response
   * @deprecated This method is deprecated and will be removed in future LangSmith versions, please use `createExamples` instead
   */
  async uploadExamplesMultipart(e, t = []) {
    return this._uploadExamplesMultipart(e, t);
  }
  async _uploadExamplesMultipart(e, t = []) {
    if (!await this._getDatasetExamplesMultiPartSupport())
      throw new Error("Your LangSmith deployment does not allow using the multipart examples endpoint, please upgrade your deployment to the latest version.");
    const n = new FormData();
    for (const a of t) {
      const i = (a.id ?? ms()).toString(), o = {
        created_at: a.created_at,
        ...a.metadata && { metadata: a.metadata },
        ...a.split && { split: a.split },
        ...a.source_run_id && { source_run_id: a.source_run_id },
        ...a.use_source_run_io && {
          use_source_run_io: a.use_source_run_io
        },
        ...a.use_source_run_attachments && {
          use_source_run_attachments: a.use_source_run_attachments
        }
      }, c = jt(o, `Serializing body for uploaded example with id: ${i}`), u = new Blob([c], {
        type: "application/json"
      });
      if (n.append(i, u), a.inputs) {
        const l = jt(a.inputs, `Serializing inputs for uploaded example with id: ${i}`), d = new Blob([l], {
          type: "application/json"
        });
        n.append(`${i}.inputs`, d);
      }
      if (a.outputs) {
        const l = jt(a.outputs, `Serializing outputs for uploaded example with id: ${i}`), d = new Blob([l], {
          type: "application/json"
        });
        n.append(`${i}.outputs`, d);
      }
      if (a.attachments)
        for (const [l, d] of Object.entries(a.attachments)) {
          let h, f;
          Array.isArray(d) ? [h, f] = d : (h = d.mimeType, f = d.data);
          const p = new Blob([f], {
            type: `${h}; length=${f.byteLength}`
          });
          n.append(`${i}.attachment.${l}`, p);
        }
    }
    return (await this.caller.call(async () => {
      const a = await this._fetch(`${this.apiUrl}${this._getPlatformEndpointPath(`datasets/${e}/examples`)}`, {
        method: "POST",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: n
      });
      return await re(a, "upload examples"), a;
    })).json();
  }
  async updatePrompt(e, t) {
    if (!await this.promptExists(e))
      throw new Error("Prompt does not exist, you must create it first.");
    const [n, s] = Wr(e);
    if (!await this._currentTenantIsOwner(n))
      throw await this._ownerConflictError("update a prompt", n);
    const a = {};
    if ((t == null ? void 0 : t.description) !== void 0 && (a.description = t.description), (t == null ? void 0 : t.readme) !== void 0 && (a.readme = t.readme), (t == null ? void 0 : t.tags) !== void 0 && (a.tags = t.tags), (t == null ? void 0 : t.isPublic) !== void 0 && (a.is_public = t.isPublic), (t == null ? void 0 : t.isArchived) !== void 0 && (a.is_archived = t.isArchived), Object.keys(a).length === 0)
      throw new Error("No valid update options provided");
    const i = JSON.stringify(a);
    return (await this.caller.call(async () => {
      const c = await this._fetch(`${this.apiUrl}/repos/${n}/${s}`, {
        method: "PATCH",
        headers: {
          ...this.headers,
          "Content-Type": "application/json"
        },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: i
      });
      return await re(c, "update prompt"), c;
    })).json();
  }
  async deletePrompt(e) {
    if (!await this.promptExists(e))
      throw new Error("Prompt does not exist, you must create it first.");
    const [t, n, s] = Wr(e);
    if (!await this._currentTenantIsOwner(t))
      throw await this._ownerConflictError("delete a prompt", t);
    return (await this.caller.call(async () => {
      const i = await this._fetch(`${this.apiUrl}/repos/${t}/${n}`, {
        method: "DELETE",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      return await re(i, "delete prompt"), i;
    })).json();
  }
  async pullPromptCommit(e, t) {
    const [n, s, a] = Wr(e), o = await (await this.caller.call(async () => {
      const c = await this._fetch(`${this.apiUrl}/commits/${n}/${s}/${a}${t != null && t.includeModel ? "?include_model=true" : ""}`, {
        method: "GET",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      return await re(c, "pull prompt commit"), c;
    })).json();
    return {
      owner: n,
      repo: s,
      commit_hash: o.commit_hash,
      manifest: o.manifest,
      examples: o.examples
    };
  }
  /**
   * This method should not be used directly, use `import { pull } from "langchain/hub"` instead.
   * Using this method directly returns the JSON string of the prompt rather than a LangChain object.
   * @private
   */
  async _pullPrompt(e, t) {
    const n = await this.pullPromptCommit(e, {
      includeModel: t == null ? void 0 : t.includeModel
    });
    return JSON.stringify(n.manifest);
  }
  async pushPrompt(e, t) {
    return await this.promptExists(e) ? t && Object.keys(t).some((s) => s !== "object") && await this.updatePrompt(e, {
      description: t == null ? void 0 : t.description,
      readme: t == null ? void 0 : t.readme,
      tags: t == null ? void 0 : t.tags,
      isPublic: t == null ? void 0 : t.isPublic
    }) : await this.createPrompt(e, {
      description: t == null ? void 0 : t.description,
      readme: t == null ? void 0 : t.readme,
      tags: t == null ? void 0 : t.tags,
      isPublic: t == null ? void 0 : t.isPublic
    }), t != null && t.object ? await this.createCommit(e, t == null ? void 0 : t.object, {
      parentCommitHash: t == null ? void 0 : t.parentCommitHash
    }) : await this._getPromptUrl(e);
  }
  /**
     * Clone a public dataset to your own langsmith tenant.
     * This operation is idempotent. If you already have a dataset with the given name,
     * this function will do nothing.
  
     * @param {string} tokenOrUrl The token of the public dataset to clone.
     * @param {Object} [options] Additional options for cloning the dataset.
     * @param {string} [options.sourceApiUrl] The URL of the langsmith server where the data is hosted. Defaults to the API URL of your current client.
     * @param {string} [options.datasetName] The name of the dataset to create in your tenant. Defaults to the name of the public dataset.
     * @returns {Promise<void>}
     */
  async clonePublicDataset(e, t = {}) {
    const { sourceApiUrl: n = this.apiUrl, datasetName: s } = t, [a, i] = this.parseTokenOrUrl(e, n), o = new Ws({
      apiUrl: a,
      // Placeholder API key not needed anymore in most cases, but
      // some private deployments may have API key-based rate limiting
      // that would cause this to fail if we provide no value.
      apiKey: "placeholder"
    }), c = await o.readSharedDataset(i), u = s || c.name;
    try {
      if (await this.hasDataset({ datasetId: u })) {
        console.log(`Dataset ${u} already exists in your tenant. Skipping.`);
        return;
      }
    } catch {
    }
    const l = await o.listSharedExamples(i), d = await this.createDataset(u, {
      description: c.description,
      dataType: c.data_type || "kv",
      inputsSchema: c.inputs_schema_definition ?? void 0,
      outputsSchema: c.outputs_schema_definition ?? void 0
    });
    try {
      await this.createExamples({
        inputs: l.map((h) => h.inputs),
        outputs: l.flatMap((h) => h.outputs ? [h.outputs] : []),
        datasetId: d.id
      });
    } catch (h) {
      throw console.error(`An error occurred while creating dataset ${u}. You should delete it manually.`), h;
    }
  }
  parseTokenOrUrl(e, t, n = 2, s = "dataset") {
    try {
      return ve(e), [t, e];
    } catch {
    }
    try {
      const i = new URL(e).pathname.split("/").filter((o) => o !== "");
      if (i.length >= n) {
        const o = i[i.length - n];
        return [t, o];
      } else
        throw new Error(`Invalid public ${s} URL: ${e}`);
    } catch {
      throw new Error(`Invalid public ${s} URL or token: ${e}`);
    }
  }
  /**
   * Awaits all pending trace batches. Useful for environments where
   * you need to be sure that all tracing requests finish before execution ends,
   * such as serverless environments.
   *
   * @example
   * ```
   * import { Client } from "langsmith";
   *
   * const client = new Client();
   *
   * try {
   *   // Tracing happens here
   *   ...
   * } finally {
   *   await client.awaitPendingTraceBatches();
   * }
   * ```
   *
   * @returns A promise that resolves once all currently pending traces have sent.
   */
  async awaitPendingTraceBatches() {
    var e, t;
    if (this.manualFlushMode)
      return console.warn("[WARNING]: When tracing in manual flush mode, you must call `await client.flush()` manually to submit trace batches."), Promise.resolve();
    await Promise.all([
      ...this.autoBatchQueue.items.map(({ itemPromise: n }) => n),
      this.batchIngestCaller.queue.onIdle()
    ]), this.langSmithToOTELTranslator !== void 0 && await ((t = (e = Vb()) == null ? void 0 : e.DEFAULT_LANGSMITH_SPAN_PROCESSOR) == null ? void 0 : t.forceFlush());
  }
}
function ah(r) {
  return "dataset_id" in r || "dataset_name" in r;
}
const wS = (r) => !!["TRACING_V2", "TRACING"].find((t) => Nt(t) === "true"), en = Symbol.for("lc:context_variables"), sc = Symbol.for("langsmith:replica_trace_roots");
function ih(r, e) {
  if (en in r)
    return r[en][e];
}
function vS(r, e, t) {
  const n = en in r ? (
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    r[en]
  ) : {};
  n[e] = t, r[en] = n;
}
const Is = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
function oh(r) {
  const t = Object.keys(r).sort().map((n) => `${n}:${r[n] ?? ""}`).join("|");
  return ks(t, Is);
}
function bS(r) {
  return r.replace(/[-:.]/g, "");
}
function ag(r, e = 1) {
  const t = e.toFixed(0).slice(0, 3).padStart(3, "0");
  return `${new Date(r).toISOString().slice(0, -1)}${t}Z`;
}
function ig(r, e, t = 1) {
  const n = ag(r, t);
  return {
    dottedOrder: bS(n) + e,
    microsecondPrecisionDatestring: n
  };
}
class xi {
  constructor(e, t, n, s) {
    Object.defineProperty(this, "metadata", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "tags", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "project_name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "replicas", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.metadata = e, this.tags = t, this.project_name = n, this.replicas = s;
  }
  static fromHeader(e) {
    const t = e.split(",");
    let n = {}, s = [], a, i;
    for (const o of t) {
      const [c, u] = o.split("="), l = decodeURIComponent(u);
      c === "langsmith-metadata" ? n = JSON.parse(l) : c === "langsmith-tags" ? s = l.split(",") : c === "langsmith-project" ? a = l : c === "langsmith-replicas" && (i = JSON.parse(l));
    }
    return new xi(n, s, a, i);
  }
  toHeader() {
    const e = [];
    return this.metadata && Object.keys(this.metadata).length > 0 && e.push(`langsmith-metadata=${encodeURIComponent(JSON.stringify(this.metadata))}`), this.tags && this.tags.length > 0 && e.push(`langsmith-tags=${encodeURIComponent(this.tags.join(","))}`), this.project_name && e.push(`langsmith-project=${encodeURIComponent(this.project_name)}`), e.join(",");
  }
}
class Ct {
  constructor(e) {
    var o;
    if (Object.defineProperty(this, "id", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "run_type", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "project_name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "parent_run", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "parent_run_id", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "child_runs", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "start_time", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "end_time", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "extra", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "tags", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "error", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "serialized", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "inputs", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "outputs", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "reference_example_id", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "client", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "events", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "trace_id", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "dotted_order", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "tracingEnabled", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "execution_order", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "child_execution_order", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "attachments", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "replicas", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "distributedParentId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_serialized_start_time", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), SS(e)) {
      Object.assign(this, { ...e });
      return;
    }
    const t = Ct.getDefaultConfig(), { metadata: n, ...s } = e, a = s.client ?? Ct.getSharedClient(), i = {
      ...n,
      ...(o = s == null ? void 0 : s.extra) == null ? void 0 : o.metadata
    };
    if (s.extra = { ...s.extra, metadata: i }, "id" in s && s.id == null && delete s.id, Object.assign(this, { ...t, ...s, client: a }), this.execution_order ?? (this.execution_order = 1), this.child_execution_order ?? (this.child_execution_order = 1), this.dotted_order || (this._serialized_start_time = ag(this.start_time, this.execution_order)), this.id || (this.id = $b(this._serialized_start_time ?? this.start_time)), this.trace_id || (this.parent_run ? this.trace_id = this.parent_run.trace_id ?? this.id : this.trace_id = this.id), this.replicas = kS(this.replicas), !this.dotted_order) {
      const { dottedOrder: c } = ig(this.start_time, this.id, this.execution_order);
      this.parent_run ? this.dotted_order = this.parent_run.dotted_order + "." + c : this.dotted_order = c;
    }
  }
  set metadata(e) {
    var t;
    this.extra = {
      ...this.extra,
      metadata: {
        ...(t = this.extra) == null ? void 0 : t.metadata,
        ...e
      }
    };
  }
  get metadata() {
    var e;
    return (e = this.extra) == null ? void 0 : e.metadata;
  }
  static getDefaultConfig() {
    const e = Date.now();
    return {
      run_type: "chain",
      project_name: Um(),
      child_runs: [],
      api_url: Or("LANGCHAIN_ENDPOINT") ?? "http://localhost:1984",
      api_key: Or("LANGCHAIN_API_KEY"),
      caller_options: {},
      start_time: e,
      serialized: {},
      inputs: {},
      extra: {}
    };
  }
  static getSharedClient() {
    return Ct.sharedClient || (Ct.sharedClient = new Ws()), Ct.sharedClient;
  }
  createChild(e) {
    var l, d, h, f, p, y, m;
    const t = this.child_execution_order + 1, n = (l = this.replicas) == null ? void 0 : l.map((v) => {
      const { reroot: g, ...w } = v;
      return w;
    }), s = e.replicas ?? n, a = new Ct({
      ...e,
      parent_run: this,
      project_name: this.project_name,
      replicas: s,
      client: this.client,
      tracingEnabled: this.tracingEnabled,
      execution_order: t,
      child_execution_order: t
    });
    en in this && (a[en] = this[en]);
    const i = Symbol.for("lc:child_config"), o = ((d = e.extra) == null ? void 0 : d[i]) ?? this.extra[i];
    if (ES(o)) {
      const v = { ...o }, g = TS(v.callbacks) ? (f = (h = v.callbacks).copy) == null ? void 0 : f.call(h) : void 0;
      g && (Object.assign(g, { _parentRunId: a.id }), (m = (y = (p = g.handlers) == null ? void 0 : p.find(og)) == null ? void 0 : y.updateFromRunTree) == null || m.call(y, a), v.callbacks = g), a.extra[i] = v;
    }
    const c = /* @__PURE__ */ new Set();
    let u = this;
    for (; u != null && !c.has(u.id); )
      c.add(u.id), u.child_execution_order = Math.max(u.child_execution_order, t), u = u.parent_run;
    return this.child_runs.push(a), a;
  }
  async end(e, t, n = Date.now(), s) {
    this.outputs = this.outputs ?? e, this.error = this.error ?? t, this.end_time = this.end_time ?? n, s && Object.keys(s).length > 0 && (this.extra = this.extra ? { ...this.extra, metadata: { ...this.extra.metadata, ...s } } : { metadata: s });
  }
  _convertToCreate(e, t, n = !0) {
    var o, c;
    const s = e.extra ?? {};
    if (((o = s == null ? void 0 : s.runtime) == null ? void 0 : o.library) === void 0 && (s.runtime || (s.runtime = {}), t))
      for (const [u, l] of Object.entries(t))
        s.runtime[u] || (s.runtime[u] = l);
    let a, i;
    return n ? (i = ((c = e.parent_run) == null ? void 0 : c.id) ?? e.parent_run_id, a = []) : (a = e.child_runs.map((u) => this._convertToCreate(u, t, n)), i = void 0), {
      id: e.id,
      name: e.name,
      start_time: e._serialized_start_time ?? e.start_time,
      end_time: e.end_time,
      run_type: e.run_type,
      reference_example_id: e.reference_example_id,
      extra: s,
      serialized: e.serialized,
      error: e.error,
      inputs: e.inputs,
      outputs: e.outputs,
      session_name: e.project_name,
      child_runs: a,
      parent_run_id: i,
      trace_id: e.trace_id,
      dotted_order: e.dotted_order,
      tags: e.tags,
      attachments: e.attachments,
      events: e.events
    };
  }
  _sliceParentId(e, t) {
    if (t.dotted_order) {
      const n = t.dotted_order.split(".");
      let s = null;
      for (let a = 0; a < n.length; a++)
        if (n[a].slice(-36) === e) {
          s = a;
          break;
        }
      if (s !== null) {
        const a = n.slice(s + 1);
        t.dotted_order = a.join("."), a.length > 0 ? t.trace_id = a[0].slice(-36) : t.trace_id = t.id;
      }
    }
    t.parent_run_id === e && (t.parent_run_id = void 0);
  }
  _setReplicaTraceRoot(e, t) {
    const n = ih(this, sc) ?? {};
    n[e] = t, vS(this, sc, n);
    for (const s of this.child_runs)
      s._setReplicaTraceRoot(e, t);
  }
  _remapForProject(e) {
    const { projectName: t, runtimeEnv: n, excludeChildRuns: s = !0, reroot: a = !1, distributedParentId: i, apiUrl: o, apiKey: c, workspaceId: u } = e, l = this._convertToCreate(this, n, s);
    if (t === this.project_name)
      return {
        ...l,
        session_name: t
      };
    if (a) {
      if (i)
        this._sliceParentId(i, l);
      else if (l.parent_run_id = void 0, l.dotted_order) {
        const g = l.dotted_order.split(".");
        g.length > 0 && (l.dotted_order = g[g.length - 1], l.trace_id = l.id);
      }
      const v = oh({
        projectName: t,
        apiUrl: o,
        apiKey: c,
        workspaceId: u
      });
      this._setReplicaTraceRoot(v, l.id);
    }
    let d;
    if (!a) {
      const v = ih(this, sc) ?? {}, g = oh({
        projectName: t,
        apiUrl: o,
        apiKey: c,
        workspaceId: u
      });
      if (d = v[g], d && (l.trace_id = d, l.dotted_order)) {
        const w = l.dotted_order.split(".");
        let T = null;
        for (let x = 0; x < w.length; x++)
          if (w[x].slice(-36) === d) {
            T = x;
            break;
          }
        if (T !== null) {
          const x = w.slice(T);
          l.dotted_order = x.join(".");
        }
      }
    }
    const h = l.id, f = ks(`${h}:${t}`, Is);
    let p;
    l.trace_id ? p = ks(`${l.trace_id}:${t}`, Is) : p = f;
    let y;
    l.parent_run_id && (y = ks(`${l.parent_run_id}:${t}`, Is));
    let m;
    return l.dotted_order && (m = l.dotted_order.split(".").map((w) => {
      const T = w.slice(-36), x = ks(`${T}:${t}`, Is);
      return w.slice(0, -36) + x;
    }).join(".")), {
      ...l,
      id: f,
      trace_id: p,
      parent_run_id: y,
      dotted_order: m,
      session_name: t
    };
  }
  async postRun(e = !0) {
    try {
      const t = Vm();
      if (this.replicas && this.replicas.length > 0)
        for (const { projectName: n, apiKey: s, apiUrl: a, workspaceId: i, reroot: o } of this.replicas) {
          const c = this._remapForProject({
            projectName: n ?? this.project_name,
            runtimeEnv: t,
            excludeChildRuns: !0,
            reroot: o,
            distributedParentId: this.distributedParentId,
            apiUrl: a,
            apiKey: s,
            workspaceId: i
          });
          await this.client.createRun(c, {
            apiKey: s,
            apiUrl: a,
            workspaceId: i
          });
        }
      else {
        const n = this._convertToCreate(this, t, e);
        await this.client.createRun(n);
      }
      if (!e) {
        Dc("Posting with excludeChildRuns=false is deprecated and will be removed in a future version.");
        for (const n of this.child_runs)
          await n.postRun(!1);
      }
    } catch (t) {
      console.error(`Error in postRun for run ${this.id}:`, t);
    }
  }
  async patchRun(e) {
    var t;
    if (this.replicas && this.replicas.length > 0)
      for (const { projectName: n, apiKey: s, apiUrl: a, workspaceId: i, updates: o, reroot: c } of this.replicas) {
        const u = this._remapForProject({
          projectName: n ?? this.project_name,
          runtimeEnv: void 0,
          excludeChildRuns: !0,
          reroot: c,
          distributedParentId: this.distributedParentId,
          apiUrl: a,
          apiKey: s,
          workspaceId: i
        }), l = {
          id: u.id,
          name: u.name,
          run_type: u.run_type,
          start_time: u.start_time,
          outputs: u.outputs,
          error: u.error,
          parent_run_id: u.parent_run_id,
          session_name: u.session_name,
          reference_example_id: u.reference_example_id,
          end_time: u.end_time,
          dotted_order: u.dotted_order,
          trace_id: u.trace_id,
          events: u.events,
          tags: u.tags,
          extra: u.extra,
          attachments: this.attachments,
          ...o
        };
        e != null && e.excludeInputs || (l.inputs = u.inputs), await this.client.updateRun(u.id, l, {
          apiKey: s,
          apiUrl: a,
          workspaceId: i
        });
      }
    else
      try {
        const n = {
          name: this.name,
          run_type: this.run_type,
          start_time: this._serialized_start_time ?? this.start_time,
          end_time: this.end_time,
          error: this.error,
          outputs: this.outputs,
          parent_run_id: ((t = this.parent_run) == null ? void 0 : t.id) ?? this.parent_run_id,
          reference_example_id: this.reference_example_id,
          extra: this.extra,
          events: this.events,
          dotted_order: this.dotted_order,
          trace_id: this.trace_id,
          tags: this.tags,
          attachments: this.attachments,
          session_name: this.project_name
        };
        e != null && e.excludeInputs || (n.inputs = this.inputs), await this.client.updateRun(this.id, n);
      } catch (n) {
        console.error(`Error in patchRun for run ${this.id}`, n);
      }
  }
  toJSON() {
    return this._convertToCreate(this, void 0, !1);
  }
  /**
   * Add an event to the run tree.
   * @param event - A single event or string to add
   */
  addEvent(e) {
    this.events || (this.events = []), typeof e == "string" ? this.events.push({
      name: "event",
      time: (/* @__PURE__ */ new Date()).toISOString(),
      message: e
    }) : this.events.push({
      ...e,
      time: e.time ?? (/* @__PURE__ */ new Date()).toISOString()
    });
  }
  static fromRunnableConfig(e, t) {
    var u, l, d, h;
    const n = e == null ? void 0 : e.callbacks;
    let s, a, i, o = wS();
    if (n) {
      const f = ((u = n == null ? void 0 : n.getParentRunId) == null ? void 0 : u.call(n)) ?? "", p = (l = n == null ? void 0 : n.handlers) == null ? void 0 : l.find((y) => (y == null ? void 0 : y.name) == "langchain_tracer");
      s = (d = p == null ? void 0 : p.getRun) == null ? void 0 : d.call(p, f), a = p == null ? void 0 : p.projectName, i = p == null ? void 0 : p.client, o = o || !!p;
    }
    return s ? new Ct({
      name: s.name,
      id: s.id,
      trace_id: s.trace_id,
      dotted_order: s.dotted_order,
      client: i,
      tracingEnabled: o,
      project_name: a,
      tags: [
        ...new Set(((s == null ? void 0 : s.tags) ?? []).concat((e == null ? void 0 : e.tags) ?? []))
      ],
      extra: {
        metadata: {
          ...(h = s == null ? void 0 : s.extra) == null ? void 0 : h.metadata,
          ...e == null ? void 0 : e.metadata
        }
      }
    }).createChild(t) : new Ct({
      ...t,
      client: i,
      tracingEnabled: o,
      project_name: a
    });
  }
  static fromDottedOrder(e) {
    return this.fromHeaders({ "langsmith-trace": e });
  }
  static fromHeaders(e, t) {
    var l;
    const n = "get" in e && typeof e.get == "function" ? {
      "langsmith-trace": e.get("langsmith-trace"),
      baggage: e.get("baggage")
    } : e, s = n["langsmith-trace"];
    if (!s || typeof s != "string")
      return;
    const a = s.trim(), i = a.split(".").map((d) => {
      const [h, f] = d.split("Z");
      return { strTime: h, time: Date.parse(h + "Z"), uuid: f };
    }), o = i[0].uuid, c = {
      ...t,
      name: (t == null ? void 0 : t.name) ?? "parent",
      run_type: (t == null ? void 0 : t.run_type) ?? "chain",
      start_time: (t == null ? void 0 : t.start_time) ?? Date.now(),
      id: (l = i.at(-1)) == null ? void 0 : l.uuid,
      trace_id: o,
      dotted_order: a
    };
    if (n.baggage && typeof n.baggage == "string") {
      const d = xi.fromHeader(n.baggage);
      c.metadata = d.metadata, c.tags = d.tags, c.project_name = d.project_name, c.replicas = d.replicas;
    }
    const u = new Ct(c);
    return u.distributedParentId = u.id, u;
  }
  toHeaders(e) {
    var n;
    const t = {
      "langsmith-trace": this.dotted_order,
      baggage: new xi((n = this.extra) == null ? void 0 : n.metadata, this.tags, this.project_name, this.replicas).toHeader()
    };
    if (e)
      for (const [s, a] of Object.entries(t))
        e.set(s, a);
    return t;
  }
}
Object.defineProperty(Ct, "sharedClient", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: null
});
function SS(r) {
  return r != null && typeof r.createChild == "function" && typeof r.postRun == "function";
}
function og(r) {
  return typeof r == "object" && r != null && typeof r.name == "string" && r.name === "langchain_tracer";
}
function ch(r) {
  return Array.isArray(r) && r.some((e) => og(e));
}
function TS(r) {
  return typeof r == "object" && r != null && Array.isArray(r.handlers);
}
function ES(r) {
  var e;
  return r != null && typeof r.callbacks == "object" && // Callback manager with a langchain tracer
  (ch((e = r.callbacks) == null ? void 0 : e.handlers) || // Or it's an array with a LangChainTracerLike object within it
  ch(r.callbacks));
}
function xS() {
  const r = Or("LANGSMITH_RUNS_ENDPOINTS");
  if (!r)
    return [];
  try {
    const e = JSON.parse(r);
    if (Array.isArray(e)) {
      const t = [];
      for (const n of e) {
        if (typeof n != "object" || n === null) {
          console.warn(`Invalid item type in LANGSMITH_RUNS_ENDPOINTS: expected object, got ${typeof n}`);
          continue;
        }
        if (typeof n.api_url != "string") {
          console.warn(`Invalid api_url type in LANGSMITH_RUNS_ENDPOINTS: expected string, got ${typeof n.api_url}`);
          continue;
        }
        if (typeof n.api_key != "string") {
          console.warn(`Invalid api_key type in LANGSMITH_RUNS_ENDPOINTS: expected string, got ${typeof n.api_key}`);
          continue;
        }
        t.push({
          apiUrl: n.api_url.replace(/\/$/, ""),
          apiKey: n.api_key
        });
      }
      return t;
    } else if (typeof e == "object" && e !== null) {
      IS(e);
      const t = [];
      for (const [n, s] of Object.entries(e)) {
        const a = n.replace(/\/$/, "");
        if (typeof s == "string")
          t.push({
            apiUrl: a,
            apiKey: s
          });
        else {
          console.warn(`Invalid value type in LANGSMITH_RUNS_ENDPOINTS for URL ${n}: expected string, got ${typeof s}`);
          continue;
        }
      }
      return t;
    } else
      return console.warn(`Invalid LANGSMITH_RUNS_ENDPOINTS â€“ must be valid JSON array of objects with api_url and api_key properties, or object mapping url->apiKey, got ${typeof e}`), [];
  } catch (e) {
    if (aS(e))
      throw e;
    return console.warn("Invalid LANGSMITH_RUNS_ENDPOINTS â€“ must be valid JSON array of objects with api_url and api_key properties, or object mapping url->apiKey"), [];
  }
}
function kS(r) {
  return r ? r.map((e) => Array.isArray(e) ? {
    projectName: e[0],
    updates: e[1]
  } : e) : xS();
}
function IS(r) {
  if (Object.keys(r).length > 0 && Nt("ENDPOINT"))
    throw new sS();
}
var OS = {};
Ae(OS, {
  BaseTracer: () => ds,
  isBaseTracer: () => Un
});
const AS = (r) => {
  if (r)
    return r.events = r.events ?? [], r.child_runs = r.child_runs ?? [], r;
};
function Uc(r, e) {
  if (r)
    return new Ct({
      ...r,
      start_time: r._serialized_start_time ?? r.start_time,
      parent_run: Uc(e),
      child_runs: r.child_runs.map((t) => Uc(t)).filter((t) => t !== void 0),
      extra: {
        ...r.extra,
        runtime: Mm()
      },
      tracingEnabled: !1
    });
}
function ac(r, e) {
  return r && !Array.isArray(r) && typeof r == "object" ? r : { [e]: r };
}
function Un(r) {
  return typeof r._addRunToRunMap == "function";
}
var ds = class extends da {
  constructor(e) {
    super(...arguments);
    /** @deprecated Use `runTreeMap` instead. */
    b(this, "runMap", /* @__PURE__ */ new Map());
    b(this, "runTreeMap", /* @__PURE__ */ new Map());
    b(this, "usesRunTreeMap", !1);
  }
  copy() {
    return this;
  }
  getRunById(e) {
    if (e !== void 0)
      return this.usesRunTreeMap ? AS(this.runTreeMap.get(e)) : this.runMap.get(e);
  }
  stringifyError(e) {
    return e instanceof Error ? e.message + (e != null && e.stack ? `

${e.stack}` : "") : typeof e == "string" ? e : `${e}`;
  }
  _addChildRun(e, t) {
    e.child_runs.push(t);
  }
  _addRunToRunMap(e) {
    const { dottedOrder: t, microsecondPrecisionDatestring: n } = ig(new Date(e.start_time).getTime(), e.id, e.execution_order), s = { ...e }, a = this.getRunById(s.parent_run_id);
    if (s.parent_run_id !== void 0 ? a && (this._addChildRun(a, s), a.child_execution_order = Math.max(a.child_execution_order, s.child_execution_order), s.trace_id = a.trace_id, a.dotted_order !== void 0 && (s.dotted_order = [a.dotted_order, t].join("."), s._serialized_start_time = n)) : (s.trace_id = s.id, s.dotted_order = t, s._serialized_start_time = n), this.usesRunTreeMap) {
      const i = Uc(s, a);
      i !== void 0 && this.runTreeMap.set(s.id, i);
    } else this.runMap.set(s.id, s);
    return s;
  }
  async _endTrace(e) {
    var n;
    const t = e.parent_run_id !== void 0 && this.getRunById(e.parent_run_id);
    t ? t.child_execution_order = Math.max(t.child_execution_order, e.child_execution_order) : await this.persistRun(e), await ((n = this.onRunUpdate) == null ? void 0 : n.call(this, e)), this.usesRunTreeMap ? this.runTreeMap.delete(e.id) : this.runMap.delete(e.id);
  }
  _getExecutionOrder(e) {
    const t = e !== void 0 && this.getRunById(e);
    return t ? t.child_execution_order + 1 : 1;
  }
  /**
  * Create and add a run to the run map for LLM start events.
  * This must sometimes be done synchronously to avoid race conditions
  * when callbacks are backgrounded, so we expose it as a separate method here.
  */
  _createRunForLLMStart(e, t, n, s, a, i, o, c) {
    const u = this._getExecutionOrder(s), l = Date.now(), d = o ? {
      ...a,
      metadata: o
    } : a, h = {
      id: n,
      name: c ?? e.id[e.id.length - 1],
      parent_run_id: s,
      start_time: l,
      serialized: e,
      events: [{
        name: "start",
        time: new Date(l).toISOString()
      }],
      inputs: { prompts: t },
      execution_order: u,
      child_runs: [],
      child_execution_order: u,
      run_type: "llm",
      extra: d ?? {},
      tags: i || []
    };
    return this._addRunToRunMap(h);
  }
  async handleLLMStart(e, t, n, s, a, i, o, c) {
    var l, d;
    const u = this.getRunById(n) ?? this._createRunForLLMStart(e, t, n, s, a, i, o, c);
    return await ((l = this.onRunCreate) == null ? void 0 : l.call(this, u)), await ((d = this.onLLMStart) == null ? void 0 : d.call(this, u)), u;
  }
  /**
  * Create and add a run to the run map for chat model start events.
  * This must sometimes be done synchronously to avoid race conditions
  * when callbacks are backgrounded, so we expose it as a separate method here.
  */
  _createRunForChatModelStart(e, t, n, s, a, i, o, c) {
    const u = this._getExecutionOrder(s), l = Date.now(), d = o ? {
      ...a,
      metadata: o
    } : a, h = {
      id: n,
      name: c ?? e.id[e.id.length - 1],
      parent_run_id: s,
      start_time: l,
      serialized: e,
      events: [{
        name: "start",
        time: new Date(l).toISOString()
      }],
      inputs: { messages: t },
      execution_order: u,
      child_runs: [],
      child_execution_order: u,
      run_type: "llm",
      extra: d ?? {},
      tags: i || []
    };
    return this._addRunToRunMap(h);
  }
  async handleChatModelStart(e, t, n, s, a, i, o, c) {
    var l, d;
    const u = this.getRunById(n) ?? this._createRunForChatModelStart(e, t, n, s, a, i, o, c);
    return await ((l = this.onRunCreate) == null ? void 0 : l.call(this, u)), await ((d = this.onLLMStart) == null ? void 0 : d.call(this, u)), u;
  }
  async handleLLMEnd(e, t, n, s, a) {
    var o;
    const i = this.getRunById(t);
    if (!i || (i == null ? void 0 : i.run_type) !== "llm") throw new Error("No LLM run to end.");
    return i.end_time = Date.now(), i.outputs = e, i.events.push({
      name: "end",
      time: new Date(i.end_time).toISOString()
    }), i.extra = {
      ...i.extra,
      ...a
    }, await ((o = this.onLLMEnd) == null ? void 0 : o.call(this, i)), await this._endTrace(i), i;
  }
  async handleLLMError(e, t, n, s, a) {
    var o;
    const i = this.getRunById(t);
    if (!i || (i == null ? void 0 : i.run_type) !== "llm") throw new Error("No LLM run to end.");
    return i.end_time = Date.now(), i.error = this.stringifyError(e), i.events.push({
      name: "error",
      time: new Date(i.end_time).toISOString()
    }), i.extra = {
      ...i.extra,
      ...a
    }, await ((o = this.onLLMError) == null ? void 0 : o.call(this, i)), await this._endTrace(i), i;
  }
  /**
  * Create and add a run to the run map for chain start events.
  * This must sometimes be done synchronously to avoid race conditions
  * when callbacks are backgrounded, so we expose it as a separate method here.
  */
  _createRunForChainStart(e, t, n, s, a, i, o, c) {
    const u = this._getExecutionOrder(s), l = Date.now(), d = {
      id: n,
      name: c ?? e.id[e.id.length - 1],
      parent_run_id: s,
      start_time: l,
      serialized: e,
      events: [{
        name: "start",
        time: new Date(l).toISOString()
      }],
      inputs: t,
      execution_order: u,
      child_execution_order: u,
      run_type: o ?? "chain",
      child_runs: [],
      extra: i ? { metadata: i } : {},
      tags: a || []
    };
    return this._addRunToRunMap(d);
  }
  async handleChainStart(e, t, n, s, a, i, o, c) {
    var l, d;
    const u = this.getRunById(n) ?? this._createRunForChainStart(e, t, n, s, a, i, o, c);
    return await ((l = this.onRunCreate) == null ? void 0 : l.call(this, u)), await ((d = this.onChainStart) == null ? void 0 : d.call(this, u)), u;
  }
  async handleChainEnd(e, t, n, s, a) {
    var o;
    const i = this.getRunById(t);
    if (!i) throw new Error("No chain run to end.");
    return i.end_time = Date.now(), i.outputs = ac(e, "output"), i.events.push({
      name: "end",
      time: new Date(i.end_time).toISOString()
    }), (a == null ? void 0 : a.inputs) !== void 0 && (i.inputs = ac(a.inputs, "input")), await ((o = this.onChainEnd) == null ? void 0 : o.call(this, i)), await this._endTrace(i), i;
  }
  async handleChainError(e, t, n, s, a) {
    var o;
    const i = this.getRunById(t);
    if (!i) throw new Error("No chain run to end.");
    return i.end_time = Date.now(), i.error = this.stringifyError(e), i.events.push({
      name: "error",
      time: new Date(i.end_time).toISOString()
    }), (a == null ? void 0 : a.inputs) !== void 0 && (i.inputs = ac(a.inputs, "input")), await ((o = this.onChainError) == null ? void 0 : o.call(this, i)), await this._endTrace(i), i;
  }
  /**
  * Create and add a run to the run map for tool start events.
  * This must sometimes be done synchronously to avoid race conditions
  * when callbacks are backgrounded, so we expose it as a separate method here.
  */
  _createRunForToolStart(e, t, n, s, a, i, o) {
    const c = this._getExecutionOrder(s), u = Date.now(), l = {
      id: n,
      name: o ?? e.id[e.id.length - 1],
      parent_run_id: s,
      start_time: u,
      serialized: e,
      events: [{
        name: "start",
        time: new Date(u).toISOString()
      }],
      inputs: { input: t },
      execution_order: c,
      child_execution_order: c,
      run_type: "tool",
      child_runs: [],
      extra: i ? { metadata: i } : {},
      tags: a || []
    };
    return this._addRunToRunMap(l);
  }
  async handleToolStart(e, t, n, s, a, i, o) {
    var u, l;
    const c = this.getRunById(n) ?? this._createRunForToolStart(e, t, n, s, a, i, o);
    return await ((u = this.onRunCreate) == null ? void 0 : u.call(this, c)), await ((l = this.onToolStart) == null ? void 0 : l.call(this, c)), c;
  }
  async handleToolEnd(e, t) {
    var s;
    const n = this.getRunById(t);
    if (!n || (n == null ? void 0 : n.run_type) !== "tool") throw new Error("No tool run to end");
    return n.end_time = Date.now(), n.outputs = { output: e }, n.events.push({
      name: "end",
      time: new Date(n.end_time).toISOString()
    }), await ((s = this.onToolEnd) == null ? void 0 : s.call(this, n)), await this._endTrace(n), n;
  }
  async handleToolError(e, t) {
    var s;
    const n = this.getRunById(t);
    if (!n || (n == null ? void 0 : n.run_type) !== "tool") throw new Error("No tool run to end");
    return n.end_time = Date.now(), n.error = this.stringifyError(e), n.events.push({
      name: "error",
      time: new Date(n.end_time).toISOString()
    }), await ((s = this.onToolError) == null ? void 0 : s.call(this, n)), await this._endTrace(n), n;
  }
  async handleAgentAction(e, t) {
    var a;
    const n = this.getRunById(t);
    if (!n || (n == null ? void 0 : n.run_type) !== "chain") return;
    const s = n;
    s.actions = s.actions || [], s.actions.push(e), s.events.push({
      name: "agent_action",
      time: (/* @__PURE__ */ new Date()).toISOString(),
      kwargs: { action: e }
    }), await ((a = this.onAgentAction) == null ? void 0 : a.call(this, n));
  }
  async handleAgentEnd(e, t) {
    var s;
    const n = this.getRunById(t);
    !n || (n == null ? void 0 : n.run_type) !== "chain" || (n.events.push({
      name: "agent_end",
      time: (/* @__PURE__ */ new Date()).toISOString(),
      kwargs: { action: e }
    }), await ((s = this.onAgentEnd) == null ? void 0 : s.call(this, n)));
  }
  /**
  * Create and add a run to the run map for retriever start events.
  * This must sometimes be done synchronously to avoid race conditions
  * when callbacks are backgrounded, so we expose it as a separate method here.
  */
  _createRunForRetrieverStart(e, t, n, s, a, i, o) {
    const c = this._getExecutionOrder(s), u = Date.now(), l = {
      id: n,
      name: o ?? e.id[e.id.length - 1],
      parent_run_id: s,
      start_time: u,
      serialized: e,
      events: [{
        name: "start",
        time: new Date(u).toISOString()
      }],
      inputs: { query: t },
      execution_order: c,
      child_execution_order: c,
      run_type: "retriever",
      child_runs: [],
      extra: i ? { metadata: i } : {},
      tags: a || []
    };
    return this._addRunToRunMap(l);
  }
  async handleRetrieverStart(e, t, n, s, a, i, o) {
    var u, l;
    const c = this.getRunById(n) ?? this._createRunForRetrieverStart(e, t, n, s, a, i, o);
    return await ((u = this.onRunCreate) == null ? void 0 : u.call(this, c)), await ((l = this.onRetrieverStart) == null ? void 0 : l.call(this, c)), c;
  }
  async handleRetrieverEnd(e, t) {
    var s;
    const n = this.getRunById(t);
    if (!n || (n == null ? void 0 : n.run_type) !== "retriever") throw new Error("No retriever run to end");
    return n.end_time = Date.now(), n.outputs = { documents: e }, n.events.push({
      name: "end",
      time: new Date(n.end_time).toISOString()
    }), await ((s = this.onRetrieverEnd) == null ? void 0 : s.call(this, n)), await this._endTrace(n), n;
  }
  async handleRetrieverError(e, t) {
    var s;
    const n = this.getRunById(t);
    if (!n || (n == null ? void 0 : n.run_type) !== "retriever") throw new Error("No retriever run to end");
    return n.end_time = Date.now(), n.error = this.stringifyError(e), n.events.push({
      name: "error",
      time: new Date(n.end_time).toISOString()
    }), await ((s = this.onRetrieverError) == null ? void 0 : s.call(this, n)), await this._endTrace(n), n;
  }
  async handleText(e, t) {
    var s;
    const n = this.getRunById(t);
    !n || (n == null ? void 0 : n.run_type) !== "chain" || (n.events.push({
      name: "text",
      time: (/* @__PURE__ */ new Date()).toISOString(),
      kwargs: { text: e }
    }), await ((s = this.onText) == null ? void 0 : s.call(this, n)));
  }
  async handleLLMNewToken(e, t, n, s, a, i) {
    var c;
    const o = this.getRunById(n);
    if (!o || (o == null ? void 0 : o.run_type) !== "llm") throw new Error('Invalid "runId" provided to "handleLLMNewToken" callback.');
    return o.events.push({
      name: "new_token",
      time: (/* @__PURE__ */ new Date()).toISOString(),
      kwargs: {
        token: e,
        idx: t,
        chunk: i == null ? void 0 : i.chunk
      }
    }), await ((c = this.onLLMNewToken) == null ? void 0 : c.call(this, o, e, { chunk: i == null ? void 0 : i.chunk })), o;
  }
}, gl = { exports: {} };
gl.exports;
(function(r) {
  const t = (a = 0) => (i) => `\x1B[${38 + a};5;${i}m`, n = (a = 0) => (i, o, c) => `\x1B[${38 + a};2;${i};${o};${c}m`;
  function s() {
    const a = /* @__PURE__ */ new Map(), i = {
      modifier: {
        reset: [0, 0],
        // 21 isn't widely supported and 22 does the same thing
        bold: [1, 22],
        dim: [2, 22],
        italic: [3, 23],
        underline: [4, 24],
        overline: [53, 55],
        inverse: [7, 27],
        hidden: [8, 28],
        strikethrough: [9, 29]
      },
      color: {
        black: [30, 39],
        red: [31, 39],
        green: [32, 39],
        yellow: [33, 39],
        blue: [34, 39],
        magenta: [35, 39],
        cyan: [36, 39],
        white: [37, 39],
        // Bright color
        blackBright: [90, 39],
        redBright: [91, 39],
        greenBright: [92, 39],
        yellowBright: [93, 39],
        blueBright: [94, 39],
        magentaBright: [95, 39],
        cyanBright: [96, 39],
        whiteBright: [97, 39]
      },
      bgColor: {
        bgBlack: [40, 49],
        bgRed: [41, 49],
        bgGreen: [42, 49],
        bgYellow: [43, 49],
        bgBlue: [44, 49],
        bgMagenta: [45, 49],
        bgCyan: [46, 49],
        bgWhite: [47, 49],
        // Bright color
        bgBlackBright: [100, 49],
        bgRedBright: [101, 49],
        bgGreenBright: [102, 49],
        bgYellowBright: [103, 49],
        bgBlueBright: [104, 49],
        bgMagentaBright: [105, 49],
        bgCyanBright: [106, 49],
        bgWhiteBright: [107, 49]
      }
    };
    i.color.gray = i.color.blackBright, i.bgColor.bgGray = i.bgColor.bgBlackBright, i.color.grey = i.color.blackBright, i.bgColor.bgGrey = i.bgColor.bgBlackBright;
    for (const [o, c] of Object.entries(i)) {
      for (const [u, l] of Object.entries(c))
        i[u] = {
          open: `\x1B[${l[0]}m`,
          close: `\x1B[${l[1]}m`
        }, c[u] = i[u], a.set(l[0], l[1]);
      Object.defineProperty(i, o, {
        value: c,
        enumerable: !1
      });
    }
    return Object.defineProperty(i, "codes", {
      value: a,
      enumerable: !1
    }), i.color.close = "\x1B[39m", i.bgColor.close = "\x1B[49m", i.color.ansi256 = t(), i.color.ansi16m = n(), i.bgColor.ansi256 = t(10), i.bgColor.ansi16m = n(10), Object.defineProperties(i, {
      rgbToAnsi256: {
        value: (o, c, u) => o === c && c === u ? o < 8 ? 16 : o > 248 ? 231 : Math.round((o - 8) / 247 * 24) + 232 : 16 + 36 * Math.round(o / 255 * 5) + 6 * Math.round(c / 255 * 5) + Math.round(u / 255 * 5),
        enumerable: !1
      },
      hexToRgb: {
        value: (o) => {
          const c = /(?<colorString>[a-f\d]{6}|[a-f\d]{3})/i.exec(o.toString(16));
          if (!c)
            return [0, 0, 0];
          let { colorString: u } = c.groups;
          u.length === 3 && (u = u.split("").map((d) => d + d).join(""));
          const l = Number.parseInt(u, 16);
          return [
            l >> 16 & 255,
            l >> 8 & 255,
            l & 255
          ];
        },
        enumerable: !1
      },
      hexToAnsi256: {
        value: (o) => i.rgbToAnsi256(...i.hexToRgb(o)),
        enumerable: !1
      }
    }), i;
  }
  Object.defineProperty(r, "exports", {
    enumerable: !0,
    get: s
  });
})(gl);
var $S = gl.exports;
const cg = /* @__PURE__ */ Yu($S);
var CS = {};
Ae(CS, { ConsoleCallbackHandler: () => zc });
function Et(r, e) {
  return `${r.open}${e}${r.close}`;
}
function Ht(r, e) {
  try {
    return JSON.stringify(r, null, 2);
  } catch {
    return e;
  }
}
function uh(r) {
  return typeof r == "string" ? r.trim() : r == null ? r : Ht(r, r.toString());
}
function Kr(r) {
  if (!r.end_time) return "";
  const e = r.end_time - r.start_time;
  return e < 1e3 ? `${e}ms` : `${(e / 1e3).toFixed(2)}s`;
}
const { color: $t } = cg;
var zc = class extends ds {
  constructor() {
    super(...arguments);
    b(this, "name", "console_callback_handler");
  }
  /**
  * Method used to persist the run. In this case, it simply returns a
  * resolved promise as there's no persistence logic.
  * @param _run The run to persist.
  * @returns A resolved promise.
  */
  persistRun(e) {
    return Promise.resolve();
  }
  /**
  * Method used to get all the parent runs of a given run.
  * @param run The run whose parents are to be retrieved.
  * @returns An array of parent runs.
  */
  getParents(e) {
    const t = [];
    let n = e;
    for (; n.parent_run_id; ) {
      const s = this.runMap.get(n.parent_run_id);
      if (s)
        t.push(s), n = s;
      else break;
    }
    return t;
  }
  /**
  * Method used to get a string representation of the run's lineage, which
  * is used in logging.
  * @param run The run whose lineage is to be retrieved.
  * @returns A string representation of the run's lineage.
  */
  getBreadcrumbs(e) {
    const n = [...this.getParents(e).reverse(), e].map((s, a, i) => {
      const o = `${s.execution_order}:${s.run_type}:${s.name}`;
      return a === i.length - 1 ? Et(cg.bold, o) : o;
    }).join(" > ");
    return Et($t.grey, n);
  }
  /**
  * Method used to log the start of a chain run.
  * @param run The chain run that has started.
  * @returns void
  */
  onChainStart(e) {
    const t = this.getBreadcrumbs(e);
    console.log(`${Et($t.green, "[chain/start]")} [${t}] Entering Chain run with input: ${Ht(e.inputs, "[inputs]")}`);
  }
  /**
  * Method used to log the end of a chain run.
  * @param run The chain run that has ended.
  * @returns void
  */
  onChainEnd(e) {
    const t = this.getBreadcrumbs(e);
    console.log(`${Et($t.cyan, "[chain/end]")} [${t}] [${Kr(e)}] Exiting Chain run with output: ${Ht(e.outputs, "[outputs]")}`);
  }
  /**
  * Method used to log any errors of a chain run.
  * @param run The chain run that has errored.
  * @returns void
  */
  onChainError(e) {
    const t = this.getBreadcrumbs(e);
    console.log(`${Et($t.red, "[chain/error]")} [${t}] [${Kr(e)}] Chain run errored with error: ${Ht(e.error, "[error]")}`);
  }
  /**
  * Method used to log the start of an LLM run.
  * @param run The LLM run that has started.
  * @returns void
  */
  onLLMStart(e) {
    const t = this.getBreadcrumbs(e), n = "prompts" in e.inputs ? { prompts: e.inputs.prompts.map((s) => s.trim()) } : e.inputs;
    console.log(`${Et($t.green, "[llm/start]")} [${t}] Entering LLM run with input: ${Ht(n, "[inputs]")}`);
  }
  /**
  * Method used to log the end of an LLM run.
  * @param run The LLM run that has ended.
  * @returns void
  */
  onLLMEnd(e) {
    const t = this.getBreadcrumbs(e);
    console.log(`${Et($t.cyan, "[llm/end]")} [${t}] [${Kr(e)}] Exiting LLM run with output: ${Ht(e.outputs, "[response]")}`);
  }
  /**
  * Method used to log any errors of an LLM run.
  * @param run The LLM run that has errored.
  * @returns void
  */
  onLLMError(e) {
    const t = this.getBreadcrumbs(e);
    console.log(`${Et($t.red, "[llm/error]")} [${t}] [${Kr(e)}] LLM run errored with error: ${Ht(e.error, "[error]")}`);
  }
  /**
  * Method used to log the start of a tool run.
  * @param run The tool run that has started.
  * @returns void
  */
  onToolStart(e) {
    const t = this.getBreadcrumbs(e);
    console.log(`${Et($t.green, "[tool/start]")} [${t}] Entering Tool run with input: "${uh(e.inputs.input)}"`);
  }
  /**
  * Method used to log the end of a tool run.
  * @param run The tool run that has ended.
  * @returns void
  */
  onToolEnd(e) {
    var n;
    const t = this.getBreadcrumbs(e);
    console.log(`${Et($t.cyan, "[tool/end]")} [${t}] [${Kr(e)}] Exiting Tool run with output: "${uh((n = e.outputs) == null ? void 0 : n.output)}"`);
  }
  /**
  * Method used to log any errors of a tool run.
  * @param run The tool run that has errored.
  * @returns void
  */
  onToolError(e) {
    const t = this.getBreadcrumbs(e);
    console.log(`${Et($t.red, "[tool/error]")} [${t}] [${Kr(e)}] Tool run errored with error: ${Ht(e.error, "[error]")}`);
  }
  /**
  * Method used to log the start of a retriever run.
  * @param run The retriever run that has started.
  * @returns void
  */
  onRetrieverStart(e) {
    const t = this.getBreadcrumbs(e);
    console.log(`${Et($t.green, "[retriever/start]")} [${t}] Entering Retriever run with input: ${Ht(e.inputs, "[inputs]")}`);
  }
  /**
  * Method used to log the end of a retriever run.
  * @param run The retriever run that has ended.
  * @returns void
  */
  onRetrieverEnd(e) {
    const t = this.getBreadcrumbs(e);
    console.log(`${Et($t.cyan, "[retriever/end]")} [${t}] [${Kr(e)}] Exiting Retriever run with output: ${Ht(e.outputs, "[outputs]")}`);
  }
  /**
  * Method used to log any errors of a retriever run.
  * @param run The retriever run that has errored.
  * @returns void
  */
  onRetrieverError(e) {
    const t = this.getBreadcrumbs(e);
    console.log(`${Et($t.red, "[retriever/error]")} [${t}] [${Kr(e)}] Retriever run errored with error: ${Ht(e.error, "[error]")}`);
  }
  /**
  * Method used to log the action selected by the agent.
  * @param run The run in which the agent action occurred.
  * @returns void
  */
  onAgentAction(e) {
    const t = e, n = this.getBreadcrumbs(e);
    console.log(`${Et($t.blue, "[agent/action]")} [${n}] Agent selected action: ${Ht(t.actions[t.actions.length - 1], "[action]")}`);
  }
};
let ic;
const ug = () => {
  if (ic === void 0) {
    const r = Er("LANGCHAIN_CALLBACKS_BACKGROUND") === "false" ? { blockOnRootRunFinalization: !0 } : {};
    ic = new Ws(r);
  }
  return ic;
};
let RS = class {
  getStore() {
  }
  run(e, t) {
    return t();
  }
};
const oc = Symbol.for("ls:tracing_async_local_storage"), NS = new RS();
let PS = class {
  getInstance() {
    return globalThis[oc] ?? NS;
  }
  initializeGlobalInstance(e) {
    globalThis[oc] === void 0 && (globalThis[oc] = e);
  }
};
const LS = new PS();
function MS(r = !1) {
  const e = LS.getInstance().getStore();
  if (!r && e === void 0)
    throw new Error(`Could not get the current run tree.

Please make sure you are calling this method within a traceable function and that tracing is enabled.`);
  return e;
}
function _l(r) {
  return typeof r == "function" && "langsmith:traceable" in r;
}
var DS = {};
Ae(DS, { LangChainTracer: () => li });
var li = class lg extends ds {
  constructor(t = {}) {
    super(t);
    b(this, "name", "langchain_tracer");
    b(this, "projectName");
    b(this, "exampleId");
    b(this, "client");
    b(this, "replicas");
    b(this, "usesRunTreeMap", !0);
    const { exampleId: n, projectName: s, client: a, replicas: i } = t;
    this.projectName = s ?? Um(), this.replicas = i, this.exampleId = n, this.client = a ?? ug();
    const o = lg.getTraceableRunTree();
    o && this.updateFromRunTree(o);
  }
  async persistRun(t) {
  }
  async onRunCreate(t) {
    const n = this.getRunTreeWithTracingConfig(t.id);
    await (n == null ? void 0 : n.postRun());
  }
  async onRunUpdate(t) {
    const n = this.getRunTreeWithTracingConfig(t.id);
    await (n == null ? void 0 : n.patchRun());
  }
  getRun(t) {
    return this.runTreeMap.get(t);
  }
  updateFromRunTree(t) {
    this.runTreeMap.set(t.id, t);
    let n = t;
    const s = /* @__PURE__ */ new Set();
    for (; n.parent_run && !(s.has(n.id) || (s.add(n.id), !n.parent_run)); )
      n = n.parent_run;
    s.clear();
    const a = [n];
    for (; a.length > 0; ) {
      const i = a.shift();
      !i || s.has(i.id) || (s.add(i.id), this.runTreeMap.set(i.id, i), i.child_runs && a.push(...i.child_runs));
    }
    this.client = t.client ?? this.client, this.replicas = t.replicas ?? this.replicas, this.projectName = t.project_name ?? this.projectName, this.exampleId = t.reference_example_id ?? this.exampleId;
  }
  getRunTreeWithTracingConfig(t) {
    const n = this.runTreeMap.get(t);
    if (n)
      return new Ct({
        ...n,
        client: this.client,
        project_name: this.projectName,
        replicas: this.replicas,
        reference_example_id: this.exampleId,
        tracingEnabled: !0
      });
  }
  static getTraceableRunTree() {
    try {
      return MS(!0);
    } catch {
      return;
    }
  }
};
let bn;
function jS() {
  const r = "default" in Dr ? Dr.default : Dr;
  return new r({
    autoStart: !0,
    concurrency: 1
  });
}
function FS() {
  return typeof bn > "u" && (bn = jS()), bn;
}
async function rt(r, e) {
  if (e === !0) {
    const t = Gs();
    t !== void 0 ? await t.run(void 0, async () => r()) : await r();
  } else
    bn = FS(), bn.add(async () => {
      const t = Gs();
      t !== void 0 ? await t.run(void 0, async () => r()) : await r();
    });
}
async function US() {
  const r = ug();
  await Promise.allSettled([typeof bn < "u" ? bn.onIdle() : Promise.resolve(), r.awaitPendingTraceBatches()]);
}
var zS = {};
Ae(zS, {
  awaitAllCallbacks: () => US,
  consumeCallback: () => rt
});
const BS = (r) => !![
  "LANGSMITH_TRACING_V2",
  "LANGCHAIN_TRACING_V2",
  "LANGSMITH_TRACING",
  "LANGCHAIN_TRACING"
].find((t) => Er(t) === "true");
function dg(r) {
  var n;
  const e = Gs();
  if (e === void 0) return;
  const t = e.getStore();
  return (n = t == null ? void 0 : t[Us]) == null ? void 0 : n[r];
}
const ZS = Symbol("lc:configure_hooks"), VS = () => dg(ZS) || [];
var qS = {};
Ae(qS, {
  BaseCallbackManager: () => hg,
  BaseRunManager: () => fa,
  CallbackManager: () => Pt,
  CallbackManagerForChainRun: () => pg,
  CallbackManagerForLLMRun: () => Bc,
  CallbackManagerForRetrieverRun: () => fg,
  CallbackManagerForToolRun: () => mg,
  ensureHandler: () => Ks,
  parseCallbackConfigArg: () => mo
});
function mo(r) {
  return r ? Array.isArray(r) || "name" in r ? { callbacks: r } : r : {};
}
var hg = class {
  setHandler(r) {
    return this.setHandlers([r]);
  }
}, fa = class {
  constructor(r, e, t, n, s, a, i, o) {
    this.runId = r, this.handlers = e, this.inheritableHandlers = t, this.tags = n, this.inheritableTags = s, this.metadata = a, this.inheritableMetadata = i, this._parentRunId = o;
  }
  get parentRunId() {
    return this._parentRunId;
  }
  async handleText(r) {
    await Promise.all(this.handlers.map((e) => rt(async () => {
      var t;
      try {
        await ((t = e.handleText) == null ? void 0 : t.call(e, r, this.runId, this._parentRunId, this.tags));
      } catch (n) {
        if ((e.raiseError ? console.error : console.warn)(`Error in handler ${e.constructor.name}, handleText: ${n}`), e.raiseError) throw n;
      }
    }, e.awaitHandlers)));
  }
  async handleCustomEvent(r, e, t, n, s) {
    await Promise.all(this.handlers.map((a) => rt(async () => {
      var i;
      try {
        await ((i = a.handleCustomEvent) == null ? void 0 : i.call(a, r, e, this.runId, this.tags, this.metadata));
      } catch (o) {
        if ((a.raiseError ? console.error : console.warn)(`Error in handler ${a.constructor.name}, handleCustomEvent: ${o}`), a.raiseError) throw o;
      }
    }, a.awaitHandlers)));
  }
}, fg = class extends fa {
  getChild(r) {
    const e = new Pt(this.runId);
    return e.setHandlers(this.inheritableHandlers), e.addTags(this.inheritableTags), e.addMetadata(this.inheritableMetadata), r && e.addTags([r], !1), e;
  }
  async handleRetrieverEnd(r) {
    await Promise.all(this.handlers.map((e) => rt(async () => {
      var t;
      if (!e.ignoreRetriever) try {
        await ((t = e.handleRetrieverEnd) == null ? void 0 : t.call(e, r, this.runId, this._parentRunId, this.tags));
      } catch (n) {
        if ((e.raiseError ? console.error : console.warn)(`Error in handler ${e.constructor.name}, handleRetriever`), e.raiseError) throw n;
      }
    }, e.awaitHandlers)));
  }
  async handleRetrieverError(r) {
    await Promise.all(this.handlers.map((e) => rt(async () => {
      var t;
      if (!e.ignoreRetriever) try {
        await ((t = e.handleRetrieverError) == null ? void 0 : t.call(e, r, this.runId, this._parentRunId, this.tags));
      } catch (n) {
        if ((e.raiseError ? console.error : console.warn)(`Error in handler ${e.constructor.name}, handleRetrieverError: ${n}`), e.raiseError) throw r;
      }
    }, e.awaitHandlers)));
  }
}, Bc = class extends fa {
  async handleLLMNewToken(r, e, t, n, s, a) {
    await Promise.all(this.handlers.map((i) => rt(async () => {
      var o;
      if (!i.ignoreLLM) try {
        await ((o = i.handleLLMNewToken) == null ? void 0 : o.call(i, r, e ?? {
          prompt: 0,
          completion: 0
        }, this.runId, this._parentRunId, this.tags, a));
      } catch (c) {
        if ((i.raiseError ? console.error : console.warn)(`Error in handler ${i.constructor.name}, handleLLMNewToken: ${c}`), i.raiseError) throw c;
      }
    }, i.awaitHandlers)));
  }
  async handleLLMError(r, e, t, n, s) {
    await Promise.all(this.handlers.map((a) => rt(async () => {
      var i;
      if (!a.ignoreLLM) try {
        await ((i = a.handleLLMError) == null ? void 0 : i.call(a, r, this.runId, this._parentRunId, this.tags, s));
      } catch (o) {
        if ((a.raiseError ? console.error : console.warn)(`Error in handler ${a.constructor.name}, handleLLMError: ${o}`), a.raiseError) throw o;
      }
    }, a.awaitHandlers)));
  }
  async handleLLMEnd(r, e, t, n, s) {
    await Promise.all(this.handlers.map((a) => rt(async () => {
      var i;
      if (!a.ignoreLLM) try {
        await ((i = a.handleLLMEnd) == null ? void 0 : i.call(a, r, this.runId, this._parentRunId, this.tags, s));
      } catch (o) {
        if ((a.raiseError ? console.error : console.warn)(`Error in handler ${a.constructor.name}, handleLLMEnd: ${o}`), a.raiseError) throw o;
      }
    }, a.awaitHandlers)));
  }
}, pg = class extends fa {
  getChild(r) {
    const e = new Pt(this.runId);
    return e.setHandlers(this.inheritableHandlers), e.addTags(this.inheritableTags), e.addMetadata(this.inheritableMetadata), r && e.addTags([r], !1), e;
  }
  async handleChainError(r, e, t, n, s) {
    await Promise.all(this.handlers.map((a) => rt(async () => {
      var i;
      if (!a.ignoreChain) try {
        await ((i = a.handleChainError) == null ? void 0 : i.call(a, r, this.runId, this._parentRunId, this.tags, s));
      } catch (o) {
        if ((a.raiseError ? console.error : console.warn)(`Error in handler ${a.constructor.name}, handleChainError: ${o}`), a.raiseError) throw o;
      }
    }, a.awaitHandlers)));
  }
  async handleChainEnd(r, e, t, n, s) {
    await Promise.all(this.handlers.map((a) => rt(async () => {
      var i;
      if (!a.ignoreChain) try {
        await ((i = a.handleChainEnd) == null ? void 0 : i.call(a, r, this.runId, this._parentRunId, this.tags, s));
      } catch (o) {
        if ((a.raiseError ? console.error : console.warn)(`Error in handler ${a.constructor.name}, handleChainEnd: ${o}`), a.raiseError) throw o;
      }
    }, a.awaitHandlers)));
  }
  async handleAgentAction(r) {
    await Promise.all(this.handlers.map((e) => rt(async () => {
      var t;
      if (!e.ignoreAgent) try {
        await ((t = e.handleAgentAction) == null ? void 0 : t.call(e, r, this.runId, this._parentRunId, this.tags));
      } catch (n) {
        if ((e.raiseError ? console.error : console.warn)(`Error in handler ${e.constructor.name}, handleAgentAction: ${n}`), e.raiseError) throw n;
      }
    }, e.awaitHandlers)));
  }
  async handleAgentEnd(r) {
    await Promise.all(this.handlers.map((e) => rt(async () => {
      var t;
      if (!e.ignoreAgent) try {
        await ((t = e.handleAgentEnd) == null ? void 0 : t.call(e, r, this.runId, this._parentRunId, this.tags));
      } catch (n) {
        if ((e.raiseError ? console.error : console.warn)(`Error in handler ${e.constructor.name}, handleAgentEnd: ${n}`), e.raiseError) throw n;
      }
    }, e.awaitHandlers)));
  }
}, mg = class extends fa {
  getChild(r) {
    const e = new Pt(this.runId);
    return e.setHandlers(this.inheritableHandlers), e.addTags(this.inheritableTags), e.addMetadata(this.inheritableMetadata), r && e.addTags([r], !1), e;
  }
  async handleToolError(r) {
    await Promise.all(this.handlers.map((e) => rt(async () => {
      var t;
      if (!e.ignoreAgent) try {
        await ((t = e.handleToolError) == null ? void 0 : t.call(e, r, this.runId, this._parentRunId, this.tags));
      } catch (n) {
        if ((e.raiseError ? console.error : console.warn)(`Error in handler ${e.constructor.name}, handleToolError: ${n}`), e.raiseError) throw n;
      }
    }, e.awaitHandlers)));
  }
  async handleToolEnd(r) {
    await Promise.all(this.handlers.map((e) => rt(async () => {
      var t;
      if (!e.ignoreAgent) try {
        await ((t = e.handleToolEnd) == null ? void 0 : t.call(e, r, this.runId, this._parentRunId, this.tags));
      } catch (n) {
        if ((e.raiseError ? console.error : console.warn)(`Error in handler ${e.constructor.name}, handleToolEnd: ${n}`), e.raiseError) throw n;
      }
    }, e.awaitHandlers)));
  }
}, Pt = class Os extends hg {
  constructor(t, n) {
    super();
    b(this, "handlers", []);
    b(this, "inheritableHandlers", []);
    b(this, "tags", []);
    b(this, "inheritableTags", []);
    b(this, "metadata", {});
    b(this, "inheritableMetadata", {});
    b(this, "name", "callback_manager");
    b(this, "_parentRunId");
    this.handlers = (n == null ? void 0 : n.handlers) ?? this.handlers, this.inheritableHandlers = (n == null ? void 0 : n.inheritableHandlers) ?? this.inheritableHandlers, this.tags = (n == null ? void 0 : n.tags) ?? this.tags, this.inheritableTags = (n == null ? void 0 : n.inheritableTags) ?? this.inheritableTags, this.metadata = (n == null ? void 0 : n.metadata) ?? this.metadata, this.inheritableMetadata = (n == null ? void 0 : n.inheritableMetadata) ?? this.inheritableMetadata, this._parentRunId = t;
  }
  /**
  * Gets the parent run ID, if any.
  *
  * @returns The parent run ID.
  */
  getParentRunId() {
    return this._parentRunId;
  }
  async handleLLMStart(t, n, s = void 0, a = void 0, i = void 0, o = void 0, c = void 0, u = void 0) {
    return Promise.all(n.map(async (l, d) => {
      const h = d === 0 && s ? s : Lr();
      return await Promise.all(this.handlers.map((f) => {
        if (!f.ignoreLLM)
          return Un(f) && f._createRunForLLMStart(t, [l], h, this._parentRunId, i, this.tags, this.metadata, u), rt(async () => {
            var p;
            try {
              await ((p = f.handleLLMStart) == null ? void 0 : p.call(f, t, [l], h, this._parentRunId, i, this.tags, this.metadata, u));
            } catch (y) {
              if ((f.raiseError ? console.error : console.warn)(`Error in handler ${f.constructor.name}, handleLLMStart: ${y}`), f.raiseError) throw y;
            }
          }, f.awaitHandlers);
      })), new Bc(h, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);
    }));
  }
  async handleChatModelStart(t, n, s = void 0, a = void 0, i = void 0, o = void 0, c = void 0, u = void 0) {
    return Promise.all(n.map(async (l, d) => {
      const h = d === 0 && s ? s : Lr();
      return await Promise.all(this.handlers.map((f) => {
        if (!f.ignoreLLM)
          return Un(f) && f._createRunForChatModelStart(t, [l], h, this._parentRunId, i, this.tags, this.metadata, u), rt(async () => {
            var p, y;
            try {
              if (f.handleChatModelStart) await ((p = f.handleChatModelStart) == null ? void 0 : p.call(f, t, [l], h, this._parentRunId, i, this.tags, this.metadata, u));
              else if (f.handleLLMStart) {
                const m = al(l);
                await ((y = f.handleLLMStart) == null ? void 0 : y.call(f, t, [m], h, this._parentRunId, i, this.tags, this.metadata, u));
              }
            } catch (m) {
              if ((f.raiseError ? console.error : console.warn)(`Error in handler ${f.constructor.name}, handleLLMStart: ${m}`), f.raiseError) throw m;
            }
          }, f.awaitHandlers);
      })), new Bc(h, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);
    }));
  }
  async handleChainStart(t, n, s = Lr(), a = void 0, i = void 0, o = void 0, c = void 0) {
    return await Promise.all(this.handlers.map((u) => {
      if (!u.ignoreChain)
        return Un(u) && u._createRunForChainStart(t, n, s, this._parentRunId, this.tags, this.metadata, a, c), rt(async () => {
          var l;
          try {
            await ((l = u.handleChainStart) == null ? void 0 : l.call(u, t, n, s, this._parentRunId, this.tags, this.metadata, a, c));
          } catch (d) {
            if ((u.raiseError ? console.error : console.warn)(`Error in handler ${u.constructor.name}, handleChainStart: ${d}`), u.raiseError) throw d;
          }
        }, u.awaitHandlers);
    })), new pg(s, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);
  }
  async handleToolStart(t, n, s = Lr(), a = void 0, i = void 0, o = void 0, c = void 0) {
    return await Promise.all(this.handlers.map((u) => {
      if (!u.ignoreAgent)
        return Un(u) && u._createRunForToolStart(t, n, s, this._parentRunId, this.tags, this.metadata, c), rt(async () => {
          var l;
          try {
            await ((l = u.handleToolStart) == null ? void 0 : l.call(u, t, n, s, this._parentRunId, this.tags, this.metadata, c));
          } catch (d) {
            if ((u.raiseError ? console.error : console.warn)(`Error in handler ${u.constructor.name}, handleToolStart: ${d}`), u.raiseError) throw d;
          }
        }, u.awaitHandlers);
    })), new mg(s, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);
  }
  async handleRetrieverStart(t, n, s = Lr(), a = void 0, i = void 0, o = void 0, c = void 0) {
    return await Promise.all(this.handlers.map((u) => {
      if (!u.ignoreRetriever)
        return Un(u) && u._createRunForRetrieverStart(t, n, s, this._parentRunId, this.tags, this.metadata, c), rt(async () => {
          var l;
          try {
            await ((l = u.handleRetrieverStart) == null ? void 0 : l.call(u, t, n, s, this._parentRunId, this.tags, this.metadata, c));
          } catch (d) {
            if ((u.raiseError ? console.error : console.warn)(`Error in handler ${u.constructor.name}, handleRetrieverStart: ${d}`), u.raiseError) throw d;
          }
        }, u.awaitHandlers);
    })), new fg(s, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);
  }
  async handleCustomEvent(t, n, s, a, i) {
    await Promise.all(this.handlers.map((o) => rt(async () => {
      var c;
      if (!o.ignoreCustomEvent) try {
        await ((c = o.handleCustomEvent) == null ? void 0 : c.call(o, t, n, s, this.tags, this.metadata));
      } catch (u) {
        if ((o.raiseError ? console.error : console.warn)(`Error in handler ${o.constructor.name}, handleCustomEvent: ${u}`), o.raiseError) throw u;
      }
    }, o.awaitHandlers)));
  }
  addHandler(t, n = !0) {
    this.handlers.push(t), n && this.inheritableHandlers.push(t);
  }
  removeHandler(t) {
    this.handlers = this.handlers.filter((n) => n !== t), this.inheritableHandlers = this.inheritableHandlers.filter((n) => n !== t);
  }
  setHandlers(t, n = !0) {
    this.handlers = [], this.inheritableHandlers = [];
    for (const s of t) this.addHandler(s, n);
  }
  addTags(t, n = !0) {
    this.removeTags(t), this.tags.push(...t), n && this.inheritableTags.push(...t);
  }
  removeTags(t) {
    this.tags = this.tags.filter((n) => !t.includes(n)), this.inheritableTags = this.inheritableTags.filter((n) => !t.includes(n));
  }
  addMetadata(t, n = !0) {
    this.metadata = {
      ...this.metadata,
      ...t
    }, n && (this.inheritableMetadata = {
      ...this.inheritableMetadata,
      ...t
    });
  }
  removeMetadata(t) {
    for (const n of Object.keys(t))
      delete this.metadata[n], delete this.inheritableMetadata[n];
  }
  copy(t = [], n = !0) {
    const s = new Os(this._parentRunId);
    for (const a of this.handlers) {
      const i = this.inheritableHandlers.includes(a);
      s.addHandler(a, i);
    }
    for (const a of this.tags) {
      const i = this.inheritableTags.includes(a);
      s.addTags([a], i);
    }
    for (const a of Object.keys(this.metadata)) {
      const i = Object.keys(this.inheritableMetadata).includes(a);
      s.addMetadata({ [a]: this.metadata[a] }, i);
    }
    for (const a of t)
      s.handlers.filter((i) => i.name === "console_callback_handler").some((i) => i.name === a.name) || s.addHandler(a, n);
    return s;
  }
  static fromHandlers(t) {
    class n extends da {
      constructor() {
        super();
        b(this, "name", Lr());
        Object.assign(this, t);
      }
    }
    const s = new this();
    return s.addHandler(new n()), s;
  }
  static configure(t, n, s, a, i, o, c) {
    return this._configureSync(t, n, s, a, i, o, c);
  }
  static _configureSync(t, n, s, a, i, o, c) {
    var f;
    let u;
    (t || n) && (Array.isArray(t) || !t ? (u = new Os(), u.setHandlers((t == null ? void 0 : t.map(Ks)) ?? [], !0)) : u = t, u = u.copy(Array.isArray(n) ? n.map(Ks) : n == null ? void 0 : n.handlers, !1));
    const l = Er("LANGCHAIN_VERBOSE") === "true" || (c == null ? void 0 : c.verbose), d = ((f = li.getTraceableRunTree()) == null ? void 0 : f.tracingEnabled) || BS(), h = d || (Er("LANGCHAIN_TRACING") ?? !1);
    if (l || h) {
      if (u || (u = new Os()), l && !u.handlers.some((p) => p.name === zc.prototype.name)) {
        const p = new zc();
        u.addHandler(p, !0);
      }
      if (h && !u.handlers.some((p) => p.name === "langchain_tracer") && d) {
        const p = new li();
        u.addHandler(p, !0);
      }
      if (d) {
        const p = li.getTraceableRunTree();
        if (p && u._parentRunId === void 0) {
          u._parentRunId = p.id;
          const y = u.handlers.find((m) => m.name === "langchain_tracer");
          y == null || y.updateFromRunTree(p);
        }
      }
    }
    for (const { contextVar: p, inheritable: y = !0, handlerClass: m, envVar: v } of VS()) {
      const g = v && Er(v) === "true" && m;
      let w;
      const T = p !== void 0 ? dg(p) : void 0;
      T && Dm(T) ? w = T : g && (w = new m({})), w !== void 0 && (u || (u = new Os()), u.handlers.some((x) => x.name === w.name) || u.addHandler(w, y));
    }
    return (s || a) && u && (u.addTags(s ?? []), u.addTags(a ?? [], !1)), (i || o) && u && (u.addMetadata(i ?? {}), u.addMetadata(o ?? {}, !1)), u;
  }
};
function Ks(r) {
  return "name" in r ? r : da.fromMethods(r);
}
var gg = class {
  getStore() {
  }
  run(r, e) {
    return e();
  }
  enterWith(r) {
  }
};
const JS = new gg(), lh = Symbol.for("lc:child_config");
var HS = class {
  getInstance() {
    return Gs() ?? JS;
  }
  getRunnableConfig() {
    var e, t;
    return (t = (e = this.getInstance().getStore()) == null ? void 0 : e.extra) == null ? void 0 : t[lh];
  }
  runWithConfig(r, e, t) {
    var u;
    const n = Pt._configureSync(r == null ? void 0 : r.callbacks, void 0, r == null ? void 0 : r.tags, void 0, r == null ? void 0 : r.metadata), s = this.getInstance(), a = s.getStore(), i = n == null ? void 0 : n.getParentRunId(), o = (u = n == null ? void 0 : n.handlers) == null ? void 0 : u.find((l) => (l == null ? void 0 : l.name) === "langchain_tracer");
    let c;
    return o && i ? c = o.getRunTreeWithTracingConfig(i) : t || (c = new Ct({
      name: "<runnable_lambda>",
      tracingEnabled: !1
    })), c && (c.extra = {
      ...c.extra,
      [lh]: r
    }), a !== void 0 && a[Us] !== void 0 && (c === void 0 && (c = {}), c[Us] = a[Us]), s.run(c, e);
  }
  initializeGlobalInstance(r) {
    Gs() === void 0 && Mv(r);
  }
};
const lr = new HS();
var GS = {};
Ae(GS, {
  AsyncLocalStorageProviderSingleton: () => lr,
  MockAsyncLocalStorage: () => gg,
  _CONTEXT_VARIABLES_KEY: () => Us
});
const cc = 25;
async function Zt(r) {
  return Pt._configureSync(r == null ? void 0 : r.callbacks, void 0, r == null ? void 0 : r.tags, void 0, r == null ? void 0 : r.metadata);
}
function ki(...r) {
  const e = {};
  for (const t of r.filter((n) => !!n)) for (const n of Object.keys(t)) if (n === "metadata") e[n] = {
    ...e[n],
    ...t[n]
  };
  else if (n === "tags") {
    const s = e[n] ?? [];
    e[n] = [...new Set(s.concat(t[n] ?? []))];
  } else if (n === "configurable") e[n] = {
    ...e[n],
    ...t[n]
  };
  else if (n === "timeout")
    e.timeout === void 0 ? e.timeout = t.timeout : t.timeout !== void 0 && (e.timeout = Math.min(e.timeout, t.timeout));
  else if (n === "signal")
    e.signal === void 0 ? e.signal = t.signal : t.signal !== void 0 && ("any" in AbortSignal ? e.signal = AbortSignal.any([e.signal, t.signal]) : e.signal = t.signal);
  else if (n === "callbacks") {
    const s = e.callbacks, a = t.callbacks;
    if (Array.isArray(a)) if (!s) e.callbacks = a;
    else if (Array.isArray(s)) e.callbacks = s.concat(a);
    else {
      const i = s.copy();
      for (const o of a) i.addHandler(Ks(o), !0);
      e.callbacks = i;
    }
    else if (a) if (!s) e.callbacks = a;
    else if (Array.isArray(s)) {
      const i = a.copy();
      for (const o of s) i.addHandler(Ks(o), !0);
      e.callbacks = i;
    } else e.callbacks = new Pt(a._parentRunId, {
      handlers: s.handlers.concat(a.handlers),
      inheritableHandlers: s.inheritableHandlers.concat(a.inheritableHandlers),
      tags: Array.from(new Set(s.tags.concat(a.tags))),
      inheritableTags: Array.from(new Set(s.inheritableTags.concat(a.inheritableTags))),
      metadata: {
        ...s.metadata,
        ...a.metadata
      }
    });
  } else {
    const s = n;
    e[s] = t[s] ?? e[s];
  }
  return e;
}
const WS = /* @__PURE__ */ new Set([
  "string",
  "number",
  "boolean"
]);
function Ce(r) {
  var n;
  const e = lr.getRunnableConfig();
  let t = {
    tags: [],
    metadata: {},
    recursionLimit: 25,
    runId: void 0
  };
  if (e) {
    const { runId: s, runName: a, ...i } = e;
    t = Object.entries(i).reduce((o, [c, u]) => (u !== void 0 && (o[c] = u), o), t);
  }
  if (r && (t = Object.entries(r).reduce((s, [a, i]) => (i !== void 0 && (s[a] = i), s), t)), t != null && t.configurable)
    for (const s of Object.keys(t.configurable)) WS.has(typeof t.configurable[s]) && !((n = t.metadata) != null && n[s]) && (t.metadata || (t.metadata = {}), t.metadata[s] = t.configurable[s]);
  if (t.timeout !== void 0) {
    if (t.timeout <= 0) throw new Error("Timeout must be a positive number");
    const s = AbortSignal.timeout(t.timeout);
    t.signal !== void 0 ? "any" in AbortSignal && (t.signal = AbortSignal.any([t.signal, s])) : t.signal = s, delete t.timeout;
  }
  return t;
}
function Be(r = {}, { callbacks: e, maxConcurrency: t, recursionLimit: n, runName: s, configurable: a, runId: i } = {}) {
  const o = Ce(r);
  return e !== void 0 && (delete o.runName, o.callbacks = e), n !== void 0 && (o.recursionLimit = n), t !== void 0 && (o.maxConcurrency = t), s !== void 0 && (o.runName = s), a !== void 0 && (o.configurable = {
    ...o.configurable,
    ...a
  }), i !== void 0 && delete o.runId, o;
}
function Ur(r) {
  if (r)
    return {
      configurable: r.configurable,
      recursionLimit: r.recursionLimit,
      callbacks: r.callbacks,
      tags: r.tags,
      metadata: r.metadata,
      maxConcurrency: r.maxConcurrency,
      timeout: r.timeout,
      signal: r.signal,
      store: r.store
    };
}
async function zr(r, e) {
  if (e === void 0) return r;
  let t;
  return Promise.race([r.catch((n) => {
    if (!(e != null && e.aborted))
      throw n;
  }), new Promise((n, s) => {
    t = () => {
      s(Ys(e));
    }, e.addEventListener("abort", t), e.aborted && s(Ys(e));
  })]).finally(() => e.removeEventListener("abort", t));
}
function Ys(r) {
  return (r == null ? void 0 : r.reason) instanceof Error ? r.reason : typeof (r == null ? void 0 : r.reason) == "string" ? new Error(r.reason) : /* @__PURE__ */ new Error("Aborted");
}
var KS = {};
Ae(KS, {
  AsyncGeneratorWithSetup: () => On,
  IterableReadableStream: () => dr,
  atee: () => yl,
  concat: () => an,
  pipeGeneratorWithSetup: () => _g
});
var dr = class Zc extends ReadableStream {
  constructor() {
    super(...arguments);
    b(this, "reader");
  }
  ensureReader() {
    this.reader || (this.reader = this.getReader());
  }
  async next() {
    this.ensureReader();
    try {
      const t = await this.reader.read();
      return t.done ? (this.reader.releaseLock(), {
        done: !0,
        value: void 0
      }) : {
        done: !1,
        value: t.value
      };
    } catch (t) {
      throw this.reader.releaseLock(), t;
    }
  }
  async return() {
    if (this.ensureReader(), this.locked) {
      const t = this.reader.cancel();
      this.reader.releaseLock(), await t;
    }
    return {
      done: !0,
      value: void 0
    };
  }
  async throw(t) {
    if (this.ensureReader(), this.locked) {
      const n = this.reader.cancel();
      this.reader.releaseLock(), await n;
    }
    throw t;
  }
  [Symbol.asyncIterator]() {
    return this;
  }
  async [Symbol.asyncDispose]() {
    await this.return();
  }
  static fromReadableStream(t) {
    const n = t.getReader();
    return new Zc({
      start(s) {
        return a();
        function a() {
          return n.read().then(({ done: i, value: o }) => {
            if (i) {
              s.close();
              return;
            }
            return s.enqueue(o), a();
          });
        }
      },
      cancel() {
        n.releaseLock();
      }
    });
  }
  static fromAsyncGenerator(t) {
    return new Zc({
      async pull(n) {
        const { value: s, done: a } = await t.next();
        a && n.close(), n.enqueue(s);
      },
      async cancel(n) {
        await t.return(n);
      }
    });
  }
};
function yl(r, e = 2) {
  const t = Array.from({ length: e }, () => []);
  return t.map(async function* (s) {
    for (; ; ) if (s.length === 0) {
      const a = await r.next();
      for (const i of t) i.push(a);
    } else {
      if (s[0].done) return;
      yield s.shift().value;
    }
  });
}
function an(r, e) {
  if (Array.isArray(r) && Array.isArray(e)) return r.concat(e);
  if (typeof r == "string" && typeof e == "string") return r + e;
  if (typeof r == "number" && typeof e == "number") return r + e;
  if ("concat" in r && typeof r.concat == "function") return r.concat(e);
  if (typeof r == "object" && typeof e == "object") {
    const t = { ...r };
    for (const [n, s] of Object.entries(e)) n in t && !Array.isArray(t[n]) ? t[n] = an(t[n], s) : t[n] = s;
    return t;
  } else throw new Error(`Cannot concat ${typeof r} and ${typeof e}`);
}
var On = class {
  constructor(r) {
    b(this, "generator");
    b(this, "setup");
    b(this, "config");
    b(this, "signal");
    b(this, "firstResult");
    b(this, "firstResultUsed", !1);
    var e;
    this.generator = r.generator, this.config = r.config, this.signal = r.signal ?? ((e = this.config) == null ? void 0 : e.signal), this.setup = new Promise((t, n) => {
      lr.runWithConfig(Ur(r.config), async () => {
        this.firstResult = r.generator.next(), r.startSetup ? this.firstResult.then(r.startSetup).then(t, n) : this.firstResult.then((s) => t(void 0), n);
      }, !0);
    });
  }
  async next(...r) {
    var e;
    return (e = this.signal) == null || e.throwIfAborted(), this.firstResultUsed ? lr.runWithConfig(Ur(this.config), this.signal ? async () => zr(this.generator.next(...r), this.signal) : async () => this.generator.next(...r), !0) : (this.firstResultUsed = !0, this.firstResult);
  }
  async return(r) {
    return this.generator.return(r);
  }
  async throw(r) {
    return this.generator.throw(r);
  }
  [Symbol.asyncIterator]() {
    return this;
  }
  async [Symbol.asyncDispose]() {
    await this.return();
  }
};
async function _g(r, e, t, n, ...s) {
  const a = new On({
    generator: e,
    startSetup: t,
    signal: n
  }), i = await a.setup;
  return {
    output: r(a, i, ...s),
    setup: i
  };
}
/*!
* https://github.com/Starcounter-Jack/JSON-Patch
* (c) 2017-2022 Joachim Wester
* MIT licensed
*/
const YS = Object.prototype.hasOwnProperty;
function Vc(r, e) {
  return YS.call(r, e);
}
function qc(r) {
  if (Array.isArray(r)) {
    const t = new Array(r.length);
    for (let n = 0; n < t.length; n++) t[n] = "" + n;
    return t;
  }
  if (Object.keys) return Object.keys(r);
  let e = [];
  for (let t in r) Vc(r, t) && e.push(t);
  return e;
}
function cr(r) {
  switch (typeof r) {
    case "object":
      return JSON.parse(JSON.stringify(r));
    case "undefined":
      return null;
    default:
      return r;
  }
}
function Jc(r) {
  let e = 0;
  const t = r.length;
  let n;
  for (; e < t; ) {
    if (n = r.charCodeAt(e), n >= 48 && n <= 57) {
      e++;
      continue;
    }
    return !1;
  }
  return !0;
}
function Ln(r) {
  return r.indexOf("/") === -1 && r.indexOf("~") === -1 ? r : r.replace(/~/g, "~0").replace(/\//g, "~1");
}
function XS(r) {
  return r.replace(/~1/g, "/").replace(/~0/g, "~");
}
function Hc(r) {
  if (r === void 0) return !0;
  if (r) {
    if (Array.isArray(r)) {
      for (let t = 0, n = r.length; t < n; t++) if (Hc(r[t])) return !0;
    } else if (typeof r == "object") {
      const t = qc(r), n = t.length;
      for (var e = 0; e < n; e++) if (Hc(r[t[e]])) return !0;
    }
  }
  return !1;
}
function dh(r, e) {
  const t = [r];
  for (const n in e) {
    const s = typeof e[n] == "object" ? JSON.stringify(e[n], null, 2) : e[n];
    typeof s < "u" && t.push(`${n}: ${s}`);
  }
  return t.join(`
`);
}
var QS = class extends Error {
  constructor(r, e, t, n, s) {
    super(dh(r, {
      name: e,
      index: t,
      operation: n,
      tree: s
    })), this.name = e, this.index = t, this.operation = n, this.tree = s, Object.setPrototypeOf(this, new.target.prototype), this.message = dh(r, {
      name: e,
      index: t,
      operation: n,
      tree: s
    });
  }
}, yg = {};
Ae(yg, {
  JsonPatchError: () => Ke,
  _areEquals: () => Xs,
  applyOperation: () => Sn,
  applyPatch: () => Xn,
  applyReducer: () => rT,
  deepClone: () => eT,
  getValueByPointer: () => Ii,
  validate: () => wg,
  validator: () => Oi
});
const Ke = QS, eT = cr, qn = {
  add: function(r, e, t) {
    return r[e] = this.value, { newDocument: t };
  },
  remove: function(r, e, t) {
    var n = r[e];
    return delete r[e], {
      newDocument: t,
      removed: n
    };
  },
  replace: function(r, e, t) {
    var n = r[e];
    return r[e] = this.value, {
      newDocument: t,
      removed: n
    };
  },
  move: function(r, e, t) {
    let n = Ii(t, this.path);
    n && (n = cr(n));
    const s = Sn(t, {
      op: "remove",
      path: this.from
    }).removed;
    return Sn(t, {
      op: "add",
      path: this.path,
      value: s
    }), {
      newDocument: t,
      removed: n
    };
  },
  copy: function(r, e, t) {
    const n = Ii(t, this.from);
    return Sn(t, {
      op: "add",
      path: this.path,
      value: cr(n)
    }), { newDocument: t };
  },
  test: function(r, e, t) {
    return {
      newDocument: t,
      test: Xs(r[e], this.value)
    };
  },
  _get: function(r, e, t) {
    return this.value = r[e], { newDocument: t };
  }
};
var tT = {
  add: function(r, e, t) {
    return Jc(e) ? r.splice(e, 0, this.value) : r[e] = this.value, {
      newDocument: t,
      index: e
    };
  },
  remove: function(r, e, t) {
    var n = r.splice(e, 1);
    return {
      newDocument: t,
      removed: n[0]
    };
  },
  replace: function(r, e, t) {
    var n = r[e];
    return r[e] = this.value, {
      newDocument: t,
      removed: n
    };
  },
  move: qn.move,
  copy: qn.copy,
  test: qn.test,
  _get: qn._get
};
function Ii(r, e) {
  if (e == "") return r;
  var t = {
    op: "_get",
    path: e
  };
  return Sn(r, t), t.value;
}
function Sn(r, e, t = !1, n = !0, s = !0, a = 0) {
  if (t && (typeof t == "function" ? t(e, 0, r, e.path) : Oi(e, 0)), e.path === "") {
    let i = { newDocument: r };
    if (e.op === "add")
      return i.newDocument = e.value, i;
    if (e.op === "replace")
      return i.newDocument = e.value, i.removed = r, i;
    if (e.op === "move" || e.op === "copy")
      return i.newDocument = Ii(r, e.from), e.op === "move" && (i.removed = r), i;
    if (e.op === "test") {
      if (i.test = Xs(r, e.value), i.test === !1) throw new Ke("Test operation failed", "TEST_OPERATION_FAILED", a, e, r);
      return i.newDocument = r, i;
    } else {
      if (e.op === "remove")
        return i.removed = r, i.newDocument = null, i;
      if (e.op === "_get")
        return e.value = r, i;
      if (t) throw new Ke("Operation `op` property is not one of operations defined in RFC-6902", "OPERATION_OP_INVALID", a, e, r);
      return i;
    }
  } else {
    n || (r = cr(r));
    const o = (e.path || "").split("/");
    let c = r, u = 1, l = o.length, d, h, f;
    for (typeof t == "function" ? f = t : f = Oi; ; ) {
      if (h = o[u], h && h.indexOf("~") != -1 && (h = XS(h)), s && (h == "__proto__" || h == "prototype" && u > 0 && o[u - 1] == "constructor")) throw new TypeError("JSON-Patch: modifying `__proto__` or `constructor/prototype` prop is banned for security reasons, if this was on purpose, please set `banPrototypeModifications` flag false and pass it to this function. More info in fast-json-patch README");
      if (t && d === void 0 && (c[h] === void 0 ? d = o.slice(0, u).join("/") : u == l - 1 && (d = e.path), d !== void 0 && f(e, 0, r, d)), u++, Array.isArray(c)) {
        if (h === "-") h = c.length;
        else {
          if (t && !Jc(h)) throw new Ke("Expected an unsigned base-10 integer value, making the new referenced value the array element with the zero-based index", "OPERATION_PATH_ILLEGAL_ARRAY_INDEX", a, e, r);
          Jc(h) && (h = ~~h);
        }
        if (u >= l) {
          if (t && e.op === "add" && h > c.length) throw new Ke("The specified index MUST NOT be greater than the number of elements in the array", "OPERATION_VALUE_OUT_OF_BOUNDS", a, e, r);
          const p = tT[e.op].call(e, c, h, r);
          if (p.test === !1) throw new Ke("Test operation failed", "TEST_OPERATION_FAILED", a, e, r);
          return p;
        }
      } else if (u >= l) {
        const p = qn[e.op].call(e, c, h, r);
        if (p.test === !1) throw new Ke("Test operation failed", "TEST_OPERATION_FAILED", a, e, r);
        return p;
      }
      if (c = c[h], t && u < l && (!c || typeof c != "object")) throw new Ke("Cannot perform operation at the desired path", "OPERATION_PATH_UNRESOLVABLE", a, e, r);
    }
  }
}
function Xn(r, e, t, n = !0, s = !0) {
  if (t && !Array.isArray(e))
    throw new Ke("Patch sequence must be an array", "SEQUENCE_NOT_AN_ARRAY");
  n || (r = cr(r));
  const a = new Array(e.length);
  for (let i = 0, o = e.length; i < o; i++)
    a[i] = Sn(r, e[i], t, !0, s, i), r = a[i].newDocument;
  return a.newDocument = r, a;
}
function rT(r, e, t) {
  const n = Sn(r, e);
  if (n.test === !1) throw new Ke("Test operation failed", "TEST_OPERATION_FAILED", t, e, r);
  return n.newDocument;
}
function Oi(r, e, t, n) {
  if (typeof r != "object" || r === null || Array.isArray(r)) throw new Ke("Operation is not an object", "OPERATION_NOT_AN_OBJECT", e, r, t);
  if (qn[r.op]) {
    if (typeof r.path != "string") throw new Ke("Operation `path` property is not a string", "OPERATION_PATH_INVALID", e, r, t);
    if (r.path.indexOf("/") !== 0 && r.path.length > 0) throw new Ke('Operation `path` property must start with "/"', "OPERATION_PATH_INVALID", e, r, t);
    if ((r.op === "move" || r.op === "copy") && typeof r.from != "string") throw new Ke("Operation `from` property is not present (applicable in `move` and `copy` operations)", "OPERATION_FROM_REQUIRED", e, r, t);
    if ((r.op === "add" || r.op === "replace" || r.op === "test") && r.value === void 0) throw new Ke("Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)", "OPERATION_VALUE_REQUIRED", e, r, t);
    if ((r.op === "add" || r.op === "replace" || r.op === "test") && Hc(r.value)) throw new Ke("Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)", "OPERATION_VALUE_CANNOT_CONTAIN_UNDEFINED", e, r, t);
    if (t) {
      if (r.op == "add") {
        var s = r.path.split("/").length, a = n.split("/").length;
        if (s !== a + 1 && s !== a) throw new Ke("Cannot perform an `add` operation at the desired path", "OPERATION_PATH_CANNOT_ADD", e, r, t);
      } else if (r.op === "replace" || r.op === "remove" || r.op === "_get") {
        if (r.path !== n) throw new Ke("Cannot perform the operation at a path that does not exist", "OPERATION_PATH_UNRESOLVABLE", e, r, t);
      } else if (r.op === "move" || r.op === "copy") {
        var i = {
          op: "_get",
          path: r.from,
          value: void 0
        }, o = wg([i], t);
        if (o && o.name === "OPERATION_PATH_UNRESOLVABLE") throw new Ke("Cannot perform the operation from a path that does not exist", "OPERATION_FROM_UNRESOLVABLE", e, r, t);
      }
    }
  } else throw new Ke("Operation `op` property is not one of operations defined in RFC-6902", "OPERATION_OP_INVALID", e, r, t);
}
function wg(r, e, t) {
  try {
    if (!Array.isArray(r)) throw new Ke("Patch sequence must be an array", "SEQUENCE_NOT_AN_ARRAY");
    if (e) Xn(cr(e), cr(r), t || !0);
    else {
      t = t || Oi;
      for (var n = 0; n < r.length; n++) t(r[n], n, e, void 0);
    }
  } catch (s) {
    if (s instanceof Ke) return s;
    throw s;
  }
}
function Xs(r, e) {
  if (r === e) return !0;
  if (r && e && typeof r == "object" && typeof e == "object") {
    var t = Array.isArray(r), n = Array.isArray(e), s, a, i;
    if (t && n) {
      if (a = r.length, a != e.length) return !1;
      for (s = a; s-- !== 0; ) if (!Xs(r[s], e[s])) return !1;
      return !0;
    }
    if (t != n) return !1;
    var o = Object.keys(r);
    if (a = o.length, a !== Object.keys(e).length) return !1;
    for (s = a; s-- !== 0; ) if (!e.hasOwnProperty(o[s])) return !1;
    for (s = a; s-- !== 0; )
      if (i = o[s], !Xs(r[i], e[i])) return !1;
    return !0;
  }
  return r !== r && e !== e;
}
function vg(r, e, t, n, s) {
  if (e !== r) {
    typeof e.toJSON == "function" && (e = e.toJSON());
    for (var a = qc(e), i = qc(r), o = !1, c = i.length - 1; c >= 0; c--) {
      var u = i[c], l = r[u];
      if (Vc(e, u) && !(e[u] === void 0 && l !== void 0 && Array.isArray(e) === !1)) {
        var d = e[u];
        typeof l == "object" && l != null && typeof d == "object" && d != null && Array.isArray(l) === Array.isArray(d) ? vg(l, d, t, n + "/" + Ln(u), s) : l !== d && (s && t.push({
          op: "test",
          path: n + "/" + Ln(u),
          value: cr(l)
        }), t.push({
          op: "replace",
          path: n + "/" + Ln(u),
          value: cr(d)
        }));
      } else Array.isArray(r) === Array.isArray(e) ? (s && t.push({
        op: "test",
        path: n + "/" + Ln(u),
        value: cr(l)
      }), t.push({
        op: "remove",
        path: n + "/" + Ln(u)
      }), o = !0) : (s && t.push({
        op: "test",
        path: n,
        value: r
      }), t.push({
        op: "replace",
        path: n,
        value: e
      }));
    }
    if (!(!o && a.length == i.length))
      for (var c = 0; c < a.length; c++) {
        var u = a[c];
        !Vc(r, u) && e[u] !== void 0 && t.push({
          op: "add",
          path: n + "/" + Ln(u),
          value: cr(e[u])
        });
      }
  }
}
function wl(r, e, t = !1) {
  var n = [];
  return vg(r, e, n, "", t), n;
}
({
  ...yg
});
var nT = {};
Ae(nT, {
  LogStreamCallbackHandler: () => Wc,
  RunLog: () => vl,
  RunLogPatch: () => Mr,
  isLogStreamHandler: () => bg
});
var Mr = class {
  constructor(r) {
    b(this, "ops");
    this.ops = r.ops ?? [];
  }
  concat(r) {
    const e = this.ops.concat(r.ops), t = Xn({}, e);
    return new vl({
      ops: e,
      state: t[t.length - 1].newDocument
    });
  }
}, vl = class Gc extends Mr {
  constructor(t) {
    super(t);
    b(this, "state");
    this.state = t.state;
  }
  concat(t) {
    const n = this.ops.concat(t.ops), s = Xn(this.state, t.ops);
    return new Gc({
      ops: n,
      state: s[s.length - 1].newDocument
    });
  }
  static fromRunLogPatch(t) {
    const n = Xn({}, t.ops);
    return new Gc({
      ops: t.ops,
      state: n[n.length - 1].newDocument
    });
  }
};
const bg = (r) => r.name === "log_stream_tracer";
async function hh(r, e) {
  if (e === "original") throw new Error("Do not assign inputs with original schema drop the key for now. When inputs are added to streamLog they should be added with standardized schema for streaming events.");
  const { inputs: t } = r;
  if ([
    "retriever",
    "llm",
    "prompt"
  ].includes(r.run_type)) return t;
  if (!(Object.keys(t).length === 1 && (t == null ? void 0 : t.input) === ""))
    return t.input;
}
async function fh(r, e) {
  const { outputs: t } = r;
  return e === "original" || [
    "retriever",
    "llm",
    "prompt"
  ].includes(r.run_type) ? t : t !== void 0 && Object.keys(t).length === 1 && (t == null ? void 0 : t.output) !== void 0 ? t.output : t;
}
function sT(r) {
  return r !== void 0 && r.message !== void 0;
}
var Wc = class extends ds {
  constructor(e) {
    super({
      _awaitHandler: !0,
      ...e
    });
    b(this, "autoClose", !0);
    b(this, "includeNames");
    b(this, "includeTypes");
    b(this, "includeTags");
    b(this, "excludeNames");
    b(this, "excludeTypes");
    b(this, "excludeTags");
    b(this, "_schemaFormat", "original");
    b(this, "rootId");
    b(this, "keyMapByRunId", {});
    b(this, "counterMapByRunName", {});
    b(this, "transformStream");
    b(this, "writer");
    b(this, "receiveStream");
    b(this, "name", "log_stream_tracer");
    b(this, "lc_prefer_streaming", !0);
    this.autoClose = (e == null ? void 0 : e.autoClose) ?? !0, this.includeNames = e == null ? void 0 : e.includeNames, this.includeTypes = e == null ? void 0 : e.includeTypes, this.includeTags = e == null ? void 0 : e.includeTags, this.excludeNames = e == null ? void 0 : e.excludeNames, this.excludeTypes = e == null ? void 0 : e.excludeTypes, this.excludeTags = e == null ? void 0 : e.excludeTags, this._schemaFormat = (e == null ? void 0 : e._schemaFormat) ?? this._schemaFormat, this.transformStream = new TransformStream(), this.writer = this.transformStream.writable.getWriter(), this.receiveStream = dr.fromReadableStream(this.transformStream.readable);
  }
  [Symbol.asyncIterator]() {
    return this.receiveStream;
  }
  async persistRun(e) {
  }
  _includeRun(e) {
    if (e.id === this.rootId) return !1;
    const t = e.tags ?? [];
    let n = this.includeNames === void 0 && this.includeTags === void 0 && this.includeTypes === void 0;
    return this.includeNames !== void 0 && (n = n || this.includeNames.includes(e.name)), this.includeTypes !== void 0 && (n = n || this.includeTypes.includes(e.run_type)), this.includeTags !== void 0 && (n = n || t.find((s) => {
      var a;
      return (a = this.includeTags) == null ? void 0 : a.includes(s);
    }) !== void 0), this.excludeNames !== void 0 && (n = n && !this.excludeNames.includes(e.name)), this.excludeTypes !== void 0 && (n = n && !this.excludeTypes.includes(e.run_type)), this.excludeTags !== void 0 && (n = n && t.every((s) => {
      var a;
      return !((a = this.excludeTags) != null && a.includes(s));
    })), n;
  }
  async *tapOutputIterable(e, t) {
    for await (const n of t) {
      if (e !== this.rootId) {
        const s = this.keyMapByRunId[e];
        s && await this.writer.write(new Mr({ ops: [{
          op: "add",
          path: `/logs/${s}/streamed_output/-`,
          value: n
        }] }));
      }
      yield n;
    }
  }
  async onRunCreate(e) {
    var s;
    if (this.rootId === void 0 && (this.rootId = e.id, await this.writer.write(new Mr({ ops: [{
      op: "replace",
      path: "",
      value: {
        id: e.id,
        name: e.name,
        type: e.run_type,
        streamed_output: [],
        final_output: void 0,
        logs: {}
      }
    }] }))), !this._includeRun(e)) return;
    this.counterMapByRunName[e.name] === void 0 && (this.counterMapByRunName[e.name] = 0), this.counterMapByRunName[e.name] += 1;
    const t = this.counterMapByRunName[e.name];
    this.keyMapByRunId[e.id] = t === 1 ? e.name : `${e.name}:${t}`;
    const n = {
      id: e.id,
      name: e.name,
      type: e.run_type,
      tags: e.tags ?? [],
      metadata: ((s = e.extra) == null ? void 0 : s.metadata) ?? {},
      start_time: new Date(e.start_time).toISOString(),
      streamed_output: [],
      streamed_output_str: [],
      final_output: void 0,
      end_time: void 0
    };
    this._schemaFormat === "streaming_events" && (n.inputs = await hh(e, this._schemaFormat)), await this.writer.write(new Mr({ ops: [{
      op: "add",
      path: `/logs/${this.keyMapByRunId[e.id]}`,
      value: n
    }] }));
  }
  async onRunUpdate(e) {
    try {
      const t = this.keyMapByRunId[e.id];
      if (t === void 0) return;
      const n = [];
      this._schemaFormat === "streaming_events" && n.push({
        op: "replace",
        path: `/logs/${t}/inputs`,
        value: await hh(e, this._schemaFormat)
      }), n.push({
        op: "add",
        path: `/logs/${t}/final_output`,
        value: await fh(e, this._schemaFormat)
      }), e.end_time !== void 0 && n.push({
        op: "add",
        path: `/logs/${t}/end_time`,
        value: new Date(e.end_time).toISOString()
      });
      const s = new Mr({ ops: n });
      await this.writer.write(s);
    } finally {
      if (e.id === this.rootId) {
        const t = new Mr({ ops: [{
          op: "replace",
          path: "/final_output",
          value: await fh(e, this._schemaFormat)
        }] });
        await this.writer.write(t), this.autoClose && await this.writer.close();
      }
    }
  }
  async onLLMNewToken(e, t, n) {
    const s = this.keyMapByRunId[e.id];
    if (s === void 0) return;
    const a = e.inputs.messages !== void 0;
    let i;
    a ? sT(n == null ? void 0 : n.chunk) ? i = n == null ? void 0 : n.chunk : i = new Ar({
      id: `run-${e.id}`,
      content: t
    }) : i = t;
    const o = new Mr({ ops: [{
      op: "add",
      path: `/logs/${s}/streamed_output_str/-`,
      value: t
    }, {
      op: "add",
      path: `/logs/${s}/streamed_output/-`,
      value: i
    }] });
    await this.writer.write(o);
  }
}, aT = {};
Ae(aT, {
  ChatGenerationChunk: () => es,
  GenerationChunk: () => Qn,
  RUN_KEY: () => Qs
});
const Qs = "__run";
var Qn = class Sg {
  constructor(e) {
    b(this, "text");
    b(this, "generationInfo");
    this.text = e.text, this.generationInfo = e.generationInfo;
  }
  concat(e) {
    return new Sg({
      text: this.text + e.text,
      generationInfo: {
        ...this.generationInfo,
        ...e.generationInfo
      }
    });
  }
}, es = class Tg extends Qn {
  constructor(t) {
    super(t);
    b(this, "message");
    this.message = t.message;
  }
  concat(t) {
    return new Tg({
      text: this.text + t.text,
      generationInfo: {
        ...this.generationInfo,
        ...t.generationInfo
      },
      message: this.message.concat(t.message)
    });
  }
};
function Ua({ name: r, serialized: e }) {
  return r !== void 0 ? r : (e == null ? void 0 : e.name) !== void 0 ? e.name : (e == null ? void 0 : e.id) !== void 0 && Array.isArray(e == null ? void 0 : e.id) ? e.id[e.id.length - 1] : "Unnamed";
}
const iT = (r) => r.name === "event_stream_tracer";
var oT = class extends ds {
  constructor(e) {
    super({
      _awaitHandler: !0,
      ...e
    });
    b(this, "autoClose", !0);
    b(this, "includeNames");
    b(this, "includeTypes");
    b(this, "includeTags");
    b(this, "excludeNames");
    b(this, "excludeTypes");
    b(this, "excludeTags");
    b(this, "runInfoMap", /* @__PURE__ */ new Map());
    b(this, "tappedPromises", /* @__PURE__ */ new Map());
    b(this, "transformStream");
    b(this, "writer");
    b(this, "receiveStream");
    b(this, "name", "event_stream_tracer");
    b(this, "lc_prefer_streaming", !0);
    this.autoClose = (e == null ? void 0 : e.autoClose) ?? !0, this.includeNames = e == null ? void 0 : e.includeNames, this.includeTypes = e == null ? void 0 : e.includeTypes, this.includeTags = e == null ? void 0 : e.includeTags, this.excludeNames = e == null ? void 0 : e.excludeNames, this.excludeTypes = e == null ? void 0 : e.excludeTypes, this.excludeTags = e == null ? void 0 : e.excludeTags, this.transformStream = new TransformStream(), this.writer = this.transformStream.writable.getWriter(), this.receiveStream = dr.fromReadableStream(this.transformStream.readable);
  }
  [Symbol.asyncIterator]() {
    return this.receiveStream;
  }
  async persistRun(e) {
  }
  _includeRun(e) {
    const t = e.tags ?? [];
    let n = this.includeNames === void 0 && this.includeTags === void 0 && this.includeTypes === void 0;
    return this.includeNames !== void 0 && (n = n || this.includeNames.includes(e.name)), this.includeTypes !== void 0 && (n = n || this.includeTypes.includes(e.runType)), this.includeTags !== void 0 && (n = n || t.find((s) => {
      var a;
      return (a = this.includeTags) == null ? void 0 : a.includes(s);
    }) !== void 0), this.excludeNames !== void 0 && (n = n && !this.excludeNames.includes(e.name)), this.excludeTypes !== void 0 && (n = n && !this.excludeTypes.includes(e.runType)), this.excludeTags !== void 0 && (n = n && t.every((s) => {
      var a;
      return !((a = this.excludeTags) != null && a.includes(s));
    })), n;
  }
  async *tapOutputIterable(e, t) {
    const n = await t.next();
    if (n.done) return;
    const s = this.runInfoMap.get(e);
    if (s === void 0) {
      yield n.value;
      return;
    }
    function a(o, c) {
      return o === "llm" && typeof c == "string" ? new Qn({ text: c }) : c;
    }
    let i = this.tappedPromises.get(e);
    if (i === void 0) {
      let o;
      i = new Promise((c) => {
        o = c;
      }), this.tappedPromises.set(e, i);
      try {
        const c = {
          event: `on_${s.runType}_stream`,
          run_id: e,
          name: s.name,
          tags: s.tags,
          metadata: s.metadata,
          data: {}
        };
        await this.send({
          ...c,
          data: { chunk: a(s.runType, n.value) }
        }, s), yield n.value;
        for await (const u of t)
          s.runType !== "tool" && s.runType !== "retriever" && await this.send({
            ...c,
            data: { chunk: a(s.runType, u) }
          }, s), yield u;
      } finally {
        o == null || o();
      }
    } else {
      yield n.value;
      for await (const o of t) yield o;
    }
  }
  async send(e, t) {
    this._includeRun(t) && await this.writer.write(e);
  }
  async sendEndEvent(e, t) {
    const n = this.tappedPromises.get(e.run_id);
    n !== void 0 ? n.then(() => {
      this.send(e, t);
    }) : await this.send(e, t);
  }
  async onLLMStart(e) {
    var i, o;
    const t = Ua(e), n = e.inputs.messages !== void 0 ? "chat_model" : "llm", s = {
      tags: e.tags ?? [],
      metadata: ((i = e.extra) == null ? void 0 : i.metadata) ?? {},
      name: t,
      runType: n,
      inputs: e.inputs
    };
    this.runInfoMap.set(e.id, s);
    const a = `on_${n}_start`;
    await this.send({
      event: a,
      data: { input: e.inputs },
      name: t,
      tags: e.tags ?? [],
      run_id: e.id,
      metadata: ((o = e.extra) == null ? void 0 : o.metadata) ?? {}
    }, s);
  }
  async onLLMNewToken(e, t, n) {
    const s = this.runInfoMap.get(e.id);
    let a, i;
    if (s === void 0) throw new Error(`onLLMNewToken: Run ID ${e.id} not found in run map.`);
    if (this.runInfoMap.size !== 1) {
      if (s.runType === "chat_model")
        i = "on_chat_model_stream", (n == null ? void 0 : n.chunk) === void 0 ? a = new Ar({
          content: t,
          id: `run-${e.id}`
        }) : a = n.chunk.message;
      else if (s.runType === "llm")
        i = "on_llm_stream", (n == null ? void 0 : n.chunk) === void 0 ? a = new Qn({ text: t }) : a = n.chunk;
      else throw new Error(`Unexpected run type ${s.runType}`);
      await this.send({
        event: i,
        data: { chunk: a },
        run_id: e.id,
        name: s.name,
        tags: s.tags,
        metadata: s.metadata
      }, s);
    }
  }
  async onLLMEnd(e) {
    var i, o, c;
    const t = this.runInfoMap.get(e.id);
    this.runInfoMap.delete(e.id);
    let n;
    if (t === void 0) throw new Error(`onLLMEnd: Run ID ${e.id} not found in run map.`);
    const s = (i = e.outputs) == null ? void 0 : i.generations;
    let a;
    if (t.runType === "chat_model") {
      for (const u of s ?? []) {
        if (a !== void 0) break;
        a = (o = u[0]) == null ? void 0 : o.message;
      }
      n = "on_chat_model_end";
    } else if (t.runType === "llm")
      a = {
        generations: s == null ? void 0 : s.map((u) => u.map((l) => ({
          text: l.text,
          generationInfo: l.generationInfo
        }))),
        llmOutput: ((c = e.outputs) == null ? void 0 : c.llmOutput) ?? {}
      }, n = "on_llm_end";
    else throw new Error(`onLLMEnd: Unexpected run type: ${t.runType}`);
    await this.sendEndEvent({
      event: n,
      data: {
        output: a,
        input: t.inputs
      },
      run_id: e.id,
      name: t.name,
      tags: t.tags,
      metadata: t.metadata
    }, t);
  }
  async onChainStart(e) {
    var i, o;
    const t = Ua(e), n = e.run_type ?? "chain", s = {
      tags: e.tags ?? [],
      metadata: ((i = e.extra) == null ? void 0 : i.metadata) ?? {},
      name: t,
      runType: e.run_type
    };
    let a = {};
    e.inputs.input === "" && Object.keys(e.inputs).length === 1 ? (a = {}, s.inputs = {}) : e.inputs.input !== void 0 ? (a.input = e.inputs.input, s.inputs = e.inputs.input) : (a.input = e.inputs, s.inputs = e.inputs), this.runInfoMap.set(e.id, s), await this.send({
      event: `on_${n}_start`,
      data: a,
      name: t,
      tags: e.tags ?? [],
      run_id: e.id,
      metadata: ((o = e.extra) == null ? void 0 : o.metadata) ?? {}
    }, s);
  }
  async onChainEnd(e) {
    var o;
    const t = this.runInfoMap.get(e.id);
    if (this.runInfoMap.delete(e.id), t === void 0) throw new Error(`onChainEnd: Run ID ${e.id} not found in run map.`);
    const n = `on_${e.run_type}_end`, s = e.inputs ?? t.inputs ?? {}, i = {
      output: ((o = e.outputs) == null ? void 0 : o.output) ?? e.outputs,
      input: s
    };
    s.input && Object.keys(s).length === 1 && (i.input = s.input, t.inputs = s.input), await this.sendEndEvent({
      event: n,
      data: i,
      run_id: e.id,
      name: t.name,
      tags: t.tags,
      metadata: t.metadata ?? {}
    }, t);
  }
  async onToolStart(e) {
    var s, a;
    const t = Ua(e), n = {
      tags: e.tags ?? [],
      metadata: ((s = e.extra) == null ? void 0 : s.metadata) ?? {},
      name: t,
      runType: "tool",
      inputs: e.inputs ?? {}
    };
    this.runInfoMap.set(e.id, n), await this.send({
      event: "on_tool_start",
      data: { input: e.inputs ?? {} },
      name: t,
      run_id: e.id,
      tags: e.tags ?? [],
      metadata: ((a = e.extra) == null ? void 0 : a.metadata) ?? {}
    }, n);
  }
  async onToolEnd(e) {
    var s;
    const t = this.runInfoMap.get(e.id);
    if (this.runInfoMap.delete(e.id), t === void 0) throw new Error(`onToolEnd: Run ID ${e.id} not found in run map.`);
    if (t.inputs === void 0) throw new Error(`onToolEnd: Run ID ${e.id} is a tool call, and is expected to have traced inputs.`);
    const n = ((s = e.outputs) == null ? void 0 : s.output) === void 0 ? e.outputs : e.outputs.output;
    await this.sendEndEvent({
      event: "on_tool_end",
      data: {
        output: n,
        input: t.inputs
      },
      run_id: e.id,
      name: t.name,
      tags: t.tags,
      metadata: t.metadata
    }, t);
  }
  async onRetrieverStart(e) {
    var a, i;
    const t = Ua(e), s = {
      tags: e.tags ?? [],
      metadata: ((a = e.extra) == null ? void 0 : a.metadata) ?? {},
      name: t,
      runType: "retriever",
      inputs: { query: e.inputs.query }
    };
    this.runInfoMap.set(e.id, s), await this.send({
      event: "on_retriever_start",
      data: { input: { query: e.inputs.query } },
      name: t,
      tags: e.tags ?? [],
      run_id: e.id,
      metadata: ((i = e.extra) == null ? void 0 : i.metadata) ?? {}
    }, s);
  }
  async onRetrieverEnd(e) {
    var n;
    const t = this.runInfoMap.get(e.id);
    if (this.runInfoMap.delete(e.id), t === void 0) throw new Error(`onRetrieverEnd: Run ID ${e.id} not found in run map.`);
    await this.sendEndEvent({
      event: "on_retriever_end",
      data: {
        output: ((n = e.outputs) == null ? void 0 : n.documents) ?? e.outputs,
        input: t.inputs
      },
      run_id: e.id,
      name: t.name,
      tags: t.tags,
      metadata: t.metadata
    }, t);
  }
  async handleCustomEvent(e, t, n) {
    const s = this.runInfoMap.get(n);
    if (s === void 0) throw new Error(`handleCustomEvent: Run ID ${n} not found in run map.`);
    await this.send({
      event: "on_custom_event",
      run_id: n,
      name: e,
      tags: s.tags,
      metadata: s.metadata,
      data: t
    }, s);
  }
  async finish() {
    const e = [...this.tappedPromises.values()];
    Promise.all(e).finally(() => {
      this.writer.close();
    });
  }
};
const cT = Object.prototype.toString, uT = (r) => cT.call(r) === "[object Error]", lT = /* @__PURE__ */ new Set([
  "network error",
  "Failed to fetch",
  "NetworkError when attempting to fetch resource.",
  "The Internet connection appears to be offline.",
  "Network request failed",
  "fetch failed",
  "terminated",
  " A network error occurred.",
  "Network connection lost"
]);
function dT(r) {
  if (!(r && uT(r) && r.name === "TypeError" && typeof r.message == "string")) return !1;
  const { message: t, stack: n } = r;
  return t === "Load failed" ? n === void 0 || "__sentry_captured__" in r : t.startsWith("error sending request for url") ? !0 : lT.has(t);
}
function hT(r) {
  if (typeof r == "number") {
    if (r < 0) throw new TypeError("Expected `retries` to be a non-negative number.");
    if (Number.isNaN(r)) throw new TypeError("Expected `retries` to be a valid number or Infinity, got NaN.");
  } else if (r !== void 0) throw new TypeError("Expected `retries` to be a number or Infinity.");
}
function za(r, e, { min: t = 0, allowInfinity: n = !1 } = {}) {
  if (e !== void 0) {
    if (typeof e != "number" || Number.isNaN(e)) throw new TypeError(`Expected \`${r}\` to be a number${n ? " or Infinity" : ""}.`);
    if (!n && !Number.isFinite(e)) throw new TypeError(`Expected \`${r}\` to be a finite number.`);
    if (e < t) throw new TypeError(`Expected \`${r}\` to be â‰¥ ${t}.`);
  }
}
var fT = class extends Error {
  constructor(r) {
    super(), r instanceof Error ? (this.originalError = r, { message: r } = r) : (this.originalError = new Error(r), this.originalError.stack = this.stack), this.name = "AbortError", this.message = r;
  }
};
function pT(r, e) {
  const t = Math.max(1, r + 1), n = e.randomize ? Math.random() + 1 : 1;
  let s = Math.round(n * e.minTimeout * e.factor ** (t - 1));
  return s = Math.min(s, e.maxTimeout), s;
}
function ph(r, e) {
  return Number.isFinite(e) ? e - (performance.now() - r) : e;
}
async function mT({ error: r, attemptNumber: e, retriesConsumed: t, startTime: n, options: s }) {
  var f, p, y;
  const a = r instanceof Error ? r : /* @__PURE__ */ new TypeError(`Non-error was thrown: "${r}". You should only throw errors.`);
  if (a instanceof fT) throw a.originalError;
  const i = Number.isFinite(s.retries) ? Math.max(0, s.retries - t) : s.retries, o = s.maxRetryTime ?? Number.POSITIVE_INFINITY, c = Object.freeze({
    error: a,
    attemptNumber: e,
    retriesLeft: i,
    retriesConsumed: t
  });
  if (await s.onFailedAttempt(c), ph(n, o) <= 0) throw a;
  const u = await s.shouldConsumeRetry(c), l = ph(n, o);
  if (l <= 0 || i <= 0) throw a;
  if (a instanceof TypeError && !dT(a)) {
    if (u) throw a;
    return (f = s.signal) == null || f.throwIfAborted(), !1;
  }
  if (!await s.shouldRetry(c)) throw a;
  if (!u)
    return (p = s.signal) == null || p.throwIfAborted(), !1;
  const d = pT(t, s), h = Math.min(d, l);
  return h > 0 && await new Promise((m, v) => {
    var T, x;
    const g = () => {
      var O;
      clearTimeout(w), (O = s.signal) == null || O.removeEventListener("abort", g), v(s.signal.reason);
    }, w = setTimeout(() => {
      var O;
      (O = s.signal) == null || O.removeEventListener("abort", g), m();
    }, h);
    s.unref && ((T = w.unref) == null || T.call(w)), (x = s.signal) == null || x.addEventListener("abort", g, { once: !0 });
  }), (y = s.signal) == null || y.throwIfAborted(), !0;
}
async function Kc(r, e = {}) {
  var a, i, o;
  if (e = { ...e }, hT(e.retries), Object.hasOwn(e, "forever")) throw new Error("The `forever` option is no longer supported. For many use-cases, you can set `retries: Infinity` instead.");
  e.retries ?? (e.retries = 10), e.factor ?? (e.factor = 2), e.minTimeout ?? (e.minTimeout = 1e3), e.maxTimeout ?? (e.maxTimeout = Number.POSITIVE_INFINITY), e.maxRetryTime ?? (e.maxRetryTime = Number.POSITIVE_INFINITY), e.randomize ?? (e.randomize = !1), e.onFailedAttempt ?? (e.onFailedAttempt = () => {
  }), e.shouldRetry ?? (e.shouldRetry = () => !0), e.shouldConsumeRetry ?? (e.shouldConsumeRetry = () => !0), za("factor", e.factor, {
    min: 0,
    allowInfinity: !1
  }), za("minTimeout", e.minTimeout, {
    min: 0,
    allowInfinity: !1
  }), za("maxTimeout", e.maxTimeout, {
    min: 0,
    allowInfinity: !0
  }), za("maxRetryTime", e.maxRetryTime, {
    min: 0,
    allowInfinity: !0
  }), e.factor > 0 || (e.factor = 1), (a = e.signal) == null || a.throwIfAborted();
  let t = 0, n = 0;
  const s = performance.now();
  for (; !Number.isFinite(e.retries) || n <= e.retries; ) {
    t++;
    try {
      (i = e.signal) == null || i.throwIfAborted();
      const c = await r(t);
      return (o = e.signal) == null || o.throwIfAborted(), c;
    } catch (c) {
      await mT({
        error: c,
        attemptNumber: t,
        retriesConsumed: n,
        startTime: s,
        options: e
      }) && n++;
    }
  }
  throw new Error("Retry attempts exhausted without throwing an error.");
}
var gT = {};
Ae(gT, { AsyncCaller: () => pa });
const _T = [
  400,
  401,
  402,
  403,
  404,
  405,
  406,
  407,
  409
], yT = (r) => {
  var t, n;
  if (r.message.startsWith("Cancel") || r.message.startsWith("AbortError") || r.name === "AbortError" || (r == null ? void 0 : r.code) === "ECONNABORTED") throw r;
  const e = ((t = r == null ? void 0 : r.response) == null ? void 0 : t.status) ?? (r == null ? void 0 : r.status);
  if (e && _T.includes(+e)) throw r;
  if (((n = r == null ? void 0 : r.error) == null ? void 0 : n.code) === "insufficient_quota") {
    const s = new Error(r == null ? void 0 : r.message);
    throw s.name = "InsufficientQuotaError", s;
  }
};
var pa = class {
  constructor(r) {
    b(this, "maxConcurrency");
    b(this, "maxRetries");
    b(this, "onFailedAttempt");
    b(this, "queue");
    this.maxConcurrency = r.maxConcurrency ?? 1 / 0, this.maxRetries = r.maxRetries ?? 6, this.onFailedAttempt = r.onFailedAttempt ?? yT;
    const e = "default" in Dr ? Dr.default : Dr;
    this.queue = new e({ concurrency: this.maxConcurrency });
  }
  async call(r, ...e) {
    return this.queue.add(() => Kc(() => r(...e).catch((t) => {
      throw t instanceof Error ? t : new Error(t);
    }), {
      onFailedAttempt: ({ error: t }) => {
        var n;
        return (n = this.onFailedAttempt) == null ? void 0 : n.call(this, t);
      },
      retries: this.maxRetries,
      randomize: !0
    }), { throwOnTimeout: !0 });
  }
  callWithOptions(r, e, ...t) {
    if (r.signal) {
      let n;
      return Promise.race([this.call(e, ...t), new Promise((s, a) => {
        var i;
        n = () => {
          a(Ys(r.signal));
        }, (i = r.signal) == null || i.addEventListener("abort", n);
      })]).finally(() => {
        r.signal && n && r.signal.removeEventListener("abort", n);
      });
    }
    return this.call(e, ...t);
  }
  fetch(...r) {
    return this.call(() => fetch(...r).then((e) => e.ok ? e : Promise.reject(e)));
  }
}, Eg = class extends ds {
  constructor({ config: e, onStart: t, onEnd: n, onError: s }) {
    super({ _awaitHandler: !0 });
    b(this, "name", "RootListenersTracer");
    /** The Run's ID. Type UUID */
    b(this, "rootId");
    b(this, "config");
    b(this, "argOnStart");
    b(this, "argOnEnd");
    b(this, "argOnError");
    this.config = e, this.argOnStart = t, this.argOnEnd = n, this.argOnError = s;
  }
  /**
  * This is a legacy method only called once for an entire run tree
  * therefore not useful here
  * @param {Run} _ Not used
  */
  persistRun(e) {
    return Promise.resolve();
  }
  async onRunCreate(e) {
    this.rootId || (this.rootId = e.id, this.argOnStart && await this.argOnStart(e, this.config));
  }
  async onRunUpdate(e) {
    e.id === this.rootId && (e.error ? this.argOnError && await this.argOnError(e, this.config) : this.argOnEnd && await this.argOnEnd(e, this.config));
  }
};
function bl(r) {
  return r ? r.lc_runnable : !1;
}
var wT = class {
  constructor(r) {
    b(this, "includeNames");
    b(this, "includeTypes");
    b(this, "includeTags");
    b(this, "excludeNames");
    b(this, "excludeTypes");
    b(this, "excludeTags");
    this.includeNames = r.includeNames, this.includeTypes = r.includeTypes, this.includeTags = r.includeTags, this.excludeNames = r.excludeNames, this.excludeTypes = r.excludeTypes, this.excludeTags = r.excludeTags;
  }
  includeEvent(r, e) {
    let t = this.includeNames === void 0 && this.includeTypes === void 0 && this.includeTags === void 0;
    const n = r.tags ?? [];
    return this.includeNames !== void 0 && (t = t || this.includeNames.includes(r.name)), this.includeTypes !== void 0 && (t = t || this.includeTypes.includes(e)), this.includeTags !== void 0 && (t = t || n.some((s) => {
      var a;
      return (a = this.includeTags) == null ? void 0 : a.includes(s);
    })), this.excludeNames !== void 0 && (t = t && !this.excludeNames.includes(r.name)), this.excludeTypes !== void 0 && (t = t && !this.excludeTypes.includes(e)), this.excludeTags !== void 0 && (t = t && n.every((s) => {
      var a;
      return !((a = this.excludeTags) != null && a.includes(s));
    })), t;
  }
};
const vT = (r) => btoa(r).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
function L(r, e, t) {
  function n(o, c) {
    if (o._zod || Object.defineProperty(o, "_zod", {
      value: {
        def: c,
        constr: i,
        traits: /* @__PURE__ */ new Set()
      },
      enumerable: !1
    }), o._zod.traits.has(r))
      return;
    o._zod.traits.add(r), e(o, c);
    const u = i.prototype, l = Object.keys(u);
    for (let d = 0; d < l.length; d++) {
      const h = l[d];
      h in o || (o[h] = u[h].bind(o));
    }
  }
  const s = (t == null ? void 0 : t.Parent) ?? Object;
  class a extends s {
  }
  Object.defineProperty(a, "name", { value: r });
  function i(o) {
    var c;
    const u = t != null && t.Parent ? new a() : this;
    n(u, o), (c = u._zod).deferred ?? (c.deferred = []);
    for (const l of u._zod.deferred)
      l();
    return u;
  }
  return Object.defineProperty(i, "init", { value: n }), Object.defineProperty(i, Symbol.hasInstance, {
    value: (o) => {
      var c, u;
      return t != null && t.Parent && o instanceof t.Parent ? !0 : (u = (c = o == null ? void 0 : o._zod) == null ? void 0 : c.traits) == null ? void 0 : u.has(r);
    }
  }), Object.defineProperty(i, "name", { value: r }), i;
}
class Kn extends Error {
  constructor() {
    super("Encountered Promise during synchronous parse. Use .parseAsync() instead.");
  }
}
class xg extends Error {
  constructor(e) {
    super(`Encountered unidirectional transform during encode: ${e}`), this.name = "ZodEncodeError";
  }
}
const kg = {};
function on(r) {
  return kg;
}
function Ig(r) {
  const e = Object.values(r).filter((n) => typeof n == "number");
  return Object.entries(r).filter(([n, s]) => e.indexOf(+n) === -1).map(([n, s]) => s);
}
function Yc(r, e) {
  return typeof e == "bigint" ? e.toString() : e;
}
function Sl(r) {
  return {
    get value() {
      {
        const e = r();
        return Object.defineProperty(this, "value", { value: e }), e;
      }
    }
  };
}
function Tl(r) {
  return r == null;
}
function El(r) {
  const e = r.startsWith("^") ? 1 : 0, t = r.endsWith("$") ? r.length - 1 : r.length;
  return r.slice(e, t);
}
function bT(r, e) {
  const t = (r.toString().split(".")[1] || "").length, n = e.toString();
  let s = (n.split(".")[1] || "").length;
  if (s === 0 && /\d?e-\d?/.test(n)) {
    const c = n.match(/\d?e-(\d?)/);
    c != null && c[1] && (s = Number.parseInt(c[1]));
  }
  const a = t > s ? t : s, i = Number.parseInt(r.toFixed(a).replace(".", "")), o = Number.parseInt(e.toFixed(a).replace(".", ""));
  return i % o / 10 ** a;
}
const mh = Symbol("evaluating");
function ze(r, e, t) {
  let n;
  Object.defineProperty(r, e, {
    get() {
      if (n !== mh)
        return n === void 0 && (n = mh, n = t()), n;
    },
    set(s) {
      Object.defineProperty(r, e, {
        value: s
        // configurable: true,
      });
    },
    configurable: !0
  });
}
function An(r, e, t) {
  Object.defineProperty(r, e, {
    value: t,
    writable: !0,
    enumerable: !0,
    configurable: !0
  });
}
function $n(...r) {
  const e = {};
  for (const t of r) {
    const n = Object.getOwnPropertyDescriptors(t);
    Object.assign(e, n);
  }
  return Object.defineProperties({}, e);
}
function gh(r) {
  return JSON.stringify(r);
}
function ST(r) {
  return r.toLowerCase().trim().replace(/[^\w\s-]/g, "").replace(/[\s_-]+/g, "-").replace(/^-+|-+$/g, "");
}
const Og = "captureStackTrace" in Error ? Error.captureStackTrace : (...r) => {
};
function Ai(r) {
  return typeof r == "object" && r !== null && !Array.isArray(r);
}
const TT = Sl(() => {
  var r;
  if (typeof navigator < "u" && ((r = navigator == null ? void 0 : navigator.userAgent) != null && r.includes("Cloudflare")))
    return !1;
  try {
    const e = Function;
    return new e(""), !0;
  } catch {
    return !1;
  }
});
function ts(r) {
  if (Ai(r) === !1)
    return !1;
  const e = r.constructor;
  if (e === void 0 || typeof e != "function")
    return !0;
  const t = e.prototype;
  return !(Ai(t) === !1 || Object.prototype.hasOwnProperty.call(t, "isPrototypeOf") === !1);
}
function Ag(r) {
  return ts(r) ? { ...r } : Array.isArray(r) ? [...r] : r;
}
const ET = /* @__PURE__ */ new Set(["string", "number", "symbol"]);
function go(r) {
  return r.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function bt(r, e, t) {
  const n = new r._zod.constr(e ?? r._zod.def);
  return (!e || t != null && t.parent) && (n._zod.parent = r), n;
}
function le(r) {
  const e = r;
  if (!e)
    return {};
  if (typeof e == "string")
    return { error: () => e };
  if ((e == null ? void 0 : e.message) !== void 0) {
    if ((e == null ? void 0 : e.error) !== void 0)
      throw new Error("Cannot specify both `message` and `error` params");
    e.error = e.message;
  }
  return delete e.message, typeof e.error == "string" ? { ...e, error: () => e.error } : e;
}
function xT(r) {
  return Object.keys(r).filter((e) => r[e]._zod.optin === "optional" && r[e]._zod.optout === "optional");
}
const kT = {
  safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],
  int32: [-2147483648, 2147483647],
  uint32: [0, 4294967295],
  float32: [-34028234663852886e22, 34028234663852886e22],
  float64: [-Number.MAX_VALUE, Number.MAX_VALUE]
};
function IT(r, e) {
  const t = r._zod.def, n = $n(r._zod.def, {
    get shape() {
      const s = {};
      for (const a in e) {
        if (!(a in t.shape))
          throw new Error(`Unrecognized key: "${a}"`);
        e[a] && (s[a] = t.shape[a]);
      }
      return An(this, "shape", s), s;
    },
    checks: []
  });
  return bt(r, n);
}
function OT(r, e) {
  const t = r._zod.def, n = $n(r._zod.def, {
    get shape() {
      const s = { ...r._zod.def.shape };
      for (const a in e) {
        if (!(a in t.shape))
          throw new Error(`Unrecognized key: "${a}"`);
        e[a] && delete s[a];
      }
      return An(this, "shape", s), s;
    },
    checks: []
  });
  return bt(r, n);
}
function $g(r, e) {
  if (!ts(e))
    throw new Error("Invalid input to extend: expected a plain object");
  const t = r._zod.def.checks;
  if (t && t.length > 0)
    throw new Error("Object schemas containing refinements cannot be extended. Use `.safeExtend()` instead.");
  const s = $n(r._zod.def, {
    get shape() {
      const a = { ...r._zod.def.shape, ...e };
      return An(this, "shape", a), a;
    },
    checks: []
  });
  return bt(r, s);
}
function AT(r, e) {
  if (!ts(e))
    throw new Error("Invalid input to safeExtend: expected a plain object");
  const t = {
    ...r._zod.def,
    get shape() {
      const n = { ...r._zod.def.shape, ...e };
      return An(this, "shape", n), n;
    },
    checks: r._zod.def.checks
  };
  return bt(r, t);
}
function $T(r, e) {
  const t = $n(r._zod.def, {
    get shape() {
      const n = { ...r._zod.def.shape, ...e._zod.def.shape };
      return An(this, "shape", n), n;
    },
    get catchall() {
      return e._zod.def.catchall;
    },
    checks: []
    // delete existing checks
  });
  return bt(r, t);
}
function Cg(r, e, t) {
  const n = $n(e._zod.def, {
    get shape() {
      const s = e._zod.def.shape, a = { ...s };
      if (t)
        for (const i in t) {
          if (!(i in s))
            throw new Error(`Unrecognized key: "${i}"`);
          t[i] && (a[i] = r ? new r({
            type: "optional",
            innerType: s[i]
          }) : s[i]);
        }
      else
        for (const i in s)
          a[i] = r ? new r({
            type: "optional",
            innerType: s[i]
          }) : s[i];
      return An(this, "shape", a), a;
    },
    checks: []
  });
  return bt(e, n);
}
function CT(r, e, t) {
  const n = $n(e._zod.def, {
    get shape() {
      const s = e._zod.def.shape, a = { ...s };
      if (t)
        for (const i in t) {
          if (!(i in a))
            throw new Error(`Unrecognized key: "${i}"`);
          t[i] && (a[i] = new r({
            type: "nonoptional",
            innerType: s[i]
          }));
        }
      else
        for (const i in s)
          a[i] = new r({
            type: "nonoptional",
            innerType: s[i]
          });
      return An(this, "shape", a), a;
    },
    checks: []
  });
  return bt(e, n);
}
function Jn(r, e = 0) {
  var t;
  if (r.aborted === !0)
    return !0;
  for (let n = e; n < r.issues.length; n++)
    if (((t = r.issues[n]) == null ? void 0 : t.continue) !== !0)
      return !0;
  return !1;
}
function Hn(r, e) {
  return e.map((t) => {
    var n;
    return (n = t).path ?? (n.path = []), t.path.unshift(r), t;
  });
}
function Ba(r) {
  return typeof r == "string" ? r : r == null ? void 0 : r.message;
}
function cn(r, e, t) {
  var s, a, i, o, c, u;
  const n = { ...r, path: r.path ?? [] };
  if (!r.message) {
    const l = Ba((i = (a = (s = r.inst) == null ? void 0 : s._zod.def) == null ? void 0 : a.error) == null ? void 0 : i.call(a, r)) ?? Ba((o = e == null ? void 0 : e.error) == null ? void 0 : o.call(e, r)) ?? Ba((c = t.customError) == null ? void 0 : c.call(t, r)) ?? Ba((u = t.localeError) == null ? void 0 : u.call(t, r)) ?? "Invalid input";
    n.message = l;
  }
  return delete n.inst, delete n.continue, e != null && e.reportInput || delete n.input, n;
}
function xl(r) {
  return Array.isArray(r) ? "array" : typeof r == "string" ? "string" : "unknown";
}
function ea(...r) {
  const [e, t, n] = r;
  return typeof e == "string" ? {
    message: e,
    code: "custom",
    input: t,
    inst: n
  } : { ...e };
}
const Rg = (r, e) => {
  r.name = "$ZodError", Object.defineProperty(r, "_zod", {
    value: r._zod,
    enumerable: !1
  }), Object.defineProperty(r, "issues", {
    value: e,
    enumerable: !1
  }), r.message = JSON.stringify(e, Yc, 2), Object.defineProperty(r, "toString", {
    value: () => r.message,
    enumerable: !1
  });
}, Ng = L("$ZodError", Rg), _o = L("$ZodError", Rg, { Parent: Error });
function RT(r, e = (t) => t.message) {
  const t = {}, n = [];
  for (const s of r.issues)
    s.path.length > 0 ? (t[s.path[0]] = t[s.path[0]] || [], t[s.path[0]].push(e(s))) : n.push(e(s));
  return { formErrors: n, fieldErrors: t };
}
function NT(r, e = (t) => t.message) {
  const t = { _errors: [] }, n = (s) => {
    for (const a of s.issues)
      if (a.code === "invalid_union" && a.errors.length)
        a.errors.map((i) => n({ issues: i }));
      else if (a.code === "invalid_key")
        n({ issues: a.issues });
      else if (a.code === "invalid_element")
        n({ issues: a.issues });
      else if (a.path.length === 0)
        t._errors.push(e(a));
      else {
        let i = t, o = 0;
        for (; o < a.path.length; ) {
          const c = a.path[o];
          o === a.path.length - 1 ? (i[c] = i[c] || { _errors: [] }, i[c]._errors.push(e(a))) : i[c] = i[c] || { _errors: [] }, i = i[c], o++;
        }
      }
  };
  return n(r), t;
}
function PT(r) {
  const e = [], t = r.map((n) => typeof n == "object" ? n.key : n);
  for (const n of t)
    typeof n == "number" ? e.push(`[${n}]`) : typeof n == "symbol" ? e.push(`[${JSON.stringify(String(n))}]`) : /[^\w$]/.test(n) ? e.push(`[${JSON.stringify(n)}]`) : (e.length && e.push("."), e.push(n));
  return e.join("");
}
function LT(r) {
  var n;
  const e = [], t = [...r.issues].sort((s, a) => (s.path ?? []).length - (a.path ?? []).length);
  for (const s of t)
    e.push(`âœ– ${s.message}`), (n = s.path) != null && n.length && e.push(`  â†’ at ${PT(s.path)}`);
  return e.join(`
`);
}
const yo = (r) => (e, t, n, s) => {
  const a = n ? Object.assign(n, { async: !1 }) : { async: !1 }, i = e._zod.run({ value: t, issues: [] }, a);
  if (i instanceof Promise)
    throw new Kn();
  if (i.issues.length) {
    const o = new ((s == null ? void 0 : s.Err) ?? r)(i.issues.map((c) => cn(c, a, on())));
    throw Og(o, s == null ? void 0 : s.callee), o;
  }
  return i.value;
}, wo = /* @__PURE__ */ yo(_o), vo = (r) => async (e, t, n, s) => {
  const a = n ? Object.assign(n, { async: !0 }) : { async: !0 };
  let i = e._zod.run({ value: t, issues: [] }, a);
  if (i instanceof Promise && (i = await i), i.issues.length) {
    const o = new ((s == null ? void 0 : s.Err) ?? r)(i.issues.map((c) => cn(c, a, on())));
    throw Og(o, s == null ? void 0 : s.callee), o;
  }
  return i.value;
}, Pg = /* @__PURE__ */ vo(_o), bo = (r) => (e, t, n) => {
  const s = n ? { ...n, async: !1 } : { async: !1 }, a = e._zod.run({ value: t, issues: [] }, s);
  if (a instanceof Promise)
    throw new Kn();
  return a.issues.length ? {
    success: !1,
    error: new (r ?? Ng)(a.issues.map((i) => cn(i, s, on())))
  } : { success: !0, data: a.value };
}, MT = /* @__PURE__ */ bo(_o), So = (r) => async (e, t, n) => {
  const s = n ? Object.assign(n, { async: !0 }) : { async: !0 };
  let a = e._zod.run({ value: t, issues: [] }, s);
  return a instanceof Promise && (a = await a), a.issues.length ? {
    success: !1,
    error: new r(a.issues.map((i) => cn(i, s, on())))
  } : { success: !0, data: a.value };
}, DT = /* @__PURE__ */ So(_o), jT = (r) => (e, t, n) => {
  const s = n ? Object.assign(n, { direction: "backward" }) : { direction: "backward" };
  return yo(r)(e, t, s);
}, FT = (r) => (e, t, n) => yo(r)(e, t, n), UT = (r) => async (e, t, n) => {
  const s = n ? Object.assign(n, { direction: "backward" }) : { direction: "backward" };
  return vo(r)(e, t, s);
}, zT = (r) => async (e, t, n) => vo(r)(e, t, n), BT = (r) => (e, t, n) => {
  const s = n ? Object.assign(n, { direction: "backward" }) : { direction: "backward" };
  return bo(r)(e, t, s);
}, ZT = (r) => (e, t, n) => bo(r)(e, t, n), VT = (r) => async (e, t, n) => {
  const s = n ? Object.assign(n, { direction: "backward" }) : { direction: "backward" };
  return So(r)(e, t, s);
}, qT = (r) => async (e, t, n) => So(r)(e, t, n), JT = /^[cC][^\s-]{8,}$/, HT = /^[0-9a-z]+$/, GT = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/, WT = /^[0-9a-vA-V]{20}$/, KT = /^[A-Za-z0-9]{27}$/, YT = /^[a-zA-Z0-9_-]{21}$/, XT = /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/, QT = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/, _h = (r) => r ? new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${r}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`) : /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/, eE = /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/, tE = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
function rE() {
  return new RegExp(tE, "u");
}
const nE = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/, sE = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$/, aE = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/, iE = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/, oE = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/, Lg = /^[A-Za-z0-9_-]*$/, cE = /^\+(?:[0-9]){6,14}[0-9]$/, Mg = "(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))", uE = /* @__PURE__ */ new RegExp(`^${Mg}$`);
function Dg(r) {
  const e = "(?:[01]\\d|2[0-3]):[0-5]\\d";
  return typeof r.precision == "number" ? r.precision === -1 ? `${e}` : r.precision === 0 ? `${e}:[0-5]\\d` : `${e}:[0-5]\\d\\.\\d{${r.precision}}` : `${e}(?::[0-5]\\d(?:\\.\\d+)?)?`;
}
function lE(r) {
  return new RegExp(`^${Dg(r)}$`);
}
function dE(r) {
  const e = Dg({ precision: r.precision }), t = ["Z"];
  r.local && t.push(""), r.offset && t.push("([+-](?:[01]\\d|2[0-3]):[0-5]\\d)");
  const n = `${e}(?:${t.join("|")})`;
  return new RegExp(`^${Mg}T(?:${n})$`);
}
const hE = (r) => {
  const e = r ? `[\\s\\S]{${(r == null ? void 0 : r.minimum) ?? 0},${(r == null ? void 0 : r.maximum) ?? ""}}` : "[\\s\\S]*";
  return new RegExp(`^${e}$`);
}, fE = /^-?\d+$/, pE = /^-?\d+(?:\.\d+)?/, mE = /^(?:true|false)$/i, gE = /^[^A-Z]*$/, _E = /^[^a-z]*$/, Lt = /* @__PURE__ */ L("$ZodCheck", (r, e) => {
  var t;
  r._zod ?? (r._zod = {}), r._zod.def = e, (t = r._zod).onattach ?? (t.onattach = []);
}), jg = {
  number: "number",
  bigint: "bigint",
  object: "date"
}, Fg = /* @__PURE__ */ L("$ZodCheckLessThan", (r, e) => {
  Lt.init(r, e);
  const t = jg[typeof e.value];
  r._zod.onattach.push((n) => {
    const s = n._zod.bag, a = (e.inclusive ? s.maximum : s.exclusiveMaximum) ?? Number.POSITIVE_INFINITY;
    e.value < a && (e.inclusive ? s.maximum = e.value : s.exclusiveMaximum = e.value);
  }), r._zod.check = (n) => {
    (e.inclusive ? n.value <= e.value : n.value < e.value) || n.issues.push({
      origin: t,
      code: "too_big",
      maximum: e.value,
      input: n.value,
      inclusive: e.inclusive,
      inst: r,
      continue: !e.abort
    });
  };
}), Ug = /* @__PURE__ */ L("$ZodCheckGreaterThan", (r, e) => {
  Lt.init(r, e);
  const t = jg[typeof e.value];
  r._zod.onattach.push((n) => {
    const s = n._zod.bag, a = (e.inclusive ? s.minimum : s.exclusiveMinimum) ?? Number.NEGATIVE_INFINITY;
    e.value > a && (e.inclusive ? s.minimum = e.value : s.exclusiveMinimum = e.value);
  }), r._zod.check = (n) => {
    (e.inclusive ? n.value >= e.value : n.value > e.value) || n.issues.push({
      origin: t,
      code: "too_small",
      minimum: e.value,
      input: n.value,
      inclusive: e.inclusive,
      inst: r,
      continue: !e.abort
    });
  };
}), yE = /* @__PURE__ */ L("$ZodCheckMultipleOf", (r, e) => {
  Lt.init(r, e), r._zod.onattach.push((t) => {
    var n;
    (n = t._zod.bag).multipleOf ?? (n.multipleOf = e.value);
  }), r._zod.check = (t) => {
    if (typeof t.value != typeof e.value)
      throw new Error("Cannot mix number and bigint in multiple_of check.");
    (typeof t.value == "bigint" ? t.value % e.value === BigInt(0) : bT(t.value, e.value) === 0) || t.issues.push({
      origin: typeof t.value,
      code: "not_multiple_of",
      divisor: e.value,
      input: t.value,
      inst: r,
      continue: !e.abort
    });
  };
}), wE = /* @__PURE__ */ L("$ZodCheckNumberFormat", (r, e) => {
  var i;
  Lt.init(r, e), e.format = e.format || "float64";
  const t = (i = e.format) == null ? void 0 : i.includes("int"), n = t ? "int" : "number", [s, a] = kT[e.format];
  r._zod.onattach.push((o) => {
    const c = o._zod.bag;
    c.format = e.format, c.minimum = s, c.maximum = a, t && (c.pattern = fE);
  }), r._zod.check = (o) => {
    const c = o.value;
    if (t) {
      if (!Number.isInteger(c)) {
        o.issues.push({
          expected: n,
          format: e.format,
          code: "invalid_type",
          continue: !1,
          input: c,
          inst: r
        });
        return;
      }
      if (!Number.isSafeInteger(c)) {
        c > 0 ? o.issues.push({
          input: c,
          code: "too_big",
          maximum: Number.MAX_SAFE_INTEGER,
          note: "Integers must be within the safe integer range.",
          inst: r,
          origin: n,
          continue: !e.abort
        }) : o.issues.push({
          input: c,
          code: "too_small",
          minimum: Number.MIN_SAFE_INTEGER,
          note: "Integers must be within the safe integer range.",
          inst: r,
          origin: n,
          continue: !e.abort
        });
        return;
      }
    }
    c < s && o.issues.push({
      origin: "number",
      input: c,
      code: "too_small",
      minimum: s,
      inclusive: !0,
      inst: r,
      continue: !e.abort
    }), c > a && o.issues.push({
      origin: "number",
      input: c,
      code: "too_big",
      maximum: a,
      inst: r
    });
  };
}), vE = /* @__PURE__ */ L("$ZodCheckMaxLength", (r, e) => {
  var t;
  Lt.init(r, e), (t = r._zod.def).when ?? (t.when = (n) => {
    const s = n.value;
    return !Tl(s) && s.length !== void 0;
  }), r._zod.onattach.push((n) => {
    const s = n._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    e.maximum < s && (n._zod.bag.maximum = e.maximum);
  }), r._zod.check = (n) => {
    const s = n.value;
    if (s.length <= e.maximum)
      return;
    const i = xl(s);
    n.issues.push({
      origin: i,
      code: "too_big",
      maximum: e.maximum,
      inclusive: !0,
      input: s,
      inst: r,
      continue: !e.abort
    });
  };
}), bE = /* @__PURE__ */ L("$ZodCheckMinLength", (r, e) => {
  var t;
  Lt.init(r, e), (t = r._zod.def).when ?? (t.when = (n) => {
    const s = n.value;
    return !Tl(s) && s.length !== void 0;
  }), r._zod.onattach.push((n) => {
    const s = n._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    e.minimum > s && (n._zod.bag.minimum = e.minimum);
  }), r._zod.check = (n) => {
    const s = n.value;
    if (s.length >= e.minimum)
      return;
    const i = xl(s);
    n.issues.push({
      origin: i,
      code: "too_small",
      minimum: e.minimum,
      inclusive: !0,
      input: s,
      inst: r,
      continue: !e.abort
    });
  };
}), SE = /* @__PURE__ */ L("$ZodCheckLengthEquals", (r, e) => {
  var t;
  Lt.init(r, e), (t = r._zod.def).when ?? (t.when = (n) => {
    const s = n.value;
    return !Tl(s) && s.length !== void 0;
  }), r._zod.onattach.push((n) => {
    const s = n._zod.bag;
    s.minimum = e.length, s.maximum = e.length, s.length = e.length;
  }), r._zod.check = (n) => {
    const s = n.value, a = s.length;
    if (a === e.length)
      return;
    const i = xl(s), o = a > e.length;
    n.issues.push({
      origin: i,
      ...o ? { code: "too_big", maximum: e.length } : { code: "too_small", minimum: e.length },
      inclusive: !0,
      exact: !0,
      input: n.value,
      inst: r,
      continue: !e.abort
    });
  };
}), To = /* @__PURE__ */ L("$ZodCheckStringFormat", (r, e) => {
  var t, n;
  Lt.init(r, e), r._zod.onattach.push((s) => {
    const a = s._zod.bag;
    a.format = e.format, e.pattern && (a.patterns ?? (a.patterns = /* @__PURE__ */ new Set()), a.patterns.add(e.pattern));
  }), e.pattern ? (t = r._zod).check ?? (t.check = (s) => {
    e.pattern.lastIndex = 0, !e.pattern.test(s.value) && s.issues.push({
      origin: "string",
      code: "invalid_format",
      format: e.format,
      input: s.value,
      ...e.pattern ? { pattern: e.pattern.toString() } : {},
      inst: r,
      continue: !e.abort
    });
  }) : (n = r._zod).check ?? (n.check = () => {
  });
}), TE = /* @__PURE__ */ L("$ZodCheckRegex", (r, e) => {
  To.init(r, e), r._zod.check = (t) => {
    e.pattern.lastIndex = 0, !e.pattern.test(t.value) && t.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "regex",
      input: t.value,
      pattern: e.pattern.toString(),
      inst: r,
      continue: !e.abort
    });
  };
}), EE = /* @__PURE__ */ L("$ZodCheckLowerCase", (r, e) => {
  e.pattern ?? (e.pattern = gE), To.init(r, e);
}), xE = /* @__PURE__ */ L("$ZodCheckUpperCase", (r, e) => {
  e.pattern ?? (e.pattern = _E), To.init(r, e);
}), kE = /* @__PURE__ */ L("$ZodCheckIncludes", (r, e) => {
  Lt.init(r, e);
  const t = go(e.includes), n = new RegExp(typeof e.position == "number" ? `^.{${e.position}}${t}` : t);
  e.pattern = n, r._zod.onattach.push((s) => {
    const a = s._zod.bag;
    a.patterns ?? (a.patterns = /* @__PURE__ */ new Set()), a.patterns.add(n);
  }), r._zod.check = (s) => {
    s.value.includes(e.includes, e.position) || s.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "includes",
      includes: e.includes,
      input: s.value,
      inst: r,
      continue: !e.abort
    });
  };
}), IE = /* @__PURE__ */ L("$ZodCheckStartsWith", (r, e) => {
  Lt.init(r, e);
  const t = new RegExp(`^${go(e.prefix)}.*`);
  e.pattern ?? (e.pattern = t), r._zod.onattach.push((n) => {
    const s = n._zod.bag;
    s.patterns ?? (s.patterns = /* @__PURE__ */ new Set()), s.patterns.add(t);
  }), r._zod.check = (n) => {
    n.value.startsWith(e.prefix) || n.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "starts_with",
      prefix: e.prefix,
      input: n.value,
      inst: r,
      continue: !e.abort
    });
  };
}), OE = /* @__PURE__ */ L("$ZodCheckEndsWith", (r, e) => {
  Lt.init(r, e);
  const t = new RegExp(`.*${go(e.suffix)}$`);
  e.pattern ?? (e.pattern = t), r._zod.onattach.push((n) => {
    const s = n._zod.bag;
    s.patterns ?? (s.patterns = /* @__PURE__ */ new Set()), s.patterns.add(t);
  }), r._zod.check = (n) => {
    n.value.endsWith(e.suffix) || n.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "ends_with",
      suffix: e.suffix,
      input: n.value,
      inst: r,
      continue: !e.abort
    });
  };
}), AE = /* @__PURE__ */ L("$ZodCheckOverwrite", (r, e) => {
  Lt.init(r, e), r._zod.check = (t) => {
    t.value = e.tx(t.value);
  };
});
class $E {
  constructor(e = []) {
    this.content = [], this.indent = 0, this && (this.args = e);
  }
  indented(e) {
    this.indent += 1, e(this), this.indent -= 1;
  }
  write(e) {
    if (typeof e == "function") {
      e(this, { execution: "sync" }), e(this, { execution: "async" });
      return;
    }
    const n = e.split(`
`).filter((i) => i), s = Math.min(...n.map((i) => i.length - i.trimStart().length)), a = n.map((i) => i.slice(s)).map((i) => " ".repeat(this.indent * 2) + i);
    for (const i of a)
      this.content.push(i);
  }
  compile() {
    const e = Function, t = this == null ? void 0 : this.args, s = [...((this == null ? void 0 : this.content) ?? [""]).map((a) => `  ${a}`)];
    return new e(...t, s.join(`
`));
  }
}
const CE = {
  major: 4,
  minor: 1,
  patch: 13
}, Ye = /* @__PURE__ */ L("$ZodType", (r, e) => {
  var s;
  var t;
  r ?? (r = {}), r._zod.def = e, r._zod.bag = r._zod.bag || {}, r._zod.version = CE;
  const n = [...r._zod.def.checks ?? []];
  r._zod.traits.has("$ZodCheck") && n.unshift(r);
  for (const a of n)
    for (const i of a._zod.onattach)
      i(r);
  if (n.length === 0)
    (t = r._zod).deferred ?? (t.deferred = []), (s = r._zod.deferred) == null || s.push(() => {
      r._zod.run = r._zod.parse;
    });
  else {
    const a = (o, c, u) => {
      let l = Jn(o), d;
      for (const h of c) {
        if (h._zod.def.when) {
          if (!h._zod.def.when(o))
            continue;
        } else if (l)
          continue;
        const f = o.issues.length, p = h._zod.check(o);
        if (p instanceof Promise && (u == null ? void 0 : u.async) === !1)
          throw new Kn();
        if (d || p instanceof Promise)
          d = (d ?? Promise.resolve()).then(async () => {
            await p, o.issues.length !== f && (l || (l = Jn(o, f)));
          });
        else {
          if (o.issues.length === f)
            continue;
          l || (l = Jn(o, f));
        }
      }
      return d ? d.then(() => o) : o;
    }, i = (o, c, u) => {
      if (Jn(o))
        return o.aborted = !0, o;
      const l = a(c, n, u);
      if (l instanceof Promise) {
        if (u.async === !1)
          throw new Kn();
        return l.then((d) => r._zod.parse(d, u));
      }
      return r._zod.parse(l, u);
    };
    r._zod.run = (o, c) => {
      if (c.skipChecks)
        return r._zod.parse(o, c);
      if (c.direction === "backward") {
        const l = r._zod.parse({ value: o.value, issues: [] }, { ...c, skipChecks: !0 });
        return l instanceof Promise ? l.then((d) => i(d, o, c)) : i(l, o, c);
      }
      const u = r._zod.parse(o, c);
      if (u instanceof Promise) {
        if (c.async === !1)
          throw new Kn();
        return u.then((l) => a(l, n, c));
      }
      return a(u, n, c);
    };
  }
  r["~standard"] = {
    validate: (a) => {
      var i;
      try {
        const o = MT(r, a);
        return o.success ? { value: o.data } : { issues: (i = o.error) == null ? void 0 : i.issues };
      } catch {
        return DT(r, a).then((c) => {
          var u;
          return c.success ? { value: c.data } : { issues: (u = c.error) == null ? void 0 : u.issues };
        });
      }
    },
    vendor: "zod",
    version: 1
  };
}), kl = /* @__PURE__ */ L("$ZodString", (r, e) => {
  var t;
  Ye.init(r, e), r._zod.pattern = [...((t = r == null ? void 0 : r._zod.bag) == null ? void 0 : t.patterns) ?? []].pop() ?? hE(r._zod.bag), r._zod.parse = (n, s) => {
    if (e.coerce)
      try {
        n.value = String(n.value);
      } catch {
      }
    return typeof n.value == "string" || n.issues.push({
      expected: "string",
      code: "invalid_type",
      input: n.value,
      inst: r
    }), n;
  };
}), Ve = /* @__PURE__ */ L("$ZodStringFormat", (r, e) => {
  To.init(r, e), kl.init(r, e);
}), RE = /* @__PURE__ */ L("$ZodGUID", (r, e) => {
  e.pattern ?? (e.pattern = QT), Ve.init(r, e);
}), NE = /* @__PURE__ */ L("$ZodUUID", (r, e) => {
  if (e.version) {
    const n = {
      v1: 1,
      v2: 2,
      v3: 3,
      v4: 4,
      v5: 5,
      v6: 6,
      v7: 7,
      v8: 8
    }[e.version];
    if (n === void 0)
      throw new Error(`Invalid UUID version: "${e.version}"`);
    e.pattern ?? (e.pattern = _h(n));
  } else
    e.pattern ?? (e.pattern = _h());
  Ve.init(r, e);
}), PE = /* @__PURE__ */ L("$ZodEmail", (r, e) => {
  e.pattern ?? (e.pattern = eE), Ve.init(r, e);
}), LE = /* @__PURE__ */ L("$ZodURL", (r, e) => {
  Ve.init(r, e), r._zod.check = (t) => {
    try {
      const n = t.value.trim(), s = new URL(n);
      e.hostname && (e.hostname.lastIndex = 0, e.hostname.test(s.hostname) || t.issues.push({
        code: "invalid_format",
        format: "url",
        note: "Invalid hostname",
        pattern: e.hostname.source,
        input: t.value,
        inst: r,
        continue: !e.abort
      })), e.protocol && (e.protocol.lastIndex = 0, e.protocol.test(s.protocol.endsWith(":") ? s.protocol.slice(0, -1) : s.protocol) || t.issues.push({
        code: "invalid_format",
        format: "url",
        note: "Invalid protocol",
        pattern: e.protocol.source,
        input: t.value,
        inst: r,
        continue: !e.abort
      })), e.normalize ? t.value = s.href : t.value = n;
      return;
    } catch {
      t.issues.push({
        code: "invalid_format",
        format: "url",
        input: t.value,
        inst: r,
        continue: !e.abort
      });
    }
  };
}), ME = /* @__PURE__ */ L("$ZodEmoji", (r, e) => {
  e.pattern ?? (e.pattern = rE()), Ve.init(r, e);
}), DE = /* @__PURE__ */ L("$ZodNanoID", (r, e) => {
  e.pattern ?? (e.pattern = YT), Ve.init(r, e);
}), jE = /* @__PURE__ */ L("$ZodCUID", (r, e) => {
  e.pattern ?? (e.pattern = JT), Ve.init(r, e);
}), FE = /* @__PURE__ */ L("$ZodCUID2", (r, e) => {
  e.pattern ?? (e.pattern = HT), Ve.init(r, e);
}), UE = /* @__PURE__ */ L("$ZodULID", (r, e) => {
  e.pattern ?? (e.pattern = GT), Ve.init(r, e);
}), zE = /* @__PURE__ */ L("$ZodXID", (r, e) => {
  e.pattern ?? (e.pattern = WT), Ve.init(r, e);
}), BE = /* @__PURE__ */ L("$ZodKSUID", (r, e) => {
  e.pattern ?? (e.pattern = KT), Ve.init(r, e);
}), ZE = /* @__PURE__ */ L("$ZodISODateTime", (r, e) => {
  e.pattern ?? (e.pattern = dE(e)), Ve.init(r, e);
}), VE = /* @__PURE__ */ L("$ZodISODate", (r, e) => {
  e.pattern ?? (e.pattern = uE), Ve.init(r, e);
}), qE = /* @__PURE__ */ L("$ZodISOTime", (r, e) => {
  e.pattern ?? (e.pattern = lE(e)), Ve.init(r, e);
}), JE = /* @__PURE__ */ L("$ZodISODuration", (r, e) => {
  e.pattern ?? (e.pattern = XT), Ve.init(r, e);
}), HE = /* @__PURE__ */ L("$ZodIPv4", (r, e) => {
  e.pattern ?? (e.pattern = nE), Ve.init(r, e), r._zod.bag.format = "ipv4";
}), GE = /* @__PURE__ */ L("$ZodIPv6", (r, e) => {
  e.pattern ?? (e.pattern = sE), Ve.init(r, e), r._zod.bag.format = "ipv6", r._zod.check = (t) => {
    try {
      new URL(`http://[${t.value}]`);
    } catch {
      t.issues.push({
        code: "invalid_format",
        format: "ipv6",
        input: t.value,
        inst: r,
        continue: !e.abort
      });
    }
  };
}), WE = /* @__PURE__ */ L("$ZodCIDRv4", (r, e) => {
  e.pattern ?? (e.pattern = aE), Ve.init(r, e);
}), KE = /* @__PURE__ */ L("$ZodCIDRv6", (r, e) => {
  e.pattern ?? (e.pattern = iE), Ve.init(r, e), r._zod.check = (t) => {
    const n = t.value.split("/");
    try {
      if (n.length !== 2)
        throw new Error();
      const [s, a] = n;
      if (!a)
        throw new Error();
      const i = Number(a);
      if (`${i}` !== a)
        throw new Error();
      if (i < 0 || i > 128)
        throw new Error();
      new URL(`http://[${s}]`);
    } catch {
      t.issues.push({
        code: "invalid_format",
        format: "cidrv6",
        input: t.value,
        inst: r,
        continue: !e.abort
      });
    }
  };
});
function zg(r) {
  if (r === "")
    return !0;
  if (r.length % 4 !== 0)
    return !1;
  try {
    return atob(r), !0;
  } catch {
    return !1;
  }
}
const YE = /* @__PURE__ */ L("$ZodBase64", (r, e) => {
  e.pattern ?? (e.pattern = oE), Ve.init(r, e), r._zod.bag.contentEncoding = "base64", r._zod.check = (t) => {
    zg(t.value) || t.issues.push({
      code: "invalid_format",
      format: "base64",
      input: t.value,
      inst: r,
      continue: !e.abort
    });
  };
});
function XE(r) {
  if (!Lg.test(r))
    return !1;
  const e = r.replace(/[-_]/g, (n) => n === "-" ? "+" : "/"), t = e.padEnd(Math.ceil(e.length / 4) * 4, "=");
  return zg(t);
}
const QE = /* @__PURE__ */ L("$ZodBase64URL", (r, e) => {
  e.pattern ?? (e.pattern = Lg), Ve.init(r, e), r._zod.bag.contentEncoding = "base64url", r._zod.check = (t) => {
    XE(t.value) || t.issues.push({
      code: "invalid_format",
      format: "base64url",
      input: t.value,
      inst: r,
      continue: !e.abort
    });
  };
}), ex = /* @__PURE__ */ L("$ZodE164", (r, e) => {
  e.pattern ?? (e.pattern = cE), Ve.init(r, e);
});
function tx(r, e = null) {
  try {
    const t = r.split(".");
    if (t.length !== 3)
      return !1;
    const [n] = t;
    if (!n)
      return !1;
    const s = JSON.parse(atob(n));
    return !("typ" in s && (s == null ? void 0 : s.typ) !== "JWT" || !s.alg || e && (!("alg" in s) || s.alg !== e));
  } catch {
    return !1;
  }
}
const rx = /* @__PURE__ */ L("$ZodJWT", (r, e) => {
  Ve.init(r, e), r._zod.check = (t) => {
    tx(t.value, e.alg) || t.issues.push({
      code: "invalid_format",
      format: "jwt",
      input: t.value,
      inst: r,
      continue: !e.abort
    });
  };
}), Bg = /* @__PURE__ */ L("$ZodNumber", (r, e) => {
  Ye.init(r, e), r._zod.pattern = r._zod.bag.pattern ?? pE, r._zod.parse = (t, n) => {
    if (e.coerce)
      try {
        t.value = Number(t.value);
      } catch {
      }
    const s = t.value;
    if (typeof s == "number" && !Number.isNaN(s) && Number.isFinite(s))
      return t;
    const a = typeof s == "number" ? Number.isNaN(s) ? "NaN" : Number.isFinite(s) ? void 0 : "Infinity" : void 0;
    return t.issues.push({
      expected: "number",
      code: "invalid_type",
      input: s,
      inst: r,
      ...a ? { received: a } : {}
    }), t;
  };
}), nx = /* @__PURE__ */ L("$ZodNumberFormat", (r, e) => {
  wE.init(r, e), Bg.init(r, e);
}), sx = /* @__PURE__ */ L("$ZodBoolean", (r, e) => {
  Ye.init(r, e), r._zod.pattern = mE, r._zod.parse = (t, n) => {
    if (e.coerce)
      try {
        t.value = !!t.value;
      } catch {
      }
    const s = t.value;
    return typeof s == "boolean" || t.issues.push({
      expected: "boolean",
      code: "invalid_type",
      input: s,
      inst: r
    }), t;
  };
}), Zg = /* @__PURE__ */ L("$ZodUnknown", (r, e) => {
  Ye.init(r, e), r._zod.parse = (t) => t;
}), Vg = /* @__PURE__ */ L("$ZodNever", (r, e) => {
  Ye.init(r, e), r._zod.parse = (t, n) => (t.issues.push({
    expected: "never",
    code: "invalid_type",
    input: t.value,
    inst: r
  }), t);
});
function yh(r, e, t) {
  r.issues.length && e.issues.push(...Hn(t, r.issues)), e.value[t] = r.value;
}
const ax = /* @__PURE__ */ L("$ZodArray", (r, e) => {
  Ye.init(r, e), r._zod.parse = (t, n) => {
    const s = t.value;
    if (!Array.isArray(s))
      return t.issues.push({
        expected: "array",
        code: "invalid_type",
        input: s,
        inst: r
      }), t;
    t.value = Array(s.length);
    const a = [];
    for (let i = 0; i < s.length; i++) {
      const o = s[i], c = e.element._zod.run({
        value: o,
        issues: []
      }, n);
      c instanceof Promise ? a.push(c.then((u) => yh(u, t, i))) : yh(c, t, i);
    }
    return a.length ? Promise.all(a).then(() => t) : t;
  };
});
function $i(r, e, t, n) {
  r.issues.length && e.issues.push(...Hn(t, r.issues)), r.value === void 0 ? t in n && (e.value[t] = void 0) : e.value[t] = r.value;
}
function qg(r) {
  var n, s, a, i;
  const e = Object.keys(r.shape);
  for (const o of e)
    if (!((i = (a = (s = (n = r.shape) == null ? void 0 : n[o]) == null ? void 0 : s._zod) == null ? void 0 : a.traits) != null && i.has("$ZodType")))
      throw new Error(`Invalid element at key "${o}": expected a Zod schema`);
  const t = xT(r.shape);
  return {
    ...r,
    keys: e,
    keySet: new Set(e),
    numKeys: e.length,
    optionalKeys: new Set(t)
  };
}
function Jg(r, e, t, n, s, a) {
  const i = [], o = s.keySet, c = s.catchall._zod, u = c.def.type;
  for (const l in e) {
    if (o.has(l))
      continue;
    if (u === "never") {
      i.push(l);
      continue;
    }
    const d = c.run({ value: e[l], issues: [] }, n);
    d instanceof Promise ? r.push(d.then((h) => $i(h, t, l, e))) : $i(d, t, l, e);
  }
  return i.length && t.issues.push({
    code: "unrecognized_keys",
    keys: i,
    input: e,
    inst: a
  }), r.length ? Promise.all(r).then(() => t) : t;
}
const ix = /* @__PURE__ */ L("$ZodObject", (r, e) => {
  Ye.init(r, e);
  const t = Object.getOwnPropertyDescriptor(e, "shape");
  if (!(t != null && t.get)) {
    const o = e.shape;
    Object.defineProperty(e, "shape", {
      get: () => {
        const c = { ...o };
        return Object.defineProperty(e, "shape", {
          value: c
        }), c;
      }
    });
  }
  const n = Sl(() => qg(e));
  ze(r._zod, "propValues", () => {
    const o = e.shape, c = {};
    for (const u in o) {
      const l = o[u]._zod;
      if (l.values) {
        c[u] ?? (c[u] = /* @__PURE__ */ new Set());
        for (const d of l.values)
          c[u].add(d);
      }
    }
    return c;
  });
  const s = Ai, a = e.catchall;
  let i;
  r._zod.parse = (o, c) => {
    i ?? (i = n.value);
    const u = o.value;
    if (!s(u))
      return o.issues.push({
        expected: "object",
        code: "invalid_type",
        input: u,
        inst: r
      }), o;
    o.value = {};
    const l = [], d = i.shape;
    for (const h of i.keys) {
      const p = d[h]._zod.run({ value: u[h], issues: [] }, c);
      p instanceof Promise ? l.push(p.then((y) => $i(y, o, h, u))) : $i(p, o, h, u);
    }
    return a ? Jg(l, u, o, c, n.value, r) : l.length ? Promise.all(l).then(() => o) : o;
  };
}), ox = /* @__PURE__ */ L("$ZodObjectJIT", (r, e) => {
  ix.init(r, e);
  const t = r._zod.parse, n = Sl(() => qg(e)), s = (h) => {
    const f = new $E(["shape", "payload", "ctx"]), p = n.value, y = (w) => {
      const T = gh(w);
      return `shape[${T}]._zod.run({ value: input[${T}], issues: [] }, ctx)`;
    };
    f.write("const input = payload.value;");
    const m = /* @__PURE__ */ Object.create(null);
    let v = 0;
    for (const w of p.keys)
      m[w] = `key_${v++}`;
    f.write("const newResult = {};");
    for (const w of p.keys) {
      const T = m[w], x = gh(w);
      f.write(`const ${T} = ${y(w)};`), f.write(`
        if (${T}.issues.length) {
          payload.issues = payload.issues.concat(${T}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${x}, ...iss.path] : [${x}]
          })));
        }
        
        
        if (${T}.value === undefined) {
          if (${x} in input) {
            newResult[${x}] = undefined;
          }
        } else {
          newResult[${x}] = ${T}.value;
        }
        
      `);
    }
    f.write("payload.value = newResult;"), f.write("return payload;");
    const g = f.compile();
    return (w, T) => g(h, w, T);
  };
  let a;
  const i = Ai, o = !kg.jitless, u = o && TT.value, l = e.catchall;
  let d;
  r._zod.parse = (h, f) => {
    d ?? (d = n.value);
    const p = h.value;
    return i(p) ? o && u && (f == null ? void 0 : f.async) === !1 && f.jitless !== !0 ? (a || (a = s(e.shape)), h = a(h, f), l ? Jg([], p, h, f, d, r) : h) : t(h, f) : (h.issues.push({
      expected: "object",
      code: "invalid_type",
      input: p,
      inst: r
    }), h);
  };
});
function wh(r, e, t, n) {
  for (const a of r)
    if (a.issues.length === 0)
      return e.value = a.value, e;
  const s = r.filter((a) => !Jn(a));
  return s.length === 1 ? (e.value = s[0].value, s[0]) : (e.issues.push({
    code: "invalid_union",
    input: e.value,
    inst: t,
    errors: r.map((a) => a.issues.map((i) => cn(i, n, on())))
  }), e);
}
const cx = /* @__PURE__ */ L("$ZodUnion", (r, e) => {
  Ye.init(r, e), ze(r._zod, "optin", () => e.options.some((s) => s._zod.optin === "optional") ? "optional" : void 0), ze(r._zod, "optout", () => e.options.some((s) => s._zod.optout === "optional") ? "optional" : void 0), ze(r._zod, "values", () => {
    if (e.options.every((s) => s._zod.values))
      return new Set(e.options.flatMap((s) => Array.from(s._zod.values)));
  }), ze(r._zod, "pattern", () => {
    if (e.options.every((s) => s._zod.pattern)) {
      const s = e.options.map((a) => a._zod.pattern);
      return new RegExp(`^(${s.map((a) => El(a.source)).join("|")})$`);
    }
  });
  const t = e.options.length === 1, n = e.options[0]._zod.run;
  r._zod.parse = (s, a) => {
    if (t)
      return n(s, a);
    let i = !1;
    const o = [];
    for (const c of e.options) {
      const u = c._zod.run({
        value: s.value,
        issues: []
      }, a);
      if (u instanceof Promise)
        o.push(u), i = !0;
      else {
        if (u.issues.length === 0)
          return u;
        o.push(u);
      }
    }
    return i ? Promise.all(o).then((c) => wh(c, s, r, a)) : wh(o, s, r, a);
  };
}), ux = /* @__PURE__ */ L("$ZodIntersection", (r, e) => {
  Ye.init(r, e), r._zod.parse = (t, n) => {
    const s = t.value, a = e.left._zod.run({ value: s, issues: [] }, n), i = e.right._zod.run({ value: s, issues: [] }, n);
    return a instanceof Promise || i instanceof Promise ? Promise.all([a, i]).then(([c, u]) => vh(t, c, u)) : vh(t, a, i);
  };
});
function Xc(r, e) {
  if (r === e)
    return { valid: !0, data: r };
  if (r instanceof Date && e instanceof Date && +r == +e)
    return { valid: !0, data: r };
  if (ts(r) && ts(e)) {
    const t = Object.keys(e), n = Object.keys(r).filter((a) => t.indexOf(a) !== -1), s = { ...r, ...e };
    for (const a of n) {
      const i = Xc(r[a], e[a]);
      if (!i.valid)
        return {
          valid: !1,
          mergeErrorPath: [a, ...i.mergeErrorPath]
        };
      s[a] = i.data;
    }
    return { valid: !0, data: s };
  }
  if (Array.isArray(r) && Array.isArray(e)) {
    if (r.length !== e.length)
      return { valid: !1, mergeErrorPath: [] };
    const t = [];
    for (let n = 0; n < r.length; n++) {
      const s = r[n], a = e[n], i = Xc(s, a);
      if (!i.valid)
        return {
          valid: !1,
          mergeErrorPath: [n, ...i.mergeErrorPath]
        };
      t.push(i.data);
    }
    return { valid: !0, data: t };
  }
  return { valid: !1, mergeErrorPath: [] };
}
function vh(r, e, t) {
  if (e.issues.length && r.issues.push(...e.issues), t.issues.length && r.issues.push(...t.issues), Jn(r))
    return r;
  const n = Xc(e.value, t.value);
  if (!n.valid)
    throw new Error(`Unmergable intersection. Error path: ${JSON.stringify(n.mergeErrorPath)}`);
  return r.value = n.data, r;
}
const lx = /* @__PURE__ */ L("$ZodRecord", (r, e) => {
  Ye.init(r, e), r._zod.parse = (t, n) => {
    const s = t.value;
    if (!ts(s))
      return t.issues.push({
        expected: "record",
        code: "invalid_type",
        input: s,
        inst: r
      }), t;
    const a = [], i = e.keyType._zod.values;
    if (i) {
      t.value = {};
      const o = /* @__PURE__ */ new Set();
      for (const u of i)
        if (typeof u == "string" || typeof u == "number" || typeof u == "symbol") {
          o.add(typeof u == "number" ? u.toString() : u);
          const l = e.valueType._zod.run({ value: s[u], issues: [] }, n);
          l instanceof Promise ? a.push(l.then((d) => {
            d.issues.length && t.issues.push(...Hn(u, d.issues)), t.value[u] = d.value;
          })) : (l.issues.length && t.issues.push(...Hn(u, l.issues)), t.value[u] = l.value);
        }
      let c;
      for (const u in s)
        o.has(u) || (c = c ?? [], c.push(u));
      c && c.length > 0 && t.issues.push({
        code: "unrecognized_keys",
        input: s,
        inst: r,
        keys: c
      });
    } else {
      t.value = {};
      for (const o of Reflect.ownKeys(s)) {
        if (o === "__proto__")
          continue;
        const c = e.keyType._zod.run({ value: o, issues: [] }, n);
        if (c instanceof Promise)
          throw new Error("Async schemas not supported in object keys currently");
        if (c.issues.length) {
          t.issues.push({
            code: "invalid_key",
            origin: "record",
            issues: c.issues.map((l) => cn(l, n, on())),
            input: o,
            path: [o],
            inst: r
          }), t.value[c.value] = c.value;
          continue;
        }
        const u = e.valueType._zod.run({ value: s[o], issues: [] }, n);
        u instanceof Promise ? a.push(u.then((l) => {
          l.issues.length && t.issues.push(...Hn(o, l.issues)), t.value[c.value] = l.value;
        })) : (u.issues.length && t.issues.push(...Hn(o, u.issues)), t.value[c.value] = u.value);
      }
    }
    return a.length ? Promise.all(a).then(() => t) : t;
  };
}), dx = /* @__PURE__ */ L("$ZodEnum", (r, e) => {
  Ye.init(r, e);
  const t = Ig(e.entries), n = new Set(t);
  r._zod.values = n, r._zod.pattern = new RegExp(`^(${t.filter((s) => ET.has(typeof s)).map((s) => typeof s == "string" ? go(s) : s.toString()).join("|")})$`), r._zod.parse = (s, a) => {
    const i = s.value;
    return n.has(i) || s.issues.push({
      code: "invalid_value",
      values: t,
      input: i,
      inst: r
    }), s;
  };
}), hx = /* @__PURE__ */ L("$ZodTransform", (r, e) => {
  Ye.init(r, e), r._zod.parse = (t, n) => {
    if (n.direction === "backward")
      throw new xg(r.constructor.name);
    const s = e.transform(t.value, t);
    if (n.async)
      return (s instanceof Promise ? s : Promise.resolve(s)).then((i) => (t.value = i, t));
    if (s instanceof Promise)
      throw new Kn();
    return t.value = s, t;
  };
});
function bh(r, e) {
  return r.issues.length && e === void 0 ? { issues: [], value: void 0 } : r;
}
const Il = /* @__PURE__ */ L("$ZodOptional", (r, e) => {
  Ye.init(r, e), r._zod.optin = "optional", r._zod.optout = "optional", ze(r._zod, "values", () => e.innerType._zod.values ? /* @__PURE__ */ new Set([...e.innerType._zod.values, void 0]) : void 0), ze(r._zod, "pattern", () => {
    const t = e.innerType._zod.pattern;
    return t ? new RegExp(`^(${El(t.source)})?$`) : void 0;
  }), r._zod.parse = (t, n) => {
    if (e.innerType._zod.optin === "optional") {
      const s = e.innerType._zod.run(t, n);
      return s instanceof Promise ? s.then((a) => bh(a, t.value)) : bh(s, t.value);
    }
    return t.value === void 0 ? t : e.innerType._zod.run(t, n);
  };
}), fx = /* @__PURE__ */ L("$ZodNullable", (r, e) => {
  Ye.init(r, e), ze(r._zod, "optin", () => e.innerType._zod.optin), ze(r._zod, "optout", () => e.innerType._zod.optout), ze(r._zod, "pattern", () => {
    const t = e.innerType._zod.pattern;
    return t ? new RegExp(`^(${El(t.source)}|null)$`) : void 0;
  }), ze(r._zod, "values", () => e.innerType._zod.values ? /* @__PURE__ */ new Set([...e.innerType._zod.values, null]) : void 0), r._zod.parse = (t, n) => t.value === null ? t : e.innerType._zod.run(t, n);
}), px = /* @__PURE__ */ L("$ZodDefault", (r, e) => {
  Ye.init(r, e), r._zod.optin = "optional", ze(r._zod, "values", () => e.innerType._zod.values), r._zod.parse = (t, n) => {
    if (n.direction === "backward")
      return e.innerType._zod.run(t, n);
    if (t.value === void 0)
      return t.value = e.defaultValue, t;
    const s = e.innerType._zod.run(t, n);
    return s instanceof Promise ? s.then((a) => Sh(a, e)) : Sh(s, e);
  };
});
function Sh(r, e) {
  return r.value === void 0 && (r.value = e.defaultValue), r;
}
const mx = /* @__PURE__ */ L("$ZodPrefault", (r, e) => {
  Ye.init(r, e), r._zod.optin = "optional", ze(r._zod, "values", () => e.innerType._zod.values), r._zod.parse = (t, n) => (n.direction === "backward" || t.value === void 0 && (t.value = e.defaultValue), e.innerType._zod.run(t, n));
}), gx = /* @__PURE__ */ L("$ZodNonOptional", (r, e) => {
  Ye.init(r, e), ze(r._zod, "values", () => {
    const t = e.innerType._zod.values;
    return t ? new Set([...t].filter((n) => n !== void 0)) : void 0;
  }), r._zod.parse = (t, n) => {
    const s = e.innerType._zod.run(t, n);
    return s instanceof Promise ? s.then((a) => Th(a, r)) : Th(s, r);
  };
});
function Th(r, e) {
  return !r.issues.length && r.value === void 0 && r.issues.push({
    code: "invalid_type",
    expected: "nonoptional",
    input: r.value,
    inst: e
  }), r;
}
const _x = /* @__PURE__ */ L("$ZodCatch", (r, e) => {
  Ye.init(r, e), ze(r._zod, "optin", () => e.innerType._zod.optin), ze(r._zod, "optout", () => e.innerType._zod.optout), ze(r._zod, "values", () => e.innerType._zod.values), r._zod.parse = (t, n) => {
    if (n.direction === "backward")
      return e.innerType._zod.run(t, n);
    const s = e.innerType._zod.run(t, n);
    return s instanceof Promise ? s.then((a) => (t.value = a.value, a.issues.length && (t.value = e.catchValue({
      ...t,
      error: {
        issues: a.issues.map((i) => cn(i, n, on()))
      },
      input: t.value
    }), t.issues = []), t)) : (t.value = s.value, s.issues.length && (t.value = e.catchValue({
      ...t,
      error: {
        issues: s.issues.map((a) => cn(a, n, on()))
      },
      input: t.value
    }), t.issues = []), t);
  };
}), yx = /* @__PURE__ */ L("$ZodPipe", (r, e) => {
  Ye.init(r, e), ze(r._zod, "values", () => e.in._zod.values), ze(r._zod, "optin", () => e.in._zod.optin), ze(r._zod, "optout", () => e.out._zod.optout), ze(r._zod, "propValues", () => e.in._zod.propValues), r._zod.parse = (t, n) => {
    if (n.direction === "backward") {
      const a = e.out._zod.run(t, n);
      return a instanceof Promise ? a.then((i) => Za(i, e.in, n)) : Za(a, e.in, n);
    }
    const s = e.in._zod.run(t, n);
    return s instanceof Promise ? s.then((a) => Za(a, e.out, n)) : Za(s, e.out, n);
  };
});
function Za(r, e, t) {
  return r.issues.length ? (r.aborted = !0, r) : e._zod.run({ value: r.value, issues: r.issues }, t);
}
const wx = /* @__PURE__ */ L("$ZodReadonly", (r, e) => {
  Ye.init(r, e), ze(r._zod, "propValues", () => e.innerType._zod.propValues), ze(r._zod, "values", () => e.innerType._zod.values), ze(r._zod, "optin", () => {
    var t, n;
    return (n = (t = e.innerType) == null ? void 0 : t._zod) == null ? void 0 : n.optin;
  }), ze(r._zod, "optout", () => {
    var t, n;
    return (n = (t = e.innerType) == null ? void 0 : t._zod) == null ? void 0 : n.optout;
  }), r._zod.parse = (t, n) => {
    if (n.direction === "backward")
      return e.innerType._zod.run(t, n);
    const s = e.innerType._zod.run(t, n);
    return s instanceof Promise ? s.then(Eh) : Eh(s);
  };
});
function Eh(r) {
  return r.value = Object.freeze(r.value), r;
}
const vx = /* @__PURE__ */ L("$ZodCustom", (r, e) => {
  Lt.init(r, e), Ye.init(r, e), r._zod.parse = (t, n) => t, r._zod.check = (t) => {
    const n = t.value, s = e.fn(n);
    if (s instanceof Promise)
      return s.then((a) => xh(a, t, n, r));
    xh(s, t, n, r);
  };
});
function xh(r, e, t, n) {
  if (!r) {
    const s = {
      code: "custom",
      input: t,
      inst: n,
      // incorporates params.error into issue reporting
      path: [...n._zod.def.path ?? []],
      // incorporates params.error into issue reporting
      continue: !n._zod.def.abort
      // params: inst._zod.def.params,
    };
    n._zod.def.params && (s.params = n._zod.def.params), e.issues.push(ea(s));
  }
}
var kh;
class Hg {
  constructor() {
    this._map = /* @__PURE__ */ new WeakMap(), this._idmap = /* @__PURE__ */ new Map();
  }
  add(e, ...t) {
    const n = t[0];
    if (this._map.set(e, n), n && typeof n == "object" && "id" in n) {
      if (this._idmap.has(n.id))
        throw new Error(`ID ${n.id} already exists in the registry`);
      this._idmap.set(n.id, e);
    }
    return this;
  }
  clear() {
    return this._map = /* @__PURE__ */ new WeakMap(), this._idmap = /* @__PURE__ */ new Map(), this;
  }
  remove(e) {
    const t = this._map.get(e);
    return t && typeof t == "object" && "id" in t && this._idmap.delete(t.id), this._map.delete(e), this;
  }
  get(e) {
    const t = e._zod.parent;
    if (t) {
      const n = { ...this.get(t) ?? {} };
      delete n.id;
      const s = { ...n, ...this._map.get(e) };
      return Object.keys(s).length ? s : void 0;
    }
    return this._map.get(e);
  }
  has(e) {
    return this._map.has(e);
  }
}
function bx() {
  return new Hg();
}
(kh = globalThis).__zod_globalRegistry ?? (kh.__zod_globalRegistry = bx());
const pt = globalThis.__zod_globalRegistry;
function Sx(r, e) {
  return new r({
    type: "string",
    ...le(e)
  });
}
function Tx(r, e) {
  return new r({
    type: "string",
    format: "email",
    check: "string_format",
    abort: !1,
    ...le(e)
  });
}
function Ih(r, e) {
  return new r({
    type: "string",
    format: "guid",
    check: "string_format",
    abort: !1,
    ...le(e)
  });
}
function Ex(r, e) {
  return new r({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    ...le(e)
  });
}
function xx(r, e) {
  return new r({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    version: "v4",
    ...le(e)
  });
}
function kx(r, e) {
  return new r({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    version: "v6",
    ...le(e)
  });
}
function Ix(r, e) {
  return new r({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    version: "v7",
    ...le(e)
  });
}
function Ox(r, e) {
  return new r({
    type: "string",
    format: "url",
    check: "string_format",
    abort: !1,
    ...le(e)
  });
}
function Ax(r, e) {
  return new r({
    type: "string",
    format: "emoji",
    check: "string_format",
    abort: !1,
    ...le(e)
  });
}
function $x(r, e) {
  return new r({
    type: "string",
    format: "nanoid",
    check: "string_format",
    abort: !1,
    ...le(e)
  });
}
function Cx(r, e) {
  return new r({
    type: "string",
    format: "cuid",
    check: "string_format",
    abort: !1,
    ...le(e)
  });
}
function Rx(r, e) {
  return new r({
    type: "string",
    format: "cuid2",
    check: "string_format",
    abort: !1,
    ...le(e)
  });
}
function Nx(r, e) {
  return new r({
    type: "string",
    format: "ulid",
    check: "string_format",
    abort: !1,
    ...le(e)
  });
}
function Px(r, e) {
  return new r({
    type: "string",
    format: "xid",
    check: "string_format",
    abort: !1,
    ...le(e)
  });
}
function Lx(r, e) {
  return new r({
    type: "string",
    format: "ksuid",
    check: "string_format",
    abort: !1,
    ...le(e)
  });
}
function Mx(r, e) {
  return new r({
    type: "string",
    format: "ipv4",
    check: "string_format",
    abort: !1,
    ...le(e)
  });
}
function Dx(r, e) {
  return new r({
    type: "string",
    format: "ipv6",
    check: "string_format",
    abort: !1,
    ...le(e)
  });
}
function jx(r, e) {
  return new r({
    type: "string",
    format: "cidrv4",
    check: "string_format",
    abort: !1,
    ...le(e)
  });
}
function Fx(r, e) {
  return new r({
    type: "string",
    format: "cidrv6",
    check: "string_format",
    abort: !1,
    ...le(e)
  });
}
function Ux(r, e) {
  return new r({
    type: "string",
    format: "base64",
    check: "string_format",
    abort: !1,
    ...le(e)
  });
}
function zx(r, e) {
  return new r({
    type: "string",
    format: "base64url",
    check: "string_format",
    abort: !1,
    ...le(e)
  });
}
function Bx(r, e) {
  return new r({
    type: "string",
    format: "e164",
    check: "string_format",
    abort: !1,
    ...le(e)
  });
}
function Zx(r, e) {
  return new r({
    type: "string",
    format: "jwt",
    check: "string_format",
    abort: !1,
    ...le(e)
  });
}
function Vx(r, e) {
  return new r({
    type: "string",
    format: "datetime",
    check: "string_format",
    offset: !1,
    local: !1,
    precision: null,
    ...le(e)
  });
}
function qx(r, e) {
  return new r({
    type: "string",
    format: "date",
    check: "string_format",
    ...le(e)
  });
}
function Jx(r, e) {
  return new r({
    type: "string",
    format: "time",
    check: "string_format",
    precision: null,
    ...le(e)
  });
}
function Hx(r, e) {
  return new r({
    type: "string",
    format: "duration",
    check: "string_format",
    ...le(e)
  });
}
function Gx(r, e) {
  return new r({
    type: "number",
    checks: [],
    ...le(e)
  });
}
function Wx(r, e) {
  return new r({
    type: "number",
    check: "number_format",
    abort: !1,
    format: "safeint",
    ...le(e)
  });
}
function Kx(r, e) {
  return new r({
    type: "boolean",
    ...le(e)
  });
}
function Gg(r) {
  return new r({
    type: "unknown"
  });
}
function Wg(r, e) {
  return new r({
    type: "never",
    ...le(e)
  });
}
function Oh(r, e) {
  return new Fg({
    check: "less_than",
    ...le(e),
    value: r,
    inclusive: !1
  });
}
function uc(r, e) {
  return new Fg({
    check: "less_than",
    ...le(e),
    value: r,
    inclusive: !0
  });
}
function Ah(r, e) {
  return new Ug({
    check: "greater_than",
    ...le(e),
    value: r,
    inclusive: !1
  });
}
function lc(r, e) {
  return new Ug({
    check: "greater_than",
    ...le(e),
    value: r,
    inclusive: !0
  });
}
function $h(r, e) {
  return new yE({
    check: "multiple_of",
    ...le(e),
    value: r
  });
}
function Kg(r, e) {
  return new vE({
    check: "max_length",
    ...le(e),
    maximum: r
  });
}
function Ci(r, e) {
  return new bE({
    check: "min_length",
    ...le(e),
    minimum: r
  });
}
function Yg(r, e) {
  return new SE({
    check: "length_equals",
    ...le(e),
    length: r
  });
}
function Yx(r, e) {
  return new TE({
    check: "string_format",
    format: "regex",
    ...le(e),
    pattern: r
  });
}
function Xx(r) {
  return new EE({
    check: "string_format",
    format: "lowercase",
    ...le(r)
  });
}
function Qx(r) {
  return new xE({
    check: "string_format",
    format: "uppercase",
    ...le(r)
  });
}
function ek(r, e) {
  return new kE({
    check: "string_format",
    format: "includes",
    ...le(e),
    includes: r
  });
}
function tk(r, e) {
  return new IE({
    check: "string_format",
    format: "starts_with",
    ...le(e),
    prefix: r
  });
}
function rk(r, e) {
  return new OE({
    check: "string_format",
    format: "ends_with",
    ...le(e),
    suffix: r
  });
}
function hs(r) {
  return new AE({
    check: "overwrite",
    tx: r
  });
}
function nk(r) {
  return hs((e) => e.normalize(r));
}
function sk() {
  return hs((r) => r.trim());
}
function ak() {
  return hs((r) => r.toLowerCase());
}
function ik() {
  return hs((r) => r.toUpperCase());
}
function ok() {
  return hs((r) => ST(r));
}
function ck(r, e, t) {
  return new r({
    type: "array",
    element: e,
    // get element() {
    //   return element;
    // },
    ...le(t)
  });
}
function uk(r, e, t) {
  return new r({
    type: "custom",
    check: "custom",
    fn: e,
    ...le(t)
  });
}
function lk(r) {
  const e = dk((t) => (t.addIssue = (n) => {
    if (typeof n == "string")
      t.issues.push(ea(n, t.value, e._zod.def));
    else {
      const s = n;
      s.fatal && (s.continue = !1), s.code ?? (s.code = "custom"), s.input ?? (s.input = t.value), s.inst ?? (s.inst = e), s.continue ?? (s.continue = !e._zod.def.abort), t.issues.push(ea(s));
    }
  }, r(t.value, t)));
  return e;
}
function dk(r, e) {
  const t = new Lt({
    check: "custom",
    ...le(e)
  });
  return t._zod.check = r, t;
}
class Ch {
  constructor(e) {
    this.counter = 0, this.metadataRegistry = (e == null ? void 0 : e.metadata) ?? pt, this.target = (e == null ? void 0 : e.target) ?? "draft-2020-12", this.unrepresentable = (e == null ? void 0 : e.unrepresentable) ?? "throw", this.override = (e == null ? void 0 : e.override) ?? (() => {
    }), this.io = (e == null ? void 0 : e.io) ?? "output", this.seen = /* @__PURE__ */ new Map();
  }
  process(e, t = { path: [], schemaPath: [] }) {
    var d, h, f;
    var n;
    const s = e._zod.def, a = {
      guid: "uuid",
      url: "uri",
      datetime: "date-time",
      json_string: "json-string",
      regex: ""
      // do not set
    }, i = this.seen.get(e);
    if (i)
      return i.count++, t.schemaPath.includes(e) && (i.cycle = t.path), i.schema;
    const o = { schema: {}, count: 1, cycle: void 0, path: t.path };
    this.seen.set(e, o);
    const c = (h = (d = e._zod).toJSONSchema) == null ? void 0 : h.call(d);
    if (c)
      o.schema = c;
    else {
      const p = {
        ...t,
        schemaPath: [...t.schemaPath, e],
        path: t.path
      }, y = e._zod.parent;
      if (y)
        o.ref = y, this.process(y, p), this.seen.get(y).isParent = !0;
      else {
        const m = o.schema;
        switch (s.type) {
          case "string": {
            const v = m;
            v.type = "string";
            const { minimum: g, maximum: w, format: T, patterns: x, contentEncoding: O } = e._zod.bag;
            if (typeof g == "number" && (v.minLength = g), typeof w == "number" && (v.maxLength = w), T && (v.format = a[T] ?? T, v.format === "" && delete v.format), O && (v.contentEncoding = O), x && x.size > 0) {
              const R = [...x];
              R.length === 1 ? v.pattern = R[0].source : R.length > 1 && (o.schema.allOf = [
                ...R.map((E) => ({
                  ...this.target === "draft-7" || this.target === "draft-4" || this.target === "openapi-3.0" ? { type: "string" } : {},
                  pattern: E.source
                }))
              ]);
            }
            break;
          }
          case "number": {
            const v = m, { minimum: g, maximum: w, format: T, multipleOf: x, exclusiveMaximum: O, exclusiveMinimum: R } = e._zod.bag;
            typeof T == "string" && T.includes("int") ? v.type = "integer" : v.type = "number", typeof R == "number" && (this.target === "draft-4" || this.target === "openapi-3.0" ? (v.minimum = R, v.exclusiveMinimum = !0) : v.exclusiveMinimum = R), typeof g == "number" && (v.minimum = g, typeof R == "number" && this.target !== "draft-4" && (R >= g ? delete v.minimum : delete v.exclusiveMinimum)), typeof O == "number" && (this.target === "draft-4" || this.target === "openapi-3.0" ? (v.maximum = O, v.exclusiveMaximum = !0) : v.exclusiveMaximum = O), typeof w == "number" && (v.maximum = w, typeof O == "number" && this.target !== "draft-4" && (O <= w ? delete v.maximum : delete v.exclusiveMaximum)), typeof x == "number" && (v.multipleOf = x);
            break;
          }
          case "boolean": {
            const v = m;
            v.type = "boolean";
            break;
          }
          case "bigint": {
            if (this.unrepresentable === "throw")
              throw new Error("BigInt cannot be represented in JSON Schema");
            break;
          }
          case "symbol": {
            if (this.unrepresentable === "throw")
              throw new Error("Symbols cannot be represented in JSON Schema");
            break;
          }
          case "null": {
            this.target === "openapi-3.0" ? (m.type = "string", m.nullable = !0, m.enum = [null]) : m.type = "null";
            break;
          }
          case "any":
            break;
          case "unknown":
            break;
          case "undefined": {
            if (this.unrepresentable === "throw")
              throw new Error("Undefined cannot be represented in JSON Schema");
            break;
          }
          case "void": {
            if (this.unrepresentable === "throw")
              throw new Error("Void cannot be represented in JSON Schema");
            break;
          }
          case "never": {
            m.not = {};
            break;
          }
          case "date": {
            if (this.unrepresentable === "throw")
              throw new Error("Date cannot be represented in JSON Schema");
            break;
          }
          case "array": {
            const v = m, { minimum: g, maximum: w } = e._zod.bag;
            typeof g == "number" && (v.minItems = g), typeof w == "number" && (v.maxItems = w), v.type = "array", v.items = this.process(s.element, { ...p, path: [...p.path, "items"] });
            break;
          }
          case "object": {
            const v = m;
            v.type = "object", v.properties = {};
            const g = s.shape;
            for (const x in g)
              v.properties[x] = this.process(g[x], {
                ...p,
                path: [...p.path, "properties", x]
              });
            const w = new Set(Object.keys(g)), T = new Set([...w].filter((x) => {
              const O = s.shape[x]._zod;
              return this.io === "input" ? O.optin === void 0 : O.optout === void 0;
            }));
            T.size > 0 && (v.required = Array.from(T)), ((f = s.catchall) == null ? void 0 : f._zod.def.type) === "never" ? v.additionalProperties = !1 : s.catchall ? s.catchall && (v.additionalProperties = this.process(s.catchall, {
              ...p,
              path: [...p.path, "additionalProperties"]
            })) : this.io === "output" && (v.additionalProperties = !1);
            break;
          }
          case "union": {
            const v = m, g = s.discriminator !== void 0, w = s.options.map((T, x) => this.process(T, {
              ...p,
              path: [...p.path, g ? "oneOf" : "anyOf", x]
            }));
            g ? v.oneOf = w : v.anyOf = w;
            break;
          }
          case "intersection": {
            const v = m, g = this.process(s.left, {
              ...p,
              path: [...p.path, "allOf", 0]
            }), w = this.process(s.right, {
              ...p,
              path: [...p.path, "allOf", 1]
            }), T = (O) => "allOf" in O && Object.keys(O).length === 1, x = [
              ...T(g) ? g.allOf : [g],
              ...T(w) ? w.allOf : [w]
            ];
            v.allOf = x;
            break;
          }
          case "tuple": {
            const v = m;
            v.type = "array";
            const g = this.target === "draft-2020-12" ? "prefixItems" : "items", w = this.target === "draft-2020-12" || this.target === "openapi-3.0" ? "items" : "additionalItems", T = s.items.map((E, V) => this.process(E, {
              ...p,
              path: [...p.path, g, V]
            })), x = s.rest ? this.process(s.rest, {
              ...p,
              path: [...p.path, w, ...this.target === "openapi-3.0" ? [s.items.length] : []]
            }) : null;
            this.target === "draft-2020-12" ? (v.prefixItems = T, x && (v.items = x)) : this.target === "openapi-3.0" ? (v.items = {
              anyOf: T
            }, x && v.items.anyOf.push(x), v.minItems = T.length, x || (v.maxItems = T.length)) : (v.items = T, x && (v.additionalItems = x));
            const { minimum: O, maximum: R } = e._zod.bag;
            typeof O == "number" && (v.minItems = O), typeof R == "number" && (v.maxItems = R);
            break;
          }
          case "record": {
            const v = m;
            v.type = "object", (this.target === "draft-7" || this.target === "draft-2020-12") && (v.propertyNames = this.process(s.keyType, {
              ...p,
              path: [...p.path, "propertyNames"]
            })), v.additionalProperties = this.process(s.valueType, {
              ...p,
              path: [...p.path, "additionalProperties"]
            });
            break;
          }
          case "map": {
            if (this.unrepresentable === "throw")
              throw new Error("Map cannot be represented in JSON Schema");
            break;
          }
          case "set": {
            if (this.unrepresentable === "throw")
              throw new Error("Set cannot be represented in JSON Schema");
            break;
          }
          case "enum": {
            const v = m, g = Ig(s.entries);
            g.every((w) => typeof w == "number") && (v.type = "number"), g.every((w) => typeof w == "string") && (v.type = "string"), v.enum = g;
            break;
          }
          case "literal": {
            const v = m, g = [];
            for (const w of s.values)
              if (w === void 0) {
                if (this.unrepresentable === "throw")
                  throw new Error("Literal `undefined` cannot be represented in JSON Schema");
              } else if (typeof w == "bigint") {
                if (this.unrepresentable === "throw")
                  throw new Error("BigInt literals cannot be represented in JSON Schema");
                g.push(Number(w));
              } else
                g.push(w);
            if (g.length !== 0) if (g.length === 1) {
              const w = g[0];
              v.type = w === null ? "null" : typeof w, this.target === "draft-4" || this.target === "openapi-3.0" ? v.enum = [w] : v.const = w;
            } else
              g.every((w) => typeof w == "number") && (v.type = "number"), g.every((w) => typeof w == "string") && (v.type = "string"), g.every((w) => typeof w == "boolean") && (v.type = "string"), g.every((w) => w === null) && (v.type = "null"), v.enum = g;
            break;
          }
          case "file": {
            const v = m, g = {
              type: "string",
              format: "binary",
              contentEncoding: "binary"
            }, { minimum: w, maximum: T, mime: x } = e._zod.bag;
            w !== void 0 && (g.minLength = w), T !== void 0 && (g.maxLength = T), x ? x.length === 1 ? (g.contentMediaType = x[0], Object.assign(v, g)) : v.anyOf = x.map((O) => ({ ...g, contentMediaType: O })) : Object.assign(v, g);
            break;
          }
          case "transform": {
            if (this.unrepresentable === "throw")
              throw new Error("Transforms cannot be represented in JSON Schema");
            break;
          }
          case "nullable": {
            const v = this.process(s.innerType, p);
            this.target === "openapi-3.0" ? (o.ref = s.innerType, m.nullable = !0) : m.anyOf = [v, { type: "null" }];
            break;
          }
          case "nonoptional": {
            this.process(s.innerType, p), o.ref = s.innerType;
            break;
          }
          case "success": {
            const v = m;
            v.type = "boolean";
            break;
          }
          case "default": {
            this.process(s.innerType, p), o.ref = s.innerType, m.default = JSON.parse(JSON.stringify(s.defaultValue));
            break;
          }
          case "prefault": {
            this.process(s.innerType, p), o.ref = s.innerType, this.io === "input" && (m._prefault = JSON.parse(JSON.stringify(s.defaultValue)));
            break;
          }
          case "catch": {
            this.process(s.innerType, p), o.ref = s.innerType;
            let v;
            try {
              v = s.catchValue(void 0);
            } catch {
              throw new Error("Dynamic catch values are not supported in JSON Schema");
            }
            m.default = v;
            break;
          }
          case "nan": {
            if (this.unrepresentable === "throw")
              throw new Error("NaN cannot be represented in JSON Schema");
            break;
          }
          case "template_literal": {
            const v = m, g = e._zod.pattern;
            if (!g)
              throw new Error("Pattern not found in template literal");
            v.type = "string", v.pattern = g.source;
            break;
          }
          case "pipe": {
            const v = this.io === "input" ? s.in._zod.def.type === "transform" ? s.out : s.in : s.out;
            this.process(v, p), o.ref = v;
            break;
          }
          case "readonly": {
            this.process(s.innerType, p), o.ref = s.innerType, m.readOnly = !0;
            break;
          }
          case "promise": {
            this.process(s.innerType, p), o.ref = s.innerType;
            break;
          }
          case "optional": {
            this.process(s.innerType, p), o.ref = s.innerType;
            break;
          }
          case "lazy": {
            const v = e._zod.innerType;
            this.process(v, p), o.ref = v;
            break;
          }
          case "custom": {
            if (this.unrepresentable === "throw")
              throw new Error("Custom types cannot be represented in JSON Schema");
            break;
          }
          case "function": {
            if (this.unrepresentable === "throw")
              throw new Error("Function types cannot be represented in JSON Schema");
            break;
          }
        }
      }
    }
    const u = this.metadataRegistry.get(e);
    return u && Object.assign(o.schema, u), this.io === "input" && kt(e) && (delete o.schema.examples, delete o.schema.default), this.io === "input" && o.schema._prefault && ((n = o.schema).default ?? (n.default = o.schema._prefault)), delete o.schema._prefault, this.seen.get(e).schema;
  }
  emit(e, t) {
    var l, d, h, f, p, y;
    const n = {
      cycles: (t == null ? void 0 : t.cycles) ?? "ref",
      reused: (t == null ? void 0 : t.reused) ?? "inline",
      // unrepresentable: _params?.unrepresentable ?? "throw",
      // uri: _params?.uri ?? ((id) => `${id}`),
      external: (t == null ? void 0 : t.external) ?? void 0
    }, s = this.seen.get(e);
    if (!s)
      throw new Error("Unprocessed schema. This is a bug in Zod.");
    const a = (m) => {
      var x;
      const v = this.target === "draft-2020-12" ? "$defs" : "definitions";
      if (n.external) {
        const O = (x = n.external.registry.get(m[0])) == null ? void 0 : x.id, R = n.external.uri ?? ((V) => V);
        if (O)
          return { ref: R(O) };
        const E = m[1].defId ?? m[1].schema.id ?? `schema${this.counter++}`;
        return m[1].defId = E, { defId: E, ref: `${R("__shared")}#/${v}/${E}` };
      }
      if (m[1] === s)
        return { ref: "#" };
      const w = `#/${v}/`, T = m[1].schema.id ?? `__schema${this.counter++}`;
      return { defId: T, ref: w + T };
    }, i = (m) => {
      if (m[1].schema.$ref)
        return;
      const v = m[1], { ref: g, defId: w } = a(m);
      v.def = { ...v.schema }, w && (v.defId = w);
      const T = v.schema;
      for (const x in T)
        delete T[x];
      T.$ref = g;
    };
    if (n.cycles === "throw")
      for (const m of this.seen.entries()) {
        const v = m[1];
        if (v.cycle)
          throw new Error(`Cycle detected: #/${(l = v.cycle) == null ? void 0 : l.join("/")}/<root>

Set the \`cycles\` parameter to \`"ref"\` to resolve cyclical schemas with defs.`);
      }
    for (const m of this.seen.entries()) {
      const v = m[1];
      if (e === m[0]) {
        i(m);
        continue;
      }
      if (n.external) {
        const w = (d = n.external.registry.get(m[0])) == null ? void 0 : d.id;
        if (e !== m[0] && w) {
          i(m);
          continue;
        }
      }
      if ((h = this.metadataRegistry.get(m[0])) == null ? void 0 : h.id) {
        i(m);
        continue;
      }
      if (v.cycle) {
        i(m);
        continue;
      }
      if (v.count > 1 && n.reused === "ref") {
        i(m);
        continue;
      }
    }
    const o = (m, v) => {
      const g = this.seen.get(m), w = g.def ?? g.schema, T = { ...w };
      if (g.ref === null)
        return;
      const x = g.ref;
      if (g.ref = null, x) {
        o(x, v);
        const O = this.seen.get(x).schema;
        O.$ref && (v.target === "draft-7" || v.target === "draft-4" || v.target === "openapi-3.0") ? (w.allOf = w.allOf ?? [], w.allOf.push(O)) : (Object.assign(w, O), Object.assign(w, T));
      }
      g.isParent || this.override({
        zodSchema: m,
        jsonSchema: w,
        path: g.path ?? []
      });
    };
    for (const m of [...this.seen.entries()].reverse())
      o(m[0], { target: this.target });
    const c = {};
    if (this.target === "draft-2020-12" ? c.$schema = "https://json-schema.org/draft/2020-12/schema" : this.target === "draft-7" ? c.$schema = "http://json-schema.org/draft-07/schema#" : this.target === "draft-4" ? c.$schema = "http://json-schema.org/draft-04/schema#" : this.target === "openapi-3.0" || console.warn(`Invalid target: ${this.target}`), (f = n.external) != null && f.uri) {
      const m = (p = n.external.registry.get(e)) == null ? void 0 : p.id;
      if (!m)
        throw new Error("Schema is missing an `id` property");
      c.$id = n.external.uri(m);
    }
    Object.assign(c, s.def);
    const u = ((y = n.external) == null ? void 0 : y.defs) ?? {};
    for (const m of this.seen.entries()) {
      const v = m[1];
      v.def && v.defId && (u[v.defId] = v.def);
    }
    n.external || Object.keys(u).length > 0 && (this.target === "draft-2020-12" ? c.$defs = u : c.definitions = u);
    try {
      return JSON.parse(JSON.stringify(c));
    } catch {
      throw new Error("Error converting schema to JSON.");
    }
  }
}
function Ri(r, e) {
  if (r instanceof Hg) {
    const n = new Ch(e), s = {};
    for (const o of r._idmap.entries()) {
      const [c, u] = o;
      n.process(u);
    }
    const a = {}, i = {
      registry: r,
      uri: e == null ? void 0 : e.uri,
      defs: s
    };
    for (const o of r._idmap.entries()) {
      const [c, u] = o;
      a[c] = n.emit(u, {
        ...e,
        external: i
      });
    }
    if (Object.keys(s).length > 0) {
      const o = n.target === "draft-2020-12" ? "$defs" : "definitions";
      a.__shared = {
        [o]: s
      };
    }
    return { schemas: a };
  }
  const t = new Ch(e);
  return t.process(r), t.emit(r, e);
}
function kt(r, e) {
  const t = e ?? { seen: /* @__PURE__ */ new Set() };
  if (t.seen.has(r))
    return !1;
  t.seen.add(r);
  const n = r._zod.def;
  if (n.type === "transform")
    return !0;
  if (n.type === "array")
    return kt(n.element, t);
  if (n.type === "set")
    return kt(n.valueType, t);
  if (n.type === "lazy")
    return kt(n.getter(), t);
  if (n.type === "promise" || n.type === "optional" || n.type === "nonoptional" || n.type === "nullable" || n.type === "readonly" || n.type === "default" || n.type === "prefault")
    return kt(n.innerType, t);
  if (n.type === "intersection")
    return kt(n.left, t) || kt(n.right, t);
  if (n.type === "record" || n.type === "map")
    return kt(n.keyType, t) || kt(n.valueType, t);
  if (n.type === "pipe")
    return kt(n.in, t) || kt(n.out, t);
  if (n.type === "object") {
    for (const s in n.shape)
      if (kt(n.shape[s], t))
        return !0;
    return !1;
  }
  if (n.type === "union") {
    for (const s of n.options)
      if (kt(s, t))
        return !0;
    return !1;
  }
  if (n.type === "tuple") {
    for (const s of n.items)
      if (kt(s, t))
        return !0;
    return !!(n.rest && kt(n.rest, t));
  }
  return !1;
}
function qe(r) {
  if (typeof r != "object" || r === null) return !1;
  const e = r;
  if (!("_zod" in e)) return !1;
  const t = e._zod;
  return typeof t == "object" && t !== null && "def" in t;
}
function st(r) {
  if (typeof r != "object" || r === null) return !1;
  const e = r;
  if (!("_def" in e) || "_zod" in e) return !1;
  const t = e._def;
  return typeof t == "object" && t != null && "typeName" in t;
}
function hk(r) {
  return qe(r) && console.warn("[WARNING] Attempting to use Zod 4 schema in a context where Zod 3 schema is expected. This may cause unexpected behavior."), st(r);
}
function br(r) {
  return !r || typeof r != "object" || Array.isArray(r) ? !1 : !!(qe(r) || st(r));
}
function Xg(r) {
  return typeof r == "object" && r !== null && "_def" in r && typeof r._def == "object" && r._def !== null && "typeName" in r._def && r._def.typeName === "ZodLiteral";
}
function Qg(r) {
  return qe(r) ? typeof r == "object" && r !== null && "_zod" in r && typeof r._zod == "object" && r._zod !== null && "def" in r._zod && typeof r._zod.def == "object" && r._zod.def !== null && "type" in r._zod.def && r._zod.def.type === "literal" : !1;
}
function fk(r) {
  return !!(Xg(r) || Qg(r));
}
async function e_(r, e) {
  if (qe(r)) try {
    return {
      success: !0,
      data: await Pg(r, e)
    };
  } catch (t) {
    return {
      success: !1,
      error: t
    };
  }
  if (st(r)) return await r.safeParseAsync(e);
  throw new Error("Schema must be an instance of z3.ZodType or z4.$ZodType");
}
async function Eo(r, e) {
  if (qe(r)) return await Pg(r, e);
  if (st(r)) return await r.parseAsync(e);
  throw new Error("Schema must be an instance of z3.ZodType or z4.$ZodType");
}
function pk(r, e) {
  if (qe(r)) try {
    return {
      success: !0,
      data: wo(r, e)
    };
  } catch (t) {
    return {
      success: !1,
      error: t
    };
  }
  if (st(r)) return r.safeParse(e);
  throw new Error("Schema must be an instance of z3.ZodType or z4.$ZodType");
}
function mk(r, e) {
  if (qe(r)) return wo(r, e);
  if (st(r)) return r.parse(e);
  throw new Error("Schema must be an instance of z3.ZodType or z4.$ZodType");
}
function xo(r) {
  var e;
  if (qe(r)) return (e = pt.get(r)) == null ? void 0 : e.description;
  if (st(r) || "description" in r && typeof r.description == "string") return r.description;
}
function gk(r) {
  if (!br(r)) return !1;
  if (st(r)) {
    const e = r._def;
    if (e.typeName === "ZodObject") {
      const t = r;
      return !t.shape || Object.keys(t.shape).length === 0;
    }
    if (e.typeName === "ZodRecord") return !0;
  }
  if (qe(r)) {
    const e = r._zod.def;
    if (e.type === "object") {
      const t = r;
      return !t.shape || Object.keys(t.shape).length === 0;
    }
    if (e.type === "record") return !0;
  }
  return typeof r == "object" && r !== null && !("shape" in r);
}
function Ol(r) {
  return br(r) ? st(r) ? r._def.typeName === "ZodString" : qe(r) ? r._zod.def.type === "string" : !1 : !1;
}
function Al(r) {
  return typeof r == "object" && r !== null && "_def" in r && typeof r._def == "object" && r._def !== null && "typeName" in r._def && r._def.typeName === "ZodObject";
}
function xr(r) {
  return qe(r) ? typeof r == "object" && r !== null && "_zod" in r && typeof r._zod == "object" && r._zod !== null && "def" in r._zod && typeof r._zod.def == "object" && r._zod.def !== null && "type" in r._zod.def && r._zod.def.type === "object" : !1;
}
function ko(r) {
  return qe(r) ? typeof r == "object" && r !== null && "_zod" in r && typeof r._zod == "object" && r._zod !== null && "def" in r._zod && typeof r._zod.def == "object" && r._zod.def !== null && "type" in r._zod.def && r._zod.def.type === "array" : !1;
}
function t_(r) {
  return qe(r) ? typeof r == "object" && r !== null && "_zod" in r && typeof r._zod == "object" && r._zod !== null && "def" in r._zod && typeof r._zod.def == "object" && r._zod.def !== null && "type" in r._zod.def && r._zod.def.type === "optional" : !1;
}
function r_(r) {
  return qe(r) ? typeof r == "object" && r !== null && "_zod" in r && typeof r._zod == "object" && r._zod !== null && "def" in r._zod && typeof r._zod.def == "object" && r._zod.def !== null && "type" in r._zod.def && r._zod.def.type === "nullable" : !1;
}
function _k(r) {
  return !!(Al(r) || xr(r));
}
function Qc(r) {
  if (st(r)) return r.shape;
  if (qe(r)) return r._zod.def.shape;
  throw new Error("Schema must be an instance of z3.ZodObject or z4.$ZodObject");
}
function yk(r, e) {
  if (st(r)) return r.extend(e);
  if (qe(r)) return $g(r, e);
  throw new Error("Schema must be an instance of z3.ZodObject or z4.$ZodObject");
}
function wk(r) {
  if (st(r)) return r.partial();
  if (qe(r)) return Cg(Il, r, void 0);
  throw new Error("Schema must be an instance of z3.ZodObject or z4.$ZodObject");
}
function Ni(r, e = !1) {
  if (st(r)) return r.strict();
  if (xr(r)) {
    const t = r._zod.def.shape;
    if (e) for (const [a, i] of Object.entries(r._zod.def.shape)) {
      if (xr(i)) {
        const c = Ni(i, e);
        t[a] = c;
      } else if (ko(i)) {
        let c = i._zod.def.element;
        xr(c) && (c = Ni(c, e)), t[a] = bt(i, {
          ...i._zod.def,
          element: c
        });
      } else t[a] = i;
      const o = pt.get(i);
      o && pt.add(t[a], o);
    }
    const n = bt(r, {
      ...r._zod.def,
      shape: t,
      catchall: Wg(Vg)
    }), s = pt.get(r);
    return s && pt.add(n, s), n;
  }
  throw new Error("Schema must be an instance of z3.ZodObject or z4.$ZodObject");
}
function eu(r, e = !1) {
  if (Al(r)) return r.passthrough();
  if (xr(r)) {
    const t = r._zod.def.shape;
    if (e) for (const [a, i] of Object.entries(r._zod.def.shape)) {
      if (xr(i)) {
        const c = eu(i, e);
        t[a] = c;
      } else if (ko(i)) {
        let c = i._zod.def.element;
        xr(c) && (c = eu(c, e)), t[a] = bt(i, {
          ...i._zod.def,
          element: c
        });
      } else t[a] = i;
      const o = pt.get(i);
      o && pt.add(t[a], o);
    }
    const n = bt(r, {
      ...r._zod.def,
      shape: t,
      catchall: Gg(Zg)
    }), s = pt.get(r);
    return s && pt.add(n, s), n;
  }
  throw new Error("Schema must be an instance of z3.ZodObject or z4.$ZodObject");
}
function vk(r) {
  if (st(r)) try {
    const e = r.parse(void 0);
    return () => e;
  } catch {
    return;
  }
  if (qe(r)) try {
    const e = wo(r, void 0);
    return () => e;
  } catch {
    return;
  }
}
function bk(r) {
  return st(r) && "typeName" in r._def && r._def.typeName === "ZodEffects";
}
function Sk(r) {
  return qe(r) && r._zod.def.type === "pipe";
}
function mn(r, e, t) {
  const n = t.get(r);
  if (n !== void 0) return n;
  if (st(r))
    return bk(r) ? mn(r._def.schema, e, t) : r;
  if (qe(r)) {
    let s = r;
    if (Sk(r) && (s = mn(r._zod.def.in, e, t)), e) {
      if (xr(s)) {
        const i = s._zod.def.shape;
        for (const [o, c] of Object.entries(s._zod.def.shape)) i[o] = mn(c, e, t);
        s = bt(s, {
          ...s._zod.def,
          shape: i
        });
      } else if (ko(s)) {
        const i = mn(s._zod.def.element, e, t);
        s = bt(s, {
          ...s._zod.def,
          element: i
        });
      } else if (t_(s)) {
        const i = mn(s._zod.def.innerType, e, t);
        s = bt(s, {
          ...s._zod.def,
          innerType: i
        });
      } else if (r_(s)) {
        const i = mn(s._zod.def.innerType, e, t);
        s = bt(s, {
          ...s._zod.def,
          innerType: i
        });
      }
    }
    const a = pt.get(r);
    return a && pt.add(s, a), t.set(r, s), s;
  }
  throw new Error("Schema must be an instance of z3.ZodType or z4.$ZodType");
}
function n_(r, e = !1) {
  return mn(r, e, /* @__PURE__ */ new WeakMap());
}
function Tk(r, e) {
  if (st(r)) {
    const t = Qc(r), n = {};
    for (const [s, a] of Object.entries(t)) e(s, a) ? n[s] = a.optional() : n[s] = a;
    return r.extend(n);
  }
  if (qe(r)) {
    const t = Qc(r), n = { ...r._zod.def.shape };
    for (const [i, o] of Object.entries(t)) e(i, o) && (n[i] = new Il({
      type: "optional",
      innerType: o
    }));
    const s = bt(r, {
      ...r._zod.def,
      shape: n
    }), a = pt.get(r);
    return a && pt.add(s, a), s;
  }
  throw new Error("Schema must be an instance of z3.ZodObject or z4.$ZodObject");
}
function s_(r) {
  return r instanceof Error && (r.constructor.name === "ZodError" || r.constructor.name === "$ZodError");
}
function dc(r) {
  return r.replace(/[^a-zA-Z-_0-9]/g, "_");
}
const Ek = [
  "*",
  "_",
  "`"
];
function xk(r) {
  let e = "";
  for (const [t, n] of Object.entries(r)) e += `	classDef ${t} ${n};
`;
  return e;
}
function kk(r, e, t) {
  const { firstNode: n, lastNode: s, nodeColors: a, withStyles: i = !0, curveStyle: o = "linear", wrapLabelNWords: c = 9 } = t ?? {};
  let u = i ? `%%{init: {'flowchart': {'curve': '${o}'}}}%%
graph TD;
` : `graph TD;
`;
  if (i) {
    const f = "default", p = { [f]: "{0}({1})" };
    n !== void 0 && (p[n] = "{0}([{1}]):::first"), s !== void 0 && (p[s] = "{0}([{1}]):::last");
    for (const [y, m] of Object.entries(r)) {
      const v = m.name.split(":").pop() ?? "";
      let w = Ek.some((x) => v.startsWith(x) && v.endsWith(x)) ? `<p>${v}</p>` : v;
      Object.keys(m.metadata ?? {}).length && (w += `<hr/><small><em>${Object.entries(m.metadata ?? {}).map(([x, O]) => `${x} = ${O}`).join(`
`)}</em></small>`);
      const T = (p[y] ?? p[f]).replace("{0}", dc(y)).replace("{1}", w);
      u += `	${T}
`;
    }
  }
  const l = {};
  for (const f of e) {
    const p = f.source.split(":"), y = f.target.split(":"), m = p.filter((v, g) => v === y[g]).join(":");
    l[m] || (l[m] = []), l[m].push(f);
  }
  const d = /* @__PURE__ */ new Set();
  function h(f, p) {
    const y = f.length === 1 && f[0].source === f[0].target;
    if (p && !y) {
      const m = p.split(":").pop();
      if (d.has(m)) throw new Error(`Found duplicate subgraph '${m}' -- this likely means that you're reusing a subgraph node with the same name. Please adjust your graph to have subgraph nodes with unique names.`);
      d.add(m), u += `	subgraph ${m}
`;
    }
    for (const m of f) {
      const { source: v, target: g, data: w, conditional: T } = m;
      let x = "";
      if (w !== void 0) {
        let O = w;
        const R = O.split(" ");
        R.length > c && (O = Array.from({ length: Math.ceil(R.length / c) }, (E, V) => R.slice(V * c, (V + 1) * c).join(" ")).join("&nbsp;<br>&nbsp;")), x = T ? ` -. &nbsp;${O}&nbsp; .-> ` : ` -- &nbsp;${O}&nbsp; --> `;
      } else x = T ? " -.-> " : " --> ";
      u += `	${dc(v)}${x}${dc(g)};
`;
    }
    for (const m in l) m.startsWith(`${p}:`) && m !== p && h(l[m], m);
    p && !y && (u += `	end
`);
  }
  h(l[""] ?? [], "");
  for (const f in l) !f.includes(":") && f !== "" && h(l[f], f);
  return i && (u += xk(a ?? {})), u;
}
async function Ik(r, e) {
  let t = (e == null ? void 0 : e.backgroundColor) ?? "white";
  const n = (e == null ? void 0 : e.imageType) ?? "png", s = vT(r);
  t !== void 0 && (/^#(?:[0-9a-fA-F]{3}){1,2}$/.test(t) || (t = `!${t}`));
  const a = `https://mermaid.ink/img/${s}?bgColor=${t}&type=${n}`, i = await fetch(a);
  if (!i.ok) throw new Error([
    "Failed to render the graph using the Mermaid.INK API.",
    `Status code: ${i.status}`,
    `Status text: ${i.statusText}`
  ].join(`
`));
  return await i.blob();
}
const Ok = Symbol("Let zodToJsonSchema decide on which parser to use"), Ak = {
  name: void 0,
  $refStrategy: "root",
  basePath: ["#"],
  effectStrategy: "input",
  pipeStrategy: "all",
  dateStrategy: "format:date-time",
  mapStrategy: "entries",
  removeAdditionalStrategy: "passthrough",
  allowedAdditionalProperties: !0,
  rejectedAdditionalProperties: !1,
  definitionPath: "definitions",
  target: "jsonSchema7",
  strictUnions: !1,
  definitions: {},
  errorMessages: !1,
  markdownDescription: !1,
  patternStrategy: "escape",
  applyRegexFlags: !1,
  emailStrategy: "format:email",
  base64Strategy: "contentEncoding:base64",
  nameStrategy: "ref",
  openAiAnyTypeName: "OpenAiAnyType"
}, $k = (r) => ({
  ...Ak,
  ...r
}), Ck = (r) => {
  const e = $k(r), t = e.name !== void 0 ? [
    ...e.basePath,
    e.definitionPath,
    e.name
  ] : e.basePath;
  return {
    ...e,
    flags: { hasReferencedOpenAiAnyType: !1 },
    currentPath: t,
    propertyPath: void 0,
    seen: new Map(Object.entries(e.definitions).map(([n, s]) => [s._def, {
      def: s._def,
      path: [
        ...e.basePath,
        e.definitionPath,
        n
      ],
      jsonSchema: void 0
    }]))
  };
}, a_ = (r, e) => {
  let t = 0;
  for (; t < r.length && t < e.length && r[t] === e[t]; t++) ;
  return [(r.length - t).toString(), ...e.slice(t)].join("/");
};
function Vt(r) {
  if (r.target !== "openAi") return {};
  const e = [
    ...r.basePath,
    r.definitionPath,
    r.openAiAnyTypeName
  ];
  return r.flags.hasReferencedOpenAiAnyType = !0, { $ref: r.$refStrategy === "relative" ? a_(e, r.currentPath) : e.join("/") };
}
function i_(r, e, t, n) {
  n != null && n.errorMessages && t && (r.errorMessage = {
    ...r.errorMessage,
    [e]: t
  });
}
function De(r, e, t, n, s) {
  r[e] = t, i_(r, e, n, s);
}
var Re;
(function(r) {
  r.assertEqual = (s) => {
  };
  function e(s) {
  }
  r.assertIs = e;
  function t(s) {
    throw new Error();
  }
  r.assertNever = t, r.arrayToEnum = (s) => {
    const a = {};
    for (const i of s)
      a[i] = i;
    return a;
  }, r.getValidEnumValues = (s) => {
    const a = r.objectKeys(s).filter((o) => typeof s[s[o]] != "number"), i = {};
    for (const o of a)
      i[o] = s[o];
    return r.objectValues(i);
  }, r.objectValues = (s) => r.objectKeys(s).map(function(a) {
    return s[a];
  }), r.objectKeys = typeof Object.keys == "function" ? (s) => Object.keys(s) : (s) => {
    const a = [];
    for (const i in s)
      Object.prototype.hasOwnProperty.call(s, i) && a.push(i);
    return a;
  }, r.find = (s, a) => {
    for (const i of s)
      if (a(i))
        return i;
  }, r.isInteger = typeof Number.isInteger == "function" ? (s) => Number.isInteger(s) : (s) => typeof s == "number" && Number.isFinite(s) && Math.floor(s) === s;
  function n(s, a = " | ") {
    return s.map((i) => typeof i == "string" ? `'${i}'` : i).join(a);
  }
  r.joinValues = n, r.jsonStringifyReplacer = (s, a) => typeof a == "bigint" ? a.toString() : a;
})(Re || (Re = {}));
var Rh;
(function(r) {
  r.mergeShapes = (e, t) => ({
    ...e,
    ...t
    // second overwrites first
  });
})(Rh || (Rh = {}));
const ee = Re.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]), Yr = (r) => {
  switch (typeof r) {
    case "undefined":
      return ee.undefined;
    case "string":
      return ee.string;
    case "number":
      return Number.isNaN(r) ? ee.nan : ee.number;
    case "boolean":
      return ee.boolean;
    case "function":
      return ee.function;
    case "bigint":
      return ee.bigint;
    case "symbol":
      return ee.symbol;
    case "object":
      return Array.isArray(r) ? ee.array : r === null ? ee.null : r.then && typeof r.then == "function" && r.catch && typeof r.catch == "function" ? ee.promise : typeof Map < "u" && r instanceof Map ? ee.map : typeof Set < "u" && r instanceof Set ? ee.set : typeof Date < "u" && r instanceof Date ? ee.date : ee.object;
    default:
      return ee.unknown;
  }
}, B = Re.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
class Br extends Error {
  get errors() {
    return this.issues;
  }
  constructor(e) {
    super(), this.issues = [], this.addIssue = (n) => {
      this.issues = [...this.issues, n];
    }, this.addIssues = (n = []) => {
      this.issues = [...this.issues, ...n];
    };
    const t = new.target.prototype;
    Object.setPrototypeOf ? Object.setPrototypeOf(this, t) : this.__proto__ = t, this.name = "ZodError", this.issues = e;
  }
  format(e) {
    const t = e || function(a) {
      return a.message;
    }, n = { _errors: [] }, s = (a) => {
      for (const i of a.issues)
        if (i.code === "invalid_union")
          i.unionErrors.map(s);
        else if (i.code === "invalid_return_type")
          s(i.returnTypeError);
        else if (i.code === "invalid_arguments")
          s(i.argumentsError);
        else if (i.path.length === 0)
          n._errors.push(t(i));
        else {
          let o = n, c = 0;
          for (; c < i.path.length; ) {
            const u = i.path[c];
            c === i.path.length - 1 ? (o[u] = o[u] || { _errors: [] }, o[u]._errors.push(t(i))) : o[u] = o[u] || { _errors: [] }, o = o[u], c++;
          }
        }
    };
    return s(this), n;
  }
  static assert(e) {
    if (!(e instanceof Br))
      throw new Error(`Not a ZodError: ${e}`);
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, Re.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(e = (t) => t.message) {
    const t = /* @__PURE__ */ Object.create(null), n = [];
    for (const s of this.issues)
      if (s.path.length > 0) {
        const a = s.path[0];
        t[a] = t[a] || [], t[a].push(e(s));
      } else
        n.push(e(s));
    return { formErrors: n, fieldErrors: t };
  }
  get formErrors() {
    return this.flatten();
  }
}
Br.create = (r) => new Br(r);
const tu = (r, e) => {
  let t;
  switch (r.code) {
    case B.invalid_type:
      r.received === ee.undefined ? t = "Required" : t = `Expected ${r.expected}, received ${r.received}`;
      break;
    case B.invalid_literal:
      t = `Invalid literal value, expected ${JSON.stringify(r.expected, Re.jsonStringifyReplacer)}`;
      break;
    case B.unrecognized_keys:
      t = `Unrecognized key(s) in object: ${Re.joinValues(r.keys, ", ")}`;
      break;
    case B.invalid_union:
      t = "Invalid input";
      break;
    case B.invalid_union_discriminator:
      t = `Invalid discriminator value. Expected ${Re.joinValues(r.options)}`;
      break;
    case B.invalid_enum_value:
      t = `Invalid enum value. Expected ${Re.joinValues(r.options)}, received '${r.received}'`;
      break;
    case B.invalid_arguments:
      t = "Invalid function arguments";
      break;
    case B.invalid_return_type:
      t = "Invalid function return type";
      break;
    case B.invalid_date:
      t = "Invalid date";
      break;
    case B.invalid_string:
      typeof r.validation == "object" ? "includes" in r.validation ? (t = `Invalid input: must include "${r.validation.includes}"`, typeof r.validation.position == "number" && (t = `${t} at one or more positions greater than or equal to ${r.validation.position}`)) : "startsWith" in r.validation ? t = `Invalid input: must start with "${r.validation.startsWith}"` : "endsWith" in r.validation ? t = `Invalid input: must end with "${r.validation.endsWith}"` : Re.assertNever(r.validation) : r.validation !== "regex" ? t = `Invalid ${r.validation}` : t = "Invalid";
      break;
    case B.too_small:
      r.type === "array" ? t = `Array must contain ${r.exact ? "exactly" : r.inclusive ? "at least" : "more than"} ${r.minimum} element(s)` : r.type === "string" ? t = `String must contain ${r.exact ? "exactly" : r.inclusive ? "at least" : "over"} ${r.minimum} character(s)` : r.type === "number" ? t = `Number must be ${r.exact ? "exactly equal to " : r.inclusive ? "greater than or equal to " : "greater than "}${r.minimum}` : r.type === "bigint" ? t = `Number must be ${r.exact ? "exactly equal to " : r.inclusive ? "greater than or equal to " : "greater than "}${r.minimum}` : r.type === "date" ? t = `Date must be ${r.exact ? "exactly equal to " : r.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(r.minimum))}` : t = "Invalid input";
      break;
    case B.too_big:
      r.type === "array" ? t = `Array must contain ${r.exact ? "exactly" : r.inclusive ? "at most" : "less than"} ${r.maximum} element(s)` : r.type === "string" ? t = `String must contain ${r.exact ? "exactly" : r.inclusive ? "at most" : "under"} ${r.maximum} character(s)` : r.type === "number" ? t = `Number must be ${r.exact ? "exactly" : r.inclusive ? "less than or equal to" : "less than"} ${r.maximum}` : r.type === "bigint" ? t = `BigInt must be ${r.exact ? "exactly" : r.inclusive ? "less than or equal to" : "less than"} ${r.maximum}` : r.type === "date" ? t = `Date must be ${r.exact ? "exactly" : r.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(r.maximum))}` : t = "Invalid input";
      break;
    case B.custom:
      t = "Invalid input";
      break;
    case B.invalid_intersection_types:
      t = "Intersection results could not be merged";
      break;
    case B.not_multiple_of:
      t = `Number must be a multiple of ${r.multipleOf}`;
      break;
    case B.not_finite:
      t = "Number must be finite";
      break;
    default:
      t = e.defaultError, Re.assertNever(r);
  }
  return { message: t };
};
let Rk = tu;
function Nk() {
  return Rk;
}
const Pk = (r) => {
  const { data: e, path: t, errorMaps: n, issueData: s } = r, a = [...t, ...s.path || []], i = {
    ...s,
    path: a
  };
  if (s.message !== void 0)
    return {
      ...s,
      path: a,
      message: s.message
    };
  let o = "";
  const c = n.filter((u) => !!u).slice().reverse();
  for (const u of c)
    o = u(i, { data: e, defaultError: o }).message;
  return {
    ...s,
    path: a,
    message: o
  };
};
function W(r, e) {
  const t = Nk(), n = Pk({
    issueData: e,
    data: r.data,
    path: r.path,
    errorMaps: [
      r.common.contextualErrorMap,
      // contextual error map is first priority
      r.schemaErrorMap,
      // then schema-bound map if available
      t,
      // then global override map
      t === tu ? void 0 : tu
      // then global default map
    ].filter((s) => !!s)
  });
  r.common.issues.push(n);
}
class qt {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    this.value === "valid" && (this.value = "dirty");
  }
  abort() {
    this.value !== "aborted" && (this.value = "aborted");
  }
  static mergeArray(e, t) {
    const n = [];
    for (const s of t) {
      if (s.status === "aborted")
        return Se;
      s.status === "dirty" && e.dirty(), n.push(s.value);
    }
    return { status: e.value, value: n };
  }
  static async mergeObjectAsync(e, t) {
    const n = [];
    for (const s of t) {
      const a = await s.key, i = await s.value;
      n.push({
        key: a,
        value: i
      });
    }
    return qt.mergeObjectSync(e, n);
  }
  static mergeObjectSync(e, t) {
    const n = {};
    for (const s of t) {
      const { key: a, value: i } = s;
      if (a.status === "aborted" || i.status === "aborted")
        return Se;
      a.status === "dirty" && e.dirty(), i.status === "dirty" && e.dirty(), a.value !== "__proto__" && (typeof i.value < "u" || s.alwaysSet) && (n[a.value] = i.value);
    }
    return { status: e.value, value: n };
  }
}
const Se = Object.freeze({
  status: "aborted"
}), As = (r) => ({ status: "dirty", value: r }), Wt = (r) => ({ status: "valid", value: r }), Nh = (r) => r.status === "aborted", Ph = (r) => r.status === "dirty", rs = (r) => r.status === "valid", Pi = (r) => typeof Promise < "u" && r instanceof Promise;
var te;
(function(r) {
  r.errToObj = (e) => typeof e == "string" ? { message: e } : e || {}, r.toString = (e) => typeof e == "string" ? e : e == null ? void 0 : e.message;
})(te || (te = {}));
class un {
  constructor(e, t, n, s) {
    this._cachedPath = [], this.parent = e, this.data = t, this._path = n, this._key = s;
  }
  get path() {
    return this._cachedPath.length || (Array.isArray(this._key) ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)), this._cachedPath;
  }
}
const Lh = (r, e) => {
  if (rs(e))
    return { success: !0, data: e.value };
  if (!r.common.issues.length)
    throw new Error("Validation failed but no issues detected.");
  return {
    success: !1,
    get error() {
      if (this._error)
        return this._error;
      const t = new Br(r.common.issues);
      return this._error = t, this._error;
    }
  };
};
function ke(r) {
  if (!r)
    return {};
  const { errorMap: e, invalid_type_error: t, required_error: n, description: s } = r;
  if (e && (t || n))
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  return e ? { errorMap: e, description: s } : { errorMap: (i, o) => {
    const { message: c } = r;
    return i.code === "invalid_enum_value" ? { message: c ?? o.defaultError } : typeof o.data > "u" ? { message: c ?? n ?? o.defaultError } : i.code !== "invalid_type" ? { message: o.defaultError } : { message: c ?? t ?? o.defaultError };
  }, description: s };
}
let $e = class {
  get description() {
    return this._def.description;
  }
  _getType(e) {
    return Yr(e.data);
  }
  _getOrReturnCtx(e, t) {
    return t || {
      common: e.parent.common,
      data: e.data,
      parsedType: Yr(e.data),
      schemaErrorMap: this._def.errorMap,
      path: e.path,
      parent: e.parent
    };
  }
  _processInputParams(e) {
    return {
      status: new qt(),
      ctx: {
        common: e.parent.common,
        data: e.data,
        parsedType: Yr(e.data),
        schemaErrorMap: this._def.errorMap,
        path: e.path,
        parent: e.parent
      }
    };
  }
  _parseSync(e) {
    const t = this._parse(e);
    if (Pi(t))
      throw new Error("Synchronous parse encountered promise.");
    return t;
  }
  _parseAsync(e) {
    const t = this._parse(e);
    return Promise.resolve(t);
  }
  parse(e, t) {
    const n = this.safeParse(e, t);
    if (n.success)
      return n.data;
    throw n.error;
  }
  safeParse(e, t) {
    const n = {
      common: {
        issues: [],
        async: (t == null ? void 0 : t.async) ?? !1,
        contextualErrorMap: t == null ? void 0 : t.errorMap
      },
      path: (t == null ? void 0 : t.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: e,
      parsedType: Yr(e)
    }, s = this._parseSync({ data: e, path: n.path, parent: n });
    return Lh(n, s);
  }
  "~validate"(e) {
    var n, s;
    const t = {
      common: {
        issues: [],
        async: !!this["~standard"].async
      },
      path: [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: e,
      parsedType: Yr(e)
    };
    if (!this["~standard"].async)
      try {
        const a = this._parseSync({ data: e, path: [], parent: t });
        return rs(a) ? {
          value: a.value
        } : {
          issues: t.common.issues
        };
      } catch (a) {
        (s = (n = a == null ? void 0 : a.message) == null ? void 0 : n.toLowerCase()) != null && s.includes("encountered") && (this["~standard"].async = !0), t.common = {
          issues: [],
          async: !0
        };
      }
    return this._parseAsync({ data: e, path: [], parent: t }).then((a) => rs(a) ? {
      value: a.value
    } : {
      issues: t.common.issues
    });
  }
  async parseAsync(e, t) {
    const n = await this.safeParseAsync(e, t);
    if (n.success)
      return n.data;
    throw n.error;
  }
  async safeParseAsync(e, t) {
    const n = {
      common: {
        issues: [],
        contextualErrorMap: t == null ? void 0 : t.errorMap,
        async: !0
      },
      path: (t == null ? void 0 : t.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: e,
      parsedType: Yr(e)
    }, s = this._parse({ data: e, path: n.path, parent: n }), a = await (Pi(s) ? s : Promise.resolve(s));
    return Lh(n, a);
  }
  refine(e, t) {
    const n = (s) => typeof t == "string" || typeof t > "u" ? { message: t } : typeof t == "function" ? t(s) : t;
    return this._refinement((s, a) => {
      const i = e(s), o = () => a.addIssue({
        code: B.custom,
        ...n(s)
      });
      return typeof Promise < "u" && i instanceof Promise ? i.then((c) => c ? !0 : (o(), !1)) : i ? !0 : (o(), !1);
    });
  }
  refinement(e, t) {
    return this._refinement((n, s) => e(n) ? !0 : (s.addIssue(typeof t == "function" ? t(n, s) : t), !1));
  }
  _refinement(e) {
    return new ss({
      schema: this,
      typeName: C.ZodEffects,
      effect: { type: "refinement", refinement: e }
    });
  }
  superRefine(e) {
    return this._refinement(e);
  }
  constructor(e) {
    this.spa = this.safeParseAsync, this._def = e, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.readonly = this.readonly.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this), this["~standard"] = {
      version: 1,
      vendor: "zod",
      validate: (t) => this["~validate"](t)
    };
  }
  optional() {
    return tn.create(this, this._def);
  }
  nullable() {
    return as.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ns.create(this);
  }
  promise() {
    return ji.create(this, this._def);
  }
  or(e) {
    return Mi.create([this, e], this._def);
  }
  and(e) {
    return Di.create(this, e, this._def);
  }
  transform(e) {
    return new ss({
      ...ke(this._def),
      schema: this,
      typeName: C.ZodEffects,
      effect: { type: "transform", transform: e }
    });
  }
  default(e) {
    const t = typeof e == "function" ? e : () => e;
    return new ou({
      ...ke(this._def),
      innerType: this,
      defaultValue: t,
      typeName: C.ZodDefault
    });
  }
  brand() {
    return new nI({
      typeName: C.ZodBranded,
      type: this,
      ...ke(this._def)
    });
  }
  catch(e) {
    const t = typeof e == "function" ? e : () => e;
    return new cu({
      ...ke(this._def),
      innerType: this,
      catchValue: t,
      typeName: C.ZodCatch
    });
  }
  describe(e) {
    const t = this.constructor;
    return new t({
      ...this._def,
      description: e
    });
  }
  pipe(e) {
    return Cl.create(this, e);
  }
  readonly() {
    return uu.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
};
const Lk = /^c[^\s-]{8,}$/i, Mk = /^[0-9a-z]+$/, Dk = /^[0-9A-HJKMNP-TV-Z]{26}$/i, jk = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i, Fk = /^[a-z0-9_-]{21}$/i, Uk = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/, zk = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/, Bk = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i, Zk = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
let hc;
const Vk = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/, qk = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/, Jk = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/, Hk = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/, Gk = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/, Wk = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/, o_ = "((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))", Kk = new RegExp(`^${o_}$`);
function c_(r) {
  let e = "[0-5]\\d";
  r.precision ? e = `${e}\\.\\d{${r.precision}}` : r.precision == null && (e = `${e}(\\.\\d+)?`);
  const t = r.precision ? "+" : "?";
  return `([01]\\d|2[0-3]):[0-5]\\d(:${e})${t}`;
}
function Yk(r) {
  return new RegExp(`^${c_(r)}$`);
}
function Xk(r) {
  let e = `${o_}T${c_(r)}`;
  const t = [];
  return t.push(r.local ? "Z?" : "Z"), r.offset && t.push("([+-]\\d{2}:?\\d{2})"), e = `${e}(${t.join("|")})`, new RegExp(`^${e}$`);
}
function Qk(r, e) {
  return !!((e === "v4" || !e) && Vk.test(r) || (e === "v6" || !e) && Jk.test(r));
}
function eI(r, e) {
  if (!Uk.test(r))
    return !1;
  try {
    const [t] = r.split(".");
    if (!t)
      return !1;
    const n = t.replace(/-/g, "+").replace(/_/g, "/").padEnd(t.length + (4 - t.length % 4) % 4, "="), s = JSON.parse(atob(n));
    return !(typeof s != "object" || s === null || "typ" in s && (s == null ? void 0 : s.typ) !== "JWT" || !s.alg || e && s.alg !== e);
  } catch {
    return !1;
  }
}
function tI(r, e) {
  return !!((e === "v4" || !e) && qk.test(r) || (e === "v6" || !e) && Hk.test(r));
}
let ru = class $s extends $e {
  _parse(e) {
    if (this._def.coerce && (e.data = String(e.data)), this._getType(e) !== ee.string) {
      const a = this._getOrReturnCtx(e);
      return W(a, {
        code: B.invalid_type,
        expected: ee.string,
        received: a.parsedType
      }), Se;
    }
    const n = new qt();
    let s;
    for (const a of this._def.checks)
      if (a.kind === "min")
        e.data.length < a.value && (s = this._getOrReturnCtx(e, s), W(s, {
          code: B.too_small,
          minimum: a.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: a.message
        }), n.dirty());
      else if (a.kind === "max")
        e.data.length > a.value && (s = this._getOrReturnCtx(e, s), W(s, {
          code: B.too_big,
          maximum: a.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: a.message
        }), n.dirty());
      else if (a.kind === "length") {
        const i = e.data.length > a.value, o = e.data.length < a.value;
        (i || o) && (s = this._getOrReturnCtx(e, s), i ? W(s, {
          code: B.too_big,
          maximum: a.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: a.message
        }) : o && W(s, {
          code: B.too_small,
          minimum: a.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: a.message
        }), n.dirty());
      } else if (a.kind === "email")
        Bk.test(e.data) || (s = this._getOrReturnCtx(e, s), W(s, {
          validation: "email",
          code: B.invalid_string,
          message: a.message
        }), n.dirty());
      else if (a.kind === "emoji")
        hc || (hc = new RegExp(Zk, "u")), hc.test(e.data) || (s = this._getOrReturnCtx(e, s), W(s, {
          validation: "emoji",
          code: B.invalid_string,
          message: a.message
        }), n.dirty());
      else if (a.kind === "uuid")
        jk.test(e.data) || (s = this._getOrReturnCtx(e, s), W(s, {
          validation: "uuid",
          code: B.invalid_string,
          message: a.message
        }), n.dirty());
      else if (a.kind === "nanoid")
        Fk.test(e.data) || (s = this._getOrReturnCtx(e, s), W(s, {
          validation: "nanoid",
          code: B.invalid_string,
          message: a.message
        }), n.dirty());
      else if (a.kind === "cuid")
        Lk.test(e.data) || (s = this._getOrReturnCtx(e, s), W(s, {
          validation: "cuid",
          code: B.invalid_string,
          message: a.message
        }), n.dirty());
      else if (a.kind === "cuid2")
        Mk.test(e.data) || (s = this._getOrReturnCtx(e, s), W(s, {
          validation: "cuid2",
          code: B.invalid_string,
          message: a.message
        }), n.dirty());
      else if (a.kind === "ulid")
        Dk.test(e.data) || (s = this._getOrReturnCtx(e, s), W(s, {
          validation: "ulid",
          code: B.invalid_string,
          message: a.message
        }), n.dirty());
      else if (a.kind === "url")
        try {
          new URL(e.data);
        } catch {
          s = this._getOrReturnCtx(e, s), W(s, {
            validation: "url",
            code: B.invalid_string,
            message: a.message
          }), n.dirty();
        }
      else a.kind === "regex" ? (a.regex.lastIndex = 0, a.regex.test(e.data) || (s = this._getOrReturnCtx(e, s), W(s, {
        validation: "regex",
        code: B.invalid_string,
        message: a.message
      }), n.dirty())) : a.kind === "trim" ? e.data = e.data.trim() : a.kind === "includes" ? e.data.includes(a.value, a.position) || (s = this._getOrReturnCtx(e, s), W(s, {
        code: B.invalid_string,
        validation: { includes: a.value, position: a.position },
        message: a.message
      }), n.dirty()) : a.kind === "toLowerCase" ? e.data = e.data.toLowerCase() : a.kind === "toUpperCase" ? e.data = e.data.toUpperCase() : a.kind === "startsWith" ? e.data.startsWith(a.value) || (s = this._getOrReturnCtx(e, s), W(s, {
        code: B.invalid_string,
        validation: { startsWith: a.value },
        message: a.message
      }), n.dirty()) : a.kind === "endsWith" ? e.data.endsWith(a.value) || (s = this._getOrReturnCtx(e, s), W(s, {
        code: B.invalid_string,
        validation: { endsWith: a.value },
        message: a.message
      }), n.dirty()) : a.kind === "datetime" ? Xk(a).test(e.data) || (s = this._getOrReturnCtx(e, s), W(s, {
        code: B.invalid_string,
        validation: "datetime",
        message: a.message
      }), n.dirty()) : a.kind === "date" ? Kk.test(e.data) || (s = this._getOrReturnCtx(e, s), W(s, {
        code: B.invalid_string,
        validation: "date",
        message: a.message
      }), n.dirty()) : a.kind === "time" ? Yk(a).test(e.data) || (s = this._getOrReturnCtx(e, s), W(s, {
        code: B.invalid_string,
        validation: "time",
        message: a.message
      }), n.dirty()) : a.kind === "duration" ? zk.test(e.data) || (s = this._getOrReturnCtx(e, s), W(s, {
        validation: "duration",
        code: B.invalid_string,
        message: a.message
      }), n.dirty()) : a.kind === "ip" ? Qk(e.data, a.version) || (s = this._getOrReturnCtx(e, s), W(s, {
        validation: "ip",
        code: B.invalid_string,
        message: a.message
      }), n.dirty()) : a.kind === "jwt" ? eI(e.data, a.alg) || (s = this._getOrReturnCtx(e, s), W(s, {
        validation: "jwt",
        code: B.invalid_string,
        message: a.message
      }), n.dirty()) : a.kind === "cidr" ? tI(e.data, a.version) || (s = this._getOrReturnCtx(e, s), W(s, {
        validation: "cidr",
        code: B.invalid_string,
        message: a.message
      }), n.dirty()) : a.kind === "base64" ? Gk.test(e.data) || (s = this._getOrReturnCtx(e, s), W(s, {
        validation: "base64",
        code: B.invalid_string,
        message: a.message
      }), n.dirty()) : a.kind === "base64url" ? Wk.test(e.data) || (s = this._getOrReturnCtx(e, s), W(s, {
        validation: "base64url",
        code: B.invalid_string,
        message: a.message
      }), n.dirty()) : Re.assertNever(a);
    return { status: n.value, value: e.data };
  }
  _regex(e, t, n) {
    return this.refinement((s) => e.test(s), {
      validation: t,
      code: B.invalid_string,
      ...te.errToObj(n)
    });
  }
  _addCheck(e) {
    return new $s({
      ...this._def,
      checks: [...this._def.checks, e]
    });
  }
  email(e) {
    return this._addCheck({ kind: "email", ...te.errToObj(e) });
  }
  url(e) {
    return this._addCheck({ kind: "url", ...te.errToObj(e) });
  }
  emoji(e) {
    return this._addCheck({ kind: "emoji", ...te.errToObj(e) });
  }
  uuid(e) {
    return this._addCheck({ kind: "uuid", ...te.errToObj(e) });
  }
  nanoid(e) {
    return this._addCheck({ kind: "nanoid", ...te.errToObj(e) });
  }
  cuid(e) {
    return this._addCheck({ kind: "cuid", ...te.errToObj(e) });
  }
  cuid2(e) {
    return this._addCheck({ kind: "cuid2", ...te.errToObj(e) });
  }
  ulid(e) {
    return this._addCheck({ kind: "ulid", ...te.errToObj(e) });
  }
  base64(e) {
    return this._addCheck({ kind: "base64", ...te.errToObj(e) });
  }
  base64url(e) {
    return this._addCheck({
      kind: "base64url",
      ...te.errToObj(e)
    });
  }
  jwt(e) {
    return this._addCheck({ kind: "jwt", ...te.errToObj(e) });
  }
  ip(e) {
    return this._addCheck({ kind: "ip", ...te.errToObj(e) });
  }
  cidr(e) {
    return this._addCheck({ kind: "cidr", ...te.errToObj(e) });
  }
  datetime(e) {
    return typeof e == "string" ? this._addCheck({
      kind: "datetime",
      precision: null,
      offset: !1,
      local: !1,
      message: e
    }) : this._addCheck({
      kind: "datetime",
      precision: typeof (e == null ? void 0 : e.precision) > "u" ? null : e == null ? void 0 : e.precision,
      offset: (e == null ? void 0 : e.offset) ?? !1,
      local: (e == null ? void 0 : e.local) ?? !1,
      ...te.errToObj(e == null ? void 0 : e.message)
    });
  }
  date(e) {
    return this._addCheck({ kind: "date", message: e });
  }
  time(e) {
    return typeof e == "string" ? this._addCheck({
      kind: "time",
      precision: null,
      message: e
    }) : this._addCheck({
      kind: "time",
      precision: typeof (e == null ? void 0 : e.precision) > "u" ? null : e == null ? void 0 : e.precision,
      ...te.errToObj(e == null ? void 0 : e.message)
    });
  }
  duration(e) {
    return this._addCheck({ kind: "duration", ...te.errToObj(e) });
  }
  regex(e, t) {
    return this._addCheck({
      kind: "regex",
      regex: e,
      ...te.errToObj(t)
    });
  }
  includes(e, t) {
    return this._addCheck({
      kind: "includes",
      value: e,
      position: t == null ? void 0 : t.position,
      ...te.errToObj(t == null ? void 0 : t.message)
    });
  }
  startsWith(e, t) {
    return this._addCheck({
      kind: "startsWith",
      value: e,
      ...te.errToObj(t)
    });
  }
  endsWith(e, t) {
    return this._addCheck({
      kind: "endsWith",
      value: e,
      ...te.errToObj(t)
    });
  }
  min(e, t) {
    return this._addCheck({
      kind: "min",
      value: e,
      ...te.errToObj(t)
    });
  }
  max(e, t) {
    return this._addCheck({
      kind: "max",
      value: e,
      ...te.errToObj(t)
    });
  }
  length(e, t) {
    return this._addCheck({
      kind: "length",
      value: e,
      ...te.errToObj(t)
    });
  }
  /**
   * Equivalent to `.min(1)`
   */
  nonempty(e) {
    return this.min(1, te.errToObj(e));
  }
  trim() {
    return new $s({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new $s({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new $s({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((e) => e.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((e) => e.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((e) => e.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((e) => e.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((e) => e.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((e) => e.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((e) => e.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((e) => e.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((e) => e.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((e) => e.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((e) => e.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((e) => e.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((e) => e.kind === "ip");
  }
  get isCIDR() {
    return !!this._def.checks.find((e) => e.kind === "cidr");
  }
  get isBase64() {
    return !!this._def.checks.find((e) => e.kind === "base64");
  }
  get isBase64url() {
    return !!this._def.checks.find((e) => e.kind === "base64url");
  }
  get minLength() {
    let e = null;
    for (const t of this._def.checks)
      t.kind === "min" && (e === null || t.value > e) && (e = t.value);
    return e;
  }
  get maxLength() {
    let e = null;
    for (const t of this._def.checks)
      t.kind === "max" && (e === null || t.value < e) && (e = t.value);
    return e;
  }
};
ru.create = (r) => new ru({
  checks: [],
  typeName: C.ZodString,
  coerce: (r == null ? void 0 : r.coerce) ?? !1,
  ...ke(r)
});
function rI(r, e) {
  const t = (r.toString().split(".")[1] || "").length, n = (e.toString().split(".")[1] || "").length, s = t > n ? t : n, a = Number.parseInt(r.toFixed(s).replace(".", "")), i = Number.parseInt(e.toFixed(s).replace(".", ""));
  return a % i / 10 ** s;
}
let Mh = class nu extends $e {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
  }
  _parse(e) {
    if (this._def.coerce && (e.data = Number(e.data)), this._getType(e) !== ee.number) {
      const a = this._getOrReturnCtx(e);
      return W(a, {
        code: B.invalid_type,
        expected: ee.number,
        received: a.parsedType
      }), Se;
    }
    let n;
    const s = new qt();
    for (const a of this._def.checks)
      a.kind === "int" ? Re.isInteger(e.data) || (n = this._getOrReturnCtx(e, n), W(n, {
        code: B.invalid_type,
        expected: "integer",
        received: "float",
        message: a.message
      }), s.dirty()) : a.kind === "min" ? (a.inclusive ? e.data < a.value : e.data <= a.value) && (n = this._getOrReturnCtx(e, n), W(n, {
        code: B.too_small,
        minimum: a.value,
        type: "number",
        inclusive: a.inclusive,
        exact: !1,
        message: a.message
      }), s.dirty()) : a.kind === "max" ? (a.inclusive ? e.data > a.value : e.data >= a.value) && (n = this._getOrReturnCtx(e, n), W(n, {
        code: B.too_big,
        maximum: a.value,
        type: "number",
        inclusive: a.inclusive,
        exact: !1,
        message: a.message
      }), s.dirty()) : a.kind === "multipleOf" ? rI(e.data, a.value) !== 0 && (n = this._getOrReturnCtx(e, n), W(n, {
        code: B.not_multiple_of,
        multipleOf: a.value,
        message: a.message
      }), s.dirty()) : a.kind === "finite" ? Number.isFinite(e.data) || (n = this._getOrReturnCtx(e, n), W(n, {
        code: B.not_finite,
        message: a.message
      }), s.dirty()) : Re.assertNever(a);
    return { status: s.value, value: e.data };
  }
  gte(e, t) {
    return this.setLimit("min", e, !0, te.toString(t));
  }
  gt(e, t) {
    return this.setLimit("min", e, !1, te.toString(t));
  }
  lte(e, t) {
    return this.setLimit("max", e, !0, te.toString(t));
  }
  lt(e, t) {
    return this.setLimit("max", e, !1, te.toString(t));
  }
  setLimit(e, t, n, s) {
    return new nu({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: e,
          value: t,
          inclusive: n,
          message: te.toString(s)
        }
      ]
    });
  }
  _addCheck(e) {
    return new nu({
      ...this._def,
      checks: [...this._def.checks, e]
    });
  }
  int(e) {
    return this._addCheck({
      kind: "int",
      message: te.toString(e)
    });
  }
  positive(e) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !1,
      message: te.toString(e)
    });
  }
  negative(e) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !1,
      message: te.toString(e)
    });
  }
  nonpositive(e) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !0,
      message: te.toString(e)
    });
  }
  nonnegative(e) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !0,
      message: te.toString(e)
    });
  }
  multipleOf(e, t) {
    return this._addCheck({
      kind: "multipleOf",
      value: e,
      message: te.toString(t)
    });
  }
  finite(e) {
    return this._addCheck({
      kind: "finite",
      message: te.toString(e)
    });
  }
  safe(e) {
    return this._addCheck({
      kind: "min",
      inclusive: !0,
      value: Number.MIN_SAFE_INTEGER,
      message: te.toString(e)
    })._addCheck({
      kind: "max",
      inclusive: !0,
      value: Number.MAX_SAFE_INTEGER,
      message: te.toString(e)
    });
  }
  get minValue() {
    let e = null;
    for (const t of this._def.checks)
      t.kind === "min" && (e === null || t.value > e) && (e = t.value);
    return e;
  }
  get maxValue() {
    let e = null;
    for (const t of this._def.checks)
      t.kind === "max" && (e === null || t.value < e) && (e = t.value);
    return e;
  }
  get isInt() {
    return !!this._def.checks.find((e) => e.kind === "int" || e.kind === "multipleOf" && Re.isInteger(e.value));
  }
  get isFinite() {
    let e = null, t = null;
    for (const n of this._def.checks) {
      if (n.kind === "finite" || n.kind === "int" || n.kind === "multipleOf")
        return !0;
      n.kind === "min" ? (t === null || n.value > t) && (t = n.value) : n.kind === "max" && (e === null || n.value < e) && (e = n.value);
    }
    return Number.isFinite(t) && Number.isFinite(e);
  }
};
Mh.create = (r) => new Mh({
  checks: [],
  typeName: C.ZodNumber,
  coerce: (r == null ? void 0 : r.coerce) || !1,
  ...ke(r)
});
class ta extends $e {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte;
  }
  _parse(e) {
    if (this._def.coerce)
      try {
        e.data = BigInt(e.data);
      } catch {
        return this._getInvalidInput(e);
      }
    if (this._getType(e) !== ee.bigint)
      return this._getInvalidInput(e);
    let n;
    const s = new qt();
    for (const a of this._def.checks)
      a.kind === "min" ? (a.inclusive ? e.data < a.value : e.data <= a.value) && (n = this._getOrReturnCtx(e, n), W(n, {
        code: B.too_small,
        type: "bigint",
        minimum: a.value,
        inclusive: a.inclusive,
        message: a.message
      }), s.dirty()) : a.kind === "max" ? (a.inclusive ? e.data > a.value : e.data >= a.value) && (n = this._getOrReturnCtx(e, n), W(n, {
        code: B.too_big,
        type: "bigint",
        maximum: a.value,
        inclusive: a.inclusive,
        message: a.message
      }), s.dirty()) : a.kind === "multipleOf" ? e.data % a.value !== BigInt(0) && (n = this._getOrReturnCtx(e, n), W(n, {
        code: B.not_multiple_of,
        multipleOf: a.value,
        message: a.message
      }), s.dirty()) : Re.assertNever(a);
    return { status: s.value, value: e.data };
  }
  _getInvalidInput(e) {
    const t = this._getOrReturnCtx(e);
    return W(t, {
      code: B.invalid_type,
      expected: ee.bigint,
      received: t.parsedType
    }), Se;
  }
  gte(e, t) {
    return this.setLimit("min", e, !0, te.toString(t));
  }
  gt(e, t) {
    return this.setLimit("min", e, !1, te.toString(t));
  }
  lte(e, t) {
    return this.setLimit("max", e, !0, te.toString(t));
  }
  lt(e, t) {
    return this.setLimit("max", e, !1, te.toString(t));
  }
  setLimit(e, t, n, s) {
    return new ta({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: e,
          value: t,
          inclusive: n,
          message: te.toString(s)
        }
      ]
    });
  }
  _addCheck(e) {
    return new ta({
      ...this._def,
      checks: [...this._def.checks, e]
    });
  }
  positive(e) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !1,
      message: te.toString(e)
    });
  }
  negative(e) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !1,
      message: te.toString(e)
    });
  }
  nonpositive(e) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !0,
      message: te.toString(e)
    });
  }
  nonnegative(e) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !0,
      message: te.toString(e)
    });
  }
  multipleOf(e, t) {
    return this._addCheck({
      kind: "multipleOf",
      value: e,
      message: te.toString(t)
    });
  }
  get minValue() {
    let e = null;
    for (const t of this._def.checks)
      t.kind === "min" && (e === null || t.value > e) && (e = t.value);
    return e;
  }
  get maxValue() {
    let e = null;
    for (const t of this._def.checks)
      t.kind === "max" && (e === null || t.value < e) && (e = t.value);
    return e;
  }
}
ta.create = (r) => new ta({
  checks: [],
  typeName: C.ZodBigInt,
  coerce: (r == null ? void 0 : r.coerce) ?? !1,
  ...ke(r)
});
let Dh = class extends $e {
  _parse(e) {
    if (this._def.coerce && (e.data = !!e.data), this._getType(e) !== ee.boolean) {
      const n = this._getOrReturnCtx(e);
      return W(n, {
        code: B.invalid_type,
        expected: ee.boolean,
        received: n.parsedType
      }), Se;
    }
    return Wt(e.data);
  }
};
Dh.create = (r) => new Dh({
  typeName: C.ZodBoolean,
  coerce: (r == null ? void 0 : r.coerce) || !1,
  ...ke(r)
});
class Li extends $e {
  _parse(e) {
    if (this._def.coerce && (e.data = new Date(e.data)), this._getType(e) !== ee.date) {
      const a = this._getOrReturnCtx(e);
      return W(a, {
        code: B.invalid_type,
        expected: ee.date,
        received: a.parsedType
      }), Se;
    }
    if (Number.isNaN(e.data.getTime())) {
      const a = this._getOrReturnCtx(e);
      return W(a, {
        code: B.invalid_date
      }), Se;
    }
    const n = new qt();
    let s;
    for (const a of this._def.checks)
      a.kind === "min" ? e.data.getTime() < a.value && (s = this._getOrReturnCtx(e, s), W(s, {
        code: B.too_small,
        message: a.message,
        inclusive: !0,
        exact: !1,
        minimum: a.value,
        type: "date"
      }), n.dirty()) : a.kind === "max" ? e.data.getTime() > a.value && (s = this._getOrReturnCtx(e, s), W(s, {
        code: B.too_big,
        message: a.message,
        inclusive: !0,
        exact: !1,
        maximum: a.value,
        type: "date"
      }), n.dirty()) : Re.assertNever(a);
    return {
      status: n.value,
      value: new Date(e.data.getTime())
    };
  }
  _addCheck(e) {
    return new Li({
      ...this._def,
      checks: [...this._def.checks, e]
    });
  }
  min(e, t) {
    return this._addCheck({
      kind: "min",
      value: e.getTime(),
      message: te.toString(t)
    });
  }
  max(e, t) {
    return this._addCheck({
      kind: "max",
      value: e.getTime(),
      message: te.toString(t)
    });
  }
  get minDate() {
    let e = null;
    for (const t of this._def.checks)
      t.kind === "min" && (e === null || t.value > e) && (e = t.value);
    return e != null ? new Date(e) : null;
  }
  get maxDate() {
    let e = null;
    for (const t of this._def.checks)
      t.kind === "max" && (e === null || t.value < e) && (e = t.value);
    return e != null ? new Date(e) : null;
  }
}
Li.create = (r) => new Li({
  checks: [],
  coerce: (r == null ? void 0 : r.coerce) || !1,
  typeName: C.ZodDate,
  ...ke(r)
});
class jh extends $e {
  _parse(e) {
    if (this._getType(e) !== ee.symbol) {
      const n = this._getOrReturnCtx(e);
      return W(n, {
        code: B.invalid_type,
        expected: ee.symbol,
        received: n.parsedType
      }), Se;
    }
    return Wt(e.data);
  }
}
jh.create = (r) => new jh({
  typeName: C.ZodSymbol,
  ...ke(r)
});
class Fh extends $e {
  _parse(e) {
    if (this._getType(e) !== ee.undefined) {
      const n = this._getOrReturnCtx(e);
      return W(n, {
        code: B.invalid_type,
        expected: ee.undefined,
        received: n.parsedType
      }), Se;
    }
    return Wt(e.data);
  }
}
Fh.create = (r) => new Fh({
  typeName: C.ZodUndefined,
  ...ke(r)
});
class Uh extends $e {
  _parse(e) {
    if (this._getType(e) !== ee.null) {
      const n = this._getOrReturnCtx(e);
      return W(n, {
        code: B.invalid_type,
        expected: ee.null,
        received: n.parsedType
      }), Se;
    }
    return Wt(e.data);
  }
}
Uh.create = (r) => new Uh({
  typeName: C.ZodNull,
  ...ke(r)
});
class su extends $e {
  constructor() {
    super(...arguments), this._any = !0;
  }
  _parse(e) {
    return Wt(e.data);
  }
}
su.create = (r) => new su({
  typeName: C.ZodAny,
  ...ke(r)
});
let zh = class extends $e {
  constructor() {
    super(...arguments), this._unknown = !0;
  }
  _parse(e) {
    return Wt(e.data);
  }
};
zh.create = (r) => new zh({
  typeName: C.ZodUnknown,
  ...ke(r)
});
let ln = class extends $e {
  _parse(e) {
    const t = this._getOrReturnCtx(e);
    return W(t, {
      code: B.invalid_type,
      expected: ee.never,
      received: t.parsedType
    }), Se;
  }
};
ln.create = (r) => new ln({
  typeName: C.ZodNever,
  ...ke(r)
});
class Bh extends $e {
  _parse(e) {
    if (this._getType(e) !== ee.undefined) {
      const n = this._getOrReturnCtx(e);
      return W(n, {
        code: B.invalid_type,
        expected: ee.void,
        received: n.parsedType
      }), Se;
    }
    return Wt(e.data);
  }
}
Bh.create = (r) => new Bh({
  typeName: C.ZodVoid,
  ...ke(r)
});
let ns = class di extends $e {
  _parse(e) {
    const { ctx: t, status: n } = this._processInputParams(e), s = this._def;
    if (t.parsedType !== ee.array)
      return W(t, {
        code: B.invalid_type,
        expected: ee.array,
        received: t.parsedType
      }), Se;
    if (s.exactLength !== null) {
      const i = t.data.length > s.exactLength.value, o = t.data.length < s.exactLength.value;
      (i || o) && (W(t, {
        code: i ? B.too_big : B.too_small,
        minimum: o ? s.exactLength.value : void 0,
        maximum: i ? s.exactLength.value : void 0,
        type: "array",
        inclusive: !0,
        exact: !0,
        message: s.exactLength.message
      }), n.dirty());
    }
    if (s.minLength !== null && t.data.length < s.minLength.value && (W(t, {
      code: B.too_small,
      minimum: s.minLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: s.minLength.message
    }), n.dirty()), s.maxLength !== null && t.data.length > s.maxLength.value && (W(t, {
      code: B.too_big,
      maximum: s.maxLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: s.maxLength.message
    }), n.dirty()), t.common.async)
      return Promise.all([...t.data].map((i, o) => s.type._parseAsync(new un(t, i, t.path, o)))).then((i) => qt.mergeArray(n, i));
    const a = [...t.data].map((i, o) => s.type._parseSync(new un(t, i, t.path, o)));
    return qt.mergeArray(n, a);
  }
  get element() {
    return this._def.type;
  }
  min(e, t) {
    return new di({
      ...this._def,
      minLength: { value: e, message: te.toString(t) }
    });
  }
  max(e, t) {
    return new di({
      ...this._def,
      maxLength: { value: e, message: te.toString(t) }
    });
  }
  length(e, t) {
    return new di({
      ...this._def,
      exactLength: { value: e, message: te.toString(t) }
    });
  }
  nonempty(e) {
    return this.min(1, e);
  }
};
ns.create = (r, e) => new ns({
  type: r,
  minLength: null,
  maxLength: null,
  exactLength: null,
  typeName: C.ZodArray,
  ...ke(e)
});
function zn(r) {
  if (r instanceof Zr) {
    const e = {};
    for (const t in r.shape) {
      const n = r.shape[t];
      e[t] = tn.create(zn(n));
    }
    return new Zr({
      ...r._def,
      shape: () => e
    });
  } else return r instanceof ns ? new ns({
    ...r._def,
    type: zn(r.element)
  }) : r instanceof tn ? tn.create(zn(r.unwrap())) : r instanceof as ? as.create(zn(r.unwrap())) : r instanceof kn ? kn.create(r.items.map((e) => zn(e))) : r;
}
let Zr = class sr extends $e {
  constructor() {
    super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const e = this._def.shape(), t = Re.objectKeys(e);
    return this._cached = { shape: e, keys: t }, this._cached;
  }
  _parse(e) {
    if (this._getType(e) !== ee.object) {
      const u = this._getOrReturnCtx(e);
      return W(u, {
        code: B.invalid_type,
        expected: ee.object,
        received: u.parsedType
      }), Se;
    }
    const { status: n, ctx: s } = this._processInputParams(e), { shape: a, keys: i } = this._getCached(), o = [];
    if (!(this._def.catchall instanceof ln && this._def.unknownKeys === "strip"))
      for (const u in s.data)
        i.includes(u) || o.push(u);
    const c = [];
    for (const u of i) {
      const l = a[u], d = s.data[u];
      c.push({
        key: { status: "valid", value: u },
        value: l._parse(new un(s, d, s.path, u)),
        alwaysSet: u in s.data
      });
    }
    if (this._def.catchall instanceof ln) {
      const u = this._def.unknownKeys;
      if (u === "passthrough")
        for (const l of o)
          c.push({
            key: { status: "valid", value: l },
            value: { status: "valid", value: s.data[l] }
          });
      else if (u === "strict")
        o.length > 0 && (W(s, {
          code: B.unrecognized_keys,
          keys: o
        }), n.dirty());
      else if (u !== "strip") throw new Error("Internal ZodObject error: invalid unknownKeys value.");
    } else {
      const u = this._def.catchall;
      for (const l of o) {
        const d = s.data[l];
        c.push({
          key: { status: "valid", value: l },
          value: u._parse(
            new un(s, d, s.path, l)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: l in s.data
        });
      }
    }
    return s.common.async ? Promise.resolve().then(async () => {
      const u = [];
      for (const l of c) {
        const d = await l.key, h = await l.value;
        u.push({
          key: d,
          value: h,
          alwaysSet: l.alwaysSet
        });
      }
      return u;
    }).then((u) => qt.mergeObjectSync(n, u)) : qt.mergeObjectSync(n, c);
  }
  get shape() {
    return this._def.shape();
  }
  strict(e) {
    return te.errToObj, new sr({
      ...this._def,
      unknownKeys: "strict",
      ...e !== void 0 ? {
        errorMap: (t, n) => {
          var a, i;
          const s = ((i = (a = this._def).errorMap) == null ? void 0 : i.call(a, t, n).message) ?? n.defaultError;
          return t.code === "unrecognized_keys" ? {
            message: te.errToObj(e).message ?? s
          } : {
            message: s
          };
        }
      } : {}
    });
  }
  strip() {
    return new sr({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new sr({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(e) {
    return new sr({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...e
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(e) {
    return new sr({
      unknownKeys: e._def.unknownKeys,
      catchall: e._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...e._def.shape()
      }),
      typeName: C.ZodObject
    });
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(e, t) {
    return this.augment({ [e]: t });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(e) {
    return new sr({
      ...this._def,
      catchall: e
    });
  }
  pick(e) {
    const t = {};
    for (const n of Re.objectKeys(e))
      e[n] && this.shape[n] && (t[n] = this.shape[n]);
    return new sr({
      ...this._def,
      shape: () => t
    });
  }
  omit(e) {
    const t = {};
    for (const n of Re.objectKeys(this.shape))
      e[n] || (t[n] = this.shape[n]);
    return new sr({
      ...this._def,
      shape: () => t
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return zn(this);
  }
  partial(e) {
    const t = {};
    for (const n of Re.objectKeys(this.shape)) {
      const s = this.shape[n];
      e && !e[n] ? t[n] = s : t[n] = s.optional();
    }
    return new sr({
      ...this._def,
      shape: () => t
    });
  }
  required(e) {
    const t = {};
    for (const n of Re.objectKeys(this.shape))
      if (e && !e[n])
        t[n] = this.shape[n];
      else {
        let a = this.shape[n];
        for (; a instanceof tn; )
          a = a._def.innerType;
        t[n] = a;
      }
    return new sr({
      ...this._def,
      shape: () => t
    });
  }
  keyof() {
    return u_(Re.objectKeys(this.shape));
  }
};
Zr.create = (r, e) => new Zr({
  shape: () => r,
  unknownKeys: "strip",
  catchall: ln.create(),
  typeName: C.ZodObject,
  ...ke(e)
});
Zr.strictCreate = (r, e) => new Zr({
  shape: () => r,
  unknownKeys: "strict",
  catchall: ln.create(),
  typeName: C.ZodObject,
  ...ke(e)
});
Zr.lazycreate = (r, e) => new Zr({
  shape: r,
  unknownKeys: "strip",
  catchall: ln.create(),
  typeName: C.ZodObject,
  ...ke(e)
});
let Mi = class extends $e {
  _parse(e) {
    const { ctx: t } = this._processInputParams(e), n = this._def.options;
    function s(a) {
      for (const o of a)
        if (o.result.status === "valid")
          return o.result;
      for (const o of a)
        if (o.result.status === "dirty")
          return t.common.issues.push(...o.ctx.common.issues), o.result;
      const i = a.map((o) => new Br(o.ctx.common.issues));
      return W(t, {
        code: B.invalid_union,
        unionErrors: i
      }), Se;
    }
    if (t.common.async)
      return Promise.all(n.map(async (a) => {
        const i = {
          ...t,
          common: {
            ...t.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await a._parseAsync({
            data: t.data,
            path: t.path,
            parent: i
          }),
          ctx: i
        };
      })).then(s);
    {
      let a;
      const i = [];
      for (const c of n) {
        const u = {
          ...t,
          common: {
            ...t.common,
            issues: []
          },
          parent: null
        }, l = c._parseSync({
          data: t.data,
          path: t.path,
          parent: u
        });
        if (l.status === "valid")
          return l;
        l.status === "dirty" && !a && (a = { result: l, ctx: u }), u.common.issues.length && i.push(u.common.issues);
      }
      if (a)
        return t.common.issues.push(...a.ctx.common.issues), a.result;
      const o = i.map((c) => new Br(c));
      return W(t, {
        code: B.invalid_union,
        unionErrors: o
      }), Se;
    }
  }
  get options() {
    return this._def.options;
  }
};
Mi.create = (r, e) => new Mi({
  options: r,
  typeName: C.ZodUnion,
  ...ke(e)
});
function au(r, e) {
  const t = Yr(r), n = Yr(e);
  if (r === e)
    return { valid: !0, data: r };
  if (t === ee.object && n === ee.object) {
    const s = Re.objectKeys(e), a = Re.objectKeys(r).filter((o) => s.indexOf(o) !== -1), i = { ...r, ...e };
    for (const o of a) {
      const c = au(r[o], e[o]);
      if (!c.valid)
        return { valid: !1 };
      i[o] = c.data;
    }
    return { valid: !0, data: i };
  } else if (t === ee.array && n === ee.array) {
    if (r.length !== e.length)
      return { valid: !1 };
    const s = [];
    for (let a = 0; a < r.length; a++) {
      const i = r[a], o = e[a], c = au(i, o);
      if (!c.valid)
        return { valid: !1 };
      s.push(c.data);
    }
    return { valid: !0, data: s };
  } else return t === ee.date && n === ee.date && +r == +e ? { valid: !0, data: r } : { valid: !1 };
}
let Di = class extends $e {
  _parse(e) {
    const { status: t, ctx: n } = this._processInputParams(e), s = (a, i) => {
      if (Nh(a) || Nh(i))
        return Se;
      const o = au(a.value, i.value);
      return o.valid ? ((Ph(a) || Ph(i)) && t.dirty(), { status: t.value, value: o.data }) : (W(n, {
        code: B.invalid_intersection_types
      }), Se);
    };
    return n.common.async ? Promise.all([
      this._def.left._parseAsync({
        data: n.data,
        path: n.path,
        parent: n
      }),
      this._def.right._parseAsync({
        data: n.data,
        path: n.path,
        parent: n
      })
    ]).then(([a, i]) => s(a, i)) : s(this._def.left._parseSync({
      data: n.data,
      path: n.path,
      parent: n
    }), this._def.right._parseSync({
      data: n.data,
      path: n.path,
      parent: n
    }));
  }
};
Di.create = (r, e, t) => new Di({
  left: r,
  right: e,
  typeName: C.ZodIntersection,
  ...ke(t)
});
class kn extends $e {
  _parse(e) {
    const { status: t, ctx: n } = this._processInputParams(e);
    if (n.parsedType !== ee.array)
      return W(n, {
        code: B.invalid_type,
        expected: ee.array,
        received: n.parsedType
      }), Se;
    if (n.data.length < this._def.items.length)
      return W(n, {
        code: B.too_small,
        minimum: this._def.items.length,
        inclusive: !0,
        exact: !1,
        type: "array"
      }), Se;
    !this._def.rest && n.data.length > this._def.items.length && (W(n, {
      code: B.too_big,
      maximum: this._def.items.length,
      inclusive: !0,
      exact: !1,
      type: "array"
    }), t.dirty());
    const a = [...n.data].map((i, o) => {
      const c = this._def.items[o] || this._def.rest;
      return c ? c._parse(new un(n, i, n.path, o)) : null;
    }).filter((i) => !!i);
    return n.common.async ? Promise.all(a).then((i) => qt.mergeArray(t, i)) : qt.mergeArray(t, a);
  }
  get items() {
    return this._def.items;
  }
  rest(e) {
    return new kn({
      ...this._def,
      rest: e
    });
  }
}
kn.create = (r, e) => {
  if (!Array.isArray(r))
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  return new kn({
    items: r,
    typeName: C.ZodTuple,
    rest: null,
    ...ke(e)
  });
};
class Zh extends $e {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(e) {
    const { status: t, ctx: n } = this._processInputParams(e);
    if (n.parsedType !== ee.map)
      return W(n, {
        code: B.invalid_type,
        expected: ee.map,
        received: n.parsedType
      }), Se;
    const s = this._def.keyType, a = this._def.valueType, i = [...n.data.entries()].map(([o, c], u) => ({
      key: s._parse(new un(n, o, n.path, [u, "key"])),
      value: a._parse(new un(n, c, n.path, [u, "value"]))
    }));
    if (n.common.async) {
      const o = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const c of i) {
          const u = await c.key, l = await c.value;
          if (u.status === "aborted" || l.status === "aborted")
            return Se;
          (u.status === "dirty" || l.status === "dirty") && t.dirty(), o.set(u.value, l.value);
        }
        return { status: t.value, value: o };
      });
    } else {
      const o = /* @__PURE__ */ new Map();
      for (const c of i) {
        const u = c.key, l = c.value;
        if (u.status === "aborted" || l.status === "aborted")
          return Se;
        (u.status === "dirty" || l.status === "dirty") && t.dirty(), o.set(u.value, l.value);
      }
      return { status: t.value, value: o };
    }
  }
}
Zh.create = (r, e, t) => new Zh({
  valueType: e,
  keyType: r,
  typeName: C.ZodMap,
  ...ke(t)
});
class ra extends $e {
  _parse(e) {
    const { status: t, ctx: n } = this._processInputParams(e);
    if (n.parsedType !== ee.set)
      return W(n, {
        code: B.invalid_type,
        expected: ee.set,
        received: n.parsedType
      }), Se;
    const s = this._def;
    s.minSize !== null && n.data.size < s.minSize.value && (W(n, {
      code: B.too_small,
      minimum: s.minSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: s.minSize.message
    }), t.dirty()), s.maxSize !== null && n.data.size > s.maxSize.value && (W(n, {
      code: B.too_big,
      maximum: s.maxSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: s.maxSize.message
    }), t.dirty());
    const a = this._def.valueType;
    function i(c) {
      const u = /* @__PURE__ */ new Set();
      for (const l of c) {
        if (l.status === "aborted")
          return Se;
        l.status === "dirty" && t.dirty(), u.add(l.value);
      }
      return { status: t.value, value: u };
    }
    const o = [...n.data.values()].map((c, u) => a._parse(new un(n, c, n.path, u)));
    return n.common.async ? Promise.all(o).then((c) => i(c)) : i(o);
  }
  min(e, t) {
    return new ra({
      ...this._def,
      minSize: { value: e, message: te.toString(t) }
    });
  }
  max(e, t) {
    return new ra({
      ...this._def,
      maxSize: { value: e, message: te.toString(t) }
    });
  }
  size(e, t) {
    return this.min(e, t).max(e, t);
  }
  nonempty(e) {
    return this.min(1, e);
  }
}
ra.create = (r, e) => new ra({
  valueType: r,
  minSize: null,
  maxSize: null,
  typeName: C.ZodSet,
  ...ke(e)
});
class Vh extends $e {
  get schema() {
    return this._def.getter();
  }
  _parse(e) {
    const { ctx: t } = this._processInputParams(e);
    return this._def.getter()._parse({ data: t.data, path: t.path, parent: t });
  }
}
Vh.create = (r, e) => new Vh({
  getter: r,
  typeName: C.ZodLazy,
  ...ke(e)
});
class qh extends $e {
  _parse(e) {
    if (e.data !== this._def.value) {
      const t = this._getOrReturnCtx(e);
      return W(t, {
        received: t.data,
        code: B.invalid_literal,
        expected: this._def.value
      }), Se;
    }
    return { status: "valid", value: e.data };
  }
  get value() {
    return this._def.value;
  }
}
qh.create = (r, e) => new qh({
  value: r,
  typeName: C.ZodLiteral,
  ...ke(e)
});
function u_(r, e) {
  return new $l({
    values: r,
    typeName: C.ZodEnum,
    ...ke(e)
  });
}
let $l = class iu extends $e {
  _parse(e) {
    if (typeof e.data != "string") {
      const t = this._getOrReturnCtx(e), n = this._def.values;
      return W(t, {
        expected: Re.joinValues(n),
        received: t.parsedType,
        code: B.invalid_type
      }), Se;
    }
    if (this._cache || (this._cache = new Set(this._def.values)), !this._cache.has(e.data)) {
      const t = this._getOrReturnCtx(e), n = this._def.values;
      return W(t, {
        received: t.data,
        code: B.invalid_enum_value,
        options: n
      }), Se;
    }
    return Wt(e.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const e = {};
    for (const t of this._def.values)
      e[t] = t;
    return e;
  }
  get Values() {
    const e = {};
    for (const t of this._def.values)
      e[t] = t;
    return e;
  }
  get Enum() {
    const e = {};
    for (const t of this._def.values)
      e[t] = t;
    return e;
  }
  extract(e, t = this._def) {
    return iu.create(e, {
      ...this._def,
      ...t
    });
  }
  exclude(e, t = this._def) {
    return iu.create(this.options.filter((n) => !e.includes(n)), {
      ...this._def,
      ...t
    });
  }
};
$l.create = u_;
class Jh extends $e {
  _parse(e) {
    const t = Re.getValidEnumValues(this._def.values), n = this._getOrReturnCtx(e);
    if (n.parsedType !== ee.string && n.parsedType !== ee.number) {
      const s = Re.objectValues(t);
      return W(n, {
        expected: Re.joinValues(s),
        received: n.parsedType,
        code: B.invalid_type
      }), Se;
    }
    if (this._cache || (this._cache = new Set(Re.getValidEnumValues(this._def.values))), !this._cache.has(e.data)) {
      const s = Re.objectValues(t);
      return W(n, {
        received: n.data,
        code: B.invalid_enum_value,
        options: s
      }), Se;
    }
    return Wt(e.data);
  }
  get enum() {
    return this._def.values;
  }
}
Jh.create = (r, e) => new Jh({
  values: r,
  typeName: C.ZodNativeEnum,
  ...ke(e)
});
class ji extends $e {
  unwrap() {
    return this._def.type;
  }
  _parse(e) {
    const { ctx: t } = this._processInputParams(e);
    if (t.parsedType !== ee.promise && t.common.async === !1)
      return W(t, {
        code: B.invalid_type,
        expected: ee.promise,
        received: t.parsedType
      }), Se;
    const n = t.parsedType === ee.promise ? t.data : Promise.resolve(t.data);
    return Wt(n.then((s) => this._def.type.parseAsync(s, {
      path: t.path,
      errorMap: t.common.contextualErrorMap
    })));
  }
}
ji.create = (r, e) => new ji({
  type: r,
  typeName: C.ZodPromise,
  ...ke(e)
});
class ss extends $e {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === C.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(e) {
    const { status: t, ctx: n } = this._processInputParams(e), s = this._def.effect || null, a = {
      addIssue: (i) => {
        W(n, i), i.fatal ? t.abort() : t.dirty();
      },
      get path() {
        return n.path;
      }
    };
    if (a.addIssue = a.addIssue.bind(a), s.type === "preprocess") {
      const i = s.transform(n.data, a);
      if (n.common.async)
        return Promise.resolve(i).then(async (o) => {
          if (t.value === "aborted")
            return Se;
          const c = await this._def.schema._parseAsync({
            data: o,
            path: n.path,
            parent: n
          });
          return c.status === "aborted" ? Se : c.status === "dirty" || t.value === "dirty" ? As(c.value) : c;
        });
      {
        if (t.value === "aborted")
          return Se;
        const o = this._def.schema._parseSync({
          data: i,
          path: n.path,
          parent: n
        });
        return o.status === "aborted" ? Se : o.status === "dirty" || t.value === "dirty" ? As(o.value) : o;
      }
    }
    if (s.type === "refinement") {
      const i = (o) => {
        const c = s.refinement(o, a);
        if (n.common.async)
          return Promise.resolve(c);
        if (c instanceof Promise)
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        return o;
      };
      if (n.common.async === !1) {
        const o = this._def.schema._parseSync({
          data: n.data,
          path: n.path,
          parent: n
        });
        return o.status === "aborted" ? Se : (o.status === "dirty" && t.dirty(), i(o.value), { status: t.value, value: o.value });
      } else
        return this._def.schema._parseAsync({ data: n.data, path: n.path, parent: n }).then((o) => o.status === "aborted" ? Se : (o.status === "dirty" && t.dirty(), i(o.value).then(() => ({ status: t.value, value: o.value }))));
    }
    if (s.type === "transform")
      if (n.common.async === !1) {
        const i = this._def.schema._parseSync({
          data: n.data,
          path: n.path,
          parent: n
        });
        if (!rs(i))
          return Se;
        const o = s.transform(i.value, a);
        if (o instanceof Promise)
          throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
        return { status: t.value, value: o };
      } else
        return this._def.schema._parseAsync({ data: n.data, path: n.path, parent: n }).then((i) => rs(i) ? Promise.resolve(s.transform(i.value, a)).then((o) => ({
          status: t.value,
          value: o
        })) : Se);
    Re.assertNever(s);
  }
}
ss.create = (r, e, t) => new ss({
  schema: r,
  typeName: C.ZodEffects,
  effect: e,
  ...ke(t)
});
ss.createWithPreprocess = (r, e, t) => new ss({
  schema: e,
  effect: { type: "preprocess", transform: r },
  typeName: C.ZodEffects,
  ...ke(t)
});
let tn = class extends $e {
  _parse(e) {
    return this._getType(e) === ee.undefined ? Wt(void 0) : this._def.innerType._parse(e);
  }
  unwrap() {
    return this._def.innerType;
  }
};
tn.create = (r, e) => new tn({
  innerType: r,
  typeName: C.ZodOptional,
  ...ke(e)
});
let as = class extends $e {
  _parse(e) {
    return this._getType(e) === ee.null ? Wt(null) : this._def.innerType._parse(e);
  }
  unwrap() {
    return this._def.innerType;
  }
};
as.create = (r, e) => new as({
  innerType: r,
  typeName: C.ZodNullable,
  ...ke(e)
});
let ou = class extends $e {
  _parse(e) {
    const { ctx: t } = this._processInputParams(e);
    let n = t.data;
    return t.parsedType === ee.undefined && (n = this._def.defaultValue()), this._def.innerType._parse({
      data: n,
      path: t.path,
      parent: t
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
};
ou.create = (r, e) => new ou({
  innerType: r,
  typeName: C.ZodDefault,
  defaultValue: typeof e.default == "function" ? e.default : () => e.default,
  ...ke(e)
});
let cu = class extends $e {
  _parse(e) {
    const { ctx: t } = this._processInputParams(e), n = {
      ...t,
      common: {
        ...t.common,
        issues: []
      }
    }, s = this._def.innerType._parse({
      data: n.data,
      path: n.path,
      parent: {
        ...n
      }
    });
    return Pi(s) ? s.then((a) => ({
      status: "valid",
      value: a.status === "valid" ? a.value : this._def.catchValue({
        get error() {
          return new Br(n.common.issues);
        },
        input: n.data
      })
    })) : {
      status: "valid",
      value: s.status === "valid" ? s.value : this._def.catchValue({
        get error() {
          return new Br(n.common.issues);
        },
        input: n.data
      })
    };
  }
  removeCatch() {
    return this._def.innerType;
  }
};
cu.create = (r, e) => new cu({
  innerType: r,
  typeName: C.ZodCatch,
  catchValue: typeof e.catch == "function" ? e.catch : () => e.catch,
  ...ke(e)
});
class Hh extends $e {
  _parse(e) {
    if (this._getType(e) !== ee.nan) {
      const n = this._getOrReturnCtx(e);
      return W(n, {
        code: B.invalid_type,
        expected: ee.nan,
        received: n.parsedType
      }), Se;
    }
    return { status: "valid", value: e.data };
  }
}
Hh.create = (r) => new Hh({
  typeName: C.ZodNaN,
  ...ke(r)
});
class nI extends $e {
  _parse(e) {
    const { ctx: t } = this._processInputParams(e), n = t.data;
    return this._def.type._parse({
      data: n,
      path: t.path,
      parent: t
    });
  }
  unwrap() {
    return this._def.type;
  }
}
class Cl extends $e {
  _parse(e) {
    const { status: t, ctx: n } = this._processInputParams(e);
    if (n.common.async)
      return (async () => {
        const a = await this._def.in._parseAsync({
          data: n.data,
          path: n.path,
          parent: n
        });
        return a.status === "aborted" ? Se : a.status === "dirty" ? (t.dirty(), As(a.value)) : this._def.out._parseAsync({
          data: a.value,
          path: n.path,
          parent: n
        });
      })();
    {
      const s = this._def.in._parseSync({
        data: n.data,
        path: n.path,
        parent: n
      });
      return s.status === "aborted" ? Se : s.status === "dirty" ? (t.dirty(), {
        status: "dirty",
        value: s.value
      }) : this._def.out._parseSync({
        data: s.value,
        path: n.path,
        parent: n
      });
    }
  }
  static create(e, t) {
    return new Cl({
      in: e,
      out: t,
      typeName: C.ZodPipeline
    });
  }
}
let uu = class extends $e {
  _parse(e) {
    const t = this._def.innerType._parse(e), n = (s) => (rs(s) && (s.value = Object.freeze(s.value)), s);
    return Pi(t) ? t.then((s) => n(s)) : n(t);
  }
  unwrap() {
    return this._def.innerType;
  }
};
uu.create = (r, e) => new uu({
  innerType: r,
  typeName: C.ZodReadonly,
  ...ke(e)
});
var C;
(function(r) {
  r.ZodString = "ZodString", r.ZodNumber = "ZodNumber", r.ZodNaN = "ZodNaN", r.ZodBigInt = "ZodBigInt", r.ZodBoolean = "ZodBoolean", r.ZodDate = "ZodDate", r.ZodSymbol = "ZodSymbol", r.ZodUndefined = "ZodUndefined", r.ZodNull = "ZodNull", r.ZodAny = "ZodAny", r.ZodUnknown = "ZodUnknown", r.ZodNever = "ZodNever", r.ZodVoid = "ZodVoid", r.ZodArray = "ZodArray", r.ZodObject = "ZodObject", r.ZodUnion = "ZodUnion", r.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", r.ZodIntersection = "ZodIntersection", r.ZodTuple = "ZodTuple", r.ZodRecord = "ZodRecord", r.ZodMap = "ZodMap", r.ZodSet = "ZodSet", r.ZodFunction = "ZodFunction", r.ZodLazy = "ZodLazy", r.ZodLiteral = "ZodLiteral", r.ZodEnum = "ZodEnum", r.ZodEffects = "ZodEffects", r.ZodNativeEnum = "ZodNativeEnum", r.ZodOptional = "ZodOptional", r.ZodNullable = "ZodNullable", r.ZodDefault = "ZodDefault", r.ZodCatch = "ZodCatch", r.ZodPromise = "ZodPromise", r.ZodBranded = "ZodBranded", r.ZodPipeline = "ZodPipeline", r.ZodReadonly = "ZodReadonly";
})(C || (C = {}));
const Io = ru.create, Gh = su.create;
ln.create;
ns.create;
const Oo = Zr.create;
Mi.create;
Di.create;
kn.create;
$l.create;
ji.create;
tn.create;
as.create;
function sI(r, e) {
  var n, s, a;
  const t = { type: "array" };
  return (n = r.type) != null && n._def && ((a = (s = r.type) == null ? void 0 : s._def) == null ? void 0 : a.typeName) !== C.ZodAny && (t.items = Le(r.type._def, {
    ...e,
    currentPath: [...e.currentPath, "items"]
  })), r.minLength && De(t, "minItems", r.minLength.value, r.minLength.message, e), r.maxLength && De(t, "maxItems", r.maxLength.value, r.maxLength.message, e), r.exactLength && (De(t, "minItems", r.exactLength.value, r.exactLength.message, e), De(t, "maxItems", r.exactLength.value, r.exactLength.message, e)), t;
}
function aI(r, e) {
  const t = {
    type: "integer",
    format: "int64"
  };
  if (!r.checks) return t;
  for (const n of r.checks) switch (n.kind) {
    case "min":
      e.target === "jsonSchema7" ? n.inclusive ? De(t, "minimum", n.value, n.message, e) : De(t, "exclusiveMinimum", n.value, n.message, e) : (n.inclusive || (t.exclusiveMinimum = !0), De(t, "minimum", n.value, n.message, e));
      break;
    case "max":
      e.target === "jsonSchema7" ? n.inclusive ? De(t, "maximum", n.value, n.message, e) : De(t, "exclusiveMaximum", n.value, n.message, e) : (n.inclusive || (t.exclusiveMaximum = !0), De(t, "maximum", n.value, n.message, e));
      break;
    case "multipleOf":
      De(t, "multipleOf", n.value, n.message, e);
      break;
  }
  return t;
}
function iI() {
  return { type: "boolean" };
}
function l_(r, e) {
  return Le(r.type._def, e);
}
const oI = (r, e) => Le(r.innerType._def, e);
function d_(r, e, t) {
  const n = t ?? e.dateStrategy;
  if (Array.isArray(n)) return { anyOf: n.map((s) => d_(r, e, s)) };
  switch (n) {
    case "string":
    case "format:date-time":
      return {
        type: "string",
        format: "date-time"
      };
    case "format:date":
      return {
        type: "string",
        format: "date"
      };
    case "integer":
      return cI(r, e);
  }
}
const cI = (r, e) => {
  const t = {
    type: "integer",
    format: "unix-time"
  };
  if (e.target === "openApi3") return t;
  for (const n of r.checks) switch (n.kind) {
    case "min":
      De(t, "minimum", n.value, n.message, e);
      break;
    case "max":
      De(t, "maximum", n.value, n.message, e);
      break;
  }
  return t;
};
function uI(r, e) {
  return {
    ...Le(r.innerType._def, e),
    default: r.defaultValue()
  };
}
function lI(r, e) {
  return e.effectStrategy === "input" ? Le(r.schema._def, e) : Vt(e);
}
function dI(r) {
  return {
    type: "string",
    enum: Array.from(r.values)
  };
}
const hI = (r) => "type" in r && r.type === "string" ? !1 : "allOf" in r;
function fI(r, e) {
  const t = [Le(r.left._def, {
    ...e,
    currentPath: [
      ...e.currentPath,
      "allOf",
      "0"
    ]
  }), Le(r.right._def, {
    ...e,
    currentPath: [
      ...e.currentPath,
      "allOf",
      "1"
    ]
  })].filter((a) => !!a);
  let n = e.target === "jsonSchema2019-09" ? { unevaluatedProperties: !1 } : void 0;
  const s = [];
  return t.forEach((a) => {
    if (hI(a))
      s.push(...a.allOf), a.unevaluatedProperties === void 0 && (n = void 0);
    else {
      let i = a;
      if ("additionalProperties" in a && a.additionalProperties === !1) {
        const { additionalProperties: o, ...c } = a;
        i = c;
      } else n = void 0;
      s.push(i);
    }
  }), s.length ? {
    allOf: s,
    ...n
  } : void 0;
}
function pI(r, e) {
  const t = typeof r.value;
  return t !== "bigint" && t !== "number" && t !== "boolean" && t !== "string" ? { type: Array.isArray(r.value) ? "array" : "object" } : e.target === "openApi3" ? {
    type: t === "bigint" ? "integer" : t,
    enum: [r.value]
  } : {
    type: t === "bigint" ? "integer" : t,
    const: r.value
  };
}
let fc;
const Qt = {
  cuid: /^[cC][^\s-]{8,}$/,
  cuid2: /^[0-9a-z]+$/,
  ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,
  email: /^(?!\.)(?!.*\.\.)([a-zA-Z0-9_'+\-\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\-]*\.)+[a-zA-Z]{2,}$/,
  emoji: () => (fc === void 0 && (fc = RegExp("^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$", "u")), fc),
  uuid: /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/,
  ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
  ipv4Cidr: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/,
  ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,
  ipv6Cidr: /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,
  base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
  base64url: /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,
  nanoid: /^[a-zA-Z0-9_-]{21}$/,
  jwt: /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/
};
function h_(r, e) {
  const t = { type: "string" };
  if (r.checks) for (const n of r.checks) switch (n.kind) {
    case "min":
      De(t, "minLength", typeof t.minLength == "number" ? Math.max(t.minLength, n.value) : n.value, n.message, e);
      break;
    case "max":
      De(t, "maxLength", typeof t.maxLength == "number" ? Math.min(t.maxLength, n.value) : n.value, n.message, e);
      break;
    case "email":
      switch (e.emailStrategy) {
        case "format:email":
          er(t, "email", n.message, e);
          break;
        case "format:idn-email":
          er(t, "idn-email", n.message, e);
          break;
        case "pattern:zod":
          xt(t, Qt.email, n.message, e);
          break;
      }
      break;
    case "url":
      er(t, "uri", n.message, e);
      break;
    case "uuid":
      er(t, "uuid", n.message, e);
      break;
    case "regex":
      xt(t, n.regex, n.message, e);
      break;
    case "cuid":
      xt(t, Qt.cuid, n.message, e);
      break;
    case "cuid2":
      xt(t, Qt.cuid2, n.message, e);
      break;
    case "startsWith":
      xt(t, RegExp(`^${pc(n.value, e)}`), n.message, e);
      break;
    case "endsWith":
      xt(t, RegExp(`${pc(n.value, e)}$`), n.message, e);
      break;
    case "datetime":
      er(t, "date-time", n.message, e);
      break;
    case "date":
      er(t, "date", n.message, e);
      break;
    case "time":
      er(t, "time", n.message, e);
      break;
    case "duration":
      er(t, "duration", n.message, e);
      break;
    case "length":
      De(t, "minLength", typeof t.minLength == "number" ? Math.max(t.minLength, n.value) : n.value, n.message, e), De(t, "maxLength", typeof t.maxLength == "number" ? Math.min(t.maxLength, n.value) : n.value, n.message, e);
      break;
    case "includes":
      xt(t, RegExp(pc(n.value, e)), n.message, e);
      break;
    case "ip":
      n.version !== "v6" && er(t, "ipv4", n.message, e), n.version !== "v4" && er(t, "ipv6", n.message, e);
      break;
    case "base64url":
      xt(t, Qt.base64url, n.message, e);
      break;
    case "jwt":
      xt(t, Qt.jwt, n.message, e);
      break;
    case "cidr":
      n.version !== "v6" && xt(t, Qt.ipv4Cidr, n.message, e), n.version !== "v4" && xt(t, Qt.ipv6Cidr, n.message, e);
      break;
    case "emoji":
      xt(t, Qt.emoji(), n.message, e);
      break;
    case "ulid":
      xt(t, Qt.ulid, n.message, e);
      break;
    case "base64":
      switch (e.base64Strategy) {
        case "format:binary":
          er(t, "binary", n.message, e);
          break;
        case "contentEncoding:base64":
          De(t, "contentEncoding", "base64", n.message, e);
          break;
        case "pattern:zod":
          xt(t, Qt.base64, n.message, e);
          break;
      }
      break;
    case "nanoid":
      xt(t, Qt.nanoid, n.message, e);
      break;
  }
  return t;
}
function pc(r, e) {
  return e.patternStrategy === "escape" ? gI(r) : r;
}
const mI = /* @__PURE__ */ new Set("ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789");
function gI(r) {
  let e = "";
  for (let t = 0; t < r.length; t++)
    mI.has(r[t]) || (e += "\\"), e += r[t];
  return e;
}
function er(r, e, t, n) {
  var s;
  r.format || (s = r.anyOf) != null && s.some((a) => a.format) ? (r.anyOf || (r.anyOf = []), r.format && (r.anyOf.push({
    format: r.format,
    ...r.errorMessage && n.errorMessages && { errorMessage: { format: r.errorMessage.format } }
  }), delete r.format, r.errorMessage && (delete r.errorMessage.format, Object.keys(r.errorMessage).length === 0 && delete r.errorMessage)), r.anyOf.push({
    format: e,
    ...t && n.errorMessages && { errorMessage: { format: t } }
  })) : De(r, "format", e, t, n);
}
function xt(r, e, t, n) {
  var s;
  r.pattern || (s = r.allOf) != null && s.some((a) => a.pattern) ? (r.allOf || (r.allOf = []), r.pattern && (r.allOf.push({
    pattern: r.pattern,
    ...r.errorMessage && n.errorMessages && { errorMessage: { pattern: r.errorMessage.pattern } }
  }), delete r.pattern, r.errorMessage && (delete r.errorMessage.pattern, Object.keys(r.errorMessage).length === 0 && delete r.errorMessage)), r.allOf.push({
    pattern: Wh(e, n),
    ...t && n.errorMessages && { errorMessage: { pattern: t } }
  })) : De(r, "pattern", Wh(e, n), t, n);
}
function Wh(r, e) {
  var c;
  if (!e.applyRegexFlags || !r.flags) return r.source;
  const t = {
    i: r.flags.includes("i"),
    m: r.flags.includes("m"),
    s: r.flags.includes("s")
  }, n = t.i ? r.source.toLowerCase() : r.source;
  let s = "", a = !1, i = !1, o = !1;
  for (let u = 0; u < n.length; u++) {
    if (a) {
      s += n[u], a = !1;
      continue;
    }
    if (t.i) {
      if (i) {
        if (n[u].match(/[a-z]/)) {
          o ? (s += n[u], s += `${n[u - 2]}-${n[u]}`.toUpperCase(), o = !1) : n[u + 1] === "-" && ((c = n[u + 2]) != null && c.match(/[a-z]/)) ? (s += n[u], o = !0) : s += `${n[u]}${n[u].toUpperCase()}`;
          continue;
        }
      } else if (n[u].match(/[a-z]/)) {
        s += `[${n[u]}${n[u].toUpperCase()}]`;
        continue;
      }
    }
    if (t.m) {
      if (n[u] === "^") {
        s += `(^|(?<=[\r
]))`;
        continue;
      } else if (n[u] === "$") {
        s += `($|(?=[\r
]))`;
        continue;
      }
    }
    if (t.s && n[u] === ".") {
      s += i ? `${n[u]}\r
` : `[${n[u]}\r
]`;
      continue;
    }
    s += n[u], n[u] === "\\" ? a = !0 : i && n[u] === "]" ? i = !1 : !i && n[u] === "[" && (i = !0);
  }
  try {
    new RegExp(s);
  } catch {
    return console.warn(`Could not convert regex pattern at ${e.currentPath.join("/")} to a flag-independent form! Falling back to the flag-ignorant source`), r.source;
  }
  return s;
}
function f_(r, e) {
  var n, s, a, i, o, c;
  if (e.target === "openAi" && console.warn("Warning: OpenAI may not support records in schemas! Try an array of key-value pairs instead."), e.target === "openApi3" && ((n = r.keyType) == null ? void 0 : n._def.typeName) === C.ZodEnum) return {
    type: "object",
    required: r.keyType._def.values,
    properties: r.keyType._def.values.reduce((u, l) => ({
      ...u,
      [l]: Le(r.valueType._def, {
        ...e,
        currentPath: [
          ...e.currentPath,
          "properties",
          l
        ]
      }) ?? Vt(e)
    }), {}),
    additionalProperties: e.rejectedAdditionalProperties
  };
  const t = {
    type: "object",
    additionalProperties: Le(r.valueType._def, {
      ...e,
      currentPath: [...e.currentPath, "additionalProperties"]
    }) ?? e.allowedAdditionalProperties
  };
  if (e.target === "openApi3") return t;
  if (((s = r.keyType) == null ? void 0 : s._def.typeName) === C.ZodString && ((a = r.keyType._def.checks) != null && a.length)) {
    const { type: u, ...l } = h_(r.keyType._def, e);
    return {
      ...t,
      propertyNames: l
    };
  } else {
    if (((i = r.keyType) == null ? void 0 : i._def.typeName) === C.ZodEnum) return {
      ...t,
      propertyNames: { enum: r.keyType._def.values }
    };
    if (((o = r.keyType) == null ? void 0 : o._def.typeName) === C.ZodBranded && r.keyType._def.type._def.typeName === C.ZodString && ((c = r.keyType._def.type._def.checks) != null && c.length)) {
      const { type: u, ...l } = l_(r.keyType._def, e);
      return {
        ...t,
        propertyNames: l
      };
    }
  }
  return t;
}
function _I(r, e) {
  if (e.mapStrategy === "record") return f_(r, e);
  const t = Le(r.keyType._def, {
    ...e,
    currentPath: [
      ...e.currentPath,
      "items",
      "items",
      "0"
    ]
  }) || Vt(e), n = Le(r.valueType._def, {
    ...e,
    currentPath: [
      ...e.currentPath,
      "items",
      "items",
      "1"
    ]
  }) || Vt(e);
  return {
    type: "array",
    maxItems: 125,
    items: {
      type: "array",
      items: [t, n],
      minItems: 2,
      maxItems: 2
    }
  };
}
function yI(r) {
  const e = r.values, n = Object.keys(r.values).filter((a) => typeof e[e[a]] != "number").map((a) => e[a]), s = Array.from(new Set(n.map((a) => typeof a)));
  return {
    type: s.length === 1 ? s[0] === "string" ? "string" : "number" : ["string", "number"],
    enum: n
  };
}
function wI(r) {
  return r.target === "openAi" ? void 0 : { not: Vt({
    ...r,
    currentPath: [...r.currentPath, "not"]
  }) };
}
function vI(r) {
  return r.target === "openApi3" ? {
    enum: ["null"],
    nullable: !0
  } : { type: "null" };
}
const Fi = {
  ZodString: "string",
  ZodNumber: "number",
  ZodBigInt: "integer",
  ZodBoolean: "boolean",
  ZodNull: "null"
};
function bI(r, e) {
  if (e.target === "openApi3") return Kh(r, e);
  const t = r.options instanceof Map ? Array.from(r.options.values()) : r.options;
  if (t.every((n) => n._def.typeName in Fi && (!n._def.checks || !n._def.checks.length))) {
    const n = t.reduce((s, a) => {
      const i = Fi[a._def.typeName];
      return i && !s.includes(i) ? [...s, i] : s;
    }, []);
    return { type: n.length > 1 ? n : n[0] };
  } else if (t.every((n) => n._def.typeName === "ZodLiteral" && !n.description)) {
    const n = t.reduce((s, a) => {
      const i = typeof a._def.value;
      switch (i) {
        case "string":
        case "number":
        case "boolean":
          return [...s, i];
        case "bigint":
          return [...s, "integer"];
        case "object":
          return a._def.value === null ? [...s, "null"] : s;
        case "symbol":
        case "undefined":
        case "function":
        default:
          return s;
      }
    }, []);
    if (n.length === t.length) {
      const s = n.filter((a, i, o) => o.indexOf(a) === i);
      return {
        type: s.length > 1 ? s : s[0],
        enum: t.reduce((a, i) => a.includes(i._def.value) ? a : [...a, i._def.value], [])
      };
    }
  } else if (t.every((n) => n._def.typeName === "ZodEnum")) return {
    type: "string",
    enum: t.reduce((n, s) => [...n, ...s._def.values.filter((a) => !n.includes(a))], [])
  };
  return Kh(r, e);
}
const Kh = (r, e) => {
  const t = (r.options instanceof Map ? Array.from(r.options.values()) : r.options).map((n, s) => Le(n._def, {
    ...e,
    currentPath: [
      ...e.currentPath,
      "anyOf",
      `${s}`
    ]
  })).filter((n) => !!n && (!e.strictUnions || typeof n == "object" && Object.keys(n).length > 0));
  return t.length ? { anyOf: t } : void 0;
};
function SI(r, e) {
  if ([
    "ZodString",
    "ZodNumber",
    "ZodBigInt",
    "ZodBoolean",
    "ZodNull"
  ].includes(r.innerType._def.typeName) && (!r.innerType._def.checks || !r.innerType._def.checks.length))
    return e.target === "openApi3" ? {
      type: Fi[r.innerType._def.typeName],
      nullable: !0
    } : { type: [Fi[r.innerType._def.typeName], "null"] };
  if (e.target === "openApi3") {
    const n = Le(r.innerType._def, {
      ...e,
      currentPath: [...e.currentPath]
    });
    return n && "$ref" in n ? {
      allOf: [n],
      nullable: !0
    } : n && {
      ...n,
      nullable: !0
    };
  }
  const t = Le(r.innerType._def, {
    ...e,
    currentPath: [
      ...e.currentPath,
      "anyOf",
      "0"
    ]
  });
  return t && { anyOf: [t, { type: "null" }] };
}
function TI(r, e) {
  const t = { type: "number" };
  if (!r.checks) return t;
  for (const n of r.checks) switch (n.kind) {
    case "int":
      t.type = "integer", i_(t, "type", n.message, e);
      break;
    case "min":
      e.target === "jsonSchema7" ? n.inclusive ? De(t, "minimum", n.value, n.message, e) : De(t, "exclusiveMinimum", n.value, n.message, e) : (n.inclusive || (t.exclusiveMinimum = !0), De(t, "minimum", n.value, n.message, e));
      break;
    case "max":
      e.target === "jsonSchema7" ? n.inclusive ? De(t, "maximum", n.value, n.message, e) : De(t, "exclusiveMaximum", n.value, n.message, e) : (n.inclusive || (t.exclusiveMaximum = !0), De(t, "maximum", n.value, n.message, e));
      break;
    case "multipleOf":
      De(t, "multipleOf", n.value, n.message, e);
      break;
  }
  return t;
}
function EI(r, e) {
  const t = e.target === "openAi", n = {
    type: "object",
    properties: {}
  }, s = [], a = r.shape();
  for (const o in a) {
    let c = a[o];
    if (c === void 0 || c._def === void 0) continue;
    let u = kI(c);
    u && t && (c._def.typeName === "ZodOptional" && (c = c._def.innerType), c.isNullable() || (c = c.nullable()), u = !1);
    const l = Le(c._def, {
      ...e,
      currentPath: [
        ...e.currentPath,
        "properties",
        o
      ],
      propertyPath: [
        ...e.currentPath,
        "properties",
        o
      ]
    });
    l !== void 0 && (n.properties[o] = l, u || s.push(o));
  }
  s.length && (n.required = s);
  const i = xI(r, e);
  return i !== void 0 && (n.additionalProperties = i), n;
}
function xI(r, e) {
  if (r.catchall._def.typeName !== "ZodNever") return Le(r.catchall._def, {
    ...e,
    currentPath: [...e.currentPath, "additionalProperties"]
  });
  switch (r.unknownKeys) {
    case "passthrough":
      return e.allowedAdditionalProperties;
    case "strict":
      return e.rejectedAdditionalProperties;
    case "strip":
      return e.removeAdditionalStrategy === "strict" ? e.allowedAdditionalProperties : e.rejectedAdditionalProperties;
  }
}
function kI(r) {
  try {
    return r.isOptional();
  } catch {
    return !0;
  }
}
const II = (r, e) => {
  var n;
  if (e.currentPath.toString() === ((n = e.propertyPath) == null ? void 0 : n.toString())) return Le(r.innerType._def, e);
  const t = Le(r.innerType._def, {
    ...e,
    currentPath: [
      ...e.currentPath,
      "anyOf",
      "1"
    ]
  });
  return t ? { anyOf: [{ not: Vt(e) }, t] } : Vt(e);
}, OI = (r, e) => {
  if (e.pipeStrategy === "input") return Le(r.in._def, e);
  if (e.pipeStrategy === "output") return Le(r.out._def, e);
  const t = Le(r.in._def, {
    ...e,
    currentPath: [
      ...e.currentPath,
      "allOf",
      "0"
    ]
  }), n = Le(r.out._def, {
    ...e,
    currentPath: [
      ...e.currentPath,
      "allOf",
      t ? "1" : "0"
    ]
  });
  return { allOf: [t, n].filter((s) => s !== void 0) };
};
function AI(r, e) {
  return Le(r.type._def, e);
}
function $I(r, e) {
  const n = {
    type: "array",
    uniqueItems: !0,
    items: Le(r.valueType._def, {
      ...e,
      currentPath: [...e.currentPath, "items"]
    })
  };
  return r.minSize && De(n, "minItems", r.minSize.value, r.minSize.message, e), r.maxSize && De(n, "maxItems", r.maxSize.value, r.maxSize.message, e), n;
}
function CI(r, e) {
  return r.rest ? {
    type: "array",
    minItems: r.items.length,
    items: r.items.map((t, n) => Le(t._def, {
      ...e,
      currentPath: [
        ...e.currentPath,
        "items",
        `${n}`
      ]
    })).reduce((t, n) => n === void 0 ? t : [...t, n], []),
    additionalItems: Le(r.rest._def, {
      ...e,
      currentPath: [...e.currentPath, "additionalItems"]
    })
  } : {
    type: "array",
    minItems: r.items.length,
    maxItems: r.items.length,
    items: r.items.map((t, n) => Le(t._def, {
      ...e,
      currentPath: [
        ...e.currentPath,
        "items",
        `${n}`
      ]
    })).reduce((t, n) => n === void 0 ? t : [...t, n], [])
  };
}
function RI(r) {
  return { not: Vt(r) };
}
function NI(r) {
  return Vt(r);
}
const PI = (r, e) => Le(r.innerType._def, e), LI = (r, e, t) => {
  switch (e) {
    case C.ZodString:
      return h_(r, t);
    case C.ZodNumber:
      return TI(r, t);
    case C.ZodObject:
      return EI(r, t);
    case C.ZodBigInt:
      return aI(r, t);
    case C.ZodBoolean:
      return iI();
    case C.ZodDate:
      return d_(r, t);
    case C.ZodUndefined:
      return RI(t);
    case C.ZodNull:
      return vI(t);
    case C.ZodArray:
      return sI(r, t);
    case C.ZodUnion:
    case C.ZodDiscriminatedUnion:
      return bI(r, t);
    case C.ZodIntersection:
      return fI(r, t);
    case C.ZodTuple:
      return CI(r, t);
    case C.ZodRecord:
      return f_(r, t);
    case C.ZodLiteral:
      return pI(r, t);
    case C.ZodEnum:
      return dI(r);
    case C.ZodNativeEnum:
      return yI(r);
    case C.ZodNullable:
      return SI(r, t);
    case C.ZodOptional:
      return II(r, t);
    case C.ZodMap:
      return _I(r, t);
    case C.ZodSet:
      return $I(r, t);
    case C.ZodLazy:
      return () => r.getter()._def;
    case C.ZodPromise:
      return AI(r, t);
    case C.ZodNaN:
    case C.ZodNever:
      return wI(t);
    case C.ZodEffects:
      return lI(r, t);
    case C.ZodAny:
      return Vt(t);
    case C.ZodUnknown:
      return NI(t);
    case C.ZodDefault:
      return uI(r, t);
    case C.ZodBranded:
      return l_(r, t);
    case C.ZodReadonly:
      return PI(r, t);
    case C.ZodCatch:
      return oI(r, t);
    case C.ZodPipeline:
      return OI(r, t);
    case C.ZodFunction:
    case C.ZodVoid:
    case C.ZodSymbol:
      return;
    default:
      return /* @__PURE__ */ ((n) => {
      })();
  }
};
function Le(r, e, t = !1) {
  var o;
  const n = e.seen.get(r);
  if (e.override) {
    const c = (o = e.override) == null ? void 0 : o.call(e, r, e, n, t);
    if (c !== Ok) return c;
  }
  if (n && !t) {
    const c = MI(n, e);
    if (c !== void 0) return c;
  }
  const s = {
    def: r,
    path: e.currentPath,
    jsonSchema: void 0
  };
  e.seen.set(r, s);
  const a = LI(r, r.typeName, e), i = typeof a == "function" ? Le(a(), e) : a;
  if (i && DI(r, e, i), e.postProcess) {
    const c = e.postProcess(i, r, e);
    return s.jsonSchema = i, c;
  }
  return s.jsonSchema = i, i;
}
const MI = (r, e) => {
  switch (e.$refStrategy) {
    case "root":
      return { $ref: r.path.join("/") };
    case "relative":
      return { $ref: a_(e.currentPath, r.path) };
    case "none":
    case "seen":
      return r.path.length < e.currentPath.length && r.path.every((t, n) => e.currentPath[n] === t) ? (console.warn(`Recursive reference detected at ${e.currentPath.join("/")}! Defaulting to any`), Vt(e)) : e.$refStrategy === "seen" ? Vt(e) : void 0;
  }
}, DI = (r, e, t) => (r.description && (t.description = r.description, e.markdownDescription && (t.markdownDescription = r.description)), t), jI = (r, e) => {
  const t = Ck(e);
  let n;
  const s = Le(r._def, t, !1) ?? Vt(t);
  t.flags.hasReferencedOpenAiAnyType && (n || (n = {}), n[t.openAiAnyTypeName] || (n[t.openAiAnyTypeName] = {
    type: [
      "string",
      "number",
      "integer",
      "boolean",
      "array",
      "null"
    ],
    items: { $ref: t.$refStrategy === "relative" ? "1" : [
      ...t.basePath,
      t.definitionPath,
      t.openAiAnyTypeName
    ].join("/") }
  }));
  const a = n ? {
    ...s,
    [t.definitionPath]: n
  } : s;
  return t.target === "jsonSchema7" ? a.$schema = "http://json-schema.org/draft-07/schema#" : (t.target === "jsonSchema2019-09" || t.target === "openAi") && (a.$schema = "https://json-schema.org/draft/2019-09/schema#"), t.target === "openAi" && ("anyOf" in a || "oneOf" in a || "allOf" in a || "type" in a && Array.isArray(a.type)) && console.warn("Warning: OpenAI may not support schemas with unions as roots! Try wrapping it in an object property."), a;
};
function Tn(r, e) {
  const t = typeof r;
  if (t !== typeof e)
    return !1;
  if (Array.isArray(r)) {
    if (!Array.isArray(e))
      return !1;
    const n = r.length;
    if (n !== e.length)
      return !1;
    for (let s = 0; s < n; s++)
      if (!Tn(r[s], e[s]))
        return !1;
    return !0;
  }
  if (t === "object") {
    if (!r || !e)
      return r === e;
    const n = Object.keys(r), s = Object.keys(e);
    if (n.length !== s.length)
      return !1;
    for (const i of n)
      if (!Tn(r[i], e[i]))
        return !1;
    return !0;
  }
  return r === e;
}
function ar(r) {
  return encodeURI(FI(r));
}
function FI(r) {
  return r.replace(/~/g, "~0").replace(/\//g, "~1");
}
const UI = {
  prefixItems: !0,
  items: !0,
  allOf: !0,
  anyOf: !0,
  oneOf: !0
}, zI = {
  $defs: !0,
  definitions: !0,
  properties: !0,
  patternProperties: !0,
  dependentSchemas: !0
}, BI = {
  id: !0,
  $id: !0,
  $ref: !0,
  $schema: !0,
  $anchor: !0,
  $vocabulary: !0,
  $comment: !0,
  default: !0,
  enum: !0,
  const: !0,
  required: !0,
  type: !0,
  maximum: !0,
  minimum: !0,
  exclusiveMaximum: !0,
  exclusiveMinimum: !0,
  multipleOf: !0,
  maxLength: !0,
  minLength: !0,
  pattern: !0,
  format: !0,
  maxItems: !0,
  minItems: !0,
  uniqueItems: !0,
  maxProperties: !0,
  minProperties: !0
};
let ZI = typeof self < "u" && self.location && self.location.origin !== "null" ? new URL(self.location.origin + self.location.pathname + location.search) : new URL("https://github.com/cfworker");
function Qr(r, e = /* @__PURE__ */ Object.create(null), t = ZI, n = "") {
  if (r && typeof r == "object" && !Array.isArray(r)) {
    const a = r.$id || r.id;
    if (a) {
      const i = new URL(a, t.href);
      i.hash.length > 1 ? e[i.href] = r : (i.hash = "", n === "" ? t = i : Qr(r, e, t));
    }
  } else if (r !== !0 && r !== !1)
    return e;
  const s = t.href + (n ? "#" + n : "");
  if (e[s] !== void 0)
    throw new Error(`Duplicate schema URI "${s}".`);
  if (e[s] = r, r === !0 || r === !1)
    return e;
  if (r.__absolute_uri__ === void 0 && Object.defineProperty(r, "__absolute_uri__", {
    enumerable: !1,
    value: s
  }), r.$ref && r.__absolute_ref__ === void 0) {
    const a = new URL(r.$ref, t.href);
    a.hash = a.hash, Object.defineProperty(r, "__absolute_ref__", {
      enumerable: !1,
      value: a.href
    });
  }
  if (r.$recursiveRef && r.__absolute_recursive_ref__ === void 0) {
    const a = new URL(r.$recursiveRef, t.href);
    a.hash = a.hash, Object.defineProperty(r, "__absolute_recursive_ref__", {
      enumerable: !1,
      value: a.href
    });
  }
  if (r.$anchor) {
    const a = new URL("#" + r.$anchor, t.href);
    e[a.href] = r;
  }
  for (let a in r) {
    if (BI[a])
      continue;
    const i = `${n}/${ar(a)}`, o = r[a];
    if (Array.isArray(o)) {
      if (UI[a]) {
        const c = o.length;
        for (let u = 0; u < c; u++)
          Qr(o[u], e, t, `${i}/${u}`);
      }
    } else if (zI[a])
      for (let c in o)
        Qr(o[c], e, t, `${i}/${ar(c)}`);
    else
      Qr(o, e, t, i);
  }
  return e;
}
const VI = /^(\d\d\d\d)-(\d\d)-(\d\d)$/, qI = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], JI = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d(?::?\d\d)?)?$/i, HI = /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i, GI = /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i, WI = /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i, KI = /^(?:(?:https?|ftp):\/\/)(?:\S+(?::\S*)?@)?(?:(?!10(?:\.\d{1,3}){3})(?!127(?:\.\d{1,3}){3})(?!169\.254(?:\.\d{1,3}){2})(?!192\.168(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z\u{00a1}-\u{ffff}0-9]+-?)*[a-z\u{00a1}-\u{ffff}0-9]+)(?:\.(?:[a-z\u{00a1}-\u{ffff}0-9]+-?)*[a-z\u{00a1}-\u{ffff}0-9]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu, YI = /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i, XI = /^(?:\/(?:[^~/]|~0|~1)*)*$/, QI = /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i, eO = /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/, tO = (r) => {
  if (r[0] === '"')
    return !1;
  const [e, t, ...n] = r.split("@");
  return !e || !t || n.length !== 0 || e.length > 64 || t.length > 253 || e[0] === "." || e.endsWith(".") || e.includes("..") || !/^[a-z0-9.-]+$/i.test(t) || !/^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+$/i.test(e) ? !1 : t.split(".").every((s) => /^[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?$/i.test(s));
}, rO = /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/, nO = /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i, sO = (r) => r.length > 1 && r.length < 80 && (/^P\d+([.,]\d+)?W$/.test(r) || /^P[\dYMDTHS]*(\d[.,]\d+)?[YMDHS]$/.test(r) && /^P([.,\d]+Y)?([.,\d]+M)?([.,\d]+D)?(T([.,\d]+H)?([.,\d]+M)?([.,\d]+S)?)?$/.test(r));
function gr(r) {
  return r.test.bind(r);
}
const Yh = {
  date: p_,
  time: m_.bind(void 0, !1),
  "date-time": oO,
  duration: sO,
  uri: lO,
  "uri-reference": gr(GI),
  "uri-template": gr(WI),
  url: gr(KI),
  email: tO,
  hostname: gr(HI),
  ipv4: gr(rO),
  ipv6: gr(nO),
  regex: hO,
  uuid: gr(YI),
  "json-pointer": gr(XI),
  "json-pointer-uri-fragment": gr(QI),
  "relative-json-pointer": gr(eO)
};
function aO(r) {
  return r % 4 === 0 && (r % 100 !== 0 || r % 400 === 0);
}
function p_(r) {
  const e = r.match(VI);
  if (!e)
    return !1;
  const t = +e[1], n = +e[2], s = +e[3];
  return n >= 1 && n <= 12 && s >= 1 && s <= (n == 2 && aO(t) ? 29 : qI[n]);
}
function m_(r, e) {
  const t = e.match(JI);
  if (!t)
    return !1;
  const n = +t[1], s = +t[2], a = +t[3], i = !!t[5];
  return (n <= 23 && s <= 59 && a <= 59 || n == 23 && s == 59 && a == 60) && (!r || i);
}
const iO = /t|\s/i;
function oO(r) {
  const e = r.split(iO);
  return e.length == 2 && p_(e[0]) && m_(!0, e[1]);
}
const cO = /\/|:/, uO = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
function lO(r) {
  return cO.test(r) && uO.test(r);
}
const dO = /[^\\]\\Z/;
function hO(r) {
  if (dO.test(r))
    return !1;
  try {
    return new RegExp(r, "u"), !0;
  } catch {
    return !1;
  }
}
function fO(r) {
  let e = 0, t = r.length, n = 0, s;
  for (; n < t; )
    e++, s = r.charCodeAt(n++), s >= 55296 && s <= 56319 && n < t && (s = r.charCodeAt(n), (s & 64512) == 56320 && n++);
  return e;
}
function Ze(r, e, t = "2019-09", n = Qr(e), s = !0, a = null, i = "#", o = "#", c = /* @__PURE__ */ Object.create(null)) {
  if (e === !0)
    return { valid: !0, errors: [] };
  if (e === !1)
    return {
      valid: !1,
      errors: [
        {
          instanceLocation: i,
          keyword: "false",
          keywordLocation: i,
          error: "False boolean schema."
        }
      ]
    };
  const u = typeof r;
  let l;
  switch (u) {
    case "boolean":
    case "number":
    case "string":
      l = u;
      break;
    case "object":
      r === null ? l = "null" : Array.isArray(r) ? l = "array" : l = "object";
      break;
    default:
      throw new Error(`Instances of "${u}" type are not supported.`);
  }
  const { $ref: d, $recursiveRef: h, $recursiveAnchor: f, type: p, const: y, enum: m, required: v, not: g, anyOf: w, allOf: T, oneOf: x, if: O, then: R, else: E, format: V, properties: ne, patternProperties: z, additionalProperties: Te, unevaluatedProperties: Oe, minProperties: Z, maxProperties: D, propertyNames: U, dependentRequired: A, dependentSchemas: P, dependencies: N, prefixItems: j, items: M, additionalItems: q, unevaluatedItems: se, contains: Ee, minContains: ae, maxContains: S, minItems: _, maxItems: $, uniqueItems: k, minimum: de, maximum: ge, exclusiveMinimum: Me, exclusiveMaximum: Ue, multipleOf: at, minLength: Yt, maxLength: He, pattern: Jt, __absolute_ref__: Cn, __absolute_recursive_ref__: va } = e, G = [];
  if (f === !0 && a === null && (a = e), h === "#") {
    const pe = a === null ? n[va] : a, oe = `${o}/$recursiveRef`, we = Ze(r, a === null ? e : a, t, n, s, pe, i, oe, c);
    we.valid || G.push({
      instanceLocation: i,
      keyword: "$recursiveRef",
      keywordLocation: oe,
      error: "A subschema had errors."
    }, ...we.errors);
  }
  if (d !== void 0) {
    const oe = n[Cn || d];
    if (oe === void 0) {
      let J = `Unresolved $ref "${d}".`;
      throw Cn && Cn !== d && (J += `  Absolute URI "${Cn}".`), J += `
Known schemas:
- ${Object.keys(n).join(`
- `)}`, new Error(J);
    }
    const we = `${o}/$ref`, X = Ze(r, oe, t, n, s, a, i, we, c);
    if (X.valid || G.push({
      instanceLocation: i,
      keyword: "$ref",
      keywordLocation: we,
      error: "A subschema had errors."
    }, ...X.errors), t === "4" || t === "7")
      return { valid: G.length === 0, errors: G };
  }
  if (Array.isArray(p)) {
    let pe = p.length, oe = !1;
    for (let we = 0; we < pe; we++)
      if (l === p[we] || p[we] === "integer" && l === "number" && r % 1 === 0 && r === r) {
        oe = !0;
        break;
      }
    oe || G.push({
      instanceLocation: i,
      keyword: "type",
      keywordLocation: `${o}/type`,
      error: `Instance type "${l}" is invalid. Expected "${p.join('", "')}".`
    });
  } else p === "integer" ? (l !== "number" || r % 1 || r !== r) && G.push({
    instanceLocation: i,
    keyword: "type",
    keywordLocation: `${o}/type`,
    error: `Instance type "${l}" is invalid. Expected "${p}".`
  }) : p !== void 0 && l !== p && G.push({
    instanceLocation: i,
    keyword: "type",
    keywordLocation: `${o}/type`,
    error: `Instance type "${l}" is invalid. Expected "${p}".`
  });
  if (y !== void 0 && (l === "object" || l === "array" ? Tn(r, y) || G.push({
    instanceLocation: i,
    keyword: "const",
    keywordLocation: `${o}/const`,
    error: `Instance does not match ${JSON.stringify(y)}.`
  }) : r !== y && G.push({
    instanceLocation: i,
    keyword: "const",
    keywordLocation: `${o}/const`,
    error: `Instance does not match ${JSON.stringify(y)}.`
  })), m !== void 0 && (l === "object" || l === "array" ? m.some((pe) => Tn(r, pe)) || G.push({
    instanceLocation: i,
    keyword: "enum",
    keywordLocation: `${o}/enum`,
    error: `Instance does not match any of ${JSON.stringify(m)}.`
  }) : m.some((pe) => r === pe) || G.push({
    instanceLocation: i,
    keyword: "enum",
    keywordLocation: `${o}/enum`,
    error: `Instance does not match any of ${JSON.stringify(m)}.`
  })), g !== void 0) {
    const pe = `${o}/not`;
    Ze(r, g, t, n, s, a, i, pe).valid && G.push({
      instanceLocation: i,
      keyword: "not",
      keywordLocation: pe,
      error: 'Instance matched "not" schema.'
    });
  }
  let hn = [];
  if (w !== void 0) {
    const pe = `${o}/anyOf`, oe = G.length;
    let we = !1;
    for (let X = 0; X < w.length; X++) {
      const J = w[X], _e = Object.create(c), me = Ze(r, J, t, n, s, f === !0 ? a : null, i, `${pe}/${X}`, _e);
      G.push(...me.errors), we = we || me.valid, me.valid && hn.push(_e);
    }
    we ? G.length = oe : G.splice(oe, 0, {
      instanceLocation: i,
      keyword: "anyOf",
      keywordLocation: pe,
      error: "Instance does not match any subschemas."
    });
  }
  if (T !== void 0) {
    const pe = `${o}/allOf`, oe = G.length;
    let we = !0;
    for (let X = 0; X < T.length; X++) {
      const J = T[X], _e = Object.create(c), me = Ze(r, J, t, n, s, f === !0 ? a : null, i, `${pe}/${X}`, _e);
      G.push(...me.errors), we = we && me.valid, me.valid && hn.push(_e);
    }
    we ? G.length = oe : G.splice(oe, 0, {
      instanceLocation: i,
      keyword: "allOf",
      keywordLocation: pe,
      error: "Instance does not match every subschema."
    });
  }
  if (x !== void 0) {
    const pe = `${o}/oneOf`, oe = G.length, we = x.filter((X, J) => {
      const _e = Object.create(c), me = Ze(r, X, t, n, s, f === !0 ? a : null, i, `${pe}/${J}`, _e);
      return G.push(...me.errors), me.valid && hn.push(_e), me.valid;
    }).length;
    we === 1 ? G.length = oe : G.splice(oe, 0, {
      instanceLocation: i,
      keyword: "oneOf",
      keywordLocation: pe,
      error: `Instance does not match exactly one subschema (${we} matches).`
    });
  }
  if ((l === "object" || l === "array") && Object.assign(c, ...hn), O !== void 0) {
    const pe = `${o}/if`;
    if (Ze(r, O, t, n, s, a, i, pe, c).valid) {
      if (R !== void 0) {
        const we = Ze(r, R, t, n, s, a, i, `${o}/then`, c);
        we.valid || G.push({
          instanceLocation: i,
          keyword: "if",
          keywordLocation: pe,
          error: 'Instance does not match "then" schema.'
        }, ...we.errors);
      }
    } else if (E !== void 0) {
      const we = Ze(r, E, t, n, s, a, i, `${o}/else`, c);
      we.valid || G.push({
        instanceLocation: i,
        keyword: "if",
        keywordLocation: pe,
        error: 'Instance does not match "else" schema.'
      }, ...we.errors);
    }
  }
  if (l === "object") {
    if (v !== void 0)
      for (const X of v)
        X in r || G.push({
          instanceLocation: i,
          keyword: "required",
          keywordLocation: `${o}/required`,
          error: `Instance does not have required property "${X}".`
        });
    const pe = Object.keys(r);
    if (Z !== void 0 && pe.length < Z && G.push({
      instanceLocation: i,
      keyword: "minProperties",
      keywordLocation: `${o}/minProperties`,
      error: `Instance does not have at least ${Z} properties.`
    }), D !== void 0 && pe.length > D && G.push({
      instanceLocation: i,
      keyword: "maxProperties",
      keywordLocation: `${o}/maxProperties`,
      error: `Instance does not have at least ${D} properties.`
    }), U !== void 0) {
      const X = `${o}/propertyNames`;
      for (const J in r) {
        const _e = `${i}/${ar(J)}`, me = Ze(J, U, t, n, s, a, _e, X);
        me.valid || G.push({
          instanceLocation: i,
          keyword: "propertyNames",
          keywordLocation: X,
          error: `Property name "${J}" does not match schema.`
        }, ...me.errors);
      }
    }
    if (A !== void 0) {
      const X = `${o}/dependantRequired`;
      for (const J in A)
        if (J in r) {
          const _e = A[J];
          for (const me of _e)
            me in r || G.push({
              instanceLocation: i,
              keyword: "dependentRequired",
              keywordLocation: X,
              error: `Instance has "${J}" but does not have "${me}".`
            });
        }
    }
    if (P !== void 0)
      for (const X in P) {
        const J = `${o}/dependentSchemas`;
        if (X in r) {
          const _e = Ze(r, P[X], t, n, s, a, i, `${J}/${ar(X)}`, c);
          _e.valid || G.push({
            instanceLocation: i,
            keyword: "dependentSchemas",
            keywordLocation: J,
            error: `Instance has "${X}" but does not match dependant schema.`
          }, ..._e.errors);
        }
      }
    if (N !== void 0) {
      const X = `${o}/dependencies`;
      for (const J in N)
        if (J in r) {
          const _e = N[J];
          if (Array.isArray(_e))
            for (const me of _e)
              me in r || G.push({
                instanceLocation: i,
                keyword: "dependencies",
                keywordLocation: X,
                error: `Instance has "${J}" but does not have "${me}".`
              });
          else {
            const me = Ze(r, _e, t, n, s, a, i, `${X}/${ar(J)}`);
            me.valid || G.push({
              instanceLocation: i,
              keyword: "dependencies",
              keywordLocation: X,
              error: `Instance has "${J}" but does not match dependant schema.`
            }, ...me.errors);
          }
        }
    }
    const oe = /* @__PURE__ */ Object.create(null);
    let we = !1;
    if (ne !== void 0) {
      const X = `${o}/properties`;
      for (const J in ne) {
        if (!(J in r))
          continue;
        const _e = `${i}/${ar(J)}`, me = Ze(r[J], ne[J], t, n, s, a, _e, `${X}/${ar(J)}`);
        if (me.valid)
          c[J] = oe[J] = !0;
        else if (we = s, G.push({
          instanceLocation: i,
          keyword: "properties",
          keywordLocation: X,
          error: `Property "${J}" does not match schema.`
        }, ...me.errors), we)
          break;
      }
    }
    if (!we && z !== void 0) {
      const X = `${o}/patternProperties`;
      for (const J in z) {
        const _e = new RegExp(J, "u"), me = z[J];
        for (const At in r) {
          if (!_e.test(At))
            continue;
          const Hl = `${i}/${ar(At)}`, Gl = Ze(r[At], me, t, n, s, a, Hl, `${X}/${ar(J)}`);
          Gl.valid ? c[At] = oe[At] = !0 : (we = s, G.push({
            instanceLocation: i,
            keyword: "patternProperties",
            keywordLocation: X,
            error: `Property "${At}" matches pattern "${J}" but does not match associated schema.`
          }, ...Gl.errors));
        }
      }
    }
    if (!we && Te !== void 0) {
      const X = `${o}/additionalProperties`;
      for (const J in r) {
        if (oe[J])
          continue;
        const _e = `${i}/${ar(J)}`, me = Ze(r[J], Te, t, n, s, a, _e, X);
        me.valid ? c[J] = !0 : (we = s, G.push({
          instanceLocation: i,
          keyword: "additionalProperties",
          keywordLocation: X,
          error: `Property "${J}" does not match additional properties schema.`
        }, ...me.errors));
      }
    } else if (!we && Oe !== void 0) {
      const X = `${o}/unevaluatedProperties`;
      for (const J in r)
        if (!c[J]) {
          const _e = `${i}/${ar(J)}`, me = Ze(r[J], Oe, t, n, s, a, _e, X);
          me.valid ? c[J] = !0 : G.push({
            instanceLocation: i,
            keyword: "unevaluatedProperties",
            keywordLocation: X,
            error: `Property "${J}" does not match unevaluated properties schema.`
          }, ...me.errors);
        }
    }
  } else if (l === "array") {
    $ !== void 0 && r.length > $ && G.push({
      instanceLocation: i,
      keyword: "maxItems",
      keywordLocation: `${o}/maxItems`,
      error: `Array has too many items (${r.length} > ${$}).`
    }), _ !== void 0 && r.length < _ && G.push({
      instanceLocation: i,
      keyword: "minItems",
      keywordLocation: `${o}/minItems`,
      error: `Array has too few items (${r.length} < ${_}).`
    });
    const pe = r.length;
    let oe = 0, we = !1;
    if (j !== void 0) {
      const X = `${o}/prefixItems`, J = Math.min(j.length, pe);
      for (; oe < J; oe++) {
        const _e = Ze(r[oe], j[oe], t, n, s, a, `${i}/${oe}`, `${X}/${oe}`);
        if (c[oe] = !0, !_e.valid && (we = s, G.push({
          instanceLocation: i,
          keyword: "prefixItems",
          keywordLocation: X,
          error: "Items did not match schema."
        }, ..._e.errors), we))
          break;
      }
    }
    if (M !== void 0) {
      const X = `${o}/items`;
      if (Array.isArray(M)) {
        const J = Math.min(M.length, pe);
        for (; oe < J; oe++) {
          const _e = Ze(r[oe], M[oe], t, n, s, a, `${i}/${oe}`, `${X}/${oe}`);
          if (c[oe] = !0, !_e.valid && (we = s, G.push({
            instanceLocation: i,
            keyword: "items",
            keywordLocation: X,
            error: "Items did not match schema."
          }, ..._e.errors), we))
            break;
        }
      } else
        for (; oe < pe; oe++) {
          const J = Ze(r[oe], M, t, n, s, a, `${i}/${oe}`, X);
          if (c[oe] = !0, !J.valid && (we = s, G.push({
            instanceLocation: i,
            keyword: "items",
            keywordLocation: X,
            error: "Items did not match schema."
          }, ...J.errors), we))
            break;
        }
      if (!we && q !== void 0) {
        const J = `${o}/additionalItems`;
        for (; oe < pe; oe++) {
          const _e = Ze(r[oe], q, t, n, s, a, `${i}/${oe}`, J);
          c[oe] = !0, _e.valid || (we = s, G.push({
            instanceLocation: i,
            keyword: "additionalItems",
            keywordLocation: J,
            error: "Items did not match additional items schema."
          }, ..._e.errors));
        }
      }
    }
    if (Ee !== void 0)
      if (pe === 0 && ae === void 0)
        G.push({
          instanceLocation: i,
          keyword: "contains",
          keywordLocation: `${o}/contains`,
          error: "Array is empty. It must contain at least one item matching the schema."
        });
      else if (ae !== void 0 && pe < ae)
        G.push({
          instanceLocation: i,
          keyword: "minContains",
          keywordLocation: `${o}/minContains`,
          error: `Array has less items (${pe}) than minContains (${ae}).`
        });
      else {
        const X = `${o}/contains`, J = G.length;
        let _e = 0;
        for (let me = 0; me < pe; me++) {
          const At = Ze(r[me], Ee, t, n, s, a, `${i}/${me}`, X);
          At.valid ? (c[me] = !0, _e++) : G.push(...At.errors);
        }
        _e >= (ae || 0) && (G.length = J), ae === void 0 && S === void 0 && _e === 0 ? G.splice(J, 0, {
          instanceLocation: i,
          keyword: "contains",
          keywordLocation: X,
          error: "Array does not contain item matching schema."
        }) : ae !== void 0 && _e < ae ? G.push({
          instanceLocation: i,
          keyword: "minContains",
          keywordLocation: `${o}/minContains`,
          error: `Array must contain at least ${ae} items matching schema. Only ${_e} items were found.`
        }) : S !== void 0 && _e > S && G.push({
          instanceLocation: i,
          keyword: "maxContains",
          keywordLocation: `${o}/maxContains`,
          error: `Array may contain at most ${S} items matching schema. ${_e} items were found.`
        });
      }
    if (!we && se !== void 0) {
      const X = `${o}/unevaluatedItems`;
      for (oe; oe < pe; oe++) {
        if (c[oe])
          continue;
        const J = Ze(r[oe], se, t, n, s, a, `${i}/${oe}`, X);
        c[oe] = !0, J.valid || G.push({
          instanceLocation: i,
          keyword: "unevaluatedItems",
          keywordLocation: X,
          error: "Items did not match unevaluated items schema."
        }, ...J.errors);
      }
    }
    if (k)
      for (let X = 0; X < pe; X++) {
        const J = r[X], _e = typeof J == "object" && J !== null;
        for (let me = 0; me < pe; me++) {
          if (X === me)
            continue;
          const At = r[me];
          (J === At || _e && (typeof At == "object" && At !== null) && Tn(J, At)) && (G.push({
            instanceLocation: i,
            keyword: "uniqueItems",
            keywordLocation: `${o}/uniqueItems`,
            error: `Duplicate items at indexes ${X} and ${me}.`
          }), X = Number.MAX_SAFE_INTEGER, me = Number.MAX_SAFE_INTEGER);
        }
      }
  } else if (l === "number") {
    if (t === "4" ? (de !== void 0 && (Me === !0 && r <= de || r < de) && G.push({
      instanceLocation: i,
      keyword: "minimum",
      keywordLocation: `${o}/minimum`,
      error: `${r} is less than ${Me ? "or equal to " : ""} ${de}.`
    }), ge !== void 0 && (Ue === !0 && r >= ge || r > ge) && G.push({
      instanceLocation: i,
      keyword: "maximum",
      keywordLocation: `${o}/maximum`,
      error: `${r} is greater than ${Ue ? "or equal to " : ""} ${ge}.`
    })) : (de !== void 0 && r < de && G.push({
      instanceLocation: i,
      keyword: "minimum",
      keywordLocation: `${o}/minimum`,
      error: `${r} is less than ${de}.`
    }), ge !== void 0 && r > ge && G.push({
      instanceLocation: i,
      keyword: "maximum",
      keywordLocation: `${o}/maximum`,
      error: `${r} is greater than ${ge}.`
    }), Me !== void 0 && r <= Me && G.push({
      instanceLocation: i,
      keyword: "exclusiveMinimum",
      keywordLocation: `${o}/exclusiveMinimum`,
      error: `${r} is less than ${Me}.`
    }), Ue !== void 0 && r >= Ue && G.push({
      instanceLocation: i,
      keyword: "exclusiveMaximum",
      keywordLocation: `${o}/exclusiveMaximum`,
      error: `${r} is greater than or equal to ${Ue}.`
    })), at !== void 0) {
      const pe = r % at;
      Math.abs(0 - pe) >= 11920929e-14 && Math.abs(at - pe) >= 11920929e-14 && G.push({
        instanceLocation: i,
        keyword: "multipleOf",
        keywordLocation: `${o}/multipleOf`,
        error: `${r} is not a multiple of ${at}.`
      });
    }
  } else if (l === "string") {
    const pe = Yt === void 0 && He === void 0 ? 0 : fO(r);
    Yt !== void 0 && pe < Yt && G.push({
      instanceLocation: i,
      keyword: "minLength",
      keywordLocation: `${o}/minLength`,
      error: `String is too short (${pe} < ${Yt}).`
    }), He !== void 0 && pe > He && G.push({
      instanceLocation: i,
      keyword: "maxLength",
      keywordLocation: `${o}/maxLength`,
      error: `String is too long (${pe} > ${He}).`
    }), Jt !== void 0 && !new RegExp(Jt, "u").test(r) && G.push({
      instanceLocation: i,
      keyword: "pattern",
      keywordLocation: `${o}/pattern`,
      error: "String does not match pattern."
    }), V !== void 0 && Yh[V] && !Yh[V](r) && G.push({
      instanceLocation: i,
      keyword: "format",
      keywordLocation: `${o}/format`,
      error: `String does not match format "${V}".`
    });
  }
  return { valid: G.length === 0, errors: G };
}
class pO {
  constructor(e, t = "2019-09", n = !0) {
    b(this, "schema");
    b(this, "draft");
    b(this, "shortCircuit");
    b(this, "lookup");
    this.schema = e, this.draft = t, this.shortCircuit = n, this.lookup = Qr(e);
  }
  validate(e) {
    return Ze(e, this.schema, this.draft, this.lookup, this.shortCircuit);
  }
  addSchema(e, t) {
    t && (e = { ...e, $id: t }), Qr(e, this.lookup);
  }
}
var mO = {};
Ae(mO, {
  Validator: () => pO,
  deepCompareStrict: () => Tn,
  toJsonSchema: () => Sr,
  validatesOnlyStrings: () => zs
});
function Sr(r) {
  if (qe(r)) {
    const e = n_(r, !0);
    if (xr(e)) {
      const t = Ni(e, !0);
      return Ri(t);
    } else return Ri(r);
  }
  return st(r) ? jI(r) : r;
}
function zs(r) {
  if (!r || typeof r != "object" || Object.keys(r).length === 0 || Array.isArray(r)) return !1;
  if ("type" in r)
    return typeof r.type == "string" ? r.type === "string" : Array.isArray(r.type) ? r.type.every((e) => e === "string") : !1;
  if ("enum" in r) return Array.isArray(r.enum) && r.enum.length > 0 && r.enum.every((e) => typeof e == "string");
  if ("const" in r) return typeof r.const == "string";
  if ("allOf" in r && Array.isArray(r.allOf)) return r.allOf.some((e) => zs(e));
  if ("anyOf" in r && Array.isArray(r.anyOf) || "oneOf" in r && Array.isArray(r.oneOf)) {
    const e = "anyOf" in r ? r.anyOf : r.oneOf;
    return e.length > 0 && e.every((t) => zs(t));
  }
  if ("not" in r) return !1;
  if ("$ref" in r && typeof r.$ref == "string") {
    const e = r.$ref, t = Qr(r);
    return t[e] ? zs(t[e]) : !1;
  }
  return !1;
}
var gO = {};
Ae(gO, { Graph: () => Rl });
function _O(r, e) {
  if (r !== void 0 && !oi(r)) return r;
  if (bl(e)) try {
    let t = e.getName();
    return t = t.startsWith("Runnable") ? t.slice(8) : t, t;
  } catch {
    return e.getName();
  }
  else return e.name ?? "UnknownSchema";
}
function yO(r) {
  return bl(r.data) ? {
    type: "runnable",
    data: {
      id: r.data.lc_id,
      name: r.data.getName()
    }
  } : {
    type: "schema",
    data: {
      ...Sr(r.data.schema),
      title: r.data.name
    }
  };
}
var Rl = class g_ {
  constructor(e) {
    b(this, "nodes", {});
    b(this, "edges", []);
    this.nodes = (e == null ? void 0 : e.nodes) ?? this.nodes, this.edges = (e == null ? void 0 : e.edges) ?? this.edges;
  }
  toJSON() {
    const e = {};
    return Object.values(this.nodes).forEach((t, n) => {
      e[t.id] = oi(t.id) ? n : t.id;
    }), {
      nodes: Object.values(this.nodes).map((t) => ({
        id: e[t.id],
        ...yO(t)
      })),
      edges: this.edges.map((t) => {
        const n = {
          source: e[t.source],
          target: e[t.target]
        };
        return typeof t.data < "u" && (n.data = t.data), typeof t.conditional < "u" && (n.conditional = t.conditional), n;
      })
    };
  }
  addNode(e, t, n) {
    if (t !== void 0 && this.nodes[t] !== void 0) throw new Error(`Node with id ${t} already exists`);
    const s = t ?? Lr(), a = {
      id: s,
      data: e,
      name: _O(t, e),
      metadata: n
    };
    return this.nodes[s] = a, a;
  }
  removeNode(e) {
    delete this.nodes[e.id], this.edges = this.edges.filter((t) => t.source !== e.id && t.target !== e.id);
  }
  addEdge(e, t, n, s) {
    if (this.nodes[e.id] === void 0) throw new Error(`Source node ${e.id} not in graph`);
    if (this.nodes[t.id] === void 0) throw new Error(`Target node ${t.id} not in graph`);
    const a = {
      source: e.id,
      target: t.id,
      data: n,
      conditional: s
    };
    return this.edges.push(a), a;
  }
  firstNode() {
    return Xh(this);
  }
  lastNode() {
    return Qh(this);
  }
  /**
  * Add all nodes and edges from another graph.
  * Note this doesn't check for duplicates, nor does it connect the graphs.
  */
  extend(e, t = "") {
    let n = t;
    Object.values(e.nodes).map((u) => u.id).every(oi) && (n = "");
    const a = (u) => n ? `${n}:${u}` : u;
    Object.entries(e.nodes).forEach(([u, l]) => {
      this.nodes[a(u)] = {
        ...l,
        id: a(u)
      };
    });
    const i = e.edges.map((u) => ({
      ...u,
      source: a(u.source),
      target: a(u.target)
    }));
    this.edges = [...this.edges, ...i];
    const o = e.firstNode(), c = e.lastNode();
    return [o ? {
      id: a(o.id),
      data: o.data
    } : void 0, c ? {
      id: a(c.id),
      data: c.data
    } : void 0];
  }
  trimFirstNode() {
    const e = this.firstNode();
    e && Xh(this, [e.id]) && this.removeNode(e);
  }
  trimLastNode() {
    const e = this.lastNode();
    e && Qh(this, [e.id]) && this.removeNode(e);
  }
  /**
  * Return a new graph with all nodes re-identified,
  * using their unique, readable names where possible.
  */
  reid() {
    const e = Object.fromEntries(Object.values(this.nodes).map((s) => [s.id, s.name])), t = /* @__PURE__ */ new Map();
    Object.values(e).forEach((s) => {
      t.set(s, (t.get(s) || 0) + 1);
    });
    const n = (s) => {
      const a = e[s];
      return oi(s) && t.get(a) === 1 ? a : s;
    };
    return new g_({
      nodes: Object.fromEntries(Object.entries(this.nodes).map(([s, a]) => [n(s), {
        ...a,
        id: n(s)
      }])),
      edges: this.edges.map((s) => ({
        ...s,
        source: n(s.source),
        target: n(s.target)
      }))
    });
  }
  drawMermaid(e) {
    const { withStyles: t, curveStyle: n, nodeColors: s = {
      default: "fill:#f2f0ff,line-height:1.2",
      first: "fill-opacity:0",
      last: "fill:#bfb6fc"
    }, wrapLabelNWords: a } = e ?? {}, i = this.reid(), o = i.firstNode(), c = i.lastNode();
    return kk(i.nodes, i.edges, {
      firstNode: o == null ? void 0 : o.id,
      lastNode: c == null ? void 0 : c.id,
      withStyles: t,
      curveStyle: n,
      nodeColors: s,
      wrapLabelNWords: a
    });
  }
  async drawMermaidPng(e) {
    const t = this.drawMermaid(e);
    return Ik(t, { backgroundColor: e == null ? void 0 : e.backgroundColor });
  }
};
function Xh(r, e = []) {
  const t = new Set(r.edges.filter((s) => !e.includes(s.source)).map((s) => s.target)), n = [];
  for (const s of Object.values(r.nodes)) !e.includes(s.id) && !t.has(s.id) && n.push(s);
  return n.length === 1 ? n[0] : void 0;
}
function Qh(r, e = []) {
  const t = new Set(r.edges.filter((s) => !e.includes(s.target)).map((s) => s.source)), n = [];
  for (const s of Object.values(r.nodes)) !e.includes(s.id) && !t.has(s.id) && n.push(s);
  return n.length === 1 ? n[0] : void 0;
}
function wO(r) {
  const e = new TextEncoder(), t = new ReadableStream({ async start(n) {
    for await (const s of r) n.enqueue(e.encode(`event: data
data: ${JSON.stringify(s)}

`));
    n.enqueue(e.encode(`event: end

`)), n.close();
  } });
  return dr.fromReadableStream(t);
}
function ef(r) {
  return typeof r == "object" && r !== null && typeof r[Symbol.iterator] == "function" && typeof r.next == "function";
}
const vO = (r) => r != null && typeof r == "object" && "next" in r && typeof r.next == "function";
function lu(r) {
  return typeof r == "object" && r !== null && typeof r[Symbol.asyncIterator] == "function";
}
function* tf(r, e) {
  for (; ; ) {
    const { value: t, done: n } = lr.runWithConfig(Ur(r), e.next.bind(e), !0);
    if (n) break;
    yield t;
  }
}
async function* du(r, e) {
  const t = e[Symbol.asyncIterator]();
  for (; ; ) {
    const { value: n, done: s } = await lr.runWithConfig(Ur(r), t.next.bind(e), !0);
    if (s) break;
    yield n;
  }
}
function ut(r, e) {
  return r && !Array.isArray(r) && !(r instanceof Date) && typeof r == "object" ? r : { [e]: r };
}
var Qe = class extends Yn {
  constructor() {
    super(...arguments);
    b(this, "lc_runnable", !0);
    b(this, "name");
  }
  getName(e) {
    const t = this.name ?? this.constructor.lc_name() ?? this.constructor.name;
    return e ? `${t}${e}` : t;
  }
  /**
  * Add retry logic to an existing runnable.
  * @param fields.stopAfterAttempt The number of attempts to retry.
  * @param fields.onFailedAttempt A function that is called when a retry fails.
  * @returns A new RunnableRetry that, when invoked, will retry according to the parameters.
  */
  withRetry(e) {
    return new Nl({
      bound: this,
      kwargs: {},
      config: {},
      maxAttemptNumber: e == null ? void 0 : e.stopAfterAttempt,
      ...e
    });
  }
  /**
  * Bind config to a Runnable, returning a new Runnable.
  * @param config New configuration parameters to attach to the new runnable.
  * @returns A new RunnableBinding with a config matching what's passed.
  */
  withConfig(e) {
    return new is({
      bound: this,
      config: e,
      kwargs: {}
    });
  }
  /**
  * Create a new runnable from the current one that will try invoking
  * other passed fallback runnables if the initial invocation fails.
  * @param fields.fallbacks Other runnables to call if the runnable errors.
  * @returns A new RunnableWithFallbacks.
  */
  withFallbacks(e) {
    const t = Array.isArray(e) ? e : e.fallbacks;
    return new S_({
      runnable: this,
      fallbacks: t
    });
  }
  _getOptionsList(e, t = 0) {
    if (Array.isArray(e) && e.length !== t) throw new Error(`Passed "options" must be an array with the same length as the inputs, but got ${e.length} options for ${t} inputs`);
    if (Array.isArray(e)) return e.map(Ce);
    if (t > 1 && !Array.isArray(e) && e.runId) {
      console.warn("Provided runId will be used only for the first element of the batch.");
      const n = Object.fromEntries(Object.entries(e).filter(([s]) => s !== "runId"));
      return Array.from({ length: t }, (s, a) => Ce(a === 0 ? e : n));
    }
    return Array.from({ length: t }, () => Ce(e));
  }
  async batch(e, t, n) {
    var c;
    const s = this._getOptionsList(t ?? {}, e.length), a = ((c = s[0]) == null ? void 0 : c.maxConcurrency) ?? (n == null ? void 0 : n.maxConcurrency), i = new pa({
      maxConcurrency: a,
      onFailedAttempt: (u) => {
        throw u;
      }
    }), o = e.map((u, l) => i.call(async () => {
      try {
        return await this.invoke(u, s[l]);
      } catch (d) {
        if (n != null && n.returnExceptions) return d;
        throw d;
      }
    }));
    return Promise.all(o);
  }
  /**
  * Default streaming implementation.
  * Subclasses should override this method if they support streaming output.
  * @param input
  * @param options
  */
  async *_streamIterator(e, t) {
    yield this.invoke(e, t);
  }
  /**
  * Stream output in chunks.
  * @param input
  * @param options
  * @returns A readable stream that is also an iterable.
  */
  async stream(e, t) {
    const n = Ce(t), s = new On({
      generator: this._streamIterator(e, n),
      config: n
    });
    return await s.setup, dr.fromAsyncGenerator(s);
  }
  _separateRunnableConfigFromCallOptions(e) {
    let t;
    e === void 0 ? t = Ce(e) : t = Ce({
      callbacks: e.callbacks,
      tags: e.tags,
      metadata: e.metadata,
      runName: e.runName,
      configurable: e.configurable,
      recursionLimit: e.recursionLimit,
      maxConcurrency: e.maxConcurrency,
      runId: e.runId,
      timeout: e.timeout,
      signal: e.signal
    });
    const n = { ...e };
    return delete n.callbacks, delete n.tags, delete n.metadata, delete n.runName, delete n.configurable, delete n.recursionLimit, delete n.maxConcurrency, delete n.runId, delete n.timeout, delete n.signal, [t, n];
  }
  async _callWithConfig(e, t, n) {
    const s = Ce(n), a = await Zt(s), i = await (a == null ? void 0 : a.handleChainStart(this.toJSON(), ut(t, "input"), s.runId, s == null ? void 0 : s.runType, void 0, void 0, (s == null ? void 0 : s.runName) ?? this.getName()));
    delete s.runId;
    let o;
    try {
      const c = e.call(this, t, s, i);
      o = await zr(c, n == null ? void 0 : n.signal);
    } catch (c) {
      throw await (i == null ? void 0 : i.handleChainError(c)), c;
    }
    return await (i == null ? void 0 : i.handleChainEnd(ut(o, "output"))), o;
  }
  /**
  * Internal method that handles batching and configuration for a runnable
  * It takes a function, input values, and optional configuration, and
  * returns a promise that resolves to the output values.
  * @param func The function to be executed for each input value.
  * @param input The input values to be processed.
  * @param config Optional configuration for the function execution.
  * @returns A promise that resolves to the output values.
  */
  async _batchWithConfig(e, t, n, s) {
    var u;
    const a = this._getOptionsList(n ?? {}, t.length), i = await Promise.all(a.map(Zt)), o = await Promise.all(i.map(async (l, d) => {
      const h = await (l == null ? void 0 : l.handleChainStart(this.toJSON(), ut(t[d], "input"), a[d].runId, a[d].runType, void 0, void 0, a[d].runName ?? this.getName()));
      return delete a[d].runId, h;
    }));
    let c;
    try {
      const l = e.call(this, t, a, o, s);
      c = await zr(l, (u = a == null ? void 0 : a[0]) == null ? void 0 : u.signal);
    } catch (l) {
      throw await Promise.all(o.map((d) => d == null ? void 0 : d.handleChainError(l))), l;
    }
    return await Promise.all(o.map((l) => l == null ? void 0 : l.handleChainEnd(ut(c, "output")))), c;
  }
  /** @internal */
  _concatOutputChunks(e, t) {
    return an(e, t);
  }
  /**
  * Helper method to transform an Iterator of Input values into an Iterator of
  * Output values, with callbacks.
  * Use this to implement `stream()` or `transform()` in Runnable subclasses.
  */
  async *_transformStreamWithConfig(e, t, n) {
    let s, a = !0, i, o = !0;
    const c = Ce(n), u = await Zt(c), l = this;
    async function* d() {
      for await (const f of e) {
        if (a) if (s === void 0) s = f;
        else try {
          s = l._concatOutputChunks(s, f);
        } catch {
          s = void 0, a = !1;
        }
        yield f;
      }
    }
    let h;
    try {
      const f = await _g(t.bind(this), d(), async () => u == null ? void 0 : u.handleChainStart(this.toJSON(), { input: "" }, c.runId, c.runType, void 0, void 0, c.runName ?? this.getName()), n == null ? void 0 : n.signal, c);
      delete c.runId, h = f.setup;
      const p = h == null ? void 0 : h.handlers.find(iT);
      let y = f.output;
      p !== void 0 && h !== void 0 && (y = p.tapOutputIterable(h.runId, y));
      const m = h == null ? void 0 : h.handlers.find(bg);
      m !== void 0 && h !== void 0 && (y = m.tapOutputIterable(h.runId, y));
      for await (const v of y)
        if (yield v, o) if (i === void 0) i = v;
        else try {
          i = this._concatOutputChunks(i, v);
        } catch {
          i = void 0, o = !1;
        }
    } catch (f) {
      throw await (h == null ? void 0 : h.handleChainError(f, void 0, void 0, void 0, { inputs: ut(s, "input") })), f;
    }
    await (h == null ? void 0 : h.handleChainEnd(i ?? {}, void 0, void 0, void 0, { inputs: ut(s, "input") }));
  }
  getGraph(e) {
    const t = new Rl(), n = t.addNode({
      name: `${this.getName()}Input`,
      schema: Gh()
    }), s = t.addNode(this), a = t.addNode({
      name: `${this.getName()}Output`,
      schema: Gh()
    });
    return t.addEdge(n, s), t.addEdge(s, a), t;
  }
  /**
  * Create a new runnable sequence that runs each individual runnable in series,
  * piping the output of one runnable into another runnable or runnable-like.
  * @param coerceable A runnable, function, or object whose values are functions or runnables.
  * @returns A new runnable sequence.
  */
  pipe(e) {
    return new ma({
      first: this,
      last: ur(e)
    });
  }
  /**
  * Pick keys from the dict output of this runnable. Returns a new runnable.
  */
  pick(e) {
    return this.pipe(new T_(e));
  }
  /**
  * Assigns new fields to the dict output of this runnable. Returns a new runnable.
  */
  assign(e) {
    return this.pipe(new Pl(new fs({ steps: e })));
  }
  /**
  * Default implementation of transform, which buffers input and then calls stream.
  * Subclasses should override this method if they can start producing output while
  * input is still being generated.
  * @param generator
  * @param options
  */
  async *transform(e, t) {
    let n;
    for await (const s of e) n === void 0 ? n = s : n = this._concatOutputChunks(n, s);
    yield* this._streamIterator(n, Ce(t));
  }
  /**
  * Stream all output from a runnable, as reported to the callback system.
  * This includes all inner runs of LLMs, Retrievers, Tools, etc.
  * Output is streamed as Log objects, which include a list of
  * jsonpatch ops that describe how the state of the run has changed in each
  * step, and the final state of the run.
  * The jsonpatch ops can be applied in order to construct state.
  * @param input
  * @param options
  * @param streamOptions
  */
  async *streamLog(e, t, n) {
    const s = new Wc({
      ...n,
      autoClose: !1,
      _schemaFormat: "original"
    }), a = Ce(t);
    yield* this._streamLog(e, s, a);
  }
  async *_streamLog(e, t, n) {
    const { callbacks: s } = n;
    if (s === void 0) n.callbacks = [t];
    else if (Array.isArray(s)) n.callbacks = s.concat([t]);
    else {
      const c = s.copy();
      c.addHandler(t, !0), n.callbacks = c;
    }
    const a = this.stream(e, n);
    async function i() {
      try {
        const c = await a;
        for await (const u of c) {
          const l = new Mr({ ops: [{
            op: "add",
            path: "/streamed_output/-",
            value: u
          }] });
          await t.writer.write(l);
        }
      } finally {
        await t.writer.close();
      }
    }
    const o = i();
    try {
      for await (const c of t) yield c;
    } finally {
      await o;
    }
  }
  streamEvents(e, t, n) {
    let s;
    if (t.version === "v1") s = this._streamEventsV1(e, t, n);
    else if (t.version === "v2") s = this._streamEventsV2(e, t, n);
    else throw new Error('Only versions "v1" and "v2" of the schema are currently supported.');
    return t.encoding === "text/event-stream" ? wO(s) : dr.fromAsyncGenerator(s);
  }
  async *_streamEventsV2(e, t, n) {
    var p;
    const s = new oT({
      ...n,
      autoClose: !1
    }), a = Ce(t), i = a.runId ?? Lr();
    a.runId = i;
    const o = a.callbacks;
    if (o === void 0) a.callbacks = [s];
    else if (Array.isArray(o)) a.callbacks = o.concat(s);
    else {
      const y = o.copy();
      y.addHandler(s, !0), a.callbacks = y;
    }
    const c = new AbortController(), u = this;
    async function l() {
      let y, m = null;
      try {
        t != null && t.signal ? "any" in AbortSignal ? y = AbortSignal.any([c.signal, t.signal]) : (y = t.signal, m = () => {
          c.abort();
        }, t.signal.addEventListener("abort", m, { once: !0 })) : y = c.signal;
        const v = await u.stream(e, {
          ...a,
          signal: y
        }), g = s.tapOutputIterable(i, v);
        for await (const w of g) if (c.signal.aborted) break;
      } finally {
        await s.finish(), y && m && y.removeEventListener("abort", m);
      }
    }
    const d = l();
    let h = !1, f;
    try {
      for await (const y of s) {
        if (!h) {
          y.data.input = e, h = !0, f = y.run_id, yield y;
          continue;
        }
        y.run_id === f && y.event.endsWith("_end") && (p = y.data) != null && p.input && delete y.data.input, yield y;
      }
    } finally {
      c.abort(), await d;
    }
  }
  async *_streamEventsV1(e, t, n) {
    let s, a = !1;
    const i = Ce(t), o = i.tags ?? [], c = i.metadata ?? {}, u = i.runName ?? this.getName(), l = new Wc({
      ...n,
      autoClose: !1,
      _schemaFormat: "streaming_events"
    }), d = new wT({ ...n }), h = this._streamLog(e, l, i);
    for await (const p of h) {
      if (s ? s = s.concat(p) : s = vl.fromRunLogPatch(p), s.state === void 0) throw new Error('Internal error: "streamEvents" state is missing. Please open a bug report.');
      if (!a) {
        a = !0;
        const g = { ...s.state }, w = {
          run_id: g.id,
          event: `on_${g.type}_start`,
          name: u,
          tags: o,
          metadata: c,
          data: { input: e }
        };
        d.includeEvent(w, g.type) && (yield w);
      }
      const y = p.ops.filter((g) => g.path.startsWith("/logs/")).map((g) => g.path.split("/")[2]), m = [...new Set(y)];
      for (const g of m) {
        let w, T = {};
        const x = s.state.logs[g];
        if (x.end_time === void 0 ? x.streamed_output.length > 0 ? w = "stream" : w = "start" : w = "end", w === "start")
          x.inputs !== void 0 && (T.input = x.inputs);
        else if (w === "end")
          x.inputs !== void 0 && (T.input = x.inputs), T.output = x.final_output;
        else if (w === "stream") {
          const O = x.streamed_output.length;
          if (O !== 1) throw new Error(`Expected exactly one chunk of streamed output, got ${O} instead. Encountered in: "${x.name}"`);
          T = { chunk: x.streamed_output[0] }, x.streamed_output = [];
        }
        yield {
          event: `on_${x.type}_${w}`,
          name: x.name,
          run_id: x.id,
          tags: x.tags,
          metadata: x.metadata,
          data: T
        };
      }
      const { state: v } = s;
      if (v.streamed_output.length > 0) {
        const g = v.streamed_output.length;
        if (g !== 1) throw new Error(`Expected exactly one chunk of streamed output, got ${g} instead. Encountered in: "${v.name}"`);
        const w = { chunk: v.streamed_output[0] };
        v.streamed_output = [];
        const T = {
          event: `on_${v.type}_stream`,
          run_id: v.id,
          tags: o,
          metadata: c,
          name: u,
          data: w
        };
        d.includeEvent(T, v.type) && (yield T);
      }
    }
    const f = s == null ? void 0 : s.state;
    if (f !== void 0) {
      const p = {
        event: `on_${f.type}_end`,
        name: u,
        run_id: f.id,
        tags: o,
        metadata: c,
        data: { output: f.final_output }
      };
      d.includeEvent(p, f.type) && (yield p);
    }
  }
  static isRunnable(e) {
    return bl(e);
  }
  /**
  * Bind lifecycle listeners to a Runnable, returning a new Runnable.
  * The Run object contains information about the run, including its id,
  * type, input, output, error, startTime, endTime, and any tags or metadata
  * added to the run.
  *
  * @param {Object} params - The object containing the callback functions.
  * @param {(run: Run) => void} params.onStart - Called before the runnable starts running, with the Run object.
  * @param {(run: Run) => void} params.onEnd - Called after the runnable finishes running, with the Run object.
  * @param {(run: Run) => void} params.onError - Called if the runnable throws an error, with the Run object.
  */
  withListeners({ onStart: e, onEnd: t, onError: n }) {
    return new is({
      bound: this,
      config: {},
      configFactories: [(s) => ({ callbacks: [new Eg({
        config: s,
        onStart: e,
        onEnd: t,
        onError: n
      })] })]
    });
  }
  /**
  * Convert a runnable to a tool. Return a new instance of `RunnableToolLike`
  * which contains the runnable, name, description and schema.
  *
  * @template {T extends RunInput = RunInput} RunInput - The input type of the runnable. Should be the same as the `RunInput` type of the runnable.
  *
  * @param fields
  * @param {string | undefined} [fields.name] The name of the tool. If not provided, it will default to the name of the runnable.
  * @param {string | undefined} [fields.description] The description of the tool. Falls back to the description on the Zod schema if not provided, or undefined if neither are provided.
  * @param {z.ZodType<T>} [fields.schema] The Zod schema for the input of the tool. Infers the Zod type from the input type of the runnable.
  * @returns {RunnableToolLike<z.ZodType<T>, RunOutput>} An instance of `RunnableToolLike` which is a runnable that can be used as a tool.
  */
  asTool(e) {
    return xO(this, e);
  }
}, is = class __ extends Qe {
  constructor(t) {
    super(t);
    b(this, "lc_namespace", ["langchain_core", "runnables"]);
    b(this, "lc_serializable", !0);
    b(this, "bound");
    b(this, "config");
    b(this, "kwargs");
    b(this, "configFactories");
    this.bound = t.bound, this.kwargs = t.kwargs, this.config = t.config, this.configFactories = t.configFactories;
  }
  static lc_name() {
    return "RunnableBinding";
  }
  getName(t) {
    return this.bound.getName(t);
  }
  async _mergeConfig(...t) {
    const n = ki(this.config, ...t);
    return ki(n, ...this.configFactories ? await Promise.all(this.configFactories.map(async (s) => await s(n))) : []);
  }
  withConfig(t) {
    return new this.constructor({
      bound: this.bound,
      kwargs: this.kwargs,
      config: {
        ...this.config,
        ...t
      }
    });
  }
  withRetry(t) {
    return new Nl({
      bound: this.bound,
      kwargs: this.kwargs,
      config: this.config,
      maxAttemptNumber: t == null ? void 0 : t.stopAfterAttempt,
      ...t
    });
  }
  async invoke(t, n) {
    return this.bound.invoke(t, await this._mergeConfig(n, this.kwargs));
  }
  async batch(t, n, s) {
    const a = Array.isArray(n) ? await Promise.all(n.map(async (i) => this._mergeConfig(Ce(i), this.kwargs))) : await this._mergeConfig(Ce(n), this.kwargs);
    return this.bound.batch(t, a, s);
  }
  /** @internal */
  _concatOutputChunks(t, n) {
    return this.bound._concatOutputChunks(t, n);
  }
  async *_streamIterator(t, n) {
    yield* this.bound._streamIterator(t, await this._mergeConfig(Ce(n), this.kwargs));
  }
  async stream(t, n) {
    return this.bound.stream(t, await this._mergeConfig(Ce(n), this.kwargs));
  }
  async *transform(t, n) {
    yield* this.bound.transform(t, await this._mergeConfig(Ce(n), this.kwargs));
  }
  streamEvents(t, n, s) {
    const a = this, i = async function* () {
      yield* a.bound.streamEvents(t, {
        ...await a._mergeConfig(Ce(n), a.kwargs),
        version: n.version
      }, s);
    };
    return dr.fromAsyncGenerator(i());
  }
  static isRunnableBinding(t) {
    return t.bound && Qe.isRunnable(t.bound);
  }
  /**
  * Bind lifecycle listeners to a Runnable, returning a new Runnable.
  * The Run object contains information about the run, including its id,
  * type, input, output, error, startTime, endTime, and any tags or metadata
  * added to the run.
  *
  * @param {Object} params - The object containing the callback functions.
  * @param {(run: Run) => void} params.onStart - Called before the runnable starts running, with the Run object.
  * @param {(run: Run) => void} params.onEnd - Called after the runnable finishes running, with the Run object.
  * @param {(run: Run) => void} params.onError - Called if the runnable throws an error, with the Run object.
  */
  withListeners({ onStart: t, onEnd: n, onError: s }) {
    return new __({
      bound: this.bound,
      kwargs: this.kwargs,
      config: this.config,
      configFactories: [(a) => ({ callbacks: [new Eg({
        config: a,
        onStart: t,
        onEnd: n,
        onError: s
      })] })]
    });
  }
}, bO = class y_ extends Qe {
  constructor(t) {
    super(t);
    b(this, "lc_serializable", !0);
    b(this, "lc_namespace", ["langchain_core", "runnables"]);
    b(this, "bound");
    this.bound = t.bound;
  }
  static lc_name() {
    return "RunnableEach";
  }
  /**
  * Invokes the runnable with the specified input and configuration.
  * @param input The input to invoke the runnable with.
  * @param config The configuration to invoke the runnable with.
  * @returns A promise that resolves to the output of the runnable.
  */
  async invoke(t, n) {
    return this._callWithConfig(this._invoke.bind(this), t, n);
  }
  /**
  * A helper method that is used to invoke the runnable with the specified input and configuration.
  * @param input The input to invoke the runnable with.
  * @param config The configuration to invoke the runnable with.
  * @returns A promise that resolves to the output of the runnable.
  */
  async _invoke(t, n, s) {
    return this.bound.batch(t, Be(n, { callbacks: s == null ? void 0 : s.getChild() }));
  }
  /**
  * Bind lifecycle listeners to a Runnable, returning a new Runnable.
  * The Run object contains information about the run, including its id,
  * type, input, output, error, startTime, endTime, and any tags or metadata
  * added to the run.
  *
  * @param {Object} params - The object containing the callback functions.
  * @param {(run: Run) => void} params.onStart - Called before the runnable starts running, with the Run object.
  * @param {(run: Run) => void} params.onEnd - Called after the runnable finishes running, with the Run object.
  * @param {(run: Run) => void} params.onError - Called if the runnable throws an error, with the Run object.
  */
  withListeners({ onStart: t, onEnd: n, onError: s }) {
    return new y_({ bound: this.bound.withListeners({
      onStart: t,
      onEnd: n,
      onError: s
    }) });
  }
}, Nl = class extends is {
  constructor(e) {
    super(e);
    b(this, "lc_namespace", ["langchain_core", "runnables"]);
    b(this, "maxAttemptNumber", 3);
    b(this, "onFailedAttempt", () => {
    });
    this.maxAttemptNumber = e.maxAttemptNumber ?? this.maxAttemptNumber, this.onFailedAttempt = e.onFailedAttempt ?? this.onFailedAttempt;
  }
  static lc_name() {
    return "RunnableRetry";
  }
  _patchConfigForRetry(e, t, n) {
    const s = e > 1 ? `retry:attempt:${e}` : void 0;
    return Be(t, { callbacks: n == null ? void 0 : n.getChild(s) });
  }
  async _invoke(e, t, n) {
    return Kc((s) => super.invoke(e, this._patchConfigForRetry(s, t, n)), {
      onFailedAttempt: ({ error: s }) => this.onFailedAttempt(s, e),
      retries: Math.max(this.maxAttemptNumber - 1, 0),
      randomize: !0
    });
  }
  /**
  * Method that invokes the runnable with the specified input, run manager,
  * and config. It handles the retry logic by catching any errors and
  * recursively invoking itself with the updated config for the next retry
  * attempt.
  * @param input The input for the runnable.
  * @param runManager The run manager for the runnable.
  * @param config The config for the runnable.
  * @returns A promise that resolves to the output of the runnable.
  */
  async invoke(e, t) {
    return this._callWithConfig(this._invoke.bind(this), e, t);
  }
  async _batch(e, t, n, s) {
    const a = {};
    try {
      await Kc(async (i) => {
        const o = e.map((h, f) => f).filter((h) => a[h.toString()] === void 0 || a[h.toString()] instanceof Error), c = o.map((h) => e[h]), u = o.map((h) => this._patchConfigForRetry(i, t == null ? void 0 : t[h], n == null ? void 0 : n[h])), l = await super.batch(c, u, {
          ...s,
          returnExceptions: !0
        });
        let d;
        for (let h = 0; h < l.length; h += 1) {
          const f = l[h], p = o[h];
          f instanceof Error && d === void 0 && (d = f, d.input = c[h]), a[p.toString()] = f;
        }
        if (d) throw d;
        return l;
      }, {
        onFailedAttempt: ({ error: i }) => this.onFailedAttempt(i, i.input),
        retries: Math.max(this.maxAttemptNumber - 1, 0),
        randomize: !0
      });
    } catch (i) {
      if ((s == null ? void 0 : s.returnExceptions) !== !0) throw i;
    }
    return Object.keys(a).sort((i, o) => parseInt(i, 10) - parseInt(o, 10)).map((i) => a[parseInt(i, 10)]);
  }
  async batch(e, t, n) {
    return this._batchWithConfig(this._batch.bind(this), e, t, n);
  }
}, ma = class Cs extends Qe {
  constructor(t) {
    super(t);
    b(this, "first");
    b(this, "middle", []);
    b(this, "last");
    b(this, "omitSequenceTags", !1);
    b(this, "lc_serializable", !0);
    b(this, "lc_namespace", ["langchain_core", "runnables"]);
    this.first = t.first, this.middle = t.middle ?? this.middle, this.last = t.last, this.name = t.name, this.omitSequenceTags = t.omitSequenceTags ?? this.omitSequenceTags;
  }
  static lc_name() {
    return "RunnableSequence";
  }
  get steps() {
    return [
      this.first,
      ...this.middle,
      this.last
    ];
  }
  async invoke(t, n) {
    var u;
    const s = Ce(n), a = await Zt(s), i = await (a == null ? void 0 : a.handleChainStart(this.toJSON(), ut(t, "input"), s.runId, void 0, void 0, void 0, s == null ? void 0 : s.runName));
    delete s.runId;
    let o = t, c;
    try {
      const l = [this.first, ...this.middle];
      for (let d = 0; d < l.length; d += 1) {
        const f = l[d].invoke(o, Be(s, { callbacks: i == null ? void 0 : i.getChild(this.omitSequenceTags ? void 0 : `seq:step:${d + 1}`) }));
        o = await zr(f, n == null ? void 0 : n.signal);
      }
      if ((u = n == null ? void 0 : n.signal) != null && u.aborted) throw Ys(n.signal);
      c = await this.last.invoke(o, Be(s, { callbacks: i == null ? void 0 : i.getChild(this.omitSequenceTags ? void 0 : `seq:step:${this.steps.length}`) }));
    } catch (l) {
      throw await (i == null ? void 0 : i.handleChainError(l)), l;
    }
    return await (i == null ? void 0 : i.handleChainEnd(ut(c, "output"))), c;
  }
  async batch(t, n, s) {
    var u;
    const a = this._getOptionsList(n ?? {}, t.length), i = await Promise.all(a.map(Zt)), o = await Promise.all(i.map(async (l, d) => {
      const h = await (l == null ? void 0 : l.handleChainStart(this.toJSON(), ut(t[d], "input"), a[d].runId, void 0, void 0, void 0, a[d].runName));
      return delete a[d].runId, h;
    }));
    let c = t;
    try {
      for (let l = 0; l < this.steps.length; l += 1) {
        const h = this.steps[l].batch(c, o.map((f, p) => {
          const y = f == null ? void 0 : f.getChild(this.omitSequenceTags ? void 0 : `seq:step:${l + 1}`);
          return Be(a[p], { callbacks: y });
        }), s);
        c = await zr(h, (u = a[0]) == null ? void 0 : u.signal);
      }
    } catch (l) {
      throw await Promise.all(o.map((d) => d == null ? void 0 : d.handleChainError(l))), l;
    }
    return await Promise.all(o.map((l) => l == null ? void 0 : l.handleChainEnd(ut(c, "output")))), c;
  }
  /** @internal */
  _concatOutputChunks(t, n) {
    return this.last._concatOutputChunks(t, n);
  }
  async *_streamIterator(t, n) {
    var h;
    const s = await Zt(n), { runId: a, ...i } = n ?? {}, o = await (s == null ? void 0 : s.handleChainStart(this.toJSON(), ut(t, "input"), a, void 0, void 0, void 0, i == null ? void 0 : i.runName)), c = [
      this.first,
      ...this.middle,
      this.last
    ];
    let u = !0, l;
    async function* d() {
      yield t;
    }
    try {
      let f = c[0].transform(d(), Be(i, { callbacks: o == null ? void 0 : o.getChild(this.omitSequenceTags ? void 0 : "seq:step:1") }));
      for (let p = 1; p < c.length; p += 1)
        f = await c[p].transform(f, Be(i, { callbacks: o == null ? void 0 : o.getChild(this.omitSequenceTags ? void 0 : `seq:step:${p + 1}`) }));
      for await (const p of f)
        if ((h = n == null ? void 0 : n.signal) == null || h.throwIfAborted(), yield p, u) if (l === void 0) l = p;
        else try {
          l = this._concatOutputChunks(l, p);
        } catch {
          l = void 0, u = !1;
        }
    } catch (f) {
      throw await (o == null ? void 0 : o.handleChainError(f)), f;
    }
    await (o == null ? void 0 : o.handleChainEnd(ut(l, "output")));
  }
  getGraph(t) {
    const n = new Rl();
    let s = null;
    return this.steps.forEach((a, i) => {
      const o = a.getGraph(t);
      i !== 0 && o.trimFirstNode(), i !== this.steps.length - 1 && o.trimLastNode(), n.extend(o);
      const c = o.firstNode();
      if (!c) throw new Error(`Runnable ${a} has no first node`);
      s && n.addEdge(s, c), s = o.lastNode();
    }), n;
  }
  pipe(t) {
    return Cs.isRunnableSequence(t) ? new Cs({
      first: this.first,
      middle: this.middle.concat([
        this.last,
        t.first,
        ...t.middle
      ]),
      last: t.last,
      name: this.name ?? t.name
    }) : new Cs({
      first: this.first,
      middle: [...this.middle, this.last],
      last: ur(t),
      name: this.name
    });
  }
  static isRunnableSequence(t) {
    return Array.isArray(t.middle) && Qe.isRunnable(t);
  }
  static from([t, ...n], s) {
    let a = {};
    return typeof s == "string" ? a.name = s : s !== void 0 && (a = s), new Cs({
      ...a,
      first: ur(t),
      middle: n.slice(0, -1).map(ur),
      last: ur(n[n.length - 1])
    });
  }
}, fs = class w_ extends Qe {
  constructor(t) {
    super(t);
    b(this, "lc_namespace", ["langchain_core", "runnables"]);
    b(this, "lc_serializable", !0);
    b(this, "steps");
    this.steps = {};
    for (const [n, s] of Object.entries(t.steps)) this.steps[n] = ur(s);
  }
  static lc_name() {
    return "RunnableMap";
  }
  getStepsKeys() {
    return Object.keys(this.steps);
  }
  static from(t) {
    return new w_({ steps: t });
  }
  async invoke(t, n) {
    const s = Ce(n), a = await Zt(s), i = await (a == null ? void 0 : a.handleChainStart(this.toJSON(), { input: t }, s.runId, void 0, void 0, void 0, s == null ? void 0 : s.runName));
    delete s.runId;
    const o = {};
    try {
      const c = Object.entries(this.steps).map(async ([u, l]) => {
        o[u] = await l.invoke(t, Be(s, { callbacks: i == null ? void 0 : i.getChild(`map:key:${u}`) }));
      });
      await zr(Promise.all(c), n == null ? void 0 : n.signal);
    } catch (c) {
      throw await (i == null ? void 0 : i.handleChainError(c)), c;
    }
    return await (i == null ? void 0 : i.handleChainEnd(o)), o;
  }
  async *_transform(t, n, s) {
    const a = { ...this.steps }, i = yl(t, Object.keys(a).length), o = new Map(Object.entries(a).map(([c, u], l) => {
      const d = u.transform(i[l], Be(s, { callbacks: n == null ? void 0 : n.getChild(`map:key:${c}`) }));
      return [c, d.next().then((h) => ({
        key: c,
        gen: d,
        result: h
      }))];
    }));
    for (; o.size; ) {
      const c = Promise.race(o.values()), { key: u, result: l, gen: d } = await zr(c, s == null ? void 0 : s.signal);
      o.delete(u), l.done || (yield { [u]: l.value }, o.set(u, d.next().then((h) => ({
        key: u,
        gen: d,
        result: h
      }))));
    }
  }
  transform(t, n) {
    return this._transformStreamWithConfig(t, this._transform.bind(this), n);
  }
  async stream(t, n) {
    async function* s() {
      yield t;
    }
    const a = Ce(n), i = new On({
      generator: this.transform(s(), a),
      config: a
    });
    return await i.setup, dr.fromAsyncGenerator(i);
  }
}, SO = class v_ extends Qe {
  constructor(t) {
    super(t);
    b(this, "lc_serializable", !1);
    b(this, "lc_namespace", ["langchain_core", "runnables"]);
    b(this, "func");
    if (!_l(t.func)) throw new Error("RunnableTraceable requires a function that is wrapped in traceable higher-order function");
    this.func = t.func;
  }
  async invoke(t, n) {
    const [s] = this._getOptionsList(n ?? {}, 1), a = await Zt(s), i = this.func(Be(s, { callbacks: a }), t);
    return zr(i, s == null ? void 0 : s.signal);
  }
  async *_streamIterator(t, n) {
    var i, o;
    const [s] = this._getOptionsList(n ?? {}, 1), a = await this.invoke(t, n);
    if (lu(a)) {
      for await (const c of a)
        (i = s == null ? void 0 : s.signal) == null || i.throwIfAborted(), yield c;
      return;
    }
    if (vO(a)) {
      for (; ; ) {
        (o = s == null ? void 0 : s.signal) == null || o.throwIfAborted();
        const c = a.next();
        if (c.done) break;
        yield c.value;
      }
      return;
    }
    yield a;
  }
  static from(t) {
    return new v_({ func: t });
  }
};
function TO(r) {
  if (_l(r)) throw new Error("RunnableLambda requires a function that is not wrapped in traceable higher-order function. This shouldn't happen.");
}
var qr = class b_ extends Qe {
  constructor(t) {
    if (_l(t.func)) return SO.from(t.func);
    super(t);
    b(this, "lc_namespace", ["langchain_core", "runnables"]);
    b(this, "func");
    TO(t.func), this.func = t.func;
  }
  static lc_name() {
    return "RunnableLambda";
  }
  static from(t) {
    return new b_({ func: t });
  }
  async _invoke(t, n, s) {
    return new Promise((a, i) => {
      const o = Be(n, {
        callbacks: s == null ? void 0 : s.getChild(),
        recursionLimit: ((n == null ? void 0 : n.recursionLimit) ?? cc) - 1
      });
      lr.runWithConfig(Ur(o), async () => {
        var c, u;
        try {
          let l = await this.func(t, { ...o });
          if (l && Qe.isRunnable(l)) {
            if ((n == null ? void 0 : n.recursionLimit) === 0) throw new Error("Recursion limit reached.");
            l = await l.invoke(t, {
              ...o,
              recursionLimit: (o.recursionLimit ?? cc) - 1
            });
          } else if (lu(l)) {
            let d;
            for await (const h of du(o, l))
              if ((c = n == null ? void 0 : n.signal) == null || c.throwIfAborted(), d === void 0) d = h;
              else try {
                d = this._concatOutputChunks(d, h);
              } catch {
                d = h;
              }
            l = d;
          } else if (ef(l)) {
            let d;
            for (const h of tf(o, l))
              if ((u = n == null ? void 0 : n.signal) == null || u.throwIfAborted(), d === void 0) d = h;
              else try {
                d = this._concatOutputChunks(d, h);
              } catch {
                d = h;
              }
            l = d;
          }
          a(l);
        } catch (l) {
          i(l);
        }
      });
    });
  }
  async invoke(t, n) {
    return this._callWithConfig(this._invoke.bind(this), t, n);
  }
  async *_transform(t, n, s) {
    var c, u;
    let a;
    for await (const l of t) if (a === void 0) a = l;
    else try {
      a = this._concatOutputChunks(a, l);
    } catch {
      a = l;
    }
    const i = Be(s, {
      callbacks: n == null ? void 0 : n.getChild(),
      recursionLimit: ((s == null ? void 0 : s.recursionLimit) ?? cc) - 1
    }), o = await new Promise((l, d) => {
      lr.runWithConfig(Ur(i), async () => {
        try {
          const h = await this.func(a, {
            ...i,
            config: i
          });
          l(h);
        } catch (h) {
          d(h);
        }
      });
    });
    if (o && Qe.isRunnable(o)) {
      if ((s == null ? void 0 : s.recursionLimit) === 0) throw new Error("Recursion limit reached.");
      const l = await o.stream(a, i);
      for await (const d of l) yield d;
    } else if (lu(o)) for await (const l of du(i, o))
      (c = s == null ? void 0 : s.signal) == null || c.throwIfAborted(), yield l;
    else if (ef(o)) for (const l of tf(i, o))
      (u = s == null ? void 0 : s.signal) == null || u.throwIfAborted(), yield l;
    else yield o;
  }
  transform(t, n) {
    return this._transformStreamWithConfig(t, this._transform.bind(this), n);
  }
  async stream(t, n) {
    async function* s() {
      yield t;
    }
    const a = Ce(n), i = new On({
      generator: this.transform(s(), a),
      config: a
    });
    return await i.setup, dr.fromAsyncGenerator(i);
  }
}, EO = class extends fs {
}, S_ = class extends Qe {
  constructor(e) {
    super(e);
    b(this, "lc_namespace", ["langchain_core", "runnables"]);
    b(this, "lc_serializable", !0);
    b(this, "runnable");
    b(this, "fallbacks");
    this.runnable = e.runnable, this.fallbacks = e.fallbacks;
  }
  static lc_name() {
    return "RunnableWithFallbacks";
  }
  *runnables() {
    yield this.runnable;
    for (const e of this.fallbacks) yield e;
  }
  async invoke(e, t) {
    const n = Ce(t), s = await Zt(n), { runId: a, ...i } = n, o = await (s == null ? void 0 : s.handleChainStart(this.toJSON(), ut(e, "input"), a, void 0, void 0, void 0, i == null ? void 0 : i.runName)), c = Be(i, { callbacks: o == null ? void 0 : o.getChild() });
    return await lr.runWithConfig(c, async () => {
      var d;
      let l;
      for (const h of this.runnables()) {
        (d = n == null ? void 0 : n.signal) == null || d.throwIfAborted();
        try {
          const f = await h.invoke(e, c);
          return await (o == null ? void 0 : o.handleChainEnd(ut(f, "output"))), f;
        } catch (f) {
          l === void 0 && (l = f);
        }
      }
      throw l === void 0 ? new Error("No error stored at end of fallback.") : (await (o == null ? void 0 : o.handleChainError(l)), l);
    });
  }
  async *_streamIterator(e, t) {
    var d;
    const n = Ce(t), s = await Zt(n), { runId: a, ...i } = n, o = await (s == null ? void 0 : s.handleChainStart(this.toJSON(), ut(e, "input"), a, void 0, void 0, void 0, i == null ? void 0 : i.runName));
    let c, u;
    for (const h of this.runnables()) {
      (d = n == null ? void 0 : n.signal) == null || d.throwIfAborted();
      const f = Be(i, { callbacks: o == null ? void 0 : o.getChild() });
      try {
        const p = await h.stream(e, f);
        u = du(f, p);
        break;
      } catch (p) {
        c === void 0 && (c = p);
      }
    }
    if (u === void 0) {
      const h = c ?? /* @__PURE__ */ new Error("No error stored at end of fallback.");
      throw await (o == null ? void 0 : o.handleChainError(h)), h;
    }
    let l;
    try {
      for await (const h of u) {
        yield h;
        try {
          l = l === void 0 ? l : this._concatOutputChunks(l, h);
        } catch {
          l = void 0;
        }
      }
    } catch (h) {
      throw await (o == null ? void 0 : o.handleChainError(h)), h;
    }
    await (o == null ? void 0 : o.handleChainEnd(ut(l, "output")));
  }
  async batch(e, t, n) {
    var c;
    if (n != null && n.returnExceptions) throw new Error("Not implemented.");
    const s = this._getOptionsList(t ?? {}, e.length), a = await Promise.all(s.map((u) => Zt(u))), i = await Promise.all(a.map(async (u, l) => {
      const d = await (u == null ? void 0 : u.handleChainStart(this.toJSON(), ut(e[l], "input"), s[l].runId, void 0, void 0, void 0, s[l].runName));
      return delete s[l].runId, d;
    }));
    let o;
    for (const u of this.runnables()) {
      (c = s[0].signal) == null || c.throwIfAborted();
      try {
        const l = await u.batch(e, i.map((d, h) => Be(s[h], { callbacks: d == null ? void 0 : d.getChild() })), n);
        return await Promise.all(i.map((d, h) => d == null ? void 0 : d.handleChainEnd(ut(l[h], "output")))), l;
      } catch (l) {
        o === void 0 && (o = l);
      }
    }
    throw o ? (await Promise.all(i.map((u) => u == null ? void 0 : u.handleChainError(o))), o) : new Error("No error stored at end of fallbacks.");
  }
};
function ur(r) {
  if (typeof r == "function") return new qr({ func: r });
  if (Qe.isRunnable(r)) return r;
  if (!Array.isArray(r) && typeof r == "object") {
    const e = {};
    for (const [t, n] of Object.entries(r)) e[t] = ur(n);
    return new fs({ steps: e });
  } else throw new Error(`Expected a Runnable, function or object.
Instead got an unsupported type.`);
}
var Pl = class extends Qe {
  constructor(e) {
    e instanceof fs && (e = { mapper: e });
    super(e);
    b(this, "lc_namespace", ["langchain_core", "runnables"]);
    b(this, "lc_serializable", !0);
    b(this, "mapper");
    this.mapper = e.mapper;
  }
  static lc_name() {
    return "RunnableAssign";
  }
  async invoke(e, t) {
    const n = await this.mapper.invoke(e, t);
    return {
      ...e,
      ...n
    };
  }
  async *_transform(e, t, n) {
    const s = this.mapper.getStepsKeys(), [a, i] = yl(e), o = this.mapper.transform(i, Be(n, { callbacks: t == null ? void 0 : t.getChild() })), c = o.next();
    for await (const u of a) {
      if (typeof u != "object" || Array.isArray(u)) throw new Error(`RunnableAssign can only be used with objects as input, got ${typeof u}`);
      const l = Object.fromEntries(Object.entries(u).filter(([d]) => !s.includes(d)));
      Object.keys(l).length > 0 && (yield l);
    }
    yield (await c).value;
    for await (const u of o) yield u;
  }
  transform(e, t) {
    return this._transformStreamWithConfig(e, this._transform.bind(this), t);
  }
  async stream(e, t) {
    async function* n() {
      yield e;
    }
    const s = Ce(t), a = new On({
      generator: this.transform(n(), s),
      config: s
    });
    return await a.setup, dr.fromAsyncGenerator(a);
  }
}, T_ = class extends Qe {
  constructor(e) {
    (typeof e == "string" || Array.isArray(e)) && (e = { keys: e });
    super(e);
    b(this, "lc_namespace", ["langchain_core", "runnables"]);
    b(this, "lc_serializable", !0);
    b(this, "keys");
    this.keys = e.keys;
  }
  static lc_name() {
    return "RunnablePick";
  }
  async _pick(e) {
    if (typeof this.keys == "string") return e[this.keys];
    {
      const t = this.keys.map((n) => [n, e[n]]).filter((n) => n[1] !== void 0);
      return t.length === 0 ? void 0 : Object.fromEntries(t);
    }
  }
  async invoke(e, t) {
    return this._callWithConfig(this._pick.bind(this), e, t);
  }
  async *_transform(e) {
    for await (const t of e) {
      const n = await this._pick(t);
      n !== void 0 && (yield n);
    }
  }
  transform(e, t) {
    return this._transformStreamWithConfig(e, this._transform.bind(this), t);
  }
  async stream(e, t) {
    async function* n() {
      yield e;
    }
    const s = Ce(t), a = new On({
      generator: this.transform(n(), s),
      config: s
    });
    return await a.setup, dr.fromAsyncGenerator(a);
  }
}, hu = class extends is {
  constructor(e) {
    const t = ma.from([qr.from(async (n) => {
      let s;
      if (js(n)) try {
        s = await Eo(this.schema, n.args);
      } catch {
        throw new Si("Received tool input did not match expected schema", JSON.stringify(n.args));
      }
      else s = n;
      return s;
    }).withConfig({ runName: `${e.name}:parse_input` }), e.bound]).withConfig({ runName: e.name });
    super({
      bound: t,
      config: e.config ?? {}
    });
    b(this, "name");
    b(this, "description");
    b(this, "schema");
    this.name = e.name, this.description = e.description, this.schema = e.schema;
  }
  static lc_name() {
    return "RunnableToolLike";
  }
};
function xO(r, e) {
  const t = e.name ?? r.getName(), n = e.description ?? xo(e.schema);
  return Ol(e.schema) ? new hu({
    name: t,
    description: n,
    schema: Oo({ input: Io() }).transform((s) => s.input),
    bound: r
  }) : new hu({
    name: t,
    description: n,
    schema: e.schema,
    bound: r
  });
}
const Ui = (r, e) => {
  const t = [...new Set(e == null ? void 0 : e.map((s) => {
    if (typeof s == "string") return s;
    const a = new s({});
    if (!("getType" in a) || typeof a.getType != "function") throw new Error("Invalid type provided.");
    return a.getType();
  }))], n = r.getType();
  return t.some((s) => s === n);
};
function kO(r, e) {
  return Array.isArray(r) ? rf(r, e) : qr.from((t) => rf(t, r));
}
function rf(r, e = {}) {
  const { includeNames: t, excludeNames: n, includeTypes: s, excludeTypes: a, includeIds: i, excludeIds: o } = e, c = [];
  for (const u of r)
    if (!(n && u.name && n.includes(u.name))) {
      {
        if (a && Ui(u, a)) continue;
        if (o && u.id && o.includes(u.id)) continue;
      }
      s || i || t ? (t && u.name && t.some((l) => l === u.name) || s && Ui(u, s) || i && u.id && i.some((l) => l === u.id)) && c.push(u) : c.push(u);
    }
  return c;
}
function IO(r) {
  return Array.isArray(r) ? nf(r) : qr.from(nf);
}
function nf(r) {
  if (!r.length) return [];
  const e = [];
  for (const t of r) {
    const n = t, s = e.pop();
    if (!s) e.push(n);
    else if (n.getType() === "tool" || n.getType() !== s.getType()) e.push(s, n);
    else {
      const a = Ti(s), i = Ti(n), o = a.concat(i);
      typeof a.content == "string" && typeof i.content == "string" && (o.content = `${a.content}
${i.content}`), e.push($O(o));
    }
  }
  return e;
}
function OO(r, e) {
  if (Array.isArray(r)) {
    const t = r;
    if (!e) throw new Error("Options parameter is required when providing messages.");
    return sf(t, e);
  } else {
    const t = r;
    return qr.from((n) => sf(n, t)).withConfig({ runName: "trim_messages" });
  }
}
async function sf(r, e) {
  const { maxTokens: t, tokenCounter: n, strategy: s = "last", allowPartial: a = !1, endOn: i, startOn: o, includeSystem: c = !1, textSplitter: u } = e;
  if (o && s === "first") throw new Error("`startOn` should only be specified if `strategy` is 'last'.");
  if (c && s === "first") throw new Error("`includeSystem` should only be specified if `strategy` is 'last'.");
  let l;
  "getNumTokens" in n ? l = async (h) => (await Promise.all(h.map((p) => n.getNumTokens(p.content)))).reduce((p, y) => p + y, 0) : l = async (h) => n(h);
  let d = x_;
  if (u && ("splitText" in u ? d = u.splitText : d = async (h) => u(h)), s === "first") return E_(r, {
    maxTokens: t,
    tokenCounter: l,
    textSplitter: d,
    partialStrategy: a ? "first" : void 0,
    endOn: i
  });
  if (s === "last") return AO(r, {
    maxTokens: t,
    tokenCounter: l,
    textSplitter: d,
    allowPartial: a,
    includeSystem: c,
    startOn: o,
    endOn: i
  });
  throw new Error(`Unrecognized strategy: '${s}'. Must be one of 'first' or 'last'.`);
}
async function E_(r, e) {
  const { maxTokens: t, tokenCounter: n, textSplitter: s, partialStrategy: a, endOn: i } = e;
  let o = [...r], c = 0;
  for (let u = 0; u < o.length; u += 1) {
    const l = u > 0 ? o.slice(0, -u) : o;
    if (await n(l) <= t) {
      c = o.length - u;
      break;
    }
  }
  if (c < o.length && a) {
    let u = !1;
    if (Array.isArray(o[c].content)) {
      const l = o[c];
      if (typeof l.content == "string") throw new Error("Expected content to be an array.");
      const d = l.content.length, h = a === "last" ? [...l.content].reverse() : l.content;
      for (let f = 1; f <= d; f += 1) {
        const p = a === "first" ? h.slice(0, f) : h.slice(-f), y = Object.fromEntries(Object.entries(l).filter(([g]) => g !== "type" && !g.startsWith("lc_"))), m = Ll(l.getType(), {
          ...y,
          content: p
        }), v = [...o.slice(0, c), m];
        if (await n(v) <= t)
          o = v, c += 1, u = !0;
        else break;
      }
      u && a === "last" && (l.content = [...h].reverse());
    }
    if (!u) {
      const l = o[c];
      let d;
      if (Array.isArray(l.content) && l.content.some((h) => typeof h == "string" || h.type === "text")) {
        const h = l.content.find((f) => f.type === "text" && f.text);
        d = h == null ? void 0 : h.text;
      } else typeof l.content == "string" && (d = l.content);
      if (d) {
        const h = await s(d), f = h.length;
        a === "last" && h.reverse();
        for (let p = 0; p < f - 1; p += 1)
          if (h.pop(), l.content = h.join(""), await n([...o.slice(0, c), l]) <= t) {
            a === "last" && (l.content = [...h].reverse().join("")), o = [...o.slice(0, c), l], c += 1;
            break;
          }
      }
    }
  }
  if (i) {
    const u = Array.isArray(i) ? i : [i];
    for (; c > 0 && !Ui(o[c - 1], u); ) c -= 1;
  }
  return o.slice(0, c);
}
async function AO(r, e) {
  var l;
  const { allowPartial: t = !1, includeSystem: n = !1, endOn: s, startOn: a, ...i } = e;
  let o = r.map((d) => {
    const h = Object.fromEntries(Object.entries(d).filter(([f]) => f !== "type" && !f.startsWith("lc_")));
    return Ll(d.getType(), h, tl(d));
  });
  if (s) {
    const d = Array.isArray(s) ? s : [s];
    for (; o.length > 0 && !Ui(o[o.length - 1], d); ) o = o.slice(0, -1);
  }
  const c = n && ((l = o[0]) == null ? void 0 : l.getType()) === "system";
  let u = c ? o.slice(0, 1).concat(o.slice(1).reverse()) : o.reverse();
  return u = await E_(u, {
    ...i,
    partialStrategy: t ? "last" : void 0,
    endOn: a
  }), c ? [u[0], ...u.slice(1).reverse()] : u.reverse();
}
const af = {
  human: {
    message: zt,
    messageChunk: la
  },
  ai: {
    message: Fe,
    messageChunk: Ar
  },
  system: {
    message: ct,
    messageChunk: sn
  },
  developer: {
    message: ct,
    messageChunk: sn
  },
  tool: {
    message: Ir,
    messageChunk: oa
  },
  function: {
    message: io,
    messageChunk: ua
  },
  generic: {
    message: In,
    messageChunk: ca
  },
  remove: {
    message: bi,
    messageChunk: bi
  }
};
function Ll(r, e, t) {
  var a;
  let n, s;
  switch (r) {
    case "human":
      t ? n = new la(e) : s = new zt(e);
      break;
    case "ai":
      if (t) {
        let i = { ...e };
        "tool_calls" in i && (i = {
          ...i,
          tool_call_chunks: (a = i.tool_calls) == null ? void 0 : a.map((o) => ({
            ...o,
            type: "tool_call_chunk",
            index: void 0,
            args: JSON.stringify(o.args)
          }))
        }), n = new Ar(i);
      } else s = new Fe(e);
      break;
    case "system":
      t ? n = new sn(e) : s = new ct(e);
      break;
    case "developer":
      t ? n = new sn({
        ...e,
        additional_kwargs: {
          ...e.additional_kwargs,
          __openai_role__: "developer"
        }
      }) : s = new ct({
        ...e,
        additional_kwargs: {
          ...e.additional_kwargs,
          __openai_role__: "developer"
        }
      });
      break;
    case "tool":
      if ("tool_call_id" in e) t ? n = new oa(e) : s = new Ir(e);
      else throw new Error("Can not convert ToolMessage to ToolMessageChunk if 'tool_call_id' field is not defined.");
      break;
    case "function":
      if (t) n = new ua(e);
      else {
        if (!e.name) throw new Error("FunctionMessage must have a 'name' field");
        s = new io(e);
      }
      break;
    case "generic":
      if ("role" in e) t ? n = new ca(e) : s = new In(e);
      else throw new Error("Can not convert ChatMessage to ChatMessageChunk if 'role' field is not defined.");
      break;
    default:
      throw new Error(`Unrecognized message type ${r}`);
  }
  if (t && n) return n;
  if (s) return s;
  throw new Error(`Unrecognized message type ${r}`);
}
function $O(r) {
  const e = r.getType();
  let t;
  const n = Object.fromEntries(Object.entries(r).filter(([s]) => !["type", "tool_call_chunks"].includes(s) && !s.startsWith("lc_")));
  if (e in af && (t = Ll(e, n)), !t) throw new Error(`Unrecognized message chunk class ${e}. Supported classes are ${Object.keys(af)}`);
  return t;
}
function x_(r) {
  const e = r.split(`
`);
  return Promise.resolve([...e.slice(0, -1).map((t) => `${t}
`), e[e.length - 1]]);
}
const CO = [
  "tool_call",
  "tool_call_chunk",
  "invalid_tool_call",
  "server_tool_call",
  "server_tool_call_chunk",
  "server_tool_call_result"
], RO = [
  "image",
  "video",
  "audio",
  "text-plain",
  "file"
], NO = [
  "text",
  "reasoning",
  ...CO,
  ...RO
];
var PO = {};
Ae(PO, {
  AIMessage: () => Fe,
  AIMessageChunk: () => Ar,
  BaseMessage: () => Vr,
  BaseMessageChunk: () => dn,
  ChatMessage: () => In,
  ChatMessageChunk: () => ca,
  FunctionMessage: () => io,
  FunctionMessageChunk: () => ua,
  HumanMessage: () => zt,
  HumanMessageChunk: () => la,
  KNOWN_BLOCK_TYPES: () => NO,
  RemoveMessage: () => bi,
  SystemMessage: () => ct,
  SystemMessageChunk: () => sn,
  ToolMessage: () => Ir,
  ToolMessageChunk: () => oa,
  _isMessageFieldWithRole: () => vm,
  _mergeDicts: () => Tt,
  _mergeLists: () => ia,
  _mergeObj: () => ym,
  _mergeStatus: () => _m,
  coerceMessageLikeToMessage: () => Fs,
  collapseToolCallChunks: () => $m,
  convertToChunk: () => Ti,
  convertToOpenAIImageBlock: () => cm,
  convertToProviderContentBlock: () => Ku,
  defaultTextSplitter: () => x_,
  defaultToolCallParser: () => nl,
  filterMessages: () => kO,
  getBufferString: () => al,
  iife: () => Am,
  isAIMessage: () => co,
  isAIMessageChunk: () => Mc,
  isBase64ContentBlock: () => Wu,
  isBaseMessage: () => Xr,
  isBaseMessageChunk: () => tl,
  isChatMessage: () => mv,
  isChatMessageChunk: () => gv,
  isDataContentBlock: () => kr,
  isDirectToolOutput: () => rl,
  isFunctionMessage: () => _v,
  isFunctionMessageChunk: () => yv,
  isHumanMessage: () => wv,
  isHumanMessageChunk: () => vv,
  isIDContentBlock: () => om,
  isMessage: () => um,
  isOpenAIToolCallArray: () => dv,
  isPlainTextContentBlock: () => Mw,
  isSystemMessage: () => bv,
  isSystemMessageChunk: () => Sv,
  isToolMessage: () => Em,
  isToolMessageChunk: () => xm,
  isURLContentBlock: () => Gu,
  mapChatMessagesToStoredMessages: () => Lv,
  mapStoredMessageToChatMessage: () => il,
  mapStoredMessagesToChatMessages: () => Pv,
  mergeContent: () => Fr,
  mergeMessageRuns: () => IO,
  mergeResponseMetadata: () => bm,
  mergeUsageMetadata: () => Tm,
  parseBase64DataUrl: () => Js,
  parseMimeType: () => Pc,
  trimMessages: () => OO
});
const En = (r) => r();
function ga(r) {
  return r ? !!(/^o\d/.test(r ?? "") || r.startsWith("gpt-5") && !r.startsWith("gpt-5-chat")) : !1;
}
function LO(r) {
  return r.role !== "system" && r.role !== "developer" && r.role !== "assistant" && r.role !== "user" && r.role !== "function" && r.role !== "tool" && console.warn(`Unknown message role: ${r.role}`), r.role;
}
function _a(r) {
  const e = r._getType();
  switch (e) {
    case "system":
      return "system";
    case "ai":
      return "assistant";
    case "human":
      return "user";
    case "function":
      return "function";
    case "tool":
      return "tool";
    case "generic":
      if (!In.isInstance(r)) throw new Error("Invalid generic chat message");
      return LO(r);
    default:
      throw new Error(`Unknown message type: ${e}`);
  }
}
function MO(r) {
  const { azureOpenAIApiDeploymentName: e, azureOpenAIApiInstanceName: t, azureOpenAIApiKey: n, azureOpenAIBasePath: s, baseURL: a, azureADTokenProvider: i, azureOpenAIEndpoint: o } = r;
  if ((n || i) && s && e) return `${s}/${e}`;
  if ((n || i) && o && e) return `${o}/openai/deployments/${e}`;
  if (n || i) {
    if (!t) throw new Error("azureOpenAIApiInstanceName is required when using azureOpenAIApiKey");
    if (!e) throw new Error("azureOpenAIApiDeploymentName is a required parameter when using azureOpenAIApiKey");
    return `https://${t}.openai.azure.com/openai/deployments/${e}`;
  }
  return a;
}
function of(r) {
  return typeof Headers < "u" && r !== null && typeof r == "object" && Object.prototype.toString.call(r) === "[object Headers]";
}
function DO(r) {
  const e = En(() => {
    if (of(r)) return r;
    if (Array.isArray(r)) return new Headers(r);
    if (typeof r == "object" && r !== null && "values" in r && of(r.values)) return r.values;
    if (typeof r == "object" && r !== null) {
      const t = Object.entries(r).filter(([, n]) => typeof n == "string").map(([n, s]) => [n, s]);
      return new Headers(t);
    }
    return new Headers();
  });
  return Object.fromEntries(e.entries());
}
function jO() {
  let r = ol();
  return (r === "node" || r === "deno") && (r = `(${r}/${process.version}; ${process.platform}; ${process.arch})`), r;
}
function FO(r, e = !1, t = "1.0.0") {
  const n = DO(r), s = jO(), a = `langchainjs${e ? "-azure" : ""}-openai`;
  return {
    ...n,
    "User-Agent": n["User-Agent"] ? `${a}/${t} (${s})${n["User-Agent"]}` : `${a}/${t} (${s})`
  };
}
function Ml(r) {
  return r !== void 0 && Array.isArray(r.lc_namespace);
}
function Dl(r) {
  return r !== void 0 && Qe.isRunnable(r) && "lc_name" in r.constructor && typeof r.constructor.lc_name == "function" && r.constructor.lc_name() === "RunnableToolLike";
}
function jl(r) {
  return !!r && typeof r == "object" && "name" in r && "schema" in r && (br(r.schema) || r.schema != null && typeof r.schema == "object" && "type" in r.schema && typeof r.schema.type == "string" && [
    "null",
    "boolean",
    "object",
    "array",
    "number",
    "string"
  ].includes(r.schema.type));
}
function Ao(r) {
  return jl(r) || Dl(r) || Ml(r);
}
var UO = {};
Ae(UO, {
  convertToOpenAIFunction: () => k_,
  convertToOpenAITool: () => I_,
  isLangChainTool: () => Ao,
  isRunnableToolLike: () => Dl,
  isStructuredTool: () => Ml,
  isStructuredToolParams: () => jl
});
function k_(r, e) {
  const t = typeof e == "number" ? void 0 : e;
  return {
    name: r.name,
    description: r.description,
    parameters: Sr(r.schema),
    ...(t == null ? void 0 : t.strict) !== void 0 ? { strict: t.strict } : {}
  };
}
function I_(r, e) {
  const t = typeof e == "number" ? void 0 : e;
  let n;
  return Ao(r) ? n = {
    type: "function",
    function: k_(r)
  } : n = r, (t == null ? void 0 : t.strict) !== void 0 && (n.function.strict = t.strict), n;
}
var zO = {};
Ae(zO, {
  extendInteropZodObject: () => yk,
  getInteropZodDefaultGetter: () => vk,
  getInteropZodObjectShape: () => Qc,
  getSchemaDescription: () => xo,
  interopParse: () => mk,
  interopParseAsync: () => Eo,
  interopSafeParse: () => pk,
  interopSafeParseAsync: () => e_,
  interopZodObjectMakeFieldsOptional: () => Tk,
  interopZodObjectPartial: () => wk,
  interopZodObjectPassthrough: () => eu,
  interopZodObjectStrict: () => Ni,
  interopZodTransformInputSchema: () => n_,
  isInteropZodError: () => s_,
  isInteropZodLiteral: () => fk,
  isInteropZodObject: () => _k,
  isInteropZodSchema: () => br,
  isShapelessZodSchema: () => gk,
  isSimpleStringZodSchema: () => Ol,
  isZodArrayV4: () => ko,
  isZodLiteralV3: () => Xg,
  isZodLiteralV4: () => Qg,
  isZodNullableV4: () => r_,
  isZodObjectV3: () => Al,
  isZodObjectV4: () => xr,
  isZodOptionalV4: () => t_,
  isZodSchema: () => hk,
  isZodSchemaV3: () => st,
  isZodSchemaV4: () => qe
});
function BO(r, e) {
  let t;
  return Ao(r) ? t = I_(r) : t = r, (e == null ? void 0 : e.strict) !== void 0 && (t.function.strict = e.strict), t;
}
function ZO(r) {
  return r.anyOf !== void 0 && Array.isArray(r.anyOf);
}
function VO(r) {
  const e = ["namespace functions {", ""];
  for (const t of r)
    t.description && e.push(`// ${t.description}`), Object.keys(t.parameters.properties ?? {}).length > 0 ? (e.push(`type ${t.name} = (_: {`), e.push(O_(t.parameters, 0)), e.push("}) => any;")) : e.push(`type ${t.name} = () => any;`), e.push("");
  return e.push("} // namespace functions"), e.join(`
`);
}
function O_(r, e) {
  var n;
  const t = [];
  for (const [s, a] of Object.entries(r.properties ?? {}))
    a.description && e < 2 && t.push(`// ${a.description}`), (n = r.required) != null && n.includes(s) ? t.push(`${s}: ${zi(a, e)},`) : t.push(`${s}?: ${zi(a, e)},`);
  return t.map((s) => " ".repeat(e) + s).join(`
`);
}
function zi(r, e) {
  if (ZO(r)) return r.anyOf.map((t) => zi(t, e)).join(" | ");
  switch (r.type) {
    case "string":
      return r.enum ? r.enum.map((t) => `"${t}"`).join(" | ") : "string";
    case "number":
      return r.enum ? r.enum.map((t) => `${t}`).join(" | ") : "number";
    case "integer":
      return r.enum ? r.enum.map((t) => `${t}`).join(" | ") : "number";
    case "boolean":
      return "boolean";
    case "null":
      return "null";
    case "object":
      return [
        "{",
        O_(r, e + 2),
        "}"
      ].join(`
`);
    case "array":
      return r.items ? `${zi(r.items, e)}[]` : "any[]";
    default:
      return "";
  }
}
function A_(r) {
  if (r) return r === "any" || r === "required" ? "required" : r === "auto" ? "auto" : r === "none" ? "none" : typeof r == "string" ? {
    type: "function",
    function: { name: r }
  } : r;
}
function Fl(r) {
  return "type" in r && r.type !== "function";
}
function qO(r) {
  return r != null && typeof r == "object" && "type" in r && r.type !== "function";
}
function Bi(r) {
  return typeof r == "object" && r !== null && "metadata" in r && typeof r.metadata == "object" && r.metadata !== null && "customTool" in r.metadata && typeof r.metadata.customTool == "object" && r.metadata.customTool !== null;
}
function $_(r) {
  return "type" in r && r.type === "custom" && "custom" in r && typeof r.custom == "object" && r.custom !== null;
}
function JO(r) {
  if (r.type === "custom_tool_call")
    return {
      ...r,
      type: "tool_call",
      call_id: r.id,
      id: r.call_id,
      name: r.name,
      isCustomTool: !0,
      args: { input: r.input }
    };
}
function HO(r) {
  return r.type === "tool_call" && "isCustomTool" in r && r.isCustomTool === !0;
}
function GO(r) {
  const e = () => {
    if (r.custom.format) {
      if (r.custom.format.type === "grammar") return {
        type: "grammar",
        definition: r.custom.format.grammar.definition,
        syntax: r.custom.format.grammar.syntax
      };
      if (r.custom.format.type === "text") return { type: "text" };
    }
  };
  return {
    type: "custom",
    name: r.custom.name,
    description: r.custom.description,
    format: e()
  };
}
function WO(r) {
  const e = () => {
    if (r.format) {
      if (r.format.type === "grammar") return {
        type: "grammar",
        grammar: {
          definition: r.format.definition,
          syntax: r.format.syntax
        }
      };
      if (r.format.type === "text") return { type: "text" };
    }
  };
  return {
    type: "custom",
    custom: {
      name: r.name,
      description: r.description,
      format: e()
    }
  };
}
const KO = /* @__PURE__ */ L("ZodISODateTime", (r, e) => {
  ZE.init(r, e), Je.init(r, e);
});
function YO(r) {
  return Vx(KO, r);
}
const XO = /* @__PURE__ */ L("ZodISODate", (r, e) => {
  VE.init(r, e), Je.init(r, e);
});
function QO(r) {
  return qx(XO, r);
}
const eA = /* @__PURE__ */ L("ZodISOTime", (r, e) => {
  qE.init(r, e), Je.init(r, e);
});
function tA(r) {
  return Jx(eA, r);
}
const rA = /* @__PURE__ */ L("ZodISODuration", (r, e) => {
  JE.init(r, e), Je.init(r, e);
});
function nA(r) {
  return Hx(rA, r);
}
const sA = (r, e) => {
  Ng.init(r, e), r.name = "ZodError", Object.defineProperties(r, {
    format: {
      value: (t) => NT(r, t)
      // enumerable: false,
    },
    flatten: {
      value: (t) => RT(r, t)
      // enumerable: false,
    },
    addIssue: {
      value: (t) => {
        r.issues.push(t), r.message = JSON.stringify(r.issues, Yc, 2);
      }
      // enumerable: false,
    },
    addIssues: {
      value: (t) => {
        r.issues.push(...t), r.message = JSON.stringify(r.issues, Yc, 2);
      }
      // enumerable: false,
    },
    isEmpty: {
      get() {
        return r.issues.length === 0;
      }
      // enumerable: false,
    }
  });
}, Kt = L("ZodError", sA, {
  Parent: Error
}), aA = /* @__PURE__ */ yo(Kt), iA = /* @__PURE__ */ vo(Kt), oA = /* @__PURE__ */ bo(Kt), cA = /* @__PURE__ */ So(Kt), uA = /* @__PURE__ */ jT(Kt), lA = /* @__PURE__ */ FT(Kt), dA = /* @__PURE__ */ UT(Kt), hA = /* @__PURE__ */ zT(Kt), fA = /* @__PURE__ */ BT(Kt), pA = /* @__PURE__ */ ZT(Kt), mA = /* @__PURE__ */ VT(Kt), gA = /* @__PURE__ */ qT(Kt), et = /* @__PURE__ */ L("ZodType", (r, e) => (Ye.init(r, e), r.def = e, r.type = e.type, Object.defineProperty(r, "_def", { value: e }), r.check = (...t) => r.clone($n(e, {
  checks: [
    ...e.checks ?? [],
    ...t.map((n) => typeof n == "function" ? { _zod: { check: n, def: { check: "custom" }, onattach: [] } } : n)
  ]
})), r.clone = (t, n) => bt(r, t, n), r.brand = () => r, r.register = (t, n) => (t.add(r, n), r), r.parse = (t, n) => aA(r, t, n, { callee: r.parse }), r.safeParse = (t, n) => oA(r, t, n), r.parseAsync = async (t, n) => iA(r, t, n, { callee: r.parseAsync }), r.safeParseAsync = async (t, n) => cA(r, t, n), r.spa = r.safeParseAsync, r.encode = (t, n) => uA(r, t, n), r.decode = (t, n) => lA(r, t, n), r.encodeAsync = async (t, n) => dA(r, t, n), r.decodeAsync = async (t, n) => hA(r, t, n), r.safeEncode = (t, n) => fA(r, t, n), r.safeDecode = (t, n) => pA(r, t, n), r.safeEncodeAsync = async (t, n) => mA(r, t, n), r.safeDecodeAsync = async (t, n) => gA(r, t, n), r.refine = (t, n) => r.check(c$(t, n)), r.superRefine = (t) => r.check(u$(t)), r.overwrite = (t) => r.check(hs(t)), r.optional = () => df(r), r.nullable = () => hf(r), r.nullish = () => df(hf(r)), r.nonoptional = (t) => t$(r, t), r.array = () => Vi(r), r.or = (t) => ZA([r, t]), r.and = (t) => qA(r, t), r.transform = (t) => ff(r, WA(t)), r.default = (t) => XA(r, t), r.prefault = (t) => e$(r, t), r.catch = (t) => n$(r, t), r.pipe = (t) => ff(r, t), r.readonly = () => i$(r), r.describe = (t) => {
  const n = r.clone();
  return pt.add(n, { description: t }), n;
}, Object.defineProperty(r, "description", {
  get() {
    var t;
    return (t = pt.get(r)) == null ? void 0 : t.description;
  },
  configurable: !0
}), r.meta = (...t) => {
  if (t.length === 0)
    return pt.get(r);
  const n = r.clone();
  return pt.add(n, t[0]), n;
}, r.isOptional = () => r.safeParse(void 0).success, r.isNullable = () => r.safeParse(null).success, r)), C_ = /* @__PURE__ */ L("_ZodString", (r, e) => {
  kl.init(r, e), et.init(r, e);
  const t = r._zod.bag;
  r.format = t.format ?? null, r.minLength = t.minimum ?? null, r.maxLength = t.maximum ?? null, r.regex = (...n) => r.check(Yx(...n)), r.includes = (...n) => r.check(ek(...n)), r.startsWith = (...n) => r.check(tk(...n)), r.endsWith = (...n) => r.check(rk(...n)), r.min = (...n) => r.check(Ci(...n)), r.max = (...n) => r.check(Kg(...n)), r.length = (...n) => r.check(Yg(...n)), r.nonempty = (...n) => r.check(Ci(1, ...n)), r.lowercase = (n) => r.check(Xx(n)), r.uppercase = (n) => r.check(Qx(n)), r.trim = () => r.check(sk()), r.normalize = (...n) => r.check(nk(...n)), r.toLowerCase = () => r.check(ak()), r.toUpperCase = () => r.check(ik()), r.slugify = () => r.check(ok());
}), _A = /* @__PURE__ */ L("ZodString", (r, e) => {
  kl.init(r, e), C_.init(r, e), r.email = (t) => r.check(Tx(yA, t)), r.url = (t) => r.check(Ox(wA, t)), r.jwt = (t) => r.check(Zx(PA, t)), r.emoji = (t) => r.check(Ax(vA, t)), r.guid = (t) => r.check(Ih(cf, t)), r.uuid = (t) => r.check(Ex(Va, t)), r.uuidv4 = (t) => r.check(xx(Va, t)), r.uuidv6 = (t) => r.check(kx(Va, t)), r.uuidv7 = (t) => r.check(Ix(Va, t)), r.nanoid = (t) => r.check($x(bA, t)), r.guid = (t) => r.check(Ih(cf, t)), r.cuid = (t) => r.check(Cx(SA, t)), r.cuid2 = (t) => r.check(Rx(TA, t)), r.ulid = (t) => r.check(Nx(EA, t)), r.base64 = (t) => r.check(Ux(CA, t)), r.base64url = (t) => r.check(zx(RA, t)), r.xid = (t) => r.check(Px(xA, t)), r.ksuid = (t) => r.check(Lx(kA, t)), r.ipv4 = (t) => r.check(Mx(IA, t)), r.ipv6 = (t) => r.check(Dx(OA, t)), r.cidrv4 = (t) => r.check(jx(AA, t)), r.cidrv6 = (t) => r.check(Fx($A, t)), r.e164 = (t) => r.check(Bx(NA, t)), r.datetime = (t) => r.check(YO(t)), r.date = (t) => r.check(QO(t)), r.time = (t) => r.check(tA(t)), r.duration = (t) => r.check(nA(t));
});
function H(r) {
  return Sx(_A, r);
}
const Je = /* @__PURE__ */ L("ZodStringFormat", (r, e) => {
  Ve.init(r, e), C_.init(r, e);
}), yA = /* @__PURE__ */ L("ZodEmail", (r, e) => {
  PE.init(r, e), Je.init(r, e);
}), cf = /* @__PURE__ */ L("ZodGUID", (r, e) => {
  RE.init(r, e), Je.init(r, e);
}), Va = /* @__PURE__ */ L("ZodUUID", (r, e) => {
  NE.init(r, e), Je.init(r, e);
}), wA = /* @__PURE__ */ L("ZodURL", (r, e) => {
  LE.init(r, e), Je.init(r, e);
}), vA = /* @__PURE__ */ L("ZodEmoji", (r, e) => {
  ME.init(r, e), Je.init(r, e);
}), bA = /* @__PURE__ */ L("ZodNanoID", (r, e) => {
  DE.init(r, e), Je.init(r, e);
}), SA = /* @__PURE__ */ L("ZodCUID", (r, e) => {
  jE.init(r, e), Je.init(r, e);
}), TA = /* @__PURE__ */ L("ZodCUID2", (r, e) => {
  FE.init(r, e), Je.init(r, e);
}), EA = /* @__PURE__ */ L("ZodULID", (r, e) => {
  UE.init(r, e), Je.init(r, e);
}), xA = /* @__PURE__ */ L("ZodXID", (r, e) => {
  zE.init(r, e), Je.init(r, e);
}), kA = /* @__PURE__ */ L("ZodKSUID", (r, e) => {
  BE.init(r, e), Je.init(r, e);
}), IA = /* @__PURE__ */ L("ZodIPv4", (r, e) => {
  HE.init(r, e), Je.init(r, e);
}), OA = /* @__PURE__ */ L("ZodIPv6", (r, e) => {
  GE.init(r, e), Je.init(r, e);
}), AA = /* @__PURE__ */ L("ZodCIDRv4", (r, e) => {
  WE.init(r, e), Je.init(r, e);
}), $A = /* @__PURE__ */ L("ZodCIDRv6", (r, e) => {
  KE.init(r, e), Je.init(r, e);
}), CA = /* @__PURE__ */ L("ZodBase64", (r, e) => {
  YE.init(r, e), Je.init(r, e);
}), RA = /* @__PURE__ */ L("ZodBase64URL", (r, e) => {
  QE.init(r, e), Je.init(r, e);
}), NA = /* @__PURE__ */ L("ZodE164", (r, e) => {
  ex.init(r, e), Je.init(r, e);
}), PA = /* @__PURE__ */ L("ZodJWT", (r, e) => {
  rx.init(r, e), Je.init(r, e);
}), R_ = /* @__PURE__ */ L("ZodNumber", (r, e) => {
  Bg.init(r, e), et.init(r, e), r.gt = (n, s) => r.check(Ah(n, s)), r.gte = (n, s) => r.check(lc(n, s)), r.min = (n, s) => r.check(lc(n, s)), r.lt = (n, s) => r.check(Oh(n, s)), r.lte = (n, s) => r.check(uc(n, s)), r.max = (n, s) => r.check(uc(n, s)), r.int = (n) => r.check(uf(n)), r.safe = (n) => r.check(uf(n)), r.positive = (n) => r.check(Ah(0, n)), r.nonnegative = (n) => r.check(lc(0, n)), r.negative = (n) => r.check(Oh(0, n)), r.nonpositive = (n) => r.check(uc(0, n)), r.multipleOf = (n, s) => r.check($h(n, s)), r.step = (n, s) => r.check($h(n, s)), r.finite = () => r;
  const t = r._zod.bag;
  r.minValue = Math.max(t.minimum ?? Number.NEGATIVE_INFINITY, t.exclusiveMinimum ?? Number.NEGATIVE_INFINITY) ?? null, r.maxValue = Math.min(t.maximum ?? Number.POSITIVE_INFINITY, t.exclusiveMaximum ?? Number.POSITIVE_INFINITY) ?? null, r.isInt = (t.format ?? "").includes("int") || Number.isSafeInteger(t.multipleOf ?? 0.5), r.isFinite = !0, r.format = t.format ?? null;
});
function We(r) {
  return Gx(R_, r);
}
const LA = /* @__PURE__ */ L("ZodNumberFormat", (r, e) => {
  nx.init(r, e), R_.init(r, e);
});
function uf(r) {
  return Wx(LA, r);
}
const MA = /* @__PURE__ */ L("ZodBoolean", (r, e) => {
  sx.init(r, e), et.init(r, e);
});
function Zi(r) {
  return Kx(MA, r);
}
const DA = /* @__PURE__ */ L("ZodUnknown", (r, e) => {
  Zg.init(r, e), et.init(r, e);
});
function lf() {
  return Gg(DA);
}
const jA = /* @__PURE__ */ L("ZodNever", (r, e) => {
  Vg.init(r, e), et.init(r, e);
});
function FA(r) {
  return Wg(jA, r);
}
const UA = /* @__PURE__ */ L("ZodArray", (r, e) => {
  ax.init(r, e), et.init(r, e), r.element = e.element, r.min = (t, n) => r.check(Ci(t, n)), r.nonempty = (t) => r.check(Ci(1, t)), r.max = (t, n) => r.check(Kg(t, n)), r.length = (t, n) => r.check(Yg(t, n)), r.unwrap = () => r.element;
});
function Vi(r, e) {
  return ck(UA, r, e);
}
const zA = /* @__PURE__ */ L("ZodObject", (r, e) => {
  ox.init(r, e), et.init(r, e), ze(r, "shape", () => e.shape), r.keyof = () => rn(Object.keys(r._zod.def.shape)), r.catchall = (t) => r.clone({ ...r._zod.def, catchall: t }), r.passthrough = () => r.clone({ ...r._zod.def, catchall: lf() }), r.loose = () => r.clone({ ...r._zod.def, catchall: lf() }), r.strict = () => r.clone({ ...r._zod.def, catchall: FA() }), r.strip = () => r.clone({ ...r._zod.def, catchall: void 0 }), r.extend = (t) => $g(r, t), r.safeExtend = (t) => AT(r, t), r.merge = (t) => $T(r, t), r.pick = (t) => IT(r, t), r.omit = (t) => OT(r, t), r.partial = (...t) => Cg(N_, r, t[0]), r.required = (...t) => CT(P_, r, t[0]);
});
function ye(r, e) {
  const t = {
    type: "object",
    shape: r ?? {},
    ...le(e)
  };
  return new zA(t);
}
const BA = /* @__PURE__ */ L("ZodUnion", (r, e) => {
  cx.init(r, e), et.init(r, e), r.options = e.options;
});
function ZA(r, e) {
  return new BA({
    type: "union",
    options: r,
    ...le(e)
  });
}
const VA = /* @__PURE__ */ L("ZodIntersection", (r, e) => {
  ux.init(r, e), et.init(r, e);
});
function qA(r, e) {
  return new VA({
    type: "intersection",
    left: r,
    right: e
  });
}
const JA = /* @__PURE__ */ L("ZodRecord", (r, e) => {
  lx.init(r, e), et.init(r, e), r.keyType = e.keyType, r.valueType = e.valueType;
});
function HA(r, e, t) {
  return new JA({
    type: "record",
    keyType: r,
    valueType: e,
    ...le(t)
  });
}
const fu = /* @__PURE__ */ L("ZodEnum", (r, e) => {
  dx.init(r, e), et.init(r, e), r.enum = e.entries, r.options = Object.values(e.entries);
  const t = new Set(Object.keys(e.entries));
  r.extract = (n, s) => {
    const a = {};
    for (const i of n)
      if (t.has(i))
        a[i] = e.entries[i];
      else
        throw new Error(`Key ${i} not found in enum`);
    return new fu({
      ...e,
      checks: [],
      ...le(s),
      entries: a
    });
  }, r.exclude = (n, s) => {
    const a = { ...e.entries };
    for (const i of n)
      if (t.has(i))
        delete a[i];
      else
        throw new Error(`Key ${i} not found in enum`);
    return new fu({
      ...e,
      checks: [],
      ...le(s),
      entries: a
    });
  };
});
function rn(r, e) {
  const t = Array.isArray(r) ? Object.fromEntries(r.map((n) => [n, n])) : r;
  return new fu({
    type: "enum",
    entries: t,
    ...le(e)
  });
}
const GA = /* @__PURE__ */ L("ZodTransform", (r, e) => {
  hx.init(r, e), et.init(r, e), r._zod.parse = (t, n) => {
    if (n.direction === "backward")
      throw new xg(r.constructor.name);
    t.addIssue = (a) => {
      if (typeof a == "string")
        t.issues.push(ea(a, t.value, e));
      else {
        const i = a;
        i.fatal && (i.continue = !1), i.code ?? (i.code = "custom"), i.input ?? (i.input = t.value), i.inst ?? (i.inst = r), t.issues.push(ea(i));
      }
    };
    const s = e.transform(t.value, t);
    return s instanceof Promise ? s.then((a) => (t.value = a, t)) : (t.value = s, t);
  };
});
function WA(r) {
  return new GA({
    type: "transform",
    transform: r
  });
}
const N_ = /* @__PURE__ */ L("ZodOptional", (r, e) => {
  Il.init(r, e), et.init(r, e), r.unwrap = () => r._zod.def.innerType;
});
function df(r) {
  return new N_({
    type: "optional",
    innerType: r
  });
}
const KA = /* @__PURE__ */ L("ZodNullable", (r, e) => {
  fx.init(r, e), et.init(r, e), r.unwrap = () => r._zod.def.innerType;
});
function hf(r) {
  return new KA({
    type: "nullable",
    innerType: r
  });
}
const YA = /* @__PURE__ */ L("ZodDefault", (r, e) => {
  px.init(r, e), et.init(r, e), r.unwrap = () => r._zod.def.innerType, r.removeDefault = r.unwrap;
});
function XA(r, e) {
  return new YA({
    type: "default",
    innerType: r,
    get defaultValue() {
      return typeof e == "function" ? e() : Ag(e);
    }
  });
}
const QA = /* @__PURE__ */ L("ZodPrefault", (r, e) => {
  mx.init(r, e), et.init(r, e), r.unwrap = () => r._zod.def.innerType;
});
function e$(r, e) {
  return new QA({
    type: "prefault",
    innerType: r,
    get defaultValue() {
      return typeof e == "function" ? e() : Ag(e);
    }
  });
}
const P_ = /* @__PURE__ */ L("ZodNonOptional", (r, e) => {
  gx.init(r, e), et.init(r, e), r.unwrap = () => r._zod.def.innerType;
});
function t$(r, e) {
  return new P_({
    type: "nonoptional",
    innerType: r,
    ...le(e)
  });
}
const r$ = /* @__PURE__ */ L("ZodCatch", (r, e) => {
  _x.init(r, e), et.init(r, e), r.unwrap = () => r._zod.def.innerType, r.removeCatch = r.unwrap;
});
function n$(r, e) {
  return new r$({
    type: "catch",
    innerType: r,
    catchValue: typeof e == "function" ? e : () => e
  });
}
const s$ = /* @__PURE__ */ L("ZodPipe", (r, e) => {
  yx.init(r, e), et.init(r, e), r.in = e.in, r.out = e.out;
});
function ff(r, e) {
  return new s$({
    type: "pipe",
    in: r,
    out: e
    // ...util.normalizeParams(params),
  });
}
const a$ = /* @__PURE__ */ L("ZodReadonly", (r, e) => {
  wx.init(r, e), et.init(r, e), r.unwrap = () => r._zod.def.innerType;
});
function i$(r) {
  return new a$({
    type: "readonly",
    innerType: r
  });
}
const o$ = /* @__PURE__ */ L("ZodCustom", (r, e) => {
  vx.init(r, e), et.init(r, e);
});
function c$(r, e = {}) {
  return uk(o$, r, e);
}
function u$(r) {
  return lk(r);
}
const l$ = Symbol("Let zodToJsonSchema decide on which parser to use"), pf = {
  name: void 0,
  $refStrategy: "root",
  effectStrategy: "input",
  pipeStrategy: "all",
  dateStrategy: "format:date-time",
  mapStrategy: "entries",
  nullableStrategy: "from-target",
  removeAdditionalStrategy: "passthrough",
  definitionPath: "definitions",
  target: "jsonSchema7",
  strictUnions: !1,
  errorMessages: !1,
  markdownDescription: !1,
  patternStrategy: "escape",
  applyRegexFlags: !1,
  emailStrategy: "format:email",
  base64Strategy: "contentEncoding:base64",
  nameStrategy: "ref"
}, d$ = (r) => typeof r == "string" ? {
  ...pf,
  basePath: ["#"],
  definitions: {},
  name: r
} : {
  ...pf,
  basePath: ["#"],
  definitions: {},
  ...r
}, pu = (r) => "_def" in r ? r._def : r;
function h$(r) {
  if (!r)
    return !0;
  for (const e in r)
    return !1;
  return !0;
}
const f$ = (r) => {
  const e = d$(r), t = e.name !== void 0 ? [...e.basePath, e.definitionPath, e.name] : e.basePath;
  return {
    ...e,
    currentPath: t,
    propertyPath: void 0,
    seenRefs: /* @__PURE__ */ new Set(),
    seen: new Map(Object.entries(e.definitions).map(([n, s]) => [
      pu(s),
      {
        def: pu(s),
        path: [...e.basePath, e.definitionPath, n],
        // Resolution of references will be forced even though seen, so it's ok that the schema is undefined here for now.
        jsonSchema: void 0
      }
    ]))
  };
};
function L_(r, e, t, n) {
  n != null && n.errorMessages && t && (r.errorMessage = {
    ...r.errorMessage,
    [e]: t
  });
}
function je(r, e, t, n, s) {
  r[e] = t, L_(r, e, n, s);
}
function p$() {
  return {};
}
function m$(r, e) {
  var n, s;
  const t = {
    type: "array"
  };
  return ((s = (n = r.type) == null ? void 0 : n._def) == null ? void 0 : s.typeName) !== C.ZodAny && (t.items = Ne(r.type._def, {
    ...e,
    currentPath: [...e.currentPath, "items"]
  })), r.minLength && je(t, "minItems", r.minLength.value, r.minLength.message, e), r.maxLength && je(t, "maxItems", r.maxLength.value, r.maxLength.message, e), r.exactLength && (je(t, "minItems", r.exactLength.value, r.exactLength.message, e), je(t, "maxItems", r.exactLength.value, r.exactLength.message, e)), t;
}
function g$(r, e) {
  const t = {
    type: "integer",
    format: "int64"
  };
  if (!r.checks)
    return t;
  for (const n of r.checks)
    switch (n.kind) {
      case "min":
        e.target === "jsonSchema7" ? n.inclusive ? je(t, "minimum", n.value, n.message, e) : je(t, "exclusiveMinimum", n.value, n.message, e) : (n.inclusive || (t.exclusiveMinimum = !0), je(t, "minimum", n.value, n.message, e));
        break;
      case "max":
        e.target === "jsonSchema7" ? n.inclusive ? je(t, "maximum", n.value, n.message, e) : je(t, "exclusiveMaximum", n.value, n.message, e) : (n.inclusive || (t.exclusiveMaximum = !0), je(t, "maximum", n.value, n.message, e));
        break;
      case "multipleOf":
        je(t, "multipleOf", n.value, n.message, e);
        break;
    }
  return t;
}
function _$() {
  return {
    type: "boolean"
  };
}
function y$(r, e) {
  return Ne(r.type._def, e);
}
const w$ = (r, e) => Ne(r.innerType._def, e);
function M_(r, e, t) {
  const n = t ?? e.dateStrategy;
  if (Array.isArray(n))
    return {
      anyOf: n.map((s, a) => M_(r, e, s))
    };
  switch (n) {
    case "string":
    case "format:date-time":
      return {
        type: "string",
        format: "date-time"
      };
    case "format:date":
      return {
        type: "string",
        format: "date"
      };
    case "integer":
      return v$(r, e);
  }
}
const v$ = (r, e) => {
  const t = {
    type: "integer",
    format: "unix-time"
  };
  if (e.target === "openApi3")
    return t;
  for (const n of r.checks)
    switch (n.kind) {
      case "min":
        je(
          t,
          "minimum",
          n.value,
          // This is in milliseconds
          n.message,
          e
        );
        break;
      case "max":
        je(
          t,
          "maximum",
          n.value,
          // This is in milliseconds
          n.message,
          e
        );
        break;
    }
  return t;
};
function b$(r, e) {
  return {
    ...Ne(r.innerType._def, e),
    default: r.defaultValue()
  };
}
function S$(r, e, t) {
  return e.effectStrategy === "input" ? Ne(r.schema._def, e, t) : {};
}
function T$(r) {
  return {
    type: "string",
    enum: [...r.values]
  };
}
const E$ = (r) => "type" in r && r.type === "string" ? !1 : "allOf" in r;
function x$(r, e) {
  const t = [
    Ne(r.left._def, {
      ...e,
      currentPath: [...e.currentPath, "allOf", "0"]
    }),
    Ne(r.right._def, {
      ...e,
      currentPath: [...e.currentPath, "allOf", "1"]
    })
  ].filter((a) => !!a);
  let n = e.target === "jsonSchema2019-09" ? { unevaluatedProperties: !1 } : void 0;
  const s = [];
  return t.forEach((a) => {
    if (E$(a))
      s.push(...a.allOf), a.unevaluatedProperties === void 0 && (n = void 0);
    else {
      let i = a;
      if ("additionalProperties" in a && a.additionalProperties === !1) {
        const { additionalProperties: o, ...c } = a;
        i = c;
      } else
        n = void 0;
      s.push(i);
    }
  }), s.length ? {
    allOf: s,
    ...n
  } : void 0;
}
function k$(r, e) {
  const t = typeof r.value;
  return t !== "bigint" && t !== "number" && t !== "boolean" && t !== "string" ? {
    type: Array.isArray(r.value) ? "array" : "object"
  } : e.target === "openApi3" ? {
    type: t === "bigint" ? "integer" : t,
    enum: [r.value]
  } : {
    type: t === "bigint" ? "integer" : t,
    const: r.value
  };
}
let mc;
const fn = {
  /**
   * `c` was changed to `[cC]` to replicate /i flag
   */
  cuid: /^[cC][^\s-]{8,}$/,
  cuid2: /^[0-9a-z]+$/,
  ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,
  /**
   * `a-z` was added to replicate /i flag
   */
  email: /^(?!\.)(?!.*\.\.)([a-zA-Z0-9_'+\-\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\-]*\.)+[a-zA-Z]{2,}$/,
  /**
   * Constructed a valid Unicode RegExp
   *
   * Lazily instantiate since this type of regex isn't supported
   * in all envs (e.g. React Native).
   *
   * See:
   * https://github.com/colinhacks/zod/issues/2433
   * Fix in Zod:
   * https://github.com/colinhacks/zod/commit/9340fd51e48576a75adc919bff65dbc4a5d4c99b
   */
  emoji: () => (mc === void 0 && (mc = RegExp("^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$", "u")), mc),
  base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
  nanoid: /^[a-zA-Z0-9_-]{21}$/
};
function D_(r, e) {
  const t = {
    type: "string"
  };
  function n(s) {
    return e.patternStrategy === "escape" ? I$(s) : s;
  }
  if (r.checks)
    for (const s of r.checks)
      switch (s.kind) {
        case "min":
          je(t, "minLength", typeof t.minLength == "number" ? Math.max(t.minLength, s.value) : s.value, s.message, e);
          break;
        case "max":
          je(t, "maxLength", typeof t.maxLength == "number" ? Math.min(t.maxLength, s.value) : s.value, s.message, e);
          break;
        case "email":
          switch (e.emailStrategy) {
            case "format:email":
              tr(t, "email", s.message, e);
              break;
            case "format:idn-email":
              tr(t, "idn-email", s.message, e);
              break;
            case "pattern:zod":
              rr(t, fn.email, s.message, e);
              break;
          }
          break;
        case "url":
          tr(t, "uri", s.message, e);
          break;
        case "uuid":
          tr(t, "uuid", s.message, e);
          break;
        case "regex":
          rr(t, s.regex, s.message, e);
          break;
        case "cuid":
          rr(t, fn.cuid, s.message, e);
          break;
        case "cuid2":
          rr(t, fn.cuid2, s.message, e);
          break;
        case "startsWith":
          rr(t, RegExp(`^${n(s.value)}`), s.message, e);
          break;
        case "endsWith":
          rr(t, RegExp(`${n(s.value)}$`), s.message, e);
          break;
        case "datetime":
          tr(t, "date-time", s.message, e);
          break;
        case "date":
          tr(t, "date", s.message, e);
          break;
        case "time":
          tr(t, "time", s.message, e);
          break;
        case "duration":
          tr(t, "duration", s.message, e);
          break;
        case "length":
          je(t, "minLength", typeof t.minLength == "number" ? Math.max(t.minLength, s.value) : s.value, s.message, e), je(t, "maxLength", typeof t.maxLength == "number" ? Math.min(t.maxLength, s.value) : s.value, s.message, e);
          break;
        case "includes": {
          rr(t, RegExp(n(s.value)), s.message, e);
          break;
        }
        case "ip": {
          s.version !== "v6" && tr(t, "ipv4", s.message, e), s.version !== "v4" && tr(t, "ipv6", s.message, e);
          break;
        }
        case "emoji":
          rr(t, fn.emoji, s.message, e);
          break;
        case "ulid": {
          rr(t, fn.ulid, s.message, e);
          break;
        }
        case "base64": {
          switch (e.base64Strategy) {
            case "format:binary": {
              tr(t, "binary", s.message, e);
              break;
            }
            case "contentEncoding:base64": {
              je(t, "contentEncoding", "base64", s.message, e);
              break;
            }
            case "pattern:zod": {
              rr(t, fn.base64, s.message, e);
              break;
            }
          }
          break;
        }
        case "nanoid":
          rr(t, fn.nanoid, s.message, e);
      }
  return t;
}
const I$ = (r) => Array.from(r).map((e) => /[a-zA-Z0-9]/.test(e) ? e : `\\${e}`).join(""), tr = (r, e, t, n) => {
  var s;
  r.format || (s = r.anyOf) != null && s.some((a) => a.format) ? (r.anyOf || (r.anyOf = []), r.format && (r.anyOf.push({
    format: r.format,
    ...r.errorMessage && n.errorMessages && {
      errorMessage: { format: r.errorMessage.format }
    }
  }), delete r.format, r.errorMessage && (delete r.errorMessage.format, Object.keys(r.errorMessage).length === 0 && delete r.errorMessage)), r.anyOf.push({
    format: e,
    ...t && n.errorMessages && { errorMessage: { format: t } }
  })) : je(r, "format", e, t, n);
}, rr = (r, e, t, n) => {
  var s;
  r.pattern || (s = r.allOf) != null && s.some((a) => a.pattern) ? (r.allOf || (r.allOf = []), r.pattern && (r.allOf.push({
    pattern: r.pattern,
    ...r.errorMessage && n.errorMessages && {
      errorMessage: { pattern: r.errorMessage.pattern }
    }
  }), delete r.pattern, r.errorMessage && (delete r.errorMessage.pattern, Object.keys(r.errorMessage).length === 0 && delete r.errorMessage)), r.allOf.push({
    pattern: mf(e, n),
    ...t && n.errorMessages && { errorMessage: { pattern: t } }
  })) : je(r, "pattern", mf(e, n), t, n);
}, mf = (r, e) => {
  var u;
  const t = typeof r == "function" ? r() : r;
  if (!e.applyRegexFlags || !t.flags)
    return t.source;
  const n = {
    i: t.flags.includes("i"),
    // Case-insensitive
    m: t.flags.includes("m"),
    // `^` and `$` matches adjacent to newline characters
    s: t.flags.includes("s")
    // `.` matches newlines
  }, s = n.i ? t.source.toLowerCase() : t.source;
  let a = "", i = !1, o = !1, c = !1;
  for (let l = 0; l < s.length; l++) {
    if (i) {
      a += s[l], i = !1;
      continue;
    }
    if (n.i) {
      if (o) {
        if (s[l].match(/[a-z]/)) {
          c ? (a += s[l], a += `${s[l - 2]}-${s[l]}`.toUpperCase(), c = !1) : s[l + 1] === "-" && ((u = s[l + 2]) != null && u.match(/[a-z]/)) ? (a += s[l], c = !0) : a += `${s[l]}${s[l].toUpperCase()}`;
          continue;
        }
      } else if (s[l].match(/[a-z]/)) {
        a += `[${s[l]}${s[l].toUpperCase()}]`;
        continue;
      }
    }
    if (n.m) {
      if (s[l] === "^") {
        a += `(^|(?<=[\r
]))`;
        continue;
      } else if (s[l] === "$") {
        a += `($|(?=[\r
]))`;
        continue;
      }
    }
    if (n.s && s[l] === ".") {
      a += o ? `${s[l]}\r
` : `[${s[l]}\r
]`;
      continue;
    }
    a += s[l], s[l] === "\\" ? i = !0 : o && s[l] === "]" ? o = !1 : !o && s[l] === "[" && (o = !0);
  }
  try {
    const l = new RegExp(a);
  } catch {
    return console.warn(`Could not convert regex pattern at ${e.currentPath.join("/")} to a flag-independent form! Falling back to the flag-ignorant source`), t.source;
  }
  return a;
};
function j_(r, e) {
  var n, s, a, i;
  if (e.target === "openApi3" && ((n = r.keyType) == null ? void 0 : n._def.typeName) === C.ZodEnum)
    return {
      type: "object",
      required: r.keyType._def.values,
      properties: r.keyType._def.values.reduce((o, c) => ({
        ...o,
        [c]: Ne(r.valueType._def, {
          ...e,
          currentPath: [...e.currentPath, "properties", c]
        }) ?? {}
      }), {}),
      additionalProperties: !1
    };
  const t = {
    type: "object",
    additionalProperties: Ne(r.valueType._def, {
      ...e,
      currentPath: [...e.currentPath, "additionalProperties"]
    }) ?? {}
  };
  if (e.target === "openApi3")
    return t;
  if (((s = r.keyType) == null ? void 0 : s._def.typeName) === C.ZodString && ((a = r.keyType._def.checks) != null && a.length)) {
    const o = Object.entries(D_(r.keyType._def, e)).reduce((c, [u, l]) => u === "type" ? c : { ...c, [u]: l }, {});
    return {
      ...t,
      propertyNames: o
    };
  } else if (((i = r.keyType) == null ? void 0 : i._def.typeName) === C.ZodEnum)
    return {
      ...t,
      propertyNames: {
        enum: r.keyType._def.values
      }
    };
  return t;
}
function O$(r, e) {
  if (e.mapStrategy === "record")
    return j_(r, e);
  const t = Ne(r.keyType._def, {
    ...e,
    currentPath: [...e.currentPath, "items", "items", "0"]
  }) || {}, n = Ne(r.valueType._def, {
    ...e,
    currentPath: [...e.currentPath, "items", "items", "1"]
  }) || {};
  return {
    type: "array",
    maxItems: 125,
    items: {
      type: "array",
      items: [t, n],
      minItems: 2,
      maxItems: 2
    }
  };
}
function A$(r) {
  const e = r.values, n = Object.keys(r.values).filter((a) => typeof e[e[a]] != "number").map((a) => e[a]), s = Array.from(new Set(n.map((a) => typeof a)));
  return {
    type: s.length === 1 ? s[0] === "string" ? "string" : "number" : ["string", "number"],
    enum: n
  };
}
function $$() {
  return {
    not: {}
  };
}
function C$(r) {
  return r.target === "openApi3" ? {
    enum: ["null"],
    nullable: !0
  } : {
    type: "null"
  };
}
const qi = {
  ZodString: "string",
  ZodNumber: "number",
  ZodBigInt: "integer",
  ZodBoolean: "boolean",
  ZodNull: "null"
};
function R$(r, e) {
  if (e.target === "openApi3")
    return gf(r, e);
  const t = r.options instanceof Map ? Array.from(r.options.values()) : r.options;
  if (t.every((n) => n._def.typeName in qi && (!n._def.checks || !n._def.checks.length))) {
    const n = t.reduce((s, a) => {
      const i = qi[a._def.typeName];
      return i && !s.includes(i) ? [...s, i] : s;
    }, []);
    return {
      type: n.length > 1 ? n : n[0]
    };
  } else if (t.every((n) => n._def.typeName === "ZodLiteral" && !n.description)) {
    const n = t.reduce((s, a) => {
      const i = typeof a._def.value;
      switch (i) {
        case "string":
        case "number":
        case "boolean":
          return [...s, i];
        case "bigint":
          return [...s, "integer"];
        case "object":
          if (a._def.value === null)
            return [...s, "null"];
        case "symbol":
        case "undefined":
        case "function":
        default:
          return s;
      }
    }, []);
    if (n.length === t.length) {
      const s = n.filter((a, i, o) => o.indexOf(a) === i);
      return {
        type: s.length > 1 ? s : s[0],
        enum: t.reduce((a, i) => a.includes(i._def.value) ? a : [...a, i._def.value], [])
      };
    }
  } else if (t.every((n) => n._def.typeName === "ZodEnum"))
    return {
      type: "string",
      enum: t.reduce((n, s) => [...n, ...s._def.values.filter((a) => !n.includes(a))], [])
    };
  return gf(r, e);
}
const gf = (r, e) => {
  const t = (r.options instanceof Map ? Array.from(r.options.values()) : r.options).map((n, s) => Ne(n._def, {
    ...e,
    currentPath: [...e.currentPath, "anyOf", `${s}`]
  })).filter((n) => !!n && (!e.strictUnions || typeof n == "object" && Object.keys(n).length > 0));
  return t.length ? { anyOf: t } : void 0;
};
function N$(r, e) {
  if (["ZodString", "ZodNumber", "ZodBigInt", "ZodBoolean", "ZodNull"].includes(r.innerType._def.typeName) && (!r.innerType._def.checks || !r.innerType._def.checks.length))
    return e.target === "openApi3" || e.nullableStrategy === "property" ? {
      type: qi[r.innerType._def.typeName],
      nullable: !0
    } : {
      type: [qi[r.innerType._def.typeName], "null"]
    };
  if (e.target === "openApi3") {
    const n = Ne(r.innerType._def, {
      ...e,
      currentPath: [...e.currentPath]
    });
    return n && "$ref" in n ? { allOf: [n], nullable: !0 } : n && { ...n, nullable: !0 };
  }
  const t = Ne(r.innerType._def, {
    ...e,
    currentPath: [...e.currentPath, "anyOf", "0"]
  });
  return t && { anyOf: [t, { type: "null" }] };
}
function P$(r, e) {
  const t = {
    type: "number"
  };
  if (!r.checks)
    return t;
  for (const n of r.checks)
    switch (n.kind) {
      case "int":
        t.type = "integer", L_(t, "type", n.message, e);
        break;
      case "min":
        e.target === "jsonSchema7" ? n.inclusive ? je(t, "minimum", n.value, n.message, e) : je(t, "exclusiveMinimum", n.value, n.message, e) : (n.inclusive || (t.exclusiveMinimum = !0), je(t, "minimum", n.value, n.message, e));
        break;
      case "max":
        e.target === "jsonSchema7" ? n.inclusive ? je(t, "maximum", n.value, n.message, e) : je(t, "exclusiveMaximum", n.value, n.message, e) : (n.inclusive || (t.exclusiveMaximum = !0), je(t, "maximum", n.value, n.message, e));
        break;
      case "multipleOf":
        je(t, "multipleOf", n.value, n.message, e);
        break;
    }
  return t;
}
function L$(r, e) {
  return e.removeAdditionalStrategy === "strict" ? r.catchall._def.typeName === "ZodNever" ? r.unknownKeys !== "strict" : Ne(r.catchall._def, {
    ...e,
    currentPath: [...e.currentPath, "additionalProperties"]
  }) ?? !0 : r.catchall._def.typeName === "ZodNever" ? r.unknownKeys === "passthrough" : Ne(r.catchall._def, {
    ...e,
    currentPath: [...e.currentPath, "additionalProperties"]
  }) ?? !0;
}
function M$(r, e) {
  const t = {
    type: "object",
    ...Object.entries(r.shape()).reduce((n, [s, a]) => {
      var c;
      if (a === void 0 || a._def === void 0)
        return n;
      const i = [...e.currentPath, "properties", s], o = Ne(a._def, {
        ...e,
        currentPath: i,
        propertyPath: i
      });
      if (o === void 0)
        return n;
      if (e.openaiStrictMode && a.isOptional() && !a.isNullable() && typeof ((c = a._def) == null ? void 0 : c.defaultValue) > "u")
        throw new Error(`Zod field at \`${i.join("/")}\` uses \`.optional()\` without \`.nullable()\` which is not supported by the API. See: https://platform.openai.com/docs/guides/structured-outputs?api-mode=responses#all-fields-must-be-required`);
      return {
        properties: {
          ...n.properties,
          [s]: o
        },
        required: a.isOptional() && !e.openaiStrictMode ? n.required : [...n.required, s]
      };
    }, { properties: {}, required: [] }),
    additionalProperties: L$(r, e)
  };
  return t.required.length || delete t.required, t;
}
const D$ = (r, e) => {
  if (e.propertyPath && e.currentPath.slice(0, e.propertyPath.length).toString() === e.propertyPath.toString())
    return Ne(r.innerType._def, { ...e, currentPath: e.currentPath });
  const t = Ne(r.innerType._def, {
    ...e,
    currentPath: [...e.currentPath, "anyOf", "1"]
  });
  return t ? {
    anyOf: [
      {
        not: {}
      },
      t
    ]
  } : {};
}, j$ = (r, e) => {
  if (e.pipeStrategy === "input")
    return Ne(r.in._def, e);
  if (e.pipeStrategy === "output")
    return Ne(r.out._def, e);
  const t = Ne(r.in._def, {
    ...e,
    currentPath: [...e.currentPath, "allOf", "0"]
  }), n = Ne(r.out._def, {
    ...e,
    currentPath: [...e.currentPath, "allOf", t ? "1" : "0"]
  });
  return {
    allOf: [t, n].filter((s) => s !== void 0)
  };
};
function F$(r, e) {
  return Ne(r.type._def, e);
}
function U$(r, e) {
  const n = {
    type: "array",
    uniqueItems: !0,
    items: Ne(r.valueType._def, {
      ...e,
      currentPath: [...e.currentPath, "items"]
    })
  };
  return r.minSize && je(n, "minItems", r.minSize.value, r.minSize.message, e), r.maxSize && je(n, "maxItems", r.maxSize.value, r.maxSize.message, e), n;
}
function z$(r, e) {
  return r.rest ? {
    type: "array",
    minItems: r.items.length,
    items: r.items.map((t, n) => Ne(t._def, {
      ...e,
      currentPath: [...e.currentPath, "items", `${n}`]
    })).reduce((t, n) => n === void 0 ? t : [...t, n], []),
    additionalItems: Ne(r.rest._def, {
      ...e,
      currentPath: [...e.currentPath, "additionalItems"]
    })
  } : {
    type: "array",
    minItems: r.items.length,
    maxItems: r.items.length,
    items: r.items.map((t, n) => Ne(t._def, {
      ...e,
      currentPath: [...e.currentPath, "items", `${n}`]
    })).reduce((t, n) => n === void 0 ? t : [...t, n], [])
  };
}
function B$() {
  return {
    not: {}
  };
}
function Z$() {
  return {};
}
const V$ = (r, e) => Ne(r.innerType._def, e);
function Ne(r, e, t = !1) {
  var i;
  const n = e.seen.get(r);
  if (e.override) {
    const o = (i = e.override) == null ? void 0 : i.call(e, r, e, n, t);
    if (o !== l$)
      return o;
  }
  if (n && !t) {
    const o = q$(n, e);
    if (o !== void 0)
      return "$ref" in o && e.seenRefs.add(o.$ref), o;
  }
  const s = { def: r, path: e.currentPath, jsonSchema: void 0 };
  e.seen.set(r, s);
  const a = H$(r, r.typeName, e, t);
  return a && G$(r, e, a), s.jsonSchema = a, a;
}
const q$ = (r, e) => {
  switch (e.$refStrategy) {
    case "root":
      return { $ref: r.path.join("/") };
    case "extract-to-root":
      const t = r.path.slice(e.basePath.length + 1).join("_");
      return t !== e.name && e.nameStrategy === "duplicate-ref" && (e.definitions[t] = r.def), { $ref: [...e.basePath, e.definitionPath, t].join("/") };
    case "relative":
      return { $ref: J$(e.currentPath, r.path) };
    case "none":
    case "seen":
      return r.path.length < e.currentPath.length && r.path.every((n, s) => e.currentPath[s] === n) ? (console.warn(`Recursive reference detected at ${e.currentPath.join("/")}! Defaulting to any`), {}) : e.$refStrategy === "seen" ? {} : void 0;
  }
}, J$ = (r, e) => {
  let t = 0;
  for (; t < r.length && t < e.length && r[t] === e[t]; t++)
    ;
  return [(r.length - t).toString(), ...e.slice(t)].join("/");
}, H$ = (r, e, t, n) => {
  switch (e) {
    case C.ZodString:
      return D_(r, t);
    case C.ZodNumber:
      return P$(r, t);
    case C.ZodObject:
      return M$(r, t);
    case C.ZodBigInt:
      return g$(r, t);
    case C.ZodBoolean:
      return _$();
    case C.ZodDate:
      return M_(r, t);
    case C.ZodUndefined:
      return B$();
    case C.ZodNull:
      return C$(t);
    case C.ZodArray:
      return m$(r, t);
    case C.ZodUnion:
    case C.ZodDiscriminatedUnion:
      return R$(r, t);
    case C.ZodIntersection:
      return x$(r, t);
    case C.ZodTuple:
      return z$(r, t);
    case C.ZodRecord:
      return j_(r, t);
    case C.ZodLiteral:
      return k$(r, t);
    case C.ZodEnum:
      return T$(r);
    case C.ZodNativeEnum:
      return A$(r);
    case C.ZodNullable:
      return N$(r, t);
    case C.ZodOptional:
      return D$(r, t);
    case C.ZodMap:
      return O$(r, t);
    case C.ZodSet:
      return U$(r, t);
    case C.ZodLazy:
      return Ne(r.getter()._def, t);
    case C.ZodPromise:
      return F$(r, t);
    case C.ZodNaN:
    case C.ZodNever:
      return $$();
    case C.ZodEffects:
      return S$(r, t, n);
    case C.ZodAny:
      return p$();
    case C.ZodUnknown:
      return Z$();
    case C.ZodDefault:
      return b$(r, t);
    case C.ZodBranded:
      return y$(r, t);
    case C.ZodReadonly:
      return V$(r, t);
    case C.ZodCatch:
      return w$(r, t);
    case C.ZodPipeline:
      return j$(r, t);
    case C.ZodFunction:
    case C.ZodVoid:
    case C.ZodSymbol:
      return;
    default:
      return /* @__PURE__ */ ((s) => {
      })();
  }
}, G$ = (r, e, t) => (r.description && (t.description = r.description, e.markdownDescription && (t.markdownDescription = r.description)), t), W$ = (r, e) => {
  const t = f$(e), n = typeof e == "string" ? e : (e == null ? void 0 : e.nameStrategy) === "title" || e == null ? void 0 : e.name, s = Ne(r._def, n === void 0 ? t : {
    ...t,
    currentPath: [...t.basePath, t.definitionPath, n]
  }, !1) ?? {}, a = typeof e == "object" && e.name !== void 0 && e.nameStrategy === "title" ? e.name : void 0;
  a !== void 0 && (s.title = a);
  const i = (() => {
    if (h$(t.definitions))
      return;
    const c = {}, u = /* @__PURE__ */ new Set();
    for (let l = 0; l < 500; l++) {
      const d = Object.entries(t.definitions).filter(([h]) => !u.has(h));
      if (d.length === 0)
        break;
      for (const [h, f] of d)
        c[h] = Ne(pu(f), { ...t, currentPath: [...t.basePath, t.definitionPath, h] }, !0) ?? {}, u.add(h);
    }
    return c;
  })(), o = n === void 0 ? i ? {
    ...s,
    [t.definitionPath]: i
  } : s : t.nameStrategy === "duplicate-ref" ? {
    ...s,
    ...i || t.seenRefs.size ? {
      [t.definitionPath]: {
        ...i,
        // only actually duplicate the schema definition if it was ever referenced
        // otherwise the duplication is completely pointless
        ...t.seenRefs.size ? { [n]: s } : void 0
      }
    } : void 0
  } : {
    $ref: [...t.$refStrategy === "relative" ? [] : t.basePath, t.definitionPath, n].join("/"),
    [t.definitionPath]: {
      ...i,
      [n]: s
    }
  };
  return t.target === "jsonSchema7" ? o.$schema = "http://json-schema.org/draft-07/schema#" : t.target === "jsonSchema2019-09" && (o.$schema = "https://json-schema.org/draft/2019-09/schema#"), o;
};
function K$(r) {
  if (r.type !== "object")
    throw new Error(`Root schema must have type: 'object' but got type: ${r.type ? `'${r.type}'` : "undefined"}`);
  const e = structuredClone(r);
  return Nr(e, [], e);
}
function mu(r) {
  if (typeof r == "boolean")
    return !1;
  if (r.type === "null")
    return !0;
  for (const e of r.oneOf ?? [])
    if (mu(e))
      return !0;
  for (const e of r.anyOf ?? [])
    if (mu(e))
      return !0;
  return !1;
}
function Nr(r, e, t) {
  if (typeof r == "boolean")
    throw new TypeError(`Expected object schema but got boolean; path=${e.join("/")}`);
  if (!gn(r))
    throw new TypeError(`Expected ${JSON.stringify(r)} to be an object; path=${e.join("/")}`);
  const n = r.$defs;
  if (gn(n))
    for (const [h, f] of Object.entries(n))
      Nr(f, [...e, "$defs", h], t);
  const s = r.definitions;
  if (gn(s))
    for (const [h, f] of Object.entries(s))
      Nr(f, [...e, "definitions", h], t);
  r.type === "object" && !("additionalProperties" in r) && (r.additionalProperties = !1);
  const i = r.required ?? [], o = r.properties;
  if (gn(o)) {
    for (const [h, f] of Object.entries(o))
      if (!mu(f) && !i.includes(h))
        throw new Error(`Zod field at \`${[...e, "properties", h].join("/")}\` uses \`.optional()\` without \`.nullable()\` which is not supported by the API. See: https://platform.openai.com/docs/guides/structured-outputs?api-mode=responses#all-fields-must-be-required`);
    r.required = Object.keys(o), r.properties = Object.fromEntries(Object.entries(o).map(([h, f]) => [
      h,
      Nr(f, [...e, "properties", h], t)
    ]));
  }
  const c = r.items;
  gn(c) && (r.items = Nr(c, [...e, "items"], t));
  const u = r.anyOf;
  Array.isArray(u) && (r.anyOf = u.map((h, f) => Nr(h, [...e, "anyOf", String(f)], t)));
  const l = r.allOf;
  if (Array.isArray(l))
    if (l.length === 1) {
      const h = Nr(l[0], [...e, "allOf", "0"], t);
      Object.assign(r, h), delete r.allOf;
    } else
      r.allOf = l.map((h, f) => Nr(h, [...e, "allOf", String(f)], t));
  r.default === null && delete r.default;
  const d = r.$ref;
  if (d && X$(r, 1)) {
    if (typeof d != "string")
      throw new TypeError(`Received non-string $ref - ${d}; path=${e.join("/")}`);
    const h = Y$(t, d);
    if (typeof h == "boolean")
      throw new Error(`Expected \`$ref: ${d}\` to resolve to an object schema but got boolean`);
    if (!gn(h))
      throw new Error(`Expected \`$ref: ${d}\` to resolve to an object but got ${JSON.stringify(h)}`);
    return Object.assign(r, { ...h, ...r }), delete r.$ref, Nr(r, e, t);
  }
  return r;
}
function Y$(r, e) {
  if (!e.startsWith("#/"))
    throw new Error(`Unexpected $ref format ${JSON.stringify(e)}; Does not start with #/`);
  const t = e.slice(2).split("/");
  let n = r;
  for (const s of t) {
    if (!gn(n))
      throw new Error(`encountered non-object entry while resolving ${e} - ${JSON.stringify(n)}`);
    const a = n[s];
    if (a === void 0)
      throw new Error(`Key ${s} not found while resolving ${e}`);
    n = a;
  }
  return n;
}
function gn(r) {
  return typeof r == "object" && r !== null && !Array.isArray(r);
}
function X$(r, e) {
  let t = 0;
  for (const n in r)
    if (t++, t > e)
      return !0;
  return !1;
}
function Q$(r, e) {
  return W$(r, {
    openaiStrictMode: !0,
    name: e.name,
    nameStrategy: "duplicate-ref",
    $refStrategy: "extract-to-root",
    nullableStrategy: "property"
  });
}
function eC(r) {
  return K$(Ri(r, {
    target: "draft-7"
  }));
}
function tC(r) {
  return "_zod" in r;
}
function rC(r, e, t) {
  return dw({
    type: "json_schema",
    json_schema: {
      ...t,
      name: e,
      strict: !0,
      schema: tC(r) ? eC(r) : Q$(r, { name: e })
    }
  }, (n) => r.parse(JSON.parse(n)));
}
const _f = [
  "jsonSchema",
  "functionCalling",
  "jsonMode"
];
function nC(r, e) {
  if (typeof e < "u" && !_f.includes(e)) throw new Error(`Invalid method: ${e}. Supported methods are: ${_f.join(", ")}`);
  const t = !r.startsWith("gpt-3") && !r.startsWith("gpt-4-") && r !== "gpt-4";
  if (t && !e) return "jsonSchema";
  if (!t && e === "jsonSchema") throw new Error(`JSON Schema is not supported for model "${r}". Please use a different method, e.g. "functionCalling" or "jsonMode".`);
  return e ?? "functionCalling";
}
function sC(r, e) {
  const t = { ...r };
  return Object.defineProperties(t, {
    $brand: {
      value: "auto-parseable-response-format",
      enumerable: !1
    },
    $parseRaw: {
      value: e,
      enumerable: !1
    }
  }), t;
}
function aC(r, e, t) {
  if (st(r)) return rC(r, e, t);
  if (qe(r)) return sC({
    type: "json_schema",
    json_schema: {
      ...t,
      name: e,
      strict: !0,
      schema: Ri(r, {
        cycles: "ref",
        reused: "ref",
        override(n) {
          n.jsonSchema.title = e;
        }
      })
    }
  }, (n) => wo(r, JSON.parse(n)));
  throw new Error("Unsupported schema response format");
}
function iC(r, e) {
  if (e && typeof e == "object" && "images" in e && Array.isArray(e.images)) {
    const t = e.images.filter((n) => {
      var s;
      return typeof ((s = n == null ? void 0 : n.image_url) == null ? void 0 : s.url) == "string";
    }).map((n) => ({
      type: "image",
      url: n.image_url.url
    }));
    return [{
      type: "text",
      text: r
    }, ...t];
  }
  return r;
}
const oC = {
  "gpt-4.1-nano": {
    maxInputTokens: 1047576,
    imageInputs: !0,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 32768,
    reasoningOutput: !1,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !0,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0,
    toolChoice: !0
  },
  "text-embedding-3-small": {
    maxInputTokens: 8191,
    imageInputs: !1,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 1536,
    reasoningOutput: !1,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !1,
    structuredOutput: !0,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0,
    toolChoice: !0
  },
  "gpt-4": {
    maxInputTokens: 8192,
    imageInputs: !1,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 8192,
    reasoningOutput: !1,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !0,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0,
    toolChoice: !0
  },
  "o1-pro": {
    maxInputTokens: 2e5,
    imageInputs: !0,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 1e5,
    reasoningOutput: !0,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !0,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0,
    toolChoice: !0
  },
  "gpt-4o-2024-05-13": {
    maxInputTokens: 128e3,
    imageInputs: !0,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 4096,
    reasoningOutput: !1,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !0,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0,
    toolChoice: !0
  },
  "gpt-4o-2024-08-06": {
    maxInputTokens: 128e3,
    imageInputs: !0,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 16384,
    reasoningOutput: !1,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !0,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0,
    toolChoice: !0
  },
  "gpt-4.1-mini": {
    maxInputTokens: 1047576,
    imageInputs: !0,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 32768,
    reasoningOutput: !1,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !0,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0,
    toolChoice: !0
  },
  "o3-deep-research": {
    maxInputTokens: 2e5,
    imageInputs: !0,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 1e5,
    reasoningOutput: !0,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !0,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0,
    toolChoice: !0
  },
  "gpt-3.5-turbo": {
    maxInputTokens: 16385,
    imageInputs: !1,
    audioInputs: !1,
    pdfInputs: !1,
    videoInputs: !1,
    maxOutputTokens: 4096,
    reasoningOutput: !1,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !1,
    structuredOutput: !1,
    imageUrlInputs: !1,
    pdfToolMessage: !1,
    imageToolMessage: !1,
    toolChoice: !0
  },
  "text-embedding-3-large": {
    maxInputTokens: 8191,
    imageInputs: !1,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 3072,
    reasoningOutput: !1,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !1,
    structuredOutput: !0,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0,
    toolChoice: !0
  },
  "gpt-4-turbo": {
    maxInputTokens: 128e3,
    imageInputs: !0,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 4096,
    reasoningOutput: !1,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !0,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0,
    toolChoice: !0
  },
  "o1-preview": {
    maxInputTokens: 128e3,
    imageInputs: !1,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 32768,
    reasoningOutput: !0,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !1,
    structuredOutput: !0,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0,
    toolChoice: !0
  },
  "o3-mini": {
    maxInputTokens: 2e5,
    imageInputs: !1,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 1e5,
    reasoningOutput: !0,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !0,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0,
    toolChoice: !0
  },
  "codex-mini-latest": {
    maxInputTokens: 2e5,
    imageInputs: !1,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 1e5,
    reasoningOutput: !0,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !0,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0,
    toolChoice: !0
  },
  "gpt-5-nano": {
    maxInputTokens: 4e5,
    imageInputs: !0,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 128e3,
    reasoningOutput: !0,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !0,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0,
    toolChoice: !0
  },
  "gpt-5-codex": {
    maxInputTokens: 4e5,
    imageInputs: !0,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 128e3,
    reasoningOutput: !0,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !0,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0,
    toolChoice: !0
  },
  "gpt-4o": {
    maxInputTokens: 128e3,
    imageInputs: !0,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 16384,
    reasoningOutput: !1,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !0,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0,
    toolChoice: !0
  },
  "gpt-4.1": {
    maxInputTokens: 1047576,
    imageInputs: !0,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 32768,
    reasoningOutput: !1,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !0,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0,
    toolChoice: !0
  },
  "o4-mini": {
    maxInputTokens: 2e5,
    imageInputs: !0,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 1e5,
    reasoningOutput: !0,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !0,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0,
    toolChoice: !0
  },
  o1: {
    maxInputTokens: 2e5,
    imageInputs: !0,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 1e5,
    reasoningOutput: !0,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !0,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0,
    toolChoice: !0
  },
  "gpt-5-mini": {
    maxInputTokens: 4e5,
    imageInputs: !0,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 128e3,
    reasoningOutput: !0,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !0,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0,
    toolChoice: !0
  },
  "o1-mini": {
    maxInputTokens: 128e3,
    imageInputs: !1,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 65536,
    reasoningOutput: !0,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !1,
    structuredOutput: !0,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0,
    toolChoice: !0
  },
  "text-embedding-ada-002": {
    maxInputTokens: 8192,
    imageInputs: !1,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 1536,
    reasoningOutput: !1,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !1,
    structuredOutput: !0,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0,
    toolChoice: !0
  },
  "o3-pro": {
    maxInputTokens: 2e5,
    imageInputs: !0,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 1e5,
    reasoningOutput: !0,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !0,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0,
    toolChoice: !0
  },
  "gpt-4o-2024-11-20": {
    maxInputTokens: 128e3,
    imageInputs: !0,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 16384,
    reasoningOutput: !1,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !0,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0,
    toolChoice: !0
  },
  o3: {
    maxInputTokens: 2e5,
    imageInputs: !0,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 1e5,
    reasoningOutput: !0,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !0,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0,
    toolChoice: !0
  },
  "o4-mini-deep-research": {
    maxInputTokens: 2e5,
    imageInputs: !0,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 1e5,
    reasoningOutput: !0,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !0,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0,
    toolChoice: !0
  },
  "gpt-5-chat-latest": {
    maxInputTokens: 4e5,
    imageInputs: !0,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 128e3,
    reasoningOutput: !0,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !1,
    structuredOutput: !0,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0,
    toolChoice: !0
  },
  "gpt-4o-mini": {
    maxInputTokens: 128e3,
    imageInputs: !0,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 16384,
    reasoningOutput: !1,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !0,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0,
    toolChoice: !0
  },
  "gpt-5": {
    maxInputTokens: 4e5,
    imageInputs: !0,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 128e3,
    reasoningOutput: !0,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !0,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0,
    toolChoice: !0
  },
  "gpt-5-pro": {
    maxInputTokens: 4e5,
    imageInputs: !0,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 272e3,
    reasoningOutput: !0,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !0,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0,
    toolChoice: !0
  }
};
var cC = oC, uC = {};
Ae(uC, {
  BasePromptValue: () => $o,
  ChatPromptValue: () => U_,
  ImagePromptValue: () => lC,
  StringPromptValue: () => F_
});
var $o = class extends Yn {
}, F_ = class extends $o {
  constructor(e) {
    super({ value: e });
    b(this, "lc_namespace", ["langchain_core", "prompt_values"]);
    b(this, "lc_serializable", !0);
    b(this, "value");
    this.value = e;
  }
  static lc_name() {
    return "StringPromptValue";
  }
  toString() {
    return this.value;
  }
  toChatMessages() {
    return [new zt(this.value)];
  }
}, U_ = class extends $o {
  constructor(e) {
    Array.isArray(e) && (e = { messages: e });
    super(e);
    b(this, "lc_namespace", ["langchain_core", "prompt_values"]);
    b(this, "lc_serializable", !0);
    b(this, "messages");
    this.messages = e.messages;
  }
  static lc_name() {
    return "ChatPromptValue";
  }
  toString() {
    return al(this.messages);
  }
  toChatMessages() {
    return this.messages;
  }
}, lC = class extends $o {
  constructor(e) {
    "imageUrl" in e || (e = { imageUrl: e });
    super(e);
    b(this, "lc_namespace", ["langchain_core", "prompt_values"]);
    b(this, "lc_serializable", !0);
    b(this, "imageUrl");
    /** @ignore */
    b(this, "value");
    this.imageUrl = e.imageUrl;
  }
  static lc_name() {
    return "ImagePromptValue";
  }
  toString() {
    return this.imageUrl.url;
  }
  toChatMessages() {
    return [new zt({ content: [{
      type: "image_url",
      image_url: {
        detail: this.imageUrl.detail,
        url: this.imageUrl.url
      }
    }] })];
  }
}, Q = "0123456789abcdef".split(""), dC = [
  -2147483648,
  8388608,
  32768,
  128
], nr = [
  24,
  16,
  8,
  0
], qa = [
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
], dt = [];
function hr(r, e) {
  e ? (dt[0] = dt[16] = dt[1] = dt[2] = dt[3] = dt[4] = dt[5] = dt[6] = dt[7] = dt[8] = dt[9] = dt[10] = dt[11] = dt[12] = dt[13] = dt[14] = dt[15] = 0, this.blocks = dt) : this.blocks = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
  ], r ? (this.h0 = 3238371032, this.h1 = 914150663, this.h2 = 812702999, this.h3 = 4144912697, this.h4 = 4290775857, this.h5 = 1750603025, this.h6 = 1694076839, this.h7 = 3204075428) : (this.h0 = 1779033703, this.h1 = 3144134277, this.h2 = 1013904242, this.h3 = 2773480762, this.h4 = 1359893119, this.h5 = 2600822924, this.h6 = 528734635, this.h7 = 1541459225), this.block = this.start = this.bytes = this.hBytes = 0, this.finalized = this.hashed = !1, this.first = !0, this.is224 = r;
}
hr.prototype.update = function(r) {
  if (!this.finalized) {
    var e, t = typeof r;
    if (t !== "string") {
      if (t === "object") {
        if (r === null) throw new Error(ERROR);
        if (ARRAY_BUFFER && r.constructor === ArrayBuffer) r = new Uint8Array(r);
        else if (!Array.isArray(r) && (!ARRAY_BUFFER || !ArrayBuffer.isView(r)))
          throw new Error(ERROR);
      } else throw new Error(ERROR);
      e = !0;
    }
    for (var n, s = 0, a, i = r.length, o = this.blocks; s < i; ) {
      if (this.hashed && (this.hashed = !1, o[0] = this.block, this.block = o[16] = o[1] = o[2] = o[3] = o[4] = o[5] = o[6] = o[7] = o[8] = o[9] = o[10] = o[11] = o[12] = o[13] = o[14] = o[15] = 0), e) for (a = this.start; s < i && a < 64; ++s) o[a >>> 2] |= r[s] << nr[a++ & 3];
      else for (a = this.start; s < i && a < 64; ++s)
        n = r.charCodeAt(s), n < 128 ? o[a >>> 2] |= n << nr[a++ & 3] : n < 2048 ? (o[a >>> 2] |= (192 | n >>> 6) << nr[a++ & 3], o[a >>> 2] |= (128 | n & 63) << nr[a++ & 3]) : n < 55296 || n >= 57344 ? (o[a >>> 2] |= (224 | n >>> 12) << nr[a++ & 3], o[a >>> 2] |= (128 | n >>> 6 & 63) << nr[a++ & 3], o[a >>> 2] |= (128 | n & 63) << nr[a++ & 3]) : (n = 65536 + ((n & 1023) << 10 | r.charCodeAt(++s) & 1023), o[a >>> 2] |= (240 | n >>> 18) << nr[a++ & 3], o[a >>> 2] |= (128 | n >>> 12 & 63) << nr[a++ & 3], o[a >>> 2] |= (128 | n >>> 6 & 63) << nr[a++ & 3], o[a >>> 2] |= (128 | n & 63) << nr[a++ & 3]);
      this.lastByteIndex = a, this.bytes += a - this.start, a >= 64 ? (this.block = o[16], this.start = a - 64, this.hash(), this.hashed = !0) : this.start = a;
    }
    return this.bytes > 4294967295 && (this.hBytes += this.bytes / 4294967296 << 0, this.bytes = this.bytes % 4294967296), this;
  }
};
hr.prototype.finalize = function() {
  if (!this.finalized) {
    this.finalized = !0;
    var r = this.blocks, e = this.lastByteIndex;
    r[16] = this.block, r[e >>> 2] |= dC[e & 3], this.block = r[16], e >= 56 && (this.hashed || this.hash(), r[0] = this.block, r[16] = r[1] = r[2] = r[3] = r[4] = r[5] = r[6] = r[7] = r[8] = r[9] = r[10] = r[11] = r[12] = r[13] = r[14] = r[15] = 0), r[14] = this.hBytes << 3 | this.bytes >>> 29, r[15] = this.bytes << 3, this.hash();
  }
};
hr.prototype.hash = function() {
  var r = this.h0, e = this.h1, t = this.h2, n = this.h3, s = this.h4, a = this.h5, i = this.h6, o = this.h7, c = this.blocks, u, l, d, h, f, p, y, m, v, g, w;
  for (u = 16; u < 64; ++u)
    f = c[u - 15], l = (f >>> 7 | f << 25) ^ (f >>> 18 | f << 14) ^ f >>> 3, f = c[u - 2], d = (f >>> 17 | f << 15) ^ (f >>> 19 | f << 13) ^ f >>> 10, c[u] = c[u - 16] + l + c[u - 7] + d << 0;
  for (w = e & t, u = 0; u < 64; u += 4)
    this.first ? (this.is224 ? (m = 300032, f = c[0] - 1413257819, o = f - 150054599 << 0, n = f + 24177077 << 0) : (m = 704751109, f = c[0] - 210244248, o = f - 1521486534 << 0, n = f + 143694565 << 0), this.first = !1) : (l = (r >>> 2 | r << 30) ^ (r >>> 13 | r << 19) ^ (r >>> 22 | r << 10), d = (s >>> 6 | s << 26) ^ (s >>> 11 | s << 21) ^ (s >>> 25 | s << 7), m = r & e, h = m ^ r & t ^ w, y = s & a ^ ~s & i, f = o + d + y + qa[u] + c[u], p = l + h, o = n + f << 0, n = f + p << 0), l = (n >>> 2 | n << 30) ^ (n >>> 13 | n << 19) ^ (n >>> 22 | n << 10), d = (o >>> 6 | o << 26) ^ (o >>> 11 | o << 21) ^ (o >>> 25 | o << 7), v = n & r, h = v ^ n & e ^ m, y = i & o ^ ~i & s, f = a + d + y + qa[u + 1] + c[u + 1], p = l + h, i = t + f << 0, t = f + p << 0, l = (t >>> 2 | t << 30) ^ (t >>> 13 | t << 19) ^ (t >>> 22 | t << 10), d = (i >>> 6 | i << 26) ^ (i >>> 11 | i << 21) ^ (i >>> 25 | i << 7), g = t & n, h = g ^ t & r ^ v, y = a & i ^ ~a & o, f = s + d + y + qa[u + 2] + c[u + 2], p = l + h, a = e + f << 0, e = f + p << 0, l = (e >>> 2 | e << 30) ^ (e >>> 13 | e << 19) ^ (e >>> 22 | e << 10), d = (a >>> 6 | a << 26) ^ (a >>> 11 | a << 21) ^ (a >>> 25 | a << 7), w = e & t, h = w ^ e & n ^ g, y = a & i ^ ~a & o, f = s + d + y + qa[u + 3] + c[u + 3], p = l + h, s = r + f << 0, r = f + p << 0, this.chromeBugWorkAround = !0;
  this.h0 = this.h0 + r << 0, this.h1 = this.h1 + e << 0, this.h2 = this.h2 + t << 0, this.h3 = this.h3 + n << 0, this.h4 = this.h4 + s << 0, this.h5 = this.h5 + a << 0, this.h6 = this.h6 + i << 0, this.h7 = this.h7 + o << 0;
};
hr.prototype.hex = function() {
  this.finalize();
  var r = this.h0, e = this.h1, t = this.h2, n = this.h3, s = this.h4, a = this.h5, i = this.h6, o = this.h7, c = Q[r >>> 28 & 15] + Q[r >>> 24 & 15] + Q[r >>> 20 & 15] + Q[r >>> 16 & 15] + Q[r >>> 12 & 15] + Q[r >>> 8 & 15] + Q[r >>> 4 & 15] + Q[r & 15] + Q[e >>> 28 & 15] + Q[e >>> 24 & 15] + Q[e >>> 20 & 15] + Q[e >>> 16 & 15] + Q[e >>> 12 & 15] + Q[e >>> 8 & 15] + Q[e >>> 4 & 15] + Q[e & 15] + Q[t >>> 28 & 15] + Q[t >>> 24 & 15] + Q[t >>> 20 & 15] + Q[t >>> 16 & 15] + Q[t >>> 12 & 15] + Q[t >>> 8 & 15] + Q[t >>> 4 & 15] + Q[t & 15] + Q[n >>> 28 & 15] + Q[n >>> 24 & 15] + Q[n >>> 20 & 15] + Q[n >>> 16 & 15] + Q[n >>> 12 & 15] + Q[n >>> 8 & 15] + Q[n >>> 4 & 15] + Q[n & 15] + Q[s >>> 28 & 15] + Q[s >>> 24 & 15] + Q[s >>> 20 & 15] + Q[s >>> 16 & 15] + Q[s >>> 12 & 15] + Q[s >>> 8 & 15] + Q[s >>> 4 & 15] + Q[s & 15] + Q[a >>> 28 & 15] + Q[a >>> 24 & 15] + Q[a >>> 20 & 15] + Q[a >>> 16 & 15] + Q[a >>> 12 & 15] + Q[a >>> 8 & 15] + Q[a >>> 4 & 15] + Q[a & 15] + Q[i >>> 28 & 15] + Q[i >>> 24 & 15] + Q[i >>> 20 & 15] + Q[i >>> 16 & 15] + Q[i >>> 12 & 15] + Q[i >>> 8 & 15] + Q[i >>> 4 & 15] + Q[i & 15];
  return this.is224 || (c += Q[o >>> 28 & 15] + Q[o >>> 24 & 15] + Q[o >>> 20 & 15] + Q[o >>> 16 & 15] + Q[o >>> 12 & 15] + Q[o >>> 8 & 15] + Q[o >>> 4 & 15] + Q[o & 15]), c;
};
hr.prototype.toString = hr.prototype.hex;
hr.prototype.digest = function() {
  this.finalize();
  var r = this.h0, e = this.h1, t = this.h2, n = this.h3, s = this.h4, a = this.h5, i = this.h6, o = this.h7, c = [
    r >>> 24 & 255,
    r >>> 16 & 255,
    r >>> 8 & 255,
    r & 255,
    e >>> 24 & 255,
    e >>> 16 & 255,
    e >>> 8 & 255,
    e & 255,
    t >>> 24 & 255,
    t >>> 16 & 255,
    t >>> 8 & 255,
    t & 255,
    n >>> 24 & 255,
    n >>> 16 & 255,
    n >>> 8 & 255,
    n & 255,
    s >>> 24 & 255,
    s >>> 16 & 255,
    s >>> 8 & 255,
    s & 255,
    a >>> 24 & 255,
    a >>> 16 & 255,
    a >>> 8 & 255,
    a & 255,
    i >>> 24 & 255,
    i >>> 16 & 255,
    i >>> 8 & 255,
    i & 255
  ];
  return this.is224 || c.push(o >>> 24 & 255, o >>> 16 & 255, o >>> 8 & 255, o & 255), c;
};
hr.prototype.array = hr.prototype.digest;
hr.prototype.arrayBuffer = function() {
  this.finalize();
  var r = /* @__PURE__ */ new ArrayBuffer(this.is224 ? 28 : 32), e = new DataView(r);
  return e.setUint32(0, this.h0), e.setUint32(4, this.h1), e.setUint32(8, this.h2), e.setUint32(12, this.h3), e.setUint32(16, this.h4), e.setUint32(20, this.h5), e.setUint32(24, this.h6), this.is224 || e.setUint32(28, this.h7), r;
};
const z_ = (...r) => new hr(!1, !0).update(r.join("")).hex();
var hC = {};
Ae(hC, { sha256: () => z_ });
var fC = {};
Ae(fC, {
  BaseCache: () => Z_,
  InMemoryCache: () => V_,
  defaultHashKeyEncoder: () => B_,
  deserializeStoredGeneration: () => pC,
  serializeGeneration: () => mC
});
const B_ = (...r) => z_(r.join("_"));
function pC(r) {
  return r.message !== void 0 ? {
    text: r.text,
    message: il(r.message)
  } : { text: r.text };
}
function mC(r) {
  const e = { text: r.text };
  return r.message !== void 0 && (e.message = r.message.toDict()), e;
}
var Z_ = class {
  constructor() {
    b(this, "keyEncoder", B_);
  }
  /**
  * Sets a custom key encoder function for the cache.
  * This function should take a prompt and an LLM key and return a string
  * that will be used as the cache key.
  * @param keyEncoderFn The custom key encoder function.
  */
  makeDefaultKeyEncoder(r) {
    this.keyEncoder = r;
  }
};
const gC = /* @__PURE__ */ new Map();
var V_ = class q_ extends Z_ {
  constructor(t) {
    super();
    b(this, "cache");
    this.cache = t ?? /* @__PURE__ */ new Map();
  }
  /**
  * Retrieves data from the cache using a prompt and an LLM key. If the
  * data is not found, it returns null.
  * @param prompt The prompt used to find the data.
  * @param llmKey The LLM key used to find the data.
  * @returns The data corresponding to the prompt and LLM key, or null if not found.
  */
  lookup(t, n) {
    return Promise.resolve(this.cache.get(this.keyEncoder(t, n)) ?? null);
  }
  /**
  * Updates the cache with new data using a prompt and an LLM key.
  * @param prompt The prompt used to store the data.
  * @param llmKey The LLM key used to store the data.
  * @param value The data to be stored.
  */
  async update(t, n, s) {
    this.cache.set(this.keyEncoder(t, n), s);
  }
  /**
  * Returns a global instance of InMemoryCache using a predefined global
  * map as the initial cache.
  * @returns A global instance of InMemoryCache.
  */
  static global() {
    return new q_(gC);
  }
}, Co = {};
Co.byteLength = wC;
Co.toByteArray = bC;
Co.fromByteArray = EC;
var wr = [], Gt = [], _C = typeof Uint8Array < "u" ? Uint8Array : Array, gc = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var Mn = 0, yC = gc.length; Mn < yC; ++Mn)
  wr[Mn] = gc[Mn], Gt[gc.charCodeAt(Mn)] = Mn;
Gt[45] = 62;
Gt[95] = 63;
function J_(r) {
  var e = r.length;
  if (e % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var t = r.indexOf("=");
  t === -1 && (t = e);
  var n = t === e ? 0 : 4 - t % 4;
  return [t, n];
}
function wC(r) {
  var e = J_(r), t = e[0], n = e[1];
  return (t + n) * 3 / 4 - n;
}
function vC(r, e, t) {
  return (e + t) * 3 / 4 - t;
}
function bC(r) {
  var e, t = J_(r), n = t[0], s = t[1], a = new _C(vC(r, n, s)), i = 0, o = s > 0 ? n - 4 : n, c;
  for (c = 0; c < o; c += 4)
    e = Gt[r.charCodeAt(c)] << 18 | Gt[r.charCodeAt(c + 1)] << 12 | Gt[r.charCodeAt(c + 2)] << 6 | Gt[r.charCodeAt(c + 3)], a[i++] = e >> 16 & 255, a[i++] = e >> 8 & 255, a[i++] = e & 255;
  return s === 2 && (e = Gt[r.charCodeAt(c)] << 2 | Gt[r.charCodeAt(c + 1)] >> 4, a[i++] = e & 255), s === 1 && (e = Gt[r.charCodeAt(c)] << 10 | Gt[r.charCodeAt(c + 1)] << 4 | Gt[r.charCodeAt(c + 2)] >> 2, a[i++] = e >> 8 & 255, a[i++] = e & 255), a;
}
function SC(r) {
  return wr[r >> 18 & 63] + wr[r >> 12 & 63] + wr[r >> 6 & 63] + wr[r & 63];
}
function TC(r, e, t) {
  for (var n, s = [], a = e; a < t; a += 3)
    n = (r[a] << 16 & 16711680) + (r[a + 1] << 8 & 65280) + (r[a + 2] & 255), s.push(SC(n));
  return s.join("");
}
function EC(r) {
  for (var e, t = r.length, n = t % 3, s = [], a = 16383, i = 0, o = t - n; i < o; i += a)
    s.push(TC(r, i, i + a > o ? o : i + a));
  return n === 1 ? (e = r[t - 1], s.push(
    wr[e >> 2] + wr[e << 4 & 63] + "=="
  )) : n === 2 && (e = (r[t - 2] << 8) + r[t - 1], s.push(
    wr[e >> 10] + wr[e >> 4 & 63] + wr[e << 2 & 63] + "="
  )), s.join("");
}
var xC = Object.defineProperty, kC = (r, e, t) => e in r ? xC(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t, IC = (r, e, t) => (kC(r, e + "", t), t);
function OC(r, e) {
  let t = Array.from(
    { length: r.length },
    (n, s) => ({ start: s, end: s + 1 })
  );
  for (; t.length > 1; ) {
    let n = null;
    for (let s = 0; s < t.length - 1; s++) {
      const a = r.slice(t[s].start, t[s + 1].end), i = e.get(a.join(","));
      i != null && (n == null || i < n[0]) && (n = [i, s]);
    }
    if (n != null) {
      const s = n[1];
      t[s] = { start: t[s].start, end: t[s + 1].end }, t.splice(s + 1, 1);
    } else
      break;
  }
  return t;
}
function AC(r, e) {
  return r.length === 1 ? [e.get(r.join(","))] : OC(r, e).map((t) => e.get(r.slice(t.start, t.end).join(","))).filter((t) => t != null);
}
function $C(r) {
  return r.replace(/[\\^$*+?.()|[\]{}]/g, "\\$&");
}
var gu = class {
  constructor(r, e) {
    /** @internal */
    b(this, "specialTokens");
    /** @internal */
    b(this, "inverseSpecialTokens");
    /** @internal */
    b(this, "patStr");
    /** @internal */
    b(this, "textEncoder", new TextEncoder());
    /** @internal */
    b(this, "textDecoder", new TextDecoder("utf-8"));
    /** @internal */
    b(this, "rankMap", /* @__PURE__ */ new Map());
    /** @internal */
    b(this, "textMap", /* @__PURE__ */ new Map());
    this.patStr = r.pat_str;
    const t = r.bpe_ranks.split(`
`).filter(Boolean).reduce((n, s) => {
      const [a, i, ...o] = s.split(" "), c = Number.parseInt(i, 10);
      return o.forEach((u, l) => n[u] = c + l), n;
    }, {});
    for (const [n, s] of Object.entries(t)) {
      const a = Co.toByteArray(n);
      this.rankMap.set(a.join(","), s), this.textMap.set(s, a);
    }
    this.specialTokens = { ...r.special_tokens, ...e }, this.inverseSpecialTokens = Object.entries(this.specialTokens).reduce((n, [s, a]) => (n[a] = this.textEncoder.encode(s), n), {});
  }
  encode(r, e = [], t = "all") {
    const n = new RegExp(this.patStr, "ug"), s = gu.specialTokenRegex(
      Object.keys(this.specialTokens)
    ), a = [], i = new Set(
      e === "all" ? Object.keys(this.specialTokens) : e
    ), o = new Set(
      t === "all" ? Object.keys(this.specialTokens).filter(
        (u) => !i.has(u)
      ) : t
    );
    if (o.size > 0) {
      const u = gu.specialTokenRegex([
        ...o
      ]), l = r.match(u);
      if (l != null)
        throw new Error(
          `The text contains a special token that is not allowed: ${l[0]}`
        );
    }
    let c = 0;
    for (; ; ) {
      let u = null, l = c;
      for (; s.lastIndex = l, u = s.exec(r), !(u == null || i.has(u[0])); )
        l = u.index + 1;
      const d = (u == null ? void 0 : u.index) ?? r.length;
      for (const f of r.substring(c, d).matchAll(n)) {
        const p = this.textEncoder.encode(f[0]), y = this.rankMap.get(p.join(","));
        if (y != null) {
          a.push(y);
          continue;
        }
        a.push(...AC(p, this.rankMap));
      }
      if (u == null)
        break;
      let h = this.specialTokens[u[0]];
      a.push(h), c = u.index + u[0].length;
    }
    return a;
  }
  decode(r) {
    const e = [];
    let t = 0;
    for (let a = 0; a < r.length; ++a) {
      const i = r[a], o = this.textMap.get(i) ?? this.inverseSpecialTokens[i];
      o != null && (e.push(o), t += o.length);
    }
    const n = new Uint8Array(t);
    let s = 0;
    for (const a of e)
      n.set(a, s), s += a.length;
    return this.textDecoder.decode(n);
  }
}, H_ = gu;
IC(H_, "specialTokenRegex", (r) => new RegExp(r.map((e) => $C(e)).join("|"), "g"));
function CC(r) {
  switch (r) {
    case "gpt2":
      return "gpt2";
    case "code-cushman-001":
    case "code-cushman-002":
    case "code-davinci-001":
    case "code-davinci-002":
    case "cushman-codex":
    case "davinci-codex":
    case "davinci-002":
    case "text-davinci-002":
    case "text-davinci-003":
      return "p50k_base";
    case "code-davinci-edit-001":
    case "text-davinci-edit-001":
      return "p50k_edit";
    case "ada":
    case "babbage":
    case "babbage-002":
    case "code-search-ada-code-001":
    case "code-search-babbage-code-001":
    case "curie":
    case "davinci":
    case "text-ada-001":
    case "text-babbage-001":
    case "text-curie-001":
    case "text-davinci-001":
    case "text-search-ada-doc-001":
    case "text-search-babbage-doc-001":
    case "text-search-curie-doc-001":
    case "text-search-davinci-doc-001":
    case "text-similarity-ada-001":
    case "text-similarity-babbage-001":
    case "text-similarity-curie-001":
    case "text-similarity-davinci-001":
      return "r50k_base";
    case "gpt-3.5-turbo-instruct-0914":
    case "gpt-3.5-turbo-instruct":
    case "gpt-3.5-turbo-16k-0613":
    case "gpt-3.5-turbo-16k":
    case "gpt-3.5-turbo-0613":
    case "gpt-3.5-turbo-0301":
    case "gpt-3.5-turbo":
    case "gpt-4-32k-0613":
    case "gpt-4-32k-0314":
    case "gpt-4-32k":
    case "gpt-4-0613":
    case "gpt-4-0314":
    case "gpt-4":
    case "gpt-3.5-turbo-1106":
    case "gpt-35-turbo":
    case "gpt-4-1106-preview":
    case "gpt-4-vision-preview":
    case "gpt-3.5-turbo-0125":
    case "gpt-4-turbo":
    case "gpt-4-turbo-2024-04-09":
    case "gpt-4-turbo-preview":
    case "gpt-4-0125-preview":
    case "text-embedding-ada-002":
    case "text-embedding-3-small":
    case "text-embedding-3-large":
      return "cl100k_base";
    case "gpt-4o":
    case "gpt-4o-2024-05-13":
    case "gpt-4o-2024-08-06":
    case "gpt-4o-2024-11-20":
    case "gpt-4o-mini-2024-07-18":
    case "gpt-4o-mini":
    case "gpt-4o-search-preview":
    case "gpt-4o-search-preview-2025-03-11":
    case "gpt-4o-mini-search-preview":
    case "gpt-4o-mini-search-preview-2025-03-11":
    case "gpt-4o-audio-preview":
    case "gpt-4o-audio-preview-2024-12-17":
    case "gpt-4o-audio-preview-2024-10-01":
    case "gpt-4o-mini-audio-preview":
    case "gpt-4o-mini-audio-preview-2024-12-17":
    case "o1":
    case "o1-2024-12-17":
    case "o1-mini":
    case "o1-mini-2024-09-12":
    case "o1-preview":
    case "o1-preview-2024-09-12":
    case "o1-pro":
    case "o1-pro-2025-03-19":
    case "o3":
    case "o3-2025-04-16":
    case "o3-mini":
    case "o3-mini-2025-01-31":
    case "o4-mini":
    case "o4-mini-2025-04-16":
    case "chatgpt-4o-latest":
    case "gpt-4o-realtime":
    case "gpt-4o-realtime-preview-2024-10-01":
    case "gpt-4o-realtime-preview-2024-12-17":
    case "gpt-4o-mini-realtime-preview":
    case "gpt-4o-mini-realtime-preview-2024-12-17":
    case "gpt-4.1":
    case "gpt-4.1-2025-04-14":
    case "gpt-4.1-mini":
    case "gpt-4.1-mini-2025-04-14":
    case "gpt-4.1-nano":
    case "gpt-4.1-nano-2025-04-14":
    case "gpt-4.5-preview":
    case "gpt-4.5-preview-2025-02-27":
    case "gpt-5":
    case "gpt-5-2025-08-07":
    case "gpt-5-nano":
    case "gpt-5-nano-2025-08-07":
    case "gpt-5-mini":
    case "gpt-5-mini-2025-08-07":
    case "gpt-5-chat-latest":
      return "o200k_base";
    default:
      throw new Error("Unknown model");
  }
}
var RC = {};
Ae(RC, {
  encodingForModel: () => Ul,
  getEncoding: () => G_
});
const Ja = {}, NC = /* @__PURE__ */ new pa({});
async function G_(r) {
  return r in Ja || (Ja[r] = NC.fetch(`https://tiktoken.pages.dev/js/${r}.json`).then((e) => e.json()).then((e) => new H_(e)).catch((e) => {
    throw delete Ja[r], e;
  })), await Ja[r];
}
async function Ul(r) {
  return G_(CC(r));
}
var PC = {};
Ae(PC, {
  BaseLangChain: () => Bl,
  BaseLanguageModel: () => Zl,
  calculateMaxTokens: () => MC,
  getEmbeddingContextSize: () => LC,
  getModelContextSize: () => W_,
  getModelNameForTiktoken: () => Ro,
  isOpenAITool: () => zl
});
const Ro = (r) => r.startsWith("gpt-5") ? "gpt-5" : r.startsWith("gpt-3.5-turbo-16k") ? "gpt-3.5-turbo-16k" : r.startsWith("gpt-3.5-turbo-") ? "gpt-3.5-turbo" : r.startsWith("gpt-4-32k") ? "gpt-4-32k" : r.startsWith("gpt-4-") ? "gpt-4" : r.startsWith("gpt-4o") ? "gpt-4o" : r, LC = (r) => {
  switch (r) {
    case "text-embedding-ada-002":
      return 8191;
    default:
      return 2046;
  }
}, W_ = (r) => {
  switch (Ro(r)) {
    case "gpt-5":
    case "gpt-5-turbo":
    case "gpt-5-turbo-preview":
      return 4e5;
    case "gpt-4o":
    case "gpt-4o-mini":
    case "gpt-4o-2024-05-13":
    case "gpt-4o-2024-08-06":
      return 128e3;
    case "gpt-4-turbo":
    case "gpt-4-turbo-preview":
    case "gpt-4-turbo-2024-04-09":
    case "gpt-4-0125-preview":
    case "gpt-4-1106-preview":
      return 128e3;
    case "gpt-4-32k":
    case "gpt-4-32k-0314":
    case "gpt-4-32k-0613":
      return 32768;
    case "gpt-4":
    case "gpt-4-0314":
    case "gpt-4-0613":
      return 8192;
    case "gpt-3.5-turbo-16k":
    case "gpt-3.5-turbo-16k-0613":
      return 16384;
    case "gpt-3.5-turbo":
    case "gpt-3.5-turbo-0301":
    case "gpt-3.5-turbo-0613":
    case "gpt-3.5-turbo-1106":
    case "gpt-3.5-turbo-0125":
      return 4096;
    case "text-davinci-003":
    case "text-davinci-002":
      return 4097;
    case "text-davinci-001":
      return 2049;
    case "text-curie-001":
    case "text-babbage-001":
    case "text-ada-001":
      return 2048;
    case "code-davinci-002":
    case "code-davinci-001":
      return 8e3;
    case "code-cushman-001":
      return 2048;
    case "claude-3-5-sonnet-20241022":
    case "claude-3-5-sonnet-20240620":
    case "claude-3-opus-20240229":
    case "claude-3-sonnet-20240229":
    case "claude-3-haiku-20240307":
    case "claude-2.1":
      return 2e5;
    case "claude-2.0":
    case "claude-instant-1.2":
      return 1e5;
    case "gemini-1.5-pro":
    case "gemini-1.5-pro-latest":
    case "gemini-1.5-flash":
    case "gemini-1.5-flash-latest":
      return 1e6;
    case "gemini-pro":
    case "gemini-pro-vision":
      return 32768;
    default:
      return 4097;
  }
};
function zl(r) {
  return typeof r != "object" || !r ? !1 : !!("type" in r && r.type === "function" && "function" in r && typeof r.function == "object" && r.function && "name" in r.function && "parameters" in r.function);
}
const MC = async ({ prompt: r, modelName: e }) => {
  let t;
  try {
    t = (await Ul(Ro(e))).encode(r).length;
  } catch {
    console.warn("Failed to calculate number of tokens, falling back to approximate count"), t = Math.ceil(r.length / 4);
  }
  return W_(e) - t;
}, DC = () => !1;
var Bl = class extends Qe {
  constructor(e) {
    super(e);
    /**
    * Whether to print out response text.
    */
    b(this, "verbose");
    b(this, "callbacks");
    b(this, "tags");
    b(this, "metadata");
    this.verbose = e.verbose ?? DC(), this.callbacks = e.callbacks, this.tags = e.tags ?? [], this.metadata = e.metadata ?? {};
  }
  get lc_attributes() {
    return {
      callbacks: void 0,
      verbose: void 0
    };
  }
}, Zl = class extends Bl {
  constructor({ callbacks: e, callbackManager: t, ...n }) {
    const { cache: s, ...a } = n;
    super({
      callbacks: e ?? t,
      ...a
    });
    /**
    * The async caller should be used by subclasses to make any async calls,
    * which will thus benefit from the concurrency and retry logic.
    */
    b(this, "caller");
    b(this, "cache");
    b(this, "_encoding");
    typeof s == "object" ? this.cache = s : s ? this.cache = V_.global() : this.cache = void 0, this.caller = new pa(n ?? {});
  }
  /**
  * Keys that the language model accepts as call options.
  */
  get callKeys() {
    return [
      "stop",
      "timeout",
      "signal",
      "tags",
      "metadata",
      "callbacks"
    ];
  }
  /**
  * Get the number of tokens in the content.
  * @param content The content to get the number of tokens for.
  * @returns The number of tokens in the content.
  */
  async getNumTokens(e) {
    let t;
    typeof e == "string" ? t = e : t = e.map((s) => typeof s == "string" ? s : s.type === "text" && "text" in s ? s.text : "").join("");
    let n = Math.ceil(t.length / 4);
    if (!this._encoding) try {
      this._encoding = await Ul("modelName" in this ? Ro(this.modelName) : "gpt2");
    } catch (s) {
      console.warn("Failed to calculate number of tokens, falling back to approximate count", s);
    }
    if (this._encoding) try {
      n = this._encoding.encode(t).length;
    } catch (s) {
      console.warn("Failed to calculate number of tokens, falling back to approximate count", s);
    }
    return n;
  }
  static _convertInputToPromptValue(e) {
    return typeof e == "string" ? new F_(e) : Array.isArray(e) ? new U_(e.map(Fs)) : e;
  }
  /**
  * Get the identifying parameters of the LLM.
  */
  _identifyingParams() {
    return {};
  }
  /**
  * Create a unique cache key for a specific call to a specific language model.
  * @param callOptions Call options for the model
  * @returns A unique cache key.
  */
  _getSerializedCacheKeyParametersForCall({ config: e, ...t }) {
    const n = {
      ...this._identifyingParams(),
      ...t,
      _type: this._llmType(),
      _model: this._modelType()
    };
    return Object.entries(n).filter(([i, o]) => o !== void 0).map(([i, o]) => `${i}:${JSON.stringify(o)}`).sort().join(",");
  }
  /**
  * @deprecated
  * Return a json-like object representing this LLM.
  */
  serialize() {
    return {
      ...this._identifyingParams(),
      _type: this._llmType(),
      _model: this._modelType()
    };
  }
  /**
  * @deprecated
  * Load an LLM from a json-like object describing it.
  */
  static async deserialize(e) {
    throw new Error("Use .toJSON() instead");
  }
  /**
  * Return profiling information for the model.
  *
  * @returns {ModelProfile} An object describing the model's capabilities and constraints
  */
  get profile() {
    return {};
  }
}, os = class extends Qe {
  constructor(e) {
    super(e);
    b(this, "lc_namespace", ["langchain_core", "runnables"]);
    b(this, "lc_serializable", !0);
    b(this, "func");
    e && (this.func = e.func);
  }
  static lc_name() {
    return "RunnablePassthrough";
  }
  async invoke(e, t) {
    const n = Ce(t);
    return this.func && await this.func(e, n), this._callWithConfig((s) => Promise.resolve(s), e, n);
  }
  async *transform(e, t) {
    const n = Ce(t);
    let s, a = !0;
    for await (const i of this._transformStreamWithConfig(e, (o) => o, n))
      if (yield i, a) if (s === void 0) s = i;
      else try {
        s = an(s, i);
      } catch {
        s = void 0, a = !1;
      }
    this.func && s !== void 0 && await this.func(s, n);
  }
  /**
  * A runnable that assigns key-value pairs to the input.
  *
  * The example below shows how you could use it with an inline function.
  *
  * @example
  * ```typescript
  * const prompt =
  *   PromptTemplate.fromTemplate(`Write a SQL query to answer the question using the following schema: {schema}
  * Question: {question}
  * SQL Query:`);
  *
  * // The `RunnablePassthrough.assign()` is used here to passthrough the input from the `.invoke()`
  * // call (in this example it's the question), along with any inputs passed to the `.assign()` method.
  * // In this case, we're passing the schema.
  * const sqlQueryGeneratorChain = RunnableSequence.from([
  *   RunnablePassthrough.assign({
  *     schema: async () => db.getTableInfo(),
  *   }),
  *   prompt,
  *   new ChatOpenAI({ model: "gpt-4o-mini" }).withConfig({ stop: ["\nSQLResult:"] }),
  *   new StringOutputParser(),
  * ]);
  * const result = await sqlQueryGeneratorChain.invoke({
  *   question: "How many employees are there?",
  * });
  * ```
  */
  static assign(e) {
    return new Pl(new fs({ steps: e }));
  }
};
const jC = (r) => r();
function _c(r) {
  const e = r.constructor;
  return new e({
    ...r,
    content: r.contentBlocks,
    response_metadata: {
      ...r.response_metadata,
      output_version: "v1"
    }
  });
}
var FC = {};
Ae(FC, {
  BaseChatModel: () => Vl,
  SimpleChatModel: () => UC
});
function yc(r) {
  const e = [];
  for (const t of r) {
    let n = t;
    if (Array.isArray(t.content)) for (let s = 0; s < t.content.length; s++) {
      const a = t.content[s];
      (Gu(a) || Wu(a)) && n === t && (n = new t.constructor({
        ...n,
        content: [
          ...t.content.slice(0, s),
          cm(a),
          ...t.content.slice(s + 1)
        ]
      }));
    }
    e.push(n);
  }
  return e;
}
var Vl = class _n extends Zl {
  constructor(t) {
    super(t);
    b(this, "lc_namespace", [
      "langchain",
      "chat_models",
      this._llmType()
    ]);
    b(this, "disableStreaming", !1);
    b(this, "outputVersion");
    this.outputVersion = jC(() => {
      const n = t.outputVersion ?? Er("LC_OUTPUT_VERSION");
      return n && ["v0", "v1"].includes(n) ? n : "v0";
    });
  }
  get callKeys() {
    return [...super.callKeys, "outputVersion"];
  }
  _separateRunnableConfigFromCallOptionsCompat(t) {
    const [n, s] = super._separateRunnableConfigFromCallOptions(t);
    return s.signal = n.signal, [n, s];
  }
  /**
  * Invokes the chat model with a single input.
  * @param input The input for the language model.
  * @param options The call options.
  * @returns A Promise that resolves to a BaseMessageChunk.
  */
  async invoke(t, n) {
    const s = _n._convertInputToPromptValue(t);
    return (await this.generatePrompt([s], n, n == null ? void 0 : n.callbacks)).generations[0][0].message;
  }
  async *_streamResponseChunks(t, n, s) {
    throw new Error("Not implemented.");
  }
  async *_streamIterator(t, n) {
    var s;
    if (this._streamResponseChunks === _n.prototype._streamResponseChunks || this.disableStreaming) yield this.invoke(t, n);
    else {
      const i = _n._convertInputToPromptValue(t).toChatMessages(), [o, c] = this._separateRunnableConfigFromCallOptionsCompat(n), u = {
        ...o.metadata,
        ...this.getLsParams(c)
      }, l = await Pt.configure(o.callbacks, this.callbacks, o.tags, this.tags, u, this.metadata, { verbose: this.verbose }), d = {
        options: c,
        invocation_params: this == null ? void 0 : this.invocationParams(c),
        batch_size: 1
      }, h = c.outputVersion ?? this.outputVersion, f = await (l == null ? void 0 : l.handleChatModelStart(this.toJSON(), [yc(i)], o.runId, void 0, d, void 0, void 0, o.runName));
      let p, y;
      try {
        for await (const m of this._streamResponseChunks(i, c, f == null ? void 0 : f[0])) {
          if (m.message.id == null) {
            const v = (s = f == null ? void 0 : f.at(0)) == null ? void 0 : s.runId;
            v != null && m.message._updateId(`run-${v}`);
          }
          m.message.response_metadata = {
            ...m.generationInfo,
            ...m.message.response_metadata
          }, h === "v1" ? yield _c(m.message) : yield m.message, p ? p = p.concat(m) : p = m, Mc(m.message) && m.message.usage_metadata !== void 0 && (y = { tokenUsage: {
            promptTokens: m.message.usage_metadata.input_tokens,
            completionTokens: m.message.usage_metadata.output_tokens,
            totalTokens: m.message.usage_metadata.total_tokens
          } });
        }
      } catch (m) {
        throw await Promise.all((f ?? []).map((v) => v == null ? void 0 : v.handleLLMError(m))), m;
      }
      await Promise.all((f ?? []).map((m) => m == null ? void 0 : m.handleLLMEnd({
        generations: [[p]],
        llmOutput: y
      })));
    }
  }
  getLsParams(t) {
    const n = this.getName().startsWith("Chat") ? this.getName().replace("Chat", "") : this.getName();
    return {
      ls_model_type: "chat",
      ls_stop: t.stop,
      ls_provider: n
    };
  }
  /** @ignore */
  async _generateUncached(t, n, s, a) {
    var f, p;
    const i = t.map((y) => y.map(Fs));
    let o;
    if (a !== void 0 && a.length === i.length) o = a;
    else {
      const y = {
        ...s.metadata,
        ...this.getLsParams(n)
      }, m = await Pt.configure(s.callbacks, this.callbacks, s.tags, this.tags, y, this.metadata, { verbose: this.verbose }), v = {
        options: n,
        invocation_params: this == null ? void 0 : this.invocationParams(n),
        batch_size: 1
      };
      o = await (m == null ? void 0 : m.handleChatModelStart(this.toJSON(), i.map(yc), s.runId, void 0, v, void 0, void 0, s.runName));
    }
    const c = n.outputVersion ?? this.outputVersion, u = [], l = [];
    if (!!(o != null && o[0].handlers.find(cl)) && !this.disableStreaming && i.length === 1 && this._streamResponseChunks !== _n.prototype._streamResponseChunks) try {
      const y = await this._streamResponseChunks(i[0], n, o == null ? void 0 : o[0]);
      let m, v;
      for await (const g of y) {
        if (g.message.id == null) {
          const w = (f = o == null ? void 0 : o.at(0)) == null ? void 0 : f.runId;
          w != null && g.message._updateId(`run-${w}`);
        }
        m === void 0 ? m = g : m = an(m, g), Mc(g.message) && g.message.usage_metadata !== void 0 && (v = { tokenUsage: {
          promptTokens: g.message.usage_metadata.input_tokens,
          completionTokens: g.message.usage_metadata.output_tokens,
          totalTokens: g.message.usage_metadata.total_tokens
        } });
      }
      if (m === void 0) throw new Error("Received empty response from chat model call.");
      u.push([m]), await (o == null ? void 0 : o[0].handleLLMEnd({
        generations: u,
        llmOutput: v
      }));
    } catch (y) {
      throw await (o == null ? void 0 : o[0].handleLLMError(y)), y;
    }
    else {
      const y = await Promise.allSettled(i.map(async (m, v) => {
        const g = await this._generate(m, {
          ...n,
          promptIndex: v
        }, o == null ? void 0 : o[v]);
        if (c === "v1") for (const w of g.generations) w.message = _c(w.message);
        return g;
      }));
      await Promise.all(y.map(async (m, v) => {
        var g, w, T;
        if (m.status === "fulfilled") {
          const x = m.value;
          for (const O of x.generations) {
            if (O.message.id == null) {
              const R = (g = o == null ? void 0 : o.at(0)) == null ? void 0 : g.runId;
              R != null && O.message._updateId(`run-${R}`);
            }
            O.message.response_metadata = {
              ...O.generationInfo,
              ...O.message.response_metadata
            };
          }
          return x.generations.length === 1 && (x.generations[0].message.response_metadata = {
            ...x.llmOutput,
            ...x.generations[0].message.response_metadata
          }), u[v] = x.generations, l[v] = x.llmOutput, (w = o == null ? void 0 : o[v]) == null ? void 0 : w.handleLLMEnd({
            generations: [x.generations],
            llmOutput: x.llmOutput
          });
        } else
          return await ((T = o == null ? void 0 : o[v]) == null ? void 0 : T.handleLLMError(m.reason)), Promise.reject(m.reason);
      }));
    }
    const h = {
      generations: u,
      llmOutput: l.length ? (p = this._combineLLMOutput) == null ? void 0 : p.call(this, ...l) : void 0
    };
    return Object.defineProperty(h, Qs, {
      value: o ? { runIds: o == null ? void 0 : o.map((y) => y.runId) } : void 0,
      configurable: !0
    }), h;
  }
  async _generateCached({ messages: t, cache: n, llmStringKey: s, parsedOptions: a, handledOptions: i }) {
    const o = t.map((g) => g.map(Fs)), c = {
      ...i.metadata,
      ...this.getLsParams(a)
    }, u = await Pt.configure(i.callbacks, this.callbacks, i.tags, this.tags, c, this.metadata, { verbose: this.verbose }), l = {
      options: a,
      invocation_params: this == null ? void 0 : this.invocationParams(a),
      batch_size: 1
    }, d = await (u == null ? void 0 : u.handleChatModelStart(this.toJSON(), o.map(yc), i.runId, void 0, l, void 0, void 0, i.runName)), h = [], p = (await Promise.allSettled(o.map(async (g, w) => {
      const T = _n._convertInputToPromptValue(g).toString(), x = await n.lookup(T, s);
      return x == null && h.push(w), x;
    }))).map((g, w) => ({
      result: g,
      runManager: d == null ? void 0 : d[w]
    })).filter(({ result: g }) => g.status === "fulfilled" && g.value != null || g.status === "rejected"), y = a.outputVersion ?? this.outputVersion, m = [];
    await Promise.all(p.map(async ({ result: g, runManager: w }, T) => {
      if (g.status === "fulfilled") {
        const x = g.value;
        return m[T] = x.map((O) => ("message" in O && Xr(O.message) && co(O.message) && (O.message.usage_metadata = {
          input_tokens: 0,
          output_tokens: 0,
          total_tokens: 0
        }, y === "v1" && (O.message = _c(O.message))), O.generationInfo = {
          ...O.generationInfo,
          tokenUsage: {}
        }, O)), x.length && await (w == null ? void 0 : w.handleLLMNewToken(x[0].text)), w == null ? void 0 : w.handleLLMEnd({ generations: [x] }, void 0, void 0, void 0, { cached: !0 });
      } else
        return await (w == null ? void 0 : w.handleLLMError(g.reason, void 0, void 0, void 0, { cached: !0 })), Promise.reject(g.reason);
    }));
    const v = {
      generations: m,
      missingPromptIndices: h,
      startedRunManagers: d
    };
    return Object.defineProperty(v, Qs, {
      value: d ? { runIds: d == null ? void 0 : d.map((g) => g.runId) } : void 0,
      configurable: !0
    }), v;
  }
  /**
  * Generates chat based on the input messages.
  * @param messages An array of arrays of BaseMessage instances.
  * @param options The call options or an array of stop sequences.
  * @param callbacks The callbacks for the language model.
  * @returns A Promise that resolves to an LLMResult.
  */
  async generate(t, n, s) {
    let a;
    Array.isArray(n) ? a = { stop: n } : a = n;
    const i = t.map((y) => y.map(Fs)), [o, c] = this._separateRunnableConfigFromCallOptionsCompat(a);
    if (o.callbacks = o.callbacks ?? s, !this.cache) return this._generateUncached(i, c, o);
    const { cache: u } = this, l = this._getSerializedCacheKeyParametersForCall(c), { generations: d, missingPromptIndices: h, startedRunManagers: f } = await this._generateCached({
      messages: i,
      cache: u,
      llmStringKey: l,
      parsedOptions: c,
      handledOptions: o
    });
    let p = {};
    if (h.length > 0) {
      const y = await this._generateUncached(h.map((m) => i[m]), c, o, f !== void 0 ? h.map((m) => f == null ? void 0 : f[m]) : void 0);
      await Promise.all(y.generations.map(async (m, v) => {
        const g = h[v];
        d[g] = m;
        const w = _n._convertInputToPromptValue(i[g]).toString();
        return u.update(w, l, m);
      })), p = y.llmOutput ?? {};
    }
    return {
      generations: d,
      llmOutput: p
    };
  }
  /**
  * Get the parameters used to invoke the model
  */
  invocationParams(t) {
    return {};
  }
  _modelType() {
    return "base_chat_model";
  }
  /**
  * Generates a prompt based on the input prompt values.
  * @param promptValues An array of BasePromptValue instances.
  * @param options The call options or an array of stop sequences.
  * @param callbacks The callbacks for the language model.
  * @returns A Promise that resolves to an LLMResult.
  */
  async generatePrompt(t, n, s) {
    const a = t.map((i) => i.toChatMessages());
    return this.generate(a, n, s);
  }
  withStructuredOutput(t, n) {
    if (typeof this.bindTools != "function") throw new Error('Chat model must implement ".bindTools()" to use withStructuredOutput.');
    if (n != null && n.strict) throw new Error('"strict" mode is not supported for this model by default.');
    const s = t, a = n == null ? void 0 : n.name, i = xo(s) ?? "A function available to call.", o = n == null ? void 0 : n.method, c = n == null ? void 0 : n.includeRaw;
    if (o === "jsonMode") throw new Error('Base withStructuredOutput implementation only supports "functionCalling" as a method.');
    let u = a ?? "extract", l;
    br(s) ? l = [{
      type: "function",
      function: {
        name: u,
        description: i,
        parameters: Sr(s)
      }
    }] : ("name" in s && (u = s.name), l = [{
      type: "function",
      function: {
        name: u,
        description: i,
        parameters: s
      }
    }]);
    const d = this.bindTools(l), h = qr.from((m) => {
      if (!Ar.isInstance(m)) throw new Error("Input is not an AIMessageChunk.");
      if (!m.tool_calls || m.tool_calls.length === 0) throw new Error("No tool calls found in the response.");
      const v = m.tool_calls.find((g) => g.name === u);
      if (!v) throw new Error(`No tool call found with name ${u}.`);
      return v.args;
    });
    if (!c) return d.pipe(h).withConfig({ runName: "StructuredOutput" });
    const f = os.assign({ parsed: (m, v) => h.invoke(m.raw, v) }), p = os.assign({ parsed: () => null }), y = f.withFallbacks({ fallbacks: [p] });
    return ma.from([{ raw: d }, y]).withConfig({ runName: "StructuredOutputRunnable" });
  }
}, UC = class extends Vl {
  async _generate(r, e, t) {
    const n = await this._call(r, e, t), s = new Fe(n);
    if (typeof s.content != "string") throw new Error("Cannot generate with a simple chat model when output is not a string.");
    return { generations: [{
      text: s.content,
      message: s
    }] };
  }
}, zC = class extends Qe {
  constructor(e) {
    super(e);
    b(this, "lc_namespace", ["langchain_core", "runnables"]);
    b(this, "lc_serializable", !0);
    b(this, "runnables");
    this.runnables = e.runnables;
  }
  static lc_name() {
    return "RouterRunnable";
  }
  async invoke(e, t) {
    const { key: n, input: s } = e, a = this.runnables[n];
    if (a === void 0) throw new Error(`No runnable associated with key "${n}".`);
    return a.invoke(s, Ce(t));
  }
  async batch(e, t, n) {
    var h;
    const s = e.map((f) => f.key), a = e.map((f) => f.input);
    if (s.find((f) => this.runnables[f] === void 0) !== void 0) throw new Error("One or more keys do not have a corresponding runnable.");
    const o = s.map((f) => this.runnables[f]), c = this._getOptionsList(t ?? {}, e.length), u = ((h = c[0]) == null ? void 0 : h.maxConcurrency) ?? (n == null ? void 0 : n.maxConcurrency), l = u && u > 0 ? u : e.length, d = [];
    for (let f = 0; f < a.length; f += l) {
      const p = a.slice(f, f + l).map((m, v) => o[v].invoke(m, c[v])), y = await Promise.all(p);
      d.push(y);
    }
    return d.flat();
  }
  async stream(e, t) {
    const { key: n, input: s } = e, a = this.runnables[n];
    if (a === void 0) throw new Error(`No runnable associated with key "${n}".`);
    return a.stream(s, t);
  }
}, BC = class extends Qe {
  constructor(e) {
    super(e);
    b(this, "lc_namespace", ["langchain_core", "runnables"]);
    b(this, "lc_serializable", !0);
    b(this, "default");
    b(this, "branches");
    this.branches = e.branches, this.default = e.default;
  }
  static lc_name() {
    return "RunnableBranch";
  }
  /**
  * Convenience method for instantiating a RunnableBranch from
  * RunnableLikes (objects, functions, or Runnables).
  *
  * Each item in the input except for the last one should be a
  * tuple with two items. The first is a "condition" RunnableLike that
  * returns "true" if the second RunnableLike in the tuple should run.
  *
  * The final item in the input should be a RunnableLike that acts as a
  * default branch if no other branches match.
  *
  * @example
  * ```ts
  * import { RunnableBranch } from "@langchain/core/runnables";
  *
  * const branch = RunnableBranch.from([
  *   [(x: number) => x > 0, (x: number) => x + 1],
  *   [(x: number) => x < 0, (x: number) => x - 1],
  *   (x: number) => x
  * ]);
  * ```
  * @param branches An array where the every item except the last is a tuple of [condition, runnable]
  *   pairs. The last item is a default runnable which is invoked if no other condition matches.
  * @returns A new RunnableBranch.
  */
  static from(e) {
    if (e.length < 1) throw new Error("RunnableBranch requires at least one branch");
    const n = e.slice(0, -1).map(([a, i]) => [ur(a), ur(i)]), s = ur(e[e.length - 1]);
    return new this({
      branches: n,
      default: s
    });
  }
  async _invoke(e, t, n) {
    let s;
    for (let a = 0; a < this.branches.length; a += 1) {
      const [i, o] = this.branches[a];
      if (await i.invoke(e, Be(t, { callbacks: n == null ? void 0 : n.getChild(`condition:${a + 1}`) }))) {
        s = await o.invoke(e, Be(t, { callbacks: n == null ? void 0 : n.getChild(`branch:${a + 1}`) }));
        break;
      }
    }
    return s || (s = await this.default.invoke(e, Be(t, { callbacks: n == null ? void 0 : n.getChild("branch:default") }))), s;
  }
  async invoke(e, t = {}) {
    return this._callWithConfig(this._invoke, e, t);
  }
  async *_streamIterator(e, t) {
    const n = await Zt(t), s = await (n == null ? void 0 : n.handleChainStart(this.toJSON(), ut(e, "input"), t == null ? void 0 : t.runId, void 0, void 0, void 0, t == null ? void 0 : t.runName));
    let a, i = !0, o;
    try {
      for (let c = 0; c < this.branches.length; c += 1) {
        const [u, l] = this.branches[c];
        if (await u.invoke(e, Be(t, { callbacks: s == null ? void 0 : s.getChild(`condition:${c + 1}`) }))) {
          o = await l.stream(e, Be(t, { callbacks: s == null ? void 0 : s.getChild(`branch:${c + 1}`) }));
          for await (const h of o)
            if (yield h, i) if (a === void 0) a = h;
            else try {
              a = an(a, h);
            } catch {
              a = void 0, i = !1;
            }
          break;
        }
      }
      if (o === void 0) {
        o = await this.default.stream(e, Be(t, { callbacks: s == null ? void 0 : s.getChild("branch:default") }));
        for await (const c of o)
          if (yield c, i) if (a === void 0) a = c;
          else try {
            a = an(a, c);
          } catch {
            a = void 0, i = !1;
          }
      }
    } catch (c) {
      throw await (s == null ? void 0 : s.handleChainError(c)), c;
    }
    await (s == null ? void 0 : s.handleChainEnd(a ?? {}));
  }
}, ZC = class extends is {
  constructor(e) {
    let t = qr.from((i, o) => this._enterHistory(i, o ?? {})).withConfig({ runName: "loadHistory" });
    const n = e.historyMessagesKey ?? e.inputMessagesKey;
    n && (t = os.assign({ [n]: t }).withConfig({ runName: "insertHistory" }));
    const s = t.pipe(e.runnable.withListeners({ onEnd: (i, o) => this._exitHistory(i, o ?? {}) })).withConfig({ runName: "RunnableWithMessageHistory" }), a = e.config ?? {};
    super({
      ...e,
      config: a,
      bound: s
    });
    b(this, "runnable");
    b(this, "inputMessagesKey");
    b(this, "outputMessagesKey");
    b(this, "historyMessagesKey");
    b(this, "getMessageHistory");
    this.runnable = e.runnable, this.getMessageHistory = e.getMessageHistory, this.inputMessagesKey = e.inputMessagesKey, this.outputMessagesKey = e.outputMessagesKey, this.historyMessagesKey = e.historyMessagesKey;
  }
  _getInputMessages(e) {
    let t;
    if (typeof e == "object" && !Array.isArray(e) && !Xr(e)) {
      let n;
      this.inputMessagesKey ? n = this.inputMessagesKey : Object.keys(e).length === 1 ? n = Object.keys(e)[0] : n = "input", Array.isArray(e[n]) && Array.isArray(e[n][0]) ? t = e[n][0] : t = e[n];
    } else t = e;
    if (typeof t == "string") return [new zt(t)];
    if (Array.isArray(t)) return t;
    if (Xr(t)) return [t];
    throw new Error(`Expected a string, BaseMessage, or array of BaseMessages.
Got ${JSON.stringify(t, null, 2)}`);
  }
  _getOutputMessages(e) {
    let t;
    if (!Array.isArray(e) && !Xr(e) && typeof e != "string") {
      let n;
      this.outputMessagesKey !== void 0 ? n = this.outputMessagesKey : Object.keys(e).length === 1 ? n = Object.keys(e)[0] : n = "output", e.generations !== void 0 ? t = e.generations[0][0].message : t = e[n];
    } else t = e;
    if (typeof t == "string") return [new Fe(t)];
    if (Array.isArray(t)) return t;
    if (Xr(t)) return [t];
    throw new Error(`Expected a string, BaseMessage, or array of BaseMessages. Received: ${JSON.stringify(t, null, 2)}`);
  }
  async _enterHistory(e, t) {
    var a;
    const s = await ((a = t == null ? void 0 : t.configurable) == null ? void 0 : a.messageHistory).getMessages();
    return this.historyMessagesKey === void 0 ? s.concat(this._getInputMessages(e)) : s;
  }
  async _exitHistory(e, t) {
    var c;
    const n = (c = t.configurable) == null ? void 0 : c.messageHistory;
    let s;
    Array.isArray(e.inputs) && Array.isArray(e.inputs[0]) ? s = e.inputs[0] : s = e.inputs;
    let a = this._getInputMessages(s);
    if (this.historyMessagesKey === void 0) {
      const u = await n.getMessages();
      a = a.slice(u.length);
    }
    const i = e.outputs;
    if (!i) throw new Error(`Output values from 'Run' undefined. Run: ${JSON.stringify(e, null, 2)}`);
    const o = this._getOutputMessages(i);
    await n.addMessages([...a, ...o]);
  }
  async _mergeConfig(...e) {
    const t = await super._mergeConfig(...e);
    if (!t.configurable || !t.configurable.sessionId) {
      const s = { [this.inputMessagesKey ?? "input"]: "foo" }, a = { configurable: { sessionId: "123" } };
      throw new Error(`sessionId is required. Pass it in as part of the config argument to .invoke() or .stream()
eg. chain.invoke(${JSON.stringify(s)}, ${JSON.stringify(a)})`);
    }
    const { sessionId: n } = t.configurable;
    return t.configurable.messageHistory = await this.getMessageHistory(n), t;
  }
}, VC = {};
Ae(VC, {
  RouterRunnable: () => zC,
  Runnable: () => Qe,
  RunnableAssign: () => Pl,
  RunnableBinding: () => is,
  RunnableBranch: () => BC,
  RunnableEach: () => bO,
  RunnableLambda: () => qr,
  RunnableMap: () => fs,
  RunnableParallel: () => EO,
  RunnablePassthrough: () => os,
  RunnablePick: () => T_,
  RunnableRetry: () => Nl,
  RunnableSequence: () => ma,
  RunnableToolLike: () => hu,
  RunnableWithFallbacks: () => S_,
  RunnableWithMessageHistory: () => ZC,
  _coerceToRunnable: () => ur,
  ensureConfig: () => Ce,
  getCallbackManagerForConfig: () => Zt,
  mergeConfigs: () => ki,
  patchConfig: () => Be,
  pickRunnableConfigKeys: () => Ur,
  raceWithSignal: () => zr
});
var K_ = class extends Qe {
  /**
  * Parses the result of an LLM call with a given prompt. By default, it
  * simply calls `parseResult`.
  * @param generations The generations from an LLM call.
  * @param _prompt The prompt used in the LLM call.
  * @param callbacks Optional callbacks.
  * @returns A promise of the parsed output.
  */
  parseResultWithPrompt(r, e, t) {
    return this.parseResult(r, t);
  }
  _baseMessageToString(r) {
    return typeof r.content == "string" ? r.content : this._baseMessageContentToString(r.content);
  }
  _baseMessageContentToString(r) {
    return JSON.stringify(r);
  }
  /**
  * Calls the parser with a given input and optional configuration options.
  * If the input is a string, it creates a generation with the input as
  * text and calls `parseResult`. If the input is a `BaseMessage`, it
  * creates a generation with the input as a message and the content of the
  * input as text, and then calls `parseResult`.
  * @param input The input to the parser, which can be a string or a `BaseMessage`.
  * @param options Optional configuration options.
  * @returns A promise of the parsed output.
  */
  async invoke(r, e) {
    return typeof r == "string" ? this._callWithConfig(async (t, n) => this.parseResult([{ text: t }], n == null ? void 0 : n.callbacks), r, {
      ...e,
      runType: "parser"
    }) : this._callWithConfig(async (t, n) => this.parseResult([{
      message: t,
      text: this._baseMessageToString(t)
    }], n == null ? void 0 : n.callbacks), r, {
      ...e,
      runType: "parser"
    });
  }
}, No = class extends K_ {
  parseResult(r, e) {
    return this.parse(r[0].text, e);
  }
  async parseWithPrompt(r, e, t) {
    return this.parse(r, t);
  }
  /**
  * Return the string type key uniquely identifying this class of parser
  */
  _type() {
    throw new Error("_type not implemented");
  }
}, jr = class extends Error {
  constructor(e, t, n, s = !1) {
    super(e);
    b(this, "llmOutput");
    b(this, "observation");
    b(this, "sendToLLM");
    if (this.llmOutput = t, this.observation = n, this.sendToLLM = s, s && (n === void 0 || t === void 0))
      throw new Error("Arguments 'observation' & 'llmOutput' are required if 'sendToLlm' is true");
    Im(this, "OUTPUT_PARSING_FAILURE");
  }
}, ya = class extends No {
  async *_transform(r) {
    for await (const e of r) typeof e == "string" ? yield this.parseResult([{ text: e }]) : yield this.parseResult([{
      message: e,
      text: this._baseMessageToString(e)
    }]);
  }
  /**
  * Transforms an asynchronous generator of input into an asynchronous
  * generator of parsed output.
  * @param inputGenerator An asynchronous generator of input.
  * @param options A configuration object.
  * @returns An asynchronous generator of parsed output.
  */
  async *transform(r, e) {
    yield* this._transformStreamWithConfig(r, this._transform.bind(this), {
      ...e,
      runType: "parser"
    });
  }
}, Po = class extends ya {
  constructor(e) {
    super(e);
    b(this, "diff", !1);
    this.diff = (e == null ? void 0 : e.diff) ?? this.diff;
  }
  async *_transform(e) {
    let t, n;
    for await (const s of e) {
      if (typeof s != "string" && typeof s.content != "string") throw new Error("Cannot handle non-string output.");
      let a;
      if (tl(s)) {
        if (typeof s.content != "string") throw new Error("Cannot handle non-string message output.");
        a = new es({
          message: s,
          text: s.content
        });
      } else if (Xr(s)) {
        if (typeof s.content != "string") throw new Error("Cannot handle non-string message output.");
        a = new es({
          message: Ti(s),
          text: s.content
        });
      } else a = new Qn({ text: s });
      n === void 0 ? n = a : n = n.concat(a);
      const i = await this.parsePartialResult([n]);
      i != null && !Tn(i, t) && (this.diff ? yield this._diff(t, i) : yield i, t = i);
    }
  }
  getFormatInstructions() {
    return "";
  }
}, qC = {};
Ae(qC, {
  applyPatch: () => Xn,
  compare: () => wl
});
var _u = class extends Po {
  constructor() {
    super(...arguments);
    b(this, "lc_namespace", ["langchain_core", "output_parsers"]);
    b(this, "lc_serializable", !0);
  }
  static lc_name() {
    return "JsonOutputParser";
  }
  /** @internal */
  _concatOutputChunks(e, t) {
    return this.diff ? super._concatOutputChunks(e, t) : t;
  }
  _diff(e, t) {
    if (t)
      return e ? wl(e, t) : [{
        op: "replace",
        path: "",
        value: t
      }];
  }
  async parsePartialResult(e) {
    return Lc(e[0].text);
  }
  async parse(e) {
    return Lc(e, JSON.parse);
  }
  getFormatInstructions() {
    return "";
  }
}, JC = class extends ya {
  constructor() {
    super(...arguments);
    b(this, "lc_namespace", [
      "langchain_core",
      "output_parsers",
      "bytes"
    ]);
    b(this, "lc_serializable", !0);
    b(this, "textEncoder", new TextEncoder());
  }
  static lc_name() {
    return "BytesOutputParser";
  }
  parse(e) {
    return Promise.resolve(this.textEncoder.encode(e));
  }
  getFormatInstructions() {
    return "";
  }
}, wa = class extends ya {
  constructor() {
    super(...arguments);
    b(this, "re");
  }
  async *_transform(e) {
    let t = "";
    for await (const n of e)
      if (typeof n == "string" ? t += n : t += n.content, this.re) {
        const s = [...t.matchAll(this.re)];
        if (s.length > 1) {
          let a = 0;
          for (const i of s.slice(0, -1))
            yield [i[1]], a += (i.index ?? 0) + i[0].length;
          t = t.slice(a);
        }
      } else {
        const s = await this.parse(t);
        if (s.length > 1) {
          for (const a of s.slice(0, -1)) yield [a];
          t = s[s.length - 1];
        }
      }
    for (const n of await this.parse(t)) yield [n];
  }
}, HC = class extends wa {
  constructor() {
    super(...arguments);
    b(this, "lc_namespace", [
      "langchain_core",
      "output_parsers",
      "list"
    ]);
    b(this, "lc_serializable", !0);
  }
  static lc_name() {
    return "CommaSeparatedListOutputParser";
  }
  /**
  * Parses the given text into an array of strings, using a comma as the
  * separator. If the parsing fails, throws an OutputParserException.
  * @param text The text to parse.
  * @returns An array of strings obtained by splitting the input text at each comma.
  */
  async parse(e) {
    try {
      return e.trim().split(",").map((t) => t.trim());
    } catch {
      throw new jr(`Could not parse output: ${e}`, e);
    }
  }
  /**
  * Provides instructions on the expected format of the response for the
  * CommaSeparatedListOutputParser.
  * @returns A string containing instructions on the expected format of the response.
  */
  getFormatInstructions() {
    return "Your response should be a list of comma separated values, eg: `foo, bar, baz`";
  }
}, GC = class extends wa {
  constructor({ length: e, separator: t }) {
    super(...arguments);
    b(this, "lc_namespace", [
      "langchain_core",
      "output_parsers",
      "list"
    ]);
    b(this, "length");
    b(this, "separator");
    this.length = e, this.separator = t || ",";
  }
  /**
  * Parses the given text into an array of strings, using the specified
  * separator. If the parsing fails or the number of items in the list
  * doesn't match the expected length, throws an OutputParserException.
  * @param text The text to parse.
  * @returns An array of strings obtained by splitting the input text at each occurrence of the specified separator.
  */
  async parse(e) {
    try {
      const t = e.trim().split(this.separator).map((n) => n.trim());
      if (this.length !== void 0 && t.length !== this.length) throw new jr(`Incorrect number of items. Expected ${this.length}, got ${t.length}.`);
      return t;
    } catch (t) {
      throw Object.getPrototypeOf(t) === jr.prototype ? t : new jr(`Could not parse output: ${e}`);
    }
  }
  /**
  * Provides instructions on the expected format of the response for the
  * CustomListOutputParser, including the number of items and the
  * separator.
  * @returns A string containing instructions on the expected format of the response.
  */
  getFormatInstructions() {
    return `Your response should be a list of ${this.length === void 0 ? "" : `${this.length} `}items separated by "${this.separator}" (eg: \`foo${this.separator} bar${this.separator} baz\`)`;
  }
}, WC = class extends wa {
  constructor() {
    super(...arguments);
    b(this, "lc_namespace", [
      "langchain_core",
      "output_parsers",
      "list"
    ]);
    b(this, "lc_serializable", !0);
    b(this, "re", /\d+\.\s([^\n]+)/g);
  }
  static lc_name() {
    return "NumberedListOutputParser";
  }
  getFormatInstructions() {
    return `Your response should be a numbered list with each item on a new line. For example: 

1. foo

2. bar

3. baz`;
  }
  async parse(e) {
    return [...e.matchAll(this.re) ?? []].map((t) => t[1]);
  }
}, KC = class extends wa {
  constructor() {
    super(...arguments);
    b(this, "lc_namespace", [
      "langchain_core",
      "output_parsers",
      "list"
    ]);
    b(this, "lc_serializable", !0);
    b(this, "re", /^\s*[-*]\s([^\n]+)$/gm);
  }
  static lc_name() {
    return "NumberedListOutputParser";
  }
  getFormatInstructions() {
    return `Your response should be a numbered list with each item on a new line. For example: 

1. foo

2. bar

3. baz`;
  }
  async parse(e) {
    return [...e.matchAll(this.re) ?? []].map((t) => t[1]);
  }
}, YC = class extends ya {
  constructor() {
    super(...arguments);
    b(this, "lc_namespace", [
      "langchain_core",
      "output_parsers",
      "string"
    ]);
    b(this, "lc_serializable", !0);
  }
  static lc_name() {
    return "StrOutputParser";
  }
  /**
  * Parses a string output from an LLM call. This method is meant to be
  * implemented by subclasses to define how a string output from an LLM
  * should be parsed.
  * @param text The string output from an LLM call.
  * @param callbacks Optional callbacks.
  * @returns A promise of the parsed output.
  */
  parse(e) {
    return Promise.resolve(e);
  }
  getFormatInstructions() {
    return "";
  }
  _textContentToString(e) {
    return e.text;
  }
  _imageUrlContentToString(e) {
    throw new Error('Cannot coerce a multimodal "image_url" message part into a string.');
  }
  _messageContentToString(e) {
    switch (e.type) {
      case "text":
      case "text_delta":
        if ("text" in e) return this._textContentToString(e);
        break;
      case "image_url":
        if ("image_url" in e) return this._imageUrlContentToString(e);
        break;
      default:
        throw new Error(`Cannot coerce "${e.type}" message part into a string.`);
    }
    throw new Error(`Invalid content type: ${e.type}`);
  }
  _baseMessageContentToString(e) {
    return e.reduce((t, n) => t + this._messageContentToString(n), "");
  }
}, Ji = class extends No {
  constructor(e) {
    super(e);
    b(this, "lc_namespace", [
      "langchain",
      "output_parsers",
      "structured"
    ]);
    this.schema = e;
  }
  static lc_name() {
    return "StructuredOutputParser";
  }
  toJSON() {
    return this.toJSONNotImplemented();
  }
  /**
  * Creates a new StructuredOutputParser from a Zod schema.
  * @param schema The Zod schema which the output should match
  * @returns A new instance of StructuredOutputParser.
  */
  static fromZodSchema(e) {
    return new this(e);
  }
  /**
  * Creates a new StructuredOutputParser from a set of names and
  * descriptions.
  * @param schemas An object where each key is a name and each value is a description
  * @returns A new instance of StructuredOutputParser.
  */
  static fromNamesAndDescriptions(e) {
    const t = Oo(Object.fromEntries(Object.entries(e).map(([n, s]) => [n, Io().describe(s)])));
    return new this(t);
  }
  /**
  * Returns a markdown code snippet with a JSON object formatted according
  * to the schema.
  * @param options Optional. The options for formatting the instructions
  * @returns A markdown code snippet with a JSON object formatted according to the schema.
  */
  getFormatInstructions() {
    return `You must format your output as a JSON value that adheres to a given "JSON Schema" instance.

"JSON Schema" is a declarative language that allows you to annotate and validate JSON documents.

For example, the example "JSON Schema" instance {{"properties": {{"foo": {{"description": "a list of test words", "type": "array", "items": {{"type": "string"}}}}}}, "required": ["foo"]}}
would match an object with one required property, "foo". The "type" property specifies "foo" must be an "array", and the "description" property semantically describes it as "a list of test words". The items within "foo" must be strings.
Thus, the object {{"foo": ["bar", "baz"]}} is a well-formatted instance of this example "JSON Schema". The object {{"properties": {{"foo": ["bar", "baz"]}}}} is not well-formatted.

Your output will be parsed and type-checked according to the provided schema instance, so make sure all fields in your output match the schema exactly and there are no trailing commas!

Here is the JSON Schema instance your output must adhere to. Include the enclosing markdown codeblock:
\`\`\`json
${JSON.stringify(Sr(this.schema))}
\`\`\`
`;
  }
  /**
  * Parses the given text according to the schema.
  * @param text The text to parse
  * @returns The parsed output.
  */
  async parse(e) {
    var t, n;
    try {
      const s = e.trim(), i = (((t = s.match(/^```(?:json)?\s*([\s\S]*?)```/)) == null ? void 0 : t[1]) || ((n = s.match(/```json\s*([\s\S]*?)```/)) == null ? void 0 : n[1]) || s).replace(/"([^"\\]*(\\.[^"\\]*)*)"/g, (o, c) => `"${c.replace(/\n/g, "\\n")}"`).replace(/\n/g, "");
      return await Eo(this.schema, JSON.parse(i));
    } catch (s) {
      throw new jr(`Failed to parse. Text: "${e}". Error: ${s}`, e);
    }
  }
}, Y_ = class extends Ji {
  static lc_name() {
    return "JsonMarkdownStructuredOutputParser";
  }
  getFormatInstructions(r) {
    const e = (r == null ? void 0 : r.interpolationDepth) ?? 1;
    if (e < 1) throw new Error("f string interpolation depth must be at least 1");
    return `Return a markdown code snippet with a JSON object formatted to look like:
\`\`\`json
${this._schemaToInstruction(Sr(this.schema)).replaceAll("{", "{".repeat(e)).replaceAll("}", "}".repeat(e))}
\`\`\``;
  }
  _schemaToInstruction(r, e = 2) {
    const t = r;
    if ("type" in t) {
      let n = !1, s;
      if (Array.isArray(t.type)) {
        const o = t.type.findIndex((c) => c === "null");
        o !== -1 && (n = !0, t.type.splice(o, 1)), s = t.type.join(" | ");
      } else s = t.type;
      if (t.type === "object" && t.properties) {
        const o = t.description ? ` // ${t.description}` : "";
        return `{
${Object.entries(t.properties).map(([u, l]) => {
          var h;
          const d = (h = t.required) != null && h.includes(u) ? "" : " (optional)";
          return `${" ".repeat(e)}"${u}": ${this._schemaToInstruction(l, e + 2)}${d}`;
        }).join(`
`)}
${" ".repeat(e - 2)}}${o}`;
      }
      if (t.type === "array" && t.items) {
        const o = t.description ? ` // ${t.description}` : "";
        return `array[
${" ".repeat(e)}${this._schemaToInstruction(t.items, e + 2)}
${" ".repeat(e - 2)}] ${o}`;
      }
      const a = n ? " (nullable)" : "", i = t.description ? ` // ${t.description}` : "";
      return `${s}${i}${a}`;
    }
    if ("anyOf" in t) return t.anyOf.map((n) => this._schemaToInstruction(n, e)).join(`
${" ".repeat(e - 2)}`);
    throw new Error("unsupported schema type");
  }
  static fromZodSchema(r) {
    return new this(r);
  }
  static fromNamesAndDescriptions(r) {
    const e = Oo(Object.fromEntries(Object.entries(r).map(([t, n]) => [t, Io().describe(n)])));
    return new this(e);
  }
}, XC = class extends No {
  constructor({ inputSchema: e }) {
    super(...arguments);
    b(this, "structuredInputParser");
    this.structuredInputParser = new Y_(e);
  }
  async parse(e) {
    let t;
    try {
      t = await this.structuredInputParser.parse(e);
    } catch (n) {
      throw new jr(`Failed to parse. Text: "${e}". Error: ${n}`, e);
    }
    return this.outputProcessor(t);
  }
  getFormatInstructions() {
    return this.structuredInputParser.getFormatInstructions();
  }
};
const QC = function() {
  const r = {};
  r.parser = function(S, _) {
    return new t(S, _);
  }, r.SAXParser = t, r.SAXStream = u, r.createStream = c, r.MAX_BUFFER_LENGTH = 64 * 1024;
  const e = [
    "comment",
    "sgmlDecl",
    "textNode",
    "tagName",
    "doctype",
    "procInstName",
    "procInstBody",
    "entity",
    "attribName",
    "attribValue",
    "cdata",
    "script"
  ];
  r.EVENTS = [
    "text",
    "processinginstruction",
    "sgmldeclaration",
    "doctype",
    "comment",
    "opentagstart",
    "attribute",
    "opentag",
    "closetag",
    "opencdata",
    "cdata",
    "closecdata",
    "error",
    "end",
    "ready",
    "script",
    "opennamespace",
    "closenamespace"
  ];
  function t(S, _) {
    if (!(this instanceof t)) return new t(S, _);
    var $ = this;
    s($), $.q = $.c = "", $.bufferCheckPosition = r.MAX_BUFFER_LENGTH, $.opt = _ || {}, $.opt.lowercase = $.opt.lowercase || $.opt.lowercasetags, $.looseCase = $.opt.lowercase ? "toLowerCase" : "toUpperCase", $.tags = [], $.closed = $.closedRoot = $.sawRoot = !1, $.tag = $.error = null, $.strict = !!S, $.noscript = !!(S || $.opt.noscript), $.state = E.BEGIN, $.strictEntities = $.opt.strictEntities, $.ENTITIES = $.strictEntities ? Object.create(r.XML_ENTITIES) : Object.create(r.ENTITIES), $.attribList = [], $.opt.xmlns && ($.ns = Object.create(p)), $.trackPosition = $.opt.position !== !1, $.trackPosition && ($.position = $.line = $.column = 0), ne($, "onready");
  }
  Object.create || (Object.create = function(S) {
    function _() {
    }
    _.prototype = S;
    var $ = new _();
    return $;
  }), Object.keys || (Object.keys = function(S) {
    var _ = [];
    for (var $ in S) S.hasOwnProperty($) && _.push($);
    return _;
  });
  function n(S) {
    for (var _ = Math.max(r.MAX_BUFFER_LENGTH, 10), $ = 0, k = 0, de = e.length; k < de; k++) {
      var ge = S[e[k]].length;
      if (ge > _) switch (e[k]) {
        case "textNode":
          Te(S);
          break;
        case "cdata":
          z(S, "oncdata", S.cdata), S.cdata = "";
          break;
        case "script":
          z(S, "onscript", S.script), S.script = "";
          break;
        default:
          Z(S, "Max buffer length exceeded: " + e[k]);
      }
      $ = Math.max($, ge);
    }
    var Me = r.MAX_BUFFER_LENGTH - $;
    S.bufferCheckPosition = Me + S.position;
  }
  function s(S) {
    for (var _ = 0, $ = e.length; _ < $; _++) S[e[_]] = "";
  }
  function a(S) {
    Te(S), S.cdata !== "" && (z(S, "oncdata", S.cdata), S.cdata = ""), S.script !== "" && (z(S, "onscript", S.script), S.script = "");
  }
  t.prototype = {
    end: function() {
      D(this);
    },
    write: ae,
    resume: function() {
      return this.error = null, this;
    },
    close: function() {
      return this.write(null);
    },
    flush: function() {
      a(this);
    }
  };
  var i = ReadableStream;
  i || (i = function() {
  });
  var o = r.EVENTS.filter(function(S) {
    return S !== "error" && S !== "end";
  });
  function c(S, _) {
    return new u(S, _);
  }
  function u(S, _) {
    if (!(this instanceof u)) return new u(S, _);
    i.apply(this), this._parser = new t(S, _), this.writable = !0, this.readable = !0;
    var $ = this;
    this._parser.onend = function() {
      $.emit("end");
    }, this._parser.onerror = function(k) {
      $.emit("error", k), $._parser.error = null;
    }, this._decoder = null, o.forEach(function(k) {
      Object.defineProperty($, "on" + k, {
        get: function() {
          return $._parser["on" + k];
        },
        set: function(de) {
          if (!de)
            return $.removeAllListeners(k), $._parser["on" + k] = de, de;
          $.on(k, de);
        },
        enumerable: !0,
        configurable: !1
      });
    });
  }
  u.prototype = Object.create(i.prototype, { constructor: { value: u } }), u.prototype.write = function(S) {
    return this._parser.write(S.toString()), this.emit("data", S), !0;
  }, u.prototype.end = function(S) {
    return S && S.length && this.write(S), this._parser.end(), !0;
  }, u.prototype.on = function(S, _) {
    var $ = this;
    return !$._parser["on" + S] && o.indexOf(S) !== -1 && ($._parser["on" + S] = function() {
      var k = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments);
      k.splice(0, 0, S), $.emit.apply($, k);
    }), i.prototype.on.call($, S, _);
  };
  var l = "[CDATA[", d = "DOCTYPE", h = "http://www.w3.org/XML/1998/namespace", f = "http://www.w3.org/2000/xmlns/", p = {
    xml: h,
    xmlns: f
  }, y = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/, m = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/, v = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/, g = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
  function w(S) {
    return S === " " || S === `
` || S === "\r" || S === "	";
  }
  function T(S) {
    return S === '"' || S === "'";
  }
  function x(S) {
    return S === ">" || w(S);
  }
  function O(S, _) {
    return S.test(_);
  }
  function R(S, _) {
    return !O(S, _);
  }
  var E = 0;
  r.STATE = {
    BEGIN: E++,
    BEGIN_WHITESPACE: E++,
    TEXT: E++,
    TEXT_ENTITY: E++,
    OPEN_WAKA: E++,
    SGML_DECL: E++,
    SGML_DECL_QUOTED: E++,
    DOCTYPE: E++,
    DOCTYPE_QUOTED: E++,
    DOCTYPE_DTD: E++,
    DOCTYPE_DTD_QUOTED: E++,
    COMMENT_STARTING: E++,
    COMMENT: E++,
    COMMENT_ENDING: E++,
    COMMENT_ENDED: E++,
    CDATA: E++,
    CDATA_ENDING: E++,
    CDATA_ENDING_2: E++,
    PROC_INST: E++,
    PROC_INST_BODY: E++,
    PROC_INST_ENDING: E++,
    OPEN_TAG: E++,
    OPEN_TAG_SLASH: E++,
    ATTRIB: E++,
    ATTRIB_NAME: E++,
    ATTRIB_NAME_SAW_WHITE: E++,
    ATTRIB_VALUE: E++,
    ATTRIB_VALUE_QUOTED: E++,
    ATTRIB_VALUE_CLOSED: E++,
    ATTRIB_VALUE_UNQUOTED: E++,
    ATTRIB_VALUE_ENTITY_Q: E++,
    ATTRIB_VALUE_ENTITY_U: E++,
    CLOSE_TAG: E++,
    CLOSE_TAG_SAW_WHITE: E++,
    SCRIPT: E++,
    SCRIPT_ENDING: E++
  }, r.XML_ENTITIES = {
    amp: "&",
    gt: ">",
    lt: "<",
    quot: '"',
    apos: "'"
  }, r.ENTITIES = {
    amp: "&",
    gt: ">",
    lt: "<",
    quot: '"',
    apos: "'",
    AElig: 198,
    Aacute: 193,
    Acirc: 194,
    Agrave: 192,
    Aring: 197,
    Atilde: 195,
    Auml: 196,
    Ccedil: 199,
    ETH: 208,
    Eacute: 201,
    Ecirc: 202,
    Egrave: 200,
    Euml: 203,
    Iacute: 205,
    Icirc: 206,
    Igrave: 204,
    Iuml: 207,
    Ntilde: 209,
    Oacute: 211,
    Ocirc: 212,
    Ograve: 210,
    Oslash: 216,
    Otilde: 213,
    Ouml: 214,
    THORN: 222,
    Uacute: 218,
    Ucirc: 219,
    Ugrave: 217,
    Uuml: 220,
    Yacute: 221,
    aacute: 225,
    acirc: 226,
    aelig: 230,
    agrave: 224,
    aring: 229,
    atilde: 227,
    auml: 228,
    ccedil: 231,
    eacute: 233,
    ecirc: 234,
    egrave: 232,
    eth: 240,
    euml: 235,
    iacute: 237,
    icirc: 238,
    igrave: 236,
    iuml: 239,
    ntilde: 241,
    oacute: 243,
    ocirc: 244,
    ograve: 242,
    oslash: 248,
    otilde: 245,
    ouml: 246,
    szlig: 223,
    thorn: 254,
    uacute: 250,
    ucirc: 251,
    ugrave: 249,
    uuml: 252,
    yacute: 253,
    yuml: 255,
    copy: 169,
    reg: 174,
    nbsp: 160,
    iexcl: 161,
    cent: 162,
    pound: 163,
    curren: 164,
    yen: 165,
    brvbar: 166,
    sect: 167,
    uml: 168,
    ordf: 170,
    laquo: 171,
    not: 172,
    shy: 173,
    macr: 175,
    deg: 176,
    plusmn: 177,
    sup1: 185,
    sup2: 178,
    sup3: 179,
    acute: 180,
    micro: 181,
    para: 182,
    middot: 183,
    cedil: 184,
    ordm: 186,
    raquo: 187,
    frac14: 188,
    frac12: 189,
    frac34: 190,
    iquest: 191,
    times: 215,
    divide: 247,
    OElig: 338,
    oelig: 339,
    Scaron: 352,
    scaron: 353,
    Yuml: 376,
    fnof: 402,
    circ: 710,
    tilde: 732,
    Alpha: 913,
    Beta: 914,
    Gamma: 915,
    Delta: 916,
    Epsilon: 917,
    Zeta: 918,
    Eta: 919,
    Theta: 920,
    Iota: 921,
    Kappa: 922,
    Lambda: 923,
    Mu: 924,
    Nu: 925,
    Xi: 926,
    Omicron: 927,
    Pi: 928,
    Rho: 929,
    Sigma: 931,
    Tau: 932,
    Upsilon: 933,
    Phi: 934,
    Chi: 935,
    Psi: 936,
    Omega: 937,
    alpha: 945,
    beta: 946,
    gamma: 947,
    delta: 948,
    epsilon: 949,
    zeta: 950,
    eta: 951,
    theta: 952,
    iota: 953,
    kappa: 954,
    lambda: 955,
    mu: 956,
    nu: 957,
    xi: 958,
    omicron: 959,
    pi: 960,
    rho: 961,
    sigmaf: 962,
    sigma: 963,
    tau: 964,
    upsilon: 965,
    phi: 966,
    chi: 967,
    psi: 968,
    omega: 969,
    thetasym: 977,
    upsih: 978,
    piv: 982,
    ensp: 8194,
    emsp: 8195,
    thinsp: 8201,
    zwnj: 8204,
    zwj: 8205,
    lrm: 8206,
    rlm: 8207,
    ndash: 8211,
    mdash: 8212,
    lsquo: 8216,
    rsquo: 8217,
    sbquo: 8218,
    ldquo: 8220,
    rdquo: 8221,
    bdquo: 8222,
    dagger: 8224,
    Dagger: 8225,
    bull: 8226,
    hellip: 8230,
    permil: 8240,
    prime: 8242,
    Prime: 8243,
    lsaquo: 8249,
    rsaquo: 8250,
    oline: 8254,
    frasl: 8260,
    euro: 8364,
    image: 8465,
    weierp: 8472,
    real: 8476,
    trade: 8482,
    alefsym: 8501,
    larr: 8592,
    uarr: 8593,
    rarr: 8594,
    darr: 8595,
    harr: 8596,
    crarr: 8629,
    lArr: 8656,
    uArr: 8657,
    rArr: 8658,
    dArr: 8659,
    hArr: 8660,
    forall: 8704,
    part: 8706,
    exist: 8707,
    empty: 8709,
    nabla: 8711,
    isin: 8712,
    notin: 8713,
    ni: 8715,
    prod: 8719,
    sum: 8721,
    minus: 8722,
    lowast: 8727,
    radic: 8730,
    prop: 8733,
    infin: 8734,
    ang: 8736,
    and: 8743,
    or: 8744,
    cap: 8745,
    cup: 8746,
    int: 8747,
    there4: 8756,
    sim: 8764,
    cong: 8773,
    asymp: 8776,
    ne: 8800,
    equiv: 8801,
    le: 8804,
    ge: 8805,
    sub: 8834,
    sup: 8835,
    nsub: 8836,
    sube: 8838,
    supe: 8839,
    oplus: 8853,
    otimes: 8855,
    perp: 8869,
    sdot: 8901,
    lceil: 8968,
    rceil: 8969,
    lfloor: 8970,
    rfloor: 8971,
    lang: 9001,
    rang: 9002,
    loz: 9674,
    spades: 9824,
    clubs: 9827,
    hearts: 9829,
    diams: 9830
  }, Object.keys(r.ENTITIES).forEach(function(S) {
    var _ = r.ENTITIES[S], $ = typeof _ == "number" ? String.fromCharCode(_) : _;
    r.ENTITIES[S] = $;
  });
  for (var V in r.STATE) r.STATE[r.STATE[V]] = V;
  E = r.STATE;
  function ne(S, _, $) {
    S[_] && S[_]($);
  }
  function z(S, _, $) {
    S.textNode && Te(S), ne(S, _, $);
  }
  function Te(S) {
    S.textNode = Oe(S.opt, S.textNode), S.textNode && ne(S, "ontext", S.textNode), S.textNode = "";
  }
  function Oe(S, _) {
    return S.trim && (_ = _.trim()), S.normalize && (_ = _.replace(/\s+/g, " ")), _;
  }
  function Z(S, _) {
    return Te(S), S.trackPosition && (_ += `
Line: ` + S.line + `
Column: ` + S.column + `
Char: ` + S.c), _ = new Error(_), S.error = _, ne(S, "onerror", _), S;
  }
  function D(S) {
    return S.sawRoot && !S.closedRoot && U(S, "Unclosed root tag"), S.state !== E.BEGIN && S.state !== E.BEGIN_WHITESPACE && S.state !== E.TEXT && Z(S, "Unexpected end"), Te(S), S.c = "", S.closed = !0, ne(S, "onend"), t.call(S, S.strict, S.opt), S;
  }
  function U(S, _) {
    if (typeof S != "object" || !(S instanceof t)) throw new Error("bad call to strictFail");
    S.strict && Z(S, _);
  }
  function A(S) {
    S.strict || (S.tagName = S.tagName[S.looseCase]());
    var _ = S.tags[S.tags.length - 1] || S, $ = S.tag = {
      name: S.tagName,
      attributes: {}
    };
    S.opt.xmlns && ($.ns = _.ns), S.attribList.length = 0, z(S, "onopentagstart", $);
  }
  function P(S, _) {
    var $ = S.indexOf(":"), k = $ < 0 ? ["", S] : S.split(":"), de = k[0], ge = k[1];
    return _ && S === "xmlns" && (de = "xmlns", ge = ""), {
      prefix: de,
      local: ge
    };
  }
  function N(S) {
    if (S.strict || (S.attribName = S.attribName[S.looseCase]()), S.attribList.indexOf(S.attribName) !== -1 || S.tag.attributes.hasOwnProperty(S.attribName)) {
      S.attribName = S.attribValue = "";
      return;
    }
    if (S.opt.xmlns) {
      var _ = P(S.attribName, !0), $ = _.prefix, k = _.local;
      if ($ === "xmlns") if (k === "xml" && S.attribValue !== h) U(S, "xml: prefix must be bound to " + h + `
Actual: ` + S.attribValue);
      else if (k === "xmlns" && S.attribValue !== f) U(S, "xmlns: prefix must be bound to " + f + `
Actual: ` + S.attribValue);
      else {
        var de = S.tag, ge = S.tags[S.tags.length - 1] || S;
        de.ns === ge.ns && (de.ns = Object.create(ge.ns)), de.ns[k] = S.attribValue;
      }
      S.attribList.push([S.attribName, S.attribValue]);
    } else
      S.tag.attributes[S.attribName] = S.attribValue, z(S, "onattribute", {
        name: S.attribName,
        value: S.attribValue
      });
    S.attribName = S.attribValue = "";
  }
  function j(S, _) {
    if (S.opt.xmlns) {
      var $ = S.tag, k = P(S.tagName);
      $.prefix = k.prefix, $.local = k.local, $.uri = $.ns[k.prefix] || "", $.prefix && !$.uri && (U(S, "Unbound namespace prefix: " + JSON.stringify(S.tagName)), $.uri = k.prefix);
      var de = S.tags[S.tags.length - 1] || S;
      $.ns && de.ns !== $.ns && Object.keys($.ns).forEach(function(hn) {
        z(S, "onopennamespace", {
          prefix: hn,
          uri: $.ns[hn]
        });
      });
      for (var ge = 0, Me = S.attribList.length; ge < Me; ge++) {
        var Ue = S.attribList[ge], at = Ue[0], Yt = Ue[1], He = P(at, !0), Jt = He.prefix, Cn = He.local, va = Jt === "" ? "" : $.ns[Jt] || "", G = {
          name: at,
          value: Yt,
          prefix: Jt,
          local: Cn,
          uri: va
        };
        Jt && Jt !== "xmlns" && !va && (U(S, "Unbound namespace prefix: " + JSON.stringify(Jt)), G.uri = Jt), S.tag.attributes[at] = G, z(S, "onattribute", G);
      }
      S.attribList.length = 0;
    }
    S.tag.isSelfClosing = !!_, S.sawRoot = !0, S.tags.push(S.tag), z(S, "onopentag", S.tag), _ || (!S.noscript && S.tagName.toLowerCase() === "script" ? S.state = E.SCRIPT : S.state = E.TEXT, S.tag = null, S.tagName = ""), S.attribName = S.attribValue = "", S.attribList.length = 0;
  }
  function M(S) {
    if (!S.tagName) {
      U(S, "Weird empty close tag."), S.textNode += "</>", S.state = E.TEXT;
      return;
    }
    if (S.script) {
      if (S.tagName !== "script") {
        S.script += "</" + S.tagName + ">", S.tagName = "", S.state = E.SCRIPT;
        return;
      }
      z(S, "onscript", S.script), S.script = "";
    }
    var _ = S.tags.length, $ = S.tagName;
    S.strict || ($ = $[S.looseCase]());
    for (var k = $; _--; ) {
      var de = S.tags[_];
      if (de.name !== k) U(S, "Unexpected close tag");
      else break;
    }
    if (_ < 0) {
      U(S, "Unmatched closing tag: " + S.tagName), S.textNode += "</" + S.tagName + ">", S.state = E.TEXT;
      return;
    }
    S.tagName = $;
    for (var ge = S.tags.length; ge-- > _; ) {
      var Me = S.tag = S.tags.pop();
      S.tagName = S.tag.name, z(S, "onclosetag", S.tagName);
      var Ue = {};
      for (var at in Me.ns) Ue[at] = Me.ns[at];
      var Yt = S.tags[S.tags.length - 1] || S;
      S.opt.xmlns && Me.ns !== Yt.ns && Object.keys(Me.ns).forEach(function(He) {
        var Jt = Me.ns[He];
        z(S, "onclosenamespace", {
          prefix: He,
          uri: Jt
        });
      });
    }
    _ === 0 && (S.closedRoot = !0), S.tagName = S.attribValue = S.attribName = "", S.attribList.length = 0, S.state = E.TEXT;
  }
  function q(S) {
    var _ = S.entity, $ = _.toLowerCase(), k, de = "";
    return S.ENTITIES[_] ? S.ENTITIES[_] : S.ENTITIES[$] ? S.ENTITIES[$] : (_ = $, _.charAt(0) === "#" && (_.charAt(1) === "x" ? (_ = _.slice(2), k = parseInt(_, 16), de = k.toString(16)) : (_ = _.slice(1), k = parseInt(_, 10), de = k.toString(10))), _ = _.replace(/^0+/, ""), isNaN(k) || de.toLowerCase() !== _ ? (U(S, "Invalid character entity"), "&" + S.entity + ";") : String.fromCodePoint(k));
  }
  function se(S, _) {
    _ === "<" ? (S.state = E.OPEN_WAKA, S.startTagPosition = S.position) : w(_) || (U(S, "Non-whitespace before first tag."), S.textNode = _, S.state = E.TEXT);
  }
  function Ee(S, _) {
    var $ = "";
    return _ < S.length && ($ = S.charAt(_)), $;
  }
  function ae(S) {
    var _ = this;
    if (this.error) throw this.error;
    if (_.closed) return Z(_, "Cannot write after close. Assign an onready handler.");
    if (S === null) return D(_);
    typeof S == "object" && (S = S.toString());
    for (var $ = 0, k = ""; k = Ee(S, $++), _.c = k, !!k; )
      switch (_.trackPosition && (_.position++, k === `
` ? (_.line++, _.column = 0) : _.column++), _.state) {
        case E.BEGIN:
          if (_.state = E.BEGIN_WHITESPACE, k === "\uFEFF") continue;
          se(_, k);
          continue;
        case E.BEGIN_WHITESPACE:
          se(_, k);
          continue;
        case E.TEXT:
          if (_.sawRoot && !_.closedRoot) {
            for (var de = $ - 1; k && k !== "<" && k !== "&"; )
              k = Ee(S, $++), k && _.trackPosition && (_.position++, k === `
` ? (_.line++, _.column = 0) : _.column++);
            _.textNode += S.substring(de, $ - 1);
          }
          k === "<" && !(_.sawRoot && _.closedRoot && !_.strict) ? (_.state = E.OPEN_WAKA, _.startTagPosition = _.position) : (!w(k) && (!_.sawRoot || _.closedRoot) && U(_, "Text data outside of root node."), k === "&" ? _.state = E.TEXT_ENTITY : _.textNode += k);
          continue;
        case E.SCRIPT:
          k === "<" ? _.state = E.SCRIPT_ENDING : _.script += k;
          continue;
        case E.SCRIPT_ENDING:
          k === "/" ? _.state = E.CLOSE_TAG : (_.script += "<" + k, _.state = E.SCRIPT);
          continue;
        case E.OPEN_WAKA:
          if (k === "!")
            _.state = E.SGML_DECL, _.sgmlDecl = "";
          else if (!w(k)) if (O(y, k))
            _.state = E.OPEN_TAG, _.tagName = k;
          else if (k === "/")
            _.state = E.CLOSE_TAG, _.tagName = "";
          else if (k === "?")
            _.state = E.PROC_INST, _.procInstName = _.procInstBody = "";
          else {
            if (U(_, "Unencoded <"), _.startTagPosition + 1 < _.position) {
              var ge = _.position - _.startTagPosition;
              k = new Array(ge).join(" ") + k;
            }
            _.textNode += "<" + k, _.state = E.TEXT;
          }
          continue;
        case E.SGML_DECL:
          (_.sgmlDecl + k).toUpperCase() === l ? (z(_, "onopencdata"), _.state = E.CDATA, _.sgmlDecl = "", _.cdata = "") : _.sgmlDecl + k === "--" ? (_.state = E.COMMENT, _.comment = "", _.sgmlDecl = "") : (_.sgmlDecl + k).toUpperCase() === d ? (_.state = E.DOCTYPE, (_.doctype || _.sawRoot) && U(_, "Inappropriately located doctype declaration"), _.doctype = "", _.sgmlDecl = "") : k === ">" ? (z(_, "onsgmldeclaration", _.sgmlDecl), _.sgmlDecl = "", _.state = E.TEXT) : (T(k) && (_.state = E.SGML_DECL_QUOTED), _.sgmlDecl += k);
          continue;
        case E.SGML_DECL_QUOTED:
          k === _.q && (_.state = E.SGML_DECL, _.q = ""), _.sgmlDecl += k;
          continue;
        case E.DOCTYPE:
          k === ">" ? (_.state = E.TEXT, z(_, "ondoctype", _.doctype), _.doctype = !0) : (_.doctype += k, k === "[" ? _.state = E.DOCTYPE_DTD : T(k) && (_.state = E.DOCTYPE_QUOTED, _.q = k));
          continue;
        case E.DOCTYPE_QUOTED:
          _.doctype += k, k === _.q && (_.q = "", _.state = E.DOCTYPE);
          continue;
        case E.DOCTYPE_DTD:
          _.doctype += k, k === "]" ? _.state = E.DOCTYPE : T(k) && (_.state = E.DOCTYPE_DTD_QUOTED, _.q = k);
          continue;
        case E.DOCTYPE_DTD_QUOTED:
          _.doctype += k, k === _.q && (_.state = E.DOCTYPE_DTD, _.q = "");
          continue;
        case E.COMMENT:
          k === "-" ? _.state = E.COMMENT_ENDING : _.comment += k;
          continue;
        case E.COMMENT_ENDING:
          k === "-" ? (_.state = E.COMMENT_ENDED, _.comment = Oe(_.opt, _.comment), _.comment && z(_, "oncomment", _.comment), _.comment = "") : (_.comment += "-" + k, _.state = E.COMMENT);
          continue;
        case E.COMMENT_ENDED:
          k !== ">" ? (U(_, "Malformed comment"), _.comment += "--" + k, _.state = E.COMMENT) : _.state = E.TEXT;
          continue;
        case E.CDATA:
          k === "]" ? _.state = E.CDATA_ENDING : _.cdata += k;
          continue;
        case E.CDATA_ENDING:
          k === "]" ? _.state = E.CDATA_ENDING_2 : (_.cdata += "]" + k, _.state = E.CDATA);
          continue;
        case E.CDATA_ENDING_2:
          k === ">" ? (_.cdata && z(_, "oncdata", _.cdata), z(_, "onclosecdata"), _.cdata = "", _.state = E.TEXT) : k === "]" ? _.cdata += "]" : (_.cdata += "]]" + k, _.state = E.CDATA);
          continue;
        case E.PROC_INST:
          k === "?" ? _.state = E.PROC_INST_ENDING : w(k) ? _.state = E.PROC_INST_BODY : _.procInstName += k;
          continue;
        case E.PROC_INST_BODY:
          if (!_.procInstBody && w(k)) continue;
          k === "?" ? _.state = E.PROC_INST_ENDING : _.procInstBody += k;
          continue;
        case E.PROC_INST_ENDING:
          k === ">" ? (z(_, "onprocessinginstruction", {
            name: _.procInstName,
            body: _.procInstBody
          }), _.procInstName = _.procInstBody = "", _.state = E.TEXT) : (_.procInstBody += "?" + k, _.state = E.PROC_INST_BODY);
          continue;
        case E.OPEN_TAG:
          O(m, k) ? _.tagName += k : (A(_), k === ">" ? j(_) : k === "/" ? _.state = E.OPEN_TAG_SLASH : (w(k) || U(_, "Invalid character in tag name"), _.state = E.ATTRIB));
          continue;
        case E.OPEN_TAG_SLASH:
          k === ">" ? (j(_, !0), M(_)) : (U(_, "Forward-slash in opening tag not followed by >"), _.state = E.ATTRIB);
          continue;
        case E.ATTRIB:
          if (w(k)) continue;
          k === ">" ? j(_) : k === "/" ? _.state = E.OPEN_TAG_SLASH : O(y, k) ? (_.attribName = k, _.attribValue = "", _.state = E.ATTRIB_NAME) : U(_, "Invalid attribute name");
          continue;
        case E.ATTRIB_NAME:
          k === "=" ? _.state = E.ATTRIB_VALUE : k === ">" ? (U(_, "Attribute without value"), _.attribValue = _.attribName, N(_), j(_)) : w(k) ? _.state = E.ATTRIB_NAME_SAW_WHITE : O(m, k) ? _.attribName += k : U(_, "Invalid attribute name");
          continue;
        case E.ATTRIB_NAME_SAW_WHITE:
          if (k === "=") _.state = E.ATTRIB_VALUE;
          else {
            if (w(k)) continue;
            U(_, "Attribute without value"), _.tag.attributes[_.attribName] = "", _.attribValue = "", z(_, "onattribute", {
              name: _.attribName,
              value: ""
            }), _.attribName = "", k === ">" ? j(_) : O(y, k) ? (_.attribName = k, _.state = E.ATTRIB_NAME) : (U(_, "Invalid attribute name"), _.state = E.ATTRIB);
          }
          continue;
        case E.ATTRIB_VALUE:
          if (w(k)) continue;
          T(k) ? (_.q = k, _.state = E.ATTRIB_VALUE_QUOTED) : (U(_, "Unquoted attribute value"), _.state = E.ATTRIB_VALUE_UNQUOTED, _.attribValue = k);
          continue;
        case E.ATTRIB_VALUE_QUOTED:
          if (k !== _.q) {
            k === "&" ? _.state = E.ATTRIB_VALUE_ENTITY_Q : _.attribValue += k;
            continue;
          }
          N(_), _.q = "", _.state = E.ATTRIB_VALUE_CLOSED;
          continue;
        case E.ATTRIB_VALUE_CLOSED:
          w(k) ? _.state = E.ATTRIB : k === ">" ? j(_) : k === "/" ? _.state = E.OPEN_TAG_SLASH : O(y, k) ? (U(_, "No whitespace between attributes"), _.attribName = k, _.attribValue = "", _.state = E.ATTRIB_NAME) : U(_, "Invalid attribute name");
          continue;
        case E.ATTRIB_VALUE_UNQUOTED:
          if (!x(k)) {
            k === "&" ? _.state = E.ATTRIB_VALUE_ENTITY_U : _.attribValue += k;
            continue;
          }
          N(_), k === ">" ? j(_) : _.state = E.ATTRIB;
          continue;
        case E.CLOSE_TAG:
          if (_.tagName) k === ">" ? M(_) : O(m, k) ? _.tagName += k : _.script ? (_.script += "</" + _.tagName, _.tagName = "", _.state = E.SCRIPT) : (w(k) || U(_, "Invalid tagname in closing tag"), _.state = E.CLOSE_TAG_SAW_WHITE);
          else {
            if (w(k)) continue;
            R(y, k) ? _.script ? (_.script += "</" + k, _.state = E.SCRIPT) : U(_, "Invalid tagname in closing tag.") : _.tagName = k;
          }
          continue;
        case E.CLOSE_TAG_SAW_WHITE:
          if (w(k)) continue;
          k === ">" ? M(_) : U(_, "Invalid characters in closing tag");
          continue;
        case E.TEXT_ENTITY:
        case E.ATTRIB_VALUE_ENTITY_Q:
        case E.ATTRIB_VALUE_ENTITY_U:
          var Me, Ue;
          switch (_.state) {
            case E.TEXT_ENTITY:
              Me = E.TEXT, Ue = "textNode";
              break;
            case E.ATTRIB_VALUE_ENTITY_Q:
              Me = E.ATTRIB_VALUE_QUOTED, Ue = "attribValue";
              break;
            case E.ATTRIB_VALUE_ENTITY_U:
              Me = E.ATTRIB_VALUE_UNQUOTED, Ue = "attribValue";
              break;
          }
          if (k === ";") if (_.opt.unparsedEntities) {
            var at = q(_);
            _.entity = "", _.state = Me, _.write(at);
          } else
            _[Ue] += q(_), _.entity = "", _.state = Me;
          else O(_.entity.length ? g : v, k) ? _.entity += k : (U(_, "Invalid character in entity name"), _[Ue] += "&" + _.entity + k, _.entity = "", _.state = Me);
          continue;
        default:
          throw new Error(_, "Unknown state: " + _.state);
      }
    return _.position >= _.bufferCheckPosition && n(_), _;
  }
  /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */
  return String.fromCodePoint || function() {
    var S = String.fromCharCode, _ = Math.floor, $ = function() {
      var k = 16384, de = [], ge, Me, Ue = -1, at = arguments.length;
      if (!at) return "";
      for (var Yt = ""; ++Ue < at; ) {
        var He = Number(arguments[Ue]);
        if (!isFinite(He) || He < 0 || He > 1114111 || _(He) !== He) throw RangeError("Invalid code point: " + He);
        He <= 65535 ? de.push(He) : (He -= 65536, ge = (He >> 10) + 55296, Me = He % 1024 + 56320, de.push(ge, Me)), (Ue + 1 === at || de.length > k) && (Yt += S.apply(null, de), de.length = 0);
      }
      return Yt;
    };
    Object.defineProperty ? Object.defineProperty(String, "fromCodePoint", {
      value: $,
      configurable: !0,
      writable: !0
    }) : String.fromCodePoint = $;
  }(), r;
}, e1 = QC(), yu = `The output should be formatted as a XML file.
1. Output should conform to the tags below. 
2. If tags are not given, make them on your own.
3. Remember to always open and close all the tags.

As an example, for the tags ["foo", "bar", "baz"]:
1. String "<foo>
   <bar>
      <baz></baz>
   </bar>
</foo>" is a well-formatted instance of the schema. 
2. String "<foo>
   <bar>
   </foo>" is a badly-formatted instance.
3. String "<foo>
   <tag>
   </tag>
</foo>" is a badly-formatted instance.

Here are the output tags:
\`\`\`
{tags}
\`\`\``;
var t1 = class extends Po {
  constructor(e) {
    super(e);
    b(this, "tags");
    b(this, "lc_namespace", ["langchain_core", "output_parsers"]);
    b(this, "lc_serializable", !0);
    this.tags = e == null ? void 0 : e.tags;
  }
  static lc_name() {
    return "XMLOutputParser";
  }
  _diff(e, t) {
    if (t)
      return e ? wl(e, t) : [{
        op: "replace",
        path: "",
        value: t
      }];
  }
  async parsePartialResult(e) {
    return wu(e[0].text);
  }
  async parse(e) {
    return wu(e);
  }
  getFormatInstructions() {
    var t;
    return !!(this.tags && this.tags.length > 0) ? yu.replace("{tags}", ((t = this.tags) == null ? void 0 : t.join(", ")) ?? "") : yu;
  }
};
const r1 = (r) => r.split(`
`).map((e) => e.replace(/^\s+/, "")).join(`
`).trim(), X_ = (r) => {
  if (Object.keys(r).length === 0) return {};
  const e = {};
  return r.children.length > 0 ? (e[r.name] = r.children.map(X_), e) : (e[r.name] = r.text ?? void 0, e);
};
function wu(r) {
  const e = r1(r), t = e1.parser(!0);
  let n = {};
  const s = [];
  t.onopentag = (o) => {
    const c = {
      name: o.name,
      attributes: o.attributes,
      children: [],
      text: "",
      isSelfClosing: o.isSelfClosing
    };
    s.length > 0 ? s[s.length - 1].children.push(c) : n = c, o.isSelfClosing || s.push(c);
  }, t.onclosetag = () => {
    if (s.length > 0) {
      const o = s.pop();
      s.length === 0 && o && (n = o);
    }
  }, t.ontext = (o) => {
    if (s.length > 0) {
      const c = s[s.length - 1];
      c.text += o;
    }
  }, t.onattribute = (o) => {
    if (s.length > 0) {
      const c = s[s.length - 1];
      c.attributes[o.name] = o.value;
    }
  };
  const a = /```(xml)?(.*)```/s.exec(e), i = a ? a[2] : e;
  return t.write(i).close(), n && n.name === "?xml" && (n = n.children[0]), X_(n);
}
var n1 = {};
Ae(n1, {
  AsymmetricStructuredOutputParser: () => XC,
  BaseCumulativeTransformOutputParser: () => Po,
  BaseLLMOutputParser: () => K_,
  BaseOutputParser: () => No,
  BaseTransformOutputParser: () => ya,
  BytesOutputParser: () => JC,
  CommaSeparatedListOutputParser: () => HC,
  CustomListOutputParser: () => GC,
  JsonMarkdownStructuredOutputParser: () => Y_,
  JsonOutputParser: () => _u,
  ListOutputParser: () => wa,
  MarkdownListOutputParser: () => KC,
  NumberedListOutputParser: () => WC,
  OutputParserException: () => jr,
  StringOutputParser: () => YC,
  StructuredOutputParser: () => Ji,
  XMLOutputParser: () => t1,
  XML_FORMAT_INSTRUCTIONS: () => yu,
  parseJsonMarkdown: () => Lc,
  parsePartialJson: () => oo,
  parseXMLMarkdown: () => wu
});
function Lo(r, e) {
  if (r.function === void 0) return;
  let t;
  if (e != null && e.partial) try {
    t = oo(r.function.arguments ?? "{}");
  } catch {
    return;
  }
  else try {
    t = JSON.parse(r.function.arguments);
  } catch (s) {
    throw new jr([
      `Function "${r.function.name}" arguments:`,
      "",
      r.function.arguments,
      "",
      "are not valid JSON.",
      `Error: ${s.message}`
    ].join(`
`));
  }
  const n = {
    name: r.function.name,
    args: t,
    type: "tool_call"
  };
  return e != null && e.returnId && (n.id = r.id), n;
}
function Q_(r) {
  if (r.id === void 0) throw new Error('All OpenAI tool calls must have an "id" field.');
  return {
    id: r.id,
    type: "function",
    function: {
      name: r.name,
      arguments: JSON.stringify(r.args)
    }
  };
}
function Hi(r, e) {
  var t, n;
  return {
    name: (t = r.function) == null ? void 0 : t.name,
    args: (n = r.function) == null ? void 0 : n.arguments,
    id: r.id,
    error: e,
    type: "invalid_tool_call"
  };
}
var ey = class extends Po {
  constructor(e) {
    super(e);
    b(this, "returnId", !1);
    b(this, "lc_namespace", [
      "langchain",
      "output_parsers",
      "openai_tools"
    ]);
    b(this, "lc_serializable", !0);
    this.returnId = (e == null ? void 0 : e.returnId) ?? this.returnId;
  }
  static lc_name() {
    return "JsonOutputToolsParser";
  }
  _diff() {
    throw new Error("Not supported.");
  }
  async parse() {
    throw new Error("Not implemented.");
  }
  async parseResult(e) {
    return await this.parsePartialResult(e, !1);
  }
  /**
  * Parses the output and returns a JSON object. If `argsOnly` is true,
  * only the arguments of the function call are returned.
  * @param generations The output of the LLM to parse.
  * @returns A JSON object representation of the function call or its arguments.
  */
  async parsePartialResult(e, t = !0) {
    var i;
    const n = e[0].message;
    let s;
    if (co(n) && ((i = n.tool_calls) != null && i.length) ? s = n.tool_calls.map((o) => {
      const { id: c, ...u } = o;
      return this.returnId ? {
        id: c,
        ...u
      } : u;
    }) : n.additional_kwargs.tool_calls !== void 0 && (s = JSON.parse(JSON.stringify(n.additional_kwargs.tool_calls)).map((c) => Lo(c, {
      returnId: this.returnId,
      partial: t
    }))), !s) return [];
    const a = [];
    for (const o of s) if (o !== void 0) {
      const c = {
        type: o.name,
        args: o.args,
        id: o.id
      };
      a.push(c);
    }
    return a;
  }
}, vu = class extends ey {
  constructor(e) {
    super(e);
    b(this, "lc_namespace", [
      "langchain",
      "output_parsers",
      "openai_tools"
    ]);
    b(this, "lc_serializable", !0);
    b(this, "returnId", !1);
    /** The type of tool calls to return. */
    b(this, "keyName");
    /** Whether to return only the first tool call. */
    b(this, "returnSingle", !1);
    b(this, "zodSchema");
    this.keyName = e.keyName, this.returnSingle = e.returnSingle ?? this.returnSingle, this.zodSchema = e.zodSchema;
  }
  static lc_name() {
    return "JsonOutputKeyToolsParser";
  }
  async _validateResult(e) {
    var n;
    if (this.zodSchema === void 0) return e;
    const t = await e_(this.zodSchema, e);
    if (t.success) return t.data;
    throw new jr(`Failed to parse. Text: "${JSON.stringify(e, null, 2)}". Error: ${JSON.stringify((n = t.error) == null ? void 0 : n.issues)}`, JSON.stringify(e, null, 2));
  }
  async parsePartialResult(e) {
    const n = (await super.parsePartialResult(e)).filter((a) => a.type === this.keyName);
    let s = n;
    if (n.length)
      return this.returnId || (s = n.map((a) => a.args)), this.returnSingle ? s[0] : s;
  }
  async parseResult(e) {
    const n = (await super.parsePartialResult(e, !1)).filter((i) => i.type === this.keyName);
    let s = n;
    return n.length ? (this.returnId || (s = n.map((i) => i.args)), this.returnSingle ? this._validateResult(s[0]) : await Promise.all(s.map((i) => this._validateResult(i)))) : void 0;
  }
}, s1 = {};
Ae(s1, {
  JsonOutputKeyToolsParser: () => vu,
  JsonOutputToolsParser: () => ey,
  convertLangChainToolCallToOpenAI: () => Q_,
  makeInvalidToolCall: () => Hi,
  parseToolCall: () => Lo
});
var ql = class extends Vl {
  constructor(e) {
    var n, s, a, i;
    super(e ?? {});
    b(this, "temperature");
    b(this, "topP");
    b(this, "frequencyPenalty");
    b(this, "presencePenalty");
    b(this, "n");
    b(this, "logitBias");
    b(this, "model", "gpt-3.5-turbo");
    b(this, "modelKwargs");
    b(this, "stop");
    b(this, "stopSequences");
    b(this, "user");
    b(this, "timeout");
    b(this, "streaming", !1);
    b(this, "streamUsage", !0);
    b(this, "maxTokens");
    b(this, "logprobs");
    b(this, "topLogprobs");
    b(this, "apiKey");
    b(this, "organization");
    b(this, "__includeRawResponse");
    /** @internal */
    b(this, "client");
    /** @internal */
    b(this, "clientConfig");
    /**
    * Whether the model supports the `strict` argument when passing in tools.
    * If `undefined` the `strict` argument will not be passed to OpenAI.
    */
    b(this, "supportsStrictToolCalling");
    b(this, "audio");
    b(this, "modalities");
    b(this, "reasoning");
    /**
    * Must be set to `true` in tenancies with Zero Data Retention. Setting to `true` will disable
    * output storage in the Responses API, but this DOES NOT enable Zero Data Retention in your
    * OpenAI organization or project. This must be configured directly with OpenAI.
    *
    * See:
    * https://platform.openai.com/docs/guides/your-data
    * https://platform.openai.com/docs/api-reference/responses/create#responses-create-store
    *
    * @default false
    */
    b(this, "zdrEnabled");
    /**
    * Service tier to use for this request. Can be "auto", "default", or "flex" or "priority".
    * Specifies the service tier for prioritization and latency optimization.
    */
    b(this, "service_tier");
    /**
    * Used by OpenAI to cache responses for similar requests to optimize your cache
    * hit rates.
    * [Learn more](https://platform.openai.com/docs/guides/prompt-caching).
    */
    b(this, "promptCacheKey");
    /**
    * The verbosity of the model's response.
    */
    b(this, "verbosity");
    b(this, "defaultOptions");
    b(this, "lc_serializable", !0);
    const t = typeof ((n = e == null ? void 0 : e.configuration) == null ? void 0 : n.apiKey) == "string" || typeof ((s = e == null ? void 0 : e.configuration) == null ? void 0 : s.apiKey) == "function" ? (a = e == null ? void 0 : e.configuration) == null ? void 0 : a.apiKey : void 0;
    this.apiKey = (e == null ? void 0 : e.apiKey) ?? t ?? Er("OPENAI_API_KEY"), this.organization = ((i = e == null ? void 0 : e.configuration) == null ? void 0 : i.organization) ?? Er("OPENAI_ORGANIZATION"), this.model = (e == null ? void 0 : e.model) ?? (e == null ? void 0 : e.modelName) ?? this.model, this.modelKwargs = (e == null ? void 0 : e.modelKwargs) ?? {}, this.timeout = e == null ? void 0 : e.timeout, this.temperature = (e == null ? void 0 : e.temperature) ?? this.temperature, this.topP = (e == null ? void 0 : e.topP) ?? this.topP, this.frequencyPenalty = (e == null ? void 0 : e.frequencyPenalty) ?? this.frequencyPenalty, this.presencePenalty = (e == null ? void 0 : e.presencePenalty) ?? this.presencePenalty, this.logprobs = e == null ? void 0 : e.logprobs, this.topLogprobs = e == null ? void 0 : e.topLogprobs, this.n = (e == null ? void 0 : e.n) ?? this.n, this.logitBias = e == null ? void 0 : e.logitBias, this.stop = (e == null ? void 0 : e.stopSequences) ?? (e == null ? void 0 : e.stop), this.stopSequences = this.stop, this.user = e == null ? void 0 : e.user, this.__includeRawResponse = e == null ? void 0 : e.__includeRawResponse, this.audio = e == null ? void 0 : e.audio, this.modalities = e == null ? void 0 : e.modalities, this.reasoning = e == null ? void 0 : e.reasoning, this.maxTokens = (e == null ? void 0 : e.maxCompletionTokens) ?? (e == null ? void 0 : e.maxTokens), this.promptCacheKey = (e == null ? void 0 : e.promptCacheKey) ?? this.promptCacheKey, this.verbosity = (e == null ? void 0 : e.verbosity) ?? this.verbosity, this.disableStreaming = (e == null ? void 0 : e.disableStreaming) === !0, this.streaming = (e == null ? void 0 : e.streaming) === !0, this.disableStreaming && (this.streaming = !1), (e == null ? void 0 : e.streaming) === !1 && (this.disableStreaming = !0), this.streamUsage = (e == null ? void 0 : e.streamUsage) ?? this.streamUsage, this.disableStreaming && (this.streamUsage = !1), this.clientConfig = {
      apiKey: this.apiKey,
      organization: this.organization,
      dangerouslyAllowBrowser: !0,
      ...e == null ? void 0 : e.configuration
    }, (e == null ? void 0 : e.supportsStrictToolCalling) !== void 0 && (this.supportsStrictToolCalling = e.supportsStrictToolCalling), (e == null ? void 0 : e.service_tier) !== void 0 && (this.service_tier = e.service_tier), this.zdrEnabled = (e == null ? void 0 : e.zdrEnabled) ?? !1;
  }
  _llmType() {
    return "openai";
  }
  static lc_name() {
    return "ChatOpenAI";
  }
  get callKeys() {
    return [
      ...super.callKeys,
      "options",
      "function_call",
      "functions",
      "tools",
      "tool_choice",
      "promptIndex",
      "response_format",
      "seed",
      "reasoning",
      "service_tier"
    ];
  }
  get lc_secrets() {
    return {
      apiKey: "OPENAI_API_KEY",
      organization: "OPENAI_ORGANIZATION"
    };
  }
  get lc_aliases() {
    return {
      apiKey: "openai_api_key",
      modelName: "model"
    };
  }
  get lc_serializable_keys() {
    return [
      "configuration",
      "logprobs",
      "topLogprobs",
      "prefixMessages",
      "supportsStrictToolCalling",
      "modalities",
      "audio",
      "temperature",
      "maxTokens",
      "topP",
      "frequencyPenalty",
      "presencePenalty",
      "n",
      "logitBias",
      "user",
      "streaming",
      "streamUsage",
      "model",
      "modelName",
      "modelKwargs",
      "stop",
      "stopSequences",
      "timeout",
      "apiKey",
      "cache",
      "maxConcurrency",
      "maxRetries",
      "verbose",
      "callbacks",
      "tags",
      "metadata",
      "disableStreaming",
      "zdrEnabled",
      "reasoning",
      "promptCacheKey",
      "verbosity"
    ];
  }
  getLsParams(e) {
    const t = this.invocationParams(e);
    return {
      ls_provider: "openai",
      ls_model_name: this.model,
      ls_model_type: "chat",
      ls_temperature: t.temperature ?? void 0,
      ls_max_tokens: t.max_tokens ?? void 0,
      ls_stop: e.stop
    };
  }
  /** @ignore */
  _identifyingParams() {
    return {
      model_name: this.model,
      ...this.invocationParams(),
      ...this.clientConfig
    };
  }
  /**
  * Get the identifying parameters for the model
  */
  identifyingParams() {
    return this._identifyingParams();
  }
  /**
  * Returns backwards compatible reasoning parameters from constructor params and call options
  * @internal
  */
  _getReasoningParams(e) {
    if (!ga(this.model)) return;
    let t;
    return this.reasoning !== void 0 && (t = {
      ...t,
      ...this.reasoning
    }), (e == null ? void 0 : e.reasoning) !== void 0 && (t = {
      ...t,
      ...e.reasoning
    }), t;
  }
  /**
  * Returns an openai compatible response format from a set of options
  * @internal
  */
  _getResponseFormat(e) {
    return e && e.type === "json_schema" && e.json_schema.schema && br(e.json_schema.schema) ? aC(e.json_schema.schema, e.json_schema.name, { description: e.json_schema.description }) : e;
  }
  _combineCallOptions(e) {
    return {
      ...this.defaultOptions,
      ...e ?? {}
    };
  }
  /** @internal */
  _getClientOptions(e) {
    if (!this.client) {
      const n = { baseURL: this.clientConfig.baseURL }, s = MO(n), a = {
        ...this.clientConfig,
        baseURL: s,
        timeout: this.timeout,
        maxRetries: 0
      };
      a.baseURL || delete a.baseURL, a.defaultHeaders = FO(a.defaultHeaders), this.client = new xe(a);
    }
    return {
      ...this.clientConfig,
      ...e
    };
  }
  _convertChatOpenAIToolToCompletionsTool(e, t) {
    return Bi(e) ? WO(e.metadata.customTool) : zl(e) ? (t == null ? void 0 : t.strict) !== void 0 ? {
      ...e,
      function: {
        ...e.function,
        strict: t.strict
      }
    } : e : BO(e, t);
  }
  bindTools(e, t) {
    let n;
    return (t == null ? void 0 : t.strict) !== void 0 ? n = t.strict : this.supportsStrictToolCalling !== void 0 && (n = this.supportsStrictToolCalling), this.withConfig({
      tools: e.map((s) => Fl(s) || Bi(s) ? s : this._convertChatOpenAIToolToCompletionsTool(s, { strict: n })),
      ...t
    });
  }
  async stream(e, t) {
    return super.stream(e, this._combineCallOptions(t));
  }
  async invoke(e, t) {
    return super.invoke(e, this._combineCallOptions(t));
  }
  /** @ignore */
  _combineLLMOutput(...e) {
    return e.reduce((t, n) => (n && n.tokenUsage && (t.tokenUsage.completionTokens += n.tokenUsage.completionTokens ?? 0, t.tokenUsage.promptTokens += n.tokenUsage.promptTokens ?? 0, t.tokenUsage.totalTokens += n.tokenUsage.totalTokens ?? 0), t), { tokenUsage: {
      completionTokens: 0,
      promptTokens: 0,
      totalTokens: 0
    } });
  }
  async getNumTokensFromMessages(e) {
    let t = 0, n = 0, s = 0;
    this.model === "gpt-3.5-turbo-0301" ? (n = 4, s = -1) : (n = 3, s = 1);
    const a = await Promise.all(e.map(async (i) => {
      var h, f, p, y, m, v;
      const o = await this.getNumTokens(i.content), c = await this.getNumTokens(_a(i)), u = i.name !== void 0 ? s + await this.getNumTokens(i.name) : 0;
      let l = o + n + c + u;
      const d = i;
      if (d._getType() === "function" && (l -= 2), (h = d.additional_kwargs) != null && h.function_call && (l += 3), (f = d == null ? void 0 : d.additional_kwargs.function_call) != null && f.name && (l += await this.getNumTokens((p = d.additional_kwargs.function_call) == null ? void 0 : p.name)), (y = d.additional_kwargs.function_call) != null && y.arguments) try {
        l += await this.getNumTokens(JSON.stringify(JSON.parse((m = d.additional_kwargs.function_call) == null ? void 0 : m.arguments)));
      } catch (g) {
        console.error("Error parsing function arguments", g, JSON.stringify(d.additional_kwargs.function_call)), l += await this.getNumTokens((v = d.additional_kwargs.function_call) == null ? void 0 : v.arguments);
      }
      return t += l, l;
    }));
    return t += 3, {
      totalCount: t,
      countPerMessage: a
    };
  }
  /** @internal */
  async _getNumTokensFromGenerations(e) {
    return (await Promise.all(e.map(async (n) => {
      var s;
      return (s = n.message.additional_kwargs) != null && s.function_call ? (await this.getNumTokensFromMessages([n.message])).countPerMessage[0] : await this.getNumTokens(n.message.content);
    }))).reduce((n, s) => n + s, 0);
  }
  /** @internal */
  async _getEstimatedTokenCountFromPrompt(e, t, n) {
    let s = (await this.getNumTokensFromMessages(e)).totalCount;
    if (t && n !== "auto") {
      const a = VO(t);
      s += await this.getNumTokens(a), s += 9;
    }
    return t && e.find((a) => a._getType() === "system") && (s -= 4), n === "none" ? s += 1 : typeof n == "object" && (s += await this.getNumTokens(n.name) + 4), s;
  }
  /**
  * Return profiling information for the model.
  *
  * Provides information about the model's capabilities and constraints,
  * including token limits, multimodal support, and advanced features like
  * tool calling and structured output.
  *
  * @returns {ModelProfile} An object describing the model's capabilities and constraints
  *
  * @example
  * ```typescript
  * const model = new ChatOpenAI({ model: "gpt-4o" });
  * const profile = model.profile;
  * console.log(profile.maxInputTokens); // 128000
  * console.log(profile.imageInputs); // true
  * ```
  */
  get profile() {
    return cC[this.model] ?? {};
  }
  /** @internal */
  _getStructuredOutputMethod(e) {
    const t = { ...e };
    if (!this.model.startsWith("gpt-3") && !this.model.startsWith("gpt-4-") && this.model !== "gpt-4") {
      if ((t == null ? void 0 : t.method) === void 0) return "jsonSchema";
    } else t.method === "jsonSchema" && console.warn(`[WARNING]: JSON Schema is not supported for model "${this.model}". Falling back to tool calling.`);
    return t.method;
  }
  /**
  * Add structured output to the model.
  *
  * The OpenAI model family supports the following structured output methods:
  * - `jsonSchema`: Use the `response_format` field in the response to return a JSON schema. Only supported with the `gpt-4o-mini`,
  *   `gpt-4o-mini-2024-07-18`, and `gpt-4o-2024-08-06` model snapshots and later.
  * - `functionCalling`: Function calling is useful when you are building an application that bridges the models and functionality
  *   of your application.
  * - `jsonMode`: JSON mode is a more basic version of the Structured Outputs feature. While JSON mode ensures that model
  *   output is valid JSON, Structured Outputs reliably matches the model's output to the schema you specify.
  *   We recommend you use `functionCalling` or `jsonSchema` if it is supported for your use case.
  *
  * The default method is `functionCalling`.
  *
  * @see https://platform.openai.com/docs/guides/structured-outputs
  * @param outputSchema - The schema to use for structured output.
  * @param config - The structured output method options.
  * @returns The model with structured output.
  */
  withStructuredOutput(e, t) {
    let n, s;
    const { schema: a, name: i, includeRaw: o } = {
      ...t,
      schema: e
    };
    if ((t == null ? void 0 : t.strict) !== void 0 && t.method === "jsonMode") throw new Error("Argument `strict` is only supported for `method` = 'function_calling'");
    const c = nC(this.model, t == null ? void 0 : t.method);
    if (c === "jsonMode") {
      br(a) ? s = Ji.fromZodSchema(a) : s = new _u();
      const h = Sr(a);
      n = this.withConfig({
        outputVersion: "v0",
        response_format: { type: "json_object" },
        ls_structured_output_format: {
          kwargs: { method: "json_mode" },
          schema: {
            title: i ?? "extract",
            ...h
          }
        }
      });
    } else if (c === "jsonSchema") {
      const h = {
        name: i ?? "extract",
        description: xo(a),
        schema: a,
        strict: t == null ? void 0 : t.strict
      }, f = Sr(h.schema);
      if (n = this.withConfig({
        outputVersion: "v0",
        response_format: {
          type: "json_schema",
          json_schema: h
        },
        ls_structured_output_format: {
          kwargs: { method: "json_schema" },
          schema: {
            title: h.name,
            description: h.description,
            ...f
          }
        }
      }), br(a)) {
        const p = Ji.fromZodSchema(a);
        s = qr.from((y) => "parsed" in y.additional_kwargs ? y.additional_kwargs.parsed : p);
      } else s = new _u();
    } else {
      let h = i ?? "extract";
      if (br(a)) {
        const f = Sr(a);
        n = this.withConfig({
          outputVersion: "v0",
          tools: [{
            type: "function",
            function: {
              name: h,
              description: f.description,
              parameters: f
            }
          }],
          tool_choice: {
            type: "function",
            function: { name: h }
          },
          ls_structured_output_format: {
            kwargs: { method: "function_calling" },
            schema: {
              title: h,
              ...f
            }
          },
          ...(t == null ? void 0 : t.strict) !== void 0 ? { strict: t.strict } : {}
        }), s = new vu({
          returnSingle: !0,
          keyName: h,
          zodSchema: a
        });
      } else {
        let f;
        typeof a.name == "string" && typeof a.parameters == "object" && a.parameters != null ? (f = a, h = a.name) : (h = a.title ?? h, f = {
          name: h,
          description: a.description ?? "",
          parameters: a
        });
        const p = Sr(a);
        n = this.withConfig({
          outputVersion: "v0",
          tools: [{
            type: "function",
            function: f
          }],
          tool_choice: {
            type: "function",
            function: { name: h }
          },
          ls_structured_output_format: {
            kwargs: { method: "function_calling" },
            schema: {
              title: h,
              ...p
            }
          },
          ...(t == null ? void 0 : t.strict) !== void 0 ? { strict: t.strict } : {}
        }), s = new vu({
          returnSingle: !0,
          keyName: h
        });
      }
    }
    if (!o) return n.pipe(s);
    const u = os.assign({ parsed: (h, f) => s.invoke(h.raw, f) }), l = os.assign({ parsed: () => null }), d = u.withFallbacks({ fallbacks: [l] });
    return ma.from([{ raw: n }, d]);
  }
};
const ty = {
  providerName: "ChatOpenAI",
  fromStandardTextBlock(r) {
    return {
      type: "text",
      text: r.text
    };
  },
  fromStandardImageBlock(r) {
    var e, t;
    if (r.source_type === "url") return {
      type: "image_url",
      image_url: {
        url: r.url,
        ...(e = r.metadata) != null && e.detail ? { detail: r.metadata.detail } : {}
      }
    };
    if (r.source_type === "base64")
      return {
        type: "image_url",
        image_url: {
          url: `data:${r.mime_type ?? ""};base64,${r.data}`,
          ...(t = r.metadata) != null && t.detail ? { detail: r.metadata.detail } : {}
        }
      };
    throw new Error(`Image content blocks with source_type ${r.source_type} are not supported for ChatOpenAI`);
  },
  fromStandardAudioBlock(r) {
    if (r.source_type === "url") {
      const e = Js({ dataUrl: r.url });
      if (!e) throw new Error(`URL audio blocks with source_type ${r.source_type} must be formatted as a data URL for ChatOpenAI`);
      const t = e.mime_type || r.mime_type || "";
      let n;
      try {
        n = Pc(t);
      } catch {
        throw new Error(`Audio blocks with source_type ${r.source_type} must have mime type of audio/wav or audio/mp3`);
      }
      if (n.type !== "audio" || n.subtype !== "wav" && n.subtype !== "mp3") throw new Error(`Audio blocks with source_type ${r.source_type} must have mime type of audio/wav or audio/mp3`);
      return {
        type: "input_audio",
        input_audio: {
          format: n.subtype,
          data: e.data
        }
      };
    }
    if (r.source_type === "base64") {
      let e;
      try {
        e = Pc(r.mime_type ?? "");
      } catch {
        throw new Error(`Audio blocks with source_type ${r.source_type} must have mime type of audio/wav or audio/mp3`);
      }
      if (e.type !== "audio" || e.subtype !== "wav" && e.subtype !== "mp3") throw new Error(`Audio blocks with source_type ${r.source_type} must have mime type of audio/wav or audio/mp3`);
      return {
        type: "input_audio",
        input_audio: {
          format: e.subtype,
          data: r.data
        }
      };
    }
    throw new Error(`Audio content blocks with source_type ${r.source_type} are not supported for ChatOpenAI`);
  },
  fromStandardFileBlock(r) {
    var e, t, n, s, a, i, o, c, u, l;
    if (r.source_type === "url") {
      if (!Js({ dataUrl: r.url })) throw new Error(`URL file blocks with source_type ${r.source_type} must be formatted as a data URL for ChatOpenAI`);
      return {
        type: "file",
        file: {
          file_data: r.url,
          ...(e = r.metadata) != null && e.filename || (t = r.metadata) != null && t.name ? { filename: ((n = r.metadata) == null ? void 0 : n.filename) || ((s = r.metadata) == null ? void 0 : s.name) } : {}
        }
      };
    }
    if (r.source_type === "base64") return {
      type: "file",
      file: {
        file_data: `data:${r.mime_type ?? ""};base64,${r.data}`,
        ...(a = r.metadata) != null && a.filename || (i = r.metadata) != null && i.name || (o = r.metadata) != null && o.title ? { filename: ((c = r.metadata) == null ? void 0 : c.filename) || ((u = r.metadata) == null ? void 0 : u.name) || ((l = r.metadata) == null ? void 0 : l.title) } : {}
      }
    };
    if (r.source_type === "id") return {
      type: "file",
      file: { file_id: r.id }
    };
    throw new Error(`File content blocks with source_type ${r.source_type} are not supported for ChatOpenAI`);
  }
}, a1 = ({ message: r, rawResponse: e, includeRawResponse: t }) => {
  var s, a;
  const n = r.tool_calls;
  switch (r.role) {
    case "assistant": {
      const i = [], o = [];
      for (const d of n ?? []) try {
        i.push(Lo(d, { returnId: !0 }));
      } catch (h) {
        o.push(Hi(d, h.message));
      }
      const c = {
        function_call: r.function_call,
        tool_calls: n
      };
      t !== void 0 && (c.__raw_response = e);
      const u = {
        model_provider: "openai",
        model_name: e.model,
        ...e.system_fingerprint ? {
          usage: { ...e.usage },
          system_fingerprint: e.system_fingerprint
        } : {}
      };
      r.audio && (c.audio = r.audio);
      const l = iC(r.content || "", (a = (s = e.choices) == null ? void 0 : s[0]) == null ? void 0 : a.message);
      return new Fe({
        content: l,
        tool_calls: i,
        invalid_tool_calls: o,
        additional_kwargs: c,
        response_metadata: u,
        id: e.id
      });
    }
    default:
      return new In(r.content || "", r.role ?? "unknown");
  }
}, i1 = ({ delta: r, rawResponse: e, includeRawResponse: t, defaultRole: n }) => {
  var c, u;
  const s = r.role ?? n, a = r.content ?? "";
  let i;
  r.function_call ? i = { function_call: r.function_call } : r.tool_calls ? i = { tool_calls: r.tool_calls } : i = {}, t && (i.__raw_response = e), r.audio && (i.audio = {
    ...r.audio,
    index: e.choices[0].index
  });
  const o = {
    model_provider: "openai",
    usage: { ...e.usage }
  };
  if (s === "user") return new la({
    content: a,
    response_metadata: o
  });
  if (s === "assistant") {
    const l = [];
    if (Array.isArray(r.tool_calls)) for (const d of r.tool_calls) l.push({
      name: (c = d.function) == null ? void 0 : c.name,
      args: (u = d.function) == null ? void 0 : u.arguments,
      id: d.id,
      index: d.index,
      type: "tool_call_chunk"
    });
    return new Ar({
      content: a,
      tool_call_chunks: l,
      additional_kwargs: i,
      id: e.id,
      response_metadata: o
    });
  } else return s === "system" ? new sn({
    content: a,
    response_metadata: o
  }) : s === "developer" ? new sn({
    content: a,
    response_metadata: o,
    additional_kwargs: { __openai_role__: "developer" }
  }) : s === "function" ? new ua({
    content: a,
    additional_kwargs: i,
    name: r.name,
    response_metadata: o
  }) : s === "tool" ? new oa({
    content: a,
    additional_kwargs: i,
    tool_call_id: r.tool_call_id,
    response_metadata: o
  }) : new ca({
    content: a,
    role: s,
    response_metadata: o
  });
}, o1 = (r) => {
  if (r.type === "image") {
    if (r.url) return {
      type: "image_url",
      image_url: { url: r.url }
    };
    if (r.data) return {
      type: "image_url",
      image_url: { url: `data:${r.mimeType};base64,${r.data}` }
    };
  }
  if (r.type === "audio" && r.data) {
    const e = Am(() => {
      const [, t] = r.mimeType.split("/");
      return t === "wav" || t === "mp3" ? t : "wav";
    });
    return {
      type: "input_audio",
      input_audio: {
        data: r.data.toString(),
        format: e
      }
    };
  }
  if (r.type === "file") {
    if (r.data) return {
      type: "file",
      file: { file_data: r.data.toString() }
    };
    if (r.fileId) return {
      type: "file",
      file: { file_id: r.fileId }
    };
  }
}, c1 = ({ message: r, model: e }) => {
  let t = _a(r);
  if (t === "system" && ga(e) && (t = "developer"), t === "developer") return {
    role: "developer",
    content: r.contentBlocks.filter((s) => s.type === "text")
  };
  if (t === "system") return {
    role: "system",
    content: r.contentBlocks.filter((s) => s.type === "text")
  };
  if (t === "assistant") return {
    role: "assistant",
    content: r.contentBlocks.filter((s) => s.type === "text")
  };
  if (t === "tool" && Ir.isInstance(r)) return {
    role: "tool",
    tool_call_id: r.tool_call_id,
    content: r.contentBlocks.filter((s) => s.type === "text")
  };
  if (t === "function") return {
    role: "function",
    name: r.name ?? "",
    content: r.contentBlocks.filter((s) => s.type === "text").join("")
  };
  function* n(s) {
    for (const a of s) {
      a.type === "text" && (yield {
        type: "text",
        text: a.text
      });
      const i = o1(a);
      i && (yield i);
    }
  }
  return {
    role: "user",
    content: Array.from(n(r.contentBlocks))
  };
}, yf = ({ messages: r, model: e }) => r.flatMap((t) => {
  var i, o;
  if ("output_version" in t.response_metadata && ((i = t.response_metadata) == null ? void 0 : i.output_version) === "v1") return c1({ message: t });
  let n = _a(t);
  n === "system" && ga(e) && (n = "developer");
  const s = typeof t.content == "string" ? t.content : t.content.map((c) => kr(c) ? Ku(c, ty) : c), a = {
    role: n,
    content: s
  };
  if (t.name != null && (a.name = t.name), t.additional_kwargs.function_call != null && (a.function_call = t.additional_kwargs.function_call, a.content = ""), Fe.isInstance(t) && ((o = t.tool_calls) != null && o.length) ? (a.tool_calls = t.tool_calls.map(Q_), a.content = "") : (t.additional_kwargs.tool_calls != null && (a.tool_calls = t.additional_kwargs.tool_calls), Ir.isInstance(t) && t.tool_call_id != null && (a.tool_call_id = t.tool_call_id)), t.additional_kwargs.audio && typeof t.additional_kwargs.audio == "object" && "id" in t.additional_kwargs.audio) {
    const c = {
      role: "assistant",
      audio: { id: t.additional_kwargs.audio.id }
    };
    return [a, c];
  }
  return a;
});
var u1 = class extends ql {
  /** @internal */
  invocationParams(r, e) {
    var i;
    let t;
    (r == null ? void 0 : r.strict) !== void 0 ? t = r.strict : this.supportsStrictToolCalling !== void 0 && (t = this.supportsStrictToolCalling);
    let n = {};
    (r == null ? void 0 : r.stream_options) !== void 0 ? n = { stream_options: r.stream_options } : this.streamUsage && (this.streaming || e != null && e.streaming) && (n = { stream_options: { include_usage: !0 } });
    const s = {
      model: this.model,
      temperature: this.temperature,
      top_p: this.topP,
      frequency_penalty: this.frequencyPenalty,
      presence_penalty: this.presencePenalty,
      logprobs: this.logprobs,
      top_logprobs: this.topLogprobs,
      n: this.n,
      logit_bias: this.logitBias,
      stop: (r == null ? void 0 : r.stop) ?? this.stopSequences,
      user: this.user,
      stream: this.streaming,
      functions: r == null ? void 0 : r.functions,
      function_call: r == null ? void 0 : r.function_call,
      tools: (i = r == null ? void 0 : r.tools) != null && i.length ? r.tools.map((o) => this._convertChatOpenAIToolToCompletionsTool(o, { strict: t })) : void 0,
      tool_choice: A_(r == null ? void 0 : r.tool_choice),
      response_format: this._getResponseFormat(r == null ? void 0 : r.response_format),
      seed: r == null ? void 0 : r.seed,
      ...n,
      parallel_tool_calls: r == null ? void 0 : r.parallel_tool_calls,
      ...this.audio || r != null && r.audio ? { audio: this.audio || (r == null ? void 0 : r.audio) } : {},
      ...this.modalities || r != null && r.modalities ? { modalities: this.modalities || (r == null ? void 0 : r.modalities) } : {},
      ...this.modelKwargs,
      prompt_cache_key: (r == null ? void 0 : r.promptCacheKey) ?? this.promptCacheKey,
      verbosity: (r == null ? void 0 : r.verbosity) ?? this.verbosity
    };
    (r == null ? void 0 : r.prediction) !== void 0 && (s.prediction = r.prediction), this.service_tier !== void 0 && (s.service_tier = this.service_tier), (r == null ? void 0 : r.service_tier) !== void 0 && (s.service_tier = r.service_tier);
    const a = this._getReasoningParams(r);
    return a !== void 0 && a.effort !== void 0 && (s.reasoning_effort = a.effort), ga(s.model) ? s.max_completion_tokens = this.maxTokens === -1 ? void 0 : this.maxTokens : s.max_tokens = this.maxTokens === -1 ? void 0 : this.maxTokens, s;
  }
  async _generate(r, e, t) {
    var i, o;
    const n = {}, s = this.invocationParams(e), a = yf({
      messages: r,
      model: this.model
    });
    if (s.stream) {
      const c = this._streamResponseChunks(r, e, t), u = {};
      for await (const y of c) {
        y.message.response_metadata = {
          ...y.generationInfo,
          ...y.message.response_metadata
        };
        const m = ((i = y.generationInfo) == null ? void 0 : i.completion) ?? 0;
        u[m] === void 0 ? u[m] = y : u[m] = u[m].concat(y);
      }
      const l = Object.entries(u).sort(([y], [m]) => parseInt(y, 10) - parseInt(m, 10)).map(([y, m]) => m), { functions: d, function_call: h } = this.invocationParams(e), f = await this._getEstimatedTokenCountFromPrompt(r, d, h), p = await this._getNumTokensFromGenerations(l);
      return n.input_tokens = f, n.output_tokens = p, n.total_tokens = f + p, {
        generations: l,
        llmOutput: { estimatedTokenUsage: {
          promptTokens: n.input_tokens,
          completionTokens: n.output_tokens,
          totalTokens: n.total_tokens
        } }
      };
    } else {
      const c = await this.completionWithRetry({
        ...s,
        stream: !1,
        messages: a
      }, {
        signal: e == null ? void 0 : e.signal,
        ...e == null ? void 0 : e.options
      }), { completion_tokens: u, prompt_tokens: l, total_tokens: d, prompt_tokens_details: h, completion_tokens_details: f } = (c == null ? void 0 : c.usage) ?? {};
      u && (n.output_tokens = (n.output_tokens ?? 0) + u), l && (n.input_tokens = (n.input_tokens ?? 0) + l), d && (n.total_tokens = (n.total_tokens ?? 0) + d), ((h == null ? void 0 : h.audio_tokens) !== null || (h == null ? void 0 : h.cached_tokens) !== null) && (n.input_token_details = {
        ...(h == null ? void 0 : h.audio_tokens) !== null && { audio: h == null ? void 0 : h.audio_tokens },
        ...(h == null ? void 0 : h.cached_tokens) !== null && { cache_read: h == null ? void 0 : h.cached_tokens }
      }), ((f == null ? void 0 : f.audio_tokens) !== null || (f == null ? void 0 : f.reasoning_tokens) !== null) && (n.output_token_details = {
        ...(f == null ? void 0 : f.audio_tokens) !== null && { audio: f == null ? void 0 : f.audio_tokens },
        ...(f == null ? void 0 : f.reasoning_tokens) !== null && { reasoning: f == null ? void 0 : f.reasoning_tokens }
      });
      const p = [];
      for (const y of (c == null ? void 0 : c.choices) ?? []) {
        const v = {
          text: ((o = y.message) == null ? void 0 : o.content) ?? "",
          message: this._convertCompletionsMessageToBaseMessage(y.message ?? { role: "assistant" }, c)
        };
        v.generationInfo = {
          ...y.finish_reason ? { finish_reason: y.finish_reason } : {},
          ...y.logprobs ? { logprobs: y.logprobs } : {}
        }, co(v.message) && (v.message.usage_metadata = n), v.message = new Fe(Object.fromEntries(Object.entries(v.message).filter(([g]) => !g.startsWith("lc_")))), p.push(v);
      }
      return {
        generations: p,
        llmOutput: { tokenUsage: {
          promptTokens: n.input_tokens,
          completionTokens: n.output_tokens,
          totalTokens: n.total_tokens
        } }
      };
    }
  }
  async *_streamResponseChunks(r, e, t) {
    var c, u, l, d, h, f, p, y, m, v;
    const n = yf({
      messages: r,
      model: this.model
    }), s = {
      ...this.invocationParams(e, { streaming: !0 }),
      messages: n,
      stream: !0
    };
    let a;
    const i = await this.completionWithRetry(s, e);
    let o;
    for await (const g of i) {
      const w = (c = g == null ? void 0 : g.choices) == null ? void 0 : c[0];
      if (g.usage && (o = g.usage), !w) continue;
      const { delta: T } = w;
      if (!T) continue;
      const x = this._convertCompletionsDeltaToBaseMessageChunk(T, g, a);
      a = T.role ?? a;
      const O = {
        prompt: e.promptIndex ?? 0,
        completion: w.index ?? 0
      };
      if (typeof x.content != "string") {
        console.log("[WARNING]: Received non-string content from OpenAI. This is currently not supported.");
        continue;
      }
      const R = { ...O };
      w.finish_reason != null && (R.finish_reason = w.finish_reason, R.system_fingerprint = g.system_fingerprint, R.model_name = g.model, R.service_tier = g.service_tier), this.logprobs && (R.logprobs = w.logprobs);
      const E = new es({
        message: x,
        text: x.content,
        generationInfo: R
      });
      yield E, await (t == null ? void 0 : t.handleLLMNewToken(E.text ?? "", O, void 0, void 0, void 0, { chunk: E }));
    }
    if (o) {
      const g = {
        ...((u = o.prompt_tokens_details) == null ? void 0 : u.audio_tokens) !== null && { audio: (l = o.prompt_tokens_details) == null ? void 0 : l.audio_tokens },
        ...((d = o.prompt_tokens_details) == null ? void 0 : d.cached_tokens) !== null && { cache_read: (h = o.prompt_tokens_details) == null ? void 0 : h.cached_tokens }
      }, w = {
        ...((f = o.completion_tokens_details) == null ? void 0 : f.audio_tokens) !== null && { audio: (p = o.completion_tokens_details) == null ? void 0 : p.audio_tokens },
        ...((y = o.completion_tokens_details) == null ? void 0 : y.reasoning_tokens) !== null && { reasoning: (m = o.completion_tokens_details) == null ? void 0 : m.reasoning_tokens }
      };
      yield new es({
        message: new Ar({
          content: "",
          response_metadata: { usage: { ...o } },
          usage_metadata: {
            input_tokens: o.prompt_tokens,
            output_tokens: o.completion_tokens,
            total_tokens: o.total_tokens,
            ...Object.keys(g).length > 0 && { input_token_details: g },
            ...Object.keys(w).length > 0 && { output_token_details: w }
          }
        }),
        text: ""
      });
    }
    if ((v = e.signal) != null && v.aborted) throw new Error("AbortError");
  }
  async completionWithRetry(r, e) {
    const t = this._getClientOptions(e), n = r.response_format && r.response_format.type === "json_schema";
    return this.caller.call(async () => {
      try {
        return n && !r.stream ? await this.client.chat.completions.parse(r, t) : await this.client.chat.completions.create(r, t);
      } catch (s) {
        throw im(s);
      }
    });
  }
  /**
  * @deprecated
  * This function was hoisted into a publicly accessible function from a
  * different export, but to maintain backwards compatibility with chat models
  * that depend on ChatOpenAICompletions, we'll keep it here as an overridable
  * method. This will be removed in a future release
  */
  _convertCompletionsDeltaToBaseMessageChunk(r, e, t) {
    return i1({
      delta: r,
      rawResponse: e,
      includeRawResponse: this.__includeRawResponse,
      defaultRole: t
    });
  }
  /**
  * @deprecated
  * This function was hoisted into a publicly accessible function from a
  * different export, but to maintain backwards compatibility with chat models
  * that depend on ChatOpenAICompletions, we'll keep it here as an overridable
  * method. This will be removed in a future release
  */
  _convertCompletionsMessageToBaseMessage(r, e) {
    return a1({
      message: r,
      rawResponse: e,
      includeRawResponse: this.__includeRawResponse
    });
  }
};
const Gn = "__openai_function_call_ids__", ry = (r) => {
  var n, s, a, i;
  const e = { ...((n = r == null ? void 0 : r.input_tokens_details) == null ? void 0 : n.cached_tokens) != null && { cache_read: (s = r == null ? void 0 : r.input_tokens_details) == null ? void 0 : s.cached_tokens } }, t = { ...((a = r == null ? void 0 : r.output_tokens_details) == null ? void 0 : a.reasoning_tokens) != null && { reasoning: (i = r == null ? void 0 : r.output_tokens_details) == null ? void 0 : i.reasoning_tokens } };
  return {
    input_tokens: (r == null ? void 0 : r.input_tokens) ?? 0,
    output_tokens: (r == null ? void 0 : r.output_tokens) ?? 0,
    total_tokens: (r == null ? void 0 : r.total_tokens) ?? 0,
    input_token_details: e,
    output_token_details: t
  };
}, ny = (r) => {
  if (r.error) {
    const o = new Error(r.error.message);
    throw o.name = r.error.code, o;
  }
  let e;
  const t = [], n = [], s = [], a = {
    model_provider: "openai",
    model: r.model,
    created_at: r.created_at,
    id: r.id,
    incomplete_details: r.incomplete_details,
    metadata: r.metadata,
    object: r.object,
    status: r.status,
    user: r.user,
    service_tier: r.service_tier,
    model_name: r.model
  }, i = {};
  for (const o of r.output) if (o.type === "message")
    e = o.id, t.push(...o.content.flatMap((c) => c.type === "output_text" ? ("parsed" in c && c.parsed != null && (i.parsed = c.parsed), {
      type: "text",
      text: c.text,
      annotations: c.annotations
    }) : c.type === "refusal" ? (i.refusal = c.refusal, []) : c));
  else if (o.type === "function_call") {
    const c = {
      function: {
        name: o.name,
        arguments: o.arguments
      },
      id: o.call_id
    };
    try {
      n.push(Lo(c, { returnId: !0 }));
    } catch (u) {
      let l;
      typeof u == "object" && u != null && "message" in u && typeof u.message == "string" && (l = u.message), s.push(Hi(c, l));
    }
    i[Gn] ?? (i[Gn] = {}), o.id && (i[Gn][o.call_id] = o.id);
  } else if (o.type === "reasoning") i.reasoning = o;
  else if (o.type === "custom_tool_call") {
    const c = JO(o);
    c ? n.push(c) : s.push(Hi(o, "Malformed custom tool call"));
  } else
    i.tool_outputs ?? (i.tool_outputs = []), i.tool_outputs.push(o);
  return new Fe({
    id: e,
    content: t,
    tool_calls: n,
    invalid_tool_calls: s,
    usage_metadata: ry(r.usage),
    additional_kwargs: i,
    response_metadata: a
  });
}, l1 = (r) => {
  const e = (r.summary.length > 1 ? r.summary.reduce((t, n) => {
    const s = t[t.length - 1];
    return s.index === n.index ? s.text += n.text : t.push(n), t;
  }, [{ ...r.summary[0] }]) : r.summary).map((t) => Object.fromEntries(Object.entries(t).filter(([n]) => n !== "index")));
  return {
    ...r,
    summary: e
  };
}, d1 = (r) => {
  var c, u;
  const e = [];
  let t = {}, n;
  const s = [], a = { model_provider: "openai" }, i = {};
  let o;
  if (r.type === "response.output_text.delta") e.push({
    type: "text",
    text: r.delta,
    index: r.content_index
  });
  else if (r.type === "response.output_text.annotation.added") e.push({
    type: "text",
    text: "",
    annotations: [r.annotation],
    index: r.content_index
  });
  else if (r.type === "response.output_item.added" && r.item.type === "message") o = r.item.id;
  else if (r.type === "response.output_item.added" && r.item.type === "function_call")
    s.push({
      type: "tool_call_chunk",
      name: r.item.name,
      args: r.item.arguments,
      id: r.item.call_id,
      index: r.output_index
    }), i[Gn] = { [r.item.call_id]: r.item.id };
  else if (r.type === "response.output_item.done" && [
    "web_search_call",
    "file_search_call",
    "computer_call",
    "code_interpreter_call",
    "mcp_call",
    "mcp_list_tools",
    "mcp_approval_request",
    "image_generation_call",
    "custom_tool_call"
  ].includes(r.item.type)) i.tool_outputs = [r.item];
  else if (r.type === "response.created")
    a.id = r.response.id, a.model_name = r.response.model, a.model = r.response.model;
  else if (r.type === "response.completed") {
    const l = ny(r.response);
    n = ry(r.response.usage), ((u = (c = r.response.text) == null ? void 0 : c.format) == null ? void 0 : u.type) === "json_schema" && (i.parsed ?? (i.parsed = JSON.parse(l.text)));
    for (const [d, h] of Object.entries(r.response)) d !== "id" && (a[d] = h);
  } else if (r.type === "response.function_call_arguments.delta" || r.type === "response.custom_tool_call_input.delta") s.push({
    type: "tool_call_chunk",
    args: r.delta,
    index: r.output_index
  });
  else if (r.type === "response.web_search_call.completed" || r.type === "response.file_search_call.completed") t = { tool_outputs: {
    id: r.item_id,
    type: r.type.replace("response.", "").replace(".completed", ""),
    status: "completed"
  } };
  else if (r.type === "response.refusal.done") i.refusal = r.refusal;
  else if (r.type === "response.output_item.added" && "item" in r && r.item.type === "reasoning") {
    const l = r.item.summary ? r.item.summary.map((d, h) => ({
      ...d,
      index: h
    })) : void 0;
    i.reasoning = {
      id: r.item.id,
      type: r.item.type,
      ...l ? { summary: l } : {}
    };
  } else if (r.type === "response.reasoning_summary_part.added") i.reasoning = {
    type: "reasoning",
    summary: [{
      ...r.part,
      index: r.summary_index
    }]
  };
  else if (r.type === "response.reasoning_summary_text.delta") i.reasoning = {
    type: "reasoning",
    summary: [{
      text: r.delta,
      type: "summary_text",
      index: r.summary_index
    }]
  };
  else return r.type === "response.image_generation_call.partial_image", null;
  return new es({
    text: e.map((l) => l.text).join(""),
    message: new Ar({
      id: o,
      content: e,
      tool_call_chunks: s,
      usage_metadata: n,
      additional_kwargs: i,
      response_metadata: a
    }),
    generationInfo: t
  });
}, h1 = (r) => {
  var n;
  const e = Fe.isInstance(r) && ((n = r.response_metadata) == null ? void 0 : n.model_provider) === "openai";
  function* t() {
    const s = En(() => {
      try {
        const g = _a(r);
        return g === "system" || g === "developer" || g === "assistant" || g === "user" ? g : "assistant";
      } catch {
        return "assistant";
      }
    });
    let a;
    const i = /* @__PURE__ */ new Set(), o = /* @__PURE__ */ new Set(), c = /* @__PURE__ */ new Map(), u = /* @__PURE__ */ new Map();
    function* l() {
      if (!a) return;
      const g = a.content;
      (typeof g == "string" && g.length > 0 || Array.isArray(g) && g.length > 0) && (yield a), a = void 0;
    }
    const d = (g) => {
      a || (a = {
        type: "message",
        role: s,
        content: []
      }), typeof a.content == "string" ? a.content = a.content.length > 0 ? [{
        type: "input_text",
        text: a.content
      }, ...g] : [...g] : a.content.push(...g);
    }, h = (g) => {
      if (typeof g == "string") return g;
      try {
        return JSON.stringify(g ?? {});
      } catch {
        return "{}";
      }
    }, f = (g) => {
      const w = En(() => {
        var x;
        const T = (x = g.metadata) == null ? void 0 : x.detail;
        return T === "low" || T === "high" || T === "auto" ? T : "auto";
      });
      if (g.fileId) return {
        type: "input_image",
        detail: w,
        file_id: g.fileId
      };
      if (g.url) return {
        type: "input_image",
        detail: w,
        image_url: g.url
      };
      if (g.data) {
        const T = typeof g.data == "string" ? g.data : Buffer.from(g.data).toString("base64"), x = g.mimeType ?? "image/png";
        return {
          type: "input_image",
          detail: w,
          image_url: `data:${x};base64,${T}`
        };
      }
    }, p = (g) => {
      var T, x, O;
      const w = ((T = g.metadata) == null ? void 0 : T.filename) ?? ((x = g.metadata) == null ? void 0 : x.name) ?? ((O = g.metadata) == null ? void 0 : O.title);
      if (g.fileId && typeof w == "string") return {
        type: "input_file",
        file_id: g.fileId,
        ...w ? { filename: w } : {}
      };
      if (g.url && typeof w == "string") return {
        type: "input_file",
        file_url: g.url,
        ...w ? { filename: w } : {}
      };
      if (g.data && typeof w == "string") {
        const R = typeof g.data == "string" ? g.data : Buffer.from(g.data).toString("base64");
        return {
          type: "input_file",
          file_data: `data:${g.mimeType ?? "application/octet-stream"};base64,${R}`,
          ...w ? { filename: w } : {}
        };
      }
    }, y = (g) => {
      const w = En(() => {
        if (Array.isArray(g.summary)) {
          const O = g.summary, R = (O == null ? void 0 : O.map((E) => E == null ? void 0 : E.text).filter((E) => typeof E == "string")) ?? [];
          if (R.length > 0) return R;
        }
        return g.reasoning ? [g.reasoning] : [];
      }), T = w.length > 0 ? w.map((O) => ({
        type: "summary_text",
        text: O
      })) : [{
        type: "summary_text",
        text: ""
      }], x = {
        type: "reasoning",
        id: g.id ?? "",
        summary: T
      };
      return g.reasoning && (x.content = [{
        type: "reasoning_text",
        text: g.reasoning
      }]), x;
    }, m = (g) => ({
      type: "function_call",
      name: g.name ?? "",
      call_id: g.id ?? "",
      arguments: h(g.args)
    }), v = (g) => {
      const w = h(g.output), T = g.status === "success" ? "completed" : g.status === "error" ? "incomplete" : void 0;
      return {
        type: "function_call_output",
        call_id: g.toolCallId ?? "",
        output: w,
        ...T ? { status: T } : {}
      };
    };
    for (const g of r.contentBlocks) if (g.type === "text") d([{
      type: "input_text",
      text: g.text
    }]);
    else if (g.type !== "invalid_tool_call") {
      if (g.type === "reasoning")
        yield* l(), yield y(g);
      else if (g.type === "tool_call") {
        yield* l();
        const w = g.id ?? "";
        w && (i.add(w), c.delete(w)), yield m(g);
      } else if (g.type === "tool_call_chunk") {
        if (g.id) {
          const w = c.get(g.id) ?? {
            name: g.name,
            args: []
          };
          g.name && (w.name = g.name), g.args && w.args.push(g.args), c.set(g.id, w);
        }
      } else if (g.type === "server_tool_call") {
        yield* l();
        const w = g.id ?? "";
        w && (o.add(w), u.delete(w)), yield m(g);
      } else if (g.type === "server_tool_call_chunk") {
        if (g.id) {
          const w = u.get(g.id) ?? {
            name: g.name,
            args: []
          };
          g.name && (w.name = g.name), g.args && w.args.push(g.args), u.set(g.id, w);
        }
      } else if (g.type === "server_tool_call_result")
        yield* l(), yield v(g);
      else if (g.type !== "audio") if (g.type === "file") {
        const w = p(g);
        w && d([w]);
      } else if (g.type === "image") {
        const w = f(g);
        w && d([w]);
      } else if (g.type === "video") {
        const w = p(g);
        w && d([w]);
      } else g.type === "text-plain" ? g.text && d([{
        type: "input_text",
        text: g.text
      }]) : g.type === "non_standard" && e && (yield* l(), yield g.value);
    }
    yield* l();
    for (const [g, w] of c) {
      if (!g || i.has(g)) continue;
      const T = w.args.join("");
      !w.name && !T || (yield {
        type: "function_call",
        call_id: g,
        name: w.name ?? "",
        arguments: T
      });
    }
    for (const [g, w] of u) {
      if (!g || o.has(g)) continue;
      const T = w.args.join("");
      !w.name && !T || (yield {
        type: "function_call",
        call_id: g,
        name: w.name ?? "",
        arguments: T
      });
    }
  }
  return Array.from(t());
}, wf = ({ messages: r, zdrEnabled: e, model: t }) => r.flatMap((n) => {
  var o, c, u, l;
  const s = n.response_metadata;
  if ((s == null ? void 0 : s.output_version) === "v1") return h1(n);
  const a = n.additional_kwargs;
  let i = _a(n);
  if (i === "system" && ga(t) && (i = "developer"), i === "function") throw new Error("Function messages are not supported in Responses API");
  if (i === "tool") {
    const d = n;
    return (a == null ? void 0 : a.type) === "computer_call_output" ? {
      type: "computer_call_output",
      output: (() => {
        if (typeof d.content == "string") return {
          type: "computer_screenshot",
          image_url: d.content
        };
        if (Array.isArray(d.content)) {
          const f = d.content.find((y) => y.type === "computer_screenshot");
          if (f) return f;
          const p = d.content.find((y) => y.type === "image_url");
          if (p) return {
            type: "computer_screenshot",
            image_url: typeof p.image_url == "string" ? p.image_url : p.image_url.url
          };
        }
        throw new Error("Invalid computer call output");
      })(),
      call_id: d.tool_call_id
    } : (o = d.additional_kwargs) != null && o.customTool ? {
      type: "custom_tool_call_output",
      call_id: d.tool_call_id,
      output: d.content
    } : {
      type: "function_call_output",
      call_id: d.tool_call_id,
      id: (c = d.id) != null && c.startsWith("fc_") ? d.id : void 0,
      output: typeof d.content != "string" ? JSON.stringify(d.content) : d.content
    };
  }
  if (i === "assistant") {
    if (!e && (s == null ? void 0 : s.output) != null && Array.isArray(s == null ? void 0 : s.output) && (s == null ? void 0 : s.output.length) > 0 && (s != null && s.output.every((m) => "type" in m))) return s == null ? void 0 : s.output;
    const d = [];
    if (a != null && a.reasoning && !e) {
      const m = l1(a.reasoning);
      d.push(m);
    }
    let { content: h } = n;
    a != null && a.refusal && (typeof h == "string" && (h = [{
      type: "output_text",
      text: h,
      annotations: []
    }]), h = [...h, {
      type: "refusal",
      refusal: a.refusal
    }]), (typeof h == "string" || h.length > 0) && d.push({
      type: "message",
      role: "assistant",
      ...n.id && !e && n.id.startsWith("msg_") ? { id: n.id } : {},
      content: En(() => typeof h == "string" ? h : h.flatMap((m) => m.type === "text" ? {
        type: "output_text",
        text: m.text,
        annotations: m.annotations ?? []
      } : m.type === "output_text" || m.type === "refusal" ? m : []))
    });
    const f = a == null ? void 0 : a[Gn];
    Fe.isInstance(n) && ((u = n.tool_calls) != null && u.length) ? d.push(...n.tool_calls.map((m) => HO(m) ? {
      type: "custom_tool_call",
      id: m.call_id,
      call_id: m.id ?? "",
      input: m.args.input,
      name: m.name
    } : {
      type: "function_call",
      name: m.name,
      arguments: JSON.stringify(m.args),
      call_id: m.id,
      ...e ? {} : { id: f == null ? void 0 : f[m.id] }
    })) : a != null && a.tool_calls && d.push(...a.tool_calls.map((m) => ({
      type: "function_call",
      name: m.function.name,
      call_id: m.id,
      arguments: m.function.arguments,
      ...e ? {} : { id: f == null ? void 0 : f[m.id] }
    })));
    const p = (l = s == null ? void 0 : s.output) != null && l.length ? s == null ? void 0 : s.output : a.tool_outputs, y = [
      "computer_call",
      "mcp_call",
      "code_interpreter_call",
      "image_generation_call"
    ];
    if (p != null) {
      const m = p, v = m == null ? void 0 : m.filter((g) => y.includes(g.type));
      v.length > 0 && d.push(...v);
    }
    return d;
  }
  if (i === "user" || i === "system" || i === "developer") {
    if (typeof n.content == "string") return {
      type: "message",
      role: i,
      content: n.content
    };
    const d = [], h = n.content.flatMap((f) => {
      if (f.type === "mcp_approval_response" && d.push({
        type: "mcp_approval_response",
        approval_request_id: f.approval_request_id,
        approve: f.approve
      }), kr(f)) return Ku(f, ty);
      if (f.type === "text") return {
        type: "input_text",
        text: f.text
      };
      if (f.type === "image_url") {
        const p = En(() => {
          if (typeof f.image_url == "string") return f.image_url;
          if (typeof f.image_url == "object" && f.image_url !== null && "url" in f.image_url) return f.image_url.url;
        }), y = En(() => {
          if (typeof f.image_url == "string") return "auto";
          if (typeof f.image_url == "object" && f.image_url !== null && "detail" in f.image_url) return f.image_url.detail;
        });
        return {
          type: "input_image",
          image_url: p,
          detail: y
        };
      }
      return f.type === "input_text" || f.type === "input_image" || f.type === "input_file" ? f : [];
    });
    return h.length > 0 && d.push({
      type: "message",
      role: i,
      content: h
    }), d;
  }
  return console.warn(`Unsupported role found when converting to OpenAI Responses API: ${i}`), [];
});
var f1 = class extends ql {
  invocationParams(r) {
    var s;
    let e;
    (r == null ? void 0 : r.strict) !== void 0 ? e = r.strict : this.supportsStrictToolCalling !== void 0 && (e = this.supportsStrictToolCalling);
    const t = {
      model: this.model,
      temperature: this.temperature,
      top_p: this.topP,
      user: this.user,
      stream: this.streaming,
      previous_response_id: r == null ? void 0 : r.previous_response_id,
      truncation: r == null ? void 0 : r.truncation,
      include: r == null ? void 0 : r.include,
      tools: (s = r == null ? void 0 : r.tools) != null && s.length ? this._reduceChatOpenAITools(r.tools, {
        stream: this.streaming,
        strict: e
      }) : void 0,
      tool_choice: qO(r == null ? void 0 : r.tool_choice) ? r == null ? void 0 : r.tool_choice : (() => {
        const a = A_(r == null ? void 0 : r.tool_choice);
        if (typeof a == "object" && "type" in a) {
          if (a.type === "function") return {
            type: "function",
            name: a.function.name
          };
          if (a.type === "allowed_tools") return {
            type: "allowed_tools",
            mode: a.allowed_tools.mode,
            tools: a.allowed_tools.tools
          };
          if (a.type === "custom") return {
            type: "custom",
            name: a.custom.name
          };
        }
      })(),
      text: (() => {
        if (r != null && r.text) return r.text;
        const a = this._getResponseFormat(r == null ? void 0 : r.response_format);
        return (a == null ? void 0 : a.type) === "json_schema" ? a.json_schema.schema != null ? {
          format: {
            type: "json_schema",
            schema: a.json_schema.schema,
            description: a.json_schema.description,
            name: a.json_schema.name,
            strict: a.json_schema.strict
          },
          verbosity: r == null ? void 0 : r.verbosity
        } : void 0 : {
          format: a,
          verbosity: r == null ? void 0 : r.verbosity
        };
      })(),
      parallel_tool_calls: r == null ? void 0 : r.parallel_tool_calls,
      max_output_tokens: this.maxTokens === -1 ? void 0 : this.maxTokens,
      prompt_cache_key: (r == null ? void 0 : r.promptCacheKey) ?? this.promptCacheKey,
      ...this.zdrEnabled ? { store: !1 } : {},
      ...this.modelKwargs
    }, n = this._getReasoningParams(r);
    return n !== void 0 && (t.reasoning = n), t;
  }
  async _generate(r, e) {
    var n;
    const t = this.invocationParams(e);
    if (t.stream) {
      const s = this._streamResponseChunks(r, e);
      let a;
      for await (const i of s)
        i.message.response_metadata = {
          ...i.generationInfo,
          ...i.message.response_metadata
        }, a = (a == null ? void 0 : a.concat(i)) ?? i;
      return {
        generations: a ? [a] : [],
        llmOutput: { estimatedTokenUsage: (n = a == null ? void 0 : a.message) == null ? void 0 : n.usage_metadata }
      };
    } else {
      const s = await this.completionWithRetry({
        input: wf({
          messages: r,
          zdrEnabled: this.zdrEnabled ?? !1,
          model: this.model
        }),
        ...t,
        stream: !1
      }, {
        signal: e == null ? void 0 : e.signal,
        ...e == null ? void 0 : e.options
      });
      return {
        generations: [{
          text: s.output_text,
          message: ny(s)
        }],
        llmOutput: {
          id: s.id,
          estimatedTokenUsage: s.usage ? {
            promptTokens: s.usage.input_tokens,
            completionTokens: s.usage.output_tokens,
            totalTokens: s.usage.total_tokens
          } : void 0
        }
      };
    }
  }
  async *_streamResponseChunks(r, e, t) {
    const n = await this.completionWithRetry({
      ...this.invocationParams(e),
      input: wf({
        messages: r,
        zdrEnabled: this.zdrEnabled ?? !1,
        model: this.model
      }),
      stream: !0
    }, e);
    for await (const s of n) {
      const a = d1(s);
      a != null && (yield a, await (t == null ? void 0 : t.handleLLMNewToken(a.text || "", {
        prompt: e.promptIndex ?? 0,
        completion: 0
      }, void 0, void 0, void 0, { chunk: a })));
    }
  }
  async completionWithRetry(r, e) {
    return this.caller.call(async () => {
      var n, s;
      const t = this._getClientOptions(e);
      try {
        return ((s = (n = r.text) == null ? void 0 : n.format) == null ? void 0 : s.type) === "json_schema" && !r.stream ? await this.client.responses.parse(r, t) : await this.client.responses.create(r, t);
      } catch (a) {
        throw im(a);
      }
    });
  }
  /** @internal */
  _reduceChatOpenAITools(r, e) {
    const t = [];
    for (const n of r) if (Fl(n))
      n.type === "image_generation" && (e != null && e.stream) && (n.partial_images = 1), t.push(n);
    else if (Bi(n)) {
      const s = n.metadata.customTool;
      t.push({
        type: "custom",
        name: s.name,
        description: s.description,
        format: s.format
      });
    } else zl(n) ? t.push({
      type: "function",
      name: n.function.name,
      parameters: n.function.parameters,
      description: n.function.description,
      strict: (e == null ? void 0 : e.strict) ?? null
    }) : $_(n) && t.push(GO(n));
    return t;
  }
}, p1 = class sy extends ql {
  constructor(t) {
    super(t);
    /**
    * Whether to use the responses API for all requests. If `false` the responses API will be used
    * only when required in order to fulfill the request.
    */
    b(this, "useResponsesApi", !1);
    b(this, "responses");
    b(this, "completions");
    this.fields = t, this.useResponsesApi = (t == null ? void 0 : t.useResponsesApi) ?? !1, this.responses = (t == null ? void 0 : t.responses) ?? new f1(t), this.completions = (t == null ? void 0 : t.completions) ?? new u1(t);
  }
  get lc_serializable_keys() {
    return [...super.lc_serializable_keys, "useResponsesApi"];
  }
  get callKeys() {
    return [...super.callKeys, "useResponsesApi"];
  }
  _useResponsesApi(t) {
    var i, o, c, u, l;
    const n = (i = t == null ? void 0 : t.tools) == null ? void 0 : i.some(Fl), s = (t == null ? void 0 : t.previous_response_id) != null || (t == null ? void 0 : t.text) != null || (t == null ? void 0 : t.truncation) != null || (t == null ? void 0 : t.include) != null || ((o = t == null ? void 0 : t.reasoning) == null ? void 0 : o.summary) != null || ((c = this.reasoning) == null ? void 0 : c.summary) != null, a = ((u = t == null ? void 0 : t.tools) == null ? void 0 : u.some($_)) || ((l = t == null ? void 0 : t.tools) == null ? void 0 : l.some(Bi));
    return this.useResponsesApi || n || s || a;
  }
  getLsParams(t) {
    const n = this._combineCallOptions(t);
    return this._useResponsesApi(t) ? this.responses.getLsParams(n) : this.completions.getLsParams(n);
  }
  invocationParams(t) {
    const n = this._combineCallOptions(t);
    return this._useResponsesApi(t) ? this.responses.invocationParams(n) : this.completions.invocationParams(n);
  }
  /** @ignore */
  async _generate(t, n, s) {
    return this._useResponsesApi(n) ? this.responses._generate(t, n) : this.completions._generate(t, n, s);
  }
  async *_streamResponseChunks(t, n, s) {
    if (this._useResponsesApi(n)) {
      yield* this.responses._streamResponseChunks(t, this._combineCallOptions(n), s);
      return;
    }
    yield* this.completions._streamResponseChunks(t, this._combineCallOptions(n), s);
  }
  withConfig(t) {
    const n = new sy(this.fields);
    return n.defaultOptions = {
      ...this.defaultOptions,
      ...t
    }, n;
  }
}, m1 = {};
Ae(m1, {
  BaseLLM: () => ay,
  LLM: () => g1
});
var ay = class Rs extends Zl {
  constructor() {
    super(...arguments);
    b(this, "lc_namespace", [
      "langchain",
      "llms",
      this._llmType()
    ]);
  }
  /**
  * This method takes an input and options, and returns a string. It
  * converts the input to a prompt value and generates a result based on
  * the prompt.
  * @param input Input for the LLM.
  * @param options Options for the LLM call.
  * @returns A string result based on the prompt.
  */
  async invoke(t, n) {
    const s = Rs._convertInputToPromptValue(t);
    return (await this.generatePrompt([s], n, n == null ? void 0 : n.callbacks)).generations[0][0].text;
  }
  async *_streamResponseChunks(t, n, s) {
    throw new Error("Not implemented.");
  }
  _separateRunnableConfigFromCallOptionsCompat(t) {
    const [n, s] = super._separateRunnableConfigFromCallOptions(t);
    return s.signal = n.signal, [n, s];
  }
  async *_streamIterator(t, n) {
    if (this._streamResponseChunks === Rs.prototype._streamResponseChunks) yield this.invoke(t, n);
    else {
      const s = Rs._convertInputToPromptValue(t), [a, i] = this._separateRunnableConfigFromCallOptionsCompat(n), o = await Pt.configure(a.callbacks, this.callbacks, a.tags, this.tags, a.metadata, this.metadata, { verbose: this.verbose }), c = {
        options: i,
        invocation_params: this == null ? void 0 : this.invocationParams(i),
        batch_size: 1
      }, u = await (o == null ? void 0 : o.handleLLMStart(this.toJSON(), [s.toString()], a.runId, void 0, c, void 0, void 0, a.runName));
      let l = new Qn({ text: "" });
      try {
        for await (const d of this._streamResponseChunks(s.toString(), i, u == null ? void 0 : u[0]))
          l ? l = l.concat(d) : l = d, typeof d.text == "string" && (yield d.text);
      } catch (d) {
        throw await Promise.all((u ?? []).map((h) => h == null ? void 0 : h.handleLLMError(d))), d;
      }
      await Promise.all((u ?? []).map((d) => d == null ? void 0 : d.handleLLMEnd({ generations: [[l]] })));
    }
  }
  /**
  * This method takes prompt values, options, and callbacks, and generates
  * a result based on the prompts.
  * @param promptValues Prompt values for the LLM.
  * @param options Options for the LLM call.
  * @param callbacks Callbacks for the LLM call.
  * @returns An LLMResult based on the prompts.
  */
  async generatePrompt(t, n, s) {
    const a = t.map((i) => i.toString());
    return this.generate(a, n, s);
  }
  /**
  * Get the parameters used to invoke the model
  */
  invocationParams(t) {
    return {};
  }
  _flattenLLMResult(t) {
    const n = [];
    for (let s = 0; s < t.generations.length; s += 1) {
      const a = t.generations[s];
      if (s === 0) n.push({
        generations: [a],
        llmOutput: t.llmOutput
      });
      else {
        const i = t.llmOutput ? {
          ...t.llmOutput,
          tokenUsage: {}
        } : void 0;
        n.push({
          generations: [a],
          llmOutput: i
        });
      }
    }
    return n;
  }
  /** @ignore */
  async _generateUncached(t, n, s, a) {
    let i;
    if (a !== void 0 && a.length === t.length) i = a;
    else {
      const l = await Pt.configure(s.callbacks, this.callbacks, s.tags, this.tags, s.metadata, this.metadata, { verbose: this.verbose }), d = {
        options: n,
        invocation_params: this == null ? void 0 : this.invocationParams(n),
        batch_size: t.length
      };
      i = await (l == null ? void 0 : l.handleLLMStart(this.toJSON(), t, s.runId, void 0, d, void 0, void 0, s == null ? void 0 : s.runName));
    }
    const o = !!(i != null && i[0].handlers.find(cl));
    let c;
    if (o && t.length === 1 && this._streamResponseChunks !== Rs.prototype._streamResponseChunks) try {
      const l = await this._streamResponseChunks(t[0], n, i == null ? void 0 : i[0]);
      let d;
      for await (const h of l) d === void 0 ? d = h : d = an(d, h);
      if (d === void 0) throw new Error("Received empty response from chat model call.");
      c = {
        generations: [[d]],
        llmOutput: {}
      }, await (i == null ? void 0 : i[0].handleLLMEnd(c));
    } catch (l) {
      throw await (i == null ? void 0 : i[0].handleLLMError(l)), l;
    }
    else {
      try {
        c = await this._generate(t, n, i == null ? void 0 : i[0]);
      } catch (d) {
        throw await Promise.all((i ?? []).map((h) => h == null ? void 0 : h.handleLLMError(d))), d;
      }
      const l = this._flattenLLMResult(c);
      await Promise.all((i ?? []).map((d, h) => d == null ? void 0 : d.handleLLMEnd(l[h])));
    }
    const u = (i == null ? void 0 : i.map((l) => l.runId)) || void 0;
    return Object.defineProperty(c, Qs, {
      value: u ? { runIds: u } : void 0,
      configurable: !0
    }), c;
  }
  async _generateCached({ prompts: t, cache: n, llmStringKey: s, parsedOptions: a, handledOptions: i, runId: o }) {
    const c = await Pt.configure(i.callbacks, this.callbacks, i.tags, this.tags, i.metadata, this.metadata, { verbose: this.verbose }), u = {
      options: a,
      invocation_params: this == null ? void 0 : this.invocationParams(a),
      batch_size: t.length
    }, l = await (c == null ? void 0 : c.handleLLMStart(this.toJSON(), t, o, void 0, u, void 0, void 0, i == null ? void 0 : i.runName)), d = [], f = (await Promise.allSettled(t.map(async (m, v) => {
      const g = await n.lookup(m, s);
      return g == null && d.push(v), g;
    }))).map((m, v) => ({
      result: m,
      runManager: l == null ? void 0 : l[v]
    })).filter(({ result: m }) => m.status === "fulfilled" && m.value != null || m.status === "rejected"), p = [];
    await Promise.all(f.map(async ({ result: m, runManager: v }, g) => {
      if (m.status === "fulfilled") {
        const w = m.value;
        return p[g] = w.map((T) => (T.generationInfo = {
          ...T.generationInfo,
          tokenUsage: {}
        }, T)), w.length && await (v == null ? void 0 : v.handleLLMNewToken(w[0].text)), v == null ? void 0 : v.handleLLMEnd({ generations: [w] }, void 0, void 0, void 0, { cached: !0 });
      } else
        return await (v == null ? void 0 : v.handleLLMError(m.reason, void 0, void 0, void 0, { cached: !0 })), Promise.reject(m.reason);
    }));
    const y = {
      generations: p,
      missingPromptIndices: d,
      startedRunManagers: l
    };
    return Object.defineProperty(y, Qs, {
      value: l ? { runIds: l == null ? void 0 : l.map((m) => m.runId) } : void 0,
      configurable: !0
    }), y;
  }
  /**
  * Run the LLM on the given prompts and input, handling caching.
  */
  async generate(t, n, s) {
    if (!Array.isArray(t)) throw new Error("Argument 'prompts' is expected to be a string[]");
    let a;
    Array.isArray(n) ? a = { stop: n } : a = n;
    const [i, o] = this._separateRunnableConfigFromCallOptionsCompat(a);
    if (i.callbacks = i.callbacks ?? s, !this.cache) return this._generateUncached(t, o, i);
    const { cache: c } = this, u = this._getSerializedCacheKeyParametersForCall(o), { generations: l, missingPromptIndices: d, startedRunManagers: h } = await this._generateCached({
      prompts: t,
      cache: c,
      llmStringKey: u,
      parsedOptions: o,
      handledOptions: i,
      runId: i.runId
    });
    let f = {};
    if (d.length > 0) {
      const p = await this._generateUncached(d.map((y) => t[y]), o, i, h !== void 0 ? d.map((y) => h == null ? void 0 : h[y]) : void 0);
      await Promise.all(p.generations.map(async (y, m) => {
        const v = d[m];
        return l[v] = y, c.update(t[v], u, y);
      })), f = p.llmOutput ?? {};
    }
    return {
      generations: l,
      llmOutput: f
    };
  }
  /**
  * Get the identifying parameters of the LLM.
  */
  _identifyingParams() {
    return {};
  }
  _modelType() {
    return "base_llm";
  }
}, g1 = class extends ay {
  async _generate(r, e, t) {
    return { generations: await Promise.all(r.map((s, a) => this._call(s, {
      ...e,
      promptIndex: a
    }, t).then((i) => [{ text: i }]))) };
  }
}, _1 = {};
Ae(_1, { chunkArray: () => y1 });
const y1 = (r, e) => r.reduce((t, n, s) => {
  const a = Math.floor(s / e), i = t[a] || [];
  return t[a] = i.concat([n]), t;
}, []);
var w1 = {};
Ae(w1, { Embeddings: () => v1 });
var v1 = class {
  constructor(r) {
    /**
    * The async caller should be used by subclasses to make any async calls,
    * which will thus benefit from the concurrency and retry logic.
    */
    b(this, "caller");
    this.caller = new pa(r ?? {});
  }
}, b1 = {};
Ae(b1, {
  BaseToolkit: () => S1,
  DynamicStructuredTool: () => cy,
  DynamicTool: () => oy,
  StructuredTool: () => Mo,
  Tool: () => iy,
  ToolInputParsingException: () => Si,
  isLangChainTool: () => Ao,
  isRunnableToolLike: () => Dl,
  isStructuredTool: () => Ml,
  isStructuredToolParams: () => jl,
  tool: () => T1
});
var Mo = class extends Bl {
  constructor(e) {
    super(e ?? {});
    /**
    * Optional provider-specific extra fields for the tool.
    *
    * This is used to pass provider-specific configuration that doesn't fit into
    * standard tool fields.
    */
    b(this, "extras");
    /**
    * Whether to return the tool's output directly.
    *
    * Setting this to true means that after the tool is called,
    * an agent should stop looping.
    */
    b(this, "returnDirect", !1);
    b(this, "verboseParsingErrors", !1);
    /**
    * The tool response format.
    *
    * If "content" then the output of the tool is interpreted as the contents of a
    * ToolMessage. If "content_and_artifact" then the output is expected to be a
    * two-tuple corresponding to the (content, artifact) of a ToolMessage.
    *
    * @default "content"
    */
    b(this, "responseFormat", "content");
    /**
    * Default config object for the tool runnable.
    */
    b(this, "defaultConfig");
    this.verboseParsingErrors = (e == null ? void 0 : e.verboseParsingErrors) ?? this.verboseParsingErrors, this.responseFormat = (e == null ? void 0 : e.responseFormat) ?? this.responseFormat, this.defaultConfig = (e == null ? void 0 : e.defaultConfig) ?? this.defaultConfig, this.metadata = (e == null ? void 0 : e.metadata) ?? this.metadata, this.extras = (e == null ? void 0 : e.extras) ?? this.extras;
  }
  get lc_namespace() {
    return ["langchain", "tools"];
  }
  /**
  * Invokes the tool with the provided input and configuration.
  * @param input The input for the tool.
  * @param config Optional configuration for the tool.
  * @returns A Promise that resolves with the tool's output.
  */
  async invoke(e, t) {
    let n, s = Ce(ki(this.defaultConfig, t));
    return js(e) ? (n = e.args, s = {
      ...s,
      toolCall: e
    }) : n = e, this.call(n, s);
  }
  /**
  * @deprecated Use .invoke() instead. Will be removed in 0.3.0.
  *
  * Calls the tool with the provided argument, configuration, and tags. It
  * parses the input according to the schema, handles any errors, and
  * manages callbacks.
  * @param arg The input argument for the tool.
  * @param configArg Optional configuration or callbacks for the tool.
  * @param tags Optional tags for the tool.
  * @returns A Promise that resolves with a string.
  */
  async call(e, t, n) {
    const s = js(e) ? e.args : e;
    let a;
    if (br(this.schema)) try {
      a = await Eo(this.schema, s);
    } catch (p) {
      let y = "Received tool input did not match expected schema";
      throw this.verboseParsingErrors && (y = `${y}
Details: ${p.message}`), s_(p) && (y = `${y}

${LT(p)}`), new Si(y, JSON.stringify(e));
    }
    else {
      const p = Ze(s, this.schema);
      if (!p.valid) {
        let y = "Received tool input did not match expected schema";
        throw this.verboseParsingErrors && (y = `${y}
Details: ${p.errors.map((m) => `${m.keywordLocation}: ${m.error}`).join(`
`)}`), new Si(y, JSON.stringify(e));
      }
      a = s;
    }
    const i = mo(t), o = Pt.configure(i.callbacks, this.callbacks, i.tags || n, this.tags, i.metadata, this.metadata, { verbose: this.verbose }), c = await (o == null ? void 0 : o.handleToolStart(this.toJSON(), typeof e == "string" ? e : JSON.stringify(e), i.runId, void 0, void 0, void 0, i.runName));
    delete i.runId;
    let u;
    try {
      u = await this._call(a, c, i);
    } catch (p) {
      throw await (c == null ? void 0 : c.handleToolError(p)), p;
    }
    let l, d;
    if (this.responseFormat === "content_and_artifact") if (Array.isArray(u) && u.length === 2) [l, d] = u;
    else throw new Error(`Tool response format is "content_and_artifact" but the output was not a two-tuple.
Result: ${JSON.stringify(u)}`);
    else l = u;
    let h;
    js(e) && (h = e.id), !h && Tv(i) && (h = i.toolCall.id);
    const f = E1({
      content: l,
      artifact: d,
      toolCallId: h,
      name: this.name,
      metadata: this.metadata
    });
    return await (c == null ? void 0 : c.handleToolEnd(f)), f;
  }
}, iy = class extends Mo {
  constructor(e) {
    super(e);
    b(this, "schema", Oo({ input: Io().optional() }).transform((e) => e.input));
  }
  /**
  * @deprecated Use .invoke() instead. Will be removed in 0.3.0.
  *
  * Calls the tool with the provided argument and callbacks. It handles
  * string inputs specifically.
  * @param arg The input argument for the tool, which can be a string, undefined, or an input of the tool's schema.
  * @param callbacks Optional callbacks for the tool.
  * @returns A Promise that resolves with a string.
  */
  call(e, t) {
    const n = typeof e == "string" || e == null ? { input: e } : e;
    return super.call(n, t);
  }
}, oy = class extends iy {
  constructor(e) {
    super(e);
    b(this, "name");
    b(this, "description");
    b(this, "func");
    this.name = e.name, this.description = e.description, this.func = e.func, this.returnDirect = e.returnDirect ?? this.returnDirect;
  }
  static lc_name() {
    return "DynamicTool";
  }
  /**
  * @deprecated Use .invoke() instead. Will be removed in 0.3.0.
  */
  async call(e, t) {
    const n = mo(t);
    return n.runName === void 0 && (n.runName = this.name), super.call(e, n);
  }
  /** @ignore */
  async _call(e, t, n) {
    return this.func(e, t, n);
  }
}, cy = class extends Mo {
  constructor(e) {
    super(e);
    b(this, "name");
    b(this, "description");
    b(this, "func");
    b(this, "schema");
    this.name = e.name, this.description = e.description, this.func = e.func, this.returnDirect = e.returnDirect ?? this.returnDirect, this.schema = e.schema;
  }
  static lc_name() {
    return "DynamicStructuredTool";
  }
  /**
  * @deprecated Use .invoke() instead. Will be removed in 0.3.0.
  */
  async call(e, t, n) {
    const s = mo(t);
    return s.runName === void 0 && (s.runName = this.name), super.call(e, s, n);
  }
  _call(e, t, n) {
    return this.func(e, t, n);
  }
}, S1 = class {
  getTools() {
    return this.tools;
  }
};
function T1(r, e) {
  var i;
  const t = Ol(e.schema), n = zs(e.schema);
  if (!e.schema || t || n) return new oy({
    ...e,
    description: e.description ?? ((i = e.schema) == null ? void 0 : i.description) ?? `${e.name} tool`,
    func: async (o, c, u) => new Promise((l, d) => {
      const h = Be(u, { callbacks: c == null ? void 0 : c.getChild() });
      lr.runWithConfig(Ur(h), async () => {
        try {
          l(r(o, h));
        } catch (f) {
          d(f);
        }
      });
    })
  });
  const s = e.schema, a = e.description ?? e.schema.description ?? `${e.name} tool`;
  return new cy({
    ...e,
    description: a,
    schema: s,
    func: async (o, c, u) => new Promise((l, d) => {
      let h;
      const f = () => {
        u != null && u.signal && h && u.signal.removeEventListener("abort", h);
      };
      u != null && u.signal && (h = () => {
        f(), d(Ys(u.signal));
      }, u.signal.addEventListener("abort", h));
      const p = Be(u, { callbacks: c == null ? void 0 : c.getChild() });
      lr.runWithConfig(Ur(p), async () => {
        var y;
        try {
          const m = await r(o, p);
          if ((y = u == null ? void 0 : u.signal) != null && y.aborted) {
            f();
            return;
          }
          f(), l(m);
        } catch (m) {
          f(), d(m);
        }
      });
    })
  });
}
function E1(r) {
  const { content: e, artifact: t, toolCallId: n, metadata: s } = r;
  return n && !rl(e) ? typeof e == "string" || Array.isArray(e) && e.every((a) => typeof a == "object") ? new Ir({
    status: "success",
    content: e,
    artifact: t,
    tool_call_id: n,
    name: r.name,
    metadata: s
  }) : new Ir({
    status: "success",
    content: x1(e),
    artifact: t,
    tool_call_id: n,
    name: r.name,
    metadata: s
  }) : e;
}
function x1(r) {
  try {
    return JSON.stringify(r, null, 2) ?? "";
  } catch {
    return `${r}`;
  }
}
var Jr = { exports: {} };
const k1 = "17.2.3", I1 = {
  version: k1
}, bu = by, Gi = If, O1 = Sy, A1 = gs, $1 = I1, Jl = $1.version, vf = [
  "ðŸ” encrypt with Dotenvx: https://dotenvx.com",
  "ðŸ” prevent committing .env to code: https://dotenvx.com/precommit",
  "ðŸ” prevent building .env in docker: https://dotenvx.com/prebuild",
  "ðŸ“¡ add observability to secrets: https://dotenvx.com/ops",
  "ðŸ‘¥ sync secrets across teammates & machines: https://dotenvx.com/ops",
  "ðŸ—‚ï¸ backup and recover secrets: https://dotenvx.com/ops",
  "âœ… audit secrets and track compliance: https://dotenvx.com/ops",
  "ðŸ”„ add secrets lifecycle management: https://dotenvx.com/ops",
  "ðŸ”‘ add access controls to secrets: https://dotenvx.com/ops",
  "ðŸ› ï¸  run anywhere with `dotenvx run -- yourcommand`",
  "âš™ï¸  specify custom .env file path with { path: '/custom/path/.env' }",
  "âš™ï¸  enable debug logging with { debug: true }",
  "âš™ï¸  override existing env vars with { override: true }",
  "âš™ï¸  suppress all logs with { quiet: true }",
  "âš™ï¸  write to custom object with { processEnv: myObject }",
  "âš™ï¸  load multiple .env files with { path: ['.env.local', '.env'] }"
];
function C1() {
  return vf[Math.floor(Math.random() * vf.length)];
}
function Wn(r) {
  return typeof r == "string" ? !["false", "0", "no", "off", ""].includes(r.toLowerCase()) : !!r;
}
function R1() {
  return process.stdout.isTTY;
}
function N1(r) {
  return R1() ? `\x1B[2m${r}\x1B[0m` : r;
}
const P1 = /(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/mg;
function L1(r) {
  const e = {};
  let t = r.toString();
  t = t.replace(/\r\n?/mg, `
`);
  let n;
  for (; (n = P1.exec(t)) != null; ) {
    const s = n[1];
    let a = n[2] || "";
    a = a.trim();
    const i = a[0];
    a = a.replace(/^(['"`])([\s\S]*)\1$/mg, "$2"), i === '"' && (a = a.replace(/\\n/g, `
`), a = a.replace(/\\r/g, "\r")), e[s] = a;
  }
  return e;
}
function M1(r) {
  r = r || {};
  const e = dy(r);
  r.path = e;
  const t = lt.configDotenv(r);
  if (!t.parsed) {
    const i = new Error(`MISSING_DATA: Cannot parse ${e} for an unknown reason`);
    throw i.code = "MISSING_DATA", i;
  }
  const n = ly(r).split(","), s = n.length;
  let a;
  for (let i = 0; i < s; i++)
    try {
      const o = n[i].trim(), c = j1(t, o);
      a = lt.decrypt(c.ciphertext, c.key);
      break;
    } catch (o) {
      if (i + 1 >= s)
        throw o;
    }
  return lt.parse(a);
}
function D1(r) {
  console.error(`[dotenv@${Jl}][WARN] ${r}`);
}
function Bs(r) {
  console.log(`[dotenv@${Jl}][DEBUG] ${r}`);
}
function uy(r) {
  console.log(`[dotenv@${Jl}] ${r}`);
}
function ly(r) {
  return r && r.DOTENV_KEY && r.DOTENV_KEY.length > 0 ? r.DOTENV_KEY : process.env.DOTENV_KEY && process.env.DOTENV_KEY.length > 0 ? process.env.DOTENV_KEY : "";
}
function j1(r, e) {
  let t;
  try {
    t = new URL(e);
  } catch (o) {
    if (o.code === "ERR_INVALID_URL") {
      const c = new Error("INVALID_DOTENV_KEY: Wrong format. Must be in valid uri format like dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=development");
      throw c.code = "INVALID_DOTENV_KEY", c;
    }
    throw o;
  }
  const n = t.password;
  if (!n) {
    const o = new Error("INVALID_DOTENV_KEY: Missing key part");
    throw o.code = "INVALID_DOTENV_KEY", o;
  }
  const s = t.searchParams.get("environment");
  if (!s) {
    const o = new Error("INVALID_DOTENV_KEY: Missing environment part");
    throw o.code = "INVALID_DOTENV_KEY", o;
  }
  const a = `DOTENV_VAULT_${s.toUpperCase()}`, i = r.parsed[a];
  if (!i) {
    const o = new Error(`NOT_FOUND_DOTENV_ENVIRONMENT: Cannot locate environment ${a} in your .env.vault file.`);
    throw o.code = "NOT_FOUND_DOTENV_ENVIRONMENT", o;
  }
  return { ciphertext: i, key: n };
}
function dy(r) {
  let e = null;
  if (r && r.path && r.path.length > 0)
    if (Array.isArray(r.path))
      for (const t of r.path)
        bu.existsSync(t) && (e = t.endsWith(".vault") ? t : `${t}.vault`);
    else
      e = r.path.endsWith(".vault") ? r.path : `${r.path}.vault`;
  else
    e = Gi.resolve(process.cwd(), ".env.vault");
  return bu.existsSync(e) ? e : null;
}
function bf(r) {
  return r[0] === "~" ? Gi.join(O1.homedir(), r.slice(1)) : r;
}
function F1(r) {
  const e = Wn(process.env.DOTENV_CONFIG_DEBUG || r && r.debug), t = Wn(process.env.DOTENV_CONFIG_QUIET || r && r.quiet);
  (e || !t) && uy("Loading env from encrypted .env.vault");
  const n = lt._parseVault(r);
  let s = process.env;
  return r && r.processEnv != null && (s = r.processEnv), lt.populate(s, n, r), { parsed: n };
}
function U1(r) {
  const e = Gi.resolve(process.cwd(), ".env");
  let t = "utf8", n = process.env;
  r && r.processEnv != null && (n = r.processEnv);
  let s = Wn(n.DOTENV_CONFIG_DEBUG || r && r.debug), a = Wn(n.DOTENV_CONFIG_QUIET || r && r.quiet);
  r && r.encoding ? t = r.encoding : s && Bs("No encoding is specified. UTF-8 is used by default");
  let i = [e];
  if (r && r.path)
    if (!Array.isArray(r.path))
      i = [bf(r.path)];
    else {
      i = [];
      for (const l of r.path)
        i.push(bf(l));
    }
  let o;
  const c = {};
  for (const l of i)
    try {
      const d = lt.parse(bu.readFileSync(l, { encoding: t }));
      lt.populate(c, d, r);
    } catch (d) {
      s && Bs(`Failed to load ${l} ${d.message}`), o = d;
    }
  const u = lt.populate(n, c, r);
  if (s = Wn(n.DOTENV_CONFIG_DEBUG || s), a = Wn(n.DOTENV_CONFIG_QUIET || a), s || !a) {
    const l = Object.keys(u).length, d = [];
    for (const h of i)
      try {
        const f = Gi.relative(process.cwd(), h);
        d.push(f);
      } catch (f) {
        s && Bs(`Failed to load ${h} ${f.message}`), o = f;
      }
    uy(`injecting env (${l}) from ${d.join(",")} ${N1(`-- tip: ${C1()}`)}`);
  }
  return o ? { parsed: c, error: o } : { parsed: c };
}
function z1(r) {
  if (ly(r).length === 0)
    return lt.configDotenv(r);
  const e = dy(r);
  return e ? lt._configVault(r) : (D1(`You set DOTENV_KEY but you are missing a .env.vault file at ${e}. Did you forget to build it?`), lt.configDotenv(r));
}
function B1(r, e) {
  const t = Buffer.from(e.slice(-64), "hex");
  let n = Buffer.from(r, "base64");
  const s = n.subarray(0, 12), a = n.subarray(-16);
  n = n.subarray(12, -16);
  try {
    const i = A1.createDecipheriv("aes-256-gcm", t, s);
    return i.setAuthTag(a), `${i.update(n)}${i.final()}`;
  } catch (i) {
    const o = i instanceof RangeError, c = i.message === "Invalid key length", u = i.message === "Unsupported state or unable to authenticate data";
    if (o || c) {
      const l = new Error("INVALID_DOTENV_KEY: It must be 64 characters long (or more)");
      throw l.code = "INVALID_DOTENV_KEY", l;
    } else if (u) {
      const l = new Error("DECRYPTION_FAILED: Please check your DOTENV_KEY");
      throw l.code = "DECRYPTION_FAILED", l;
    } else
      throw i;
  }
}
function Z1(r, e, t = {}) {
  const n = !!(t && t.debug), s = !!(t && t.override), a = {};
  if (typeof e != "object") {
    const i = new Error("OBJECT_REQUIRED: Please check the processEnv argument being passed to populate");
    throw i.code = "OBJECT_REQUIRED", i;
  }
  for (const i of Object.keys(e))
    Object.prototype.hasOwnProperty.call(r, i) ? (s === !0 && (r[i] = e[i], a[i] = e[i]), n && Bs(s === !0 ? `"${i}" is already defined and WAS overwritten` : `"${i}" is already defined and was NOT overwritten`)) : (r[i] = e[i], a[i] = e[i]);
  return a;
}
const lt = {
  configDotenv: U1,
  _configVault: F1,
  _parseVault: M1,
  config: z1,
  decrypt: B1,
  parse: L1,
  populate: Z1
};
Jr.exports.configDotenv = lt.configDotenv;
Jr.exports._configVault = lt._configVault;
Jr.exports._parseVault = lt._parseVault;
Jr.exports.config = lt.config;
Jr.exports.decrypt = lt.decrypt;
Jr.exports.parse = lt.parse;
Jr.exports.populate = lt.populate;
Jr.exports = lt;
var V1 = Jr.exports;
const q1 = /* @__PURE__ */ Yu(V1);
class J1 {
  constructor() {
    b(this, "storage", new Ty());
  }
  run(e, t) {
    return this.storage.run(e, t);
  }
  getRunId() {
    var e;
    return ((e = this.storage.getStore()) == null ? void 0 : e.runId) ?? null;
  }
  getRequesterWebContentsId() {
    var e;
    return ((e = this.storage.getStore()) == null ? void 0 : e.requesterWebContentsId) ?? null;
  }
  getBrowserContext() {
    var e;
    return ((e = this.storage.getStore()) == null ? void 0 : e.browserContext) ?? null;
  }
  setBrowserContext(e) {
    const t = this.storage.getStore();
    t && (t.browserContext = e);
  }
  getObserveOnly() {
    var e;
    return ((e = this.storage.getStore()) == null ? void 0 : e.observeOnly) ?? !1;
  }
  setObserveOnly(e) {
    const t = this.storage.getStore();
    t && (t.observeOnly = e);
  }
  getYoloMode() {
    var e;
    return ((e = this.storage.getStore()) == null ? void 0 : e.yoloMode) ?? !1;
  }
  setYoloMode(e) {
    const t = this.storage.getStore();
    t && (t.yoloMode = e);
  }
}
const ft = new J1();
class H1 {
  constructor() {
    b(this, "baseDir", null);
  }
  getBaseDir() {
    if (this.baseDir) return this.baseDir;
    const e = Bt.getPath("userData");
    return this.baseDir = Ie.join(e, "telemetry"), this.baseDir;
  }
  async ensureDir() {
    await Xe.mkdir(this.getBaseDir(), { recursive: !0 });
  }
  fileForRun(e) {
    return Ie.join(this.getBaseDir(), `agent-run-${e}.jsonl`);
  }
  async appendLine(e, t) {
    await this.ensureDir(), await Xe.appendFile(e, JSON.stringify(t) + `
`, "utf8");
  }
  async emit(e) {
    const t = e.runId;
    t && await this.appendLine(this.fileForRun(t), e), await this.appendLine(Ie.join(this.getBaseDir(), "agent-events.jsonl"), e);
  }
  async exportTrajectories(e) {
    await this.ensureDir();
    const t = this.getBaseDir(), s = (await Xe.readdir(t)).filter((i) => i.startsWith("agent-run-") && i.endsWith(".jsonl")), a = [];
    for (const i of s)
      try {
        const c = (await Xe.readFile(Ie.join(t, i), "utf8")).trim().split(`
`).map((u) => {
          try {
            return JSON.parse(u);
          } catch {
            return null;
          }
        }).filter((u) => u !== null);
        c.length > 0 && a.push({
          runId: c[0].runId,
          timestamp: c[0].ts,
          eventCount: c.length,
          events: c
        });
      } catch (o) {
        console.error(`Failed to process trajectory file ${i}:`, o);
      }
    return await Xe.writeFile(e, JSON.stringify(a, null, 2)), a.length;
  }
}
const tt = new H1();
class G1 {
  constructor() {
    b(this, "db");
    b(this, "encryptionKey", null);
    b(this, "DB_FILENAME", "audit_logs.db");
    const e = Bt.getPath("userData"), t = If.join(e, this.DB_FILENAME);
    this.db = new Ey(t), this.init();
  }
  async init() {
    this.db.exec(`
      CREATE TABLE IF NOT EXISTS audit_logs (
        id TEXT PRIMARY KEY,
        timestamp TEXT NOT NULL,
        actor TEXT NOT NULL,
        action TEXT NOT NULL,
        details TEXT,
        status TEXT NOT NULL
      )
    `), await this.loadOrGenerateKey();
  }
  async loadOrGenerateKey() {
    let e = await Ps.getSecret("audit_db_key");
    e || (e = gs.randomBytes(32).toString("hex"), await Ps.setSecret("audit_db_key", e)), this.encryptionKey = Buffer.from(e, "hex");
  }
  encrypt(e) {
    if (!this.encryptionKey) return e;
    const t = gs.randomBytes(16), n = gs.createCipheriv("aes-256-cbc", this.encryptionKey, t);
    let s = n.update(e);
    return s = Buffer.concat([s, n.final()]), t.toString("hex") + ":" + s.toString("hex");
  }
  decrypt(e) {
    if (!this.encryptionKey) return e;
    try {
      const t = e.split(":"), n = Buffer.from(t.shift(), "hex"), s = Buffer.from(t.join(":"), "hex"), a = gs.createDecipheriv("aes-256-cbc", this.encryptionKey, n);
      let i = a.update(s);
      return i = Buffer.concat([i, a.final()]), i.toString();
    } catch (t) {
      return console.error("Failed to decrypt log:", t), "[Encrypted Content]";
    }
  }
  async log(e) {
    this.encryptionKey || await this.loadOrGenerateKey();
    const t = Pe(), n = (/* @__PURE__ */ new Date()).toISOString(), s = JSON.stringify(e.details), a = this.encrypt(s);
    return this.db.prepare(`
      INSERT INTO audit_logs (id, timestamp, actor, action, details, status)
      VALUES (?, ?, ?, ?, ?, ?)
    `).run(t, n, e.actor, e.action, a, e.status), t;
  }
  getLogs(e = 100) {
    return this.db.prepare("SELECT * FROM audit_logs ORDER BY timestamp DESC LIMIT ?").all(e).map((s) => ({
      ...s,
      details: this.decrypt(s.details)
      // Attempt to decrypt on read
    }));
  }
}
const yt = new G1();
var Su = /* @__PURE__ */ ((r) => (r.ALLOW = "allow", r.DENY = "deny", r.NEEDS_APPROVAL = "needs_approval", r))(Su || {});
const Ha = {
  // Browser observation tools - LOW risk
  browser_observe: 0,
  browser_wait_for_selector: 0,
  browser_wait_for_url: 0,
  browser_wait_for_text: 0,
  browser_wait_for_text_in: 0,
  browser_find_text: 0,
  browser_get_text: 0,
  browser_extract_main_text: 1,
  // Extraction is risky but read-only
  // Browser navigation - LOW to MEDIUM risk
  browser_navigate: 0,
  browser_go_back: 0,
  browser_go_forward: 0,
  browser_reload: 0,
  // Browser interaction - MEDIUM risk
  browser_click: 1,
  browser_click_text: 1,
  browser_type: 1,
  browser_select: 1,
  browser_scroll: 1,
  browser_press_key: 1,
  browser_focus: 1,
  browser_clear: 1,
  // Complex browser operations - HIGH risk
  browser_execute_plan: 2,
  browser_screenshot: 1,
  // Mock SaaS operations - MEDIUM to HIGH risk
  jira_create_issue: 2,
  jira_update_issue: 1,
  jira_delete_issue: 2,
  confluence_create_page: 2,
  confluence_update_page: 1,
  confluence_delete_page: 2,
  trello_create_card: 1,
  trello_move_card: 1,
  trello_delete_card: 2,
  // Code and file operations - MEDIUM to HIGH risk
  code_read_file: 0,
  code_list_files: 0,
  code_search: 0,
  code_execute: 2,
  code_write_file: 2,
  code_delete_file: 2,
  // System operations - HIGH risk
  system_execute: 2,
  system_write_file: 2,
  system_delete_file: 2
  /* HIGH */
}, Cr = {
  // Local development - LOW risk
  localhost: 0,
  "127.0.0.1": 0,
  "0.0.0.0": 0,
  // Mock SaaS - LOW risk (sandboxed)
  "mock-saas.com": 0,
  "localhost:3000": 0,
  // Trusted domains - LOW risk
  "docs.example.com": 0,
  "help.example.com": 0,
  // Production domains - MEDIUM to HIGH risk
  "app.example.com": 1,
  "admin.example.com": 2,
  "api.example.com": 1,
  // External domains - HIGH risk
  "github.com": 1,
  "stackoverflow.com": 0,
  "google.com": 0
  /* LOW */
};
class W1 {
  constructor(e, t) {
    b(this, "rules", []);
    b(this, "telemetryService");
    b(this, "auditService");
    this.telemetryService = e, this.auditService = t, this.initializeDefaultRules();
  }
  initializeDefaultRules() {
    this.addRule({
      name: "observe-only-enforcement",
      description: "Block state-modifying tools in observe-only mode",
      priority: 1e3,
      match: (e) => !!e.observeOnly,
      evaluate: (e) => [
        "browser_observe",
        "browser_navigate",
        // Allowed to move around to observe
        "browser_go_back",
        "browser_go_forward",
        "browser_reload",
        "browser_scroll",
        "browser_wait_for_selector",
        "browser_wait_for_url",
        "browser_wait_for_text",
        "browser_wait_for_text_in",
        "browser_get_text",
        "browser_find_text",
        "browser_extract_main_text",
        "browser_screenshot",
        "code_read_file",
        "code_list_files",
        "code_search"
      ].includes(e.toolName) ? {
        decision: "allow",
        riskLevel: 0,
        reason: "Tool allowed in observe-only mode (pending further checks)",
        matchedRule: "observe-only-enforcement"
      } : {
        decision: "deny",
        riskLevel: 2,
        reason: "Tool execution denied: Observe-only mode is active",
        matchedRule: "observe-only-enforcement"
      }
    }), this.addRule({
      name: "dangerous-operations-deny",
      description: "Deny dangerous system operations",
      priority: 100,
      match: (e) => ["system_execute", "system_delete_file", "code_execute"].includes(e.toolName),
      evaluate: (e) => ({
        decision: "deny",
        riskLevel: 2,
        reason: "Dangerous system operations are not allowed",
        matchedRule: "dangerous-operations-deny"
      })
    }), this.addRule({
      name: "admin-bypass",
      description: "Allow low/medium risk operations in admin mode",
      priority: 90,
      match: (e) => e.userMode === "admin",
      evaluate: (e) => {
        const t = Ha[e.toolName] || 1, n = e.domain && Cr[e.domain] || 1, s = t > n ? t : n;
        return s === 2 ? {
          decision: "needs_approval",
          riskLevel: 2,
          reason: "High risk operation requires approval even in admin mode",
          matchedRule: "admin-bypass"
        } : {
          decision: "allow",
          riskLevel: s,
          reason: "Allowed in admin mode",
          matchedRule: "admin-bypass"
        };
      }
    }), this.addRule({
      name: "high-risk-domains",
      description: "Require approval for operations on high-risk domains",
      priority: 80,
      match: (e) => (e.domain ? Cr[e.domain] : 1) === 2,
      evaluate: (e) => ({
        decision: "needs_approval",
        riskLevel: 2,
        reason: `High risk domain: ${e.domain}`,
        matchedRule: "high-risk-domains"
      })
    }), this.addRule({
      name: "extract-main-text-gating",
      description: "Gate browser_extract_main_text to reduce sensitive data exposure",
      priority: 85,
      match: (e) => e.toolName === "browser_extract_main_text",
      evaluate: (e) => {
        const t = e.domain ? Cr[e.domain] : void 0;
        return (t === void 0 ? 2 : t) === 0 ? {
          decision: "needs_approval",
          riskLevel: 1,
          reason: "Extract main text requires approval",
          matchedRule: "extract-main-text-gating"
        } : {
          decision: "needs_approval",
          riskLevel: 2,
          reason: `Extract main text on non-low-risk domain: ${e.domain ?? "unknown"}`,
          matchedRule: "extract-main-text-gating"
        };
      }
    }), this.addRule({
      name: "external-file-operations",
      description: "File uploads/downloads on external domains need approval",
      priority: 70,
      match: (e) => {
        const t = ["code_write_file", "code_delete_file"], n = !!(e.domain && !(e.domain in Cr));
        return t.includes(e.toolName) && n;
      },
      evaluate: (e) => ({
        decision: "needs_approval",
        riskLevel: 2,
        reason: "File operations on external domains require approval",
        matchedRule: "external-file-operations"
      })
    }), this.addRule({
      name: "default-risk-evaluation",
      description: "Default evaluation based on tool and domain risk",
      priority: 0,
      match: () => !0,
      // Always matches as fallback
      evaluate: (e) => {
        const t = Ha[e.toolName] || 1, n = e.domain && Cr[e.domain] || 1, s = t > n ? t : n, a = this.evaluateArgsRisk(e), i = a > s ? a : s;
        return i === 2 ? {
          decision: "needs_approval",
          riskLevel: 2,
          reason: "High risk operation detected",
          matchedRule: "default-risk-evaluation"
        } : i === 1 && e.userMode !== "developer" ? {
          decision: "needs_approval",
          riskLevel: 1,
          reason: "Medium risk operation requires approval in standard mode",
          matchedRule: "default-risk-evaluation"
        } : {
          decision: "allow",
          riskLevel: i,
          reason: "Low risk operation allowed",
          matchedRule: "default-risk-evaluation"
        };
      }
    });
  }
  evaluateArgsRisk(e) {
    const { args: t } = e;
    if (!t || typeof t != "object") return 0;
    if (e.toolName === "browser_navigate" && t && typeof t.url == "string")
      try {
        const a = new URL(t.url), i = a.port ? `${a.hostname}:${a.port}` : a.hostname, o = Cr[i];
        if (o === 2 || o === void 0)
          return 2;
      } catch {
        return 2;
      }
    if (e.toolName === "browser_execute_plan")
      try {
        const a = Array.isArray(t == null ? void 0 : t.steps) ? t.steps : [];
        for (const i of a)
          if ((i == null ? void 0 : i.action) === "navigate" && typeof (i == null ? void 0 : i.url) == "string")
            try {
              const o = new URL(i.url), c = o.port ? `${o.hostname}:${o.port}` : o.hostname, u = Cr[c];
              if (u === 2 || u === void 0)
                return 2;
            } catch {
              return 2;
            }
      } catch {
        return 1;
      }
    const n = [
      /password/i,
      /token/i,
      /secret/i,
      /key/i,
      /delete/i,
      /drop\s+table/i,
      /rm\s+-rf/i,
      /sudo/i
    ], s = JSON.stringify(t).toLowerCase();
    for (const a of n)
      if (a.test(s))
        return 2;
    return t.value && typeof t.value == "string" && t.value.length > 1e4 ? 1 : 0;
  }
  addRule(e) {
    this.rules.push(e), this.rules.sort((t, n) => n.priority - t.priority);
  }
  removeRule(e) {
    this.rules = this.rules.filter((t) => t.name !== e);
  }
  async evaluate(e) {
    const t = Date.now(), n = e.runId;
    for (const s of this.rules)
      if (s.match(e)) {
        const a = s.evaluate(e), i = Date.now() - t, o = this.hashArgs(e.args);
        try {
          await this.telemetryService.emit({
            eventId: Pe(),
            runId: n,
            ts: (/* @__PURE__ */ new Date()).toISOString(),
            type: "policy_evaluation",
            name: "PolicyService",
            data: {
              toolName: e.toolName,
              domain: e.domain,
              userMode: e.userMode,
              decision: a.decision,
              riskLevel: a.riskLevel,
              matchedRule: s.name,
              durationMs: i,
              argsHash: o
            }
          });
        } catch {
        }
        try {
          await this.auditService.log({
            actor: "system",
            action: "policy_evaluation",
            details: {
              runId: n,
              toolName: e.toolName,
              domain: e.domain,
              userMode: e.userMode,
              decision: a.decision,
              riskLevel: a.riskLevel,
              reason: a.reason,
              matchedRule: s.name,
              durationMs: i,
              argsHash: o
            },
            status: "success"
          }).catch(() => {
          });
        } catch {
        }
        return a;
      }
    return {
      decision: "needs_approval",
      riskLevel: 1,
      reason: "No policy rule matched"
    };
  }
  hashArgs(e) {
    if (!e) return "";
    const t = JSON.stringify(e);
    let n = 0;
    for (let s = 0; s < t.length; s++) {
      const a = t.charCodeAt(s);
      n = (n << 5) - n + a, n = n & n;
    }
    return n.toString(36);
  }
  // Helper methods for policy management
  getRules() {
    return [...this.rules];
  }
  getToolRiskLevel(e) {
    return Ha[e] || 1;
  }
  getDomainRiskLevel(e) {
    return Cr[e] || 1;
  }
  // Update domain risk levels at runtime
  updateDomainRiskLevel(e, t) {
    Cr[e] = t;
  }
  // Update tool risk levels at runtime
  updateToolRiskLevel(e, t) {
    Ha[e] = t;
  }
}
class K1 {
  constructor() {
    b(this, "tools", /* @__PURE__ */ new Map());
    b(this, "approvalHandler", null);
    b(this, "policyService", null);
  }
  setApprovalHandler(e) {
    this.approvalHandler = e;
  }
  setPolicyService(e) {
    this.policyService = e;
  }
  getPolicyService() {
    return this.policyService;
  }
  register(e) {
    this.tools.has(e.name) && console.warn(`Tool with name ${e.name} is already registered. Overwriting.`), this.tools.set(e.name, e);
  }
  getTool(e) {
    return this.tools.get(e);
  }
  getAllTools() {
    return Array.from(this.tools.values());
  }
  async invokeToolInternal(e, t) {
    var l;
    const n = ft.getRunId() ?? void 0, s = (() => {
      try {
        return JSON.stringify(t ?? null);
      } catch {
        return "[unserializable_args]";
      }
    })(), a = nn.createHash("sha256").update(s).digest("hex"), i = Pe(), o = Date.now();
    try {
      await tt.emit({
        eventId: Pe(),
        runId: n,
        ts: (/* @__PURE__ */ new Date()).toISOString(),
        type: "tool_call_start",
        name: e.name,
        data: { toolCallId: i, argsHash: a }
      });
    } catch {
    }
    try {
      yt.log({
        actor: "agent",
        action: "tool_call_start",
        details: { runId: n, toolName: e.name, toolCallId: i, argsHash: a },
        status: "pending"
      }).catch(() => {
      });
    } catch {
    }
    const c = this.approvalHandler, u = this.policyService;
    if (u) {
      const d = ft.getBrowserContext(), h = {
        toolName: e.name,
        args: t,
        url: d == null ? void 0 : d.url,
        domain: d == null ? void 0 : d.domain,
        userMode: "standard",
        observeOnly: ft.getObserveOnly(),
        runId: n
      }, f = await u.evaluate(h);
      if (f.decision === Su.DENY) {
        const p = Date.now() - o;
        try {
          await tt.emit({
            eventId: Pe(),
            runId: n,
            ts: (/* @__PURE__ */ new Date()).toISOString(),
            type: "tool_call_end",
            name: e.name,
            data: { toolCallId: i, argsHash: a, durationMs: p, error: "Policy denied" }
          });
        } catch {
        }
        try {
          yt.log({
            actor: "system",
            action: "tool_call_denied",
            details: { runId: n, toolName: e.name, toolCallId: i, reason: f.reason },
            status: "failure"
          }).catch(() => {
          });
        } catch {
        }
        return `Operation denied by policy: ${f.reason}`;
      }
      if (f.decision === Su.NEEDS_APPROVAL && c)
        if (ft.getYoloMode())
          try {
            yt.log({
              actor: "system",
              action: "approval_auto_granted",
              details: { runId: n, toolName: e.name, toolCallId: i, reason: "YOLO mode" },
              status: "success"
            }).catch(() => {
            });
          } catch {
          }
        else {
          try {
            await tt.emit({
              eventId: Pe(),
              runId: n,
              ts: (/* @__PURE__ */ new Date()).toISOString(),
              type: "approval_request",
              name: e.name,
              data: { toolCallId: i, argsHash: a, riskLevel: f.riskLevel }
            });
          } catch {
          }
          try {
            yt.log({
              actor: "system",
              action: "approval_request",
              details: { runId: n, toolName: e.name, toolCallId: i, argsHash: a, reason: f.reason },
              status: "pending"
            }).catch(() => {
            });
          } catch {
          }
          const p = await c(e.name, t);
          try {
            await tt.emit({
              eventId: Pe(),
              runId: n,
              ts: (/* @__PURE__ */ new Date()).toISOString(),
              type: "approval_decision",
              name: e.name,
              data: { toolCallId: i, argsHash: a, approved: p }
            });
          } catch {
          }
          try {
            yt.log({
              actor: "system",
              action: "approval_decision",
              details: { runId: n, toolName: e.name, toolCallId: i, argsHash: a, approved: p },
              status: p ? "success" : "failure"
            }).catch(() => {
            });
          } catch {
          }
          if (!p) {
            const y = Date.now() - o;
            try {
              await tt.emit({
                eventId: Pe(),
                runId: n,
                ts: (/* @__PURE__ */ new Date()).toISOString(),
                type: "tool_call_end",
                name: e.name,
                data: { toolCallId: i, argsHash: a, durationMs: y, error: "User denied" }
              });
            } catch {
            }
            try {
              yt.log({
                actor: "user",
                action: "tool_call_denied",
                details: { runId: n, toolName: e.name, toolCallId: i },
                status: "failure"
              }).catch(() => {
              });
            } catch {
            }
            return "User denied execution of this tool.";
          }
        }
    } else if (e.requiresApproval && c)
      if (ft.getYoloMode())
        try {
          yt.log({
            actor: "system",
            action: "approval_auto_granted",
            details: { runId: n, toolName: e.name, toolCallId: i, reason: "YOLO mode" },
            status: "success"
          }).catch(() => {
          });
        } catch {
        }
      else {
        try {
          await tt.emit({
            eventId: Pe(),
            runId: n,
            ts: (/* @__PURE__ */ new Date()).toISOString(),
            type: "approval_request",
            name: e.name,
            data: { toolCallId: i, argsHash: a }
          });
        } catch {
        }
        try {
          yt.log({
            actor: "system",
            action: "approval_request",
            details: { runId: n, toolName: e.name, toolCallId: i, argsHash: a },
            status: "pending"
          }).catch(() => {
          });
        } catch {
        }
        const d = await c(e.name, t);
        try {
          await tt.emit({
            eventId: Pe(),
            runId: n,
            ts: (/* @__PURE__ */ new Date()).toISOString(),
            type: "approval_decision",
            name: e.name,
            data: { toolCallId: i, argsHash: a, approved: d }
          });
        } catch {
        }
        try {
          yt.log({
            actor: "system",
            action: "approval_decision",
            details: { runId: n, toolName: e.name, toolCallId: i, argsHash: a, approved: d },
            status: d ? "success" : "failure"
          }).catch(() => {
          });
        } catch {
        }
        if (!d) {
          const h = Date.now() - o;
          try {
            await tt.emit({
              eventId: Pe(),
              runId: n,
              ts: (/* @__PURE__ */ new Date()).toISOString(),
              type: "tool_call_end",
              name: e.name,
              data: { toolCallId: i, argsHash: a, durationMs: h, error: "User denied" }
            });
          } catch {
          }
          try {
            yt.log({
              actor: "user",
              action: "tool_call_denied",
              details: { runId: n, toolName: e.name, toolCallId: i },
              status: "failure"
            }).catch(() => {
            });
          } catch {
          }
          return "User denied execution of this tool.";
        }
      }
    try {
      const d = (l = e.schema) != null && l.parse ? e.schema.parse(t ?? {}) : t, h = await e.execute(d), f = Date.now() - o;
      try {
        await tt.emit({
          eventId: Pe(),
          runId: n,
          ts: (/* @__PURE__ */ new Date()).toISOString(),
          type: "tool_call_end",
          name: e.name,
          data: { toolCallId: i, argsHash: a, durationMs: f, resultLength: String(h ?? "").length }
        });
      } catch {
      }
      try {
        yt.log({
          actor: "agent",
          action: "tool_call_end",
          details: { runId: n, toolName: e.name, toolCallId: i, durationMs: f },
          status: "success"
        }).catch(() => {
        });
      } catch {
      }
      return h;
    } catch (d) {
      const h = Date.now() - o;
      try {
        await tt.emit({
          eventId: Pe(),
          runId: n,
          ts: (/* @__PURE__ */ new Date()).toISOString(),
          type: "tool_call_end",
          name: e.name,
          data: { toolCallId: i, argsHash: a, durationMs: h, error: String((d == null ? void 0 : d.message) ?? d) }
        });
      } catch {
      }
      try {
        yt.log({
          actor: "agent",
          action: "tool_call_end",
          details: { runId: n, toolName: e.name, toolCallId: i, durationMs: h, error: String((d == null ? void 0 : d.message) ?? d) },
          status: "failure"
        }).catch(() => {
        });
      } catch {
      }
      return `Tool execution failed: ${String((d == null ? void 0 : d.message) ?? d)}`;
    }
  }
  async invokeTool(e, t) {
    const n = this.tools.get(e);
    return n ? this.invokeToolInternal(n, t) : `Error: Tool '${e}' not found.`;
  }
  // Convert to LangChain tools format
  toLangChainTools() {
    const e = this;
    return this.getAllTools().map((t) => new class extends Mo {
      constructor() {
        super(...arguments);
        b(this, "name", t.name);
        b(this, "description", t.description);
        b(this, "schema", t.schema);
      }
      async _call(s) {
        return e.invokeToolInternal(t, s);
      }
    }());
  }
}
const he = new K1();
class Y1 {
  constructor() {
    b(this, "storageFile");
    b(this, "skills", []);
    this.storageFile = Ie.resolve(process.cwd(), "skill_library.json"), this.load(), this.registerTools();
  }
  async load() {
    var e;
    try {
      const t = await Xe.readFile(this.storageFile, "utf8");
      this.skills = JSON.parse(t);
    } catch {
      try {
        const t = Ie.resolve(process.cwd(), "task_knowledge.json"), n = await Xe.readFile(t, "utf8"), s = JSON.parse(n);
        this.skills = s.map((a) => {
          const i = Date.now();
          return {
            id: Pe(),
            name: a.goal.toLowerCase().replace(/\s+/g, "_").slice(0, 50),
            description: a.goal,
            domain: "unknown",
            steps: a.steps,
            currentVersion: 1,
            stats: { successes: 0, failures: 0, lastUsed: i },
            versions: [{ version: 1, steps: a.steps, createdAt: i }],
            tags: a.trigger_keywords || []
          };
        }), await this.save();
      } catch {
        this.skills = [];
      }
    }
    for (const t of this.skills) {
      const n = Array.isArray(t == null ? void 0 : t.versions) ? t.versions : [];
      if (typeof t.currentVersion != "number") {
        const s = n.length > 0 ? Number(((e = n[n.length - 1]) == null ? void 0 : e.version) ?? n.length) : 1;
        t.currentVersion = s;
      }
      (!t.stats || typeof t.stats != "object") && (t.stats = { successes: 0, failures: 0, lastUsed: Date.now() }), typeof t.stats.successes != "number" && (t.stats.successes = 0), typeof t.stats.failures != "number" && (t.stats.failures = 0), typeof t.stats.partials != "number" && (t.stats.partials = 0), typeof t.stats.lastUsed != "number" && (t.stats.lastUsed = Date.now()), Array.isArray(t.tags) || (t.tags = []), Array.isArray(t.feedback) || (t.feedback = []), (!Array.isArray(t.embedding) || t.embedding.length === 0) && (t.embedding = this.computeEmbedding(this.buildSkillText(t)));
    }
    try {
      await this.save();
    } catch {
    }
  }
  normalizeText(e) {
    return String(e ?? "").toLowerCase().replace(/[^a-z0-9_\-\s/.:]+/g, " ").replace(/\s+/g, " ").trim();
  }
  tokenize(e) {
    const t = this.normalizeText(e);
    return t ? t.split(" ").filter(Boolean).slice(0, 400) : [];
  }
  computeEmbedding(e) {
    const n = new Array(256).fill(0), s = this.tokenize(e);
    for (const i of s) {
      let o = 2166136261;
      for (let u = 0; u < i.length; u++)
        o ^= i.charCodeAt(u), o = Math.imul(o, 16777619);
      const c = Math.abs(o) % 256;
      n[c] += 1;
    }
    let a = 0;
    for (const i of n) a += i * i;
    return a = Math.sqrt(a) || 1, n.map((i) => i / a);
  }
  cosineSimilarity(e, t) {
    if (!e || !t || e.length === 0 || t.length === 0) return 0;
    const n = Math.min(e.length, t.length);
    let s = 0;
    for (let a = 0; a < n; a++) s += e[a] * t[a];
    return s;
  }
  buildSkillText(e) {
    const t = (e.steps || []).map((n) => [n.action, n.url, n.selector, n.value, n.text].filter(Boolean).join(" ")).join(" ");
    return [e.name, e.description, e.domain, e.fingerprint ?? "", ...e.tags || [], t].filter(Boolean).join(" ");
  }
  async save() {
    try {
      await Xe.writeFile(this.storageFile, JSON.stringify(this.skills, null, 2));
    } catch (e) {
      console.error("Failed to save skill library:", e);
    }
  }
  findSkill(e, t, n) {
    const s = e.toLowerCase();
    let a = this.skills;
    t && (a = a.filter(
      (c) => c.domain === t || t.includes(c.domain) || c.domain === "unknown"
    )), n && (a = a.filter((c) => c.fingerprint ? n.includes(c.fingerprint) || c.fingerprint.includes(n) : !0));
    const i = this.computeEmbedding(e), o = a.map((c) => {
      let u = 0;
      c.name.replace(/_/g, " ").includes(s) && (u += 10), c.description.toLowerCase().includes(s) && (u += 5), c.tags.some((y) => s.includes(y.toLowerCase())) && (u += 3);
      const l = c.stats.partials ?? 0, d = c.stats.successes + c.stats.failures + l;
      if (d > 0) {
        const y = (c.stats.successes + 0.5 * l) / d;
        u += y * 2;
      }
      n && c.fingerprint && (n === c.fingerprint ? u += 3 : (n.includes(c.fingerprint) || c.fingerprint.includes(n)) && (u += 1));
      const h = this.cosineSimilarity(c.embedding, i);
      u += h * 10;
      const p = (Array.isArray(c.feedback) ? c.feedback : []).slice(-6);
      for (const y of p)
        y.label === "worked" && (u += 0.6), y.label === "partial" && (u += 0.2), y.label === "failed" && (u -= 0.6);
      return { skill: c, score: u };
    });
    return o.sort((c, u) => u.score - c.score), o.length > 0 && o[0].score > 0 ? o[0].skill : null;
  }
  addSkill(e) {
    const t = this.skills.findIndex(
      (n) => n.name === e.name && n.domain === e.domain
    );
    if (t >= 0) {
      const n = this.skills[t], s = (n.versions.length > 0 ? n.versions[n.versions.length - 1].version : 0) + 1;
      n.versions.push({
        version: s,
        steps: e.steps,
        createdAt: Date.now()
      }), n.steps = e.steps, n.description = e.description, n.domain = e.domain, n.fingerprint = e.fingerprint ?? n.fingerprint, n.currentVersion = s, n.tags = Array.from(/* @__PURE__ */ new Set([...n.tags, ...e.tags])), n.stats.lastUsed = Date.now(), n.stats.successes += 1, n.stats.lastOutcomeAt = Date.now(), n.stats.lastOutcomeSuccess = !0, n.embedding = this.computeEmbedding(this.buildSkillText(n)), this.skills[t] = n;
    } else {
      const n = {
        id: Pe(),
        name: e.name,
        description: e.description,
        domain: e.domain,
        fingerprint: e.fingerprint,
        steps: e.steps,
        currentVersion: 1,
        embedding: this.computeEmbedding(this.buildSkillText({
          id: "tmp",
          name: e.name,
          description: e.description,
          domain: e.domain,
          fingerprint: e.fingerprint,
          steps: e.steps,
          currentVersion: 1,
          stats: { successes: 1, failures: 0, partials: 0, lastUsed: Date.now(), lastOutcomeAt: Date.now(), lastOutcomeSuccess: !0 },
          versions: [{ version: 1, steps: e.steps, createdAt: Date.now() }],
          tags: e.tags
        })),
        stats: { successes: 1, failures: 0, partials: 0, lastUsed: Date.now(), lastOutcomeAt: Date.now(), lastOutcomeSuccess: !0 },
        feedback: [],
        versions: [{ version: 1, steps: e.steps, createdAt: Date.now() }],
        tags: e.tags
      };
      this.skills.push(n);
    }
    this.save();
  }
  recordOutcome(e, t) {
    this.recordFeedback(e, t ? "worked" : "failed");
  }
  recordFeedback(e, t, n) {
    const s = this.skills.find((c) => c.id === e);
    if (!s) return;
    t === "worked" && s.stats.successes++, t === "failed" && s.stats.failures++, t === "partial" && (s.stats.partials = (s.stats.partials ?? 0) + 1), s.stats.lastUsed = Date.now(), s.stats.lastOutcomeAt = Date.now(), s.stats.lastOutcomeSuccess = t === "worked";
    const a = ft.getRunId() ?? void 0, i = ft.getBrowserContext(), o = {
      ts: Date.now(),
      label: t,
      version: n ?? s.currentVersion,
      runId: a,
      domain: i == null ? void 0 : i.domain,
      fingerprint: (() => {
        const c = i == null ? void 0 : i.url;
        if (c)
          try {
            return new URL(c).pathname || void 0;
          } catch {
            return;
          }
      })()
    };
    Array.isArray(s.feedback) || (s.feedback = []), s.feedback.push(o), s.feedback.length > 200 && (s.feedback = s.feedback.slice(-200)), this.save();
  }
  rollbackSkill(e, t) {
    const n = this.skills.find((a) => a.id === e);
    if (!n) return !1;
    const s = n.versions.find((a) => a.version === t);
    return s ? (n.steps = s.steps, n.currentVersion = s.version, n.stats.lastUsed = Date.now(), this.save(), !0) : !1;
  }
  registerTools() {
    const e = ye({
      name: H().describe('Short identifier for the skill (e.g. "create_jira_issue")'),
      description: H().describe("Description of what the skill does"),
      domain: H().optional().describe('Domain where this skill applies (e.g. "localhost:3000")'),
      fingerprint: H().optional().describe('Optional page fingerprint (e.g. "/jira" or "/aerocore/admin")'),
      steps: Vi(
        ye({
          action: rn(["navigate", "click", "type", "select", "wait"]),
          url: H().optional(),
          selector: H().optional(),
          value: H().optional(),
          text: H().optional()
        })
      ),
      tags: Vi(H()).describe("Keywords for retrieval")
    }), t = {
      name: "knowledge_save_skill",
      description: "Save a verified execution plan as a reusable skill.",
      schema: e,
      execute: async (o) => {
        const c = e.parse(o), u = ft.getBrowserContext(), l = c.domain ?? (u == null ? void 0 : u.domain) ?? "unknown", d = (() => {
          if (c.fingerprint) return c.fingerprint;
          const h = u == null ? void 0 : u.url;
          if (h)
            try {
              return new URL(h).pathname || void 0;
            } catch {
              return;
            }
        })();
        return this.addSkill({
          name: c.name,
          description: c.description,
          domain: l,
          fingerprint: d,
          steps: c.steps,
          tags: c.tags
        }), `Saved skill "${c.name}" for domain ${l}.`;
      }
    }, n = {
      name: "knowledge_search_skill",
      description: "Search for a saved skill matching the user request and domain.",
      schema: ye({
        query: H().describe("User request description"),
        domain: H().optional().describe("Current domain context"),
        fingerprint: H().optional().describe("Optional page fingerprint for disambiguation")
      }),
      execute: async (o) => {
        const { query: c, domain: u, fingerprint: l } = o, d = ft.getBrowserContext(), h = u ?? (d == null ? void 0 : d.domain), f = l ?? (() => {
          const y = d == null ? void 0 : d.url;
          if (y)
            try {
              return new URL(y).pathname || void 0;
            } catch {
              return;
            }
        })(), p = this.findSkill(c, h, f);
        return JSON.stringify(p ? {
          found: !0,
          skill: {
            id: p.id,
            name: p.name,
            description: p.description,
            domain: p.domain,
            fingerprint: p.fingerprint,
            currentVersion: p.currentVersion,
            steps: p.steps,
            stats: p.stats
          }
        } : { found: !1 });
      }
    }, s = {
      name: "knowledge_record_outcome",
      description: "Record whether a skill execution succeeded or failed.",
      schema: ye({
        skillId: H(),
        success: Zi().optional(),
        label: rn(["worked", "failed", "partial"]).optional(),
        version: We().optional()
      }),
      execute: async (o) => {
        const { skillId: c, success: u, label: l, version: d } = o, h = l ?? (u === !0 ? "worked" : u === !1 ? "failed" : "worked");
        return this.recordFeedback(c, h, d), `Recorded ${h} for skill ${c}.`;
      }
    }, a = {
      name: "knowledge_rollback_skill",
      description: "Rollback a skill to a previous version.",
      schema: ye({
        skillId: H(),
        version: We().describe("Version number to restore")
      }),
      execute: async (o) => {
        const { skillId: c, version: u } = o;
        return this.rollbackSkill(c, u) ? `Rolled back skill ${c} to version ${u}.` : `Failed to rollback skill ${c} to version ${u}.`;
      }
    }, i = {
      name: "knowledge_list_skills",
      description: "List saved skills for debugging and evaluation.",
      schema: ye({
        domain: H().optional()
      }),
      execute: async (o) => {
        const { domain: c } = o ?? {}, u = ft.getBrowserContext(), l = c ?? (u == null ? void 0 : u.domain), h = (l ? this.skills.filter((f) => f.domain === l || f.domain === "unknown") : this.skills).map((f) => {
          const p = f.stats.successes + f.stats.failures, y = p > 0 ? f.stats.successes / p : null;
          return {
            id: f.id,
            name: f.name,
            domain: f.domain,
            fingerprint: f.fingerprint,
            currentVersion: f.currentVersion,
            successes: f.stats.successes,
            failures: f.stats.failures,
            successRate: y,
            versions: f.versions.map((m) => m.version),
            lastUsed: f.stats.lastUsed,
            tags: f.tags
          };
        }).sort((f, p) => (p.successRate ?? -1) - (f.successRate ?? -1));
        return JSON.stringify({ count: h.length, skills: h }, null, 2);
      }
    };
    he.register(t), he.register(n), he.register(s), he.register(a), he.register(i);
  }
}
const Ga = new Y1();
q1.config();
const Bn = [
  // Fast models
  {
    id: "llama-3.1-70b",
    name: "Llama 3.1 70B (Fast)",
    modelName: "meta/llama-3.1-70b-instruct",
    temperature: 0.1,
    maxTokens: 4096,
    supportsThinking: !1
  },
  {
    id: "llama-3.3-70b",
    name: "Llama 3.3 70B â­ Recommended",
    modelName: "meta/llama-3.3-70b-instruct",
    temperature: 0.1,
    maxTokens: 4096,
    supportsThinking: !1
  },
  {
    id: "qwen3-235b",
    name: "Qwen3 235B (Best Quality)",
    modelName: "qwen/qwen3-235b-a22b",
    temperature: 0.6,
    maxTokens: 4096,
    supportsThinking: !1
  },
  // Thinking models
  {
    id: "deepseek-v3.1",
    name: "DeepSeek V3.1 (Thinking)",
    modelName: "deepseek-ai/deepseek-v3.1-terminus",
    temperature: 0.2,
    maxTokens: 8192,
    supportsThinking: !0,
    extraBody: { chat_template_kwargs: { thinking: !0 } }
  },
  {
    id: "qwen3-80b",
    name: "Qwen3 80B (Thinking)",
    modelName: "qwen/qwen3-next-80b-a3b-thinking",
    temperature: 0.6,
    maxTokens: 4096,
    supportsThinking: !0
  },
  {
    id: "kimi-k2",
    name: "Kimi K2 (Thinking)",
    modelName: "moonshotai/kimi-k2-thinking",
    temperature: 1,
    maxTokens: 16384,
    supportsThinking: !0
  },
  {
    id: "nemotron-nano",
    name: "Nemotron Nano 30B (Thinking)",
    modelName: "nvidia/nemotron-3-nano-30b-a3b",
    temperature: 1,
    maxTokens: 16384,
    supportsThinking: !0,
    extraBody: { chat_template_kwargs: { enable_thinking: !0 } }
  },
  // Specialized models
  {
    id: "actions-policy-v1",
    name: "Actions Policy (Beta)",
    modelName: "custom/actions-policy-v1",
    temperature: 0,
    maxTokens: 2048,
    supportsThinking: !1
  }
], Zs = class Zs {
  constructor() {
    b(this, "model");
    b(this, "currentModelId", "llama-3.1-70b");
    b(this, "useActionsPolicy", !1);
    b(this, "agentMode", "do");
    b(this, "permissionMode", "permissions");
    b(this, "onStep");
    b(this, "conversationHistory", []);
    b(this, "systemPrompt");
    this.model = this.createModel("llama-3.1-70b"), this.systemPrompt = new ct("");
  }
  /**
   * Redact common secrets from text before sending to LLM
   */
  redactSecrets(e) {
    if (!e) return e;
    let t = e;
    const n = [
      // Bearer tokens
      { re: /Bearer\s+[a-zA-Z0-9\-\._]+/gi, repl: "Bearer [REDACTED_TOKEN]" },
      // Authorization header
      { re: /Authorization\s*:\s*Bearer\s+[a-zA-Z0-9\-\._]+/gi, repl: "Authorization: Bearer [REDACTED_TOKEN]" },
      // OpenAI sk- keys
      { re: /sk-[a-zA-Z0-9]{32,}/g, repl: "[REDACTED_OPENAI_KEY]" },
      // GitHub tokens
      { re: /gh[pousr]_[A-Za-z0-9_]{20,}/g, repl: "[REDACTED_GITHUB_TOKEN]" },
      // Slack tokens
      { re: /xox[baprs]-[A-Za-z0-9-]{10,}/g, repl: "[REDACTED_SLACK_TOKEN]" },
      // AWS Access Keys
      { re: /AKIA[0-9A-Z]{16}/g, repl: "[REDACTED_AWS_KEY]" },
      // JWT-like tokens
      { re: /\beyJ[a-zA-Z0-9_-]{10,}\.[a-zA-Z0-9_-]{10,}\.[a-zA-Z0-9_-]{10,}\b/g, repl: "[REDACTED_JWT]" },
      // Generic "password": "..." patterns (loose match)
      { re: /"(password|client_secret|access_token|id_token|refresh_token|api_key|apikey)"\s*:\s*"[^"]+"/gi, repl: '"$1": "[REDACTED]"' },
      // password=... / token=... forms
      { re: /(password|passwd|pwd|token|secret|api[_-]?key)\s*[:=]\s*[^\s\n"']+/gi, repl: "$1=[REDACTED]" },
      // Private Keys
      { re: /-----BEGIN [A-Z]+ PRIVATE KEY-----[\s\S]*?-----END [A-Z]+ PRIVATE KEY-----/g, repl: "[REDACTED_PRIVATE_KEY]" }
    ];
    for (const { re: s, repl: a } of n)
      t = t.replace(s, a);
    return t;
  }
  extractJsonObject(e) {
    const t = e.replace(/```json/g, "").replace(/```/g, "").trim(), n = t.indexOf("{");
    if (n === -1) return null;
    let s = !1, a = !1, i = 0;
    for (let o = n; o < t.length; o++) {
      const c = t[o];
      if (s) {
        a ? a = !1 : c === "\\" ? a = !0 : c === '"' && (s = !1);
        continue;
      }
      if (c === '"') {
        s = !0;
        continue;
      }
      if (c === "{" && i++, c === "}" && i--, i === 0) return t.slice(n, o + 1);
    }
    return null;
  }
  parseToolCall(e) {
    const t = e.replace(/```json/g, "").replace(/```/g, "").trim(), n = this.extractJsonObject(t) ?? (t.startsWith("{") ? t : null);
    if (!n) return null;
    const s = (y) => {
      try {
        return JSON.parse(y);
      } catch {
        return null;
      }
    }, a = s(n);
    if (a) return a;
    const i = n.replace(/,\s*([}\]])/g, "$1"), o = s(i);
    if (o) return o;
    const c = n.replace(/:\s*"([^"]*)\n([^"]*)"/g, ': "$1\\n$2"'), u = s(c);
    if (u) return u;
    const l = n.replace(/'/g, '"'), d = s(l);
    if (d) return d;
    const h = t.match(/"tool"\s*:\s*"([^"]+)"/);
    if (!h) return null;
    const f = h[1];
    if (f === "final_response") {
      const y = [
        /"message"\s*:\s*"([\s\S]*?)"\s*(?:,|\})/,
        /"message"\s*:\s*"([^"]*)"/,
        /"message"\s*:\s*'([^']*)'/
      ];
      for (const m of y) {
        const v = t.match(m);
        if (v)
          return { tool: f, args: { message: v[1] } };
      }
      return { tool: f, args: { message: "" } };
    }
    const p = t.match(/"args"\s*:\s*(\{[^}]+\})/);
    if (p) {
      const y = p[1], m = s(y);
      if (m) return { tool: f, args: m };
    }
    return null;
  }
  /**
   * Toggle the use of the specialized actions policy model
   */
  toggleActionsPolicy(e) {
    this.useActionsPolicy = e, e ? this.setModel("actions-policy-v1") : this.setModel("llama-3.1-70b"), console.log(`[AgentService] Actions Policy Model: ${e ? "ENABLED" : "DISABLED"}`);
  }
  isActionsPolicyEnabled() {
    return this.useActionsPolicy;
  }
  /**
   * Set the agent mode (chat/read/do)
   */
  setAgentMode(e) {
    this.agentMode = e, console.log(`[AgentService] Agent Mode: ${e}`);
  }
  getAgentMode() {
    return this.agentMode;
  }
  /**
   * Set the permission mode (yolo/permissions) - only applies in 'do' mode
   */
  setPermissionMode(e) {
    this.permissionMode = e, console.log(`[AgentService] Permission Mode: ${e}`);
  }
  getPermissionMode() {
    return this.permissionMode;
  }
  /**
   * Check if YOLO mode is active (do mode + yolo permissions)
   */
  isYoloMode() {
    return this.agentMode === "do" && this.permissionMode === "yolo";
  }
  /**
   * Create a model instance from config
   */
  createModel(e) {
    const t = process.env.NVIDIA_API_KEY;
    t || console.warn("NVIDIA_API_KEY is not set in environment variables");
    const n = Bn.find((a) => a.id === e) || Bn[0];
    console.log(`[AgentService] Creating model: ${n.name} (${n.modelName})`);
    const s = {
      response_format: { type: "json_object" },
      ...n.extraBody
    };
    return new p1({
      configuration: {
        baseURL: "https://integrate.api.nvidia.com/v1",
        apiKey: t
      },
      modelName: n.modelName,
      temperature: n.temperature,
      maxTokens: n.maxTokens,
      streaming: !1,
      modelKwargs: s
    });
  }
  /**
   * Switch to a different model
   */
  setModel(e) {
    const t = Bn.find((n) => n.id === e);
    if (!t) {
      console.error(`[AgentService] Unknown model: ${e}`);
      return;
    }
    this.currentModelId = e, this.model = this.createModel(e), console.log(`[AgentService] Switched to model: ${t.name}`);
  }
  /**
   * Get current model ID
   */
  getCurrentModelId() {
    return this.currentModelId;
  }
  /**
   * Get available models
   */
  static getAvailableModels() {
    return Bn;
  }
  /**
   * Reset conversation history - call this when starting a new session
   */
  resetConversation() {
    this.conversationHistory = [], console.log("[AgentService] Conversation history cleared");
  }
  /**
   * Trim conversation history if it exceeds the max limit
   * Keeps the most recent messages
   */
  trimConversationHistory() {
    if (this.conversationHistory.length > Zs.MAX_HISTORY_MESSAGES) {
      const e = this.conversationHistory.length - Zs.MAX_HISTORY_MESSAGES;
      this.conversationHistory = this.conversationHistory.slice(e), console.log(`[AgentService] Trimmed ${e} old messages from conversation history`);
    }
  }
  setStepHandler(e) {
    this.onStep = e;
  }
  clearStepHandler() {
    this.onStep = void 0;
  }
  emitStep(e, t, n) {
    if (this.onStep) {
      const s = ft.getRunId() ?? void 0, a = {
        ...n ?? {},
        ts: (/* @__PURE__ */ new Date()).toISOString(),
        runId: s
      };
      this.onStep({ type: e, content: t, metadata: a });
    }
  }
  async chat(e, t) {
    return this.agentMode === "chat" ? this.chatOnly(e) : this.agentMode === "read" ? this.readOnly(e, t) : this.doMode(e, t);
  }
  /**
   * Chat-only mode: Regular chatbot, no browser access or tools
   */
  async chatOnly(e) {
    const t = this.redactSecrets(e), n = new ct("You are a helpful assistant. You are in CHAT mode - you cannot access the browser or use any tools. Just have a helpful conversation with the user. Respond naturally without JSON formatting.");
    this.conversationHistory.push(new zt(t)), this.trimConversationHistory();
    try {
      const s = await this.model.invoke([n, ...this.conversationHistory]), a = typeof s.content == "string" ? s.content : JSON.stringify(s.content);
      return this.conversationHistory.push(new Fe(a)), this.trimConversationHistory(), a;
    } catch (s) {
      return `Error: ${s.message}`;
    }
  }
  /**
   * Read-only mode: Can see browser state but cannot take actions
   */
  async readOnly(e, t) {
    const n = this.redactSecrets(e);
    let s = t || "Current browser state: No context provided";
    s = this.redactSecrets(s);
    const a = new ct(`You are a helpful assistant integrated into a browser. You are in READ mode - you can see what the user sees on their browser, but you CANNOT take any actions or use any tools.

Current browser state:
${s}

You can answer questions about what's on the page, explain content, summarize information, or help the user understand what they're looking at. But you cannot click, type, navigate, or modify anything. Respond naturally without JSON formatting.`);
    this.conversationHistory.push(new zt(n)), this.trimConversationHistory();
    try {
      const i = await this.model.invoke([a, ...this.conversationHistory]), o = typeof i.content == "string" ? i.content : JSON.stringify(i.content);
      return this.conversationHistory.push(new Fe(o)), this.trimConversationHistory(), o;
    } catch (i) {
      return `Error: ${i.message}`;
    }
  }
  /**
   * Do mode: Full agentic capabilities with tools
   */
  async doMode(e, t) {
    var o;
    const n = he.toLangChainTools();
    let s = !1, a = 0, i = null;
    try {
      let c = t || "Current browser state: No context provided";
      c = this.redactSecrets(c);
      const u = this.redactSecrets(e);
      this.systemPrompt = new ct(`You are a helpful enterprise assistant integrated into a browser. 
        
        You have access to the following tools:
        ${n.map((y) => {
        var m;
        return `- ${y.name}: ${y.description} (Args: ${JSON.stringify(((m = y.schema) == null ? void 0 : m.shape) || {})})`;
      }).join(`
`)}

        CRITICAL INSTRUCTIONS:
        1. You are an agent that MUST use tools to interact with the world.
        2. To call a tool, you MUST output a VALID JSON object in the following format:
           {
             "tool": "tool_name",
             "args": { "arg_name": "value" }
           }
        3. Do not output any other text when calling a tool. Just the JSON.
        4. If you have completed the task or need to ask the user something, output a JSON with tool "final_response":
           {
             "tool": "final_response",
             "args": { "message": "Your text here" }
           }

        API-FIRST STRATEGY (CRITICAL FOR SPEED):
        For data retrieval from common websites, ALWAYS try API tools first:
        - GitHub search/stars â†’ use "api_github_search" (returns repos with star counts instantly)
        - Hacker News top stories â†’ use "api_hackernews_top"
        - Wikipedia featured article â†’ use "api_wikipedia_featured"
        - Cryptocurrency prices (Bitcoin, Ethereum, etc.) â†’ use "api_crypto_price" (instead of coinmarketcap.com)
        - Any JSON API â†’ use "api_http_get"
        
        APIs are 10-100x faster than browser automation. Only fall back to browser if:
        1. The API fails or is rate-limited
        2. The task requires interaction (clicking, form filling)
        3. No API exists for the data you need

        IMPORTANT: If the user says "go to" or "click" or "navigate", they want to SEE the page in the browser.
        In this case, use the API to get the data quickly, then ALSO navigate the browser to show them the result.
        
        CRITICAL - NO HALLUCINATION RULE:
        - NEVER claim you have done something you haven't actually done.
        - If the user asks you to "go to Google and search", you MUST call browser_navigate BEFORE saying you did it.
        - Do NOT say "I have navigated to X" unless you actually called browser_navigate and got a success response.
        - If a task has multiple steps (e.g., "get price THEN search Google"), you must complete ALL steps with actual tool calls.
        
        Example: Multi-Step Task (Bitcoin price + Google search)
        User: "Find the Bitcoin price, then go to Google and search for Bitcoin news"
        Assistant: { "tool": "api_crypto_price", "args": { "coin": "bitcoin" } }
        User: Tool Output: { "price_usd": 86077 }
        Assistant: { "tool": "browser_navigate", "args": { "url": "https://www.google.com/search?q=Bitcoin+news+today" } }
        User: Tool Output: "Navigated to https://www.google.com/search?q=Bitcoin+news+today"
        Assistant: { "tool": "final_response", "args": { "message": "Bitcoin is currently $86,077. I've navigated to Google search results for 'Bitcoin news today'." } }

        Example: GitHub with Navigation
        User: "Go to GitHub, search for langchain, click the first repo, tell me the stars"
        Assistant: { "tool": "api_github_search", "args": { "query": "langchain", "sort": "stars", "limit": 1 } }
        User: Tool Output: { "results": [{ "name": "langchain-ai/langchain", "stars": 122107, "url": "https://github.com/langchain-ai/langchain" }] }
        Assistant: { "tool": "browser_navigate", "args": { "url": "https://github.com/langchain-ai/langchain" } }
        User: Tool Output: "Navigated to https://github.com/langchain-ai/langchain"
        Assistant: { "tool": "final_response", "args": { "message": "langchain-ai/langchain has 122,107 stars on GitHub." } }

        Example: Pure Data Query (no navigation needed)
        User: "How many stars does langchain have on GitHub?"
        Assistant: { "tool": "api_github_search", "args": { "query": "langchain", "sort": "stars", "limit": 1 } }
        User: Tool Output: { "results": [{ "name": "langchain-ai/langchain", "stars": 122107 }] }
        Assistant: { "tool": "final_response", "args": { "message": "langchain-ai/langchain has 122,107 stars." } }
        
        PREFERRED WORKFLOW (SPEED & RELIABILITY):
        1. API FIRST: Check if an api_* tool can answer the question directly.
        2. OBSERVE: If browser is needed and page state is unknown, call 'browser_observe'.
        3. PLAN: For multi-step tasks (especially Mock SaaS), ALWAYS output ONE full 'browser_execute_plan' (include a final wait step for verification). This is significantly faster and more reliable than individual tool calls.
        4. EXECUTE: Submit the plan once. Avoid calling browser_click/browser_type in separate turns for multi-step tasks.
        
        FAIL FAST ON BROWSER ERRORS:
        - If a selector times out ONCE, do NOT retry with the same selector.
        - Switch strategies immediately: try a different selector, use browser_click_text, or use direct URL navigation.
        - If browser_observe fails, use browser_extract_main_text or browser_find_text instead.
        - Maximum 2 retries for any single action before switching approach.

        CONVERSATION CONTEXT:
        - You have memory of the entire conversation. Use previous messages to understand context.
        - If the user refers to "it", "this page", "here", etc., use the conversation history and current browser state to understand what they mean.
        - ${c}

        JSON SAFETY:
        - Tool JSON must be valid JSON. If you include a CSS selector string, it MUST NOT contain unescaped double quotes (").
        - Prefer selectors returned by browser_observe like [data-testid=jira-create-button] that do not require quotes.
        - In final_response.message, do not include unescaped double quotes ("). If you need quotes, use single quotes inside the message, e.g. 'fix alignment'.

        VERIFICATION RULE (IMPORTANT):
        - Verify ONCE. Do not verify multiple times.
        - If you included a "wait" step in your execution plan and it passed, THAT IS YOUR VERIFICATION. You do not need to verify again.
        - If you must verify manually, use "browser_wait_for_text".
        - DO NOT guess container selectors (e.g. do not invent [data-testid=jira-issue-list]). Only use selectors you saw in "browser_observe" or the source code.
        
        WHITE-BOX MOCK SaaS MODE (mock-saas):
        - When the task targets the local Mock SaaS (e.g. URLs like http://localhost:3000/* or apps like Jira/Confluence/Trello/AeroCore in this repo), you MUST operate in this order:

        PHASE 0: RECALL (Check Memory)
        - Call "knowledge_search_skill" with the user's request and current domain.
        - If a skill is found, verify it briefly, then execute it using "browser_execute_plan".

        PHASE 1: PLAN (Read Code) - if no skill found
        - DO NOT touch the browser yet.
        - Use "code_search" or "code_list_files" to find the relevant React components.
        - Read "mock-saas/src/App.tsx" to find the correct route.
        - NOTE: AeroCore apps are under "/aerocore/*" (e.g. /aerocore/admin, /aerocore/dispatch).
        - Read the page/component source code (e.g. "JiraPage.tsx" or "AdminPage.tsx") to find:
          * Stable "data-testid" selectors.
          * WARNING: If a selector is inside a loop (e.g. [data-testid=jira-create-issue-button] inside columns), IT IS NOT UNIQUE. browser_click will refuse ambiguous matches. Prefer browser_click_text or disambiguate via withinSelector/matchText/index.
          * Validation logic (e.g. allowed values for priority).
          
        PHASE 2: EXECUTE (Run Plan)
        - Call "browser_execute_plan" with the full sequence.
        - Include a "wait" step at the end of your plan to verify the outcome automatically (e.g. wait for the text you just created).
        - Example plan:
          [
            { "action": "navigate", "url": "http://localhost:3000/jira" },
            { "action": "click", "selector": "[data-testid=jira-create-button]" },
            { "action": "type", "selector": "[data-testid=jira-summary-input]", "value": "Bug Report" },
            { "action": "select", "selector": "[data-testid=jira-status-select]", "value": "To Do" },
            { "action": "click", "selector": "[data-testid=jira-submit-create]" },
            { "action": "wait", "text": "Bug Report" }
          ]

        PHASE 3: LEARN (Save Memory)
        - If the execution (and its built-in wait) succeeded, call "knowledge_save_skill" IMMEDIATELY.
        - Then IMMEDIATELY send "final_response". Do not perform extra verifications.
        
        BROWSER AUTOMATION STRATEGY:
        - You have no eyes. You must use "browser_observe" to see the page.
        - For EXTERNAL WEBSITES (not localhost): Use the current browser state above. If you're already on a site (e.g. youtube.com), interact with it directly using browser_type, browser_click, browser_observe. Do NOT navigate away unless asked.
        - Step 1: Check current browser state. If already on the target site, skip navigation.
        - Step 2: Use "browser_observe" with scope="main" to see relevant page content.
        - Step 3: Prefer "browser_click_text" when you can describe a link/button by visible text (more robust than guessing aria-label/href).
        - Step 4: Use selectors returned by "browser_observe" (which are JSON-safe) for "browser_click", "browser_type", "browser_select". If browser_click says the selector is ambiguous, disambiguate via withinSelector/matchText/index or switch to browser_click_text.
        - Step 5: Verify outcomes using "browser_wait_for_text", "browser_wait_for_text_in", or "browser_extract_main_text".

        INFORMATION EXTRACTION (CRITICAL):
        - If the user asks you to "tell me", "find", "what is", "show me", "get", "read", or asks a question about page content, you MUST:
          1. Navigate to the page (if not already there)
          2. Call "browser_observe" to see the page content
          3. Read the "mainTextSnippet" from the observation result
          4. Extract the requested information from the text
          5. Return the answer in your final_response
        - DO NOT stop after just navigating. The user wants INFORMATION, not just navigation.
        - The "mainTextSnippet" in browser_observe output contains the visible text on the page - use it to answer questions.

        Example: Information Extraction
        User: "Go to wikipedia.org and tell me the featured article of the day"
        Assistant: { "tool": "browser_navigate", "args": { "url": "https://www.wikipedia.org" } }
        User: Tool Output: "Navigated to https://www.wikipedia.org"
        Assistant: { "tool": "browser_observe", "args": { "scope": "main" } }
        User: Tool Output: { "mainTextSnippet": "...Featured article: The Battle of...", ... }
        Assistant: { "tool": "final_response", "args": { "message": "The featured article of the day on Wikipedia is 'The Battle of...'" } }

        Example: Simple Navigation
        User: "Go to Jira"
        Assistant: { "tool": "browser_navigate", "args": { "url": "http://localhost:3000/jira" } }
        User: Tool Output: "Navigated to..."
        Assistant: { "tool": "browser_observe", "args": { "scope": "main" } }
        User: Tool Output: { "interactiveElements": [...] }
        Assistant: { "tool": "final_response", "args": { "message": "I have navigated to Jira." } }
        `);
      const l = new zt(`[${c}]

User request: ${u}`);
      this.conversationHistory.push(l), this.trimConversationHistory();
      const d = [
        this.systemPrompt,
        ...this.conversationHistory
      ], h = Bn.find((y) => y.id === this.currentModelId), p = (h == null ? void 0 : h.supportsThinking) || (h == null ? void 0 : h.id) === "qwen3-235b" ? 9e4 : 45e3;
      for (let y = 0; y < 15; y++) {
        const m = ft.getRunId() ?? void 0, v = Pe(), g = Date.now();
        this.emitStep("thought", `Calling model ${this.currentModelId} (turn ${y + 1})`, {
          phase: "llm_start",
          llmCallId: v,
          turnIndex: y,
          modelId: this.currentModelId
        });
        try {
          await tt.emit({
            eventId: Pe(),
            runId: m,
            ts: (/* @__PURE__ */ new Date()).toISOString(),
            type: "llm_call_start",
            name: "agent_turn",
            data: {
              llmCallId: v,
              turnIndex: y,
              modelId: this.currentModelId,
              modelName: h == null ? void 0 : h.modelName,
              timeoutMs: p
            }
          });
        } catch {
        }
        const w = new Promise(
          (z, Te) => setTimeout(() => Te(new Error(`LLM call timed out after ${p / 1e3} seconds`)), p)
        );
        let T, x = null, O = 0;
        try {
          x = setInterval(() => {
            O += 1;
            const z = Date.now() - g;
            O <= 6 && this.emitStep("thought", `Still thinking... (${Math.round(z / 1e3)}s)`, {
              phase: "llm_wait",
              llmCallId: v,
              turnIndex: y,
              modelId: this.currentModelId,
              elapsedMs: z
            });
          }, 5e3), T = await Promise.race([
            this.model.invoke(d),
            w
          ]);
        } catch (z) {
          x && clearInterval(x);
          const Te = Date.now() - g;
          this.emitStep("observation", `LLM timed out after ${Math.round(Te)}ms`, {
            phase: "llm_end",
            ok: !1,
            llmCallId: v,
            turnIndex: y,
            modelId: this.currentModelId,
            durationMs: Te,
            errorMessage: String((z == null ? void 0 : z.message) ?? z)
          });
          try {
            await tt.emit({
              eventId: Pe(),
              runId: m,
              ts: (/* @__PURE__ */ new Date()).toISOString(),
              type: "llm_call_end",
              name: "agent_turn",
              data: {
                llmCallId: v,
                turnIndex: y,
                ok: !1,
                durationMs: Te,
                errorMessage: String((z == null ? void 0 : z.message) ?? z)
              }
            });
          } catch {
          }
          return this.emitStep("observation", "Request timed out. Try a simpler request or switch to a faster model."), "The request timed out. Try breaking it into smaller steps or use a faster model.";
        }
        x && clearInterval(x);
        try {
          const z = Date.now() - g;
          this.emitStep("thought", `Model responded in ${Math.round(z)}ms`, {
            phase: "llm_end",
            ok: !0,
            llmCallId: v,
            turnIndex: y,
            modelId: this.currentModelId,
            durationMs: z
          }), await tt.emit({
            eventId: Pe(),
            runId: m,
            ts: (/* @__PURE__ */ new Date()).toISOString(),
            type: "llm_call_end",
            name: "agent_turn",
            data: {
              llmCallId: v,
              turnIndex: y,
              ok: !0,
              durationMs: z,
              responseLength: String((T == null ? void 0 : T.content) ?? "").length
            }
          });
        } catch {
        }
        const R = T.content;
        console.log(`[Agent Turn ${y}] Raw Response:`, this.redactSecrets(R));
        const E = R.indexOf("{");
        if (E > 10) {
          const Te = R.slice(0, E).trim().replace(/```json/g, "").replace(/```/g, "").trim();
          Te.length > 5 && this.emitStep("thought", Te);
        }
        const V = this.parseToolCall(R);
        if (V && V.tool, !V || typeof V.tool != "string" || !V.args || typeof V.args != "object") {
          if (a++, this.emitStep("observation", `Model returned invalid JSON (attempt ${a}/3).`), console.warn("Failed to parse JSON response:", R), d.push(new Fe(this.redactSecrets(String((T == null ? void 0 : T.content) ?? "")))), d.push(
            new ct(
              `Error: Output ONLY valid JSON. Format: {"tool":"tool_name","args":{...}}
To finish: {"tool":"final_response","args":{"message":"your response"}}`
            )
          ), i && a >= 2)
            return `Done: ${i}`;
          if (a >= 3)
            return "I had trouble completing this task. Try a simpler request or switch to a thinking model (DeepSeek, Qwen).";
          continue;
        }
        if (V.tool !== "final_response" && this.emitStep("thought", `Decided to call ${V.tool}`), V.tool === "final_response") {
          const z = V.args, Te = typeof (z == null ? void 0 : z.message) == "string" ? z.message : "";
          if (!Te) {
            d.push(T), d.push(
              new ct(
                'Error: final_response must include args.message as a string. Example: {"tool":"final_response","args":{"message":"..."}}'
              )
            );
            continue;
          }
          if (s) {
            const Oe = d.slice(-8).map((U) => U.content ?? "").join(`
`), Z = /\b(created|created a|successfully|done|completed)\b/i.test(Te), D = /\bFound text:\b|\b\"found\":\s*[1-9]\d*\b/i.test(Oe) || /\bSaved plan for\b/i.test(Oe);
            if (Z && !D) {
              d.push(T), d.push(
                new ct(
                  "You must verify UI changes before claiming success. Use browser_wait_for_text or browser_find_text for the expected item title, then respond."
                )
              );
              continue;
            }
          }
          return this.conversationHistory.push(new Fe(this.redactSecrets(R))), Te;
        }
        const ne = n.find((z) => z.name === V.tool);
        if (ne) {
          console.log(`Executing tool: ${ne.name} with args:`, V.args);
          const z = Pe(), Te = Date.now();
          this.emitStep("action", `Executing ${ne.name}`, {
            tool: ne.name,
            args: V.args,
            toolCallId: z,
            phase: "tool_start"
          });
          try {
            const Oe = await ne.invoke(V.args), Z = Date.now() - Te;
            this.emitStep("observation", `Tool Output: ${Oe}`, {
              tool: ne.name,
              result: Oe,
              toolCallId: z,
              phase: "tool_end",
              durationMs: Z
            }), ne.name.startsWith("browser_") && (s = !0), (ne.name === "browser_wait_for_text" || ne.name === "browser_wait_for_text_in") && typeof Oe == "string" && Oe.startsWith("Found text") && (i = Oe);
            const D = String(Oe), U = V.tool;
            if (U === "browser_execute_plan" && D.startsWith("Plan completed successfully.")) {
              const M = "Completed the requested steps and verified the outcome.";
              return this.conversationHistory.push(
                new Fe(
                  JSON.stringify({ tool: "final_response", args: { message: M } })
                )
              ), M;
            }
            if (U === "browser_scroll" && !D.toLowerCase().includes("error")) {
              const M = "Scrolled the page.";
              return this.conversationHistory.push(new Fe(JSON.stringify({ tool: "final_response", args: { message: M } }))), M;
            }
            if (U === "browser_go_back" && !D.toLowerCase().includes("error")) {
              const M = "Went back to the previous page.";
              return this.conversationHistory.push(new Fe(JSON.stringify({ tool: "final_response", args: { message: M } }))), M;
            }
            if (U === "browser_go_forward" && !D.toLowerCase().includes("error")) {
              const M = "Went forward to the next page.";
              return this.conversationHistory.push(new Fe(JSON.stringify({ tool: "final_response", args: { message: M } }))), M;
            }
            if (U === "browser_reload" && !D.toLowerCase().includes("error")) {
              const M = "Reloaded the page.";
              return this.conversationHistory.push(new Fe(JSON.stringify({ tool: "final_response", args: { message: M } }))), M;
            }
            if (U === "browser_press_key" && !D.toLowerCase().includes("error")) {
              const q = `Pressed ${((o = V.args) == null ? void 0 : o.key) || "the key"}.`;
              return this.conversationHistory.push(new Fe(JSON.stringify({ tool: "final_response", args: { message: q } }))), q;
            }
            if (U === "browser_clear" && !D.toLowerCase().includes("error")) {
              const M = "Cleared the input field.";
              return this.conversationHistory.push(new Fe(JSON.stringify({ tool: "final_response", args: { message: M } }))), M;
            }
            const A = this.redactSecrets(R), P = this.redactSecrets(String(Oe ?? "")), N = new Fe(A), j = new ct(`Tool '${V.tool}' Output:
${P}`);
            d.push(N), d.push(j), this.conversationHistory.push(N), this.conversationHistory.push(j);
          } catch (Oe) {
            console.error(`Tool execution failed: ${Oe}`);
            const Z = Date.now() - Te;
            this.emitStep("observation", `Tool Execution Error: ${Oe.message}`, {
              tool: ne.name,
              toolCallId: z,
              phase: "tool_end",
              ok: !1,
              durationMs: Z,
              errorMessage: String((Oe == null ? void 0 : Oe.message) ?? Oe)
            });
            const D = new Fe(this.redactSecrets(R)), U = new ct(`Tool Execution Error: ${Oe.message}`);
            d.push(D), d.push(U), this.conversationHistory.push(D), this.conversationHistory.push(U);
          }
        } else {
          console.error(`Tool not found: ${V.tool}`);
          const z = new Fe(R), Te = new ct(`Error: Tool '${V.tool}' not found. Available tools: ${n.map((Oe) => Oe.name).join(", ")}`);
          d.push(z), d.push(Te), this.conversationHistory.push(z), this.conversationHistory.push(Te);
        }
      }
      return "I could not complete the task within the maximum number of steps. Try simplifying the request or check the browser is in the expected state.";
    } catch (c) {
      return console.error("Error in AgentService chat:", c), "Sorry, I encountered an error while processing your request.";
    }
  }
  // Future: Implement streaming support
  async *streamChat(e) {
    const t = await this.model.stream([
      new ct("You are a helpful enterprise assistant integrated into a browser."),
      new zt(e)
    ]);
    for await (const n of t)
      yield n.content;
  }
};
// Limit conversation history to prevent unbounded memory growth
// Each turn can have ~2-4 messages (user, AI, tool output, etc.)
// 50 messages â‰ˆ 12-25 turns of context
b(Zs, "MAX_HISTORY_MESSAGES", 50);
let Tu = Zs;
const Ot = new Tu();
class X1 {
  constructor() {
    b(this, "tabIdToWebContentsId", /* @__PURE__ */ new Map());
    b(this, "activeTabId", null);
  }
  registerWebview(e, t) {
    !e || !Number.isFinite(t) || this.tabIdToWebContentsId.set(e, {
      tabId: e,
      webContentsId: t,
      lastSeenAt: Date.now()
    });
  }
  setActiveTab(e) {
    this.activeTabId = e;
  }
  getActiveWebContents() {
    const e = this.activeTabId;
    if (e) {
      const s = this.tabIdToWebContentsId.get(e);
      if (s) {
        const a = Vs.fromId(s.webContentsId);
        if (a && !a.isDestroyed()) return a;
      }
    }
    const n = Vs.getAllWebContents().filter((s) => !s.isDestroyed()).filter((s) => s.getType() === "webview").filter((s) => {
      const a = s.getURL() || "";
      return !a.startsWith("devtools://") && !a.includes("localhost:5173") && !a.includes("localhost:5174") && !a.endsWith("index.html");
    });
    if (n.length === 0)
      throw new Error(
        "No active webview found. Open a tab and ensure the BrowserView is loaded."
      );
    return n[n.length - 1];
  }
}
const Ns = new X1();
class Q1 {
  constructor() {
    b(this, "mockSaasRoutesCache", null);
    b(this, "observeCache", /* @__PURE__ */ new Map());
    b(this, "attachedWebContentsIds", /* @__PURE__ */ new Set());
    this.setupWebContentsInvalidation(), this.registerTools();
  }
  setupWebContentsInvalidation() {
    try {
      for (const e of Vs.getAllWebContents())
        this.attachWebContentsListeners(e);
    } catch {
    }
    try {
      Bt.on("web-contents-created", (e, t) => {
        this.attachWebContentsListeners(t);
      });
    } catch {
    }
  }
  attachWebContentsListeners(e) {
    try {
      if (!e || e.isDestroyed() || this.attachedWebContentsIds.has(e.id)) return;
      this.attachedWebContentsIds.add(e.id);
      const t = () => this.invalidateCache(e.id);
      e.on("did-start-navigation", t), e.on("did-navigate", t), e.on("did-navigate-in-page", t), e.on("dom-ready", t), e.on("destroyed", () => {
        this.invalidateCache(e.id), this.attachedWebContentsIds.delete(e.id);
      });
    } catch {
    }
  }
  invalidateCache(e) {
    this.observeCache.delete(e);
  }
  async getDomVersion(e) {
    try {
      const t = await e.executeJavaScript(
        `(() => {
          const w = window;
          if (typeof w.__enterprise_observe_dom_version !== 'number') {
            w.__enterprise_observe_dom_version = 0;
          }
          if (!w.__enterprise_observe_dom_observer) {
            const bump = () => { w.__enterprise_observe_dom_version += 1; };
            const obs = new MutationObserver(() => bump());
            const root = document.documentElement || document.body;
            if (root) {
              obs.observe(root, { subtree: true, childList: true, attributes: true, characterData: true });
            }
            w.__enterprise_observe_dom_observer = obs;
          }
          return w.__enterprise_observe_dom_version;
        })()`,
        !0
      );
      return Number(t) || 0;
    } catch {
      return 0;
    }
  }
  async delay(e) {
    await new Promise((t) => setTimeout(t, e));
  }
  async getMockSaasRoutes() {
    const e = Date.now();
    if (this.mockSaasRoutesCache && e - this.mockSaasRoutesCache.loadedAt < 1e4)
      return this.mockSaasRoutesCache.routes;
    const t = /* @__PURE__ */ new Set(["/", "/jira", "/confluence", "/trello"]), n = [
      Ie.resolve(process.cwd(), "mock-saas", "src", "App.tsx"),
      Ie.resolve(process.cwd(), "..", "mock-saas", "src", "App.tsx"),
      Ie.resolve(process.cwd(), "..", "..", "mock-saas", "src", "App.tsx")
    ];
    let s = null;
    for (const a of n)
      try {
        if ((await Xe.stat(a)).isFile()) {
          s = a;
          break;
        }
      } catch {
      }
    if (!s)
      return this.mockSaasRoutesCache = { loadedAt: e, routes: t }, t;
    try {
      const a = await Xe.readFile(s, "utf8"), i = /* @__PURE__ */ new Set(), o = /<Route\s+(?:path|element)\s*=\s*["']([^"']+)["']/g;
      let c;
      for (; c = o.exec(a); ) {
        let l = c[1];
        l.endsWith("/*") && (l = l.replace("/*", ""), l === "/aerocore" && (i.add("/aerocore/admin"), i.add("/aerocore/dispatch"), i.add("/aerocore/fleet"), i.add("/aerocore/security"), i.add("/aerocore/hr"), i.add("/aerocore/cargo"), i.add("/aerocore/data"))), i.add(l);
      }
      const u = i.size > 0 ? i : t;
      return this.mockSaasRoutesCache = { loadedAt: e, routes: u }, u;
    } catch {
      return this.mockSaasRoutesCache = { loadedAt: e, routes: t }, t;
    }
  }
  async getTarget() {
    return Ns.getActiveWebContents();
  }
  async waitForSelector(e, t, n = 5e3) {
    const s = Date.now();
    for (; Date.now() - s < n; ) {
      if (await e.executeJavaScript(
        `Boolean(document.querySelector(${JSON.stringify(t)}))`,
        !0
      )) return;
      await this.delay(100);
    }
    throw new Error(`Timeout waiting for selector: ${t}`);
  }
  async querySelectorCount(e, t) {
    const n = await e.executeJavaScript(
      `document.querySelectorAll(${JSON.stringify(t)}).length`,
      !0
    );
    return Number(n) || 0;
  }
  registerTools() {
    const e = ye({
      scope: rn(["main", "document"]).optional().describe("Where to look for elements (default: main)"),
      maxElements: We().optional().describe("Max interactive elements to return (default: 80)"),
      forceRefresh: Zi().optional().describe("Ignore cache and force a fresh observation")
    }), t = {
      name: "browser_observe",
      description: "Analyze the current page URL/title and return visible interactive elements. Defaults to main content to avoid header/nav noise. Caches results for performance; use forceRefresh to bypass.",
      schema: e,
      execute: async (A) => {
        const { scope: P, maxElements: N, forceRefresh: j } = e.parse(A ?? {});
        try {
          const M = await this.getTarget(), q = M.id, se = M.getURL(), Ee = JSON.stringify({ scope: P ?? "main", maxElements: N ?? 80 }), ae = await this.getDomVersion(M);
          if (!j) {
            const ge = this.observeCache.get(q);
            if (ge && ge.url === se && ge.argsKey === Ee && ge.domVersion === ae && Date.now() - ge.timestamp < 5e3) {
              const Me = Date.now() - ge.timestamp;
              return JSON.stringify(
                {
                  ...ge.data,
                  _meta: {
                    cached: !0,
                    timestamp: ge.timestamp,
                    ageMs: Me,
                    url: ge.url,
                    title: ge.title,
                    domVersion: ge.domVersion,
                    args: { scope: P ?? "main", maxElements: N ?? 80 }
                  }
                },
                null,
                2
              );
            }
          }
          const S = se, _ = await M.executeJavaScript("document.title", !0), $ = await M.executeJavaScript(
            `(() => {
                const escapeForSingleQuotes = (value) => {
                  if (typeof value !== 'string') return '';
                  return value.replace(/\\\\/g, '\\\\\\\\').replace(/'/g, "\\\\'");
                };

                const attrSelectorValue = (value) => {
                  if (typeof value !== 'string') return "''";
                  // If value is simple, avoid quotes entirely (JSON-safe and CSS-valid).
                  if (/^[a-zA-Z0-9_-]+$/.test(value)) return value;
                  return "'" + escapeForSingleQuotes(value) + "'";
                };

                const isVisible = (el) => {
                  if (!el || el.nodeType !== 1) return false;
                  const style = window.getComputedStyle(el);
                  if (!style) return false;
                  if (style.display === 'none' || style.visibility === 'hidden' || style.opacity === '0') return false;
                  if (style.pointerEvents === 'none') return false;
                  const rects = el.getClientRects();
                  if (!rects || rects.length === 0) return false;
                  const rect = el.getBoundingClientRect();
                  if (rect.width < 2 || rect.height < 2) return false;
                  // Prefer in-viewport elements (allow small offscreen buffer)
                  const vw = window.innerWidth || 0;
                  const vh = window.innerHeight || 0;
                  const buffer = 40;
                  if (rect.bottom < -buffer || rect.top > vh + buffer) return false;
                  if (rect.right < -buffer || rect.left > vw + buffer) return false;
                  return true;
                };

                const cssPath = (el) => {
                  if (!el || el.nodeType !== 1) return '';
                  const parts = [];
                  let cur = el;
                  let guard = 0;
                  while (cur && cur.nodeType === 1 && guard++ < 7) {
                    const tag = cur.tagName.toLowerCase();
                    if (cur.id) {
                      parts.unshift(tag + '#' + CSS.escape(cur.id));
                      break;
                    }

                    let part = tag;
                    const testId =
                      cur.getAttribute &&
                      (cur.getAttribute('data-testid') || cur.getAttribute('data-test-id'));
                    if (testId) {
                      part += '[data-testid=' + attrSelectorValue(testId) + ']';
                      parts.unshift(part);
                      break;
                    }

                    const classList = cur.classList ? Array.from(cur.classList) : [];
                    if (classList.length) {
                      part += '.' + classList.slice(0, 2).map((c) => CSS.escape(c)).join('.');
                    }

                    const parent = cur.parentElement;
                    if (parent) {
                      const sameTagSiblings = Array.from(parent.children).filter(
                        (sib) => sib.tagName === cur.tagName
                      );
                      if (sameTagSiblings.length > 1) {
                        part += ':nth-of-type(' + (sameTagSiblings.indexOf(cur) + 1) + ')';
                      }
                    }

                    parts.unshift(part);
                    cur = cur.parentElement;
                  }
                  return parts.join(' > ');
                };

                const bestSelector = (el) => {
                  if (!el || el.nodeType !== 1) return '';
                  if (el.id) return '#' + el.id;
                  const testId = el.getAttribute && (el.getAttribute('data-testid') || el.getAttribute('data-test-id'));
                  if (testId) return '[data-testid=' + attrSelectorValue(testId) + ']';
                  const name = el.getAttribute && el.getAttribute('name');
                  if (name) return el.tagName.toLowerCase() + '[name=' + attrSelectorValue(name) + ']';
                  const ariaLabel = el.getAttribute && el.getAttribute('aria-label');
                  if (ariaLabel) return el.tagName.toLowerCase() + '[aria-label=' + attrSelectorValue(ariaLabel) + ']';
                  const placeholder = el.getAttribute && el.getAttribute('placeholder');
                  if (placeholder) return el.tagName.toLowerCase() + '[placeholder=' + attrSelectorValue(placeholder) + ']';
                  if (el.className && typeof el.className === 'string') {
                    const classes = el.className.split(' ').filter((c) => c.trim()).slice(0, 3).join('.');
                    if (classes) return el.tagName.toLowerCase() + '.' + classes;
                  }
                  const path = cssPath(el);
                  return path || el.tagName.toLowerCase();
                };

                const requestedScope = ${JSON.stringify(P ?? "main")};
                const root =
                  requestedScope === 'document'
                    ? document
                    : (document.querySelector('main, [role="main"]') || document.body);

                const withinRoot = (el) => {
                  try { return root && root !== document ? root.contains(el) : true; } catch { return true; }
                };

                const selectorList = 'button, a, input, textarea, select, summary, [role="button"], [role="link"], [role="tab"]';
                const candidates = Array.from((root && root !== document ? root : document).querySelectorAll(selectorList));

                // Visible + within root + de-duplicate by selector+text+tag.
                const seen = new Set();
                const out = [];
                const limit = Math.max(1, Math.min(200, ${JSON.stringify(N ?? 80)}));

                for (const el of candidates) {
                  if (!withinRoot(el)) continue;
                  if (!isVisible(el)) continue;

                  const tag = el.tagName.toLowerCase();
                  const text = (el.textContent || '').substring(0, 80).trim().replace(/\\s+/g, ' ');
                  const placeholder = el.getAttribute('placeholder') || '';
                  const type = el.getAttribute('type') || '';
                  const role = el.getAttribute('role') || '';
                  const name = el.getAttribute('name') || '';
                  const disabled = 'disabled' in el ? Boolean(el.disabled) : el.getAttribute('aria-disabled') === 'true';
                  const selector = bestSelector(el);
                  const matches = selector ? document.querySelectorAll(selector).length : 0;
                  const value = 'value' in el ? String(el.value ?? '') : '';
                  const href = tag === 'a' ? (el.getAttribute('href') || '') : '';
                  const ariaLabel = el.getAttribute('aria-label') || '';

                  const key = [tag, selector, text].join('|');
                  if (seen.has(key)) continue;
                  seen.add(key);

                  out.push({ tag, text, placeholder, type, role, name, disabled, value, href, ariaLabel, selector, matches });
                  if (out.length >= limit) break;
                }

                // Provide a small main-text snippet so the agent can orient itself.
                const mainText = (() => {
                  const node =
                    (document.querySelector('main, [role="main"]') || document.body);
                  const raw = (node?.innerText || '').replace(/\\s+/g, ' ').trim();
                  return raw.slice(0, 1200);
                })();

                return { interactiveElements: out, mainTextSnippet: mainText, scope: requestedScope };
              })()`,
            !0
          ), k = { url: S, title: _, ...$ }, de = Date.now();
          return this.observeCache.set(q, {
            url: S,
            title: String(_ ?? ""),
            argsKey: Ee,
            data: k,
            timestamp: de,
            domVersion: ae
          }), JSON.stringify(
            {
              ...k,
              _meta: {
                cached: !1,
                timestamp: de,
                ageMs: 0,
                url: S,
                title: String(_ ?? ""),
                domVersion: ae,
                args: { scope: P ?? "main", maxElements: N ?? 80 }
              }
            },
            null,
            2
          );
        } catch (M) {
          return `Failed to observe page: ${M.message}`;
        }
      }
    }, n = {
      name: "browser_go_back",
      description: "Navigate back in the browser history.",
      schema: ye({}),
      execute: async () => {
        const A = await this.getTarget();
        return A.canGoBack() ? (A.goBack(), this.invalidateCache(A.id), await this.delay(500), "Navigated back") : "Cannot go back (no history)";
      }
    }, s = {
      name: "browser_go_forward",
      description: "Navigate forward in the browser history.",
      schema: ye({}),
      execute: async () => {
        const A = await this.getTarget();
        return A.canGoForward() ? (A.goForward(), this.invalidateCache(A.id), await this.delay(500), "Navigated forward") : "Cannot go forward (no history)";
      }
    }, a = {
      name: "browser_reload",
      description: "Reload the current page.",
      schema: ye({}),
      execute: async () => {
        const A = await this.getTarget();
        return A.reload(), this.invalidateCache(A.id), await this.delay(1e3), "Page reloading triggered";
      }
    }, i = {
      name: "browser_navigate",
      description: "Navigate the browser to a specific URL.",
      schema: ye({
        url: H().describe("The URL to navigate to (must include http/https)"),
        waitForSelector: H().optional().describe("Optional selector to wait for after navigation"),
        waitForText: H().optional().describe("Optional text to wait for after navigation"),
        timeoutMs: We().optional().describe("Timeout in ms for optional waits (default 8000)")
      }),
      execute: async ({
        url: A,
        waitForSelector: P,
        waitForText: N,
        timeoutMs: j
      }) => {
        try {
          let M;
          try {
            M = await this.getTarget();
          } catch {
            const { BrowserWindow: Ee } = await import("electron"), ae = Ee.getAllWindows()[0];
            if (ae) {
              ae.webContents.send("browser:navigate-to", A), await this.delay(1500);
              try {
                M = await this.getTarget();
              } catch {
                return `Navigated to ${A} (webview initializing)`;
              }
            } else
              return "Failed to navigate: No browser window found";
          }
          try {
            const se = new _y(A);
            if ((se.hostname === "localhost" || se.hostname === "127.0.0.1") && se.port === "3000") {
              const Ee = await this.getMockSaasRoutes(), ae = se.pathname.replace(/\/+$/, "") || "/";
              if (!Ee.has(ae))
                return `Failed to navigate: Unknown mock-saas route ${ae}. Known routes: ${Array.from(
                  Ee
                ).sort().join(", ")}. Navigate to /jira and use the Create button (it is a modal, not a /create route).`;
            }
          } catch {
          }
          this.invalidateCache(M.id);
          const q = j ?? 8e3;
          try {
            await M.loadURL(A);
          } catch (se) {
            if (!String((se == null ? void 0 : se.message) ?? se).includes("ERR_ABORTED") || (await this.delay(250), !M.getURL())) throw se;
          }
          if (P && await this.waitForSelector(M, P, q), N) {
            const se = Date.now(), Ee = N.toLowerCase();
            for (; Date.now() - se < q && !await M.executeJavaScript(
              `document.body && document.body.innerText && document.body.innerText.toLowerCase().includes(${JSON.stringify(
                Ee
              )})`,
              !0
            ); )
              await this.delay(150);
          }
          return `Navigated to ${M.getURL()}`;
        } catch (M) {
          return `Failed to navigate: ${M.message}`;
        }
      }
    }, c = {
      name: "browser_scroll",
      description: 'Scroll to an element or by an amount. Provide "selector" to scroll element into view, or "direction" (up/down/top/bottom) to scroll page.',
      schema: ye({
        selector: H().optional().describe("CSS selector to scroll into view"),
        direction: rn(["up", "down", "top", "bottom"]).optional().describe("Scroll direction if no selector provided"),
        amount: We().optional().describe("Pixels to scroll (default 500 for up/down)")
      }),
      execute: async ({ selector: A, direction: P, amount: N }) => {
        const j = await this.getTarget();
        if (this.invalidateCache(j.id), A)
          return await this.waitForSelector(j, A, 5e3), await j.executeJavaScript(
            `(() => {
               const el = document.querySelector(${JSON.stringify(A)});
               if (el) el.scrollIntoView({ behavior: 'smooth', block: 'center' });
             })()`,
            !0
          ), `Scrolled to element "${A}"`;
        if (P) {
          const M = N ?? 500;
          return await j.executeJavaScript(
            `(() => {
               const amt = ${JSON.stringify(M)};
               const dir = ${JSON.stringify(P)};
               if (dir === 'top') window.scrollTo({ top: 0, behavior: 'smooth' });
               else if (dir === 'bottom') window.scrollTo({ top: document.body.scrollHeight, behavior: 'smooth' });
               else if (dir === 'up') window.scrollBy({ top: -amt, behavior: 'smooth' });
               else window.scrollBy({ top: amt, behavior: 'smooth' });
             })()`,
            !0
          ), `Scrolled ${P}`;
        }
        return "No scroll action performed (provide selector or direction)";
      }
    }, l = {
      name: "browser_press_key",
      description: "Press a keyboard key (e.g. Enter, Escape, ArrowDown, Tab).",
      schema: ye({
        key: H().describe("Key name (e.g. Enter, Escape, ArrowDown)")
      }),
      execute: async ({ key: A }) => {
        const P = await this.getTarget();
        try {
          return P.sendInputEvent({ type: "keyDown", keyCode: A }), P.sendInputEvent({ type: "keyUp", keyCode: A }), this.invalidateCache(P.id), `Pressed key: ${A}`;
        } catch (N) {
          return `Failed to press key: ${N.message}`;
        }
      }
    }, h = {
      name: "browser_wait_for_selector",
      description: "Wait for an element to appear in the DOM.",
      schema: ye({
        selector: H().describe("CSS selector to wait for"),
        timeoutMs: We().optional().describe("Timeout in ms (default 5000)")
      }),
      execute: async ({ selector: A, timeoutMs: P }) => {
        const N = await this.getTarget(), j = P ?? 5e3;
        try {
          return await this.waitForSelector(N, A, j), `Element "${A}" appeared`;
        } catch {
          return `Timeout waiting for "${A}"`;
        }
      }
    }, p = {
      name: "browser_wait_for_url",
      description: "Wait for the URL to contain a specific string.",
      schema: ye({
        urlPart: H().describe("Substring or full URL to wait for"),
        timeoutMs: We().optional().describe("Timeout in ms (default 5000)")
      }),
      execute: async ({ urlPart: A, timeoutMs: P }) => {
        const N = await this.getTarget(), j = P ?? 5e3, M = Date.now();
        for (; Date.now() - M < j; ) {
          if (N.getURL().includes(A)) return `URL matches "${A}"`;
          await this.delay(200);
        }
        return `Timeout waiting for URL to contain "${A}"`;
      }
    }, m = {
      name: "browser_focus",
      description: "Focus an element (e.g. input field).",
      schema: ye({
        selector: H().describe("CSS selector to focus")
      }),
      execute: async ({ selector: A }) => {
        const P = await this.getTarget();
        return await this.waitForSelector(P, A, 5e3), await P.executeJavaScript(
          `(() => {
             const el = document.querySelector(${JSON.stringify(A)});
             if (el && typeof el.focus === 'function') el.focus();
           })()`,
          !0
        ), this.invalidateCache(P.id), `Focused "${A}"`;
      }
    }, g = {
      name: "browser_clear",
      description: "Clear the value of an input or textarea.",
      schema: ye({
        selector: H().describe("CSS selector of input to clear")
      }),
      execute: async ({ selector: A }) => {
        const P = await this.getTarget();
        return await this.waitForSelector(P, A, 5e3), await P.executeJavaScript(
          `(() => {
             const el = document.querySelector(${JSON.stringify(A)});
             if (!el) return { ok: false, error: 'Element not found' };
             const tag = (el.tagName || '').toLowerCase();
             const isEditable = tag === 'input' || tag === 'textarea' || Boolean(el.isContentEditable);
             if (!isEditable) return { ok: false, error: 'Element is not editable' };

             const setNativeValue = (node, value) => {
               const t = (node.tagName || '').toLowerCase();
               if (t === 'input') {
                 const setter = Object.getOwnPropertyDescriptor(window.HTMLInputElement.prototype, 'value')?.set;
                 if (setter) setter.call(node, value);
                 else node.value = value;
                 return;
               }
               if (t === 'textarea') {
                 const setter = Object.getOwnPropertyDescriptor(window.HTMLTextAreaElement.prototype, 'value')?.set;
                 if (setter) setter.call(node, value);
                 else node.value = value;
                 return;
               }
               if (node.isContentEditable) {
                 node.textContent = value;
                 return;
               }
               node.value = value;
             };

             setNativeValue(el, '');
             el.dispatchEvent(new InputEvent('input', { bubbles: true, data: '', inputType: 'deleteContentBackward' }));
             el.dispatchEvent(new Event('change', { bubbles: true }));
             return { ok: true };
           })()`,
          !0
        ), this.invalidateCache(P.id), `Cleared input "${A}"`;
      }
    }, T = {
      name: "browser_click",
      description: "Click an element on the current page. Safe + deterministic: if the selector matches multiple visible elements, you must disambiguate using withinSelector, matchText, or index (or use browser_click_text).",
      schema: ye({
        selector: H().describe("CSS selector of the element to click"),
        withinSelector: H().optional().describe("Optional container selector to scope the search (must match exactly 1 element)"),
        index: We().optional().describe("Index of element if multiple match (0-based)"),
        matchText: H().optional().describe("Text content to match if multiple elements found")
      }),
      execute: async ({ selector: A, withinSelector: P, index: N, matchText: j }) => {
        try {
          const M = await this.getTarget();
          P && await this.waitForSelector(M, P, 5e3), await this.waitForSelector(M, A, 5e3);
          const q = await M.executeJavaScript(
            `(() => {
                // Helper to find elements including shadow DOM
                const findElements = (root, sel) => {
                  const results = [];
                  const queryDeep = (root) => {
                    const els = Array.from(root.querySelectorAll(sel));
                    results.push(...els);
                    if (root.shadowRoot) {
                      queryDeep(root.shadowRoot);
                    }
                    const walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT);
                    while (walker.nextNode()) {
                      const node = walker.currentNode;
                      if (node.shadowRoot) {
                        queryDeep(node.shadowRoot);
                      }
                    }
                  };
                  queryDeep(root);
                  return results;
                };

                const isVisible = (el) => {
                  if (!el || el.nodeType !== 1) return false;
                  const style = window.getComputedStyle(el);
                  if (!style) return false;
                  if (style.display === 'none' || style.visibility === 'hidden' || style.opacity === '0') return false;
                  if (style.pointerEvents === 'none') return false;
                  const rects = el.getClientRects();
                  if (!rects || rects.length === 0) return false;
                  const rect = el.getBoundingClientRect();
                  if (rect.width < 2 || rect.height < 2) return false;
                  const vw = window.innerWidth || 0;
                  const vh = window.innerHeight || 0;
                  const buffer = 40;
                  if (rect.bottom < -buffer || rect.top > vh + buffer) return false;
                  if (rect.right < -buffer || rect.left > vw + buffer) return false;
                  return true;
                };

                const describe = (el) => {
                  const tag = (el.tagName || '').toLowerCase();
                  const text = (el.innerText || el.textContent || '').replace(/s+/g, ' ').trim().slice(0, 80);
                  const ariaLabel = el.getAttribute?.('aria-label') || '';
                  const testId = el.getAttribute?.('data-testid') || el.getAttribute?.('data-test-id') || '';
                  const id = el.id || '';
                  return { tag, text, ariaLabel, testId, id };
                };

                const withinSel = ${JSON.stringify(P ?? "")};
                let root = document;
                if (withinSel) {
                  const roots = Array.from(document.querySelectorAll(withinSel)).filter(isVisible);
                  if (roots.length === 0) {
                    return { ok: false, error: 'Within selector not found (or not visible)', matches: 0 };
                  }
                  if (roots.length > 1) {
                    return { ok: false, error: 'Within selector is not unique', matches: roots.length, roots: roots.slice(0, 5).map(describe) };
                  }
                  root = roots[0];
                }

                let candidates = findElements(root, ${JSON.stringify(A)});
                candidates = candidates.filter(isVisible);
                
                // Filter by text if provided
                if (${JSON.stringify(j)}) {
                  const needle = ${JSON.stringify(j || "")}.toLowerCase();
                  candidates = candidates.filter(el => (el.innerText || '').toLowerCase().includes(needle));
                }

                if (candidates.length === 0) {
                  return { ok: false, error: 'Element not found (visible)', matches: 0 };
                }

                const idxProvided = ${JSON.stringify(N !== void 0)};
                const idx = ${JSON.stringify(N ?? 0)};

                if (candidates.length > 1 && !idxProvided) {
                  return {
                    ok: false,
                    error: 'Ambiguous selector (multiple visible matches)',
                    matches: candidates.length,
                    candidates: candidates.slice(0, 6).map(describe),
                  };
                }

                if (idx >= candidates.length) return { ok: false, error: 'Index out of bounds' };
                
                const el = candidates[idx];
                
                const isDisabled = ('disabled' in el && Boolean(el.disabled)) || el.getAttribute?.('aria-disabled') === 'true';
                if (isDisabled) return { ok: false, error: 'Element is disabled' };
                
                el.scrollIntoView({ block: 'center', inline: 'center' });
                
                // Try multiple click strategies
                try {
                  el.click(); // Standard click
                } catch (e) { console.error('Standard click failed', e); }
                
                // Dispatch events (crucial for React/Angular/Vue apps)
                const eventOpts = { bubbles: true, cancelable: true, view: window };
                el.dispatchEvent(new MouseEvent('mouseover', eventOpts));
                el.dispatchEvent(new MouseEvent('mousedown', eventOpts));
                el.dispatchEvent(new MouseEvent('mouseup', eventOpts));
                el.dispatchEvent(new MouseEvent('click', eventOpts));
                
                return { ok: true, matches: candidates.length, clicked: describe(el) };
              })()`,
            !0
          );
          if (!q.ok) {
            const se = `Refusing to click: ${q.error}. Selector=${JSON.stringify(
              A
            )}${P ? ` within=${JSON.stringify(P)}` : ""}.`;
            if (q.error === "Ambiguous selector (multiple visible matches)") {
              const Ee = typeof q.matches == "number" ? q.matches : "multiple", ae = Array.isArray(q.candidates) ? q.candidates.map((S, _) => {
                const $ = [S.tag, S.testId ? `testId=${S.testId}` : "", S.id ? `id=${S.id}` : ""].filter(Boolean).join(" "), k = S.ariaLabel ? ` ariaLabel=${JSON.stringify(S.ariaLabel)}` : "", de = S.text ? ` text=${JSON.stringify(S.text)}` : "";
                return `#${_} ${$}${k}${de}`;
              }).join(`
`) : "";
              return `${se} Matched ${Ee} visible elements.
Provide one of: {"index":0..}, {"matchText":"..."}, or {"withinSelector":"..."}.
Or prefer browser_click_text (more robust).
` + (ae ? `Candidates:
${ae}` : "");
            }
            if (q.error === "Within selector is not unique") {
              const Ee = Array.isArray(q.roots) ? q.roots.map((ae, S) => {
                const _ = [ae.tag, ae.testId ? `testId=${ae.testId}` : "", ae.id ? `id=${ae.id}` : ""].filter(Boolean).join(" "), $ = ae.text ? ` text=${JSON.stringify(ae.text)}` : "";
                return `#${S} ${_}${$}`;
              }).join(`
`) : "";
              return `${se} The withinSelector must match exactly 1 visible container.
` + (Ee ? `Within candidates:
${Ee}` : "");
            }
            return `${se} Try browser_click_text or refine your selector.`;
          }
          return this.invalidateCache(M.id), `Clicked element ${A}`;
        } catch (M) {
          return `Failed to click ${A}: ${M.message}`;
        }
      }
    }, x = {
      name: "browser_type",
      description: "Type text into an input field.",
      schema: ye({
        selector: H().describe("CSS selector of the input"),
        text: H().describe("Text to type")
      }),
      execute: async ({ selector: A, text: P }) => {
        try {
          const N = await this.getTarget(), j = await this.querySelectorCount(N, A);
          if (j > 1)
            return `Refusing to type into non-unique selector (matches=${j}): ${A}`;
          await this.waitForSelector(N, A, 5e3);
          const M = await N.executeJavaScript(
            `(() => {
                const el = document.querySelector(${JSON.stringify(A)});
                if (!el) throw new Error('Element not found');
                const isDisabled = ('disabled' in el && Boolean(el.disabled)) || el.getAttribute?.('aria-disabled') === 'true';
                if (isDisabled) throw new Error('Element is disabled');
                el.scrollIntoView({ block: 'center', inline: 'center' });
                el.focus?.();

                const setNativeValue = (node, value) => {
                  const tag = node.tagName?.toLowerCase?.() || '';
                  if (tag === 'input') {
                    const setter = Object.getOwnPropertyDescriptor(window.HTMLInputElement.prototype, 'value')?.set;
                    if (setter) setter.call(node, value);
                    else node.value = value;
                    return;
                  }
                  if (tag === 'textarea') {
                    const setter = Object.getOwnPropertyDescriptor(window.HTMLTextAreaElement.prototype, 'value')?.set;
                    if (setter) setter.call(node, value);
                    else node.value = value;
                    return;
                  }
                  if (node.isContentEditable) {
                    node.textContent = value;
                    return;
                  }
                  node.value = value;
                };

                setNativeValue(el, '');
                el.dispatchEvent(new InputEvent('input', { bubbles: true, data: '', inputType: 'deleteContentBackward' }));
                setNativeValue(el, ${JSON.stringify(P)});
                el.dispatchEvent(new InputEvent('input', { bubbles: true, data: ${JSON.stringify(P)}, inputType: 'insertText' }));
                el.dispatchEvent(new Event('change', { bubbles: true }));
                return ('value' in el) ? String(el.value ?? '') : (el.textContent || '');
              })()`,
            !0
          );
          return this.invalidateCache(N.id), `Typed into ${A}. Current value: ${JSON.stringify(M)}`;
        } catch (N) {
          return `Failed to type into ${A}: ${N.message}`;
        }
      }
    }, O = {
      name: "browser_get_text",
      description: "Get the text content of an element.",
      schema: ye({
        selector: H().describe("CSS selector")
      }),
      execute: async ({ selector: A }) => {
        try {
          const P = await this.getTarget();
          return await this.waitForSelector(P, A, 5e3), await P.executeJavaScript(
            `(() => {
                    const el = document.querySelector(${JSON.stringify(A)});
                    return el ? (el.textContent || '') : null;
                  })()`,
            !0
          ) || "Element found but has no text.";
        } catch (P) {
          return `Failed to get text: ${P.message}`;
        }
      }
    }, R = {
      name: "browser_screenshot",
      description: "Take a screenshot of the current page.",
      schema: ye({
        path: H().optional().describe("Path to save the screenshot (optional)")
      }),
      execute: async ({ path: A }) => {
        const j = (await (await this.getTarget()).capturePage()).toPNG();
        if (A) {
          const M = Ie.isAbsolute(A) ? A : Ie.join(process.cwd(), A);
          return await Xe.writeFile(M, j), `Screenshot saved to ${M} (${j.length} bytes).`;
        }
        return `Screenshot taken (${j.length} bytes).`;
      }
    }, E = {
      name: "browser_find_text",
      description: "Find text on the current page and return matching elements/selectors.",
      schema: ye({
        text: H().describe("Text to search for (case-insensitive substring match)"),
        maxMatches: We().optional().describe("Max results to return (default 10)")
      }),
      execute: async ({ text: A, maxMatches: P }) => {
        const j = await (await this.getTarget()).executeJavaScript(
          `(() => {
            const query = ${JSON.stringify(A)}.toLowerCase();
            const limit = Math.max(1, Math.min(50, ${JSON.stringify(P ?? 10)}));

            const escapeForSingleQuotes = (value) => {
              if (typeof value !== 'string') return '';
              return value.replace(/\\\\/g, '\\\\\\\\').replace(/'/g, "\\\\'");
            };

            const attrSelectorValue = (value) => {
              if (typeof value !== 'string') return "''";
              if (/^[a-zA-Z0-9_-]+$/.test(value)) return value;
              return "'" + escapeForSingleQuotes(value) + "'";
            };

            const selectorFor = (el) => {
              if (!el || el.nodeType !== 1) return '';
              if (el.id) return '#' + el.id;
              const testId = el.getAttribute && (el.getAttribute('data-testid') || el.getAttribute('data-test-id'));
              if (testId) return '[data-testid=' + attrSelectorValue(testId) + ']';
              const ariaLabel = el.getAttribute && el.getAttribute('aria-label');
              if (ariaLabel) return el.tagName.toLowerCase() + '[aria-label=' + attrSelectorValue(ariaLabel) + ']';
              const placeholder = el.getAttribute && el.getAttribute('placeholder');
              if (placeholder) return el.tagName.toLowerCase() + '[placeholder=' + attrSelectorValue(placeholder) + ']';
              return el.tagName.toLowerCase();
            };

            const out = [];
            const walker = document.createTreeWalker(document.body, NodeFilter.SHOW_TEXT);
            while (walker.nextNode()) {
              const node = walker.currentNode;
              const raw = node.nodeValue || '';
              const normalized = raw.replace(/\\s+/g, ' ').trim();
              if (!normalized) continue;
              if (!normalized.toLowerCase().includes(query)) continue;

              const parent = node.parentElement;
              if (!parent) continue;
              const el = parent.closest('button, a, [role="button"], [role="link"], input, textarea, select, div, span, p') || parent;
              const selector = selectorFor(el);
              out.push({
                selector,
                tag: el.tagName.toLowerCase(),
                text: (el.textContent || '').replace(/\\s+/g, ' ').trim().slice(0, 120),
              });
              if (out.length >= limit) break;
            }
            return out;
          })()`,
          !0
        );
        return JSON.stringify({ found: Array.isArray(j) ? j.length : 0, matches: j }, null, 2);
      }
    }, V = {
      name: "browser_wait_for_text",
      description: "Wait until text appears on the page (case-insensitive). Useful to verify actions succeeded.",
      schema: ye({
        text: H().describe("Text to wait for"),
        timeoutMs: We().optional().describe("Timeout in ms (default 5000)")
      }),
      execute: async ({ text: A, timeoutMs: P }) => {
        const N = await this.getTarget(), j = Date.now(), M = P ?? 5e3;
        for (; Date.now() - j < M; ) {
          if (await N.executeJavaScript(
            `document.body && document.body.innerText && document.body.innerText.toLowerCase().includes(${JSON.stringify(
              A.toLowerCase()
            )})`,
            !0
          )) return `Found text: ${JSON.stringify(A)}`;
          await this.delay(150);
        }
        return `Did not find text within ${M}ms: ${JSON.stringify(A)}`;
      }
    }, ne = {
      name: "browser_wait_for_text_in",
      description: "Wait until text appears within a specific container selector (case-insensitive).",
      schema: ye({
        selector: H().describe("CSS selector for the container"),
        text: H().describe("Text to wait for"),
        timeoutMs: We().optional().describe("Timeout in ms (default 5000)")
      }),
      execute: async ({
        selector: A,
        text: P,
        timeoutMs: N
      }) => {
        const j = await this.getTarget(), M = Date.now(), q = N ?? 5e3, se = P.toLowerCase();
        for (; Date.now() - M < q; ) {
          if (await j.executeJavaScript(
            `(() => {
              const root = document.querySelector(${JSON.stringify(A)});
              if (!root) return false;
              const text = (root.innerText || '').toLowerCase();
              return text.includes(${JSON.stringify(se)});
            })()`,
            !0
          )) return `Found text in ${A}: ${JSON.stringify(P)}`;
          await this.delay(150);
        }
        return `Did not find text in ${A} within ${q}ms: ${JSON.stringify(P)}`;
      }
    }, z = {
      name: "browser_select",
      description: "Set the value of a <select> element.",
      schema: ye({
        selector: H().describe("CSS selector of the select element"),
        value: H().describe("Option value to set")
      }),
      execute: async ({ selector: A, value: P }) => {
        try {
          const N = await this.getTarget(), j = await this.querySelectorCount(N, A);
          if (j > 1)
            return `Refusing to select on non-unique selector (matches=${j}): ${A}`;
          await this.waitForSelector(N, A, 5e3);
          const M = await N.executeJavaScript(
            `(() => {
              const el = document.querySelector(${JSON.stringify(A)});
              if (!el) throw new Error('Element not found');
              const tag = el.tagName?.toLowerCase?.();
              if (tag !== 'select') throw new Error('Element is not a <select>');
              const isDisabled = Boolean(el.disabled) || el.getAttribute?.('aria-disabled') === 'true';
              if (isDisabled) throw new Error('Element is disabled');
              el.value = ${JSON.stringify(P)};
              el.dispatchEvent(new Event('input', { bubbles: true }));
              el.dispatchEvent(new Event('change', { bubbles: true }));
              return String(el.value ?? '');
            })()`,
            !0
          );
          return this.invalidateCache(N.id), `Selected value ${JSON.stringify(M)} on ${A}`;
        } catch (N) {
          return `Failed to select on ${A}: ${N.message}`;
        }
      }
    }, Te = {
      name: "browser_click_text",
      description: "Click a visible element by its text (avoids brittle selectors). Optionally filter by tag/role and choose index.",
      schema: ye({
        text: H().describe("Visible text to match"),
        exact: Zi().optional().describe("Exact match (default false = substring match)"),
        role: H().optional().describe("ARIA role to filter (e.g. tab, button, link)"),
        tag: H().optional().describe("Tag name to filter (e.g. a, button)"),
        index: We().optional().describe("Which match to click (0-based, default 0)"),
        withinSelector: H().optional().describe("Limit search to a container selector")
      }),
      execute: async ({
        text: A,
        exact: P,
        role: N,
        tag: j,
        index: M,
        withinSelector: q
      }) => {
        try {
          const Ee = await (await this.getTarget()).executeJavaScript(
            `(() => {
              const query = ${JSON.stringify(A)}.toLowerCase().trim();
              const exact = Boolean(${JSON.stringify(P ?? !1)});
              const role = ${JSON.stringify(N ?? "")}.toLowerCase().trim();
              const tag = ${JSON.stringify(j ?? "")}.toLowerCase().trim();
              const idx = Math.max(0, Math.floor(${JSON.stringify(M ?? 0)}));
              const root = ${q ? `document.querySelector(${JSON.stringify(q)})` : "document"} || document;

              const isVisible = (el) => {
                if (!el || el.nodeType !== 1) return false;
                const style = window.getComputedStyle(el);
                if (!style) return false;
                if (style.display === 'none' || style.visibility === 'hidden' || style.opacity === '0') return false;
                if (style.pointerEvents === 'none') return false;
                const rects = el.getClientRects();
                if (!rects || rects.length === 0) return false;
                const rect = el.getBoundingClientRect();
                if (rect.width < 2 || rect.height < 2) return false;
                const vw = window.innerWidth || 0;
                const vh = window.innerHeight || 0;
                const buffer = 40;
                if (rect.bottom < -buffer || rect.top > vh + buffer) return false;
                if (rect.right < -buffer || rect.left > vw + buffer) return false;
                return true;
              };

              const selector = 'button, a, [role="button"], [role="link"], [role="tab"], summary';
              const candidates = Array.from((root === document ? document : root).querySelectorAll(selector));
              const matches = [];
              for (const el of candidates) {
                if (!isVisible(el)) continue;
                if (tag && el.tagName.toLowerCase() !== tag) continue;
                if (role) {
                  const r = (el.getAttribute('role') || '').toLowerCase();
                  if (r !== role) continue;
                }
                const t = (el.textContent || '').replace(/\\s+/g, ' ').trim().toLowerCase();
                if (!t) continue;
                const ok = exact ? t === query : t.includes(query);
                if (!ok) continue;
                const disabled = ('disabled' in el && Boolean(el.disabled)) || el.getAttribute?.('aria-disabled') === 'true';
                matches.push({ el, text: t, disabled });
              }

              if (matches.length === 0) {
                return { ok: false, reason: 'No matching visible elements', matches: 0 };
              }
              const chosen = matches[Math.min(idx, matches.length - 1)];
              if (chosen.disabled) {
                return { ok: false, reason: 'Matched element is disabled', matches: matches.length };
              }
              const el = chosen.el;
              el.scrollIntoView({ block: 'center', inline: 'center' });
              el.dispatchEvent(new MouseEvent('mouseover', { bubbles: true }));
              el.dispatchEvent(new MouseEvent('mousedown', { bubbles: true }));
              el.dispatchEvent(new MouseEvent('mouseup', { bubbles: true }));
              el.click();
              return { ok: true, matches: matches.length, clickedText: chosen.text };
            })()`,
            !0
          );
          return `ClickText result: ${JSON.stringify(Ee)}`;
        } catch (se) {
          return `Failed to click by text: ${se.message}`;
        }
      }
    }, Oe = {
      name: "browser_extract_main_text",
      description: "Extract visible text from the main content area (role=main/main tag) to support scraping/QA.",
      schema: ye({
        maxChars: We().optional().describe("Max characters to return (default 2000, hard cap 4000)")
      }),
      execute: async ({ maxChars: A }) => {
        const P = await this.getTarget(), N = Math.max(1, Math.min(4e3, Math.floor(A ?? 2e3))), j = await P.executeJavaScript(
          `(() => {
            const node = document.querySelector('main, [role="main"]') || document.body;
            const raw = (node?.innerText || '').replace(/s+/g, ' ').trim();
            return raw.slice(0, ${JSON.stringify(N)});
          })()`,
          !0
        );
        return String(j ?? "");
      }
    }, Z = ye({
      action: rn(["navigate", "click", "type", "select", "wait"]),
      url: H().optional().describe("For navigate action"),
      selector: H().optional().describe("For click/type/select actions"),
      value: H().optional().describe("For type/select actions"),
      text: H().optional().describe("For wait action"),
      index: We().optional().describe("For click actions: index to disambiguate (0-based)"),
      matchText: H().optional().describe("For click actions: filter candidates by visible text"),
      withinSelector: H().optional().describe("For click actions: scope search to a unique container selector")
    }), D = ye({
      steps: Vi(Z)
    }), U = {
      name: "browser_execute_plan",
      description: "Execute a batch of browser actions (navigate, click, type, select, wait). Use this for Mock SaaS tasks where you have read the code and know the selectors.",
      schema: D,
      execute: async (A) => {
        const N = D.parse(A ?? {}).steps, j = [], M = ft.getRunId() ?? void 0, q = Pe();
        if (!Array.isArray(N) || N.length === 0)
          return "Plan rejected: steps must be a non-empty array.";
        for (const [S, _] of N.entries()) {
          if (_.action === "navigate" && !_.url)
            return `Plan rejected: step ${S + 1} navigate is missing url.`;
          if (_.action === "click" && !_.selector)
            return `Plan rejected: step ${S + 1} click is missing selector.`;
          if (_.action === "type") {
            if (!_.selector) return `Plan rejected: step ${S + 1} type is missing selector.`;
            if (_.value === void 0) return `Plan rejected: step ${S + 1} type is missing value.`;
          }
          if (_.action === "select") {
            if (!_.selector) return `Plan rejected: step ${S + 1} select is missing selector.`;
            if (_.value === void 0) return `Plan rejected: step ${S + 1} select is missing value.`;
          }
          if (_.action === "wait" && !_.text)
            return `Plan rejected: step ${S + 1} wait is missing text.`;
        }
        if (N.some((S) => S.action === "click" || S.action === "type" || S.action === "select")) {
          const S = N[N.length - 1];
          if ((S == null ? void 0 : S.action) !== "wait" || !(S != null && S.text))
            return 'Plan rejected: plans with interactions must end with a verification wait step (action="wait" with text).';
        }
        const Ee = he.getPolicyService();
        if (Ee) {
          const S = ft.getBrowserContext();
          for (const [_, $] of N.entries()) {
            const k = (() => {
              switch ($.action) {
                case "navigate":
                  return "browser_navigate";
                case "click":
                  return "browser_click";
                case "type":
                  return "browser_type";
                case "select":
                  return "browser_select";
                case "wait":
                  return "browser_wait_for_text";
                default:
                  return "browser_execute_plan_step";
              }
            })(), de = (() => {
              switch ($.action) {
                case "navigate":
                  return { url: $.url };
                case "click":
                  return {
                    selector: $.selector,
                    index: $.index,
                    matchText: $.matchText,
                    withinSelector: $.withinSelector
                  };
                case "type":
                  return { selector: $.selector, text: $.value };
                case "select":
                  return { selector: $.selector, value: $.value };
                case "wait":
                  return { text: $.text };
              }
            })(), ge = await Ee.evaluate({
              toolName: k,
              args: de,
              url: S == null ? void 0 : S.url,
              domain: S == null ? void 0 : S.domain,
              userMode: "standard",
              observeOnly: ft.getObserveOnly(),
              runId: M
            });
            if (ge.decision === "deny")
              return `Plan rejected by policy at step ${_ + 1} (${k}): ${ge.reason}`;
          }
        }
        const ae = (S) => {
          const _ = String(S ?? "");
          return _.startsWith("Refusing") || _.startsWith("Failed") || _.startsWith("Timeout") || _.startsWith("Operation denied by policy") || _.startsWith("User denied") || _.startsWith("Tool execution failed");
        };
        for (const [S, _] of N.entries()) {
          const $ = Pe(), k = Date.now();
          try {
            await tt.emit({
              eventId: Pe(),
              runId: M,
              ts: (/* @__PURE__ */ new Date()).toISOString(),
              type: "plan_step_start",
              name: "browser_execute_plan",
              data: {
                planId: q,
                stepId: $,
                stepIndex: S,
                action: String((_ == null ? void 0 : _.action) ?? "")
              }
            });
          } catch {
          }
          try {
            const de = (() => {
              switch (_.action) {
                case "navigate":
                  return "browser_navigate";
                case "click":
                  return "browser_click";
                case "type":
                  return "browser_type";
                case "select":
                  return "browser_select";
                case "wait":
                  return "browser_wait_for_text";
                default:
                  return "browser_execute_plan_step";
              }
            })(), ge = (() => {
              switch (_.action) {
                case "navigate":
                  return { url: _.url };
                case "click":
                  return {
                    selector: _.selector,
                    index: _.index,
                    matchText: _.matchText,
                    withinSelector: _.withinSelector
                  };
                case "type":
                  return { selector: _.selector, text: _.value };
                case "select":
                  return { selector: _.selector, value: _.value };
                case "wait":
                  return { text: _.text };
              }
            })(), Me = await he.invokeTool(de, ge), Ue = String(Me ?? "");
            if (ae(Ue))
              throw new Error(Ue);
            if (_.action === "wait" && !Ue.startsWith("Found text"))
              throw new Error(Ue);
            const at = Date.now() - k;
            try {
              await tt.emit({
                eventId: Pe(),
                runId: M,
                ts: (/* @__PURE__ */ new Date()).toISOString(),
                type: "plan_step_end",
                name: "browser_execute_plan",
                data: {
                  planId: q,
                  stepId: $,
                  stepIndex: S,
                  action: String((_ == null ? void 0 : _.action) ?? ""),
                  ok: !0,
                  durationMs: at,
                  resultLength: String(Ue ?? "").length
                }
              });
            } catch {
            }
            j.push(`Step ${S + 1} (${_.action}): ${Ue}`);
          } catch (de) {
            const ge = Date.now() - k;
            try {
              await tt.emit({
                eventId: Pe(),
                runId: M,
                ts: (/* @__PURE__ */ new Date()).toISOString(),
                type: "plan_step_end",
                name: "browser_execute_plan",
                data: {
                  planId: q,
                  stepId: $,
                  stepIndex: S,
                  action: String((_ == null ? void 0 : _.action) ?? ""),
                  ok: !1,
                  durationMs: ge,
                  errorMessage: String((de == null ? void 0 : de.message) ?? de)
                }
              });
            } catch {
            }
            return j.push(`Step ${S + 1} (${_.action}) FAILED: ${de.message}`), `Plan execution stopped at step ${S + 1} due to error.
Results so far:
${j.join(`
`)}`;
          }
        }
        return `Plan completed successfully.
${j.join(`
`)}`;
      }
    };
    he.register(t), he.register(n), he.register(s), he.register(a), he.register(i), he.register(c), he.register(l), he.register(h), he.register(p), he.register(m), he.register(g), he.register(T), he.register(x), he.register(O), he.register(R), he.register(E), he.register(V), he.register(ne), he.register(z), he.register(Te), he.register(Oe), he.register(U);
  }
}
const eR = new Q1(), Sf = [
  {
    id: "aerocore-dispatch",
    name: "AeroCore Dispatch",
    description: "Create and dispatch a new job in AeroCore Dispatch",
    userMessage: "Go to AeroCore Dispatch and create a new dispatch job for cargo delivery from Warehouse A to Terminal 1",
    expectedOutcome: { type: "text_present", value: "Warehouse A" },
    timeoutMs: 6e4
  },
  {
    id: "aerocore-fleet",
    name: "AeroCore Fleet",
    description: "Add a new drone to the fleet",
    userMessage: "Navigate to AeroCore Fleet and add a new drone with serial DR-001",
    expectedOutcome: { type: "text_present", value: "DR-001" },
    timeoutMs: 6e4
  },
  {
    id: "aerocore-workforce",
    name: "AeroCore Workforce",
    description: "Create a new employee profile",
    userMessage: "Go to AeroCore Workforce and create a new employee profile for Jane Doe",
    expectedOutcome: { type: "text_present", value: "Jane Doe" },
    timeoutMs: 6e4
  },
  {
    id: "aerocore-cargo",
    name: "AeroCore Cargo",
    description: "Create a new shipment",
    userMessage: "Navigate to AeroCore Cargo and create a new shipment with ID SH-9987",
    expectedOutcome: { type: "text_present", value: "SH-9987" },
    timeoutMs: 6e4
  },
  {
    id: "aerocore-security",
    name: "AeroCore Security",
    description: "Create a security incident report",
    userMessage: "Go to AeroCore Security and file a new security incident report",
    expectedOutcome: { type: "text_present", value: "Incident" },
    timeoutMs: 6e4
  },
  {
    id: "aerocore-admin",
    name: "AeroCore Admin",
    description: "Update system settings",
    userMessage: "Navigate to AeroCore Admin and update the system timezone to UTC",
    expectedOutcome: { type: "text_present", value: "UTC" },
    timeoutMs: 6e4
  },
  {
    id: "aerocore-portal",
    name: "AeroCore Portal",
    description: "Create a new portal announcement",
    userMessage: "Go to AeroCore Portal and create a new announcement about system maintenance",
    expectedOutcome: { type: "text_present", value: "maintenance" },
    timeoutMs: 6e4
  },
  {
    id: "aerocore-datalake",
    name: "AeroCore Datalake",
    description: "Run a data query",
    userMessage: "Navigate to AeroCore Datalake and run a query for recent logs",
    expectedOutcome: { type: "text_present", value: "logs" },
    timeoutMs: 6e4
  },
  // Personal Browser Scenarios
  {
    id: "personal-wikipedia",
    name: "Wikipedia Navigation",
    description: "Navigate to Wikipedia and find the Featured Article",
    userMessage: `Go to wikipedia.org and verify that the "From today's featured article" section is present.`,
    expectedOutcome: { type: "text_present", value: "From today's featured article" },
    timeoutMs: 6e4
  },
  {
    id: "personal-todomvc",
    name: "TodoMVC Interaction",
    description: "Add and complete tasks in a React Todo app",
    userMessage: 'Go to https://todomvc.com/examples/react/dist/. Add a new todo item called "Review Agent Performance" and then press Enter.',
    expectedOutcome: { type: "text_present", value: "Review Agent Performance" },
    timeoutMs: 6e4
  },
  {
    id: "personal-hn",
    name: "Hacker News Retrieval",
    description: "Navigate to Hacker News",
    userMessage: 'Go to news.ycombinator.com and find the "Hacker News" header.',
    expectedOutcome: { type: "text_present", value: "Hacker News" },
    timeoutMs: 45e3
  },
  {
    id: "personal-duckduckgo",
    name: "Search Engine Usage",
    description: "Search using DuckDuckGo",
    userMessage: 'Go to duckduckgo.com, type "Enterprise Browser" into the search box, and search.',
    expectedOutcome: { type: "url_match", value: "duckduckgo.com/?q=Enterprise+Browser" },
    timeoutMs: 6e4
  }
];
class tR {
  constructor() {
    b(this, "trajectory", []);
    b(this, "llmCalls", 0);
    b(this, "retries", 0);
  }
  async runSuite(e, t) {
    const n = e ? Sf.filter((a) => a.id.includes(e)) : Sf;
    console.log(`[Benchmark] Starting suite with ${n.length} scenarios (actionsPolicy=${t})...`);
    const s = [];
    for (const a of n) {
      console.log(`[Benchmark] Running scenario: ${a.name} (${a.id})`);
      const i = await this.runScenario(a, t);
      s.push(i), console.log(`[Benchmark] Scenario ${a.id} ${i.success ? "PASSED" : "FAILED"} in ${i.durationMs}ms (llmCalls=${i.llmCalls}, retries=${i.retries})`);
    }
    return s;
  }
  async runScenario(e, t) {
    const n = Pe(), s = Date.now();
    this.trajectory = [], this.llmCalls = 0, this.retries = 0;
    const a = (i) => {
      var o;
      this.trajectory.push({
        ts: (o = i.metadata) != null && o.ts ? new Date(i.metadata.ts).getTime() : Date.now(),
        type: i.type,
        content: i.content,
        metadata: i.metadata
      }), i.type === "llm_start" && this.llmCalls++;
    };
    try {
      await Ot.resetConversation(), Ot.toggleActionsPolicy(!!t), Ot.setStepHandler(a), await Ot.chat(e.userMessage);
      const i = await this.verifyOutcome(e);
      return {
        scenarioId: e.id,
        success: i,
        durationMs: Date.now() - s,
        steps: this.trajectory.length,
        llmCalls: this.llmCalls,
        retries: this.retries,
        runId: n,
        trajectory: [...this.trajectory]
      };
    } catch (i) {
      return {
        scenarioId: e.id,
        success: !1,
        durationMs: Date.now() - s,
        steps: this.trajectory.length,
        llmCalls: this.llmCalls,
        retries: this.retries,
        error: i.message,
        runId: n,
        trajectory: [...this.trajectory]
      };
    } finally {
      Ot.clearStepHandler();
    }
  }
  extractNormalizedPlan(e) {
    return e.filter((n) => {
      var s;
      return n.type === "action" && ((s = n.metadata) == null ? void 0 : s.tool);
    }).map((n) => {
      var a;
      const s = ((a = n.metadata) == null ? void 0 : a.toolArgs) ?? {};
      return {
        tool: n.metadata.tool,
        args: s,
        ts: n.ts
      };
    });
  }
  extractFeedbackLabels(e) {
    return e.filter((t) => {
      var n;
      return t.type === "observation" && ((n = t.content) == null ? void 0 : n.includes("Recorded"));
    }).map((t) => {
      var s;
      const n = (s = t.content) == null ? void 0 : s.match(/Recorded (worked|failed|partial)/i);
      return n ? n[1].toLowerCase() : void 0;
    }).filter(Boolean);
  }
  async exportTrajectories(e) {
    var i, o;
    const t = Ie.join(Bt.getPath("userData"), "benchmark_datasets");
    await Xe.mkdir(t, { recursive: !0 });
    const n = (/* @__PURE__ */ new Date()).toISOString().replace(/[:.]/g, "-"), s = Ie.join(t, `trajectories_${n}.jsonl`), a = [];
    for (const c of e) {
      if (!c.trajectory) continue;
      const u = this.extractNormalizedPlan(c.trajectory), l = this.extractFeedbackLabels(c.trajectory), d = (o = (i = c.trajectory.find((y) => {
        var m;
        return (m = y.metadata) == null ? void 0 : m.url;
      })) == null ? void 0 : i.metadata) == null ? void 0 : o.url, h = (() => {
        if (!d) return "unknown";
        try {
          return new URL(d).hostname;
        } catch {
          return "unknown";
        }
      })(), f = (() => {
        if (d)
          try {
            return new URL(d).pathname;
          } catch {
            return;
          }
      })(), p = {
        scenarioId: c.scenarioId,
        runId: c.runId,
        domain: h,
        fingerprint: f,
        normalizedPlan: u,
        steps: c.trajectory,
        outcome: c.success ? "success" : "failure",
        success: c.success,
        durationMs: c.durationMs,
        llmCalls: c.llmCalls,
        retries: c.retries,
        feedbackLabels: l
      };
      a.push(JSON.stringify(p));
    }
    return await Xe.writeFile(s, a.join(`
`), "utf8"), console.log(`[Benchmark] Exported ${e.length} trajectories to ${s}`), s;
  }
  async verifyOutcome(e) {
    const t = await eR.getTarget();
    return e.expectedOutcome.type === "text_present" ? !!await t.executeJavaScript(
      `document.body.innerText.includes(${JSON.stringify(e.expectedOutcome.value)})`,
      !0
    ) : e.expectedOutcome.type === "url_match" ? (await t.getURL()).includes(e.expectedOutcome.value) : !1;
  }
}
const wc = new tR(), rR = 2e3, Tf = 2e5, nR = /* @__PURE__ */ new Set([
  "node_modules",
  ".git",
  "dist",
  "build",
  ".next",
  ".turbo",
  ".cache"
]), Ef = (r, e) => {
  const t = Ie.relative(e, r);
  return t === "" || !t.startsWith(".." + Ie.sep) && t !== "..";
};
class sR {
  constructor() {
    b(this, "mockSaasSrcRoot", null);
    b(this, "mockSaasSrcRootReal", null);
    this.registerTools();
  }
  async pathExists(e) {
    try {
      return await Xe.stat(e), !0;
    } catch {
      return !1;
    }
  }
  async getMockSaasSrcRoot() {
    if (this.mockSaasSrcRoot && this.mockSaasSrcRootReal)
      return { root: this.mockSaasSrcRoot, rootReal: this.mockSaasSrcRootReal };
    const e = [];
    e.push(process.cwd()), e.push(Ie.dirname(process.cwd())), e.push(Ie.dirname(Ie.dirname(process.cwd())));
    try {
      e.push(Bt.getAppPath()), e.push(Ie.dirname(Bt.getAppPath())), e.push(Ie.dirname(Ie.dirname(Bt.getAppPath())));
    } catch {
    }
    for (const t of e) {
      const n = Ie.resolve(t, "mock-saas", "src");
      if (await this.pathExists(n)) {
        const s = await Xe.realpath(n);
        return this.mockSaasSrcRoot = n, this.mockSaasSrcRootReal = s, { root: n, rootReal: s };
      }
    }
    throw new Error(
      "mock-saas/src not found. This white-box tool only works when the repo contains mock-saas/src."
    );
  }
  normalizeUserPath(e) {
    return e.replace(/\\/g, "/").trim().replace(/^(\.\/)+/, "").replace(/^\/+/, "").replace(/^mock-saas\/src\//, "").replace(/^mock-saas\//, "").replace(/^src\//, "");
  }
  async resolvePathWithinMockSaasSrc(e) {
    const { rootReal: t } = await this.getMockSaasSrcRoot(), n = this.normalizeUserPath(e), s = Ie.resolve(t, n);
    if (!Ef(s, t))
      throw new Error("Path escapes mock-saas/src. Access denied.");
    return s;
  }
  async listFilesRecursive(e, t, n, s) {
    if (n.length >= t) return;
    const a = await Xe.readdir(e, { withFileTypes: !0 });
    for (const i of a) {
      if (n.length >= t) return;
      if (i.name.startsWith(".") || nR.has(i.name)) continue;
      const o = Ie.join(e, i.name);
      let c;
      try {
        c = await Xe.realpath(o);
      } catch {
        continue;
      }
      Ef(c, s) && (i.isDirectory() ? await this.listFilesRecursive(c, t, n, s) : i.isFile() && n.push(c));
    }
  }
  registerTools() {
    const e = ye({
      dir: H().optional().describe('Directory within mock-saas/src to list (default: ".")'),
      maxFiles: We().int().min(1).max(5e3).optional().describe("Max files to return (default 500)")
    }), t = {
      name: "code_list_files",
      description: "List files under mock-saas/src (white-box access). Ignores node_modules/dist. Returns paths relative to mock-saas/src.",
      schema: e,
      execute: async (o) => {
        const { dir: c, maxFiles: u } = e.parse(o ?? {}), { rootReal: l } = await this.getMockSaasSrcRoot(), d = await this.resolvePathWithinMockSaasSrc(c ?? "."), h = [];
        await this.listFilesRecursive(d, u ?? 500, h, l);
        const f = h.map((p) => Ie.relative(l, p).replace(/\\/g, "/")).sort();
        return JSON.stringify(
          {
            root: "mock-saas/src",
            dir: (c ?? ".").replace(/\\/g, "/"),
            count: f.length,
            files: f
          },
          null,
          2
        );
      }
    }, n = ye({
      path: H().describe('File path within mock-saas/src (e.g. "pages/jira/JiraPage.tsx")'),
      startLine: We().int().min(1).optional().describe("Start line (1-based)"),
      maxLines: We().int().min(1).max(2e3).optional().describe("Max lines to return (default 200)"),
      maxBytes: We().int().min(1).max(2e6).optional().describe("Max bytes to read (default 200k)")
    }), s = {
      name: "code_read_file",
      description: "Read a file from mock-saas/src (white-box access). Use this to discover data-testid selectors and UI state logic.",
      schema: n,
      execute: async (o) => {
        const { path: c, startLine: u, maxLines: l, maxBytes: d } = n.parse(o), { rootReal: h } = await this.getMockSaasSrcRoot(), f = await this.resolvePathWithinMockSaasSrc(c), p = await Xe.stat(f);
        if (!p.isFile()) throw new Error("Not a file.");
        if (p.size > (d ?? Tf))
          throw new Error(
            `File too large (${p.size} bytes). Increase maxBytes (<=2,000,000) or read a smaller file.`
          );
        const m = (await Xe.readFile(f, "utf8")).split(/\r?\n/), v = m.length, g = Math.max(1, u ?? 1), T = Math.min(v, g + (l ?? 200) - 1), x = m.slice(g - 1, T).join(`
`);
        return JSON.stringify(
          {
            root: "mock-saas/src",
            path: Ie.relative(h, f).replace(/\\/g, "/"),
            totalLines: v,
            startLine: g,
            endLine: T,
            content: x
          },
          null,
          2
        );
      }
    }, a = ye({
      query: H().min(1).describe("Text to search for"),
      dir: H().optional().describe('Directory within mock-saas/src to search (default ".")'),
      maxResults: We().int().min(1).max(200).optional().describe("Max matches to return (default 20)"),
      caseSensitive: Zi().optional().describe("Case-sensitive search (default false)"),
      maxFiles: We().int().min(1).max(5e3).optional().describe("Max files to scan (default 2000)")
    }), i = {
      name: "code_search",
      description: "Search for text within mock-saas/src (white-box access). Returns file/line previews to quickly find relevant components.",
      schema: a,
      execute: async (o) => {
        const { query: c, dir: u, maxResults: l, caseSensitive: d, maxFiles: h } = a.parse(o), { rootReal: f } = await this.getMockSaasSrcRoot(), p = await this.resolvePathWithinMockSaasSrc(u ?? "."), y = [];
        await this.listFilesRecursive(p, h ?? rR, y, f);
        const m = d ? c : c.toLowerCase(), v = l ?? 20, g = [];
        for (const w of y) {
          if (g.length >= v) break;
          let T;
          try {
            T = await Xe.stat(w);
          } catch {
            continue;
          }
          if (!T.isFile() || T.size > Tf * 2) continue;
          let x;
          try {
            x = await Xe.readFile(w, "utf8");
          } catch {
            continue;
          }
          const O = x.split(/\r?\n/);
          for (let R = 0; R < O.length && !(g.length >= v); R++)
            (d ? O[R] : O[R].toLowerCase()).includes(m) && g.push({
              path: Ie.relative(f, w).replace(/\\/g, "/"),
              line: R + 1,
              preview: O[R].trim().slice(0, 200)
            });
        }
        return JSON.stringify(
          {
            root: "mock-saas/src",
            dir: (u ?? ".").replace(/\\/g, "/"),
            query: c,
            count: g.length,
            matches: g
          },
          null,
          2
        );
      }
    };
    he.register(t), he.register(s), he.register(i);
  }
}
new sR();
class aR {
  constructor() {
    b(this, "issues", [
      {
        key: "PROJ-1",
        summary: "Fix login page layout",
        description: "The login button is misaligned on mobile devices.",
        status: "To Do",
        assignee: "jdoe"
      },
      {
        key: "PROJ-2",
        summary: "Update API documentation",
        description: "The /v2/users endpoint docs are outdated.",
        status: "In Progress",
        assignee: "smitchell"
      },
      {
        key: "PROJ-3",
        summary: "Investigate server crash",
        description: "Server 3 crashed with OOM error last night.",
        status: "Done",
        assignee: "jdoe"
      }
    ]);
    this.registerTools();
  }
  async simulateDelay() {
    await new Promise((e) => setTimeout(e, 500));
  }
  registerTools() {
    const e = {
      name: "jira_list_issues",
      description: "List all Jira issues, optionally filtered by status.",
      schema: ye({
        status: H().optional().describe("Filter by status (To Do, In Progress, Done)")
      }),
      execute: async ({ status: s }) => {
        await this.simulateDelay();
        let a = this.issues;
        return s && (a = a.filter((i) => i.status.toLowerCase() === s.toLowerCase())), JSON.stringify(a, null, 2);
      }
    }, t = {
      name: "jira_get_issue",
      description: "Get details of a specific Jira issue by key.",
      schema: ye({
        key: H().describe("The issue key (e.g., PROJ-1)")
      }),
      execute: async ({ key: s }) => {
        await this.simulateDelay();
        const a = this.issues.find((i) => i.key === s);
        return a ? JSON.stringify(a, null, 2) : `Issue ${s} not found.`;
      }
    }, n = {
      name: "jira_create_issue",
      description: "Create a new Jira issue.",
      requiresApproval: !0,
      schema: ye({
        summary: H().describe("The issue summary/title"),
        description: H().describe("The issue description"),
        assignee: H().optional().describe("The user to assign the issue to")
      }),
      execute: async ({ summary: s, description: a, assignee: i }) => {
        await this.simulateDelay();
        const o = `PROJ-${this.issues.length + 1}`, c = {
          key: o,
          summary: s,
          description: a,
          status: "To Do",
          assignee: i || "unassigned"
        };
        return this.issues.push(c), `Successfully created issue ${o}`;
      }
    };
    he.register(e), he.register(t), he.register(n);
  }
}
new aR();
class iR {
  constructor() {
    b(this, "pages", [
      {
        id: "1001",
        title: "Project Phoenix Architecture",
        space: "ENG",
        content: "Project Phoenix aims to unify the browser experience. Key components: Electron, React, LangChain.",
        lastUpdated: "2023-10-01"
      },
      {
        id: "1002",
        title: "Q4 Marketing Strategy",
        space: "MKT",
        content: "Focus on enterprise decision makers. Channels: LinkedIn, TechCrunch, Industry Events.",
        lastUpdated: "2023-10-15"
      },
      {
        id: "1003",
        title: "Employee Onboarding Guide",
        space: "HR",
        content: "Welcome to the team! 1. Setup email. 2. Join Slack. 3. Read the handbook.",
        lastUpdated: "2023-09-20"
      }
    ]);
    this.registerTools();
  }
  async simulateDelay() {
    await new Promise((e) => setTimeout(e, 500));
  }
  registerTools() {
    const e = {
      name: "confluence_search",
      description: "Search for Confluence pages by title or content.",
      schema: ye({
        query: H().describe("Search query string")
      }),
      execute: async ({ query: s }) => {
        await this.simulateDelay();
        const a = s.toLowerCase(), i = this.pages.filter(
          (o) => o.title.toLowerCase().includes(a) || o.content.toLowerCase().includes(a)
        ).map(({ content: o, ...c }) => c);
        return JSON.stringify(i, null, 2);
      }
    }, t = {
      name: "confluence_read_page",
      description: "Read the full content of a Confluence page.",
      schema: ye({
        id: H().describe("The page ID (e.g., 1001)")
      }),
      execute: async ({ id: s }) => {
        await this.simulateDelay();
        const a = this.pages.find((i) => i.id === s);
        return a ? JSON.stringify(a, null, 2) : `Page ${s} not found.`;
      }
    }, n = {
      name: "confluence_create_page",
      description: "Create a new Confluence page.",
      schema: ye({
        title: H().describe("Page title"),
        space: H().describe("Space key (e.g. ENG, HR)"),
        content: H().describe("Page content")
      }),
      execute: async ({ title: s, space: a, content: i }) => {
        await this.simulateDelay();
        const o = (1e3 + this.pages.length + 1).toString();
        return this.pages.push({
          id: o,
          title: s,
          space: a,
          content: i,
          lastUpdated: (/* @__PURE__ */ new Date()).toISOString().split("T")[0]
        }), `Created page ${o}: "${s}" in space ${a}`;
      }
    };
    he.register(e), he.register(t), he.register(n);
  }
}
new iR();
class oR {
  constructor() {
    b(this, "boards", [
      {
        id: "board-1",
        name: "Product Roadmap",
        lists: [
          { id: "list-1", name: "Backlog" },
          { id: "list-2", name: "Doing" },
          { id: "list-3", name: "Done" }
        ],
        cards: [
          { id: "card-1", title: "Research competitors", listId: "list-1" },
          { id: "card-2", title: "Design new logo", listId: "list-2" }
        ]
      }
    ]);
    this.registerTools();
  }
  async simulateDelay() {
    await new Promise((e) => setTimeout(e, 500));
  }
  registerTools() {
    const e = {
      name: "trello_get_board",
      description: "Get details of a Trello board, including lists and cards.",
      schema: ye({
        id: H().describe("The board ID (e.g., board-1)")
      }),
      execute: async ({ id: s }) => {
        await this.simulateDelay();
        const a = this.boards.find((i) => i.id === s);
        return a ? JSON.stringify(a, null, 2) : `Board ${s} not found.`;
      }
    }, t = {
      name: "trello_move_card",
      description: "Move a Trello card to a different list.",
      schema: ye({
        cardId: H().describe("The ID of the card to move"),
        targetListId: H().describe("The ID of the destination list")
      }),
      execute: async ({ cardId: s, targetListId: a }) => {
        await this.simulateDelay();
        for (const i of this.boards) {
          const o = i.cards.find((c) => c.id === s);
          if (o)
            return i.lists.some((u) => u.id === a) ? (o.listId = a, `Successfully moved card ${s} to list ${a}`) : `List ${a} not found on this board.`;
        }
        return `Card ${s} not found.`;
      }
    }, n = {
      name: "trello_create_card",
      description: "Create a new Trello card.",
      schema: ye({
        boardId: H().describe("Board ID"),
        listId: H().describe("List ID"),
        title: H().describe("Card title")
      }),
      execute: async ({ boardId: s, listId: a, title: i }) => {
        await this.simulateDelay();
        const o = this.boards.find((l) => l.id === s);
        if (!o) return `Board ${s} not found`;
        const c = o.lists.find((l) => l.id === a);
        if (!c) return `List ${a} not found`;
        const u = `card-${Date.now()}`;
        return o.cards.push({ id: u, title: i, listId: a }), `Created card ${u}: "${i}" in list ${c.name}`;
      }
    };
    he.register(e), he.register(t), he.register(n);
  }
}
new oR();
class cR {
  constructor() {
    this.registerTools();
  }
  registerTools() {
    const t = {
      name: "api_github_search",
      description: "Search GitHub repositories, users, or code via API. MUCH faster than browser automation. Returns repo names, stars, descriptions. Use this instead of navigating to github.com for search tasks.",
      schema: ye({
        query: H().describe('Search query (e.g., "langchain", "react")'),
        type: rn(["repositories", "users", "code"]).optional().describe("Type of search (default: repositories)"),
        sort: rn(["stars", "forks", "updated", "best-match"]).optional().describe("Sort by (default: best-match)"),
        limit: We().optional().describe("Number of results to return (default: 5, max: 10)")
      }),
      execute: async ({ query: d, type: h = "repositories", sort: f = "stars", limit: p = 5 }) => {
        try {
          const y = h === "repositories" ? "repositories" : h === "users" ? "users" : "code", m = `https://api.github.com/search/${y}?q=${encodeURIComponent(d)}&sort=${f}&order=desc&per_page=${Math.min(p, 10)}`, v = await fetch(m, {
            headers: {
              Accept: "application/vnd.github.v3+json",
              "User-Agent": "EnterpriseBrowser/1.0"
            }
          });
          if (!v.ok)
            return v.status === 403 ? JSON.stringify({ error: "Rate limited. Try browser_navigate to https://github.com/search?q=" + encodeURIComponent(d) + "&type=repositories&s=stars&o=desc instead." }) : JSON.stringify({ error: `GitHub API error: ${v.status} ${v.statusText}` });
          const g = await v.json();
          if (y === "repositories") {
            const w = g.items.slice(0, p).map((T) => {
              var x;
              return {
                name: T.full_name,
                stars: T.stargazers_count,
                forks: T.forks_count,
                description: ((x = T.description) == null ? void 0 : x.slice(0, 100)) || "",
                url: T.html_url,
                language: T.language
              };
            });
            return JSON.stringify({ total_count: g.total_count, results: w }, null, 2);
          } else if (y === "users") {
            const w = g.items.slice(0, p).map((T) => ({
              login: T.login,
              url: T.html_url,
              type: T.type
            }));
            return JSON.stringify({ total_count: g.total_count, results: w }, null, 2);
          }
          return JSON.stringify({ total_count: g.total_count, items: g.items.slice(0, p) }, null, 2);
        } catch (y) {
          return JSON.stringify({ error: `Failed to search GitHub: ${y.message}` });
        }
      }
    }, s = {
      name: "api_hackernews_top",
      description: "Get top stories from Hacker News via API. Returns titles, scores, URLs. Use this instead of navigating to news.ycombinator.com.",
      schema: ye({
        limit: We().optional().describe("Number of stories to return (default: 5, max: 30)")
      }),
      execute: async ({ limit: d = 5 }) => {
        try {
          const h = await fetch("https://hacker-news.firebaseio.com/v0/topstories.json");
          if (!h.ok)
            return JSON.stringify({ error: "Failed to fetch HN top stories" });
          const f = await h.json(), p = Math.min(d, 30), m = (await Promise.all(
            f.slice(0, p).map(async (v) => (await fetch(`https://hacker-news.firebaseio.com/v0/item/${v}.json`)).json())
          )).map((v) => ({
            title: v.title,
            score: v.score,
            url: v.url || `https://news.ycombinator.com/item?id=${v.id}`,
            by: v.by,
            comments: v.descendants || 0
          }));
          return JSON.stringify({ results: m }, null, 2);
        } catch (h) {
          return JSON.stringify({ error: `Failed to fetch HN stories: ${h.message}` });
        }
      }
    }, i = {
      name: "api_wikipedia_featured",
      description: "Get today's featured article from Wikipedia via API. Use this instead of navigating to wikipedia.org.",
      schema: ye({}),
      execute: async () => {
        var d, h, f, p, y, m;
        try {
          const v = /* @__PURE__ */ new Date(), g = v.getFullYear(), w = String(v.getMonth() + 1).padStart(2, "0"), T = String(v.getDate()).padStart(2, "0"), x = `https://api.wikimedia.org/feed/v1/wikipedia/en/featured/${g}/${w}/${T}`, O = await fetch(x, {
            headers: {
              "User-Agent": "EnterpriseBrowser/1.0"
            }
          });
          if (!O.ok)
            return JSON.stringify({ error: `Wikipedia API error: ${O.status}` });
          const R = await O.json(), E = {
            title: ((d = R.tfa) == null ? void 0 : d.title) || "Unknown",
            extract: ((f = (h = R.tfa) == null ? void 0 : h.extract) == null ? void 0 : f.slice(0, 500)) || "",
            url: ((m = (y = (p = R.tfa) == null ? void 0 : p.content_urls) == null ? void 0 : y.desktop) == null ? void 0 : m.page) || ""
          };
          return JSON.stringify(E, null, 2);
        } catch (v) {
          return JSON.stringify({ error: `Failed to fetch Wikipedia featured: ${v.message}` });
        }
      }
    }, c = {
      name: "api_http_get",
      description: "Make a simple HTTP GET request to any URL. Returns the response body. Useful for APIs that return JSON.",
      schema: ye({
        url: H().describe("URL to fetch"),
        headers: HA(H(), H()).optional().describe("Optional headers")
      }),
      execute: async ({ url: d, headers: h = {} }) => {
        try {
          const f = await fetch(d, {
            headers: {
              "User-Agent": "EnterpriseBrowser/1.0",
              ...h
            }
          });
          if (!f.ok)
            return JSON.stringify({ error: `HTTP ${f.status}: ${f.statusText}` });
          if ((f.headers.get("content-type") || "").includes("application/json")) {
            const m = await f.json();
            return JSON.stringify(m, null, 2);
          }
          return (await f.text()).slice(0, 5e3);
        } catch (f) {
          return JSON.stringify({ error: `HTTP request failed: ${f.message}` });
        }
      }
    }, l = {
      name: "api_crypto_price",
      description: "Get current cryptocurrency price via CoinGecko API. Use this instead of navigating to coinmarketcap.com or other crypto sites. Returns price in USD, 24h change, and market cap.",
      schema: ye({
        coin: H().describe('Cryptocurrency name or symbol (e.g., "bitcoin", "ethereum", "btc", "eth")')
      }),
      execute: async ({ coin: d }) => {
        var h;
        try {
          const p = {
            btc: "bitcoin",
            eth: "ethereum",
            sol: "solana",
            doge: "dogecoin",
            xrp: "ripple",
            ada: "cardano",
            dot: "polkadot",
            matic: "polygon",
            link: "chainlink",
            avax: "avalanche-2"
          }[d.toLowerCase()] || d.toLowerCase(), y = `https://api.coingecko.com/api/v3/simple/price?ids=${p}&vs_currencies=usd&include_24hr_change=true&include_market_cap=true`, m = await fetch(y, {
            headers: {
              "User-Agent": "EnterpriseBrowser/1.0"
            }
          });
          if (!m.ok)
            return JSON.stringify({ error: `CoinGecko API error: ${m.status}` });
          const v = await m.json();
          if (!v[p])
            return JSON.stringify({ error: `Coin '${d}' not found. Try the full name (e.g., 'bitcoin' instead of 'btc').` });
          const g = v[p], w = {
            coin: p,
            price_usd: g.usd,
            change_24h_percent: ((h = g.usd_24h_change) == null ? void 0 : h.toFixed(2)) + "%",
            market_cap_usd: g.usd_market_cap
          };
          return JSON.stringify(w, null, 2);
        } catch (f) {
          return JSON.stringify({ error: `Failed to fetch crypto price: ${f.message}` });
        }
      }
    };
    he.register(t), he.register(s), he.register(i), he.register(c), he.register(l);
  }
}
new cR();
const hy = Ie.dirname(yy(import.meta.url));
process.env.APP_ROOT = Ie.join(hy, "..");
const Eu = process.env.VITE_DEV_SERVER_URL, XR = Ie.join(process.env.APP_ROOT, "dist-electron"), fy = Ie.join(process.env.APP_ROOT, "dist");
process.env.VITE_PUBLIC = Eu ? Ie.join(process.env.APP_ROOT, "public") : fy;
let Pr;
const Wa = /* @__PURE__ */ new Map(), xf = 3e4;
function py() {
  Pr = new xu({
    icon: Ie.join(process.env.VITE_PUBLIC, "electron-vite.svg"),
    webPreferences: {
      preload: Ie.join(hy, "preload.mjs"),
      webviewTag: !0
    }
  }), Pr.webContents.on("did-finish-load", () => {
    Pr == null || Pr.webContents.send("main-process-message", (/* @__PURE__ */ new Date()).toLocaleString());
  }), Eu ? (Pr.loadURL(Eu), Pr.webContents.openDevTools()) : Pr.loadFile(Ie.join(fy, "index.html"));
}
process.env.ENABLE_ELECTRON_REMOTE_DEBUGGING === "true" && Bt.commandLine.appendSwitch("remote-debugging-port", "9222");
Bt.on("window-all-closed", () => {
  process.platform !== "darwin" && (Bt.quit(), Pr = null);
});
Bt.on("activate", () => {
  xu.getAllWindows().length === 0 && py();
});
Bt.whenReady().then(() => {
  const r = new W1(tt, yt);
  he.setPolicyService(r), Ge.on("agent:approval-response", (e, t) => {
    var i;
    const n = t == null ? void 0 : t.requestId, s = !!(t != null && t.approved);
    if (typeof n != "string") return;
    const a = Wa.get(n);
    a && ((i = e.sender) == null ? void 0 : i.id) === a.requesterWebContentsId && (clearTimeout(a.timeout), Wa.delete(n), a.resolve(s));
  }), he.setApprovalHandler(async (e, t) => {
    const n = ft.getRunId(), s = ft.getRequesterWebContentsId();
    if (!s) return !1;
    const a = Vs.fromId(s);
    if (!a || a.isDestroyed()) return !1;
    const i = Pe(), o = Date.now();
    return a.send("agent:request-approval", { requestId: i, toolName: e, args: t, runId: n, timeoutMs: xf }), await new Promise((c) => {
      const u = setTimeout(() => {
        Wa.delete(i);
        try {
          const l = Vs.fromId(s);
          l && !l.isDestroyed() && l.send("agent:approval-timeout", { requestId: i, toolName: e, runId: n });
        } catch {
        }
        c(!1);
      }, xf);
      Wa.set(i, {
        requestId: i,
        runId: n,
        toolName: e,
        requesterWebContentsId: s,
        createdAt: o,
        timeout: u,
        resolve: c
      });
    });
  }), Ge.handle("browser:webview-register", async (e, { tabId: t, webContentsId: n }) => {
    Ns.registerWebview(t, n);
  }), Ge.handle("browser:active-tab", async (e, { tabId: t }) => {
    Ns.setActiveTab(t ?? null);
  }), Ge.handle("vault:set", async (e, t, n) => await Ps.setSecret(t, n)), Ge.handle("vault:get", async (e, t) => await Ps.getSecret(t)), Ge.handle("vault:delete", async (e, t) => await Ps.deleteSecret(t)), Ge.handle("audit:get-logs", async (e, t) => yt.getLogs(typeof t == "number" ? t : 100).map((s) => {
    const a = (() => {
      try {
        return JSON.parse(s.details);
      } catch {
        return s.details;
      }
    })();
    return { ...s, details: a };
  })), Ge.handle("agent:feedback", async (e, t) => {
    const n = t, s = n == null ? void 0 : n.skillId;
    if (typeof s != "string") return !1;
    const a = n == null ? void 0 : n.label, i = n == null ? void 0 : n.version, o = n == null ? void 0 : n.success;
    if (a === "worked" || a === "failed" || a === "partial") {
      const c = typeof i == "number" ? i : void 0;
      return typeof Ga.recordFeedback == "function" ? (Ga.recordFeedback(
        s,
        a,
        c
      ), !0) : (Ga.recordOutcome(s, a === "worked"), !0);
    }
    return typeof o == "boolean" ? (Ga.recordOutcome(s, o), !0) : !1;
  }), Ge.handle("telemetry:export", async () => {
    const e = Ie.join(Bt.getPath("userData"), "trajectories_export.json");
    return { success: !0, count: await tt.exportTrajectories(e), path: e };
  }), Ge.handle("benchmark:runSuite", async (e, t) => await wc.runSuite(t)), Ge.handle("benchmark:runSuiteWithFlag", async (e, t, n) => await wc.runSuite(t, n)), Ge.handle("benchmark:exportTrajectories", async (e, t) => ({ success: !0, path: await wc.exportTrajectories(t) })), Ge.handle("agent:chat", async (e, t) => {
    const n = Pe();
    try {
      e.sender.send("agent:step", {
        type: "observation",
        content: `Run started: ${n}`,
        metadata: { runId: n, ts: (/* @__PURE__ */ new Date()).toISOString() }
      });
    } catch {
    }
    let s, a;
    try {
      const c = Ns.getActiveWebContents();
      if (c && !c.isDestroyed() && (s = c.getURL(), s))
        try {
          const u = new URL(s);
          a = u.hostname, u.port && (a += `:${u.port}`);
        } catch {
        }
    } catch {
    }
    try {
      await tt.emit({
        eventId: Pe(),
        runId: n,
        ts: (/* @__PURE__ */ new Date()).toISOString(),
        type: "agent_run_start",
        name: "agent:chat",
        data: { messageLength: String(t ?? "").length }
      });
    } catch {
    }
    await yt.log({
      actor: "user",
      action: "chat_message",
      details: { message: t, runId: n },
      status: "success"
    }), Ot.setStepHandler((c) => {
      e.sender.send("agent:step", c);
      try {
        const u = c == null ? void 0 : c.metadata, l = u == null ? void 0 : u.tool, d = u == null ? void 0 : u.args, h = String((c == null ? void 0 : c.content) ?? ""), f = h.length, p = nn.createHash("sha256").update(h).digest("hex"), y = f > 2e3 ? h.slice(0, 2e3) : h, m = (() => {
          try {
            return JSON.stringify(d ?? null);
          } catch {
            return "[unserializable_args]";
          }
        })(), v = nn.createHash("sha256").update(m).digest("hex"), g = u ? {
          ...u,
          ...d !== void 0 ? { args: void 0, argsHash: v } : null
        } : void 0;
        yt.log({
          actor: "agent",
          action: "agent_step",
          details: {
            runId: n,
            type: c == null ? void 0 : c.type,
            toolName: l,
            contentPreview: y,
            contentLength: f,
            contentHash: p,
            argsHash: d !== void 0 ? v : void 0,
            metadata: g
          },
          status: "success"
        }).catch(() => {
        });
      } catch {
      }
    });
    let i = "Current browser state: No active tab";
    try {
      const c = Ns.getActiveWebContents(), u = c.getURL(), l = c.getTitle();
      i = `Current browser state: URL="${u}", Title="${l}"`;
    } catch {
    }
    let o = "";
    try {
      const c = Ot.isYoloMode();
      o = await ft.run(
        { runId: n, requesterWebContentsId: e.sender.id, browserContext: { url: s, domain: a }, yoloMode: c },
        async () => await Ot.chat(t, i)
      );
    } finally {
      try {
        await tt.emit({
          eventId: Pe(),
          runId: n,
          ts: (/* @__PURE__ */ new Date()).toISOString(),
          type: "agent_run_end",
          name: "agent:chat",
          data: { responseLength: o.length }
        });
      } catch {
      }
    }
    return await yt.log({
      actor: "agent",
      action: "chat_response",
      details: { response: o, runId: n },
      status: "success"
    }), o;
  }), Ge.handle("agent:reset-conversation", async () => (Ot.resetConversation(), { success: !0 })), Ge.handle("agent:get-models", async () => Bn), Ge.handle("agent:get-current-model", async () => Ot.getCurrentModelId()), Ge.handle("agent:set-model", async (e, t) => (Ot.setModel(t), { success: !0, modelId: t })), Ge.handle("agent:set-mode", async (e, t) => (Ot.setAgentMode(t), { success: !0 })), Ge.handle("agent:get-mode", async () => Ot.getAgentMode()), Ge.handle("agent:set-permission-mode", async (e, t) => (Ot.setPermissionMode(t), { success: !0 })), Ge.handle("agent:get-permission-mode", async () => Ot.getPermissionMode()), Ge.handle("browser:navigate-tab", async (e, t) => {
    const n = xu.getAllWindows()[0];
    return n ? (n.webContents.send("browser:navigate-to", t), { success: !0, url: t }) : { success: !1, error: "No window found" };
  }), py();
});
export {
  XR as MAIN_DIST,
  fy as RENDERER_DIST,
  Eu as VITE_DEV_SERVER_URL
};
