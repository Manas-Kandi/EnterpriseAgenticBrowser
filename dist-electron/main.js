var my = Object.defineProperty;
var gy = (r, e, t) => e in r ? my(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t;
var v = (r, e, t) => gy(r, typeof e != "symbol" ? e + "" : e, t);
import { app as Bt, webContents as Bs, BrowserWindow as Eu, ipcMain as We } from "electron";
import { URL as _y, fileURLToPath as yy } from "node:url";
import ke from "node:path";
import rn, { randomFillSync as wy, randomUUID as vy } from "node:crypto";
import Mo from "keytar";
import by from "fs";
import If from "path";
import Sy from "os";
import ps from "crypto";
import { AsyncLocalStorage as Ty } from "node:async_hooks";
import Ke from "node:fs/promises";
import Ey from "better-sqlite3";
const mt = [];
for (let r = 0; r < 256; ++r)
  mt.push((r + 256).toString(16).slice(1));
function xy(r, e = 0) {
  return (mt[r[e + 0]] + mt[r[e + 1]] + mt[r[e + 2]] + mt[r[e + 3]] + "-" + mt[r[e + 4]] + mt[r[e + 5]] + "-" + mt[r[e + 6]] + mt[r[e + 7]] + "-" + mt[r[e + 8]] + mt[r[e + 9]] + "-" + mt[r[e + 10]] + mt[r[e + 11]] + mt[r[e + 12]] + mt[r[e + 13]] + mt[r[e + 14]] + mt[r[e + 15]]).toLowerCase();
}
const Ga = new Uint8Array(256);
let va = Ga.length;
function Iy() {
  return va > Ga.length - 16 && (wy(Ga), va = 0), Ga.slice(va, va += 16);
}
const Wl = { randomUUID: vy };
function ky(r, e, t) {
  var s;
  r = r || {};
  const n = r.random ?? ((s = r.rng) == null ? void 0 : s.call(r)) ?? Iy();
  if (n.length < 16)
    throw new Error("Random bytes length must be >= 16");
  return n[6] = n[6] & 15 | 64, n[8] = n[8] & 63 | 128, xy(n);
}
function Pe(r, e, t) {
  return Wl.randomUUID && !r ? Wl.randomUUID() : ky(r);
}
class Oy {
  constructor() {
    v(this, "serviceName", "EnterpriseAgenticBrowser");
  }
  async setSecret(e, t) {
    await Mo.setPassword(this.serviceName, e, t);
  }
  async getSecret(e) {
    return await Mo.getPassword(this.serviceName, e);
  }
  async deleteSecret(e) {
    return await Mo.deletePassword(this.serviceName, e);
  }
}
const Rs = new Oy();
function ba(r, e) {
  return r.lc_error_code = e, r.message = `${r.message}

Troubleshooting URL: https://docs.langchain.com/oss/javascript/langchain/errors/${e}/
`, r;
}
function he(r, e, t, n, s) {
  if (typeof e == "function" ? r !== e || !0 : !e.has(r))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return e.set(r, t), t;
}
function k(r, e, t, n) {
  if (t === "a" && !n)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof e == "function" ? r !== e || !n : !e.has(r))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return t === "m" ? n : t === "a" ? n.call(r) : n ? n.value : e.get(r);
}
let kf = function() {
  const { crypto: r } = globalThis;
  if (r != null && r.randomUUID)
    return kf = r.randomUUID.bind(r), r.randomUUID();
  const e = new Uint8Array(1), t = r ? () => r.getRandomValues(e)[0] : () => Math.random() * 255 & 255;
  return "10000000-1000-4000-8000-100000000000".replace(/[018]/g, (n) => (+n ^ t() & 15 >> +n / 4).toString(16));
};
function wc(r) {
  return typeof r == "object" && r !== null && // Spec-compliant fetch implementations
  ("name" in r && r.name === "AbortError" || // Expo fetch
  "message" in r && String(r.message).includes("FetchRequestCanceledException"));
}
const vc = (r) => {
  if (r instanceof Error)
    return r;
  if (typeof r == "object" && r !== null) {
    try {
      if (Object.prototype.toString.call(r) === "[object Error]") {
        const e = new Error(r.message, r.cause ? { cause: r.cause } : {});
        return r.stack && (e.stack = r.stack), r.cause && !e.cause && (e.cause = r.cause), r.name && (e.name = r.name), e;
      }
    } catch {
    }
    try {
      return new Error(JSON.stringify(r));
    } catch {
    }
  }
  return new Error(r);
};
class ce extends Error {
}
class St extends ce {
  constructor(e, t, n, s) {
    super(`${St.makeMessage(e, t, n)}`), this.status = e, this.headers = s, this.requestID = s == null ? void 0 : s.get("x-request-id"), this.error = t;
    const a = t;
    this.code = a == null ? void 0 : a.code, this.param = a == null ? void 0 : a.param, this.type = a == null ? void 0 : a.type;
  }
  static makeMessage(e, t, n) {
    const s = t != null && t.message ? typeof t.message == "string" ? t.message : JSON.stringify(t.message) : t ? JSON.stringify(t) : n;
    return e && s ? `${e} ${s}` : e ? `${e} status code (no body)` : s || "(no status code or body)";
  }
  static generate(e, t, n, s) {
    if (!e || !s)
      return new Wi({ message: n, cause: vc(t) });
    const a = t == null ? void 0 : t.error;
    return e === 400 ? new Of(e, a, n, s) : e === 401 ? new Af(e, a, n, s) : e === 403 ? new $f(e, a, n, s) : e === 404 ? new Cf(e, a, n, s) : e === 409 ? new Rf(e, a, n, s) : e === 422 ? new Nf(e, a, n, s) : e === 429 ? new Pf(e, a, n, s) : e >= 500 ? new Lf(e, a, n, s) : new St(e, a, n, s);
  }
}
class Ut extends St {
  constructor({ message: e } = {}) {
    super(void 0, void 0, e || "Request was aborted.", void 0);
  }
}
class Wi extends St {
  constructor({ message: e, cause: t }) {
    super(void 0, void 0, e || "Connection error.", void 0), t && (this.cause = t);
  }
}
class Gi extends Wi {
  constructor({ message: e } = {}) {
    super({ message: e ?? "Request timed out." });
  }
}
class Of extends St {
}
class Af extends St {
}
class $f extends St {
}
class Cf extends St {
}
class Rf extends St {
}
class Nf extends St {
}
class Pf extends St {
}
class Lf extends St {
}
class Mf extends ce {
  constructor() {
    super("Could not parse response content as the length limit was reached");
  }
}
class Df extends ce {
  constructor() {
    super("Could not parse response content as the request was rejected by the content filter");
  }
}
class ms extends Error {
  constructor(e) {
    super(e);
  }
}
const Ay = /^[a-z][a-z0-9+.-]*:/i, $y = (r) => Ay.test(r);
let Rt = (r) => (Rt = Array.isArray, Rt(r)), Gl = Rt;
function jf(r) {
  return typeof r != "object" ? {} : r ?? {};
}
function Cy(r) {
  if (!r)
    return !0;
  for (const e in r)
    return !1;
  return !0;
}
function Ry(r, e) {
  return Object.prototype.hasOwnProperty.call(r, e);
}
function Do(r) {
  return r != null && typeof r == "object" && !Array.isArray(r);
}
const Ny = (r, e) => {
  if (typeof e != "number" || !Number.isInteger(e))
    throw new ce(`${r} must be an integer`);
  if (e < 0)
    throw new ce(`${r} must be a positive integer`);
  return e;
}, Py = (r) => {
  try {
    return JSON.parse(r);
  } catch {
    return;
  }
}, ra = (r) => new Promise((e) => setTimeout(e, r)), Mn = "6.10.0", Ly = () => (
  // @ts-ignore
  typeof window < "u" && // @ts-ignore
  typeof window.document < "u" && // @ts-ignore
  typeof navigator < "u"
);
function My() {
  return typeof Deno < "u" && Deno.build != null ? "deno" : typeof EdgeRuntime < "u" ? "edge" : Object.prototype.toString.call(typeof globalThis.process < "u" ? globalThis.process : 0) === "[object process]" ? "node" : "unknown";
}
const Dy = () => {
  var t;
  const r = My();
  if (r === "deno")
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": Mn,
      "X-Stainless-OS": Yl(Deno.build.os),
      "X-Stainless-Arch": Kl(Deno.build.arch),
      "X-Stainless-Runtime": "deno",
      "X-Stainless-Runtime-Version": typeof Deno.version == "string" ? Deno.version : ((t = Deno.version) == null ? void 0 : t.deno) ?? "unknown"
    };
  if (typeof EdgeRuntime < "u")
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": Mn,
      "X-Stainless-OS": "Unknown",
      "X-Stainless-Arch": `other:${EdgeRuntime}`,
      "X-Stainless-Runtime": "edge",
      "X-Stainless-Runtime-Version": globalThis.process.version
    };
  if (r === "node")
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": Mn,
      "X-Stainless-OS": Yl(globalThis.process.platform ?? "unknown"),
      "X-Stainless-Arch": Kl(globalThis.process.arch ?? "unknown"),
      "X-Stainless-Runtime": "node",
      "X-Stainless-Runtime-Version": globalThis.process.version ?? "unknown"
    };
  const e = jy();
  return e ? {
    "X-Stainless-Lang": "js",
    "X-Stainless-Package-Version": Mn,
    "X-Stainless-OS": "Unknown",
    "X-Stainless-Arch": "unknown",
    "X-Stainless-Runtime": `browser:${e.browser}`,
    "X-Stainless-Runtime-Version": e.version
  } : {
    "X-Stainless-Lang": "js",
    "X-Stainless-Package-Version": Mn,
    "X-Stainless-OS": "Unknown",
    "X-Stainless-Arch": "unknown",
    "X-Stainless-Runtime": "unknown",
    "X-Stainless-Runtime-Version": "unknown"
  };
};
function jy() {
  if (typeof navigator > "u" || !navigator)
    return null;
  const r = [
    { key: "edge", pattern: /Edge(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "ie", pattern: /MSIE(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "ie", pattern: /Trident(?:.*rv\:(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "chrome", pattern: /Chrome(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "firefox", pattern: /Firefox(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "safari", pattern: /(?:Version\W+(\d+)\.(\d+)(?:\.(\d+))?)?(?:\W+Mobile\S*)?\W+Safari/ }
  ];
  for (const { key: e, pattern: t } of r) {
    const n = t.exec(navigator.userAgent);
    if (n) {
      const s = n[1] || 0, a = n[2] || 0, i = n[3] || 0;
      return { browser: e, version: `${s}.${a}.${i}` };
    }
  }
  return null;
}
const Kl = (r) => r === "x32" ? "x32" : r === "x86_64" || r === "x64" ? "x64" : r === "arm" ? "arm" : r === "aarch64" || r === "arm64" ? "arm64" : r ? `other:${r}` : "unknown", Yl = (r) => (r = r.toLowerCase(), r.includes("ios") ? "iOS" : r === "android" ? "Android" : r === "darwin" ? "MacOS" : r === "win32" ? "Windows" : r === "freebsd" ? "FreeBSD" : r === "openbsd" ? "OpenBSD" : r === "linux" ? "Linux" : r ? `Other:${r}` : "Unknown");
let Xl;
const Fy = () => Xl ?? (Xl = Dy());
function Uy() {
  if (typeof fetch < "u")
    return fetch;
  throw new Error("`fetch` is not defined as a global; Either pass `fetch` to the client, `new OpenAI({ fetch })` or polyfill the global, `globalThis.fetch = fetch`");
}
function Ff(...r) {
  const e = globalThis.ReadableStream;
  if (typeof e > "u")
    throw new Error("`ReadableStream` is not defined as a global; You will need to polyfill it, `globalThis.ReadableStream = ReadableStream`");
  return new e(...r);
}
function Uf(r) {
  let e = Symbol.asyncIterator in r ? r[Symbol.asyncIterator]() : r[Symbol.iterator]();
  return Ff({
    start() {
    },
    async pull(t) {
      const { done: n, value: s } = await e.next();
      n ? t.close() : t.enqueue(s);
    },
    async cancel() {
      var t;
      await ((t = e.return) == null ? void 0 : t.call(e));
    }
  });
}
function zf(r) {
  if (r[Symbol.asyncIterator])
    return r;
  const e = r.getReader();
  return {
    async next() {
      try {
        const t = await e.read();
        return t != null && t.done && e.releaseLock(), t;
      } catch (t) {
        throw e.releaseLock(), t;
      }
    },
    async return() {
      const t = e.cancel();
      return e.releaseLock(), await t, { done: !0, value: void 0 };
    },
    [Symbol.asyncIterator]() {
      return this;
    }
  };
}
async function zy(r) {
  var n, s;
  if (r === null || typeof r != "object")
    return;
  if (r[Symbol.asyncIterator]) {
    await ((s = (n = r[Symbol.asyncIterator]()).return) == null ? void 0 : s.call(n));
    return;
  }
  const e = r.getReader(), t = e.cancel();
  e.releaseLock(), await t;
}
const By = ({ headers: r, body: e }) => ({
  bodyHeaders: {
    "content-type": "application/json"
  },
  body: JSON.stringify(e)
}), Bf = "RFC3986", Zf = (r) => String(r), Ql = {
  RFC1738: (r) => String(r).replace(/%20/g, "+"),
  RFC3986: Zf
}, Zy = "RFC1738";
let bc = (r, e) => (bc = Object.hasOwn ?? Function.prototype.call.bind(Object.prototype.hasOwnProperty), bc(r, e));
const pr = /* @__PURE__ */ (() => {
  const r = [];
  for (let e = 0; e < 256; ++e)
    r.push("%" + ((e < 16 ? "0" : "") + e.toString(16)).toUpperCase());
  return r;
})(), jo = 1024, Vy = (r, e, t, n, s) => {
  if (r.length === 0)
    return r;
  let a = r;
  if (typeof r == "symbol" ? a = Symbol.prototype.toString.call(r) : typeof r != "string" && (a = String(r)), t === "iso-8859-1")
    return escape(a).replace(/%u[0-9a-f]{4}/gi, function(o) {
      return "%26%23" + parseInt(o.slice(2), 16) + "%3B";
    });
  let i = "";
  for (let o = 0; o < a.length; o += jo) {
    const c = a.length >= jo ? a.slice(o, o + jo) : a, u = [];
    for (let l = 0; l < c.length; ++l) {
      let d = c.charCodeAt(l);
      if (d === 45 || // -
      d === 46 || // .
      d === 95 || // _
      d === 126 || // ~
      d >= 48 && d <= 57 || // 0-9
      d >= 65 && d <= 90 || // a-z
      d >= 97 && d <= 122 || // A-Z
      s === Zy && (d === 40 || d === 41)) {
        u[u.length] = c.charAt(l);
        continue;
      }
      if (d < 128) {
        u[u.length] = pr[d];
        continue;
      }
      if (d < 2048) {
        u[u.length] = pr[192 | d >> 6] + pr[128 | d & 63];
        continue;
      }
      if (d < 55296 || d >= 57344) {
        u[u.length] = pr[224 | d >> 12] + pr[128 | d >> 6 & 63] + pr[128 | d & 63];
        continue;
      }
      l += 1, d = 65536 + ((d & 1023) << 10 | c.charCodeAt(l) & 1023), u[u.length] = pr[240 | d >> 18] + pr[128 | d >> 12 & 63] + pr[128 | d >> 6 & 63] + pr[128 | d & 63];
    }
    i += u.join("");
  }
  return i;
};
function qy(r) {
  return !r || typeof r != "object" ? !1 : !!(r.constructor && r.constructor.isBuffer && r.constructor.isBuffer(r));
}
function ed(r, e) {
  if (Rt(r)) {
    const t = [];
    for (let n = 0; n < r.length; n += 1)
      t.push(e(r[n]));
    return t;
  }
  return e(r);
}
const Vf = {
  brackets(r) {
    return String(r) + "[]";
  },
  comma: "comma",
  indices(r, e) {
    return String(r) + "[" + e + "]";
  },
  repeat(r) {
    return String(r);
  }
}, qf = function(r, e) {
  Array.prototype.push.apply(r, Rt(e) ? e : [e]);
};
let td;
const ot = {
  addQueryPrefix: !1,
  allowDots: !1,
  allowEmptyArrays: !1,
  arrayFormat: "indices",
  charset: "utf-8",
  charsetSentinel: !1,
  delimiter: "&",
  encode: !0,
  encodeDotInKeys: !1,
  encoder: Vy,
  encodeValuesOnly: !1,
  format: Bf,
  formatter: Zf,
  /** @deprecated */
  indices: !1,
  serializeDate(r) {
    return (td ?? (td = Function.prototype.call.bind(Date.prototype.toISOString)))(r);
  },
  skipNulls: !1,
  strictNullHandling: !1
};
function Hy(r) {
  return typeof r == "string" || typeof r == "number" || typeof r == "boolean" || typeof r == "symbol" || typeof r == "bigint";
}
const Fo = {};
function Hf(r, e, t, n, s, a, i, o, c, u, l, d, h, f, p, y, g, S) {
  let _ = r, w = S, T = 0, x = !1;
  for (; (w = w.get(Fo)) !== void 0 && !x; ) {
    const ne = w.get(r);
    if (T += 1, typeof ne < "u") {
      if (ne === T)
        throw new RangeError("Cyclic object value");
      x = !0;
    }
    typeof w.get(Fo) > "u" && (T = 0);
  }
  if (typeof u == "function" ? _ = u(e, _) : _ instanceof Date ? _ = h == null ? void 0 : h(_) : t === "comma" && Rt(_) && (_ = ed(_, function(ne) {
    return ne instanceof Date ? h == null ? void 0 : h(ne) : ne;
  })), _ === null) {
    if (a)
      return c && !y ? (
        // @ts-expect-error
        c(e, ot.encoder, g, "key", f)
      ) : e;
    _ = "";
  }
  if (Hy(_) || qy(_)) {
    if (c) {
      const ne = y ? e : c(e, ot.encoder, g, "key", f);
      return [
        (p == null ? void 0 : p(ne)) + "=" + // @ts-expect-error
        (p == null ? void 0 : p(c(_, ot.encoder, g, "value", f)))
      ];
    }
    return [(p == null ? void 0 : p(e)) + "=" + (p == null ? void 0 : p(String(_)))];
  }
  const A = [];
  if (typeof _ > "u")
    return A;
  let R;
  if (t === "comma" && Rt(_))
    y && c && (_ = ed(_, c)), R = [{ value: _.length > 0 ? _.join(",") || null : void 0 }];
  else if (Rt(u))
    R = u;
  else {
    const ne = Object.keys(_);
    R = l ? ne.sort(l) : ne;
  }
  const E = o ? String(e).replace(/\./g, "%2E") : String(e), V = n && Rt(_) && _.length === 1 ? E + "[]" : E;
  if (s && Rt(_) && _.length === 0)
    return V + "[]";
  for (let ne = 0; ne < R.length; ++ne) {
    const z = R[ne], Se = (
      // @ts-ignore
      typeof z == "object" && typeof z.value < "u" ? z.value : _[z]
    );
    if (i && Se === null)
      continue;
    const Oe = d && o ? z.replace(/\./g, "%2E") : z, Z = Rt(_) ? typeof t == "function" ? t(V, Oe) : V : V + (d ? "." + Oe : "[" + Oe + "]");
    S.set(r, T);
    const D = /* @__PURE__ */ new WeakMap();
    D.set(Fo, S), qf(A, Hf(
      Se,
      Z,
      t,
      n,
      s,
      a,
      i,
      o,
      // @ts-ignore
      t === "comma" && y && Rt(_) ? null : c,
      u,
      l,
      d,
      h,
      f,
      p,
      y,
      g,
      D
    ));
  }
  return A;
}
function Jy(r = ot) {
  if (typeof r.allowEmptyArrays < "u" && typeof r.allowEmptyArrays != "boolean")
    throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
  if (typeof r.encodeDotInKeys < "u" && typeof r.encodeDotInKeys != "boolean")
    throw new TypeError("`encodeDotInKeys` option can only be `true` or `false`, when provided");
  if (r.encoder !== null && typeof r.encoder < "u" && typeof r.encoder != "function")
    throw new TypeError("Encoder has to be a function.");
  const e = r.charset || ot.charset;
  if (typeof r.charset < "u" && r.charset !== "utf-8" && r.charset !== "iso-8859-1")
    throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
  let t = Bf;
  if (typeof r.format < "u") {
    if (!bc(Ql, r.format))
      throw new TypeError("Unknown format option provided.");
    t = r.format;
  }
  const n = Ql[t];
  let s = ot.filter;
  (typeof r.filter == "function" || Rt(r.filter)) && (s = r.filter);
  let a;
  if (r.arrayFormat && r.arrayFormat in Vf ? a = r.arrayFormat : "indices" in r ? a = r.indices ? "indices" : "repeat" : a = ot.arrayFormat, "commaRoundTrip" in r && typeof r.commaRoundTrip != "boolean")
    throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
  const i = typeof r.allowDots > "u" ? r.encodeDotInKeys ? !0 : ot.allowDots : !!r.allowDots;
  return {
    addQueryPrefix: typeof r.addQueryPrefix == "boolean" ? r.addQueryPrefix : ot.addQueryPrefix,
    // @ts-ignore
    allowDots: i,
    allowEmptyArrays: typeof r.allowEmptyArrays == "boolean" ? !!r.allowEmptyArrays : ot.allowEmptyArrays,
    arrayFormat: a,
    charset: e,
    charsetSentinel: typeof r.charsetSentinel == "boolean" ? r.charsetSentinel : ot.charsetSentinel,
    commaRoundTrip: !!r.commaRoundTrip,
    delimiter: typeof r.delimiter > "u" ? ot.delimiter : r.delimiter,
    encode: typeof r.encode == "boolean" ? r.encode : ot.encode,
    encodeDotInKeys: typeof r.encodeDotInKeys == "boolean" ? r.encodeDotInKeys : ot.encodeDotInKeys,
    encoder: typeof r.encoder == "function" ? r.encoder : ot.encoder,
    encodeValuesOnly: typeof r.encodeValuesOnly == "boolean" ? r.encodeValuesOnly : ot.encodeValuesOnly,
    filter: s,
    format: t,
    formatter: n,
    serializeDate: typeof r.serializeDate == "function" ? r.serializeDate : ot.serializeDate,
    skipNulls: typeof r.skipNulls == "boolean" ? r.skipNulls : ot.skipNulls,
    // @ts-ignore
    sort: typeof r.sort == "function" ? r.sort : null,
    strictNullHandling: typeof r.strictNullHandling == "boolean" ? r.strictNullHandling : ot.strictNullHandling
  };
}
function Wy(r, e = {}) {
  let t = r;
  const n = Jy(e);
  let s, a;
  typeof n.filter == "function" ? (a = n.filter, t = a("", t)) : Rt(n.filter) && (a = n.filter, s = a);
  const i = [];
  if (typeof t != "object" || t === null)
    return "";
  const o = Vf[n.arrayFormat], c = o === "comma" && n.commaRoundTrip;
  s || (s = Object.keys(t)), n.sort && s.sort(n.sort);
  const u = /* @__PURE__ */ new WeakMap();
  for (let h = 0; h < s.length; ++h) {
    const f = s[h];
    n.skipNulls && t[f] === null || qf(i, Hf(
      t[f],
      f,
      // @ts-expect-error
      o,
      c,
      n.allowEmptyArrays,
      n.strictNullHandling,
      n.skipNulls,
      n.encodeDotInKeys,
      n.encode ? n.encoder : null,
      n.filter,
      n.sort,
      n.allowDots,
      n.serializeDate,
      n.format,
      n.formatter,
      n.encodeValuesOnly,
      n.charset,
      u
    ));
  }
  const l = i.join(n.delimiter);
  let d = n.addQueryPrefix === !0 ? "?" : "";
  return n.charsetSentinel && (n.charset === "iso-8859-1" ? d += "utf8=%26%2310003%3B&" : d += "utf8=%E2%9C%93&"), l.length > 0 ? d + l : "";
}
function Gy(r) {
  let e = 0;
  for (const s of r)
    e += s.length;
  const t = new Uint8Array(e);
  let n = 0;
  for (const s of r)
    t.set(s, n), n += s.length;
  return t;
}
let rd;
function xu(r) {
  let e;
  return (rd ?? (e = new globalThis.TextEncoder(), rd = e.encode.bind(e)))(r);
}
let nd;
function sd(r) {
  let e;
  return (nd ?? (e = new globalThis.TextDecoder(), nd = e.decode.bind(e)))(r);
}
var Mt, Dt;
class Ki {
  constructor() {
    Mt.set(this, void 0), Dt.set(this, void 0), he(this, Mt, new Uint8Array()), he(this, Dt, null);
  }
  decode(e) {
    if (e == null)
      return [];
    const t = e instanceof ArrayBuffer ? new Uint8Array(e) : typeof e == "string" ? xu(e) : e;
    he(this, Mt, Gy([k(this, Mt, "f"), t]));
    const n = [];
    let s;
    for (; (s = Ky(k(this, Mt, "f"), k(this, Dt, "f"))) != null; ) {
      if (s.carriage && k(this, Dt, "f") == null) {
        he(this, Dt, s.index);
        continue;
      }
      if (k(this, Dt, "f") != null && (s.index !== k(this, Dt, "f") + 1 || s.carriage)) {
        n.push(sd(k(this, Mt, "f").subarray(0, k(this, Dt, "f") - 1))), he(this, Mt, k(this, Mt, "f").subarray(k(this, Dt, "f"))), he(this, Dt, null);
        continue;
      }
      const a = k(this, Dt, "f") !== null ? s.preceding - 1 : s.preceding, i = sd(k(this, Mt, "f").subarray(0, a));
      n.push(i), he(this, Mt, k(this, Mt, "f").subarray(s.index)), he(this, Dt, null);
    }
    return n;
  }
  flush() {
    return k(this, Mt, "f").length ? this.decode(`
`) : [];
  }
}
Mt = /* @__PURE__ */ new WeakMap(), Dt = /* @__PURE__ */ new WeakMap();
Ki.NEWLINE_CHARS = /* @__PURE__ */ new Set([`
`, "\r"]);
Ki.NEWLINE_REGEXP = /\r\n|[\n\r]/g;
function Ky(r, e) {
  for (let s = e ?? 0; s < r.length; s++) {
    if (r[s] === 10)
      return { preceding: s, index: s + 1, carriage: !1 };
    if (r[s] === 13)
      return { preceding: s, index: s + 1, carriage: !0 };
  }
  return null;
}
function Yy(r) {
  for (let n = 0; n < r.length - 1; n++) {
    if (r[n] === 10 && r[n + 1] === 10 || r[n] === 13 && r[n + 1] === 13)
      return n + 2;
    if (r[n] === 13 && r[n + 1] === 10 && n + 3 < r.length && r[n + 2] === 13 && r[n + 3] === 10)
      return n + 4;
  }
  return -1;
}
const di = {
  off: 0,
  error: 200,
  warn: 300,
  info: 400,
  debug: 500
}, ad = (r, e, t) => {
  if (r) {
    if (Ry(di, r))
      return r;
    wt(t).warn(`${e} was set to ${JSON.stringify(r)}, expected one of ${JSON.stringify(Object.keys(di))}`);
  }
};
function gs() {
}
function Sa(r, e, t) {
  return !e || di[r] > di[t] ? gs : e[r].bind(e);
}
const Xy = {
  error: gs,
  warn: gs,
  info: gs,
  debug: gs
};
let id = /* @__PURE__ */ new WeakMap();
function wt(r) {
  const e = r.logger, t = r.logLevel ?? "off";
  if (!e)
    return Xy;
  const n = id.get(e);
  if (n && n[0] === t)
    return n[1];
  const s = {
    error: Sa("error", e, t),
    warn: Sa("warn", e, t),
    info: Sa("info", e, t),
    debug: Sa("debug", e, t)
  };
  return id.set(e, [t, s]), s;
}
const dn = (r) => (r.options && (r.options = { ...r.options }, delete r.options.headers), r.headers && (r.headers = Object.fromEntries((r.headers instanceof Headers ? [...r.headers] : Object.entries(r.headers)).map(([e, t]) => [
  e,
  e.toLowerCase() === "authorization" || e.toLowerCase() === "cookie" || e.toLowerCase() === "set-cookie" ? "***" : t
]))), "retryOfRequestLogID" in r && (r.retryOfRequestLogID && (r.retryOf = r.retryOfRequestLogID), delete r.retryOfRequestLogID), r);
var hs;
class vr {
  constructor(e, t, n) {
    this.iterator = e, hs.set(this, void 0), this.controller = t, he(this, hs, n);
  }
  static fromSSEResponse(e, t, n) {
    let s = !1;
    const a = n ? wt(n) : console;
    async function* i() {
      if (s)
        throw new ce("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
      s = !0;
      let o = !1;
      try {
        for await (const c of Qy(e, t))
          if (!o) {
            if (c.data.startsWith("[DONE]")) {
              o = !0;
              continue;
            }
            if (c.event === null || !c.event.startsWith("thread.")) {
              let u;
              try {
                u = JSON.parse(c.data);
              } catch (l) {
                throw a.error("Could not parse message into JSON:", c.data), a.error("From chunk:", c.raw), l;
              }
              if (u && u.error)
                throw new St(void 0, u.error, void 0, e.headers);
              yield u;
            } else {
              let u;
              try {
                u = JSON.parse(c.data);
              } catch (l) {
                throw console.error("Could not parse message into JSON:", c.data), console.error("From chunk:", c.raw), l;
              }
              if (c.event == "error")
                throw new St(void 0, u.error, u.message, void 0);
              yield { event: c.event, data: u };
            }
          }
        o = !0;
      } catch (c) {
        if (wc(c))
          return;
        throw c;
      } finally {
        o || t.abort();
      }
    }
    return new vr(i, t, n);
  }
  /**
   * Generates a Stream from a newline-separated ReadableStream
   * where each item is a JSON value.
   */
  static fromReadableStream(e, t, n) {
    let s = !1;
    async function* a() {
      const o = new Ki(), c = zf(e);
      for await (const u of c)
        for (const l of o.decode(u))
          yield l;
      for (const u of o.flush())
        yield u;
    }
    async function* i() {
      if (s)
        throw new ce("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
      s = !0;
      let o = !1;
      try {
        for await (const c of a())
          o || c && (yield JSON.parse(c));
        o = !0;
      } catch (c) {
        if (wc(c))
          return;
        throw c;
      } finally {
        o || t.abort();
      }
    }
    return new vr(i, t, n);
  }
  [(hs = /* @__PURE__ */ new WeakMap(), Symbol.asyncIterator)]() {
    return this.iterator();
  }
  /**
   * Splits the stream into two streams which can be
   * independently read from at different speeds.
   */
  tee() {
    const e = [], t = [], n = this.iterator(), s = (a) => ({
      next: () => {
        if (a.length === 0) {
          const i = n.next();
          e.push(i), t.push(i);
        }
        return a.shift();
      }
    });
    return [
      new vr(() => s(e), this.controller, k(this, hs, "f")),
      new vr(() => s(t), this.controller, k(this, hs, "f"))
    ];
  }
  /**
   * Converts this stream to a newline-separated ReadableStream of
   * JSON stringified values in the stream
   * which can be turned back into a Stream with `Stream.fromReadableStream()`.
   */
  toReadableStream() {
    const e = this;
    let t;
    return Ff({
      async start() {
        t = e[Symbol.asyncIterator]();
      },
      async pull(n) {
        try {
          const { value: s, done: a } = await t.next();
          if (a)
            return n.close();
          const i = xu(JSON.stringify(s) + `
`);
          n.enqueue(i);
        } catch (s) {
          n.error(s);
        }
      },
      async cancel() {
        var n;
        await ((n = t.return) == null ? void 0 : n.call(t));
      }
    });
  }
}
async function* Qy(r, e) {
  if (!r.body)
    throw e.abort(), typeof globalThis.navigator < "u" && globalThis.navigator.product === "ReactNative" ? new ce("The default react-native fetch implementation does not support streaming. Please use expo/fetch: https://docs.expo.dev/versions/latest/sdk/expo/#expofetch-api") : new ce("Attempted to iterate over a response with no body");
  const t = new tw(), n = new Ki(), s = zf(r.body);
  for await (const a of ew(s))
    for (const i of n.decode(a)) {
      const o = t.decode(i);
      o && (yield o);
    }
  for (const a of n.flush()) {
    const i = t.decode(a);
    i && (yield i);
  }
}
async function* ew(r) {
  let e = new Uint8Array();
  for await (const t of r) {
    if (t == null)
      continue;
    const n = t instanceof ArrayBuffer ? new Uint8Array(t) : typeof t == "string" ? xu(t) : t;
    let s = new Uint8Array(e.length + n.length);
    s.set(e), s.set(n, e.length), e = s;
    let a;
    for (; (a = Yy(e)) !== -1; )
      yield e.slice(0, a), e = e.slice(a);
  }
  e.length > 0 && (yield e);
}
class tw {
  constructor() {
    this.event = null, this.data = [], this.chunks = [];
  }
  decode(e) {
    if (e.endsWith("\r") && (e = e.substring(0, e.length - 1)), !e) {
      if (!this.event && !this.data.length)
        return null;
      const a = {
        event: this.event,
        data: this.data.join(`
`),
        raw: this.chunks
      };
      return this.event = null, this.data = [], this.chunks = [], a;
    }
    if (this.chunks.push(e), e.startsWith(":"))
      return null;
    let [t, n, s] = rw(e, ":");
    return s.startsWith(" ") && (s = s.substring(1)), t === "event" ? this.event = s : t === "data" && this.data.push(s), null;
  }
}
function rw(r, e) {
  const t = r.indexOf(e);
  return t !== -1 ? [r.substring(0, t), e, r.substring(t + e.length)] : [r, "", ""];
}
async function Jf(r, e) {
  const { response: t, requestLogID: n, retryOfRequestLogID: s, startTime: a } = e, i = await (async () => {
    var d;
    if (e.options.stream)
      return wt(r).debug("response", t.status, t.url, t.headers, t.body), e.options.__streamClass ? e.options.__streamClass.fromSSEResponse(t, e.controller, r) : vr.fromSSEResponse(t, e.controller, r);
    if (t.status === 204)
      return null;
    if (e.options.__binaryResponse)
      return t;
    const o = t.headers.get("content-type"), c = (d = o == null ? void 0 : o.split(";")[0]) == null ? void 0 : d.trim();
    if ((c == null ? void 0 : c.includes("application/json")) || (c == null ? void 0 : c.endsWith("+json"))) {
      const h = await t.json();
      return Wf(h, t);
    }
    return await t.text();
  })();
  return wt(r).debug(`[${n}] response parsed`, dn({
    retryOfRequestLogID: s,
    url: t.url,
    status: t.status,
    body: i,
    durationMs: Date.now() - a
  })), i;
}
function Wf(r, e) {
  return !r || typeof r != "object" || Array.isArray(r) ? r : Object.defineProperty(r, "_request_id", {
    value: e.headers.get("x-request-id"),
    enumerable: !1
  });
}
var _s;
class Yi extends Promise {
  constructor(e, t, n = Jf) {
    super((s) => {
      s(null);
    }), this.responsePromise = t, this.parseResponse = n, _s.set(this, void 0), he(this, _s, e);
  }
  _thenUnwrap(e) {
    return new Yi(k(this, _s, "f"), this.responsePromise, async (t, n) => Wf(e(await this.parseResponse(t, n), n), n.response));
  }
  /**
   * Gets the raw `Response` instance instead of parsing the response
   * data.
   *
   * If you want to parse the response body but still get the `Response`
   * instance, you can use {@link withResponse()}.
   *
   * ðŸ‘‹ Getting the wrong TypeScript type for `Response`?
   * Try setting `"moduleResolution": "NodeNext"` or add `"lib": ["DOM"]`
   * to your `tsconfig.json`.
   */
  asResponse() {
    return this.responsePromise.then((e) => e.response);
  }
  /**
   * Gets the parsed response data, the raw `Response` instance and the ID of the request,
   * returned via the X-Request-ID header which is useful for debugging requests and reporting
   * issues to OpenAI.
   *
   * If you just want to get the raw `Response` instance without parsing it,
   * you can use {@link asResponse()}.
   *
   * ðŸ‘‹ Getting the wrong TypeScript type for `Response`?
   * Try setting `"moduleResolution": "NodeNext"` or add `"lib": ["DOM"]`
   * to your `tsconfig.json`.
   */
  async withResponse() {
    const [e, t] = await Promise.all([this.parse(), this.asResponse()]);
    return { data: e, response: t, request_id: t.headers.get("x-request-id") };
  }
  parse() {
    return this.parsedPromise || (this.parsedPromise = this.responsePromise.then((e) => this.parseResponse(k(this, _s, "f"), e))), this.parsedPromise;
  }
  then(e, t) {
    return this.parse().then(e, t);
  }
  catch(e) {
    return this.parse().catch(e);
  }
  finally(e) {
    return this.parse().finally(e);
  }
}
_s = /* @__PURE__ */ new WeakMap();
var Ta;
class Iu {
  constructor(e, t, n, s) {
    Ta.set(this, void 0), he(this, Ta, e), this.options = s, this.response = t, this.body = n;
  }
  hasNextPage() {
    return this.getPaginatedItems().length ? this.nextPageRequestOptions() != null : !1;
  }
  async getNextPage() {
    const e = this.nextPageRequestOptions();
    if (!e)
      throw new ce("No next page expected; please check `.hasNextPage()` before calling `.getNextPage()`.");
    return await k(this, Ta, "f").requestAPIList(this.constructor, e);
  }
  async *iterPages() {
    let e = this;
    for (yield e; e.hasNextPage(); )
      e = await e.getNextPage(), yield e;
  }
  async *[(Ta = /* @__PURE__ */ new WeakMap(), Symbol.asyncIterator)]() {
    for await (const e of this.iterPages())
      for (const t of e.getPaginatedItems())
        yield t;
  }
}
class nw extends Yi {
  constructor(e, t, n) {
    super(e, t, async (s, a) => new n(s, a.response, await Jf(s, a), a.options));
  }
  /**
   * Allow auto-paginating iteration on an unawaited list call, eg:
   *
   *    for await (const item of client.items.list()) {
   *      console.log(item)
   *    }
   */
  async *[Symbol.asyncIterator]() {
    const e = await this;
    for await (const t of e)
      yield t;
  }
}
class Xi extends Iu {
  constructor(e, t, n, s) {
    super(e, t, n, s), this.data = n.data || [], this.object = n.object;
  }
  getPaginatedItems() {
    return this.data ?? [];
  }
  nextPageRequestOptions() {
    return null;
  }
}
class rt extends Iu {
  constructor(e, t, n, s) {
    super(e, t, n, s), this.data = n.data || [], this.has_more = n.has_more || !1;
  }
  getPaginatedItems() {
    return this.data ?? [];
  }
  hasNextPage() {
    return this.has_more === !1 ? !1 : super.hasNextPage();
  }
  nextPageRequestOptions() {
    var n;
    const e = this.getPaginatedItems(), t = (n = e[e.length - 1]) == null ? void 0 : n.id;
    return t ? {
      ...this.options,
      query: {
        ...jf(this.options.query),
        after: t
      }
    } : null;
  }
}
class hi extends Iu {
  constructor(e, t, n, s) {
    super(e, t, n, s), this.data = n.data || [], this.has_more = n.has_more || !1, this.last_id = n.last_id || "";
  }
  getPaginatedItems() {
    return this.data ?? [];
  }
  hasNextPage() {
    return this.has_more === !1 ? !1 : super.hasNextPage();
  }
  nextPageRequestOptions() {
    const e = this.last_id;
    return e ? {
      ...this.options,
      query: {
        ...jf(this.options.query),
        after: e
      }
    } : null;
  }
}
const Gf = () => {
  var r;
  if (typeof File > "u") {
    const { process: e } = globalThis, t = typeof ((r = e == null ? void 0 : e.versions) == null ? void 0 : r.node) == "string" && parseInt(e.versions.node.split(".")) < 20;
    throw new Error("`File` is not defined as a global, which is required for file uploads." + (t ? " Update to Node 20 LTS or newer, or set `globalThis.File` to `import('node:buffer').File`." : ""));
  }
};
function Ns(r, e, t) {
  return Gf(), new File(r, e ?? "unknown_file", t);
}
function Ka(r) {
  return (typeof r == "object" && r !== null && ("name" in r && r.name && String(r.name) || "url" in r && r.url && String(r.url) || "filename" in r && r.filename && String(r.filename) || "path" in r && r.path && String(r.path)) || "").split(/[\\/]/).pop() || void 0;
}
const ku = (r) => r != null && typeof r == "object" && typeof r[Symbol.asyncIterator] == "function", od = async (r, e) => Sc(r.body) ? { ...r, body: await Kf(r.body, e) } : r, Sn = async (r, e) => ({ ...r, body: await Kf(r.body, e) }), cd = /* @__PURE__ */ new WeakMap();
function sw(r) {
  const e = typeof r == "function" ? r : r.fetch, t = cd.get(e);
  if (t)
    return t;
  const n = (async () => {
    try {
      const s = "Response" in e ? e.Response : (await e("data:,")).constructor, a = new FormData();
      return a.toString() !== await new s(a).text();
    } catch {
      return !0;
    }
  })();
  return cd.set(e, n), n;
}
const Kf = async (r, e) => {
  if (!await sw(e))
    throw new TypeError("The provided fetch function does not support file uploads with the current global FormData class.");
  const t = new FormData();
  return await Promise.all(Object.entries(r || {}).map(([n, s]) => Tc(t, n, s))), t;
}, Yf = (r) => r instanceof Blob && "name" in r, aw = (r) => typeof r == "object" && r !== null && (r instanceof Response || ku(r) || Yf(r)), Sc = (r) => {
  if (aw(r))
    return !0;
  if (Array.isArray(r))
    return r.some(Sc);
  if (r && typeof r == "object") {
    for (const e in r)
      if (Sc(r[e]))
        return !0;
  }
  return !1;
}, Tc = async (r, e, t) => {
  if (t !== void 0) {
    if (t == null)
      throw new TypeError(`Received null for "${e}"; to pass null in FormData, you must use the string 'null'`);
    if (typeof t == "string" || typeof t == "number" || typeof t == "boolean")
      r.append(e, String(t));
    else if (t instanceof Response)
      r.append(e, Ns([await t.blob()], Ka(t)));
    else if (ku(t))
      r.append(e, Ns([await new Response(Uf(t)).blob()], Ka(t)));
    else if (Yf(t))
      r.append(e, t, Ka(t));
    else if (Array.isArray(t))
      await Promise.all(t.map((n) => Tc(r, e + "[]", n)));
    else if (typeof t == "object")
      await Promise.all(Object.entries(t).map(([n, s]) => Tc(r, `${e}[${n}]`, s)));
    else
      throw new TypeError(`Invalid value given to form, expected a string, number, boolean, object, Array, File or Blob but got ${t} instead`);
  }
}, Xf = (r) => r != null && typeof r == "object" && typeof r.size == "number" && typeof r.type == "string" && typeof r.text == "function" && typeof r.slice == "function" && typeof r.arrayBuffer == "function", iw = (r) => r != null && typeof r == "object" && typeof r.name == "string" && typeof r.lastModified == "number" && Xf(r), ow = (r) => r != null && typeof r == "object" && typeof r.url == "string" && typeof r.blob == "function";
async function cw(r, e, t) {
  if (Gf(), r = await r, iw(r))
    return r instanceof File ? r : Ns([await r.arrayBuffer()], r.name);
  if (ow(r)) {
    const s = await r.blob();
    return e || (e = new URL(r.url).pathname.split(/[\\/]/).pop()), Ns(await Ec(s), e, t);
  }
  const n = await Ec(r);
  if (e || (e = Ka(r)), !(t != null && t.type)) {
    const s = n.find((a) => typeof a == "object" && "type" in a && a.type);
    typeof s == "string" && (t = { ...t, type: s });
  }
  return Ns(n, e, t);
}
async function Ec(r) {
  var t;
  let e = [];
  if (typeof r == "string" || ArrayBuffer.isView(r) || // includes Uint8Array, Buffer, etc.
  r instanceof ArrayBuffer)
    e.push(r);
  else if (Xf(r))
    e.push(r instanceof Blob ? r : await r.arrayBuffer());
  else if (ku(r))
    for await (const n of r)
      e.push(...await Ec(n));
  else {
    const n = (t = r == null ? void 0 : r.constructor) == null ? void 0 : t.name;
    throw new Error(`Unexpected data type: ${typeof r}${n ? `; constructor: ${n}` : ""}${uw(r)}`);
  }
  return e;
}
function uw(r) {
  return typeof r != "object" || r === null ? "" : `; props: [${Object.getOwnPropertyNames(r).map((t) => `"${t}"`).join(", ")}]`;
}
class ie {
  constructor(e) {
    this._client = e;
  }
}
function Qf(r) {
  return r.replace(/[^A-Za-z0-9\-._~!$&'()*+,;=:@]+/g, encodeURIComponent);
}
const ud = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.create(null)), lw = (r = Qf) => function(t, ...n) {
  if (t.length === 1)
    return t[0];
  let s = !1;
  const a = [], i = t.reduce((l, d, h) => {
    var y;
    /[?#]/.test(d) && (s = !0);
    const f = n[h];
    let p = (s ? encodeURIComponent : r)("" + f);
    return h !== n.length && (f == null || typeof f == "object" && // handle values from other realms
    f.toString === ((y = Object.getPrototypeOf(Object.getPrototypeOf(f.hasOwnProperty ?? ud) ?? ud)) == null ? void 0 : y.toString)) && (p = f + "", a.push({
      start: l.length + d.length,
      length: p.length,
      error: `Value of type ${Object.prototype.toString.call(f).slice(8, -1)} is not a valid path parameter`
    })), l + d + (h === n.length ? "" : p);
  }, ""), o = i.split(/[?#]/, 1)[0], c = new RegExp("(?<=^|\\/)(?:\\.|%2e){1,2}(?=\\/|$)", "gi");
  let u;
  for (; (u = c.exec(o)) !== null; )
    a.push({
      start: u.index,
      length: u[0].length,
      error: `Value "${u[0]}" can't be safely passed as a path parameter`
    });
  if (a.sort((l, d) => l.start - d.start), a.length > 0) {
    let l = 0;
    const d = a.reduce((h, f) => {
      const p = " ".repeat(f.start - l), y = "^".repeat(f.length);
      return l = f.start + f.length, h + p + y;
    }, "");
    throw new ce(`Path parameters result in path with invalid segments:
${a.map((h) => h.error).join(`
`)}
${i}
${d}`);
  }
  return i;
}, F = /* @__PURE__ */ lw(Qf);
let ep = class extends ie {
  /**
   * Get the messages in a stored chat completion. Only Chat Completions that have
   * been created with the `store` parameter set to `true` will be returned.
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const chatCompletionStoreMessage of client.chat.completions.messages.list(
   *   'completion_id',
   * )) {
   *   // ...
   * }
   * ```
   */
  list(e, t = {}, n) {
    return this._client.getAPIList(F`/chat/completions/${e}/messages`, rt, { query: t, ...n });
  }
};
function fi(r) {
  return r !== void 0 && "function" in r && r.function !== void 0;
}
function dw(r, e) {
  const t = { ...r };
  return Object.defineProperties(t, {
    $brand: {
      value: "auto-parseable-response-format",
      enumerable: !1
    },
    $parseRaw: {
      value: e,
      enumerable: !1
    }
  }), t;
}
function Ou(r) {
  return (r == null ? void 0 : r.$brand) === "auto-parseable-response-format";
}
function na(r) {
  return (r == null ? void 0 : r.$brand) === "auto-parseable-tool";
}
function hw(r, e) {
  return !e || !tp(e) ? {
    ...r,
    choices: r.choices.map((t) => (rp(t.message.tool_calls), {
      ...t,
      message: {
        ...t.message,
        parsed: null,
        ...t.message.tool_calls ? {
          tool_calls: t.message.tool_calls
        } : void 0
      }
    }))
  } : Au(r, e);
}
function Au(r, e) {
  const t = r.choices.map((n) => {
    var s;
    if (n.finish_reason === "length")
      throw new Mf();
    if (n.finish_reason === "content_filter")
      throw new Df();
    return rp(n.message.tool_calls), {
      ...n,
      message: {
        ...n.message,
        ...n.message.tool_calls ? {
          tool_calls: ((s = n.message.tool_calls) == null ? void 0 : s.map((a) => pw(e, a))) ?? void 0
        } : void 0,
        parsed: n.message.content && !n.message.refusal ? fw(e, n.message.content) : null
      }
    };
  });
  return { ...r, choices: t };
}
function fw(r, e) {
  var t, n;
  return ((t = r.response_format) == null ? void 0 : t.type) !== "json_schema" ? null : ((n = r.response_format) == null ? void 0 : n.type) === "json_schema" ? "$parseRaw" in r.response_format ? r.response_format.$parseRaw(e) : JSON.parse(e) : null;
}
function pw(r, e) {
  var n;
  const t = (n = r.tools) == null ? void 0 : n.find((s) => {
    var a;
    return fi(s) && ((a = s.function) == null ? void 0 : a.name) === e.function.name;
  });
  return {
    ...e,
    function: {
      ...e.function,
      parsed_arguments: na(t) ? t.$parseRaw(e.function.arguments) : t != null && t.function.strict ? JSON.parse(e.function.arguments) : null
    }
  };
}
function mw(r, e) {
  var n;
  if (!r || !("tools" in r) || !r.tools)
    return !1;
  const t = (n = r.tools) == null ? void 0 : n.find((s) => {
    var a;
    return fi(s) && ((a = s.function) == null ? void 0 : a.name) === e.function.name;
  });
  return fi(t) && (na(t) || (t == null ? void 0 : t.function.strict) || !1);
}
function tp(r) {
  var e;
  return Ou(r.response_format) ? !0 : ((e = r.tools) == null ? void 0 : e.some((t) => na(t) || t.type === "function" && t.function.strict === !0)) ?? !1;
}
function rp(r) {
  for (const e of r || [])
    if (e.type !== "function")
      throw new ce(`Currently only \`function\` tool calls are supported; Received \`${e.type}\``);
}
function gw(r) {
  for (const e of r ?? []) {
    if (e.type !== "function")
      throw new ce(`Currently only \`function\` tool types support auto-parsing; Received \`${e.type}\``);
    if (e.function.strict !== !0)
      throw new ce(`The \`${e.function.name}\` tool is not marked with \`strict: true\`. Only strict function tools can be auto-parsed`);
  }
}
const pi = (r) => (r == null ? void 0 : r.role) === "assistant", np = (r) => (r == null ? void 0 : r.role) === "tool";
var xc, Ya, Xa, ys, ws, Qa, vs, Rr, bs, mi, gi, Dn, sp;
class $u {
  constructor() {
    xc.add(this), this.controller = new AbortController(), Ya.set(this, void 0), Xa.set(this, () => {
    }), ys.set(this, () => {
    }), ws.set(this, void 0), Qa.set(this, () => {
    }), vs.set(this, () => {
    }), Rr.set(this, {}), bs.set(this, !1), mi.set(this, !1), gi.set(this, !1), Dn.set(this, !1), he(this, Ya, new Promise((e, t) => {
      he(this, Xa, e, "f"), he(this, ys, t, "f");
    })), he(this, ws, new Promise((e, t) => {
      he(this, Qa, e, "f"), he(this, vs, t, "f");
    })), k(this, Ya, "f").catch(() => {
    }), k(this, ws, "f").catch(() => {
    });
  }
  _run(e) {
    setTimeout(() => {
      e().then(() => {
        this._emitFinal(), this._emit("end");
      }, k(this, xc, "m", sp).bind(this));
    }, 0);
  }
  _connected() {
    this.ended || (k(this, Xa, "f").call(this), this._emit("connect"));
  }
  get ended() {
    return k(this, bs, "f");
  }
  get errored() {
    return k(this, mi, "f");
  }
  get aborted() {
    return k(this, gi, "f");
  }
  abort() {
    this.controller.abort();
  }
  /**
   * Adds the listener function to the end of the listeners array for the event.
   * No checks are made to see if the listener has already been added. Multiple calls passing
   * the same combination of event and listener will result in the listener being added, and
   * called, multiple times.
   * @returns this ChatCompletionStream, so that calls can be chained
   */
  on(e, t) {
    return (k(this, Rr, "f")[e] || (k(this, Rr, "f")[e] = [])).push({ listener: t }), this;
  }
  /**
   * Removes the specified listener from the listener array for the event.
   * off() will remove, at most, one instance of a listener from the listener array. If any single
   * listener has been added multiple times to the listener array for the specified event, then
   * off() must be called multiple times to remove each instance.
   * @returns this ChatCompletionStream, so that calls can be chained
   */
  off(e, t) {
    const n = k(this, Rr, "f")[e];
    if (!n)
      return this;
    const s = n.findIndex((a) => a.listener === t);
    return s >= 0 && n.splice(s, 1), this;
  }
  /**
   * Adds a one-time listener function for the event. The next time the event is triggered,
   * this listener is removed and then invoked.
   * @returns this ChatCompletionStream, so that calls can be chained
   */
  once(e, t) {
    return (k(this, Rr, "f")[e] || (k(this, Rr, "f")[e] = [])).push({ listener: t, once: !0 }), this;
  }
  /**
   * This is similar to `.once()`, but returns a Promise that resolves the next time
   * the event is triggered, instead of calling a listener callback.
   * @returns a Promise that resolves the next time given event is triggered,
   * or rejects if an error is emitted.  (If you request the 'error' event,
   * returns a promise that resolves with the error).
   *
   * Example:
   *
   *   const message = await stream.emitted('message') // rejects if the stream errors
   */
  emitted(e) {
    return new Promise((t, n) => {
      he(this, Dn, !0), e !== "error" && this.once("error", n), this.once(e, t);
    });
  }
  async done() {
    he(this, Dn, !0), await k(this, ws, "f");
  }
  _emit(e, ...t) {
    if (k(this, bs, "f"))
      return;
    e === "end" && (he(this, bs, !0), k(this, Qa, "f").call(this));
    const n = k(this, Rr, "f")[e];
    if (n && (k(this, Rr, "f")[e] = n.filter((s) => !s.once), n.forEach(({ listener: s }) => s(...t))), e === "abort") {
      const s = t[0];
      !k(this, Dn, "f") && !(n != null && n.length) && Promise.reject(s), k(this, ys, "f").call(this, s), k(this, vs, "f").call(this, s), this._emit("end");
      return;
    }
    if (e === "error") {
      const s = t[0];
      !k(this, Dn, "f") && !(n != null && n.length) && Promise.reject(s), k(this, ys, "f").call(this, s), k(this, vs, "f").call(this, s), this._emit("end");
    }
  }
  _emitFinal() {
  }
}
Ya = /* @__PURE__ */ new WeakMap(), Xa = /* @__PURE__ */ new WeakMap(), ys = /* @__PURE__ */ new WeakMap(), ws = /* @__PURE__ */ new WeakMap(), Qa = /* @__PURE__ */ new WeakMap(), vs = /* @__PURE__ */ new WeakMap(), Rr = /* @__PURE__ */ new WeakMap(), bs = /* @__PURE__ */ new WeakMap(), mi = /* @__PURE__ */ new WeakMap(), gi = /* @__PURE__ */ new WeakMap(), Dn = /* @__PURE__ */ new WeakMap(), xc = /* @__PURE__ */ new WeakSet(), sp = function(e) {
  if (he(this, mi, !0), e instanceof Error && e.name === "AbortError" && (e = new Ut()), e instanceof Ut)
    return he(this, gi, !0), this._emit("abort", e);
  if (e instanceof ce)
    return this._emit("error", e);
  if (e instanceof Error) {
    const t = new ce(e.message);
    return t.cause = e, this._emit("error", t);
  }
  return this._emit("error", new ce(String(e)));
};
function _w(r) {
  return typeof r.parse == "function";
}
var kt, Ic, _i, kc, Oc, Ac, ap, ip;
const yw = 10;
class op extends $u {
  constructor() {
    super(...arguments), kt.add(this), this._chatCompletions = [], this.messages = [];
  }
  _addChatCompletion(e) {
    var n;
    this._chatCompletions.push(e), this._emit("chatCompletion", e);
    const t = (n = e.choices[0]) == null ? void 0 : n.message;
    return t && this._addMessage(t), e;
  }
  _addMessage(e, t = !0) {
    if ("content" in e || (e.content = null), this.messages.push(e), t) {
      if (this._emit("message", e), np(e) && e.content)
        this._emit("functionToolCallResult", e.content);
      else if (pi(e) && e.tool_calls)
        for (const n of e.tool_calls)
          n.type === "function" && this._emit("functionToolCall", n.function);
    }
  }
  /**
   * @returns a promise that resolves with the final ChatCompletion, or rejects
   * if an error occurred or the stream ended prematurely without producing a ChatCompletion.
   */
  async finalChatCompletion() {
    await this.done();
    const e = this._chatCompletions[this._chatCompletions.length - 1];
    if (!e)
      throw new ce("stream ended without producing a ChatCompletion");
    return e;
  }
  /**
   * @returns a promise that resolves with the content of the final ChatCompletionMessage, or rejects
   * if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.
   */
  async finalContent() {
    return await this.done(), k(this, kt, "m", Ic).call(this);
  }
  /**
   * @returns a promise that resolves with the the final assistant ChatCompletionMessage response,
   * or rejects if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.
   */
  async finalMessage() {
    return await this.done(), k(this, kt, "m", _i).call(this);
  }
  /**
   * @returns a promise that resolves with the content of the final FunctionCall, or rejects
   * if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.
   */
  async finalFunctionToolCall() {
    return await this.done(), k(this, kt, "m", kc).call(this);
  }
  async finalFunctionToolCallResult() {
    return await this.done(), k(this, kt, "m", Oc).call(this);
  }
  async totalUsage() {
    return await this.done(), k(this, kt, "m", Ac).call(this);
  }
  allChatCompletions() {
    return [...this._chatCompletions];
  }
  _emitFinal() {
    const e = this._chatCompletions[this._chatCompletions.length - 1];
    e && this._emit("finalChatCompletion", e);
    const t = k(this, kt, "m", _i).call(this);
    t && this._emit("finalMessage", t);
    const n = k(this, kt, "m", Ic).call(this);
    n && this._emit("finalContent", n);
    const s = k(this, kt, "m", kc).call(this);
    s && this._emit("finalFunctionToolCall", s);
    const a = k(this, kt, "m", Oc).call(this);
    a != null && this._emit("finalFunctionToolCallResult", a), this._chatCompletions.some((i) => i.usage) && this._emit("totalUsage", k(this, kt, "m", Ac).call(this));
  }
  async _createChatCompletion(e, t, n) {
    const s = n == null ? void 0 : n.signal;
    s && (s.aborted && this.controller.abort(), s.addEventListener("abort", () => this.controller.abort())), k(this, kt, "m", ap).call(this, t);
    const a = await e.chat.completions.create({ ...t, stream: !1 }, { ...n, signal: this.controller.signal });
    return this._connected(), this._addChatCompletion(Au(a, t));
  }
  async _runChatCompletion(e, t, n) {
    for (const s of t.messages)
      this._addMessage(s, !1);
    return await this._createChatCompletion(e, t, n);
  }
  async _runTools(e, t, n) {
    var f, p, y;
    const s = "tool", { tool_choice: a = "auto", stream: i, ...o } = t, c = typeof a != "string" && a.type === "function" && ((f = a == null ? void 0 : a.function) == null ? void 0 : f.name), { maxChatCompletions: u = yw } = n || {}, l = t.tools.map((g) => {
      if (na(g)) {
        if (!g.$callback)
          throw new ce("Tool given to `.runTools()` that does not have an associated function");
        return {
          type: "function",
          function: {
            function: g.$callback,
            name: g.function.name,
            description: g.function.description || "",
            parameters: g.function.parameters,
            parse: g.$parseRaw,
            strict: !0
          }
        };
      }
      return g;
    }), d = {};
    for (const g of l)
      g.type === "function" && (d[g.function.name || g.function.function.name] = g.function);
    const h = "tools" in t ? l.map((g) => g.type === "function" ? {
      type: "function",
      function: {
        name: g.function.name || g.function.function.name,
        parameters: g.function.parameters,
        description: g.function.description,
        strict: g.function.strict
      }
    } : g) : void 0;
    for (const g of t.messages)
      this._addMessage(g, !1);
    for (let g = 0; g < u; ++g) {
      const _ = (p = (await this._createChatCompletion(e, {
        ...o,
        tool_choice: a,
        tools: h,
        messages: [...this.messages]
      }, n)).choices[0]) == null ? void 0 : p.message;
      if (!_)
        throw new ce("missing message in ChatCompletion response");
      if (!((y = _.tool_calls) != null && y.length))
        return;
      for (const w of _.tool_calls) {
        if (w.type !== "function")
          continue;
        const T = w.id, { name: x, arguments: A } = w.function, R = d[x];
        if (R) {
          if (c && c !== x) {
            const z = `Invalid tool_call: ${JSON.stringify(x)}. ${JSON.stringify(c)} requested. Please try again`;
            this._addMessage({ role: s, tool_call_id: T, content: z });
            continue;
          }
        } else {
          const z = `Invalid tool_call: ${JSON.stringify(x)}. Available options are: ${Object.keys(d).map((Se) => JSON.stringify(Se)).join(", ")}. Please try again`;
          this._addMessage({ role: s, tool_call_id: T, content: z });
          continue;
        }
        let E;
        try {
          E = _w(R) ? await R.parse(A) : A;
        } catch (z) {
          const Se = z instanceof Error ? z.message : String(z);
          this._addMessage({ role: s, tool_call_id: T, content: Se });
          continue;
        }
        const V = await R.function(E, this), ne = k(this, kt, "m", ip).call(this, V);
        if (this._addMessage({ role: s, tool_call_id: T, content: ne }), c)
          return;
      }
    }
  }
}
kt = /* @__PURE__ */ new WeakSet(), Ic = function() {
  return k(this, kt, "m", _i).call(this).content ?? null;
}, _i = function() {
  let e = this.messages.length;
  for (; e-- > 0; ) {
    const t = this.messages[e];
    if (pi(t))
      return {
        ...t,
        content: t.content ?? null,
        refusal: t.refusal ?? null
      };
  }
  throw new ce("stream ended without producing a ChatCompletionMessage with role=assistant");
}, kc = function() {
  var e, t;
  for (let n = this.messages.length - 1; n >= 0; n--) {
    const s = this.messages[n];
    if (pi(s) && ((e = s == null ? void 0 : s.tool_calls) != null && e.length))
      return (t = s.tool_calls.filter((a) => a.type === "function").at(-1)) == null ? void 0 : t.function;
  }
}, Oc = function() {
  for (let e = this.messages.length - 1; e >= 0; e--) {
    const t = this.messages[e];
    if (np(t) && t.content != null && typeof t.content == "string" && this.messages.some((n) => {
      var s;
      return n.role === "assistant" && ((s = n.tool_calls) == null ? void 0 : s.some((a) => a.type === "function" && a.id === t.tool_call_id));
    }))
      return t.content;
  }
}, Ac = function() {
  const e = {
    completion_tokens: 0,
    prompt_tokens: 0,
    total_tokens: 0
  };
  for (const { usage: t } of this._chatCompletions)
    t && (e.completion_tokens += t.completion_tokens, e.prompt_tokens += t.prompt_tokens, e.total_tokens += t.total_tokens);
  return e;
}, ap = function(e) {
  if (e.n != null && e.n > 1)
    throw new ce("ChatCompletion convenience helpers only support n=1 at this time. To use n>1, please use chat.completions.create() directly.");
}, ip = function(e) {
  return typeof e == "string" ? e : e === void 0 ? "undefined" : JSON.stringify(e);
};
class Cu extends op {
  static runTools(e, t, n) {
    const s = new Cu(), a = {
      ...n,
      headers: { ...n == null ? void 0 : n.headers, "X-Stainless-Helper-Method": "runTools" }
    };
    return s._run(() => s._runTools(e, t, a)), s;
  }
  _addMessage(e, t = !0) {
    super._addMessage(e, t), pi(e) && e.content && this._emit("content", e.content);
  }
}
const cp = 1, up = 2, lp = 4, dp = 8, hp = 16, fp = 32, pp = 64, mp = 128, gp = 256, _p = mp | gp, yp = hp | fp | _p | pp, wp = cp | up | yp, vp = lp | dp, ww = wp | vp, ht = {
  STR: cp,
  NUM: up,
  ARR: lp,
  OBJ: dp,
  NULL: hp,
  BOOL: fp,
  NAN: pp,
  INFINITY: mp,
  MINUS_INFINITY: gp,
  INF: _p,
  SPECIAL: yp,
  ATOM: wp,
  COLLECTION: vp,
  ALL: ww
};
class vw extends Error {
}
class bw extends Error {
}
function Sw(r, e = ht.ALL) {
  if (typeof r != "string")
    throw new TypeError(`expecting str, got ${typeof r}`);
  if (!r.trim())
    throw new Error(`${r} is empty`);
  return Tw(r.trim(), e);
}
const Tw = (r, e) => {
  const t = r.length;
  let n = 0;
  const s = (h) => {
    throw new vw(`${h} at position ${n}`);
  }, a = (h) => {
    throw new bw(`${h} at position ${n}`);
  }, i = () => (d(), n >= t && s("Unexpected end of input"), r[n] === '"' ? o() : r[n] === "{" ? c() : r[n] === "[" ? u() : r.substring(n, n + 4) === "null" || ht.NULL & e && t - n < 4 && "null".startsWith(r.substring(n)) ? (n += 4, null) : r.substring(n, n + 4) === "true" || ht.BOOL & e && t - n < 4 && "true".startsWith(r.substring(n)) ? (n += 4, !0) : r.substring(n, n + 5) === "false" || ht.BOOL & e && t - n < 5 && "false".startsWith(r.substring(n)) ? (n += 5, !1) : r.substring(n, n + 8) === "Infinity" || ht.INFINITY & e && t - n < 8 && "Infinity".startsWith(r.substring(n)) ? (n += 8, 1 / 0) : r.substring(n, n + 9) === "-Infinity" || ht.MINUS_INFINITY & e && 1 < t - n && t - n < 9 && "-Infinity".startsWith(r.substring(n)) ? (n += 9, -1 / 0) : r.substring(n, n + 3) === "NaN" || ht.NAN & e && t - n < 3 && "NaN".startsWith(r.substring(n)) ? (n += 3, NaN) : l()), o = () => {
    const h = n;
    let f = !1;
    for (n++; n < t && (r[n] !== '"' || f && r[n - 1] === "\\"); )
      f = r[n] === "\\" ? !f : !1, n++;
    if (r.charAt(n) == '"')
      try {
        return JSON.parse(r.substring(h, ++n - Number(f)));
      } catch (p) {
        a(String(p));
      }
    else if (ht.STR & e)
      try {
        return JSON.parse(r.substring(h, n - Number(f)) + '"');
      } catch {
        return JSON.parse(r.substring(h, r.lastIndexOf("\\")) + '"');
      }
    s("Unterminated string literal");
  }, c = () => {
    n++, d();
    const h = {};
    try {
      for (; r[n] !== "}"; ) {
        if (d(), n >= t && ht.OBJ & e)
          return h;
        const f = o();
        d(), n++;
        try {
          const p = i();
          Object.defineProperty(h, f, { value: p, writable: !0, enumerable: !0, configurable: !0 });
        } catch (p) {
          if (ht.OBJ & e)
            return h;
          throw p;
        }
        d(), r[n] === "," && n++;
      }
    } catch {
      if (ht.OBJ & e)
        return h;
      s("Expected '}' at end of object");
    }
    return n++, h;
  }, u = () => {
    n++;
    const h = [];
    try {
      for (; r[n] !== "]"; )
        h.push(i()), d(), r[n] === "," && n++;
    } catch {
      if (ht.ARR & e)
        return h;
      s("Expected ']' at end of array");
    }
    return n++, h;
  }, l = () => {
    if (n === 0) {
      r === "-" && ht.NUM & e && s("Not sure what '-' is");
      try {
        return JSON.parse(r);
      } catch (f) {
        if (ht.NUM & e)
          try {
            return r[r.length - 1] === "." ? JSON.parse(r.substring(0, r.lastIndexOf("."))) : JSON.parse(r.substring(0, r.lastIndexOf("e")));
          } catch {
          }
        a(String(f));
      }
    }
    const h = n;
    for (r[n] === "-" && n++; r[n] && !",]}".includes(r[n]); )
      n++;
    n == t && !(ht.NUM & e) && s("Unterminated number literal");
    try {
      return JSON.parse(r.substring(h, n));
    } catch {
      r.substring(h, n) === "-" && ht.NUM & e && s("Not sure what '-' is");
      try {
        return JSON.parse(r.substring(h, r.lastIndexOf("e")));
      } catch (p) {
        a(String(p));
      }
    }
  }, d = () => {
    for (; n < t && ` 
\r	`.includes(r[n]); )
      n++;
  };
  return i();
}, ld = (r) => Sw(r, ht.ALL ^ ht.NUM);
var it, $r, Cn, Jr, Uo, Ea, zo, Bo, Zo, xa, Vo, dd;
class Zs extends op {
  constructor(e) {
    super(), it.add(this), $r.set(this, void 0), Cn.set(this, void 0), Jr.set(this, void 0), he(this, $r, e), he(this, Cn, []);
  }
  get currentChatCompletionSnapshot() {
    return k(this, Jr, "f");
  }
  /**
   * Intended for use on the frontend, consuming a stream produced with
   * `.toReadableStream()` on the backend.
   *
   * Note that messages sent to the model do not appear in `.on('message')`
   * in this context.
   */
  static fromReadableStream(e) {
    const t = new Zs(null);
    return t._run(() => t._fromReadableStream(e)), t;
  }
  static createChatCompletion(e, t, n) {
    const s = new Zs(t);
    return s._run(() => s._runChatCompletion(e, { ...t, stream: !0 }, { ...n, headers: { ...n == null ? void 0 : n.headers, "X-Stainless-Helper-Method": "stream" } })), s;
  }
  async _createChatCompletion(e, t, n) {
    var i;
    super._createChatCompletion;
    const s = n == null ? void 0 : n.signal;
    s && (s.aborted && this.controller.abort(), s.addEventListener("abort", () => this.controller.abort())), k(this, it, "m", Uo).call(this);
    const a = await e.chat.completions.create({ ...t, stream: !0 }, { ...n, signal: this.controller.signal });
    this._connected();
    for await (const o of a)
      k(this, it, "m", zo).call(this, o);
    if ((i = a.controller.signal) != null && i.aborted)
      throw new Ut();
    return this._addChatCompletion(k(this, it, "m", xa).call(this));
  }
  async _fromReadableStream(e, t) {
    var i;
    const n = t == null ? void 0 : t.signal;
    n && (n.aborted && this.controller.abort(), n.addEventListener("abort", () => this.controller.abort())), k(this, it, "m", Uo).call(this), this._connected();
    const s = vr.fromReadableStream(e, this.controller);
    let a;
    for await (const o of s)
      a && a !== o.id && this._addChatCompletion(k(this, it, "m", xa).call(this)), k(this, it, "m", zo).call(this, o), a = o.id;
    if ((i = s.controller.signal) != null && i.aborted)
      throw new Ut();
    return this._addChatCompletion(k(this, it, "m", xa).call(this));
  }
  [($r = /* @__PURE__ */ new WeakMap(), Cn = /* @__PURE__ */ new WeakMap(), Jr = /* @__PURE__ */ new WeakMap(), it = /* @__PURE__ */ new WeakSet(), Uo = function() {
    this.ended || he(this, Jr, void 0);
  }, Ea = function(t) {
    let n = k(this, Cn, "f")[t.index];
    return n || (n = {
      content_done: !1,
      refusal_done: !1,
      logprobs_content_done: !1,
      logprobs_refusal_done: !1,
      done_tool_calls: /* @__PURE__ */ new Set(),
      current_tool_call_index: null
    }, k(this, Cn, "f")[t.index] = n, n);
  }, zo = function(t) {
    var s, a, i, o, c, u, l, d, h, f, p, y, g, S, _;
    if (this.ended)
      return;
    const n = k(this, it, "m", dd).call(this, t);
    this._emit("chunk", t, n);
    for (const w of t.choices) {
      const T = n.choices[w.index];
      w.delta.content != null && ((s = T.message) == null ? void 0 : s.role) === "assistant" && ((a = T.message) != null && a.content) && (this._emit("content", w.delta.content, T.message.content), this._emit("content.delta", {
        delta: w.delta.content,
        snapshot: T.message.content,
        parsed: T.message.parsed
      })), w.delta.refusal != null && ((i = T.message) == null ? void 0 : i.role) === "assistant" && ((o = T.message) != null && o.refusal) && this._emit("refusal.delta", {
        delta: w.delta.refusal,
        snapshot: T.message.refusal
      }), ((c = w.logprobs) == null ? void 0 : c.content) != null && ((u = T.message) == null ? void 0 : u.role) === "assistant" && this._emit("logprobs.content.delta", {
        content: (l = w.logprobs) == null ? void 0 : l.content,
        snapshot: ((d = T.logprobs) == null ? void 0 : d.content) ?? []
      }), ((h = w.logprobs) == null ? void 0 : h.refusal) != null && ((f = T.message) == null ? void 0 : f.role) === "assistant" && this._emit("logprobs.refusal.delta", {
        refusal: (p = w.logprobs) == null ? void 0 : p.refusal,
        snapshot: ((y = T.logprobs) == null ? void 0 : y.refusal) ?? []
      });
      const x = k(this, it, "m", Ea).call(this, T);
      T.finish_reason && (k(this, it, "m", Zo).call(this, T), x.current_tool_call_index != null && k(this, it, "m", Bo).call(this, T, x.current_tool_call_index));
      for (const A of w.delta.tool_calls ?? [])
        x.current_tool_call_index !== A.index && (k(this, it, "m", Zo).call(this, T), x.current_tool_call_index != null && k(this, it, "m", Bo).call(this, T, x.current_tool_call_index)), x.current_tool_call_index = A.index;
      for (const A of w.delta.tool_calls ?? []) {
        const R = (g = T.message.tool_calls) == null ? void 0 : g[A.index];
        R != null && R.type && ((R == null ? void 0 : R.type) === "function" ? this._emit("tool_calls.function.arguments.delta", {
          name: (S = R.function) == null ? void 0 : S.name,
          index: A.index,
          arguments: R.function.arguments,
          parsed_arguments: R.function.parsed_arguments,
          arguments_delta: ((_ = A.function) == null ? void 0 : _.arguments) ?? ""
        }) : (R == null || R.type, void 0));
      }
    }
  }, Bo = function(t, n) {
    var i, o, c;
    if (k(this, it, "m", Ea).call(this, t).done_tool_calls.has(n))
      return;
    const a = (i = t.message.tool_calls) == null ? void 0 : i[n];
    if (!a)
      throw new Error("no tool call snapshot");
    if (!a.type)
      throw new Error("tool call snapshot missing `type`");
    if (a.type === "function") {
      const u = (c = (o = k(this, $r, "f")) == null ? void 0 : o.tools) == null ? void 0 : c.find((l) => fi(l) && l.function.name === a.function.name);
      this._emit("tool_calls.function.arguments.done", {
        name: a.function.name,
        index: n,
        arguments: a.function.arguments,
        parsed_arguments: na(u) ? u.$parseRaw(a.function.arguments) : u != null && u.function.strict ? JSON.parse(a.function.arguments) : null
      });
    } else
      a.type;
  }, Zo = function(t) {
    var s, a;
    const n = k(this, it, "m", Ea).call(this, t);
    if (t.message.content && !n.content_done) {
      n.content_done = !0;
      const i = k(this, it, "m", Vo).call(this);
      this._emit("content.done", {
        content: t.message.content,
        parsed: i ? i.$parseRaw(t.message.content) : null
      });
    }
    t.message.refusal && !n.refusal_done && (n.refusal_done = !0, this._emit("refusal.done", { refusal: t.message.refusal })), (s = t.logprobs) != null && s.content && !n.logprobs_content_done && (n.logprobs_content_done = !0, this._emit("logprobs.content.done", { content: t.logprobs.content })), (a = t.logprobs) != null && a.refusal && !n.logprobs_refusal_done && (n.logprobs_refusal_done = !0, this._emit("logprobs.refusal.done", { refusal: t.logprobs.refusal }));
  }, xa = function() {
    if (this.ended)
      throw new ce("stream has ended, this shouldn't happen");
    const t = k(this, Jr, "f");
    if (!t)
      throw new ce("request ended without sending any chunks");
    return he(this, Jr, void 0), he(this, Cn, []), Ew(t, k(this, $r, "f"));
  }, Vo = function() {
    var n;
    const t = (n = k(this, $r, "f")) == null ? void 0 : n.response_format;
    return Ou(t) ? t : null;
  }, dd = function(t) {
    var n, s, a, i;
    let o = k(this, Jr, "f");
    const { choices: c, ...u } = t;
    o ? Object.assign(o, u) : o = he(this, Jr, {
      ...u,
      choices: []
    });
    for (const { delta: l, finish_reason: d, index: h, logprobs: f = null, ...p } of t.choices) {
      let y = o.choices[h];
      if (y || (y = o.choices[h] = { finish_reason: d, index: h, message: {}, logprobs: f, ...p }), f)
        if (!y.logprobs)
          y.logprobs = Object.assign({}, f);
        else {
          const { content: A, refusal: R, ...E } = f;
          Object.assign(y.logprobs, E), A && ((n = y.logprobs).content ?? (n.content = []), y.logprobs.content.push(...A)), R && ((s = y.logprobs).refusal ?? (s.refusal = []), y.logprobs.refusal.push(...R));
        }
      if (d && (y.finish_reason = d, k(this, $r, "f") && tp(k(this, $r, "f")))) {
        if (d === "length")
          throw new Mf();
        if (d === "content_filter")
          throw new Df();
      }
      if (Object.assign(y, p), !l)
        continue;
      const { content: g, refusal: S, function_call: _, role: w, tool_calls: T, ...x } = l;
      if (Object.assign(y.message, x), S && (y.message.refusal = (y.message.refusal || "") + S), w && (y.message.role = w), _ && (y.message.function_call ? (_.name && (y.message.function_call.name = _.name), _.arguments && ((a = y.message.function_call).arguments ?? (a.arguments = ""), y.message.function_call.arguments += _.arguments)) : y.message.function_call = _), g && (y.message.content = (y.message.content || "") + g, !y.message.refusal && k(this, it, "m", Vo).call(this) && (y.message.parsed = ld(y.message.content))), T) {
        y.message.tool_calls || (y.message.tool_calls = []);
        for (const { index: A, id: R, type: E, function: V, ...ne } of T) {
          const z = (i = y.message.tool_calls)[A] ?? (i[A] = {});
          Object.assign(z, ne), R && (z.id = R), E && (z.type = E), V && (z.function ?? (z.function = { name: V.name ?? "", arguments: "" })), V != null && V.name && (z.function.name = V.name), V != null && V.arguments && (z.function.arguments += V.arguments, mw(k(this, $r, "f"), z) && (z.function.parsed_arguments = ld(z.function.arguments)));
        }
      }
    }
    return o;
  }, Symbol.asyncIterator)]() {
    const e = [], t = [];
    let n = !1;
    return this.on("chunk", (s) => {
      const a = t.shift();
      a ? a.resolve(s) : e.push(s);
    }), this.on("end", () => {
      n = !0;
      for (const s of t)
        s.resolve(void 0);
      t.length = 0;
    }), this.on("abort", (s) => {
      n = !0;
      for (const a of t)
        a.reject(s);
      t.length = 0;
    }), this.on("error", (s) => {
      n = !0;
      for (const a of t)
        a.reject(s);
      t.length = 0;
    }), {
      next: async () => e.length ? { value: e.shift(), done: !1 } : n ? { value: void 0, done: !0 } : new Promise((a, i) => t.push({ resolve: a, reject: i })).then((a) => a ? { value: a, done: !1 } : { value: void 0, done: !0 }),
      return: async () => (this.abort(), { value: void 0, done: !0 })
    };
  }
  toReadableStream() {
    return new vr(this[Symbol.asyncIterator].bind(this), this.controller).toReadableStream();
  }
}
function Ew(r, e) {
  const { id: t, choices: n, created: s, model: a, system_fingerprint: i, ...o } = r, c = {
    ...o,
    id: t,
    choices: n.map(({ message: u, finish_reason: l, index: d, logprobs: h, ...f }) => {
      if (!l)
        throw new ce(`missing finish_reason for choice ${d}`);
      const { content: p = null, function_call: y, tool_calls: g, ...S } = u, _ = u.role;
      if (!_)
        throw new ce(`missing role for choice ${d}`);
      if (y) {
        const { arguments: w, name: T } = y;
        if (w == null)
          throw new ce(`missing function_call.arguments for choice ${d}`);
        if (!T)
          throw new ce(`missing function_call.name for choice ${d}`);
        return {
          ...f,
          message: {
            content: p,
            function_call: { arguments: w, name: T },
            role: _,
            refusal: u.refusal ?? null
          },
          finish_reason: l,
          index: d,
          logprobs: h
        };
      }
      return g ? {
        ...f,
        index: d,
        finish_reason: l,
        logprobs: h,
        message: {
          ...S,
          role: _,
          content: p,
          refusal: u.refusal ?? null,
          tool_calls: g.map((w, T) => {
            const { function: x, type: A, id: R, ...E } = w, { arguments: V, name: ne, ...z } = x || {};
            if (R == null)
              throw new ce(`missing choices[${d}].tool_calls[${T}].id
${Ia(r)}`);
            if (A == null)
              throw new ce(`missing choices[${d}].tool_calls[${T}].type
${Ia(r)}`);
            if (ne == null)
              throw new ce(`missing choices[${d}].tool_calls[${T}].function.name
${Ia(r)}`);
            if (V == null)
              throw new ce(`missing choices[${d}].tool_calls[${T}].function.arguments
${Ia(r)}`);
            return { ...E, id: R, type: A, function: { ...z, name: ne, arguments: V } };
          })
        }
      } : {
        ...f,
        message: { ...S, content: p, role: _, refusal: u.refusal ?? null },
        finish_reason: l,
        index: d,
        logprobs: h
      };
    }),
    created: s,
    model: a,
    object: "chat.completion",
    ...i ? { system_fingerprint: i } : {}
  };
  return hw(c, e);
}
function Ia(r) {
  return JSON.stringify(r);
}
class yi extends Zs {
  static fromReadableStream(e) {
    const t = new yi(null);
    return t._run(() => t._fromReadableStream(e)), t;
  }
  static runTools(e, t, n) {
    const s = new yi(
      // @ts-expect-error TODO these types are incompatible
      t
    ), a = {
      ...n,
      headers: { ...n == null ? void 0 : n.headers, "X-Stainless-Helper-Method": "runTools" }
    };
    return s._run(() => s._runTools(e, t, a)), s;
  }
}
let Ru = class extends ie {
  constructor() {
    super(...arguments), this.messages = new ep(this._client);
  }
  create(e, t) {
    return this._client.post("/chat/completions", { body: e, ...t, stream: e.stream ?? !1 });
  }
  /**
   * Get a stored chat completion. Only Chat Completions that have been created with
   * the `store` parameter set to `true` will be returned.
   *
   * @example
   * ```ts
   * const chatCompletion =
   *   await client.chat.completions.retrieve('completion_id');
   * ```
   */
  retrieve(e, t) {
    return this._client.get(F`/chat/completions/${e}`, t);
  }
  /**
   * Modify a stored chat completion. Only Chat Completions that have been created
   * with the `store` parameter set to `true` can be modified. Currently, the only
   * supported modification is to update the `metadata` field.
   *
   * @example
   * ```ts
   * const chatCompletion = await client.chat.completions.update(
   *   'completion_id',
   *   { metadata: { foo: 'string' } },
   * );
   * ```
   */
  update(e, t, n) {
    return this._client.post(F`/chat/completions/${e}`, { body: t, ...n });
  }
  /**
   * List stored Chat Completions. Only Chat Completions that have been stored with
   * the `store` parameter set to `true` will be returned.
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const chatCompletion of client.chat.completions.list()) {
   *   // ...
   * }
   * ```
   */
  list(e = {}, t) {
    return this._client.getAPIList("/chat/completions", rt, { query: e, ...t });
  }
  /**
   * Delete a stored chat completion. Only Chat Completions that have been created
   * with the `store` parameter set to `true` can be deleted.
   *
   * @example
   * ```ts
   * const chatCompletionDeleted =
   *   await client.chat.completions.delete('completion_id');
   * ```
   */
  delete(e, t) {
    return this._client.delete(F`/chat/completions/${e}`, t);
  }
  parse(e, t) {
    return gw(e.tools), this._client.chat.completions.create(e, {
      ...t,
      headers: {
        ...t == null ? void 0 : t.headers,
        "X-Stainless-Helper-Method": "chat.completions.parse"
      }
    })._thenUnwrap((n) => Au(n, e));
  }
  runTools(e, t) {
    return e.stream ? yi.runTools(this._client, e, t) : Cu.runTools(this._client, e, t);
  }
  /**
   * Creates a chat completion stream
   */
  stream(e, t) {
    return Zs.createChatCompletion(this._client, e, t);
  }
};
Ru.Messages = ep;
class Nu extends ie {
  constructor() {
    super(...arguments), this.completions = new Ru(this._client);
  }
}
Nu.Completions = Ru;
const bp = /* @__PURE__ */ Symbol("brand.privateNullableHeaders");
function* xw(r) {
  if (!r)
    return;
  if (bp in r) {
    const { values: n, nulls: s } = r;
    yield* n.entries();
    for (const a of s)
      yield [a, null];
    return;
  }
  let e = !1, t;
  r instanceof Headers ? t = r.entries() : Gl(r) ? t = r : (e = !0, t = Object.entries(r ?? {}));
  for (let n of t) {
    const s = n[0];
    if (typeof s != "string")
      throw new TypeError("expected header name to be a string");
    const a = Gl(n[1]) ? n[1] : [n[1]];
    let i = !1;
    for (const o of a)
      o !== void 0 && (e && !i && (i = !0, yield [s, null]), yield [s, o]);
  }
}
const Y = (r) => {
  const e = new Headers(), t = /* @__PURE__ */ new Set();
  for (const n of r) {
    const s = /* @__PURE__ */ new Set();
    for (const [a, i] of xw(n)) {
      const o = a.toLowerCase();
      s.has(o) || (e.delete(a), s.add(o)), i === null ? (e.delete(a), t.add(o)) : (e.append(a, i), t.delete(o));
    }
  }
  return { [bp]: !0, values: e, nulls: t };
};
class Sp extends ie {
  /**
   * Generates audio from the input text.
   *
   * @example
   * ```ts
   * const speech = await client.audio.speech.create({
   *   input: 'input',
   *   model: 'string',
   *   voice: 'ash',
   * });
   *
   * const content = await speech.blob();
   * console.log(content);
   * ```
   */
  create(e, t) {
    return this._client.post("/audio/speech", {
      body: e,
      ...t,
      headers: Y([{ Accept: "application/octet-stream" }, t == null ? void 0 : t.headers]),
      __binaryResponse: !0
    });
  }
}
class Tp extends ie {
  create(e, t) {
    return this._client.post("/audio/transcriptions", Sn({
      body: e,
      ...t,
      stream: e.stream ?? !1,
      __metadata: { model: e.model }
    }, this._client));
  }
}
class Ep extends ie {
  create(e, t) {
    return this._client.post("/audio/translations", Sn({ body: e, ...t, __metadata: { model: e.model } }, this._client));
  }
}
class sa extends ie {
  constructor() {
    super(...arguments), this.transcriptions = new Tp(this._client), this.translations = new Ep(this._client), this.speech = new Sp(this._client);
  }
}
sa.Transcriptions = Tp;
sa.Translations = Ep;
sa.Speech = Sp;
class xp extends ie {
  /**
   * Creates and executes a batch from an uploaded file of requests
   */
  create(e, t) {
    return this._client.post("/batches", { body: e, ...t });
  }
  /**
   * Retrieves a batch.
   */
  retrieve(e, t) {
    return this._client.get(F`/batches/${e}`, t);
  }
  /**
   * List your organization's batches.
   */
  list(e = {}, t) {
    return this._client.getAPIList("/batches", rt, { query: e, ...t });
  }
  /**
   * Cancels an in-progress batch. The batch will be in status `cancelling` for up to
   * 10 minutes, before changing to `cancelled`, where it will have partial results
   * (if any) available in the output file.
   */
  cancel(e, t) {
    return this._client.post(F`/batches/${e}/cancel`, t);
  }
}
class Ip extends ie {
  /**
   * Create an assistant with a model and instructions.
   *
   * @example
   * ```ts
   * const assistant = await client.beta.assistants.create({
   *   model: 'gpt-4o',
   * });
   * ```
   */
  create(e, t) {
    return this._client.post("/assistants", {
      body: e,
      ...t,
      headers: Y([{ "OpenAI-Beta": "assistants=v2" }, t == null ? void 0 : t.headers])
    });
  }
  /**
   * Retrieves an assistant.
   *
   * @example
   * ```ts
   * const assistant = await client.beta.assistants.retrieve(
   *   'assistant_id',
   * );
   * ```
   */
  retrieve(e, t) {
    return this._client.get(F`/assistants/${e}`, {
      ...t,
      headers: Y([{ "OpenAI-Beta": "assistants=v2" }, t == null ? void 0 : t.headers])
    });
  }
  /**
   * Modifies an assistant.
   *
   * @example
   * ```ts
   * const assistant = await client.beta.assistants.update(
   *   'assistant_id',
   * );
   * ```
   */
  update(e, t, n) {
    return this._client.post(F`/assistants/${e}`, {
      body: t,
      ...n,
      headers: Y([{ "OpenAI-Beta": "assistants=v2" }, n == null ? void 0 : n.headers])
    });
  }
  /**
   * Returns a list of assistants.
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const assistant of client.beta.assistants.list()) {
   *   // ...
   * }
   * ```
   */
  list(e = {}, t) {
    return this._client.getAPIList("/assistants", rt, {
      query: e,
      ...t,
      headers: Y([{ "OpenAI-Beta": "assistants=v2" }, t == null ? void 0 : t.headers])
    });
  }
  /**
   * Delete an assistant.
   *
   * @example
   * ```ts
   * const assistantDeleted =
   *   await client.beta.assistants.delete('assistant_id');
   * ```
   */
  delete(e, t) {
    return this._client.delete(F`/assistants/${e}`, {
      ...t,
      headers: Y([{ "OpenAI-Beta": "assistants=v2" }, t == null ? void 0 : t.headers])
    });
  }
}
let kp = class extends ie {
  /**
   * Create an ephemeral API token for use in client-side applications with the
   * Realtime API. Can be configured with the same session parameters as the
   * `session.update` client event.
   *
   * It responds with a session object, plus a `client_secret` key which contains a
   * usable ephemeral API token that can be used to authenticate browser clients for
   * the Realtime API.
   *
   * @example
   * ```ts
   * const session =
   *   await client.beta.realtime.sessions.create();
   * ```
   */
  create(e, t) {
    return this._client.post("/realtime/sessions", {
      body: e,
      ...t,
      headers: Y([{ "OpenAI-Beta": "assistants=v2" }, t == null ? void 0 : t.headers])
    });
  }
};
class Op extends ie {
  /**
   * Create an ephemeral API token for use in client-side applications with the
   * Realtime API specifically for realtime transcriptions. Can be configured with
   * the same session parameters as the `transcription_session.update` client event.
   *
   * It responds with a session object, plus a `client_secret` key which contains a
   * usable ephemeral API token that can be used to authenticate browser clients for
   * the Realtime API.
   *
   * @example
   * ```ts
   * const transcriptionSession =
   *   await client.beta.realtime.transcriptionSessions.create();
   * ```
   */
  create(e, t) {
    return this._client.post("/realtime/transcription_sessions", {
      body: e,
      ...t,
      headers: Y([{ "OpenAI-Beta": "assistants=v2" }, t == null ? void 0 : t.headers])
    });
  }
}
let Qi = class extends ie {
  constructor() {
    super(...arguments), this.sessions = new kp(this._client), this.transcriptionSessions = new Op(this._client);
  }
};
Qi.Sessions = kp;
Qi.TranscriptionSessions = Op;
class Ap extends ie {
  /**
   * Create a ChatKit session
   *
   * @example
   * ```ts
   * const chatSession =
   *   await client.beta.chatkit.sessions.create({
   *     user: 'x',
   *     workflow: { id: 'id' },
   *   });
   * ```
   */
  create(e, t) {
    return this._client.post("/chatkit/sessions", {
      body: e,
      ...t,
      headers: Y([{ "OpenAI-Beta": "chatkit_beta=v1" }, t == null ? void 0 : t.headers])
    });
  }
  /**
   * Cancel a ChatKit session
   *
   * @example
   * ```ts
   * const chatSession =
   *   await client.beta.chatkit.sessions.cancel('cksess_123');
   * ```
   */
  cancel(e, t) {
    return this._client.post(F`/chatkit/sessions/${e}/cancel`, {
      ...t,
      headers: Y([{ "OpenAI-Beta": "chatkit_beta=v1" }, t == null ? void 0 : t.headers])
    });
  }
}
let $p = class extends ie {
  /**
   * Retrieve a ChatKit thread
   *
   * @example
   * ```ts
   * const chatkitThread =
   *   await client.beta.chatkit.threads.retrieve('cthr_123');
   * ```
   */
  retrieve(e, t) {
    return this._client.get(F`/chatkit/threads/${e}`, {
      ...t,
      headers: Y([{ "OpenAI-Beta": "chatkit_beta=v1" }, t == null ? void 0 : t.headers])
    });
  }
  /**
   * List ChatKit threads
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const chatkitThread of client.beta.chatkit.threads.list()) {
   *   // ...
   * }
   * ```
   */
  list(e = {}, t) {
    return this._client.getAPIList("/chatkit/threads", hi, {
      query: e,
      ...t,
      headers: Y([{ "OpenAI-Beta": "chatkit_beta=v1" }, t == null ? void 0 : t.headers])
    });
  }
  /**
   * Delete a ChatKit thread
   *
   * @example
   * ```ts
   * const thread = await client.beta.chatkit.threads.delete(
   *   'cthr_123',
   * );
   * ```
   */
  delete(e, t) {
    return this._client.delete(F`/chatkit/threads/${e}`, {
      ...t,
      headers: Y([{ "OpenAI-Beta": "chatkit_beta=v1" }, t == null ? void 0 : t.headers])
    });
  }
  /**
   * List ChatKit thread items
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const thread of client.beta.chatkit.threads.listItems(
   *   'cthr_123',
   * )) {
   *   // ...
   * }
   * ```
   */
  listItems(e, t = {}, n) {
    return this._client.getAPIList(F`/chatkit/threads/${e}/items`, hi, { query: t, ...n, headers: Y([{ "OpenAI-Beta": "chatkit_beta=v1" }, n == null ? void 0 : n.headers]) });
  }
};
class eo extends ie {
  constructor() {
    super(...arguments), this.sessions = new Ap(this._client), this.threads = new $p(this._client);
  }
}
eo.Sessions = Ap;
eo.Threads = $p;
class Cp extends ie {
  /**
   * Create a message.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  create(e, t, n) {
    return this._client.post(F`/threads/${e}/messages`, {
      body: t,
      ...n,
      headers: Y([{ "OpenAI-Beta": "assistants=v2" }, n == null ? void 0 : n.headers])
    });
  }
  /**
   * Retrieve a message.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  retrieve(e, t, n) {
    const { thread_id: s } = t;
    return this._client.get(F`/threads/${s}/messages/${e}`, {
      ...n,
      headers: Y([{ "OpenAI-Beta": "assistants=v2" }, n == null ? void 0 : n.headers])
    });
  }
  /**
   * Modifies a message.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  update(e, t, n) {
    const { thread_id: s, ...a } = t;
    return this._client.post(F`/threads/${s}/messages/${e}`, {
      body: a,
      ...n,
      headers: Y([{ "OpenAI-Beta": "assistants=v2" }, n == null ? void 0 : n.headers])
    });
  }
  /**
   * Returns a list of messages for a given thread.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  list(e, t = {}, n) {
    return this._client.getAPIList(F`/threads/${e}/messages`, rt, {
      query: t,
      ...n,
      headers: Y([{ "OpenAI-Beta": "assistants=v2" }, n == null ? void 0 : n.headers])
    });
  }
  /**
   * Deletes a message.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  delete(e, t, n) {
    const { thread_id: s } = t;
    return this._client.delete(F`/threads/${s}/messages/${e}`, {
      ...n,
      headers: Y([{ "OpenAI-Beta": "assistants=v2" }, n == null ? void 0 : n.headers])
    });
  }
}
class Rp extends ie {
  /**
   * Retrieves a run step.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  retrieve(e, t, n) {
    const { thread_id: s, run_id: a, ...i } = t;
    return this._client.get(F`/threads/${s}/runs/${a}/steps/${e}`, {
      query: i,
      ...n,
      headers: Y([{ "OpenAI-Beta": "assistants=v2" }, n == null ? void 0 : n.headers])
    });
  }
  /**
   * Returns a list of run steps belonging to a run.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  list(e, t, n) {
    const { thread_id: s, ...a } = t;
    return this._client.getAPIList(F`/threads/${s}/runs/${e}/steps`, rt, {
      query: a,
      ...n,
      headers: Y([{ "OpenAI-Beta": "assistants=v2" }, n == null ? void 0 : n.headers])
    });
  }
}
const Iw = (r) => {
  if (typeof Buffer < "u") {
    const e = Buffer.from(r, "base64");
    return Array.from(new Float32Array(e.buffer, e.byteOffset, e.length / Float32Array.BYTES_PER_ELEMENT));
  } else {
    const e = atob(r), t = e.length, n = new Uint8Array(t);
    for (let s = 0; s < t; s++)
      n[s] = e.charCodeAt(s);
    return Array.from(new Float32Array(n.buffer));
  }
}, Rn = (r) => {
  var e, t, n, s, a;
  if (typeof globalThis.process < "u")
    return ((t = (e = globalThis.process.env) == null ? void 0 : e[r]) == null ? void 0 : t.trim()) ?? void 0;
  if (typeof globalThis.Deno < "u")
    return (a = (s = (n = globalThis.Deno.env) == null ? void 0 : n.get) == null ? void 0 : s.call(n, r)) == null ? void 0 : a.trim();
};
var vt, gn, $c, yr, ei, ir, _n, Bn, mn, wi, Ft, ti, ri, Ps, Ss, Ts, hd, fd, pd, md, gd, _d, yd;
class Ls extends $u {
  constructor() {
    super(...arguments), vt.add(this), $c.set(this, []), yr.set(this, {}), ei.set(this, {}), ir.set(this, void 0), _n.set(this, void 0), Bn.set(this, void 0), mn.set(this, void 0), wi.set(this, void 0), Ft.set(this, void 0), ti.set(this, void 0), ri.set(this, void 0), Ps.set(this, void 0);
  }
  [($c = /* @__PURE__ */ new WeakMap(), yr = /* @__PURE__ */ new WeakMap(), ei = /* @__PURE__ */ new WeakMap(), ir = /* @__PURE__ */ new WeakMap(), _n = /* @__PURE__ */ new WeakMap(), Bn = /* @__PURE__ */ new WeakMap(), mn = /* @__PURE__ */ new WeakMap(), wi = /* @__PURE__ */ new WeakMap(), Ft = /* @__PURE__ */ new WeakMap(), ti = /* @__PURE__ */ new WeakMap(), ri = /* @__PURE__ */ new WeakMap(), Ps = /* @__PURE__ */ new WeakMap(), vt = /* @__PURE__ */ new WeakSet(), Symbol.asyncIterator)]() {
    const e = [], t = [];
    let n = !1;
    return this.on("event", (s) => {
      const a = t.shift();
      a ? a.resolve(s) : e.push(s);
    }), this.on("end", () => {
      n = !0;
      for (const s of t)
        s.resolve(void 0);
      t.length = 0;
    }), this.on("abort", (s) => {
      n = !0;
      for (const a of t)
        a.reject(s);
      t.length = 0;
    }), this.on("error", (s) => {
      n = !0;
      for (const a of t)
        a.reject(s);
      t.length = 0;
    }), {
      next: async () => e.length ? { value: e.shift(), done: !1 } : n ? { value: void 0, done: !0 } : new Promise((a, i) => t.push({ resolve: a, reject: i })).then((a) => a ? { value: a, done: !1 } : { value: void 0, done: !0 }),
      return: async () => (this.abort(), { value: void 0, done: !0 })
    };
  }
  static fromReadableStream(e) {
    const t = new gn();
    return t._run(() => t._fromReadableStream(e)), t;
  }
  async _fromReadableStream(e, t) {
    var a;
    const n = t == null ? void 0 : t.signal;
    n && (n.aborted && this.controller.abort(), n.addEventListener("abort", () => this.controller.abort())), this._connected();
    const s = vr.fromReadableStream(e, this.controller);
    for await (const i of s)
      k(this, vt, "m", Ss).call(this, i);
    if ((a = s.controller.signal) != null && a.aborted)
      throw new Ut();
    return this._addRun(k(this, vt, "m", Ts).call(this));
  }
  toReadableStream() {
    return new vr(this[Symbol.asyncIterator].bind(this), this.controller).toReadableStream();
  }
  static createToolAssistantStream(e, t, n, s) {
    const a = new gn();
    return a._run(() => a._runToolAssistantStream(e, t, n, {
      ...s,
      headers: { ...s == null ? void 0 : s.headers, "X-Stainless-Helper-Method": "stream" }
    })), a;
  }
  async _createToolAssistantStream(e, t, n, s) {
    var c;
    const a = s == null ? void 0 : s.signal;
    a && (a.aborted && this.controller.abort(), a.addEventListener("abort", () => this.controller.abort()));
    const i = { ...n, stream: !0 }, o = await e.submitToolOutputs(t, i, {
      ...s,
      signal: this.controller.signal
    });
    this._connected();
    for await (const u of o)
      k(this, vt, "m", Ss).call(this, u);
    if ((c = o.controller.signal) != null && c.aborted)
      throw new Ut();
    return this._addRun(k(this, vt, "m", Ts).call(this));
  }
  static createThreadAssistantStream(e, t, n) {
    const s = new gn();
    return s._run(() => s._threadAssistantStream(e, t, {
      ...n,
      headers: { ...n == null ? void 0 : n.headers, "X-Stainless-Helper-Method": "stream" }
    })), s;
  }
  static createAssistantStream(e, t, n, s) {
    const a = new gn();
    return a._run(() => a._runAssistantStream(e, t, n, {
      ...s,
      headers: { ...s == null ? void 0 : s.headers, "X-Stainless-Helper-Method": "stream" }
    })), a;
  }
  currentEvent() {
    return k(this, ti, "f");
  }
  currentRun() {
    return k(this, ri, "f");
  }
  currentMessageSnapshot() {
    return k(this, ir, "f");
  }
  currentRunStepSnapshot() {
    return k(this, Ps, "f");
  }
  async finalRunSteps() {
    return await this.done(), Object.values(k(this, yr, "f"));
  }
  async finalMessages() {
    return await this.done(), Object.values(k(this, ei, "f"));
  }
  async finalRun() {
    if (await this.done(), !k(this, _n, "f"))
      throw Error("Final run was not received.");
    return k(this, _n, "f");
  }
  async _createThreadAssistantStream(e, t, n) {
    var o;
    const s = n == null ? void 0 : n.signal;
    s && (s.aborted && this.controller.abort(), s.addEventListener("abort", () => this.controller.abort()));
    const a = { ...t, stream: !0 }, i = await e.createAndRun(a, { ...n, signal: this.controller.signal });
    this._connected();
    for await (const c of i)
      k(this, vt, "m", Ss).call(this, c);
    if ((o = i.controller.signal) != null && o.aborted)
      throw new Ut();
    return this._addRun(k(this, vt, "m", Ts).call(this));
  }
  async _createAssistantStream(e, t, n, s) {
    var c;
    const a = s == null ? void 0 : s.signal;
    a && (a.aborted && this.controller.abort(), a.addEventListener("abort", () => this.controller.abort()));
    const i = { ...n, stream: !0 }, o = await e.create(t, i, { ...s, signal: this.controller.signal });
    this._connected();
    for await (const u of o)
      k(this, vt, "m", Ss).call(this, u);
    if ((c = o.controller.signal) != null && c.aborted)
      throw new Ut();
    return this._addRun(k(this, vt, "m", Ts).call(this));
  }
  static accumulateDelta(e, t) {
    for (const [n, s] of Object.entries(t)) {
      if (!e.hasOwnProperty(n)) {
        e[n] = s;
        continue;
      }
      let a = e[n];
      if (a == null) {
        e[n] = s;
        continue;
      }
      if (n === "index" || n === "type") {
        e[n] = s;
        continue;
      }
      if (typeof a == "string" && typeof s == "string")
        a += s;
      else if (typeof a == "number" && typeof s == "number")
        a += s;
      else if (Do(a) && Do(s))
        a = this.accumulateDelta(a, s);
      else if (Array.isArray(a) && Array.isArray(s)) {
        if (a.every((i) => typeof i == "string" || typeof i == "number")) {
          a.push(...s);
          continue;
        }
        for (const i of s) {
          if (!Do(i))
            throw new Error(`Expected array delta entry to be an object but got: ${i}`);
          const o = i.index;
          if (o == null)
            throw console.error(i), new Error("Expected array delta entry to have an `index` property");
          if (typeof o != "number")
            throw new Error(`Expected array delta entry \`index\` property to be a number but got ${o}`);
          const c = a[o];
          c == null ? a.push(i) : a[o] = this.accumulateDelta(c, i);
        }
        continue;
      } else
        throw Error(`Unhandled record type: ${n}, deltaValue: ${s}, accValue: ${a}`);
      e[n] = a;
    }
    return e;
  }
  _addRun(e) {
    return e;
  }
  async _threadAssistantStream(e, t, n) {
    return await this._createThreadAssistantStream(t, e, n);
  }
  async _runAssistantStream(e, t, n, s) {
    return await this._createAssistantStream(t, e, n, s);
  }
  async _runToolAssistantStream(e, t, n, s) {
    return await this._createToolAssistantStream(t, e, n, s);
  }
}
gn = Ls, Ss = function(e) {
  if (!this.ended)
    switch (he(this, ti, e), k(this, vt, "m", pd).call(this, e), e.event) {
      case "thread.created":
        break;
      case "thread.run.created":
      case "thread.run.queued":
      case "thread.run.in_progress":
      case "thread.run.requires_action":
      case "thread.run.completed":
      case "thread.run.incomplete":
      case "thread.run.failed":
      case "thread.run.cancelling":
      case "thread.run.cancelled":
      case "thread.run.expired":
        k(this, vt, "m", yd).call(this, e);
        break;
      case "thread.run.step.created":
      case "thread.run.step.in_progress":
      case "thread.run.step.delta":
      case "thread.run.step.completed":
      case "thread.run.step.failed":
      case "thread.run.step.cancelled":
      case "thread.run.step.expired":
        k(this, vt, "m", fd).call(this, e);
        break;
      case "thread.message.created":
      case "thread.message.in_progress":
      case "thread.message.delta":
      case "thread.message.completed":
      case "thread.message.incomplete":
        k(this, vt, "m", hd).call(this, e);
        break;
      case "error":
        throw new Error("Encountered an error event in event processing - errors should be processed earlier");
    }
}, Ts = function() {
  if (this.ended)
    throw new ce("stream has ended, this shouldn't happen");
  if (!k(this, _n, "f"))
    throw Error("Final run has not been received");
  return k(this, _n, "f");
}, hd = function(e) {
  const [t, n] = k(this, vt, "m", gd).call(this, e, k(this, ir, "f"));
  he(this, ir, t), k(this, ei, "f")[t.id] = t;
  for (const s of n) {
    const a = t.content[s.index];
    (a == null ? void 0 : a.type) == "text" && this._emit("textCreated", a.text);
  }
  switch (e.event) {
    case "thread.message.created":
      this._emit("messageCreated", e.data);
      break;
    case "thread.message.in_progress":
      break;
    case "thread.message.delta":
      if (this._emit("messageDelta", e.data.delta, t), e.data.delta.content)
        for (const s of e.data.delta.content) {
          if (s.type == "text" && s.text) {
            let a = s.text, i = t.content[s.index];
            if (i && i.type == "text")
              this._emit("textDelta", a, i.text);
            else
              throw Error("The snapshot associated with this text delta is not text or missing");
          }
          if (s.index != k(this, Bn, "f")) {
            if (k(this, mn, "f"))
              switch (k(this, mn, "f").type) {
                case "text":
                  this._emit("textDone", k(this, mn, "f").text, k(this, ir, "f"));
                  break;
                case "image_file":
                  this._emit("imageFileDone", k(this, mn, "f").image_file, k(this, ir, "f"));
                  break;
              }
            he(this, Bn, s.index);
          }
          he(this, mn, t.content[s.index]);
        }
      break;
    case "thread.message.completed":
    case "thread.message.incomplete":
      if (k(this, Bn, "f") !== void 0) {
        const s = e.data.content[k(this, Bn, "f")];
        if (s)
          switch (s.type) {
            case "image_file":
              this._emit("imageFileDone", s.image_file, k(this, ir, "f"));
              break;
            case "text":
              this._emit("textDone", s.text, k(this, ir, "f"));
              break;
          }
      }
      k(this, ir, "f") && this._emit("messageDone", e.data), he(this, ir, void 0);
  }
}, fd = function(e) {
  const t = k(this, vt, "m", md).call(this, e);
  switch (he(this, Ps, t), e.event) {
    case "thread.run.step.created":
      this._emit("runStepCreated", e.data);
      break;
    case "thread.run.step.delta":
      const n = e.data.delta;
      if (n.step_details && n.step_details.type == "tool_calls" && n.step_details.tool_calls && t.step_details.type == "tool_calls")
        for (const a of n.step_details.tool_calls)
          a.index == k(this, wi, "f") ? this._emit("toolCallDelta", a, t.step_details.tool_calls[a.index]) : (k(this, Ft, "f") && this._emit("toolCallDone", k(this, Ft, "f")), he(this, wi, a.index), he(this, Ft, t.step_details.tool_calls[a.index]), k(this, Ft, "f") && this._emit("toolCallCreated", k(this, Ft, "f")));
      this._emit("runStepDelta", e.data.delta, t);
      break;
    case "thread.run.step.completed":
    case "thread.run.step.failed":
    case "thread.run.step.cancelled":
    case "thread.run.step.expired":
      he(this, Ps, void 0), e.data.step_details.type == "tool_calls" && k(this, Ft, "f") && (this._emit("toolCallDone", k(this, Ft, "f")), he(this, Ft, void 0)), this._emit("runStepDone", e.data, t);
      break;
  }
}, pd = function(e) {
  k(this, $c, "f").push(e), this._emit("event", e);
}, md = function(e) {
  switch (e.event) {
    case "thread.run.step.created":
      return k(this, yr, "f")[e.data.id] = e.data, e.data;
    case "thread.run.step.delta":
      let t = k(this, yr, "f")[e.data.id];
      if (!t)
        throw Error("Received a RunStepDelta before creation of a snapshot");
      let n = e.data;
      if (n.delta) {
        const s = gn.accumulateDelta(t, n.delta);
        k(this, yr, "f")[e.data.id] = s;
      }
      return k(this, yr, "f")[e.data.id];
    case "thread.run.step.completed":
    case "thread.run.step.failed":
    case "thread.run.step.cancelled":
    case "thread.run.step.expired":
    case "thread.run.step.in_progress":
      k(this, yr, "f")[e.data.id] = e.data;
      break;
  }
  if (k(this, yr, "f")[e.data.id])
    return k(this, yr, "f")[e.data.id];
  throw new Error("No snapshot available");
}, gd = function(e, t) {
  let n = [];
  switch (e.event) {
    case "thread.message.created":
      return [e.data, n];
    case "thread.message.delta":
      if (!t)
        throw Error("Received a delta with no existing snapshot (there should be one from message creation)");
      let s = e.data;
      if (s.delta.content)
        for (const a of s.delta.content)
          if (a.index in t.content) {
            let i = t.content[a.index];
            t.content[a.index] = k(this, vt, "m", _d).call(this, a, i);
          } else
            t.content[a.index] = a, n.push(a);
      return [t, n];
    case "thread.message.in_progress":
    case "thread.message.completed":
    case "thread.message.incomplete":
      if (t)
        return [t, n];
      throw Error("Received thread message event with no existing snapshot");
  }
  throw Error("Tried to accumulate a non-message event");
}, _d = function(e, t) {
  return gn.accumulateDelta(t, e);
}, yd = function(e) {
  switch (he(this, ri, e.data), e.event) {
    case "thread.run.created":
      break;
    case "thread.run.queued":
      break;
    case "thread.run.in_progress":
      break;
    case "thread.run.requires_action":
    case "thread.run.cancelled":
    case "thread.run.failed":
    case "thread.run.completed":
    case "thread.run.expired":
    case "thread.run.incomplete":
      he(this, _n, e.data), k(this, Ft, "f") && (this._emit("toolCallDone", k(this, Ft, "f")), he(this, Ft, void 0));
      break;
  }
};
let Pu = class extends ie {
  constructor() {
    super(...arguments), this.steps = new Rp(this._client);
  }
  create(e, t, n) {
    const { include: s, ...a } = t;
    return this._client.post(F`/threads/${e}/runs`, {
      query: { include: s },
      body: a,
      ...n,
      headers: Y([{ "OpenAI-Beta": "assistants=v2" }, n == null ? void 0 : n.headers]),
      stream: t.stream ?? !1
    });
  }
  /**
   * Retrieves a run.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  retrieve(e, t, n) {
    const { thread_id: s } = t;
    return this._client.get(F`/threads/${s}/runs/${e}`, {
      ...n,
      headers: Y([{ "OpenAI-Beta": "assistants=v2" }, n == null ? void 0 : n.headers])
    });
  }
  /**
   * Modifies a run.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  update(e, t, n) {
    const { thread_id: s, ...a } = t;
    return this._client.post(F`/threads/${s}/runs/${e}`, {
      body: a,
      ...n,
      headers: Y([{ "OpenAI-Beta": "assistants=v2" }, n == null ? void 0 : n.headers])
    });
  }
  /**
   * Returns a list of runs belonging to a thread.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  list(e, t = {}, n) {
    return this._client.getAPIList(F`/threads/${e}/runs`, rt, {
      query: t,
      ...n,
      headers: Y([{ "OpenAI-Beta": "assistants=v2" }, n == null ? void 0 : n.headers])
    });
  }
  /**
   * Cancels a run that is `in_progress`.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  cancel(e, t, n) {
    const { thread_id: s } = t;
    return this._client.post(F`/threads/${s}/runs/${e}/cancel`, {
      ...n,
      headers: Y([{ "OpenAI-Beta": "assistants=v2" }, n == null ? void 0 : n.headers])
    });
  }
  /**
   * A helper to create a run an poll for a terminal state. More information on Run
   * lifecycles can be found here:
   * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
   */
  async createAndPoll(e, t, n) {
    const s = await this.create(e, t, n);
    return await this.poll(s.id, { thread_id: e }, n);
  }
  /**
   * Create a Run stream
   *
   * @deprecated use `stream` instead
   */
  createAndStream(e, t, n) {
    return Ls.createAssistantStream(e, this._client.beta.threads.runs, t, n);
  }
  /**
   * A helper to poll a run status until it reaches a terminal state. More
   * information on Run lifecycles can be found here:
   * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
   */
  async poll(e, t, n) {
    var a;
    const s = Y([
      n == null ? void 0 : n.headers,
      {
        "X-Stainless-Poll-Helper": "true",
        "X-Stainless-Custom-Poll-Interval": ((a = n == null ? void 0 : n.pollIntervalMs) == null ? void 0 : a.toString()) ?? void 0
      }
    ]);
    for (; ; ) {
      const { data: i, response: o } = await this.retrieve(e, t, {
        ...n,
        headers: { ...n == null ? void 0 : n.headers, ...s }
      }).withResponse();
      switch (i.status) {
        case "queued":
        case "in_progress":
        case "cancelling":
          let c = 5e3;
          if (n != null && n.pollIntervalMs)
            c = n.pollIntervalMs;
          else {
            const u = o.headers.get("openai-poll-after-ms");
            if (u) {
              const l = parseInt(u);
              isNaN(l) || (c = l);
            }
          }
          await ra(c);
          break;
        case "requires_action":
        case "incomplete":
        case "cancelled":
        case "completed":
        case "failed":
        case "expired":
          return i;
      }
    }
  }
  /**
   * Create a Run stream
   */
  stream(e, t, n) {
    return Ls.createAssistantStream(e, this._client.beta.threads.runs, t, n);
  }
  submitToolOutputs(e, t, n) {
    const { thread_id: s, ...a } = t;
    return this._client.post(F`/threads/${s}/runs/${e}/submit_tool_outputs`, {
      body: a,
      ...n,
      headers: Y([{ "OpenAI-Beta": "assistants=v2" }, n == null ? void 0 : n.headers]),
      stream: t.stream ?? !1
    });
  }
  /**
   * A helper to submit a tool output to a run and poll for a terminal run state.
   * More information on Run lifecycles can be found here:
   * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
   */
  async submitToolOutputsAndPoll(e, t, n) {
    const s = await this.submitToolOutputs(e, t, n);
    return await this.poll(s.id, t, n);
  }
  /**
   * Submit the tool outputs from a previous run and stream the run to a terminal
   * state. More information on Run lifecycles can be found here:
   * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
   */
  submitToolOutputsStream(e, t, n) {
    return Ls.createToolAssistantStream(e, this._client.beta.threads.runs, t, n);
  }
};
Pu.Steps = Rp;
class to extends ie {
  constructor() {
    super(...arguments), this.runs = new Pu(this._client), this.messages = new Cp(this._client);
  }
  /**
   * Create a thread.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  create(e = {}, t) {
    return this._client.post("/threads", {
      body: e,
      ...t,
      headers: Y([{ "OpenAI-Beta": "assistants=v2" }, t == null ? void 0 : t.headers])
    });
  }
  /**
   * Retrieves a thread.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  retrieve(e, t) {
    return this._client.get(F`/threads/${e}`, {
      ...t,
      headers: Y([{ "OpenAI-Beta": "assistants=v2" }, t == null ? void 0 : t.headers])
    });
  }
  /**
   * Modifies a thread.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  update(e, t, n) {
    return this._client.post(F`/threads/${e}`, {
      body: t,
      ...n,
      headers: Y([{ "OpenAI-Beta": "assistants=v2" }, n == null ? void 0 : n.headers])
    });
  }
  /**
   * Delete a thread.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  delete(e, t) {
    return this._client.delete(F`/threads/${e}`, {
      ...t,
      headers: Y([{ "OpenAI-Beta": "assistants=v2" }, t == null ? void 0 : t.headers])
    });
  }
  createAndRun(e, t) {
    return this._client.post("/threads/runs", {
      body: e,
      ...t,
      headers: Y([{ "OpenAI-Beta": "assistants=v2" }, t == null ? void 0 : t.headers]),
      stream: e.stream ?? !1
    });
  }
  /**
   * A helper to create a thread, start a run and then poll for a terminal state.
   * More information on Run lifecycles can be found here:
   * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
   */
  async createAndRunPoll(e, t) {
    const n = await this.createAndRun(e, t);
    return await this.runs.poll(n.id, { thread_id: n.thread_id }, t);
  }
  /**
   * Create a thread and stream the run back
   */
  createAndRunStream(e, t) {
    return Ls.createThreadAssistantStream(e, this._client.beta.threads, t);
  }
}
to.Runs = Pu;
to.Messages = Cp;
class is extends ie {
  constructor() {
    super(...arguments), this.realtime = new Qi(this._client), this.chatkit = new eo(this._client), this.assistants = new Ip(this._client), this.threads = new to(this._client);
  }
}
is.Realtime = Qi;
is.ChatKit = eo;
is.Assistants = Ip;
is.Threads = to;
class Np extends ie {
  create(e, t) {
    return this._client.post("/completions", { body: e, ...t, stream: e.stream ?? !1 });
  }
}
class Pp extends ie {
  /**
   * Retrieve Container File Content
   */
  retrieve(e, t, n) {
    const { container_id: s } = t;
    return this._client.get(F`/containers/${s}/files/${e}/content`, {
      ...n,
      headers: Y([{ Accept: "application/binary" }, n == null ? void 0 : n.headers]),
      __binaryResponse: !0
    });
  }
}
let Lu = class extends ie {
  constructor() {
    super(...arguments), this.content = new Pp(this._client);
  }
  /**
   * Create a Container File
   *
   * You can send either a multipart/form-data request with the raw file content, or
   * a JSON request with a file ID.
   */
  create(e, t, n) {
    return this._client.post(F`/containers/${e}/files`, Sn({ body: t, ...n }, this._client));
  }
  /**
   * Retrieve Container File
   */
  retrieve(e, t, n) {
    const { container_id: s } = t;
    return this._client.get(F`/containers/${s}/files/${e}`, n);
  }
  /**
   * List Container files
   */
  list(e, t = {}, n) {
    return this._client.getAPIList(F`/containers/${e}/files`, rt, {
      query: t,
      ...n
    });
  }
  /**
   * Delete Container File
   */
  delete(e, t, n) {
    const { container_id: s } = t;
    return this._client.delete(F`/containers/${s}/files/${e}`, {
      ...n,
      headers: Y([{ Accept: "*/*" }, n == null ? void 0 : n.headers])
    });
  }
};
Lu.Content = Pp;
class Mu extends ie {
  constructor() {
    super(...arguments), this.files = new Lu(this._client);
  }
  /**
   * Create Container
   */
  create(e, t) {
    return this._client.post("/containers", { body: e, ...t });
  }
  /**
   * Retrieve Container
   */
  retrieve(e, t) {
    return this._client.get(F`/containers/${e}`, t);
  }
  /**
   * List Containers
   */
  list(e = {}, t) {
    return this._client.getAPIList("/containers", rt, { query: e, ...t });
  }
  /**
   * Delete Container
   */
  delete(e, t) {
    return this._client.delete(F`/containers/${e}`, {
      ...t,
      headers: Y([{ Accept: "*/*" }, t == null ? void 0 : t.headers])
    });
  }
}
Mu.Files = Lu;
class Lp extends ie {
  /**
   * Create items in a conversation with the given ID.
   */
  create(e, t, n) {
    const { include: s, ...a } = t;
    return this._client.post(F`/conversations/${e}/items`, {
      query: { include: s },
      body: a,
      ...n
    });
  }
  /**
   * Get a single item from a conversation with the given IDs.
   */
  retrieve(e, t, n) {
    const { conversation_id: s, ...a } = t;
    return this._client.get(F`/conversations/${s}/items/${e}`, { query: a, ...n });
  }
  /**
   * List all items for a conversation with the given ID.
   */
  list(e, t = {}, n) {
    return this._client.getAPIList(F`/conversations/${e}/items`, hi, { query: t, ...n });
  }
  /**
   * Delete an item from a conversation with the given IDs.
   */
  delete(e, t, n) {
    const { conversation_id: s } = t;
    return this._client.delete(F`/conversations/${s}/items/${e}`, n);
  }
}
class Du extends ie {
  constructor() {
    super(...arguments), this.items = new Lp(this._client);
  }
  /**
   * Create a conversation.
   */
  create(e = {}, t) {
    return this._client.post("/conversations", { body: e, ...t });
  }
  /**
   * Get a conversation
   */
  retrieve(e, t) {
    return this._client.get(F`/conversations/${e}`, t);
  }
  /**
   * Update a conversation
   */
  update(e, t, n) {
    return this._client.post(F`/conversations/${e}`, { body: t, ...n });
  }
  /**
   * Delete a conversation. Items in the conversation will not be deleted.
   */
  delete(e, t) {
    return this._client.delete(F`/conversations/${e}`, t);
  }
}
Du.Items = Lp;
let Mp = class extends ie {
  /**
   * Creates an embedding vector representing the input text.
   *
   * @example
   * ```ts
   * const createEmbeddingResponse =
   *   await client.embeddings.create({
   *     input: 'The quick brown fox jumped over the lazy dog',
   *     model: 'text-embedding-3-small',
   *   });
   * ```
   */
  create(e, t) {
    const n = !!e.encoding_format;
    let s = n ? e.encoding_format : "base64";
    n && wt(this._client).debug("embeddings/user defined encoding_format:", e.encoding_format);
    const a = this._client.post("/embeddings", {
      body: {
        ...e,
        encoding_format: s
      },
      ...t
    });
    return n ? a : (wt(this._client).debug("embeddings/decoding base64 embeddings from base64"), a._thenUnwrap((i) => (i && i.data && i.data.forEach((o) => {
      const c = o.embedding;
      o.embedding = Iw(c);
    }), i)));
  }
};
class Dp extends ie {
  /**
   * Get an evaluation run output item by ID.
   */
  retrieve(e, t, n) {
    const { eval_id: s, run_id: a } = t;
    return this._client.get(F`/evals/${s}/runs/${a}/output_items/${e}`, n);
  }
  /**
   * Get a list of output items for an evaluation run.
   */
  list(e, t, n) {
    const { eval_id: s, ...a } = t;
    return this._client.getAPIList(F`/evals/${s}/runs/${e}/output_items`, rt, { query: a, ...n });
  }
}
class ju extends ie {
  constructor() {
    super(...arguments), this.outputItems = new Dp(this._client);
  }
  /**
   * Kicks off a new run for a given evaluation, specifying the data source, and what
   * model configuration to use to test. The datasource will be validated against the
   * schema specified in the config of the evaluation.
   */
  create(e, t, n) {
    return this._client.post(F`/evals/${e}/runs`, { body: t, ...n });
  }
  /**
   * Get an evaluation run by ID.
   */
  retrieve(e, t, n) {
    const { eval_id: s } = t;
    return this._client.get(F`/evals/${s}/runs/${e}`, n);
  }
  /**
   * Get a list of runs for an evaluation.
   */
  list(e, t = {}, n) {
    return this._client.getAPIList(F`/evals/${e}/runs`, rt, {
      query: t,
      ...n
    });
  }
  /**
   * Delete an eval run.
   */
  delete(e, t, n) {
    const { eval_id: s } = t;
    return this._client.delete(F`/evals/${s}/runs/${e}`, n);
  }
  /**
   * Cancel an ongoing evaluation run.
   */
  cancel(e, t, n) {
    const { eval_id: s } = t;
    return this._client.post(F`/evals/${s}/runs/${e}`, n);
  }
}
ju.OutputItems = Dp;
class Fu extends ie {
  constructor() {
    super(...arguments), this.runs = new ju(this._client);
  }
  /**
   * Create the structure of an evaluation that can be used to test a model's
   * performance. An evaluation is a set of testing criteria and the config for a
   * data source, which dictates the schema of the data used in the evaluation. After
   * creating an evaluation, you can run it on different models and model parameters.
   * We support several types of graders and datasources. For more information, see
   * the [Evals guide](https://platform.openai.com/docs/guides/evals).
   */
  create(e, t) {
    return this._client.post("/evals", { body: e, ...t });
  }
  /**
   * Get an evaluation by ID.
   */
  retrieve(e, t) {
    return this._client.get(F`/evals/${e}`, t);
  }
  /**
   * Update certain properties of an evaluation.
   */
  update(e, t, n) {
    return this._client.post(F`/evals/${e}`, { body: t, ...n });
  }
  /**
   * List evaluations for a project.
   */
  list(e = {}, t) {
    return this._client.getAPIList("/evals", rt, { query: e, ...t });
  }
  /**
   * Delete an evaluation.
   */
  delete(e, t) {
    return this._client.delete(F`/evals/${e}`, t);
  }
}
Fu.Runs = ju;
let jp = class extends ie {
  /**
   * Upload a file that can be used across various endpoints. Individual files can be
   * up to 512 MB, and the size of all files uploaded by one organization can be up
   * to 1 TB.
   *
   * - The Assistants API supports files up to 2 million tokens and of specific file
   *   types. See the
   *   [Assistants Tools guide](https://platform.openai.com/docs/assistants/tools)
   *   for details.
   * - The Fine-tuning API only supports `.jsonl` files. The input also has certain
   *   required formats for fine-tuning
   *   [chat](https://platform.openai.com/docs/api-reference/fine-tuning/chat-input)
   *   or
   *   [completions](https://platform.openai.com/docs/api-reference/fine-tuning/completions-input)
   *   models.
   * - The Batch API only supports `.jsonl` files up to 200 MB in size. The input
   *   also has a specific required
   *   [format](https://platform.openai.com/docs/api-reference/batch/request-input).
   *
   * Please [contact us](https://help.openai.com/) if you need to increase these
   * storage limits.
   */
  create(e, t) {
    return this._client.post("/files", Sn({ body: e, ...t }, this._client));
  }
  /**
   * Returns information about a specific file.
   */
  retrieve(e, t) {
    return this._client.get(F`/files/${e}`, t);
  }
  /**
   * Returns a list of files.
   */
  list(e = {}, t) {
    return this._client.getAPIList("/files", rt, { query: e, ...t });
  }
  /**
   * Delete a file and remove it from all vector stores.
   */
  delete(e, t) {
    return this._client.delete(F`/files/${e}`, t);
  }
  /**
   * Returns the contents of the specified file.
   */
  content(e, t) {
    return this._client.get(F`/files/${e}/content`, {
      ...t,
      headers: Y([{ Accept: "application/binary" }, t == null ? void 0 : t.headers]),
      __binaryResponse: !0
    });
  }
  /**
   * Waits for the given file to be processed, default timeout is 30 mins.
   */
  async waitForProcessing(e, { pollInterval: t = 5e3, maxWait: n = 30 * 60 * 1e3 } = {}) {
    const s = /* @__PURE__ */ new Set(["processed", "error", "deleted"]), a = Date.now();
    let i = await this.retrieve(e);
    for (; !i.status || !s.has(i.status); )
      if (await ra(t), i = await this.retrieve(e), Date.now() - a > n)
        throw new Gi({
          message: `Giving up on waiting for file ${e} to finish processing after ${n} milliseconds.`
        });
    return i;
  }
};
class Fp extends ie {
}
let Up = class extends ie {
  /**
   * Run a grader.
   *
   * @example
   * ```ts
   * const response = await client.fineTuning.alpha.graders.run({
   *   grader: {
   *     input: 'input',
   *     name: 'name',
   *     operation: 'eq',
   *     reference: 'reference',
   *     type: 'string_check',
   *   },
   *   model_sample: 'model_sample',
   * });
   * ```
   */
  run(e, t) {
    return this._client.post("/fine_tuning/alpha/graders/run", { body: e, ...t });
  }
  /**
   * Validate a grader.
   *
   * @example
   * ```ts
   * const response =
   *   await client.fineTuning.alpha.graders.validate({
   *     grader: {
   *       input: 'input',
   *       name: 'name',
   *       operation: 'eq',
   *       reference: 'reference',
   *       type: 'string_check',
   *     },
   *   });
   * ```
   */
  validate(e, t) {
    return this._client.post("/fine_tuning/alpha/graders/validate", { body: e, ...t });
  }
};
class Uu extends ie {
  constructor() {
    super(...arguments), this.graders = new Up(this._client);
  }
}
Uu.Graders = Up;
class zp extends ie {
  /**
   * **NOTE:** Calling this endpoint requires an [admin API key](../admin-api-keys).
   *
   * This enables organization owners to share fine-tuned models with other projects
   * in their organization.
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const permissionCreateResponse of client.fineTuning.checkpoints.permissions.create(
   *   'ft:gpt-4o-mini-2024-07-18:org:weather:B7R9VjQd',
   *   { project_ids: ['string'] },
   * )) {
   *   // ...
   * }
   * ```
   */
  create(e, t, n) {
    return this._client.getAPIList(F`/fine_tuning/checkpoints/${e}/permissions`, Xi, { body: t, method: "post", ...n });
  }
  /**
   * **NOTE:** This endpoint requires an [admin API key](../admin-api-keys).
   *
   * Organization owners can use this endpoint to view all permissions for a
   * fine-tuned model checkpoint.
   *
   * @example
   * ```ts
   * const permission =
   *   await client.fineTuning.checkpoints.permissions.retrieve(
   *     'ft-AF1WoRqd3aJAHsqc9NY7iL8F',
   *   );
   * ```
   */
  retrieve(e, t = {}, n) {
    return this._client.get(F`/fine_tuning/checkpoints/${e}/permissions`, {
      query: t,
      ...n
    });
  }
  /**
   * **NOTE:** This endpoint requires an [admin API key](../admin-api-keys).
   *
   * Organization owners can use this endpoint to delete a permission for a
   * fine-tuned model checkpoint.
   *
   * @example
   * ```ts
   * const permission =
   *   await client.fineTuning.checkpoints.permissions.delete(
   *     'cp_zc4Q7MP6XxulcVzj4MZdwsAB',
   *     {
   *       fine_tuned_model_checkpoint:
   *         'ft:gpt-4o-mini-2024-07-18:org:weather:B7R9VjQd',
   *     },
   *   );
   * ```
   */
  delete(e, t, n) {
    const { fine_tuned_model_checkpoint: s } = t;
    return this._client.delete(F`/fine_tuning/checkpoints/${s}/permissions/${e}`, n);
  }
}
let zu = class extends ie {
  constructor() {
    super(...arguments), this.permissions = new zp(this._client);
  }
};
zu.Permissions = zp;
class Bp extends ie {
  /**
   * List checkpoints for a fine-tuning job.
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const fineTuningJobCheckpoint of client.fineTuning.jobs.checkpoints.list(
   *   'ft-AF1WoRqd3aJAHsqc9NY7iL8F',
   * )) {
   *   // ...
   * }
   * ```
   */
  list(e, t = {}, n) {
    return this._client.getAPIList(F`/fine_tuning/jobs/${e}/checkpoints`, rt, { query: t, ...n });
  }
}
class Bu extends ie {
  constructor() {
    super(...arguments), this.checkpoints = new Bp(this._client);
  }
  /**
   * Creates a fine-tuning job which begins the process of creating a new model from
   * a given dataset.
   *
   * Response includes details of the enqueued job including job status and the name
   * of the fine-tuned models once complete.
   *
   * [Learn more about fine-tuning](https://platform.openai.com/docs/guides/model-optimization)
   *
   * @example
   * ```ts
   * const fineTuningJob = await client.fineTuning.jobs.create({
   *   model: 'gpt-4o-mini',
   *   training_file: 'file-abc123',
   * });
   * ```
   */
  create(e, t) {
    return this._client.post("/fine_tuning/jobs", { body: e, ...t });
  }
  /**
   * Get info about a fine-tuning job.
   *
   * [Learn more about fine-tuning](https://platform.openai.com/docs/guides/model-optimization)
   *
   * @example
   * ```ts
   * const fineTuningJob = await client.fineTuning.jobs.retrieve(
   *   'ft-AF1WoRqd3aJAHsqc9NY7iL8F',
   * );
   * ```
   */
  retrieve(e, t) {
    return this._client.get(F`/fine_tuning/jobs/${e}`, t);
  }
  /**
   * List your organization's fine-tuning jobs
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const fineTuningJob of client.fineTuning.jobs.list()) {
   *   // ...
   * }
   * ```
   */
  list(e = {}, t) {
    return this._client.getAPIList("/fine_tuning/jobs", rt, { query: e, ...t });
  }
  /**
   * Immediately cancel a fine-tune job.
   *
   * @example
   * ```ts
   * const fineTuningJob = await client.fineTuning.jobs.cancel(
   *   'ft-AF1WoRqd3aJAHsqc9NY7iL8F',
   * );
   * ```
   */
  cancel(e, t) {
    return this._client.post(F`/fine_tuning/jobs/${e}/cancel`, t);
  }
  /**
   * Get status updates for a fine-tuning job.
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const fineTuningJobEvent of client.fineTuning.jobs.listEvents(
   *   'ft-AF1WoRqd3aJAHsqc9NY7iL8F',
   * )) {
   *   // ...
   * }
   * ```
   */
  listEvents(e, t = {}, n) {
    return this._client.getAPIList(F`/fine_tuning/jobs/${e}/events`, rt, { query: t, ...n });
  }
  /**
   * Pause a fine-tune job.
   *
   * @example
   * ```ts
   * const fineTuningJob = await client.fineTuning.jobs.pause(
   *   'ft-AF1WoRqd3aJAHsqc9NY7iL8F',
   * );
   * ```
   */
  pause(e, t) {
    return this._client.post(F`/fine_tuning/jobs/${e}/pause`, t);
  }
  /**
   * Resume a fine-tune job.
   *
   * @example
   * ```ts
   * const fineTuningJob = await client.fineTuning.jobs.resume(
   *   'ft-AF1WoRqd3aJAHsqc9NY7iL8F',
   * );
   * ```
   */
  resume(e, t) {
    return this._client.post(F`/fine_tuning/jobs/${e}/resume`, t);
  }
}
Bu.Checkpoints = Bp;
class os extends ie {
  constructor() {
    super(...arguments), this.methods = new Fp(this._client), this.jobs = new Bu(this._client), this.checkpoints = new zu(this._client), this.alpha = new Uu(this._client);
  }
}
os.Methods = Fp;
os.Jobs = Bu;
os.Checkpoints = zu;
os.Alpha = Uu;
class Zp extends ie {
}
class Zu extends ie {
  constructor() {
    super(...arguments), this.graderModels = new Zp(this._client);
  }
}
Zu.GraderModels = Zp;
class Vp extends ie {
  /**
   * Creates a variation of a given image. This endpoint only supports `dall-e-2`.
   *
   * @example
   * ```ts
   * const imagesResponse = await client.images.createVariation({
   *   image: fs.createReadStream('otter.png'),
   * });
   * ```
   */
  createVariation(e, t) {
    return this._client.post("/images/variations", Sn({ body: e, ...t }, this._client));
  }
  edit(e, t) {
    return this._client.post("/images/edits", Sn({ body: e, ...t, stream: e.stream ?? !1 }, this._client));
  }
  generate(e, t) {
    return this._client.post("/images/generations", { body: e, ...t, stream: e.stream ?? !1 });
  }
}
class qp extends ie {
  /**
   * Retrieves a model instance, providing basic information about the model such as
   * the owner and permissioning.
   */
  retrieve(e, t) {
    return this._client.get(F`/models/${e}`, t);
  }
  /**
   * Lists the currently available models, and provides basic information about each
   * one such as the owner and availability.
   */
  list(e) {
    return this._client.getAPIList("/models", Xi, e);
  }
  /**
   * Delete a fine-tuned model. You must have the Owner role in your organization to
   * delete a model.
   */
  delete(e, t) {
    return this._client.delete(F`/models/${e}`, t);
  }
}
class Hp extends ie {
  /**
   * Classifies if text and/or image inputs are potentially harmful. Learn more in
   * the [moderation guide](https://platform.openai.com/docs/guides/moderation).
   */
  create(e, t) {
    return this._client.post("/moderations", { body: e, ...t });
  }
}
class Jp extends ie {
  /**
   * Accept an incoming SIP call and configure the realtime session that will handle
   * it.
   *
   * @example
   * ```ts
   * await client.realtime.calls.accept('call_id', {
   *   type: 'realtime',
   * });
   * ```
   */
  accept(e, t, n) {
    return this._client.post(F`/realtime/calls/${e}/accept`, {
      body: t,
      ...n,
      headers: Y([{ Accept: "*/*" }, n == null ? void 0 : n.headers])
    });
  }
  /**
   * End an active Realtime API call, whether it was initiated over SIP or WebRTC.
   *
   * @example
   * ```ts
   * await client.realtime.calls.hangup('call_id');
   * ```
   */
  hangup(e, t) {
    return this._client.post(F`/realtime/calls/${e}/hangup`, {
      ...t,
      headers: Y([{ Accept: "*/*" }, t == null ? void 0 : t.headers])
    });
  }
  /**
   * Transfer an active SIP call to a new destination using the SIP REFER verb.
   *
   * @example
   * ```ts
   * await client.realtime.calls.refer('call_id', {
   *   target_uri: 'tel:+14155550123',
   * });
   * ```
   */
  refer(e, t, n) {
    return this._client.post(F`/realtime/calls/${e}/refer`, {
      body: t,
      ...n,
      headers: Y([{ Accept: "*/*" }, n == null ? void 0 : n.headers])
    });
  }
  /**
   * Decline an incoming SIP call by returning a SIP status code to the caller.
   *
   * @example
   * ```ts
   * await client.realtime.calls.reject('call_id');
   * ```
   */
  reject(e, t = {}, n) {
    return this._client.post(F`/realtime/calls/${e}/reject`, {
      body: t,
      ...n,
      headers: Y([{ Accept: "*/*" }, n == null ? void 0 : n.headers])
    });
  }
}
class Wp extends ie {
  /**
   * Create a Realtime client secret with an associated session configuration.
   *
   * @example
   * ```ts
   * const clientSecret =
   *   await client.realtime.clientSecrets.create();
   * ```
   */
  create(e, t) {
    return this._client.post("/realtime/client_secrets", { body: e, ...t });
  }
}
class ro extends ie {
  constructor() {
    super(...arguments), this.clientSecrets = new Wp(this._client), this.calls = new Jp(this._client);
  }
}
ro.ClientSecrets = Wp;
ro.Calls = Jp;
function kw(r, e) {
  return !e || !Aw(e) ? {
    ...r,
    output_parsed: null,
    output: r.output.map((t) => t.type === "function_call" ? {
      ...t,
      parsed_arguments: null
    } : t.type === "message" ? {
      ...t,
      content: t.content.map((n) => ({
        ...n,
        parsed: null
      }))
    } : t)
  } : Gp(r, e);
}
function Gp(r, e) {
  const t = r.output.map((s) => {
    if (s.type === "function_call")
      return {
        ...s,
        parsed_arguments: Rw(e, s)
      };
    if (s.type === "message") {
      const a = s.content.map((i) => i.type === "output_text" ? {
        ...i,
        parsed: Ow(e, i.text)
      } : i);
      return {
        ...s,
        content: a
      };
    }
    return s;
  }), n = Object.assign({}, r, { output: t });
  return Object.getOwnPropertyDescriptor(r, "output_text") || Cc(n), Object.defineProperty(n, "output_parsed", {
    enumerable: !0,
    get() {
      for (const s of n.output)
        if (s.type === "message") {
          for (const a of s.content)
            if (a.type === "output_text" && a.parsed !== null)
              return a.parsed;
        }
      return null;
    }
  }), n;
}
function Ow(r, e) {
  var t, n, s, a;
  return ((n = (t = r.text) == null ? void 0 : t.format) == null ? void 0 : n.type) !== "json_schema" ? null : "$parseRaw" in ((s = r.text) == null ? void 0 : s.format) ? ((a = r.text) == null ? void 0 : a.format).$parseRaw(e) : JSON.parse(e);
}
function Aw(r) {
  var e;
  return !!Ou((e = r.text) == null ? void 0 : e.format);
}
function $w(r) {
  return (r == null ? void 0 : r.$brand) === "auto-parseable-tool";
}
function Cw(r, e) {
  return r.find((t) => t.type === "function" && t.name === e);
}
function Rw(r, e) {
  const t = Cw(r.tools ?? [], e.name);
  return {
    ...e,
    ...e,
    parsed_arguments: $w(t) ? t.$parseRaw(e.arguments) : t != null && t.strict ? JSON.parse(e.arguments) : null
  };
}
function Cc(r) {
  const e = [];
  for (const t of r.output)
    if (t.type === "message")
      for (const n of t.content)
        n.type === "output_text" && e.push(n.text);
  r.output_text = e.join("");
}
var Nn, ka, Wr, Oa, wd, vd, bd, Sd;
class Vu extends $u {
  constructor(e) {
    super(), Nn.add(this), ka.set(this, void 0), Wr.set(this, void 0), Oa.set(this, void 0), he(this, ka, e);
  }
  static createResponse(e, t, n) {
    const s = new Vu(t);
    return s._run(() => s._createOrRetrieveResponse(e, t, {
      ...n,
      headers: { ...n == null ? void 0 : n.headers, "X-Stainless-Helper-Method": "stream" }
    })), s;
  }
  async _createOrRetrieveResponse(e, t, n) {
    var o;
    const s = n == null ? void 0 : n.signal;
    s && (s.aborted && this.controller.abort(), s.addEventListener("abort", () => this.controller.abort())), k(this, Nn, "m", wd).call(this);
    let a, i = null;
    "response_id" in t ? (a = await e.responses.retrieve(t.response_id, { stream: !0 }, { ...n, signal: this.controller.signal, stream: !0 }), i = t.starting_after ?? null) : a = await e.responses.create({ ...t, stream: !0 }, { ...n, signal: this.controller.signal }), this._connected();
    for await (const c of a)
      k(this, Nn, "m", vd).call(this, c, i);
    if ((o = a.controller.signal) != null && o.aborted)
      throw new Ut();
    return k(this, Nn, "m", bd).call(this);
  }
  [(ka = /* @__PURE__ */ new WeakMap(), Wr = /* @__PURE__ */ new WeakMap(), Oa = /* @__PURE__ */ new WeakMap(), Nn = /* @__PURE__ */ new WeakSet(), wd = function() {
    this.ended || he(this, Wr, void 0);
  }, vd = function(t, n) {
    if (this.ended)
      return;
    const s = (i, o) => {
      (n == null || o.sequence_number > n) && this._emit(i, o);
    }, a = k(this, Nn, "m", Sd).call(this, t);
    switch (s("event", t), t.type) {
      case "response.output_text.delta": {
        const i = a.output[t.output_index];
        if (!i)
          throw new ce(`missing output at index ${t.output_index}`);
        if (i.type === "message") {
          const o = i.content[t.content_index];
          if (!o)
            throw new ce(`missing content at index ${t.content_index}`);
          if (o.type !== "output_text")
            throw new ce(`expected content to be 'output_text', got ${o.type}`);
          s("response.output_text.delta", {
            ...t,
            snapshot: o.text
          });
        }
        break;
      }
      case "response.function_call_arguments.delta": {
        const i = a.output[t.output_index];
        if (!i)
          throw new ce(`missing output at index ${t.output_index}`);
        i.type === "function_call" && s("response.function_call_arguments.delta", {
          ...t,
          snapshot: i.arguments
        });
        break;
      }
      default:
        s(t.type, t);
        break;
    }
  }, bd = function() {
    if (this.ended)
      throw new ce("stream has ended, this shouldn't happen");
    const t = k(this, Wr, "f");
    if (!t)
      throw new ce("request ended without sending any events");
    he(this, Wr, void 0);
    const n = Nw(t, k(this, ka, "f"));
    return he(this, Oa, n), n;
  }, Sd = function(t) {
    var s;
    let n = k(this, Wr, "f");
    if (!n) {
      if (t.type !== "response.created")
        throw new ce(`When snapshot hasn't been set yet, expected 'response.created' event, got ${t.type}`);
      return n = he(this, Wr, t.response), n;
    }
    switch (t.type) {
      case "response.output_item.added": {
        n.output.push(t.item);
        break;
      }
      case "response.content_part.added": {
        const a = n.output[t.output_index];
        if (!a)
          throw new ce(`missing output at index ${t.output_index}`);
        const i = a.type, o = t.part;
        i === "message" && o.type !== "reasoning_text" ? a.content.push(o) : i === "reasoning" && o.type === "reasoning_text" && (a.content || (a.content = []), a.content.push(o));
        break;
      }
      case "response.output_text.delta": {
        const a = n.output[t.output_index];
        if (!a)
          throw new ce(`missing output at index ${t.output_index}`);
        if (a.type === "message") {
          const i = a.content[t.content_index];
          if (!i)
            throw new ce(`missing content at index ${t.content_index}`);
          if (i.type !== "output_text")
            throw new ce(`expected content to be 'output_text', got ${i.type}`);
          i.text += t.delta;
        }
        break;
      }
      case "response.function_call_arguments.delta": {
        const a = n.output[t.output_index];
        if (!a)
          throw new ce(`missing output at index ${t.output_index}`);
        a.type === "function_call" && (a.arguments += t.delta);
        break;
      }
      case "response.reasoning_text.delta": {
        const a = n.output[t.output_index];
        if (!a)
          throw new ce(`missing output at index ${t.output_index}`);
        if (a.type === "reasoning") {
          const i = (s = a.content) == null ? void 0 : s[t.content_index];
          if (!i)
            throw new ce(`missing content at index ${t.content_index}`);
          if (i.type !== "reasoning_text")
            throw new ce(`expected content to be 'reasoning_text', got ${i.type}`);
          i.text += t.delta;
        }
        break;
      }
      case "response.completed": {
        he(this, Wr, t.response);
        break;
      }
    }
    return n;
  }, Symbol.asyncIterator)]() {
    const e = [], t = [];
    let n = !1;
    return this.on("event", (s) => {
      const a = t.shift();
      a ? a.resolve(s) : e.push(s);
    }), this.on("end", () => {
      n = !0;
      for (const s of t)
        s.resolve(void 0);
      t.length = 0;
    }), this.on("abort", (s) => {
      n = !0;
      for (const a of t)
        a.reject(s);
      t.length = 0;
    }), this.on("error", (s) => {
      n = !0;
      for (const a of t)
        a.reject(s);
      t.length = 0;
    }), {
      next: async () => e.length ? { value: e.shift(), done: !1 } : n ? { value: void 0, done: !0 } : new Promise((a, i) => t.push({ resolve: a, reject: i })).then((a) => a ? { value: a, done: !1 } : { value: void 0, done: !0 }),
      return: async () => (this.abort(), { value: void 0, done: !0 })
    };
  }
  /**
   * @returns a promise that resolves with the final Response, or rejects
   * if an error occurred or the stream ended prematurely without producing a REsponse.
   */
  async finalResponse() {
    await this.done();
    const e = k(this, Oa, "f");
    if (!e)
      throw new ce("stream ended without producing a ChatCompletion");
    return e;
  }
}
function Nw(r, e) {
  return kw(r, e);
}
class Kp extends ie {
  /**
   * Returns a list of input items for a given response.
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const responseItem of client.responses.inputItems.list(
   *   'response_id',
   * )) {
   *   // ...
   * }
   * ```
   */
  list(e, t = {}, n) {
    return this._client.getAPIList(F`/responses/${e}/input_items`, rt, { query: t, ...n });
  }
}
class Yp extends ie {
  /**
   * Get input token counts
   *
   * @example
   * ```ts
   * const response = await client.responses.inputTokens.count();
   * ```
   */
  count(e = {}, t) {
    return this._client.post("/responses/input_tokens", { body: e, ...t });
  }
}
class no extends ie {
  constructor() {
    super(...arguments), this.inputItems = new Kp(this._client), this.inputTokens = new Yp(this._client);
  }
  create(e, t) {
    return this._client.post("/responses", { body: e, ...t, stream: e.stream ?? !1 })._thenUnwrap((n) => ("object" in n && n.object === "response" && Cc(n), n));
  }
  retrieve(e, t = {}, n) {
    return this._client.get(F`/responses/${e}`, {
      query: t,
      ...n,
      stream: (t == null ? void 0 : t.stream) ?? !1
    })._thenUnwrap((s) => ("object" in s && s.object === "response" && Cc(s), s));
  }
  /**
   * Deletes a model response with the given ID.
   *
   * @example
   * ```ts
   * await client.responses.delete(
   *   'resp_677efb5139a88190b512bc3fef8e535d',
   * );
   * ```
   */
  delete(e, t) {
    return this._client.delete(F`/responses/${e}`, {
      ...t,
      headers: Y([{ Accept: "*/*" }, t == null ? void 0 : t.headers])
    });
  }
  parse(e, t) {
    return this._client.responses.create(e, t)._thenUnwrap((n) => Gp(n, e));
  }
  /**
   * Creates a model response stream
   */
  stream(e, t) {
    return Vu.createResponse(this._client, e, t);
  }
  /**
   * Cancels a model response with the given ID. Only responses created with the
   * `background` parameter set to `true` can be cancelled.
   * [Learn more](https://platform.openai.com/docs/guides/background).
   *
   * @example
   * ```ts
   * const response = await client.responses.cancel(
   *   'resp_677efb5139a88190b512bc3fef8e535d',
   * );
   * ```
   */
  cancel(e, t) {
    return this._client.post(F`/responses/${e}/cancel`, t);
  }
  /**
   * Compact conversation
   *
   * @example
   * ```ts
   * const compactedResponse = await client.responses.compact();
   * ```
   */
  compact(e = {}, t) {
    return this._client.post("/responses/compact", { body: e, ...t });
  }
}
no.InputItems = Kp;
no.InputTokens = Yp;
class Xp extends ie {
  /**
   * Adds a
   * [Part](https://platform.openai.com/docs/api-reference/uploads/part-object) to an
   * [Upload](https://platform.openai.com/docs/api-reference/uploads/object) object.
   * A Part represents a chunk of bytes from the file you are trying to upload.
   *
   * Each Part can be at most 64 MB, and you can add Parts until you hit the Upload
   * maximum of 8 GB.
   *
   * It is possible to add multiple Parts in parallel. You can decide the intended
   * order of the Parts when you
   * [complete the Upload](https://platform.openai.com/docs/api-reference/uploads/complete).
   */
  create(e, t, n) {
    return this._client.post(F`/uploads/${e}/parts`, Sn({ body: t, ...n }, this._client));
  }
}
class qu extends ie {
  constructor() {
    super(...arguments), this.parts = new Xp(this._client);
  }
  /**
   * Creates an intermediate
   * [Upload](https://platform.openai.com/docs/api-reference/uploads/object) object
   * that you can add
   * [Parts](https://platform.openai.com/docs/api-reference/uploads/part-object) to.
   * Currently, an Upload can accept at most 8 GB in total and expires after an hour
   * after you create it.
   *
   * Once you complete the Upload, we will create a
   * [File](https://platform.openai.com/docs/api-reference/files/object) object that
   * contains all the parts you uploaded. This File is usable in the rest of our
   * platform as a regular File object.
   *
   * For certain `purpose` values, the correct `mime_type` must be specified. Please
   * refer to documentation for the
   * [supported MIME types for your use case](https://platform.openai.com/docs/assistants/tools/file-search#supported-files).
   *
   * For guidance on the proper filename extensions for each purpose, please follow
   * the documentation on
   * [creating a File](https://platform.openai.com/docs/api-reference/files/create).
   */
  create(e, t) {
    return this._client.post("/uploads", { body: e, ...t });
  }
  /**
   * Cancels the Upload. No Parts may be added after an Upload is cancelled.
   */
  cancel(e, t) {
    return this._client.post(F`/uploads/${e}/cancel`, t);
  }
  /**
   * Completes the
   * [Upload](https://platform.openai.com/docs/api-reference/uploads/object).
   *
   * Within the returned Upload object, there is a nested
   * [File](https://platform.openai.com/docs/api-reference/files/object) object that
   * is ready to use in the rest of the platform.
   *
   * You can specify the order of the Parts by passing in an ordered list of the Part
   * IDs.
   *
   * The number of bytes uploaded upon completion must match the number of bytes
   * initially specified when creating the Upload object. No Parts may be added after
   * an Upload is completed.
   */
  complete(e, t, n) {
    return this._client.post(F`/uploads/${e}/complete`, { body: t, ...n });
  }
}
qu.Parts = Xp;
const Pw = async (r) => {
  const e = await Promise.allSettled(r), t = e.filter((s) => s.status === "rejected");
  if (t.length) {
    for (const s of t)
      console.error(s.reason);
    throw new Error(`${t.length} promise(s) failed - see the above errors`);
  }
  const n = [];
  for (const s of e)
    s.status === "fulfilled" && n.push(s.value);
  return n;
};
class Qp extends ie {
  /**
   * Create a vector store file batch.
   */
  create(e, t, n) {
    return this._client.post(F`/vector_stores/${e}/file_batches`, {
      body: t,
      ...n,
      headers: Y([{ "OpenAI-Beta": "assistants=v2" }, n == null ? void 0 : n.headers])
    });
  }
  /**
   * Retrieves a vector store file batch.
   */
  retrieve(e, t, n) {
    const { vector_store_id: s } = t;
    return this._client.get(F`/vector_stores/${s}/file_batches/${e}`, {
      ...n,
      headers: Y([{ "OpenAI-Beta": "assistants=v2" }, n == null ? void 0 : n.headers])
    });
  }
  /**
   * Cancel a vector store file batch. This attempts to cancel the processing of
   * files in this batch as soon as possible.
   */
  cancel(e, t, n) {
    const { vector_store_id: s } = t;
    return this._client.post(F`/vector_stores/${s}/file_batches/${e}/cancel`, {
      ...n,
      headers: Y([{ "OpenAI-Beta": "assistants=v2" }, n == null ? void 0 : n.headers])
    });
  }
  /**
   * Create a vector store batch and poll until all files have been processed.
   */
  async createAndPoll(e, t, n) {
    const s = await this.create(e, t);
    return await this.poll(e, s.id, n);
  }
  /**
   * Returns a list of vector store files in a batch.
   */
  listFiles(e, t, n) {
    const { vector_store_id: s, ...a } = t;
    return this._client.getAPIList(F`/vector_stores/${s}/file_batches/${e}/files`, rt, { query: a, ...n, headers: Y([{ "OpenAI-Beta": "assistants=v2" }, n == null ? void 0 : n.headers]) });
  }
  /**
   * Wait for the given file batch to be processed.
   *
   * Note: this will return even if one of the files failed to process, you need to
   * check batch.file_counts.failed_count to handle this case.
   */
  async poll(e, t, n) {
    var a;
    const s = Y([
      n == null ? void 0 : n.headers,
      {
        "X-Stainless-Poll-Helper": "true",
        "X-Stainless-Custom-Poll-Interval": ((a = n == null ? void 0 : n.pollIntervalMs) == null ? void 0 : a.toString()) ?? void 0
      }
    ]);
    for (; ; ) {
      const { data: i, response: o } = await this.retrieve(t, { vector_store_id: e }, {
        ...n,
        headers: s
      }).withResponse();
      switch (i.status) {
        case "in_progress":
          let c = 5e3;
          if (n != null && n.pollIntervalMs)
            c = n.pollIntervalMs;
          else {
            const u = o.headers.get("openai-poll-after-ms");
            if (u) {
              const l = parseInt(u);
              isNaN(l) || (c = l);
            }
          }
          await ra(c);
          break;
        case "failed":
        case "cancelled":
        case "completed":
          return i;
      }
    }
  }
  /**
   * Uploads the given files concurrently and then creates a vector store file batch.
   *
   * The concurrency limit is configurable using the `maxConcurrency` parameter.
   */
  async uploadAndPoll(e, { files: t, fileIds: n = [] }, s) {
    if (t == null || t.length == 0)
      throw new Error("No `files` provided to process. If you've already uploaded files you should use `.createAndPoll()` instead");
    const a = (s == null ? void 0 : s.maxConcurrency) ?? 5, i = Math.min(a, t.length), o = this._client, c = t.values(), u = [...n];
    async function l(h) {
      for (let f of h) {
        const p = await o.files.create({ file: f, purpose: "assistants" }, s);
        u.push(p.id);
      }
    }
    const d = Array(i).fill(c).map(l);
    return await Pw(d), await this.createAndPoll(e, {
      file_ids: u
    });
  }
}
class em extends ie {
  /**
   * Create a vector store file by attaching a
   * [File](https://platform.openai.com/docs/api-reference/files) to a
   * [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object).
   */
  create(e, t, n) {
    return this._client.post(F`/vector_stores/${e}/files`, {
      body: t,
      ...n,
      headers: Y([{ "OpenAI-Beta": "assistants=v2" }, n == null ? void 0 : n.headers])
    });
  }
  /**
   * Retrieves a vector store file.
   */
  retrieve(e, t, n) {
    const { vector_store_id: s } = t;
    return this._client.get(F`/vector_stores/${s}/files/${e}`, {
      ...n,
      headers: Y([{ "OpenAI-Beta": "assistants=v2" }, n == null ? void 0 : n.headers])
    });
  }
  /**
   * Update attributes on a vector store file.
   */
  update(e, t, n) {
    const { vector_store_id: s, ...a } = t;
    return this._client.post(F`/vector_stores/${s}/files/${e}`, {
      body: a,
      ...n,
      headers: Y([{ "OpenAI-Beta": "assistants=v2" }, n == null ? void 0 : n.headers])
    });
  }
  /**
   * Returns a list of vector store files.
   */
  list(e, t = {}, n) {
    return this._client.getAPIList(F`/vector_stores/${e}/files`, rt, {
      query: t,
      ...n,
      headers: Y([{ "OpenAI-Beta": "assistants=v2" }, n == null ? void 0 : n.headers])
    });
  }
  /**
   * Delete a vector store file. This will remove the file from the vector store but
   * the file itself will not be deleted. To delete the file, use the
   * [delete file](https://platform.openai.com/docs/api-reference/files/delete)
   * endpoint.
   */
  delete(e, t, n) {
    const { vector_store_id: s } = t;
    return this._client.delete(F`/vector_stores/${s}/files/${e}`, {
      ...n,
      headers: Y([{ "OpenAI-Beta": "assistants=v2" }, n == null ? void 0 : n.headers])
    });
  }
  /**
   * Attach a file to the given vector store and wait for it to be processed.
   */
  async createAndPoll(e, t, n) {
    const s = await this.create(e, t, n);
    return await this.poll(e, s.id, n);
  }
  /**
   * Wait for the vector store file to finish processing.
   *
   * Note: this will return even if the file failed to process, you need to check
   * file.last_error and file.status to handle these cases
   */
  async poll(e, t, n) {
    var a;
    const s = Y([
      n == null ? void 0 : n.headers,
      {
        "X-Stainless-Poll-Helper": "true",
        "X-Stainless-Custom-Poll-Interval": ((a = n == null ? void 0 : n.pollIntervalMs) == null ? void 0 : a.toString()) ?? void 0
      }
    ]);
    for (; ; ) {
      const i = await this.retrieve(t, {
        vector_store_id: e
      }, { ...n, headers: s }).withResponse(), o = i.data;
      switch (o.status) {
        case "in_progress":
          let c = 5e3;
          if (n != null && n.pollIntervalMs)
            c = n.pollIntervalMs;
          else {
            const u = i.response.headers.get("openai-poll-after-ms");
            if (u) {
              const l = parseInt(u);
              isNaN(l) || (c = l);
            }
          }
          await ra(c);
          break;
        case "failed":
        case "completed":
          return o;
      }
    }
  }
  /**
   * Upload a file to the `files` API and then attach it to the given vector store.
   *
   * Note the file will be asynchronously processed (you can use the alternative
   * polling helper method to wait for processing to complete).
   */
  async upload(e, t, n) {
    const s = await this._client.files.create({ file: t, purpose: "assistants" }, n);
    return this.create(e, { file_id: s.id }, n);
  }
  /**
   * Add a file to a vector store and poll until processing is complete.
   */
  async uploadAndPoll(e, t, n) {
    const s = await this.upload(e, t, n);
    return await this.poll(e, s.id, n);
  }
  /**
   * Retrieve the parsed contents of a vector store file.
   */
  content(e, t, n) {
    const { vector_store_id: s } = t;
    return this._client.getAPIList(F`/vector_stores/${s}/files/${e}/content`, Xi, { ...n, headers: Y([{ "OpenAI-Beta": "assistants=v2" }, n == null ? void 0 : n.headers]) });
  }
}
class so extends ie {
  constructor() {
    super(...arguments), this.files = new em(this._client), this.fileBatches = new Qp(this._client);
  }
  /**
   * Create a vector store.
   */
  create(e, t) {
    return this._client.post("/vector_stores", {
      body: e,
      ...t,
      headers: Y([{ "OpenAI-Beta": "assistants=v2" }, t == null ? void 0 : t.headers])
    });
  }
  /**
   * Retrieves a vector store.
   */
  retrieve(e, t) {
    return this._client.get(F`/vector_stores/${e}`, {
      ...t,
      headers: Y([{ "OpenAI-Beta": "assistants=v2" }, t == null ? void 0 : t.headers])
    });
  }
  /**
   * Modifies a vector store.
   */
  update(e, t, n) {
    return this._client.post(F`/vector_stores/${e}`, {
      body: t,
      ...n,
      headers: Y([{ "OpenAI-Beta": "assistants=v2" }, n == null ? void 0 : n.headers])
    });
  }
  /**
   * Returns a list of vector stores.
   */
  list(e = {}, t) {
    return this._client.getAPIList("/vector_stores", rt, {
      query: e,
      ...t,
      headers: Y([{ "OpenAI-Beta": "assistants=v2" }, t == null ? void 0 : t.headers])
    });
  }
  /**
   * Delete a vector store.
   */
  delete(e, t) {
    return this._client.delete(F`/vector_stores/${e}`, {
      ...t,
      headers: Y([{ "OpenAI-Beta": "assistants=v2" }, t == null ? void 0 : t.headers])
    });
  }
  /**
   * Search a vector store for relevant chunks based on a query and file attributes
   * filter.
   */
  search(e, t, n) {
    return this._client.getAPIList(F`/vector_stores/${e}/search`, Xi, {
      body: t,
      method: "post",
      ...n,
      headers: Y([{ "OpenAI-Beta": "assistants=v2" }, n == null ? void 0 : n.headers])
    });
  }
}
so.Files = em;
so.FileBatches = Qp;
class tm extends ie {
  /**
   * Create a video
   */
  create(e, t) {
    return this._client.post("/videos", od({ body: e, ...t }, this._client));
  }
  /**
   * Retrieve a video
   */
  retrieve(e, t) {
    return this._client.get(F`/videos/${e}`, t);
  }
  /**
   * List videos
   */
  list(e = {}, t) {
    return this._client.getAPIList("/videos", hi, { query: e, ...t });
  }
  /**
   * Delete a video
   */
  delete(e, t) {
    return this._client.delete(F`/videos/${e}`, t);
  }
  /**
   * Download video content
   */
  downloadContent(e, t = {}, n) {
    return this._client.get(F`/videos/${e}/content`, {
      query: t,
      ...n,
      headers: Y([{ Accept: "application/binary" }, n == null ? void 0 : n.headers]),
      __binaryResponse: !0
    });
  }
  /**
   * Create a video remix
   */
  remix(e, t, n) {
    return this._client.post(F`/videos/${e}/remix`, od({ body: t, ...n }, this._client));
  }
}
var jn, rm, ni;
class nm extends ie {
  constructor() {
    super(...arguments), jn.add(this);
  }
  /**
   * Validates that the given payload was sent by OpenAI and parses the payload.
   */
  async unwrap(e, t, n = this._client.webhookSecret, s = 300) {
    return await this.verifySignature(e, t, n, s), JSON.parse(e);
  }
  /**
   * Validates whether or not the webhook payload was sent by OpenAI.
   *
   * An error will be raised if the webhook payload was not sent by OpenAI.
   *
   * @param payload - The webhook payload
   * @param headers - The webhook headers
   * @param secret - The webhook secret (optional, will use client secret if not provided)
   * @param tolerance - Maximum age of the webhook in seconds (default: 300 = 5 minutes)
   */
  async verifySignature(e, t, n = this._client.webhookSecret, s = 300) {
    if (typeof crypto > "u" || typeof crypto.subtle.importKey != "function" || typeof crypto.subtle.verify != "function")
      throw new Error("Webhook signature verification is only supported when the `crypto` global is defined");
    k(this, jn, "m", rm).call(this, n);
    const a = Y([t]).values, i = k(this, jn, "m", ni).call(this, a, "webhook-signature"), o = k(this, jn, "m", ni).call(this, a, "webhook-timestamp"), c = k(this, jn, "m", ni).call(this, a, "webhook-id"), u = parseInt(o, 10);
    if (isNaN(u))
      throw new ms("Invalid webhook timestamp format");
    const l = Math.floor(Date.now() / 1e3);
    if (l - u > s)
      throw new ms("Webhook timestamp is too old");
    if (u > l + s)
      throw new ms("Webhook timestamp is too new");
    const d = i.split(" ").map((y) => y.startsWith("v1,") ? y.substring(3) : y), h = n.startsWith("whsec_") ? Buffer.from(n.replace("whsec_", ""), "base64") : Buffer.from(n, "utf-8"), f = c ? `${c}.${o}.${e}` : `${o}.${e}`, p = await crypto.subtle.importKey("raw", h, { name: "HMAC", hash: "SHA-256" }, !1, ["verify"]);
    for (const y of d)
      try {
        const g = Buffer.from(y, "base64");
        if (await crypto.subtle.verify("HMAC", p, g, new TextEncoder().encode(f)))
          return;
      } catch {
        continue;
      }
    throw new ms("The given webhook signature does not match the expected signature");
  }
}
jn = /* @__PURE__ */ new WeakSet(), rm = function(e) {
  if (typeof e != "string" || e.length === 0)
    throw new Error("The webhook secret must either be set using the env var, OPENAI_WEBHOOK_SECRET, on the client class, OpenAI({ webhookSecret: '123' }), or passed to this function");
}, ni = function(e, t) {
  if (!e)
    throw new Error("Headers are required");
  const n = e.get(t);
  if (n == null)
    throw new Error(`Missing required header: ${t}`);
  return n;
};
var Rc, Hu, si, sm;
class xe {
  /**
   * API Client for interfacing with the OpenAI API.
   *
   * @param {string | undefined} [opts.apiKey=process.env['OPENAI_API_KEY'] ?? undefined]
   * @param {string | null | undefined} [opts.organization=process.env['OPENAI_ORG_ID'] ?? null]
   * @param {string | null | undefined} [opts.project=process.env['OPENAI_PROJECT_ID'] ?? null]
   * @param {string | null | undefined} [opts.webhookSecret=process.env['OPENAI_WEBHOOK_SECRET'] ?? null]
   * @param {string} [opts.baseURL=process.env['OPENAI_BASE_URL'] ?? https://api.openai.com/v1] - Override the default base URL for the API.
   * @param {number} [opts.timeout=10 minutes] - The maximum amount of time (in milliseconds) the client will wait for a response before timing out.
   * @param {MergedRequestInit} [opts.fetchOptions] - Additional `RequestInit` options to be passed to `fetch` calls.
   * @param {Fetch} [opts.fetch] - Specify a custom `fetch` function implementation.
   * @param {number} [opts.maxRetries=2] - The maximum number of times the client will retry a request.
   * @param {HeadersLike} opts.defaultHeaders - Default headers to include with every request to the API.
   * @param {Record<string, string | undefined>} opts.defaultQuery - Default query parameters to include with every request to the API.
   * @param {boolean} [opts.dangerouslyAllowBrowser=false] - By default, client-side use of this library is not allowed, as it risks exposing your secret API credentials to attackers.
   */
  constructor({ baseURL: e = Rn("OPENAI_BASE_URL"), apiKey: t = Rn("OPENAI_API_KEY"), organization: n = Rn("OPENAI_ORG_ID") ?? null, project: s = Rn("OPENAI_PROJECT_ID") ?? null, webhookSecret: a = Rn("OPENAI_WEBHOOK_SECRET") ?? null, ...i } = {}) {
    if (Rc.add(this), si.set(this, void 0), this.completions = new Np(this), this.chat = new Nu(this), this.embeddings = new Mp(this), this.files = new jp(this), this.images = new Vp(this), this.audio = new sa(this), this.moderations = new Hp(this), this.models = new qp(this), this.fineTuning = new os(this), this.graders = new Zu(this), this.vectorStores = new so(this), this.webhooks = new nm(this), this.beta = new is(this), this.batches = new xp(this), this.uploads = new qu(this), this.responses = new no(this), this.realtime = new ro(this), this.conversations = new Du(this), this.evals = new Fu(this), this.containers = new Mu(this), this.videos = new tm(this), t === void 0)
      throw new ce("Missing credentials. Please pass an `apiKey`, or set the `OPENAI_API_KEY` environment variable.");
    const o = {
      apiKey: t,
      organization: n,
      project: s,
      webhookSecret: a,
      ...i,
      baseURL: e || "https://api.openai.com/v1"
    };
    if (!o.dangerouslyAllowBrowser && Ly())
      throw new ce(`It looks like you're running in a browser-like environment.

This is disabled by default, as it risks exposing your secret API credentials to attackers.
If you understand the risks and have appropriate mitigations in place,
you can set the \`dangerouslyAllowBrowser\` option to \`true\`, e.g.,

new OpenAI({ apiKey, dangerouslyAllowBrowser: true });

https://help.openai.com/en/articles/5112595-best-practices-for-api-key-safety
`);
    this.baseURL = o.baseURL, this.timeout = o.timeout ?? Hu.DEFAULT_TIMEOUT, this.logger = o.logger ?? console;
    const c = "warn";
    this.logLevel = c, this.logLevel = ad(o.logLevel, "ClientOptions.logLevel", this) ?? ad(Rn("OPENAI_LOG"), "process.env['OPENAI_LOG']", this) ?? c, this.fetchOptions = o.fetchOptions, this.maxRetries = o.maxRetries ?? 2, this.fetch = o.fetch ?? Uy(), he(this, si, By), this._options = o, this.apiKey = typeof t == "string" ? t : "Missing Key", this.organization = n, this.project = s, this.webhookSecret = a;
  }
  /**
   * Create a new client instance re-using the same options given to the current client with optional overriding.
   */
  withOptions(e) {
    return new this.constructor({
      ...this._options,
      baseURL: this.baseURL,
      maxRetries: this.maxRetries,
      timeout: this.timeout,
      logger: this.logger,
      logLevel: this.logLevel,
      fetch: this.fetch,
      fetchOptions: this.fetchOptions,
      apiKey: this.apiKey,
      organization: this.organization,
      project: this.project,
      webhookSecret: this.webhookSecret,
      ...e
    });
  }
  defaultQuery() {
    return this._options.defaultQuery;
  }
  validateHeaders({ values: e, nulls: t }) {
  }
  async authHeaders(e) {
    return Y([{ Authorization: `Bearer ${this.apiKey}` }]);
  }
  stringifyQuery(e) {
    return Wy(e, { arrayFormat: "brackets" });
  }
  getUserAgent() {
    return `${this.constructor.name}/JS ${Mn}`;
  }
  defaultIdempotencyKey() {
    return `stainless-node-retry-${kf()}`;
  }
  makeStatusError(e, t, n, s) {
    return St.generate(e, t, n, s);
  }
  async _callApiKey() {
    const e = this._options.apiKey;
    if (typeof e != "function")
      return !1;
    let t;
    try {
      t = await e();
    } catch (n) {
      throw n instanceof ce ? n : new ce(
        `Failed to get token from 'apiKey' function: ${n.message}`,
        // @ts-ignore
        { cause: n }
      );
    }
    if (typeof t != "string" || !t)
      throw new ce(`Expected 'apiKey' function argument to return a string but it returned ${t}`);
    return this.apiKey = t, !0;
  }
  buildURL(e, t, n) {
    const s = !k(this, Rc, "m", sm).call(this) && n || this.baseURL, a = $y(e) ? new URL(e) : new URL(s + (s.endsWith("/") && e.startsWith("/") ? e.slice(1) : e)), i = this.defaultQuery();
    return Cy(i) || (t = { ...i, ...t }), typeof t == "object" && t && !Array.isArray(t) && (a.search = this.stringifyQuery(t)), a.toString();
  }
  /**
   * Used as a callback for mutating the given `FinalRequestOptions` object.
   */
  async prepareOptions(e) {
    await this._callApiKey();
  }
  /**
   * Used as a callback for mutating the given `RequestInit` object.
   *
   * This is useful for cases where you want to add certain headers based off of
   * the request properties, e.g. `method` or `url`.
   */
  async prepareRequest(e, { url: t, options: n }) {
  }
  get(e, t) {
    return this.methodRequest("get", e, t);
  }
  post(e, t) {
    return this.methodRequest("post", e, t);
  }
  patch(e, t) {
    return this.methodRequest("patch", e, t);
  }
  put(e, t) {
    return this.methodRequest("put", e, t);
  }
  delete(e, t) {
    return this.methodRequest("delete", e, t);
  }
  methodRequest(e, t, n) {
    return this.request(Promise.resolve(n).then((s) => ({ method: e, path: t, ...s })));
  }
  request(e, t = null) {
    return new Yi(this, this.makeRequest(e, t, void 0));
  }
  async makeRequest(e, t, n) {
    var S, _;
    const s = await e, a = s.maxRetries ?? this.maxRetries;
    t == null && (t = a), await this.prepareOptions(s);
    const { req: i, url: o, timeout: c } = await this.buildRequest(s, {
      retryCount: a - t
    });
    await this.prepareRequest(i, { url: o, options: s });
    const u = "log_" + (Math.random() * (1 << 24) | 0).toString(16).padStart(6, "0"), l = n === void 0 ? "" : `, retryOf: ${n}`, d = Date.now();
    if (wt(this).debug(`[${u}] sending request`, dn({
      retryOfRequestLogID: n,
      method: s.method,
      url: o,
      options: s,
      headers: i.headers
    })), (S = s.signal) != null && S.aborted)
      throw new Ut();
    const h = new AbortController(), f = await this.fetchWithTimeout(o, i, c, h).catch(vc), p = Date.now();
    if (f instanceof globalThis.Error) {
      const w = `retrying, ${t} attempts remaining`;
      if ((_ = s.signal) != null && _.aborted)
        throw new Ut();
      const T = wc(f) || /timed? ?out/i.test(String(f) + ("cause" in f ? String(f.cause) : ""));
      if (t)
        return wt(this).info(`[${u}] connection ${T ? "timed out" : "failed"} - ${w}`), wt(this).debug(`[${u}] connection ${T ? "timed out" : "failed"} (${w})`, dn({
          retryOfRequestLogID: n,
          url: o,
          durationMs: p - d,
          message: f.message
        })), this.retryRequest(s, t, n ?? u);
      throw wt(this).info(`[${u}] connection ${T ? "timed out" : "failed"} - error; no more retries left`), wt(this).debug(`[${u}] connection ${T ? "timed out" : "failed"} (error; no more retries left)`, dn({
        retryOfRequestLogID: n,
        url: o,
        durationMs: p - d,
        message: f.message
      })), T ? new Gi() : new Wi({ cause: f });
    }
    const y = [...f.headers.entries()].filter(([w]) => w === "x-request-id").map(([w, T]) => ", " + w + ": " + JSON.stringify(T)).join(""), g = `[${u}${l}${y}] ${i.method} ${o} ${f.ok ? "succeeded" : "failed"} with status ${f.status} in ${p - d}ms`;
    if (!f.ok) {
      const w = await this.shouldRetry(f);
      if (t && w) {
        const V = `retrying, ${t} attempts remaining`;
        return await zy(f.body), wt(this).info(`${g} - ${V}`), wt(this).debug(`[${u}] response error (${V})`, dn({
          retryOfRequestLogID: n,
          url: f.url,
          status: f.status,
          headers: f.headers,
          durationMs: p - d
        })), this.retryRequest(s, t, n ?? u, f.headers);
      }
      const T = w ? "error; no more retries left" : "error; not retryable";
      wt(this).info(`${g} - ${T}`);
      const x = await f.text().catch((V) => vc(V).message), A = Py(x), R = A ? void 0 : x;
      throw wt(this).debug(`[${u}] response error (${T})`, dn({
        retryOfRequestLogID: n,
        url: f.url,
        status: f.status,
        headers: f.headers,
        message: R,
        durationMs: Date.now() - d
      })), this.makeStatusError(f.status, A, R, f.headers);
    }
    return wt(this).info(g), wt(this).debug(`[${u}] response start`, dn({
      retryOfRequestLogID: n,
      url: f.url,
      status: f.status,
      headers: f.headers,
      durationMs: p - d
    })), { response: f, options: s, controller: h, requestLogID: u, retryOfRequestLogID: n, startTime: d };
  }
  getAPIList(e, t, n) {
    return this.requestAPIList(t, { method: "get", path: e, ...n });
  }
  requestAPIList(e, t) {
    const n = this.makeRequest(t, null, void 0);
    return new nw(this, n, e);
  }
  async fetchWithTimeout(e, t, n, s) {
    const { signal: a, method: i, ...o } = t || {};
    a && a.addEventListener("abort", () => s.abort());
    const c = setTimeout(() => s.abort(), n), u = globalThis.ReadableStream && o.body instanceof globalThis.ReadableStream || typeof o.body == "object" && o.body !== null && Symbol.asyncIterator in o.body, l = {
      signal: s.signal,
      ...u ? { duplex: "half" } : {},
      method: "GET",
      ...o
    };
    i && (l.method = i.toUpperCase());
    try {
      return await this.fetch.call(void 0, e, l);
    } finally {
      clearTimeout(c);
    }
  }
  async shouldRetry(e) {
    const t = e.headers.get("x-should-retry");
    return t === "true" ? !0 : t === "false" ? !1 : e.status === 408 || e.status === 409 || e.status === 429 || e.status >= 500;
  }
  async retryRequest(e, t, n, s) {
    let a;
    const i = s == null ? void 0 : s.get("retry-after-ms");
    if (i) {
      const c = parseFloat(i);
      Number.isNaN(c) || (a = c);
    }
    const o = s == null ? void 0 : s.get("retry-after");
    if (o && !a) {
      const c = parseFloat(o);
      Number.isNaN(c) ? a = Date.parse(o) - Date.now() : a = c * 1e3;
    }
    if (!(a && 0 <= a && a < 60 * 1e3)) {
      const c = e.maxRetries ?? this.maxRetries;
      a = this.calculateDefaultRetryTimeoutMillis(t, c);
    }
    return await ra(a), this.makeRequest(e, t - 1, n);
  }
  calculateDefaultRetryTimeoutMillis(e, t) {
    const a = t - e, i = Math.min(0.5 * Math.pow(2, a), 8), o = 1 - Math.random() * 0.25;
    return i * o * 1e3;
  }
  async buildRequest(e, { retryCount: t = 0 } = {}) {
    const n = { ...e }, { method: s, path: a, query: i, defaultBaseURL: o } = n, c = this.buildURL(a, i, o);
    "timeout" in n && Ny("timeout", n.timeout), n.timeout = n.timeout ?? this.timeout;
    const { bodyHeaders: u, body: l } = this.buildBody({ options: n }), d = await this.buildHeaders({ options: e, method: s, bodyHeaders: u, retryCount: t });
    return { req: {
      method: s,
      headers: d,
      ...n.signal && { signal: n.signal },
      ...globalThis.ReadableStream && l instanceof globalThis.ReadableStream && { duplex: "half" },
      ...l && { body: l },
      ...this.fetchOptions ?? {},
      ...n.fetchOptions ?? {}
    }, url: c, timeout: n.timeout };
  }
  async buildHeaders({ options: e, method: t, bodyHeaders: n, retryCount: s }) {
    let a = {};
    this.idempotencyHeader && t !== "get" && (e.idempotencyKey || (e.idempotencyKey = this.defaultIdempotencyKey()), a[this.idempotencyHeader] = e.idempotencyKey);
    const i = Y([
      a,
      {
        Accept: "application/json",
        "User-Agent": this.getUserAgent(),
        "X-Stainless-Retry-Count": String(s),
        ...e.timeout ? { "X-Stainless-Timeout": String(Math.trunc(e.timeout / 1e3)) } : {},
        ...Fy(),
        "OpenAI-Organization": this.organization,
        "OpenAI-Project": this.project
      },
      await this.authHeaders(e),
      this._options.defaultHeaders,
      n,
      e.headers
    ]);
    return this.validateHeaders(i), i.values;
  }
  buildBody({ options: { body: e, headers: t } }) {
    if (!e)
      return { bodyHeaders: void 0, body: void 0 };
    const n = Y([t]);
    return (
      // Pass raw type verbatim
      ArrayBuffer.isView(e) || e instanceof ArrayBuffer || e instanceof DataView || typeof e == "string" && // Preserve legacy string encoding behavior for now
      n.values.has("content-type") || // `Blob` is superset of `File`
      globalThis.Blob && e instanceof globalThis.Blob || // `FormData` -> `multipart/form-data`
      e instanceof FormData || // `URLSearchParams` -> `application/x-www-form-urlencoded`
      e instanceof URLSearchParams || // Send chunked stream (each chunk has own `length`)
      globalThis.ReadableStream && e instanceof globalThis.ReadableStream ? { bodyHeaders: void 0, body: e } : typeof e == "object" && (Symbol.asyncIterator in e || Symbol.iterator in e && "next" in e && typeof e.next == "function") ? { bodyHeaders: void 0, body: Uf(e) } : k(this, si, "f").call(this, { body: e, headers: n })
    );
  }
}
Hu = xe, si = /* @__PURE__ */ new WeakMap(), Rc = /* @__PURE__ */ new WeakSet(), sm = function() {
  return this.baseURL !== "https://api.openai.com/v1";
};
xe.OpenAI = Hu;
xe.DEFAULT_TIMEOUT = 6e5;
xe.OpenAIError = ce;
xe.APIError = St;
xe.APIConnectionError = Wi;
xe.APIConnectionTimeoutError = Gi;
xe.APIUserAbortError = Ut;
xe.NotFoundError = Cf;
xe.ConflictError = Rf;
xe.RateLimitError = Pf;
xe.BadRequestError = Of;
xe.AuthenticationError = Af;
xe.InternalServerError = Lf;
xe.PermissionDeniedError = $f;
xe.UnprocessableEntityError = Nf;
xe.InvalidWebhookSignatureError = ms;
xe.toFile = cw;
xe.Completions = Np;
xe.Chat = Nu;
xe.Embeddings = Mp;
xe.Files = jp;
xe.Images = Vp;
xe.Audio = sa;
xe.Moderations = Hp;
xe.Models = qp;
xe.FineTuning = os;
xe.Graders = Zu;
xe.VectorStores = so;
xe.Webhooks = nm;
xe.Beta = is;
xe.Batches = xp;
xe.Uploads = qu;
xe.Responses = no;
xe.Realtime = ro;
xe.Conversations = Du;
xe.Evals = Fu;
xe.Containers = Mu;
xe.Videos = tm;
function am(r) {
  if (!r || typeof r != "object") return r;
  let e;
  return r.constructor.name === Gi.name && "message" in r && typeof r.message == "string" ? (e = new Error(r.message), e.name = "TimeoutError") : r.constructor.name === Ut.name && "message" in r && typeof r.message == "string" ? (e = new Error(r.message), e.name = "AbortError") : "status" in r && r.status === 400 && "message" in r && typeof r.message == "string" && r.message.includes("tool_calls") ? e = ba(r, "INVALID_TOOL_RESULTS") : "status" in r && r.status === 401 ? e = ba(r, "MODEL_AUTHENTICATION") : "status" in r && r.status === 429 ? e = ba(r, "MODEL_RATE_LIMIT") : "status" in r && r.status === 404 ? e = ba(r, "MODEL_NOT_FOUND") : e = r, e;
}
var Lw = Object.defineProperty, Ae = (r, e) => {
  for (var t in e) Lw(r, t, {
    get: e[t],
    enumerable: !0
  });
};
function Ir(r) {
  return typeof r == "object" && r !== null && "type" in r && typeof r.type == "string" && "source_type" in r && (r.source_type === "url" || r.source_type === "base64" || r.source_type === "text" || r.source_type === "id");
}
function Ju(r) {
  return Ir(r) && r.source_type === "url" && "url" in r && typeof r.url == "string";
}
function Wu(r) {
  return Ir(r) && r.source_type === "base64" && "data" in r && typeof r.data == "string";
}
function Mw(r) {
  return Ir(r) && r.source_type === "text" && "text" in r && typeof r.text == "string";
}
function im(r) {
  return Ir(r) && r.source_type === "id" && "id" in r && typeof r.id == "string";
}
function om(r) {
  if (Ir(r)) {
    if (r.source_type === "url") return {
      type: "image_url",
      image_url: { url: r.url }
    };
    if (r.source_type === "base64") {
      if (!r.mime_type) throw new Error("mime_type key is required for base64 data.");
      return {
        type: "image_url",
        image_url: { url: `data:${r.mime_type};base64,${r.data}` }
      };
    }
  }
  throw new Error("Unsupported source type. Only 'url' and 'base64' are supported.");
}
function Nc(r) {
  const e = r.split(";")[0].split("/");
  if (e.length !== 2) throw new Error(`Invalid mime type: "${r}" - does not match type/subtype format.`);
  const t = e[0].trim(), n = e[1].trim();
  if (t === "" || n === "") throw new Error(`Invalid mime type: "${r}" - type or subtype is empty.`);
  const s = {};
  for (const a of r.split(";").slice(1)) {
    const i = a.split("=");
    if (i.length !== 2) throw new Error(`Invalid parameter syntax in mime type: "${r}".`);
    const o = i[0].trim(), c = i[1].trim();
    if (o === "") throw new Error(`Invalid parameter syntax in mime type: "${r}".`);
    s[o] = c;
  }
  return {
    type: t,
    subtype: n,
    parameters: s
  };
}
function Vs({ dataUrl: r, asTypedArray: e = !1 }) {
  const t = r.match(/^data:(\w+\/\w+);base64,([A-Za-z0-9+/]+=*)$/);
  let n;
  if (t) {
    n = t[1].toLowerCase();
    const s = e ? Uint8Array.from(atob(t[2]), (a) => a.charCodeAt(0)) : t[2];
    return {
      mime_type: n,
      data: s
    };
  }
}
function Gu(r, e) {
  if (r.type === "text") {
    if (!e.fromStandardTextBlock) throw new Error(`Converter for ${e.providerName} does not implement \`fromStandardTextBlock\` method.`);
    return e.fromStandardTextBlock(r);
  }
  if (r.type === "image") {
    if (!e.fromStandardImageBlock) throw new Error(`Converter for ${e.providerName} does not implement \`fromStandardImageBlock\` method.`);
    return e.fromStandardImageBlock(r);
  }
  if (r.type === "audio") {
    if (!e.fromStandardAudioBlock) throw new Error(`Converter for ${e.providerName} does not implement \`fromStandardAudioBlock\` method.`);
    return e.fromStandardAudioBlock(r);
  }
  if (r.type === "file") {
    if (!e.fromStandardFileBlock) throw new Error(`Converter for ${e.providerName} does not implement \`fromStandardFileBlock\` method.`);
    return e.fromStandardFileBlock(r);
  }
  throw new Error(`Unable to convert content block type '${r.type}' to provider-specific format: not recognized.`);
}
function cm(r) {
  return typeof r == "object" && r !== null && "type" in r && "content" in r && (typeof r.content == "string" || Array.isArray(r.content));
}
function Ku(r) {
  return r && r.__esModule && Object.prototype.hasOwnProperty.call(r, "default") ? r.default : r;
}
var Dw = function(r, e) {
  if (typeof r != "string")
    throw new TypeError("Expected a string");
  return e = typeof e > "u" ? "_" : e, r.replace(/([a-z\d])([A-Z])/g, "$1" + e + "$2").replace(/([A-Z]+)([A-Z][a-z\d]+)/g, "$1" + e + "$2").toLowerCase();
};
const jw = /* @__PURE__ */ Ku(Dw);
var um = { exports: {} };
const Fw = /[\p{Lu}]/u, Uw = /[\p{Ll}]/u, Td = /^[\p{Lu}](?![\p{Lu}])/gu, lm = /([\p{Alpha}\p{N}_]|$)/u, dm = /[_.\- ]+/, zw = new RegExp("^" + dm.source), Ed = new RegExp(dm.source + lm.source, "gu"), xd = new RegExp("\\d+" + lm.source, "gu"), Bw = (r, e, t) => {
  let n = !1, s = !1, a = !1;
  for (let i = 0; i < r.length; i++) {
    const o = r[i];
    n && Fw.test(o) ? (r = r.slice(0, i) + "-" + r.slice(i), n = !1, a = s, s = !0, i++) : s && a && Uw.test(o) ? (r = r.slice(0, i - 1) + "-" + r.slice(i - 1), a = s, s = !1, n = !0) : (n = e(o) === o && t(o) !== o, a = s, s = t(o) === o && e(o) !== o);
  }
  return r;
}, Zw = (r, e) => (Td.lastIndex = 0, r.replace(Td, (t) => e(t))), Vw = (r, e) => (Ed.lastIndex = 0, xd.lastIndex = 0, r.replace(Ed, (t, n) => e(n)).replace(xd, (t) => e(t))), hm = (r, e) => {
  if (!(typeof r == "string" || Array.isArray(r)))
    throw new TypeError("Expected the input to be `string | string[]`");
  if (e = {
    pascalCase: !1,
    preserveConsecutiveUppercase: !1,
    ...e
  }, Array.isArray(r) ? r = r.map((a) => a.trim()).filter((a) => a.length).join("-") : r = r.trim(), r.length === 0)
    return "";
  const t = e.locale === !1 ? (a) => a.toLowerCase() : (a) => a.toLocaleLowerCase(e.locale), n = e.locale === !1 ? (a) => a.toUpperCase() : (a) => a.toLocaleUpperCase(e.locale);
  return r.length === 1 ? e.pascalCase ? n(r) : t(r) : (r !== t(r) && (r = Bw(r, t, n)), r = r.replace(zw, ""), e.preserveConsecutiveUppercase ? r = Zw(r, t) : r = t(r), e.pascalCase && (r = n(r.charAt(0)) + r.slice(1)), Vw(r, n));
};
um.exports = hm;
um.exports.default = hm;
function qw(r, e) {
  return (e == null ? void 0 : e[r]) || jw(r);
}
function Hw(r, e, t) {
  const n = {};
  for (const s in r) Object.hasOwn(r, s) && (n[e(s, t)] = r[s]);
  return n;
}
var Jw = {};
Ae(Jw, {
  Serializable: () => Kn,
  get_lc_unique_name: () => Yu
});
function Id(r) {
  return Array.isArray(r) ? [...r] : { ...r };
}
function Ww(r, e) {
  const t = Id(r);
  for (const [n, s] of Object.entries(e)) {
    const [a, ...i] = n.split(".").reverse();
    let o = t;
    for (const c of i.reverse()) {
      if (o[c] === void 0) break;
      o[c] = Id(o[c]), o = o[c];
    }
    o[a] !== void 0 && (o[a] = {
      lc: 1,
      type: "secret",
      id: [s]
    });
  }
  return t;
}
function Yu(r) {
  const e = Object.getPrototypeOf(r);
  return typeof r.lc_name == "function" && (typeof e.lc_name != "function" || r.lc_name() !== e.lc_name()) ? r.lc_name() : r.name;
}
var Kn = class fm {
  constructor(e, ...t) {
    v(this, "lc_serializable", !1);
    v(this, "lc_kwargs");
    this.lc_serializable_keys !== void 0 ? this.lc_kwargs = Object.fromEntries(Object.entries(e || {}).filter(([n]) => {
      var s;
      return (s = this.lc_serializable_keys) == null ? void 0 : s.includes(n);
    })) : this.lc_kwargs = e ?? {};
  }
  /**
  * The name of the serializable. Override to provide an alias or
  * to preserve the serialized module name in minified environments.
  *
  * Implemented as a static method to support loading logic.
  */
  static lc_name() {
    return this.name;
  }
  /**
  * The final serialized identifier for the module.
  */
  get lc_id() {
    return [...this.lc_namespace, Yu(this.constructor)];
  }
  /**
  * A map of secrets, which will be omitted from serialization.
  * Keys are paths to the secret in constructor args, e.g. "foo.bar.baz".
  * Values are the secret ids, which will be used when deserializing.
  */
  get lc_secrets() {
  }
  /**
  * A map of additional attributes to merge with constructor args.
  * Keys are the attribute names, e.g. "foo".
  * Values are the attribute values, which will be serialized.
  * These attributes need to be accepted by the constructor as arguments.
  */
  get lc_attributes() {
  }
  /**
  * A map of aliases for constructor args.
  * Keys are the attribute names, e.g. "foo".
  * Values are the alias that will replace the key in serialization.
  * This is used to eg. make argument names match Python.
  */
  get lc_aliases() {
  }
  /**
  * A manual list of keys that should be serialized.
  * If not overridden, all fields passed into the constructor will be serialized.
  */
  get lc_serializable_keys() {
  }
  toJSON() {
    if (!this.lc_serializable) return this.toJSONNotImplemented();
    if (this.lc_kwargs instanceof fm || typeof this.lc_kwargs != "object" || Array.isArray(this.lc_kwargs)) return this.toJSONNotImplemented();
    const e = {}, t = {}, n = Object.keys(this.lc_kwargs).reduce((s, a) => (s[a] = a in this ? this[a] : this.lc_kwargs[a], s), {});
    for (let s = Object.getPrototypeOf(this); s; s = Object.getPrototypeOf(s))
      Object.assign(e, Reflect.get(s, "lc_aliases", this)), Object.assign(t, Reflect.get(s, "lc_secrets", this)), Object.assign(n, Reflect.get(s, "lc_attributes", this));
    return Object.keys(t).forEach((s) => {
      let a = this, i = n;
      const [o, ...c] = s.split(".").reverse();
      for (const u of c.reverse()) {
        if (!(u in a) || a[u] === void 0) return;
        (!(u in i) || i[u] === void 0) && (typeof a[u] == "object" && a[u] != null ? i[u] = {} : Array.isArray(a[u]) && (i[u] = [])), a = a[u], i = i[u];
      }
      o in a && a[o] !== void 0 && (i[o] = i[o] || a[o]);
    }), {
      lc: 1,
      type: "constructor",
      id: this.lc_id,
      kwargs: Hw(Object.keys(t).length ? Ww(n, t) : n, qw, e)
    };
  }
  toJSONNotImplemented() {
    return {
      lc: 1,
      type: "not_implemented",
      id: this.lc_id
    };
  }
};
function ue(r, e) {
  return ve(r) && r.type === e;
}
function ve(r) {
  return typeof r == "object" && r !== null;
}
function Tr(r) {
  return Array.isArray(r);
}
function K(r) {
  return typeof r == "string";
}
function or(r) {
  return typeof r == "number";
}
function Xu(r) {
  return r instanceof Uint8Array;
}
function kd(r) {
  try {
    return JSON.parse(r);
  } catch {
    return;
  }
}
const qs = (r) => r();
function Gw(r) {
  if (r.type === "char_location" && K(r.document_title) && or(r.start_char_index) && or(r.end_char_index) && K(r.cited_text)) {
    const { document_title: e, start_char_index: t, end_char_index: n, cited_text: s, ...a } = r;
    return {
      ...a,
      type: "citation",
      source: "char",
      title: e ?? void 0,
      startIndex: t,
      endIndex: n,
      citedText: s
    };
  }
  if (r.type === "page_location" && K(r.document_title) && or(r.start_page_number) && or(r.end_page_number) && K(r.cited_text)) {
    const { document_title: e, start_page_number: t, end_page_number: n, cited_text: s, ...a } = r;
    return {
      ...a,
      type: "citation",
      source: "page",
      title: e ?? void 0,
      startIndex: t,
      endIndex: n,
      citedText: s
    };
  }
  if (r.type === "content_block_location" && K(r.document_title) && or(r.start_block_index) && or(r.end_block_index) && K(r.cited_text)) {
    const { document_title: e, start_block_index: t, end_block_index: n, cited_text: s, ...a } = r;
    return {
      ...a,
      type: "citation",
      source: "block",
      title: e ?? void 0,
      startIndex: t,
      endIndex: n,
      citedText: s
    };
  }
  if (r.type === "web_search_result_location" && K(r.url) && K(r.title) && K(r.encrypted_index) && K(r.cited_text)) {
    const { url: e, title: t, encrypted_index: n, cited_text: s, ...a } = r;
    return {
      ...a,
      type: "citation",
      source: "url",
      url: e,
      title: t,
      startIndex: Number(n),
      endIndex: Number(n),
      citedText: s
    };
  }
  if (r.type === "search_result_location" && K(r.source) && K(r.title) && or(r.start_block_index) && or(r.end_block_index) && K(r.cited_text)) {
    const { source: e, title: t, start_block_index: n, end_block_index: s, cited_text: a, ...i } = r;
    return {
      ...i,
      type: "citation",
      source: "search",
      url: e,
      title: t ?? void 0,
      startIndex: n,
      endIndex: s,
      citedText: a
    };
  }
}
function pm(r) {
  if (ue(r, "document") && ve(r.source) && "type" in r.source) {
    if (r.source.type === "base64" && K(r.source.media_type) && K(r.source.data)) return {
      type: "file",
      mimeType: r.source.media_type,
      data: r.source.data
    };
    if (r.source.type === "url" && K(r.source.url)) return {
      type: "file",
      url: r.source.url
    };
    if (r.source.type === "file" && K(r.source.file_id)) return {
      type: "file",
      fileId: r.source.file_id
    };
    if (r.source.type === "text" && K(r.source.data)) return {
      type: "file",
      mimeType: String(r.source.media_type ?? "text/plain"),
      data: r.source.data
    };
  } else if (ue(r, "image") && ve(r.source) && "type" in r.source) {
    if (r.source.type === "base64" && K(r.source.media_type) && K(r.source.data)) return {
      type: "image",
      mimeType: r.source.media_type,
      data: r.source.data
    };
    if (r.source.type === "url" && K(r.source.url)) return {
      type: "image",
      url: r.source.url
    };
    if (r.source.type === "file" && K(r.source.file_id)) return {
      type: "image",
      fileId: r.source.file_id
    };
  }
}
function Kw(r) {
  function* e() {
    for (const t of r) {
      const n = pm(t);
      n ? yield n : yield t;
    }
  }
  return Array.from(e());
}
function Od(r) {
  function* e() {
    var n;
    const t = typeof r.content == "string" ? [{
      type: "text",
      text: r.content
    }] : r.content;
    for (const s of t) {
      if (ue(s, "text") && K(s.text)) {
        const { text: a, citations: i, ...o } = s;
        if (Tr(i) && i.length) {
          const c = i.reduce((u, l) => {
            const d = Gw(l);
            return d ? [...u, d] : u;
          }, []);
          yield {
            ...o,
            type: "text",
            text: a,
            annotations: c
          };
          continue;
        } else {
          yield {
            ...o,
            type: "text",
            text: a
          };
          continue;
        }
      } else if (ue(s, "thinking") && K(s.thinking)) {
        const { thinking: a, signature: i, ...o } = s;
        yield {
          ...o,
          type: "reasoning",
          reasoning: a,
          signature: i
        };
        continue;
      } else if (ue(s, "redacted_thinking")) {
        yield {
          type: "non_standard",
          value: s
        };
        continue;
      } else if (ue(s, "tool_use") && K(s.name) && K(s.id)) {
        yield {
          type: "tool_call",
          id: s.id,
          name: s.name,
          args: s.input
        };
        continue;
      } else if (ue(s, "input_json_delta")) {
        if (Xw(r) && ((n = r.tool_call_chunks) != null && n.length)) {
          const a = r.tool_call_chunks[0];
          yield {
            type: "tool_call_chunk",
            id: a.id,
            name: a.name,
            args: a.args,
            index: a.index
          };
          continue;
        }
      } else if (ue(s, "server_tool_use") && K(s.name) && K(s.id)) {
        const { name: a, id: i } = s;
        if (a === "web_search") {
          const o = qs(() => {
            if (typeof s.input == "string") return s.input;
            if (ve(s.input) && K(s.input.query)) return s.input.query;
            if (K(s.partial_json)) {
              const c = kd(s.partial_json);
              if (c != null && c.query) return c.query;
            }
            return "";
          });
          yield {
            id: i,
            type: "server_tool_call",
            name: "web_search",
            args: { query: o }
          };
          continue;
        } else if (s.name === "code_execution") {
          const o = qs(() => {
            if (typeof s.input == "string") return s.input;
            if (ve(s.input) && K(s.input.code)) return s.input.code;
            if (K(s.partial_json)) {
              const c = kd(s.partial_json);
              if (c != null && c.code) return c.code;
            }
            return "";
          });
          yield {
            id: i,
            type: "server_tool_call",
            name: "code_execution",
            args: { code: o }
          };
          continue;
        }
      } else if (ue(s, "web_search_tool_result") && K(s.tool_use_id) && Tr(s.content)) {
        const { content: a, tool_use_id: i } = s, o = a.reduce((c, u) => ue(u, "web_search_result") ? [...c, u.url] : c, []);
        yield {
          type: "server_tool_call_result",
          name: "web_search",
          toolCallId: i,
          status: "success",
          output: { urls: o }
        };
        continue;
      } else if (ue(s, "code_execution_tool_result") && K(s.tool_use_id) && ve(s.content)) {
        yield {
          type: "server_tool_call_result",
          name: "code_execution",
          toolCallId: s.tool_use_id,
          status: "success",
          output: s.content
        };
        continue;
      } else if (ue(s, "mcp_tool_use")) {
        yield {
          id: s.id,
          type: "server_tool_call",
          name: "mcp_tool_use",
          args: s.input
        };
        continue;
      } else if (ue(s, "mcp_tool_result") && K(s.tool_use_id) && ve(s.content)) {
        yield {
          type: "server_tool_call_result",
          name: "mcp_tool_use",
          toolCallId: s.tool_use_id,
          status: "success",
          output: s.content
        };
        continue;
      } else if (ue(s, "container_upload")) {
        yield {
          type: "server_tool_call",
          name: "container_upload",
          args: s.input
        };
        continue;
      } else if (ue(s, "search_result")) {
        yield {
          id: s.id,
          type: "non_standard",
          value: s
        };
        continue;
      } else if (ue(s, "tool_result")) {
        yield {
          id: s.id,
          type: "non_standard",
          value: s
        };
        continue;
      } else {
        const a = pm(s);
        if (a) {
          yield a;
          continue;
        }
      }
      yield {
        type: "non_standard",
        value: s
      };
    }
  }
  return Array.from(e());
}
const Yw = {
  translateContent: Od,
  translateContentChunk: Od
};
function Xw(r) {
  return typeof (r == null ? void 0 : r._getType) == "function" && typeof r.concat == "function" && r._getType() === "ai";
}
function Qw(r) {
  return Ju(r) ? {
    type: r.type,
    mimeType: r.mime_type,
    url: r.url,
    metadata: r.metadata
  } : Wu(r) ? {
    type: r.type,
    mimeType: r.mime_type ?? "application/octet-stream",
    data: r.data,
    metadata: r.metadata
  } : im(r) ? {
    type: r.type,
    mimeType: r.mime_type,
    fileId: r.id,
    metadata: r.metadata
  } : r;
}
function ev(r) {
  return r.map(Qw);
}
function tv(r) {
  return !!(ue(r, "image_url") && ve(r.image_url) || ue(r, "input_audio") && ve(r.input_audio) || ue(r, "file") && ve(r.file));
}
function rv(r) {
  if (ue(r, "image_url") && ve(r.image_url) && K(r.image_url.url)) {
    const e = Vs({ dataUrl: r.image_url.url });
    return e ? {
      type: "image",
      mimeType: e.mime_type,
      data: e.data
    } : {
      type: "image",
      url: r.image_url.url
    };
  } else {
    if (ue(r, "input_audio") && ve(r.input_audio) && K(r.input_audio.data) && K(r.input_audio.format)) return {
      type: "audio",
      data: r.input_audio.data,
      mimeType: `audio/${r.input_audio.format}`
    };
    if (ue(r, "file") && ve(r.file) && K(r.file.data)) {
      const e = Vs({ dataUrl: r.file.data });
      if (e) return {
        type: "file",
        data: e.data,
        mimeType: e.mime_type
      };
      if (K(r.file.file_id)) return {
        type: "file",
        fileId: r.file.file_id
      };
    }
  }
  return r;
}
function nv(r) {
  const e = [];
  typeof r.content == "string" ? e.push({
    type: "text",
    text: r.content
  }) : e.push(...Qu(r.content));
  for (const t of r.tool_calls ?? []) e.push({
    type: "tool_call",
    id: t.id,
    name: t.name,
    args: t.args
  });
  return e;
}
function sv(r) {
  const e = [];
  typeof r.content == "string" ? e.push({
    type: "text",
    text: r.content
  }) : e.push(...Qu(r.content));
  for (const t of r.tool_calls ?? []) e.push({
    type: "tool_call",
    id: t.id,
    name: t.name,
    args: t.args
  });
  return e;
}
function Qu(r) {
  const e = [];
  for (const t of r) tv(t) ? e.push(rv(t)) : e.push(t);
  return e;
}
function av(r) {
  if (r.type === "url_citation") {
    const { url: e, title: t, start_index: n, end_index: s } = r;
    return {
      type: "citation",
      url: e,
      title: t,
      startIndex: n,
      endIndex: s
    };
  }
  if (r.type === "file_citation") {
    const { file_id: e, filename: t, index: n } = r;
    return {
      type: "citation",
      title: t,
      startIndex: n,
      endIndex: n,
      fileId: e
    };
  }
  return r;
}
function mm(r) {
  function* e() {
    var n;
    ve((n = r.additional_kwargs) == null ? void 0 : n.reasoning) && Tr(r.additional_kwargs.reasoning.summary) && (yield {
      type: "reasoning",
      reasoning: r.additional_kwargs.reasoning.summary.reduce((a, i) => ve(i) && K(i.text) ? `${a}${i.text}` : a, "")
    });
    const t = typeof r.content == "string" ? [{
      type: "text",
      text: r.content
    }] : r.content;
    for (const s of t) if (ue(s, "text")) {
      const { text: a, annotations: i, ...o } = s;
      Array.isArray(i) ? yield {
        ...o,
        type: "text",
        text: String(a),
        annotations: i.map(av)
      } : yield {
        ...o,
        type: "text",
        text: String(a)
      };
    }
    for (const s of r.tool_calls ?? []) yield {
      type: "tool_call",
      id: s.id,
      name: s.name,
      args: s.args
    };
    if (ve(r.additional_kwargs) && Tr(r.additional_kwargs.tool_outputs)) for (const s of r.additional_kwargs.tool_outputs) {
      if (ue(s, "web_search_call")) {
        yield {
          id: s.id,
          type: "server_tool_call",
          name: "web_search",
          args: { query: s.query }
        };
        continue;
      } else if (ue(s, "file_search_call")) {
        yield {
          id: s.id,
          type: "server_tool_call",
          name: "file_search",
          args: { query: s.query }
        };
        continue;
      } else if (ue(s, "computer_call")) {
        yield {
          type: "non_standard",
          value: s
        };
        continue;
      } else if (ue(s, "code_interpreter_call")) {
        if (K(s.code) && (yield {
          id: s.id,
          type: "server_tool_call",
          name: "code_interpreter",
          args: { code: s.code }
        }), Tr(s.outputs)) {
          const a = qs(() => {
            if (s.status !== "in_progress") {
              if (s.status === "completed") return 0;
              if (s.status === "incomplete") return 127;
              if (s.status !== "interpreting" && s.status === "failed")
                return 1;
            }
          });
          for (const i of s.outputs) if (ue(i, "logs")) {
            yield {
              type: "server_tool_call_result",
              toolCallId: s.id ?? "",
              status: "success",
              output: {
                type: "code_interpreter_output",
                returnCode: a ?? 0,
                stderr: [0, void 0].includes(a) ? void 0 : String(i.logs),
                stdout: [0, void 0].includes(a) ? String(i.logs) : void 0
              }
            };
            continue;
          }
        }
        continue;
      } else if (ue(s, "mcp_call")) {
        yield {
          id: s.id,
          type: "server_tool_call",
          name: "mcp_call",
          args: s.input
        };
        continue;
      } else if (ue(s, "mcp_list_tools")) {
        yield {
          id: s.id,
          type: "server_tool_call",
          name: "mcp_list_tools",
          args: s.input
        };
        continue;
      } else if (ue(s, "mcp_approval_request")) {
        yield {
          type: "non_standard",
          value: s
        };
        continue;
      } else if (ue(s, "image_generation_call")) {
        yield {
          type: "non_standard",
          value: s
        };
        continue;
      }
      ve(s) && (yield {
        type: "non_standard",
        value: s
      });
    }
  }
  return Array.from(e());
}
function iv(r) {
  function* e() {
    yield* mm(r);
    for (const t of r.tool_call_chunks ?? []) yield {
      type: "tool_call_chunk",
      id: t.id,
      name: t.name,
      args: t.args
    };
  }
  return Array.from(e());
}
const ov = {
  translateContent: (r) => typeof r.content == "string" ? nv(r) : mm(r),
  translateContentChunk: (r) => typeof r.content == "string" ? sv(r) : iv(r)
};
function cv(r, e = "pretty") {
  return e === "pretty" ? uv(r) : JSON.stringify(r);
}
function uv(r) {
  const e = [], t = ` ${r.type.charAt(0).toUpperCase() + r.type.slice(1)} Message `, n = Math.floor((80 - t.length) / 2), s = "=".repeat(n), a = t.length % 2 === 0 ? s : `${s}=`;
  if (e.push(`${s}${t}${a}`), r.type === "ai") {
    const i = r;
    if (i.tool_calls && i.tool_calls.length > 0) {
      e.push("Tool Calls:");
      for (const o of i.tool_calls) {
        e.push(`  ${o.name} (${o.id})`), e.push(` Call ID: ${o.id}`), e.push("  Args:");
        for (const [c, u] of Object.entries(o.args)) e.push(`    ${c}: ${u}`);
      }
    }
  }
  if (r.type === "tool") {
    const i = r;
    i.name && e.push(`Name: ${i.name}`);
  }
  return typeof r.content == "string" && r.content.trim() && (e.length > 1 && e.push(""), e.push(r.content)), e.join(`
`);
}
const qo = Symbol.for("langchain.message");
function Fr(r, e) {
  return typeof r == "string" ? r === "" ? e : typeof e == "string" ? r + e : Array.isArray(e) && e.length === 0 ? r : Array.isArray(e) && e.some((t) => Ir(t)) ? [{
    type: "text",
    source_type: "text",
    text: r
  }, ...e] : [{
    type: "text",
    text: r
  }, ...e] : Array.isArray(e) ? aa(r, e) ?? [...r, ...e] : e === "" ? r : Array.isArray(r) && r.some((t) => Ir(t)) ? [...r, {
    type: "file",
    source_type: "text",
    text: e
  }] : [...r, {
    type: "text",
    text: e
  }];
}
function gm(r, e) {
  return r === "error" || e === "error" ? "error" : "success";
}
function lv(r, e) {
  function t(n, s) {
    if (typeof n != "object" || n === null || n === void 0) return n;
    if (s >= e)
      return Array.isArray(n) ? "[Array]" : "[Object]";
    if (Array.isArray(n)) return n.map((i) => t(i, s + 1));
    const a = {};
    for (const i of Object.keys(n)) a[i] = t(n[i], s + 1);
    return a;
  }
  return JSON.stringify(t(r, 0), null, 2);
}
var xf, Vr = class extends Kn {
  constructor(e) {
    const t = typeof e == "string" || Array.isArray(e) ? { content: e } : e;
    t.additional_kwargs || (t.additional_kwargs = {}), t.response_metadata || (t.response_metadata = {});
    super(t);
    v(this, "lc_namespace", ["langchain_core", "messages"]);
    v(this, "lc_serializable", !0);
    v(this, xf, !0);
    v(this, "id");
    v(this, "name");
    v(this, "content");
    v(this, "additional_kwargs");
    v(this, "response_metadata");
    this.name = t.name, t.content === void 0 && t.contentBlocks !== void 0 ? (this.content = t.contentBlocks, this.response_metadata = {
      output_version: "v1",
      ...t.response_metadata
    }) : t.content !== void 0 ? (this.content = t.content ?? [], this.response_metadata = t.response_metadata) : (this.content = [], this.response_metadata = t.response_metadata), this.additional_kwargs = t.additional_kwargs, this.id = t.id;
  }
  get lc_aliases() {
    return {
      additional_kwargs: "additional_kwargs",
      response_metadata: "response_metadata"
    };
  }
  /**
  * @deprecated Use .getType() instead or import the proper typeguard.
  * For example:
  *
  * ```ts
  * import { isAIMessage } from "@langchain/core/messages";
  *
  * const message = new AIMessage("Hello!");
  * isAIMessage(message); // true
  * ```
  */
  _getType() {
    return this.type;
  }
  /**
  * @deprecated Use .type instead
  * The type of the message.
  */
  getType() {
    return this._getType();
  }
  /** Get text content of the message. */
  get text() {
    return typeof this.content == "string" ? this.content : Array.isArray(this.content) ? this.content.map((e) => typeof e == "string" ? e : e.type === "text" ? e.text : "").join("") : "";
  }
  get contentBlocks() {
    const e = typeof this.content == "string" ? [{
      type: "text",
      text: this.content
    }] : this.content;
    return [
      ev,
      Qu,
      Kw
    ].reduce((s, a) => a(s), e);
  }
  toDict() {
    return {
      type: this.getType(),
      data: this.toJSON().kwargs
    };
  }
  static lc_name() {
    return "BaseMessage";
  }
  get _printableFields() {
    return {
      id: this.id,
      content: this.content,
      name: this.name,
      additional_kwargs: this.additional_kwargs,
      response_metadata: this.response_metadata
    };
  }
  static isInstance(e) {
    return typeof e == "object" && e !== null && qo in e && e[qo] === !0 && cm(e);
  }
  _updateId(e) {
    this.id = e, this.lc_kwargs.id = e;
  }
  get [(xf = qo, Symbol.toStringTag)]() {
    return this.constructor.lc_name();
  }
  [Symbol.for("nodejs.util.inspect.custom")](e) {
    if (e === null) return this;
    const t = lv(this._printableFields, Math.max(4, e));
    return `${this.constructor.lc_name()} ${t}`;
  }
  toFormattedString(e = "pretty") {
    return cv(this, e);
  }
};
function dv(r) {
  return Array.isArray(r) && r.every((e) => typeof e.index == "number");
}
function Tt(r = {}, e = {}) {
  const t = { ...r };
  for (const [n, s] of Object.entries(e)) if (t[n] == null) t[n] = s;
  else {
    if (s == null) continue;
    if (typeof t[n] != typeof s || Array.isArray(t[n]) !== Array.isArray(s)) throw new Error(`field[${n}] already exists in the message chunk, but with a different type.`);
    if (typeof t[n] == "string") {
      if (n === "type") continue;
      [
        "id",
        "name",
        "output_version",
        "model_provider"
      ].includes(n) ? s && (t[n] = s) : t[n] += s;
    } else if (typeof t[n] == "object" && !Array.isArray(t[n])) t[n] = Tt(t[n], s);
    else if (Array.isArray(t[n])) t[n] = aa(t[n], s);
    else {
      if (t[n] === s) continue;
      console.warn(`field[${n}] already exists in this message chunk and value has unsupported type.`);
    }
  }
  return t;
}
function aa(r, e) {
  if (!(r === void 0 && e === void 0)) {
    if (r === void 0 || e === void 0) return r || e;
    {
      const t = [...r];
      for (const n of e) if (typeof n == "object" && n !== null && "index" in n && typeof n.index == "number") {
        const s = t.findIndex((a) => {
          const i = typeof a == "object", o = "index" in a && a.index === n.index, c = "id" in a && "id" in n && (a == null ? void 0 : a.id) === (n == null ? void 0 : n.id), u = !("id" in a) || !(a != null && a.id) || !("id" in n) || !(n != null && n.id);
          return i && o && (c || u);
        });
        s !== -1 && typeof t[s] == "object" && t[s] !== null ? t[s] = Tt(t[s], n) : t.push(n);
      } else {
        if (typeof n == "object" && n !== null && "text" in n && n.text === "") continue;
        t.push(n);
      }
      return t;
    }
  }
}
function _m(r, e) {
  if (!r && !e) throw new Error("Cannot merge two undefined objects.");
  if (!r || !e) return r || e;
  if (typeof r != typeof e) throw new Error(`Cannot merge objects of different types.
Left ${typeof r}
Right ${typeof e}`);
  if (typeof r == "string" && typeof e == "string") return r + e;
  if (Array.isArray(r) && Array.isArray(e)) return aa(r, e);
  if (typeof r == "object" && typeof e == "object") return Tt(r, e);
  if (r === e) return r;
  throw new Error(`Can not merge objects of different types.
Left ${r}
Right ${e}`);
}
var cn = class ym extends Vr {
  static isInstance(e) {
    if (!super.isInstance(e)) return !1;
    let t = Object.getPrototypeOf(e);
    for (; t !== null; ) {
      if (t === ym.prototype) return !0;
      t = Object.getPrototypeOf(t);
    }
    return !1;
  }
};
function wm(r) {
  return typeof r.role == "string";
}
function Xr(r) {
  return typeof (r == null ? void 0 : r._getType) == "function";
}
function el(r) {
  return cn.isInstance(r);
}
function vm(r, e) {
  return Tt(r ?? {}, e ?? {});
}
function bm(r, e) {
  const t = {};
  return ((r == null ? void 0 : r.audio) !== void 0 || (e == null ? void 0 : e.audio) !== void 0) && (t.audio = ((r == null ? void 0 : r.audio) ?? 0) + ((e == null ? void 0 : e.audio) ?? 0)), ((r == null ? void 0 : r.image) !== void 0 || (e == null ? void 0 : e.image) !== void 0) && (t.image = ((r == null ? void 0 : r.image) ?? 0) + ((e == null ? void 0 : e.image) ?? 0)), ((r == null ? void 0 : r.video) !== void 0 || (e == null ? void 0 : e.video) !== void 0) && (t.video = ((r == null ? void 0 : r.video) ?? 0) + ((e == null ? void 0 : e.video) ?? 0)), ((r == null ? void 0 : r.document) !== void 0 || (e == null ? void 0 : e.document) !== void 0) && (t.document = ((r == null ? void 0 : r.document) ?? 0) + ((e == null ? void 0 : e.document) ?? 0)), ((r == null ? void 0 : r.text) !== void 0 || (e == null ? void 0 : e.text) !== void 0) && (t.text = ((r == null ? void 0 : r.text) ?? 0) + ((e == null ? void 0 : e.text) ?? 0)), t;
}
function hv(r, e) {
  const t = { ...bm(r, e) };
  return ((r == null ? void 0 : r.cache_read) !== void 0 || (e == null ? void 0 : e.cache_read) !== void 0) && (t.cache_read = ((r == null ? void 0 : r.cache_read) ?? 0) + ((e == null ? void 0 : e.cache_read) ?? 0)), ((r == null ? void 0 : r.cache_creation) !== void 0 || (e == null ? void 0 : e.cache_creation) !== void 0) && (t.cache_creation = ((r == null ? void 0 : r.cache_creation) ?? 0) + ((e == null ? void 0 : e.cache_creation) ?? 0)), t;
}
function fv(r, e) {
  const t = { ...bm(r, e) };
  return ((r == null ? void 0 : r.reasoning) !== void 0 || (e == null ? void 0 : e.reasoning) !== void 0) && (t.reasoning = ((r == null ? void 0 : r.reasoning) ?? 0) + ((e == null ? void 0 : e.reasoning) ?? 0)), t;
}
function Sm(r, e) {
  return {
    input_tokens: ((r == null ? void 0 : r.input_tokens) ?? 0) + ((e == null ? void 0 : e.input_tokens) ?? 0),
    output_tokens: ((r == null ? void 0 : r.output_tokens) ?? 0) + ((e == null ? void 0 : e.output_tokens) ?? 0),
    total_tokens: ((r == null ? void 0 : r.total_tokens) ?? 0) + ((e == null ? void 0 : e.total_tokens) ?? 0),
    input_token_details: hv(r == null ? void 0 : r.input_token_details, e == null ? void 0 : e.input_token_details),
    output_token_details: fv(r == null ? void 0 : r.output_token_details, e == null ? void 0 : e.output_token_details)
  };
}
var pv = {};
Ae(pv, {
  ToolMessage: () => kr,
  ToolMessageChunk: () => ia,
  defaultToolCallParser: () => rl,
  isDirectToolOutput: () => tl,
  isToolMessage: () => Tm,
  isToolMessageChunk: () => Em
});
function tl(r) {
  return r != null && typeof r == "object" && "lc_direct_tool_output" in r && r.lc_direct_tool_output === !0;
}
var kr = class extends Vr {
  constructor(e, t, n) {
    const s = typeof e == "string" || Array.isArray(e) ? {
      content: e,
      name: n,
      tool_call_id: t
    } : e;
    super(s);
    v(this, "lc_direct_tool_output", !0);
    v(this, "type", "tool");
    /**
    * Status of the tool invocation.
    * @version 0.2.19
    */
    v(this, "status");
    v(this, "tool_call_id");
    v(this, "metadata");
    /**
    * Artifact of the Tool execution which is not meant to be sent to the model.
    *
    * Should only be specified if it is different from the message content, e.g. if only
    * a subset of the full tool output is being passed as message content but the full
    * output is needed in other parts of the code.
    */
    v(this, "artifact");
    this.tool_call_id = s.tool_call_id, this.artifact = s.artifact, this.status = s.status, this.metadata = s.metadata;
  }
  static lc_name() {
    return "ToolMessage";
  }
  get lc_aliases() {
    return { tool_call_id: "tool_call_id" };
  }
  static isInstance(e) {
    return super.isInstance(e) && e.type === "tool";
  }
  get _printableFields() {
    return {
      ...super._printableFields,
      tool_call_id: this.tool_call_id,
      artifact: this.artifact
    };
  }
}, ia = class extends cn {
  constructor(e) {
    super(e);
    v(this, "type", "tool");
    v(this, "tool_call_id");
    /**
    * Status of the tool invocation.
    * @version 0.2.19
    */
    v(this, "status");
    /**
    * Artifact of the Tool execution which is not meant to be sent to the model.
    *
    * Should only be specified if it is different from the message content, e.g. if only
    * a subset of the full tool output is being passed as message content but the full
    * output is needed in other parts of the code.
    */
    v(this, "artifact");
    this.tool_call_id = e.tool_call_id, this.artifact = e.artifact, this.status = e.status;
  }
  static lc_name() {
    return "ToolMessageChunk";
  }
  concat(e) {
    const t = this.constructor;
    return new t({
      content: Fr(this.content, e.content),
      additional_kwargs: Tt(this.additional_kwargs, e.additional_kwargs),
      response_metadata: Tt(this.response_metadata, e.response_metadata),
      artifact: _m(this.artifact, e.artifact),
      tool_call_id: this.tool_call_id,
      id: this.id ?? e.id,
      status: gm(this.status, e.status)
    });
  }
  get _printableFields() {
    return {
      ...super._printableFields,
      tool_call_id: this.tool_call_id,
      artifact: this.artifact
    };
  }
};
function rl(r) {
  const e = [], t = [];
  for (const n of r) if (n.function) {
    const s = n.function.name;
    try {
      const a = JSON.parse(n.function.arguments);
      e.push({
        name: s || "",
        args: a || {},
        id: n.id
      });
    } catch {
      t.push({
        name: s,
        args: n.function.arguments,
        id: n.id,
        error: "Malformed args."
      });
    }
  } else
    continue;
  return [e, t];
}
function Tm(r) {
  return typeof r == "object" && r !== null && "getType" in r && typeof r.getType == "function" && r.getType() === "tool";
}
function Em(r) {
  return r._getType() === "tool";
}
var In = class xm extends Vr {
  constructor(t, n) {
    (typeof t == "string" || Array.isArray(t)) && (t = {
      content: t,
      role: n
    });
    super(t);
    v(this, "type", "generic");
    v(this, "role");
    this.role = t.role;
  }
  static lc_name() {
    return "ChatMessage";
  }
  static _chatMessageClass() {
    return xm;
  }
  static isInstance(t) {
    return super.isInstance(t) && t.type === "generic";
  }
  get _printableFields() {
    return {
      ...super._printableFields,
      role: this.role
    };
  }
}, oa = class extends cn {
  constructor(e, t) {
    (typeof e == "string" || Array.isArray(e)) && (e = {
      content: e,
      role: t
    });
    super(e);
    v(this, "type", "generic");
    v(this, "role");
    this.role = e.role;
  }
  static lc_name() {
    return "ChatMessageChunk";
  }
  concat(e) {
    const t = this.constructor;
    return new t({
      content: Fr(this.content, e.content),
      additional_kwargs: Tt(this.additional_kwargs, e.additional_kwargs),
      response_metadata: Tt(this.response_metadata, e.response_metadata),
      role: this.role,
      id: this.id ?? e.id
    });
  }
  static isInstance(e) {
    return super.isInstance(e) && e.type === "generic";
  }
  get _printableFields() {
    return {
      ...super._printableFields,
      role: this.role
    };
  }
};
function mv(r) {
  return r._getType() === "generic";
}
function gv(r) {
  return r._getType() === "generic";
}
var ao = class extends Vr {
  constructor(e) {
    super(e);
    v(this, "type", "function");
    v(this, "name");
    this.name = e.name;
  }
  static lc_name() {
    return "FunctionMessage";
  }
}, ca = class extends cn {
  constructor() {
    super(...arguments);
    v(this, "type", "function");
  }
  static lc_name() {
    return "FunctionMessageChunk";
  }
  concat(e) {
    const t = this.constructor;
    return new t({
      content: Fr(this.content, e.content),
      additional_kwargs: Tt(this.additional_kwargs, e.additional_kwargs),
      response_metadata: Tt(this.response_metadata, e.response_metadata),
      name: this.name ?? "",
      id: this.id ?? e.id
    });
  }
};
function _v(r) {
  return r._getType() === "function";
}
function yv(r) {
  return r._getType() === "function";
}
var zt = class extends Vr {
  constructor(e) {
    super(e);
    v(this, "type", "human");
  }
  static lc_name() {
    return "HumanMessage";
  }
  static isInstance(e) {
    return super.isInstance(e) && e.type === "human";
  }
}, ua = class extends cn {
  constructor(e) {
    super(e);
    v(this, "type", "human");
  }
  static lc_name() {
    return "HumanMessageChunk";
  }
  concat(e) {
    const t = this.constructor;
    return new t({
      content: Fr(this.content, e.content),
      additional_kwargs: Tt(this.additional_kwargs, e.additional_kwargs),
      response_metadata: Tt(this.response_metadata, e.response_metadata),
      id: this.id ?? e.id
    });
  }
  static isInstance(e) {
    return super.isInstance(e) && e.type === "human";
  }
};
function wv(r) {
  return r.getType() === "human";
}
function vv(r) {
  return r.getType() === "human";
}
var vi = class extends Vr {
  constructor(e) {
    super({
      ...e,
      content: []
    });
    v(this, "type", "remove");
    /**
    * The ID of the message to remove.
    */
    v(this, "id");
    this.id = e.id;
  }
  get _printableFields() {
    return {
      ...super._printableFields,
      id: this.id
    };
  }
  static isInstance(e) {
    return super.isInstance(e) && e.type === "remove";
  }
}, ct = class ai extends Vr {
  constructor(t) {
    super(t);
    v(this, "type", "system");
  }
  static lc_name() {
    return "SystemMessage";
  }
  /**
  * Concatenates a string or another system message with the current system message.
  * @param chunk - The chunk to concatenate with the system message.
  * @returns A new system message with the concatenated content.
  */
  concat(t) {
    if (typeof t == "string") return new ai({
      ...this,
      content: Fr(this.content, t)
    });
    if (ai.isInstance(t)) return new ai({
      ...this,
      additional_kwargs: {
        ...this.additional_kwargs,
        ...t.additional_kwargs
      },
      response_metadata: {
        ...this.response_metadata,
        ...t.response_metadata
      },
      content: Fr(this.content, t.content)
    });
    throw new Error("Unexpected chunk type for system message");
  }
  static isInstance(t) {
    return super.isInstance(t) && t.type === "system";
  }
}, nn = class extends cn {
  constructor(e) {
    super(e);
    v(this, "type", "system");
  }
  static lc_name() {
    return "SystemMessageChunk";
  }
  concat(e) {
    const t = this.constructor;
    return new t({
      content: Fr(this.content, e.content),
      additional_kwargs: Tt(this.additional_kwargs, e.additional_kwargs),
      response_metadata: Tt(this.response_metadata, e.response_metadata),
      id: this.id ?? e.id
    });
  }
  static isInstance(e) {
    return super.isInstance(e) && e.type === "system";
  }
};
function bv(r) {
  return r._getType() === "system";
}
function Sv(r) {
  return r._getType() === "system";
}
function Im(r, e) {
  return r.lc_error_code = e, r.message = `${r.message}

Troubleshooting URL: https://docs.langchain.com/oss/javascript/langchain/errors/${e}/
`, r;
}
function Ms(r) {
  return !!(r && typeof r == "object" && "type" in r && r.type === "tool_call");
}
function Tv(r) {
  return !!(r && typeof r == "object" && "toolCall" in r && r.toolCall != null && typeof r.toolCall == "object" && "id" in r.toolCall && typeof r.toolCall.id == "string");
}
var bi = class extends Error {
  constructor(e, t) {
    super(e);
    v(this, "output");
    this.output = t;
  }
};
function Pc(r, e = io) {
  r = r.trim();
  const t = r.indexOf("```");
  if (t === -1) return e(r);
  let n = r.substring(t + 3);
  n.startsWith(`json
`) ? n = n.substring(5) : n.startsWith("json") ? n = n.substring(4) : n.startsWith(`
`) && (n = n.substring(1));
  const s = n.indexOf("```");
  let a = n;
  return s !== -1 && (a = n.substring(0, s)), e(a.trim());
}
function Ev(r) {
  try {
    return JSON.parse(r);
  } catch {
  }
  const e = r.trim();
  if (e.length === 0) throw new Error("Unexpected end of JSON input");
  let t = 0;
  function n() {
    for (; t < e.length && /\s/.test(e[t]); ) t += 1;
  }
  function s() {
    if (e[t] !== '"') throw new Error(`Expected '"' at position ${t}, got '${e[t]}'`);
    t += 1;
    let l = "", d = !1;
    for (; t < e.length; ) {
      const h = e[t];
      if (d) {
        if (h === "n") l += `
`;
        else if (h === "t") l += "	";
        else if (h === "r") l += "\r";
        else if (h === "\\") l += "\\";
        else if (h === '"') l += '"';
        else if (h === "b") l += "\b";
        else if (h === "f") l += "\f";
        else if (h === "/") l += "/";
        else if (h === "u") {
          const f = e.substring(t + 1, t + 5);
          if (/^[0-9A-Fa-f]{0,4}$/.test(f))
            f.length === 4 ? l += String.fromCharCode(Number.parseInt(f, 16)) : l += `u${f}`, t += f.length;
          else throw new Error(`Invalid unicode escape sequence '\\u${f}' at position ${t}`);
        } else throw new Error(`Invalid escape sequence '\\${h}' at position ${t}`);
        d = !1;
      } else if (h === "\\") d = !0;
      else {
        if (h === '"')
          return t += 1, l;
        l += h;
      }
      t += 1;
    }
    return d && (l += "\\"), l;
  }
  function a() {
    const l = t;
    let d = "";
    if (e[t] === "-" && (d += "-", t += 1), t < e.length && e[t] === "0" && (d += "0", t += 1, e[t] >= "0" && e[t] <= "9"))
      throw new Error(`Invalid number at position ${l}`);
    if (t < e.length && e[t] >= "1" && e[t] <= "9") for (; t < e.length && e[t] >= "0" && e[t] <= "9"; )
      d += e[t], t += 1;
    if (t < e.length && e[t] === ".")
      for (d += ".", t += 1; t < e.length && e[t] >= "0" && e[t] <= "9"; )
        d += e[t], t += 1;
    if (t < e.length && (e[t] === "e" || e[t] === "E"))
      for (d += e[t], t += 1, t < e.length && (e[t] === "+" || e[t] === "-") && (d += e[t], t += 1); t < e.length && e[t] >= "0" && e[t] <= "9"; )
        d += e[t], t += 1;
    if (d === "-") return -0;
    const h = Number.parseFloat(d);
    if (Number.isNaN(h))
      throw t = l, new Error(`Invalid number '${d}' at position ${l}`);
    return h;
  }
  function i() {
    if (n(), t >= e.length) throw new Error(`Unexpected end of input at position ${t}`);
    const l = e[t];
    if (l === "{") return c();
    if (l === "[") return o();
    if (l === '"') return s();
    if ("null".startsWith(e.substring(t, t + 4)))
      return t += Math.min(4, e.length - t), null;
    if ("true".startsWith(e.substring(t, t + 4)))
      return t += Math.min(4, e.length - t), !0;
    if ("false".startsWith(e.substring(t, t + 5)))
      return t += Math.min(5, e.length - t), !1;
    if (l === "-" || l >= "0" && l <= "9") return a();
    throw new Error(`Unexpected character '${l}' at position ${t}`);
  }
  function o() {
    if (e[t] !== "[") throw new Error(`Expected '[' at position ${t}, got '${e[t]}'`);
    const l = [];
    if (t += 1, n(), t >= e.length) return l;
    if (e[t] === "]")
      return t += 1, l;
    for (; t < e.length; ) {
      if (n(), t >= e.length || (l.push(i()), n(), t >= e.length)) return l;
      if (e[t] === "]")
        return t += 1, l;
      if (e[t] === ",") {
        t += 1;
        continue;
      }
      throw new Error(`Expected ',' or ']' at position ${t}, got '${e[t]}'`);
    }
    return l;
  }
  function c() {
    if (e[t] !== "{") throw new Error(`Expected '{' at position ${t}, got '${e[t]}'`);
    const l = {};
    if (t += 1, n(), t >= e.length) return l;
    if (e[t] === "}")
      return t += 1, l;
    for (; t < e.length; ) {
      if (n(), t >= e.length) return l;
      const d = s();
      if (n(), t >= e.length) return l;
      if (e[t] !== ":") throw new Error(`Expected ':' at position ${t}, got '${e[t]}'`);
      if (t += 1, n(), t >= e.length || (l[d] = i(), n(), t >= e.length)) return l;
      if (e[t] === "}")
        return t += 1, l;
      if (e[t] === ",") {
        t += 1;
        continue;
      }
      throw new Error(`Expected ',' or '}' at position ${t}, got '${e[t]}'`);
    }
    return l;
  }
  const u = i();
  if (n(), t < e.length) throw new Error(`Unexpected character '${e[t]}' at position ${t}`);
  return u;
}
function io(r) {
  try {
    return typeof r > "u" ? null : Ev(r);
  } catch {
    return null;
  }
}
function nl(r) {
  switch (r) {
    case "csv":
      return "text/csv";
    case "doc":
      return "application/vnd.openxmlformats-officedocument.wordprocessingml.document";
    case "docx":
      return "application/vnd.openxmlformats-officedocument.wordprocessingml.document";
    case "html":
      return "text/html";
    case "md":
      return "text/markdown";
    case "pdf":
      return "application/pdf";
    case "txt":
      return "text/plain";
    case "xls":
      return "application/vnd.ms-excel";
    case "xlsx":
      return "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet";
    case "gif":
      return "image/gif";
    case "jpeg":
      return "image/jpeg";
    case "jpg":
      return "image/jpeg";
    case "png":
      return "image/png";
    case "webp":
      return "image/webp";
    case "flv":
      return "video/flv";
    case "mkv":
      return "video/mkv";
    case "mov":
      return "video/mov";
    case "mp4":
      return "video/mp4";
    case "mpeg":
      return "video/mpeg";
    case "mpg":
      return "video/mpg";
    case "three_gp":
      return "video/three_gp";
    case "webm":
      return "video/webm";
    case "wmv":
      return "video/wmv";
    default:
      return "application/octet-stream";
  }
}
function xv(r) {
  if (ve(r.document) && ve(r.document.source)) {
    const e = ve(r.document) && K(r.document.format) ? r.document.format : "", t = nl(e);
    if (ve(r.document.source)) {
      if (ve(r.document.source.s3Location) && K(r.document.source.s3Location.uri)) return {
        type: "file",
        mimeType: t,
        fileId: r.document.source.s3Location.uri
      };
      if (Xu(r.document.source.bytes)) return {
        type: "file",
        mimeType: t,
        data: r.document.source.bytes
      };
      if (K(r.document.source.text)) return {
        type: "file",
        mimeType: t,
        data: Buffer.from(r.document.source.text).toString("base64")
      };
      if (Tr(r.document.source.content)) {
        const n = r.document.source.content.reduce((s, a) => ve(a) && K(a.text) ? s + a.text : s, "");
        return {
          type: "file",
          mimeType: t,
          data: n
        };
      }
    }
  }
  return {
    type: "non_standard",
    value: r
  };
}
function Iv(r) {
  if (ue(r, "image") && ve(r.image)) {
    const e = ve(r.image) && K(r.image.format) ? r.image.format : "", t = nl(e);
    if (ve(r.image.source)) {
      if (ve(r.image.source.s3Location) && K(r.image.source.s3Location.uri)) return {
        type: "image",
        mimeType: t,
        fileId: r.image.source.s3Location.uri
      };
      if (Xu(r.image.source.bytes)) return {
        type: "image",
        mimeType: t,
        data: r.image.source.bytes
      };
    }
  }
  return {
    type: "non_standard",
    value: r
  };
}
function kv(r) {
  if (ue(r, "video") && ve(r.video)) {
    const e = ve(r.video) && K(r.video.format) ? r.video.format : "", t = nl(e);
    if (ve(r.video.source)) {
      if (ve(r.video.source.s3Location) && K(r.video.source.s3Location.uri)) return {
        type: "video",
        mimeType: t,
        fileId: r.video.source.s3Location.uri
      };
      if (Xu(r.video.source.bytes)) return {
        type: "video",
        mimeType: t,
        data: r.video.source.bytes
      };
    }
  }
  return {
    type: "non_standard",
    value: r
  };
}
function Ad(r) {
  function* e() {
    const t = typeof r.content == "string" ? [{
      type: "text",
      text: r.content
    }] : r.content;
    for (const n of t) {
      if (ue(n, "cache_point")) {
        yield {
          type: "non_standard",
          value: n
        };
        continue;
      } else if (ue(n, "citations_content") && ve(n.citationsContent)) {
        const s = Tr(n.citationsContent.content) ? n.citationsContent.content.reduce((i, o) => ve(o) && K(o.text) ? i + o.text : i, "") : "", a = Tr(n.citationsContent.citations) ? n.citationsContent.citations.reduce((i, o) => {
          if (ve(o)) {
            const c = Tr(o.sourceContent) ? o.sourceContent.reduce((l, d) => ve(d) && K(d.text) ? l + d.text : l, "") : "", u = qs(() => {
              if (ve(o.location)) {
                const l = o.location.documentChar || o.location.documentPage || o.location.documentChunk;
                if (ve(l)) return {
                  source: or(l.documentIndex) ? l.documentIndex.toString() : void 0,
                  startIndex: or(l.start) ? l.start : void 0,
                  endIndex: or(l.end) ? l.end : void 0
                };
              }
              return {};
            });
            i.push({
              type: "citation",
              citedText: c,
              ...u
            });
          }
          return i;
        }, []) : [];
        yield {
          type: "text",
          text: s,
          annotations: a
        };
        continue;
      } else if (ue(n, "document") && ve(n.document)) {
        yield xv(n);
        continue;
      } else if (ue(n, "guard_content")) {
        yield {
          type: "non_standard",
          value: n
        };
        continue;
      } else if (ue(n, "image") && ve(n.image)) {
        yield Iv(n);
        continue;
      } else if (ue(n, "reasoning_content") && K(n.reasoningText)) {
        yield {
          type: "reasoning",
          reasoning: n.reasoningText
        };
        continue;
      } else if (ue(n, "text") && K(n.text)) {
        yield {
          type: "text",
          text: n.text
        };
        continue;
      } else if (ue(n, "tool_result")) {
        yield {
          type: "non_standard",
          value: n
        };
        continue;
      } else {
        if (ue(n, "tool_call")) continue;
        if (ue(n, "video") && ve(n.video)) {
          yield kv(n);
          continue;
        }
      }
      yield {
        type: "non_standard",
        value: n
      };
    }
  }
  return Array.from(e());
}
const Ov = {
  translateContent: Ad,
  translateContentChunk: Ad
};
function $d(r) {
  function* e() {
    const t = typeof r.content == "string" ? [{
      type: "text",
      text: r.content
    }] : r.content;
    for (const n of t) {
      if (ue(n, "text") && K(n.text)) {
        yield {
          type: "text",
          text: n.text
        };
        continue;
      } else if (ue(n, "inlineData") && ve(n.inlineData) && K(n.inlineData.mimeType) && K(n.inlineData.data)) {
        yield {
          type: "file",
          mimeType: n.inlineData.mimeType,
          data: n.inlineData.data
        };
        continue;
      } else if (ue(n, "functionCall") && ve(n.functionCall) && K(n.functionCall.name) && ve(n.functionCall.args)) {
        yield {
          type: "tool_call",
          id: r.id,
          name: n.functionCall.name,
          args: n.functionCall.args
        };
        continue;
      } else if (ue(n, "functionResponse")) {
        yield {
          type: "non_standard",
          value: n
        };
        continue;
      } else if (ue(n, "fileData") && ve(n.fileData) && K(n.fileData.mimeType) && K(n.fileData.fileUri)) {
        yield {
          type: "file",
          mimeType: n.fileData.mimeType,
          fileId: n.fileData.fileUri
        };
        continue;
      } else if (ue(n, "executableCode")) {
        yield {
          type: "non_standard",
          value: n
        };
        continue;
      } else if (ue(n, "codeExecutionResult")) {
        yield {
          type: "non_standard",
          value: n
        };
        continue;
      }
      yield {
        type: "non_standard",
        value: n
      };
    }
  }
  return Array.from(e());
}
const Av = {
  translateContent: $d,
  translateContentChunk: $d
};
function Cd(r) {
  function* e() {
    const t = typeof r.content == "string" ? [{
      type: "text",
      text: r.content
    }] : r.content;
    for (const n of t) {
      if (ue(n, "reasoning") && K(n.reasoning)) {
        const s = qs(() => {
          var i;
          const a = t.indexOf(n);
          if (Tr((i = r.additional_kwargs) == null ? void 0 : i.signatures) && a >= 0) return r.additional_kwargs.signatures.at(a);
        });
        K(s) ? yield {
          type: "reasoning",
          reasoning: n.reasoning,
          signature: s
        } : yield {
          type: "reasoning",
          reasoning: n.reasoning
        };
        continue;
      } else if (ue(n, "text") && K(n.text)) {
        yield {
          type: "text",
          text: n.text
        };
        continue;
      } else if (ue(n, "image_url")) {
        if (K(n.image_url)) if (n.image_url.startsWith("data:")) {
          const s = /^data:([^;]+);base64,(.+)$/, a = n.image_url.match(s);
          a ? yield {
            type: "image",
            data: a[2],
            mimeType: a[1]
          } : yield {
            type: "image",
            url: n.image_url
          };
        } else yield {
          type: "image",
          url: n.image_url
        };
        continue;
      } else if (ue(n, "media") && K(n.mimeType) && K(n.data)) {
        yield {
          type: "file",
          mimeType: n.mimeType,
          data: n.data
        };
        continue;
      }
      yield {
        type: "non_standard",
        value: n
      };
    }
  }
  return Array.from(e());
}
const $v = {
  translateContent: Cd,
  translateContentChunk: Cd
};
globalThis.lc_block_translators_registry ?? (globalThis.lc_block_translators_registry = /* @__PURE__ */ new Map([
  ["anthropic", Yw],
  ["bedrock-converse", Ov],
  ["google-genai", Av],
  ["google-vertexai", $v],
  ["openai", ov]
]));
function km(r) {
  return globalThis.lc_block_translators_registry.get(r);
}
var Fe = class extends Vr {
  constructor(e) {
    var n;
    let t;
    if (typeof e == "string" || Array.isArray(e)) t = {
      content: e,
      tool_calls: [],
      invalid_tool_calls: [],
      additional_kwargs: {}
    };
    else {
      t = e;
      const s = (n = t.additional_kwargs) == null ? void 0 : n.tool_calls, a = t.tool_calls;
      s != null && s.length > 0 && (a === void 0 || a.length === 0) && console.warn([
        "New LangChain packages are available that more efficiently handle",
        `tool calling.

Please upgrade your packages to versions that set`,
        "message tool calls. e.g., `pnpm install @langchain/anthropic`,",
        "pnpm install @langchain/openai`, etc."
      ].join(" "));
      try {
        if (s != null && a === void 0) {
          const [i, o] = rl(s);
          t.tool_calls = i ?? [], t.invalid_tool_calls = o ?? [];
        } else
          t.tool_calls = t.tool_calls ?? [], t.invalid_tool_calls = t.invalid_tool_calls ?? [];
      } catch {
        t.tool_calls = [], t.invalid_tool_calls = [];
      }
      if (t.response_metadata !== void 0 && "output_version" in t.response_metadata && t.response_metadata.output_version === "v1" && (t.contentBlocks = t.content, t.content = void 0), t.contentBlocks !== void 0) {
        t.contentBlocks.push(...t.tool_calls.map((o) => ({
          type: "tool_call",
          id: o.id,
          name: o.name,
          args: o.args
        })));
        const i = t.contentBlocks.filter((o) => o.type === "tool_call").filter((o) => {
          var c;
          return !((c = t.tool_calls) != null && c.some((u) => u.id === o.id && u.name === o.name));
        });
        i.length > 0 && (t.tool_calls = i.map((o) => ({
          type: "tool_call",
          id: o.id,
          name: o.name,
          args: o.args
        })));
      }
    }
    super(t);
    v(this, "type", "ai");
    v(this, "tool_calls", []);
    v(this, "invalid_tool_calls", []);
    v(this, "usage_metadata");
    typeof t != "string" && (this.tool_calls = t.tool_calls ?? this.tool_calls, this.invalid_tool_calls = t.invalid_tool_calls ?? this.invalid_tool_calls), this.usage_metadata = t.usage_metadata;
  }
  get lc_aliases() {
    return {
      ...super.lc_aliases,
      tool_calls: "tool_calls",
      invalid_tool_calls: "invalid_tool_calls"
    };
  }
  static lc_name() {
    return "AIMessage";
  }
  get contentBlocks() {
    if (this.response_metadata && "output_version" in this.response_metadata && this.response_metadata.output_version === "v1") return this.content;
    if (this.response_metadata && "model_provider" in this.response_metadata && typeof this.response_metadata.model_provider == "string") {
      const t = km(this.response_metadata.model_provider);
      if (t) return t.translateContent(this);
    }
    const e = super.contentBlocks;
    if (this.tool_calls) {
      const t = this.tool_calls.filter((n) => !e.some((s) => s.id === n.id && s.name === n.name));
      e.push(...t.map((n) => ({
        ...n,
        type: "tool_call",
        id: n.id,
        name: n.name,
        args: n.args
      })));
    }
    return e;
  }
  get _printableFields() {
    return {
      ...super._printableFields,
      tool_calls: this.tool_calls,
      invalid_tool_calls: this.invalid_tool_calls,
      usage_metadata: this.usage_metadata
    };
  }
  static isInstance(e) {
    return super.isInstance(e) && e.type === "ai";
  }
};
function oo(r) {
  return r._getType() === "ai";
}
function Lc(r) {
  return r._getType() === "ai";
}
var Ar = class extends cn {
  constructor(e) {
    let t;
    typeof e == "string" || Array.isArray(e) ? t = {
      content: e,
      tool_calls: [],
      invalid_tool_calls: [],
      tool_call_chunks: []
    } : e.tool_call_chunks === void 0 || e.tool_call_chunks.length === 0 ? t = {
      ...e,
      tool_calls: e.tool_calls ?? [],
      invalid_tool_calls: [],
      tool_call_chunks: [],
      usage_metadata: e.usage_metadata !== void 0 ? e.usage_metadata : void 0
    } : t = {
      ...e,
      ...Am(e.tool_call_chunks ?? []),
      usage_metadata: e.usage_metadata !== void 0 ? e.usage_metadata : void 0
    };
    super(t);
    v(this, "type", "ai");
    v(this, "tool_calls", []);
    v(this, "invalid_tool_calls", []);
    v(this, "tool_call_chunks", []);
    v(this, "usage_metadata");
    this.tool_call_chunks = t.tool_call_chunks ?? this.tool_call_chunks, this.tool_calls = t.tool_calls ?? this.tool_calls, this.invalid_tool_calls = t.invalid_tool_calls ?? this.invalid_tool_calls, this.usage_metadata = t.usage_metadata;
  }
  get lc_aliases() {
    return {
      ...super.lc_aliases,
      tool_calls: "tool_calls",
      invalid_tool_calls: "invalid_tool_calls",
      tool_call_chunks: "tool_call_chunks"
    };
  }
  static lc_name() {
    return "AIMessageChunk";
  }
  get contentBlocks() {
    if (this.response_metadata && "output_version" in this.response_metadata && this.response_metadata.output_version === "v1") return this.content;
    if (this.response_metadata && "model_provider" in this.response_metadata && typeof this.response_metadata.model_provider == "string") {
      const t = km(this.response_metadata.model_provider);
      if (t) return t.translateContent(this);
    }
    const e = super.contentBlocks;
    if (this.tool_calls && typeof this.content != "string") {
      const t = this.content.filter((n) => n.type === "tool_call").map((n) => n.id);
      for (const n of this.tool_calls) n.id && !t.includes(n.id) && e.push({
        ...n,
        type: "tool_call",
        id: n.id,
        name: n.name,
        args: n.args
      });
    }
    return e;
  }
  get _printableFields() {
    return {
      ...super._printableFields,
      tool_calls: this.tool_calls,
      tool_call_chunks: this.tool_call_chunks,
      invalid_tool_calls: this.invalid_tool_calls,
      usage_metadata: this.usage_metadata
    };
  }
  concat(e) {
    const t = {
      content: Fr(this.content, e.content),
      additional_kwargs: Tt(this.additional_kwargs, e.additional_kwargs),
      response_metadata: vm(this.response_metadata, e.response_metadata),
      tool_call_chunks: [],
      id: this.id ?? e.id
    };
    if (this.tool_call_chunks !== void 0 || e.tool_call_chunks !== void 0) {
      const s = aa(this.tool_call_chunks, e.tool_call_chunks);
      s !== void 0 && s.length > 0 && (t.tool_call_chunks = s);
    }
    (this.usage_metadata !== void 0 || e.usage_metadata !== void 0) && (t.usage_metadata = Sm(this.usage_metadata, e.usage_metadata));
    const n = this.constructor;
    return new n(t);
  }
  static isInstance(e) {
    return super.isInstance(e) && e.type === "ai";
  }
};
const Om = (r) => r();
function Cv(r) {
  return Ms(r) ? r : typeof r.id == "string" && r.type === "function" && typeof r.function == "object" && r.function !== null && "arguments" in r.function && typeof r.function.arguments == "string" && "name" in r.function && typeof r.function.name == "string" ? {
    id: r.id,
    args: JSON.parse(r.function.arguments),
    name: r.function.name,
    type: "tool_call"
  } : r;
}
function Rv(r) {
  return typeof r == "object" && r != null && r.lc === 1 && Array.isArray(r.id) && r.kwargs != null && typeof r.kwargs == "object";
}
function Ho(r) {
  let e, t;
  if (Rv(r)) {
    const n = r.id.at(-1);
    n === "HumanMessage" || n === "HumanMessageChunk" ? e = "user" : n === "AIMessage" || n === "AIMessageChunk" ? e = "assistant" : n === "SystemMessage" || n === "SystemMessageChunk" ? e = "system" : n === "FunctionMessage" || n === "FunctionMessageChunk" ? e = "function" : n === "ToolMessage" || n === "ToolMessageChunk" ? e = "tool" : e = "unknown", t = r.kwargs;
  } else {
    const { type: n, ...s } = r;
    e = n, t = s;
  }
  if (e === "human" || e === "user") return new zt(t);
  if (e === "ai" || e === "assistant") {
    const { tool_calls: n, ...s } = t;
    if (!Array.isArray(n)) return new Fe(t);
    const a = n.map(Cv);
    return new Fe({
      ...s,
      tool_calls: a
    });
  } else {
    if (e === "system") return new ct(t);
    if (e === "developer") return new ct({
      ...t,
      additional_kwargs: {
        ...t.additional_kwargs,
        __openai_role__: "developer"
      }
    });
    if (e === "tool" && "tool_call_id" in t) return new kr({
      ...t,
      content: t.content,
      tool_call_id: t.tool_call_id,
      name: t.name
    });
    if (e === "remove" && "id" in t && typeof t.id == "string") return new vi({
      ...t,
      id: t.id
    });
    throw Im(/* @__PURE__ */ new Error(`Unable to coerce message from array: only human, AI, system, developer, or tool message coercion is currently supported.

Received: ${JSON.stringify(r, null, 2)}`), "MESSAGE_COERCION_FAILURE");
  }
}
function Ds(r) {
  if (typeof r == "string") return new zt(r);
  if (Xr(r)) return r;
  if (Array.isArray(r)) {
    const [e, t] = r;
    return Ho({
      type: e,
      content: t
    });
  } else if (wm(r)) {
    const { role: e, ...t } = r;
    return Ho({
      ...t,
      type: e
    });
  } else return Ho(r);
}
function sl(r, e = "Human", t = "AI") {
  const n = [];
  for (const s of r) {
    let a;
    if (s._getType() === "human") a = e;
    else if (s._getType() === "ai") a = t;
    else if (s._getType() === "system") a = "System";
    else if (s._getType() === "tool") a = "Tool";
    else if (s._getType() === "generic") a = s.role;
    else throw new Error(`Got unsupported message type: ${s._getType()}`);
    const i = s.name ? `${s.name}, ` : "", o = typeof s.content == "string" ? s.content : JSON.stringify(s.content, null, 2);
    n.push(`${a}: ${i}${o}`);
  }
  return n.join(`
`);
}
function Nv(r) {
  if (r.data !== void 0) return r;
  {
    const e = r;
    return {
      type: e.type,
      data: {
        content: e.text,
        role: e.role,
        name: void 0,
        tool_call_id: void 0
      }
    };
  }
}
function al(r) {
  const e = Nv(r);
  switch (e.type) {
    case "human":
      return new zt(e.data);
    case "ai":
      return new Fe(e.data);
    case "system":
      return new ct(e.data);
    case "function":
      if (e.data.name === void 0) throw new Error("Name must be defined for function messages");
      return new ao(e.data);
    case "tool":
      if (e.data.tool_call_id === void 0) throw new Error("Tool call ID must be defined for tool messages");
      return new kr(e.data);
    case "generic":
      if (e.data.role === void 0) throw new Error("Role must be defined for chat messages");
      return new In(e.data);
    default:
      throw new Error(`Got unexpected type: ${e.type}`);
  }
}
function Pv(r) {
  return r.map(al);
}
function Lv(r) {
  return r.map((e) => e.toDict());
}
function Si(r) {
  var t;
  const e = r._getType();
  if (e === "human") return new ua({ ...r });
  if (e === "ai") {
    let n = { ...r };
    return "tool_calls" in n && (n = {
      ...n,
      tool_call_chunks: (t = n.tool_calls) == null ? void 0 : t.map((s) => ({
        ...s,
        type: "tool_call_chunk",
        index: void 0,
        args: JSON.stringify(s.args)
      }))
    }), new Ar({ ...n });
  } else {
    if (e === "system") return new nn({ ...r });
    if (e === "function") return new ca({ ...r });
    if (In.isInstance(r)) return new oa({ ...r });
    throw new Error("Unknown message type.");
  }
}
function Am(r) {
  var s, a;
  const e = r.reduce((i, o) => {
    const c = i.findIndex(([u]) => "id" in o && o.id && "index" in o && o.index !== void 0 ? o.id === u.id && o.index === u.index : "id" in o && o.id ? o.id === u.id : "index" in o && o.index !== void 0 ? o.index === u.index : !1);
    return c !== -1 ? i[c].push(o) : i.push([o]), i;
  }, []), t = [], n = [];
  for (const i of e) {
    let o = null;
    const c = ((s = i[0]) == null ? void 0 : s.name) ?? "", u = i.map((h) => h.args || "").join("").trim(), l = u.length ? u : "{}", d = (a = i[0]) == null ? void 0 : a.id;
    try {
      if (o = io(l), !d || o === null || typeof o != "object" || Array.isArray(o)) throw new Error("Malformed tool call chunk args.");
      t.push({
        name: c,
        args: o,
        id: d,
        type: "tool_call"
      });
    } catch {
      n.push({
        name: c,
        args: l,
        id: d,
        error: "Malformed args.",
        type: "invalid_tool_call"
      });
    }
  }
  return {
    tool_call_chunks: r,
    tool_calls: t,
    invalid_tool_calls: n
  };
}
const $m = Symbol.for("ls:tracing_async_local_storage"), js = Symbol.for("lc:context_variables"), Mv = (r) => {
  globalThis[$m] = r;
}, Hs = () => globalThis[$m];
var Dv = {};
Ae(Dv, {
  getEnv: () => il,
  getEnvironmentVariable: () => Er,
  getRuntimeEnvironment: () => Lm,
  isBrowser: () => Cm,
  isDeno: () => co,
  isJsDom: () => Nm,
  isNode: () => Pm,
  isWebWorker: () => Rm
});
const Cm = () => typeof window < "u" && typeof window.document < "u", Rm = () => typeof globalThis == "object" && globalThis.constructor && globalThis.constructor.name === "DedicatedWorkerGlobalScope", Nm = () => typeof window < "u" && window.name === "nodejs" || typeof navigator < "u" && navigator.userAgent.includes("jsdom"), co = () => typeof Deno < "u", Pm = () => typeof process < "u" && typeof process.versions < "u" && typeof process.versions.node < "u" && !co(), il = () => {
  let r;
  return Cm() ? r = "browser" : Pm() ? r = "node" : Rm() ? r = "webworker" : Nm() ? r = "jsdom" : co() ? r = "deno" : r = "other", r;
};
let Jo;
function Lm() {
  return Jo === void 0 && (Jo = {
    library: "langchain-js",
    runtime: il()
  }), Jo;
}
function Er(r) {
  var e;
  try {
    return typeof process < "u" ? (e = process.env) == null ? void 0 : e[r] : co() ? Deno == null ? void 0 : Deno.env.get(r) : void 0;
  } catch {
    return;
  }
}
const jv = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i;
function ii(r) {
  return typeof r == "string" && jv.test(r);
}
const gt = [];
for (let r = 0; r < 256; ++r)
  gt.push((r + 256).toString(16).slice(1));
function Fv(r, e = 0) {
  return (gt[r[e + 0]] + gt[r[e + 1]] + gt[r[e + 2]] + gt[r[e + 3]] + "-" + gt[r[e + 4]] + gt[r[e + 5]] + "-" + gt[r[e + 6]] + gt[r[e + 7]] + "-" + gt[r[e + 8]] + gt[r[e + 9]] + "-" + gt[r[e + 10]] + gt[r[e + 11]] + gt[r[e + 12]] + gt[r[e + 13]] + gt[r[e + 14]] + gt[r[e + 15]]).toLowerCase();
}
const oi = new Uint8Array(256);
let Aa = oi.length;
function Uv() {
  return Aa > oi.length - 16 && (rn.randomFillSync(oi), Aa = 0), oi.slice(Aa, Aa += 16);
}
const Rd = {
  randomUUID: rn.randomUUID
};
function Lr(r, e, t) {
  if (Rd.randomUUID && !r)
    return Rd.randomUUID();
  r = r || {};
  const n = r.random || (r.rng || Uv)();
  return n[6] = n[6] & 15 | 64, n[8] = n[8] & 63 | 128, Fv(n);
}
var zv = {};
Ae(zv, {
  BaseCallbackHandler: () => la,
  callbackHandlerPrefersStreaming: () => ol,
  isBaseCallbackHandler: () => Mm
});
var Bv = class {
};
function ol(r) {
  return "lc_prefer_streaming" in r && r.lc_prefer_streaming;
}
var la = class extends Bv {
  constructor(e) {
    super();
    v(this, "lc_serializable", !1);
    v(this, "lc_kwargs");
    v(this, "ignoreLLM", !1);
    v(this, "ignoreChain", !1);
    v(this, "ignoreAgent", !1);
    v(this, "ignoreRetriever", !1);
    v(this, "ignoreCustomEvent", !1);
    v(this, "raiseError", !1);
    v(this, "awaitHandlers", Er("LANGCHAIN_CALLBACKS_BACKGROUND") === "false");
    this.lc_kwargs = e || {}, e && (this.ignoreLLM = e.ignoreLLM ?? this.ignoreLLM, this.ignoreChain = e.ignoreChain ?? this.ignoreChain, this.ignoreAgent = e.ignoreAgent ?? this.ignoreAgent, this.ignoreRetriever = e.ignoreRetriever ?? this.ignoreRetriever, this.ignoreCustomEvent = e.ignoreCustomEvent ?? this.ignoreCustomEvent, this.raiseError = e.raiseError ?? this.raiseError, this.awaitHandlers = this.raiseError || (e._awaitHandler ?? this.awaitHandlers));
  }
  get lc_namespace() {
    return [
      "langchain_core",
      "callbacks",
      this.name
    ];
  }
  get lc_secrets() {
  }
  get lc_attributes() {
  }
  get lc_aliases() {
  }
  get lc_serializable_keys() {
  }
  /**
  * The name of the serializable. Override to provide an alias or
  * to preserve the serialized module name in minified environments.
  *
  * Implemented as a static method to support loading logic.
  */
  static lc_name() {
    return this.name;
  }
  /**
  * The final serialized identifier for the module.
  */
  get lc_id() {
    return [...this.lc_namespace, Yu(this.constructor)];
  }
  copy() {
    return new this.constructor(this);
  }
  toJSON() {
    return Kn.prototype.toJSON.call(this);
  }
  toJSONNotImplemented() {
    return Kn.prototype.toJSONNotImplemented.call(this);
  }
  static fromMethods(e) {
    class t extends la {
      constructor() {
        super();
        v(this, "name", Lr());
        Object.assign(this, e);
      }
    }
    return new t();
  }
};
const Mm = (r) => {
  const e = r;
  return e !== void 0 && typeof e.copy == "function" && typeof e.name == "string" && typeof e.awaitHandlers == "boolean";
}, Zv = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i;
function Vv(r) {
  return typeof r == "string" && Zv.test(r);
}
function qv(r) {
  if (!Vv(r))
    throw TypeError("Invalid UUID");
  let e;
  const t = new Uint8Array(16);
  return t[0] = (e = parseInt(r.slice(0, 8), 16)) >>> 24, t[1] = e >>> 16 & 255, t[2] = e >>> 8 & 255, t[3] = e & 255, t[4] = (e = parseInt(r.slice(9, 13), 16)) >>> 8, t[5] = e & 255, t[6] = (e = parseInt(r.slice(14, 18), 16)) >>> 8, t[7] = e & 255, t[8] = (e = parseInt(r.slice(19, 23), 16)) >>> 8, t[9] = e & 255, t[10] = (e = parseInt(r.slice(24, 36), 16)) / 1099511627776 & 255, t[11] = e / 4294967296 & 255, t[12] = e >>> 24 & 255, t[13] = e >>> 16 & 255, t[14] = e >>> 8 & 255, t[15] = e & 255, t;
}
const _t = [];
for (let r = 0; r < 256; ++r)
  _t.push((r + 256).toString(16).slice(1));
function cl(r, e = 0) {
  return (_t[r[e + 0]] + _t[r[e + 1]] + _t[r[e + 2]] + _t[r[e + 3]] + "-" + _t[r[e + 4]] + _t[r[e + 5]] + "-" + _t[r[e + 6]] + _t[r[e + 7]] + "-" + _t[r[e + 8]] + _t[r[e + 9]] + "-" + _t[r[e + 10]] + _t[r[e + 11]] + _t[r[e + 12]] + _t[r[e + 13]] + _t[r[e + 14]] + _t[r[e + 15]]).toLowerCase();
}
const ci = new Uint8Array(256);
let $a = ci.length;
function Dm() {
  return $a > ci.length - 16 && (rn.randomFillSync(ci), $a = 0), ci.slice($a, $a += 16);
}
function Hv(r) {
  r = unescape(encodeURIComponent(r));
  const e = [];
  for (let t = 0; t < r.length; ++t)
    e.push(r.charCodeAt(t));
  return e;
}
const Jv = "6ba7b810-9dad-11d1-80b4-00c04fd430c8", Wv = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
function Gv(r, e, t) {
  function n(s, a, i, o) {
    var c;
    if (typeof s == "string" && (s = Hv(s)), typeof a == "string" && (a = qv(a)), ((c = a) === null || c === void 0 ? void 0 : c.length) !== 16)
      throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
    let u = new Uint8Array(16 + s.length);
    if (u.set(a), u.set(s, a.length), u = t(u), u[6] = u[6] & 15 | e, u[8] = u[8] & 63 | 128, i) {
      o = o || 0;
      for (let l = 0; l < 16; ++l)
        i[o + l] = u[l];
      return i;
    }
    return cl(u);
  }
  try {
    n.name = r;
  } catch {
  }
  return n.DNS = Jv, n.URL = Wv, n;
}
const Nd = {
  randomUUID: rn.randomUUID
};
function fs(r, e, t) {
  if (Nd.randomUUID && !r)
    return Nd.randomUUID();
  r = r || {};
  const n = r.random || (r.rng || Dm)();
  return n[6] = n[6] & 15 | 64, n[8] = n[8] & 63 | 128, cl(n);
}
function Kv(r) {
  return Array.isArray(r) ? r = Buffer.from(r) : typeof r == "string" && (r = Buffer.from(r, "utf8")), rn.createHash("sha1").update(r).digest();
}
const Es = Gv("v5", 80, Kv);
let Pd = null, Ld = null, Xt = 0;
function Yv(r, e, t) {
  r = r || {};
  let n = 0;
  const s = new Uint8Array(16), a = r.random || (r.rng || Dm)(), i = r.msecs !== void 0 ? r.msecs : Date.now();
  let o = r.seq !== void 0 ? r.seq : null, c = Ld, u = Pd;
  return i > Xt && r.msecs === void 0 && (Xt = i, o !== null && (c = null, u = null)), o !== null && (o > 2147483647 && (o = 2147483647), c = o >>> 19 & 4095, u = o & 524287), (c === null || u === null) && (c = a[6] & 127, c = c << 8 | a[7], u = a[8] & 63, u = u << 8 | a[9], u = u << 5 | a[10] >>> 3), i + 1e4 > Xt && o === null ? ++u > 524287 && (u = 0, ++c > 4095 && (c = 0, Xt++)) : Xt = i, Ld = c, Pd = u, s[n++] = Xt / 1099511627776 & 255, s[n++] = Xt / 4294967296 & 255, s[n++] = Xt / 16777216 & 255, s[n++] = Xt / 65536 & 255, s[n++] = Xt / 256 & 255, s[n++] = Xt & 255, s[n++] = c >>> 4 & 15 | 112, s[n++] = c & 255, s[n++] = u >>> 13 & 63 | 128, s[n++] = u >>> 5 & 255, s[n++] = u << 3 & 255 | a[10] & 7, s[n++] = a[11], s[n++] = a[12], s[n++] = a[13], s[n++] = a[14], s[n++] = a[15], e || cl(s);
}
const Xv = "gen_ai.operation.name", Qv = "gen_ai.system", Md = "gen_ai.request.model", eb = "gen_ai.response.model", Dd = "gen_ai.usage.input_tokens", jd = "gen_ai.usage.output_tokens", Fd = "gen_ai.usage.total_tokens", tb = "gen_ai.request.max_tokens", rb = "gen_ai.request.temperature", nb = "gen_ai.request.top_p", sb = "gen_ai.request.frequency_penalty", ab = "gen_ai.request.presence_penalty", ib = "gen_ai.response.finish_reasons", ob = "gen_ai.prompt", cb = "gen_ai.completion", ub = "gen_ai.request.extra_query", lb = "gen_ai.request.extra_body", db = "gen_ai.serialized.name", hb = "gen_ai.serialized.signature", fb = "gen_ai.serialized.doc", pb = "gen_ai.response.id", mb = "gen_ai.response.service_tier", gb = "gen_ai.response.system_fingerprint", _b = "gen_ai.usage.input_token_details", yb = "gen_ai.usage.output_token_details", wb = "langsmith.trace.session_id", vb = "langsmith.trace.session_name", bb = "langsmith.span.kind", Sb = "langsmith.trace.name", Tb = "langsmith.metadata", Ud = "langsmith.span.tags", Eb = "langsmith.request.streaming", xb = "langsmith.request.headers", Ib = (...r) => fetch(...r), jm = Symbol.for("ls:fetch_implementation"), kb = () => {
  const r = globalThis[jm];
  return r ? typeof r == "function" && "Headers" in r && "Request" in r && "Response" in r : !1;
}, Ob = (r) => async (...e) => {
  if (r || Nt("DEBUG") === "true") {
    const [n, s] = e;
    console.log(`â†’ ${(s == null ? void 0 : s.method) || "GET"} ${n}`);
  }
  const t = await (globalThis[jm] ?? Ib)(...e);
  return (r || Nt("DEBUG") === "true") && console.log(`â† ${t.status} ${t.statusText} ${t.url}`), t;
}, Fm = () => Nt("PROJECT") ?? Or("LANGCHAIN_SESSION") ?? // TODO: Deprecate
"default", zd = {};
function Mc(r) {
  zd[r] || (console.warn(r), zd[r] = !0);
}
const Ab = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
function ye(r, e) {
  if (!Ab.test(r)) {
    const t = e !== void 0 ? `Invalid UUID for ${e}: ${r}` : `Invalid UUID: ${r}`;
    throw new Error(t);
  }
  return r;
}
function $b(r) {
  const e = typeof r == "string" ? Date.parse(r) : r;
  return Yv({ msecs: e, seq: 0 });
}
const Um = "0.3.84";
let mr;
const Cb = () => typeof window < "u" && typeof window.document < "u", Rb = () => typeof globalThis == "object" && globalThis.constructor && globalThis.constructor.name === "DedicatedWorkerGlobalScope", Nb = () => typeof window < "u" && window.name === "nodejs" || typeof navigator < "u" && navigator.userAgent.includes("jsdom"), zm = () => typeof Deno < "u", Pb = () => typeof process < "u" && typeof process.versions < "u" && typeof process.versions.node < "u" && !zm(), Bm = () => mr || (typeof Bun < "u" ? mr = "bun" : Cb() ? mr = "browser" : Pb() ? mr = "node" : Rb() ? mr = "webworker" : Nb() ? mr = "jsdom" : zm() ? mr = "deno" : mr = "other", mr);
let Wo;
function Zm() {
  if (Wo === void 0) {
    const r = Bm(), e = Mb();
    Wo = {
      library: "langsmith",
      runtime: r,
      sdk: "langsmith-js",
      sdk_version: Um,
      ...e
    };
  }
  return Wo;
}
function Vm() {
  const r = Lb(), e = {}, t = [
    "LANGCHAIN_API_KEY",
    "LANGCHAIN_ENDPOINT",
    "LANGCHAIN_TRACING_V2",
    "LANGCHAIN_PROJECT",
    "LANGCHAIN_SESSION",
    "LANGSMITH_API_KEY",
    "LANGSMITH_ENDPOINT",
    "LANGSMITH_TRACING_V2",
    "LANGSMITH_PROJECT",
    "LANGSMITH_SESSION"
  ];
  for (const [n, s] of Object.entries(r))
    typeof s == "string" && !t.includes(n) && !n.toLowerCase().includes("key") && !n.toLowerCase().includes("secret") && !n.toLowerCase().includes("token") && (n === "LANGCHAIN_REVISION_ID" ? e.revision_id = s : e[n] = s);
  return e;
}
function Lb() {
  const r = {};
  try {
    if (typeof process < "u" && process.env)
      for (const [e, t] of Object.entries(process.env))
        (e.startsWith("LANGCHAIN_") || e.startsWith("LANGSMITH_")) && t != null && ((e.toLowerCase().includes("key") || e.toLowerCase().includes("secret") || e.toLowerCase().includes("token")) && typeof t == "string" ? r[e] = t.slice(0, 2) + "*".repeat(t.length - 4) + t.slice(-2) : r[e] = t);
  } catch {
  }
  return r;
}
function Or(r) {
  var e;
  try {
    return typeof process < "u" ? (
      // eslint-disable-next-line no-process-env
      (e = process.env) == null ? void 0 : e[r]
    ) : void 0;
  } catch {
    return;
  }
}
function Nt(r) {
  return Or(`LANGSMITH_${r}`) || Or(`LANGCHAIN_${r}`);
}
let Go;
function Mb() {
  if (Go !== void 0)
    return Go;
  const r = [
    "VERCEL_GIT_COMMIT_SHA",
    "NEXT_PUBLIC_VERCEL_GIT_COMMIT_SHA",
    "COMMIT_REF",
    "RENDER_GIT_COMMIT",
    "CI_COMMIT_SHA",
    "CIRCLE_SHA1",
    "CF_PAGES_COMMIT_SHA",
    "REACT_APP_GIT_SHA",
    "SOURCE_VERSION",
    "GITHUB_SHA",
    "TRAVIS_COMMIT",
    "GIT_COMMIT",
    "BUILD_VCS_NUMBER",
    "bamboo_planRepository_revision",
    "Build.SourceVersion",
    "BITBUCKET_COMMIT",
    "DRONE_COMMIT_SHA",
    "SEMAPHORE_GIT_SHA",
    "BUILDKITE_COMMIT"
  ], e = {};
  for (const t of r) {
    const n = Or(t);
    n !== void 0 && (e[t] = n);
  }
  return Go = e, e;
}
function qm() {
  return Or("OTEL_ENABLED") === "true" || Nt("OTEL_ENABLED") === "true";
}
class Db {
  constructor() {
    Object.defineProperty(this, "hasWarned", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    });
  }
  startActiveSpan(e, ...t) {
    !this.hasWarned && qm() && (console.warn('You have enabled OTEL export via the `OTEL_ENABLED` or `LANGSMITH_OTEL_ENABLED` environment variable, but have not initialized the required OTEL instances. Please add:\n```\nimport { initializeOTEL } from "langsmith/experimental/otel/setup";\ninitializeOTEL();\n```\nat the beginning of your code.'), this.hasWarned = !0);
    let n;
    if (t.length === 1 && typeof t[0] == "function" ? n = t[0] : t.length === 2 && typeof t[1] == "function" ? n = t[1] : t.length === 3 && typeof t[2] == "function" && (n = t[2]), typeof n == "function")
      return n();
  }
}
class jb {
  constructor() {
    Object.defineProperty(this, "mockTracer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new Db()
    });
  }
  getTracer(e, t) {
    return this.mockTracer;
  }
  getActiveSpan() {
  }
  setSpan(e, t) {
    return e;
  }
  getSpan(e) {
  }
  setSpanContext(e, t) {
    return e;
  }
  getTracerProvider() {
  }
  setGlobalTracerProvider(e) {
    return !1;
  }
}
class Fb {
  active() {
    return {};
  }
  with(e, t) {
    return t();
  }
}
const Ko = Symbol.for("ls:otel_trace"), Yo = Symbol.for("ls:otel_context"), Bd = Symbol.for("ls:otel_get_default_otlp_tracer_provider"), Ub = new jb(), zb = new Fb();
class Bb {
  getTraceInstance() {
    return globalThis[Ko] ?? Ub;
  }
  getContextInstance() {
    return globalThis[Yo] ?? zb;
  }
  initializeGlobalInstances(e) {
    globalThis[Ko] === void 0 && (globalThis[Ko] = e.trace), globalThis[Yo] === void 0 && (globalThis[Yo] = e.context);
  }
  setDefaultOTLPTracerComponents(e) {
    globalThis[Bd] = e;
  }
  getDefaultOTLPTracerComponents() {
    return globalThis[Bd] ?? void 0;
  }
}
const ul = new Bb();
function Hm() {
  return ul.getTraceInstance();
}
function Zb() {
  return ul.getContextInstance();
}
function Vb() {
  return ul.getDefaultOTLPTracerComponents();
}
const qb = {
  llm: "chat",
  tool: "execute_tool",
  retriever: "embeddings",
  embedding: "embeddings",
  prompt: "chat"
};
function Hb(r) {
  return qb[r] || r;
}
class Jb {
  constructor() {
    Object.defineProperty(this, "spans", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: /* @__PURE__ */ new Map()
    });
  }
  exportBatch(e, t) {
    for (const n of e)
      try {
        if (!n.run)
          continue;
        if (n.operation === "post") {
          const s = this.createSpanForRun(n, n.run, t.get(n.id));
          s && !n.run.end_time && this.spans.set(n.id, s);
        } else
          this.updateSpanForRun(n, n.run);
      } catch (s) {
        console.error(`Error processing operation ${n.id}:`, s);
      }
  }
  createSpanForRun(e, t, n) {
    const s = n && Hm().getSpan(n);
    if (s)
      try {
        return this.finishSpanSetup(s, t, e);
      } catch (a) {
        console.error(`Failed to create span for run ${e.id}:`, a);
        return;
      }
  }
  finishSpanSetup(e, t, n) {
    return this.setSpanAttributes(e, t, n), t.error ? (e.setStatus({ code: 2 }), e.recordException(new Error(t.error))) : e.setStatus({ code: 1 }), t.end_time && e.end(new Date(t.end_time)), e;
  }
  updateSpanForRun(e, t) {
    try {
      const n = this.spans.get(e.id);
      if (!n) {
        console.debug(`No span found for run ${e.id} during update`);
        return;
      }
      this.setSpanAttributes(n, t, e), t.error ? (n.setStatus({ code: 2 }), n.recordException(new Error(t.error))) : n.setStatus({ code: 1 });
      const s = t.end_time;
      s && (n.end(new Date(s)), this.spans.delete(e.id));
    } catch (n) {
      console.error(`Failed to update span for run ${e.id}:`, n);
    }
  }
  extractModelName(e) {
    var t;
    if ((t = e.extra) != null && t.metadata) {
      const n = e.extra.metadata;
      if (n.ls_model_name)
        return n.ls_model_name;
      if (n.invocation_params) {
        const s = n.invocation_params;
        if (s.model)
          return s.model;
        if (s.model_name)
          return s.model_name;
      }
    }
  }
  setSpanAttributes(e, t, n) {
    var o;
    if ("run_type" in t && t.run_type) {
      e.setAttribute(bb, t.run_type);
      const c = Hb(t.run_type || "chain");
      e.setAttribute(Xv, c);
    }
    "name" in t && t.name && e.setAttribute(Sb, t.name), "session_id" in t && t.session_id && e.setAttribute(wb, t.session_id), "session_name" in t && t.session_name && e.setAttribute(vb, t.session_name), this.setGenAiSystem(e, t);
    const s = this.extractModelName(t);
    s && e.setAttribute(Md, s), "prompt_tokens" in t && typeof t.prompt_tokens == "number" && e.setAttribute(Dd, t.prompt_tokens), "completion_tokens" in t && typeof t.completion_tokens == "number" && e.setAttribute(jd, t.completion_tokens), "total_tokens" in t && typeof t.total_tokens == "number" && e.setAttribute(Fd, t.total_tokens), this.setInvocationParameters(e, t);
    const a = ((o = t.extra) == null ? void 0 : o.metadata) || {};
    for (const [c, u] of Object.entries(a))
      u != null && e.setAttribute(`${Tb}.${c}`, String(u));
    const i = t.tags;
    if (i && Array.isArray(i) ? e.setAttribute(Ud, i.join(", ")) : i && e.setAttribute(Ud, String(i)), "serialized" in t && typeof t.serialized == "object") {
      const c = t.serialized;
      c.name && e.setAttribute(db, String(c.name)), c.signature && e.setAttribute(hb, String(c.signature)), c.doc && e.setAttribute(fb, String(c.doc));
    }
    this.setIOAttributes(e, n);
  }
  setGenAiSystem(e, t) {
    let n = "langchain";
    const s = this.extractModelName(t);
    if (s) {
      const a = s.toLowerCase();
      a.includes("anthropic") || a.startsWith("claude") ? n = "anthropic" : a.includes("bedrock") ? n = "aws.bedrock" : a.includes("azure") && a.includes("openai") ? n = "az.ai.openai" : a.includes("azure") && a.includes("inference") ? n = "az.ai.inference" : a.includes("cohere") ? n = "cohere" : a.includes("deepseek") ? n = "deepseek" : a.includes("gemini") ? n = "gemini" : a.includes("groq") ? n = "groq" : a.includes("watson") || a.includes("ibm") ? n = "ibm.watsonx.ai" : a.includes("mistral") ? n = "mistral_ai" : a.includes("gpt") || a.includes("openai") ? n = "openai" : a.includes("perplexity") || a.includes("sonar") ? n = "perplexity" : a.includes("vertex") ? n = "vertex_ai" : (a.includes("xai") || a.includes("grok")) && (n = "xai");
    }
    e.setAttribute(Qv, n);
  }
  setInvocationParameters(e, t) {
    var s, a;
    if (!((a = (s = t.extra) == null ? void 0 : s.metadata) != null && a.invocation_params))
      return;
    const n = t.extra.metadata.invocation_params;
    n.max_tokens !== void 0 && e.setAttribute(tb, n.max_tokens), n.temperature !== void 0 && e.setAttribute(rb, n.temperature), n.top_p !== void 0 && e.setAttribute(nb, n.top_p), n.frequency_penalty !== void 0 && e.setAttribute(sb, n.frequency_penalty), n.presence_penalty !== void 0 && e.setAttribute(ab, n.presence_penalty);
  }
  setIOAttributes(e, t) {
    if (t.run.inputs)
      try {
        const n = t.run.inputs;
        typeof n == "object" && n !== null && (n.model && Array.isArray(n.messages) && e.setAttribute(Md, n.model), n.stream !== void 0 && e.setAttribute(Eb, n.stream), n.extra_headers && e.setAttribute(xb, JSON.stringify(n.extra_headers)), n.extra_query && e.setAttribute(ub, JSON.stringify(n.extra_query)), n.extra_body && e.setAttribute(lb, JSON.stringify(n.extra_body))), e.setAttribute(ob, JSON.stringify(n));
      } catch (n) {
        console.debug(`Failed to process inputs for run ${t.id}`, n);
      }
    if (t.run.outputs)
      try {
        const n = t.run.outputs, s = this.getUnifiedRunTokens(n);
        if (s && (e.setAttribute(Dd, s[0]), e.setAttribute(jd, s[1]), e.setAttribute(Fd, s[0] + s[1])), n && typeof n == "object") {
          if (n.model && e.setAttribute(eb, String(n.model)), n.id && e.setAttribute(pb, n.id), n.choices && Array.isArray(n.choices)) {
            const a = n.choices.map((i) => i.finish_reason).filter((i) => i).map(String);
            a.length > 0 && e.setAttribute(ib, a.join(", "));
          }
          if (n.service_tier && e.setAttribute(mb, n.service_tier), n.system_fingerprint && e.setAttribute(gb, n.system_fingerprint), n.usage_metadata && typeof n.usage_metadata == "object") {
            const a = n.usage_metadata;
            a.input_token_details && e.setAttribute(_b, JSON.stringify(a.input_token_details)), a.output_token_details && e.setAttribute(yb, JSON.stringify(a.output_token_details));
          }
        }
        e.setAttribute(cb, JSON.stringify(n));
      } catch (n) {
        console.debug(`Failed to process outputs for run ${t.id}`, n);
      }
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  getUnifiedRunTokens(e) {
    if (!e)
      return null;
    let t = this.extractUnifiedRunTokens(e.usage_metadata);
    if (t)
      return t;
    const n = Object.keys(e);
    for (const i of n) {
      const o = e[i];
      if (!(!o || typeof o != "object") && (t = this.extractUnifiedRunTokens(o.usage_metadata), t || o.lc === 1 && o.kwargs && typeof o.kwargs == "object" && (t = this.extractUnifiedRunTokens(o.kwargs.usage_metadata), t)))
        return t;
    }
    const s = e.generations || [];
    if (!Array.isArray(s))
      return null;
    const a = Array.isArray(s[0]) ? s.flat() : s;
    for (const i of a)
      if (typeof i == "object" && i.message && typeof i.message == "object" && i.message.kwargs && typeof i.message.kwargs == "object" && (t = this.extractUnifiedRunTokens(i.message.kwargs.usage_metadata), t))
        return t;
    return null;
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  extractUnifiedRunTokens(e) {
    return !e || typeof e != "object" || typeof e.input_tokens != "number" || typeof e.output_tokens != "number" ? null : [e.input_tokens, e.output_tokens];
  }
}
const Wb = Object.prototype.toString, Gb = (r) => Wb.call(r) === "[object Error]", Kb = /* @__PURE__ */ new Set([
  "network error",
  // Chrome
  "Failed to fetch",
  // Chrome
  "NetworkError when attempting to fetch resource.",
  // Firefox
  "The Internet connection appears to be offline.",
  // Safari 16
  "Network request failed",
  // `cross-fetch`
  "fetch failed",
  // Undici (Node.js)
  "terminated",
  // Undici (Node.js)
  " A network error occurred.",
  // Bun (WebKit)
  "Network connection lost"
  // Cloudflare Workers (fetch)
]);
function Yb(r) {
  if (!(r && Gb(r) && r.name === "TypeError" && typeof r.message == "string"))
    return !1;
  const { message: t, stack: n } = r;
  return t === "Load failed" ? n === void 0 || // Sentry adds its own stack trace to the fetch error, so also check for that
  "__sentry_captured__" in r : t.startsWith("error sending request for url") ? !0 : Kb.has(t);
}
function Xb(r) {
  if (typeof r == "number") {
    if (r < 0)
      throw new TypeError("Expected `retries` to be a non-negative number.");
    if (Number.isNaN(r))
      throw new TypeError("Expected `retries` to be a valid number or Infinity, got NaN.");
  } else if (r !== void 0)
    throw new TypeError("Expected `retries` to be a number or Infinity.");
}
function Ca(r, e, { min: t = 0, allowInfinity: n = !1 } = {}) {
  if (e !== void 0) {
    if (typeof e != "number" || Number.isNaN(e))
      throw new TypeError(`Expected \`${r}\` to be a number${n ? " or Infinity" : ""}.`);
    if (!n && !Number.isFinite(e))
      throw new TypeError(`Expected \`${r}\` to be a finite number.`);
    if (e < t)
      throw new TypeError(`Expected \`${r}\` to be â‰¥ ${t}.`);
  }
}
let Qb = class extends Error {
  constructor(e) {
    super(), e instanceof Error ? (this.originalError = e, { message: e } = e) : (this.originalError = new Error(e), this.originalError.stack = this.stack), this.name = "AbortError", this.message = e;
  }
};
function e0(r, e) {
  const t = Math.max(1, r + 1), n = e.randomize ? Math.random() + 1 : 1;
  let s = Math.round(n * e.minTimeout * e.factor ** (t - 1));
  return s = Math.min(s, e.maxTimeout), s;
}
function Zd(r, e) {
  return Number.isFinite(e) ? e - (performance.now() - r) : e;
}
async function t0({ error: r, attemptNumber: e, retriesConsumed: t, startTime: n, options: s }) {
  var f, p, y;
  const a = r instanceof Error ? r : new TypeError(`Non-error was thrown: "${r}". You should only throw errors.`);
  if (a instanceof Qb)
    throw a.originalError;
  const i = Number.isFinite(s.retries) ? Math.max(0, s.retries - t) : s.retries, o = s.maxRetryTime ?? Number.POSITIVE_INFINITY, c = Object.freeze({
    error: a,
    attemptNumber: e,
    retriesLeft: i,
    retriesConsumed: t
  });
  if (await s.onFailedAttempt(c), Zd(n, o) <= 0)
    throw a;
  const u = await s.shouldConsumeRetry(c), l = Zd(n, o);
  if (l <= 0 || i <= 0)
    throw a;
  if (a instanceof TypeError && !Yb(a)) {
    if (u)
      throw a;
    return (f = s.signal) == null || f.throwIfAborted(), !1;
  }
  if (!await s.shouldRetry(c))
    throw a;
  if (!u)
    return (p = s.signal) == null || p.throwIfAborted(), !1;
  const d = e0(t, s), h = Math.min(d, l);
  return h > 0 && await new Promise((g, S) => {
    var T, x;
    const _ = () => {
      var A;
      clearTimeout(w), (A = s.signal) == null || A.removeEventListener("abort", _), S(s.signal.reason);
    }, w = setTimeout(() => {
      var A;
      (A = s.signal) == null || A.removeEventListener("abort", _), g();
    }, h);
    s.unref && ((T = w.unref) == null || T.call(w)), (x = s.signal) == null || x.addEventListener("abort", _, { once: !0 });
  }), (y = s.signal) == null || y.throwIfAborted(), !0;
}
async function r0(r, e = {}) {
  var a, i, o;
  if (e = { ...e }, Xb(e.retries), Object.hasOwn(e, "forever"))
    throw new Error("The `forever` option is no longer supported. For many use-cases, you can set `retries: Infinity` instead.");
  e.retries ?? (e.retries = 10), e.factor ?? (e.factor = 2), e.minTimeout ?? (e.minTimeout = 1e3), e.maxTimeout ?? (e.maxTimeout = Number.POSITIVE_INFINITY), e.maxRetryTime ?? (e.maxRetryTime = Number.POSITIVE_INFINITY), e.randomize ?? (e.randomize = !1), e.onFailedAttempt ?? (e.onFailedAttempt = () => {
  }), e.shouldRetry ?? (e.shouldRetry = () => !0), e.shouldConsumeRetry ?? (e.shouldConsumeRetry = () => !0), Ca("factor", e.factor, {
    min: 0,
    allowInfinity: !1
  }), Ca("minTimeout", e.minTimeout, {
    min: 0,
    allowInfinity: !1
  }), Ca("maxTimeout", e.maxTimeout, {
    min: 0,
    allowInfinity: !0
  }), Ca("maxRetryTime", e.maxRetryTime, {
    min: 0,
    allowInfinity: !0
  }), e.factor > 0 || (e.factor = 1), (a = e.signal) == null || a.throwIfAborted();
  let t = 0, n = 0;
  const s = performance.now();
  for (; !Number.isFinite(e.retries) || n <= e.retries; ) {
    t++;
    try {
      (i = e.signal) == null || i.throwIfAborted();
      const c = await r(t);
      return (o = e.signal) == null || o.throwIfAborted(), c;
    } catch (c) {
      await t0({
        error: c,
        attemptNumber: t,
        retriesConsumed: n,
        startTime: s,
        options: e
      }) && n++;
    }
  }
  throw new Error("Retry attempts exhausted without throwing an error.");
}
var Jm = {}, Wm = { exports: {} };
(function(r) {
  var e = Object.prototype.hasOwnProperty, t = "~";
  function n() {
  }
  Object.create && (n.prototype = /* @__PURE__ */ Object.create(null), new n().__proto__ || (t = !1));
  function s(c, u, l) {
    this.fn = c, this.context = u, this.once = l || !1;
  }
  function a(c, u, l, d, h) {
    if (typeof l != "function")
      throw new TypeError("The listener must be a function");
    var f = new s(l, d || c, h), p = t ? t + u : u;
    return c._events[p] ? c._events[p].fn ? c._events[p] = [c._events[p], f] : c._events[p].push(f) : (c._events[p] = f, c._eventsCount++), c;
  }
  function i(c, u) {
    --c._eventsCount === 0 ? c._events = new n() : delete c._events[u];
  }
  function o() {
    this._events = new n(), this._eventsCount = 0;
  }
  o.prototype.eventNames = function() {
    var u = [], l, d;
    if (this._eventsCount === 0) return u;
    for (d in l = this._events)
      e.call(l, d) && u.push(t ? d.slice(1) : d);
    return Object.getOwnPropertySymbols ? u.concat(Object.getOwnPropertySymbols(l)) : u;
  }, o.prototype.listeners = function(u) {
    var l = t ? t + u : u, d = this._events[l];
    if (!d) return [];
    if (d.fn) return [d.fn];
    for (var h = 0, f = d.length, p = new Array(f); h < f; h++)
      p[h] = d[h].fn;
    return p;
  }, o.prototype.listenerCount = function(u) {
    var l = t ? t + u : u, d = this._events[l];
    return d ? d.fn ? 1 : d.length : 0;
  }, o.prototype.emit = function(u, l, d, h, f, p) {
    var y = t ? t + u : u;
    if (!this._events[y]) return !1;
    var g = this._events[y], S = arguments.length, _, w;
    if (g.fn) {
      switch (g.once && this.removeListener(u, g.fn, void 0, !0), S) {
        case 1:
          return g.fn.call(g.context), !0;
        case 2:
          return g.fn.call(g.context, l), !0;
        case 3:
          return g.fn.call(g.context, l, d), !0;
        case 4:
          return g.fn.call(g.context, l, d, h), !0;
        case 5:
          return g.fn.call(g.context, l, d, h, f), !0;
        case 6:
          return g.fn.call(g.context, l, d, h, f, p), !0;
      }
      for (w = 1, _ = new Array(S - 1); w < S; w++)
        _[w - 1] = arguments[w];
      g.fn.apply(g.context, _);
    } else {
      var T = g.length, x;
      for (w = 0; w < T; w++)
        switch (g[w].once && this.removeListener(u, g[w].fn, void 0, !0), S) {
          case 1:
            g[w].fn.call(g[w].context);
            break;
          case 2:
            g[w].fn.call(g[w].context, l);
            break;
          case 3:
            g[w].fn.call(g[w].context, l, d);
            break;
          case 4:
            g[w].fn.call(g[w].context, l, d, h);
            break;
          default:
            if (!_) for (x = 1, _ = new Array(S - 1); x < S; x++)
              _[x - 1] = arguments[x];
            g[w].fn.apply(g[w].context, _);
        }
    }
    return !0;
  }, o.prototype.on = function(u, l, d) {
    return a(this, u, l, d, !1);
  }, o.prototype.once = function(u, l, d) {
    return a(this, u, l, d, !0);
  }, o.prototype.removeListener = function(u, l, d, h) {
    var f = t ? t + u : u;
    if (!this._events[f]) return this;
    if (!l)
      return i(this, f), this;
    var p = this._events[f];
    if (p.fn)
      p.fn === l && (!h || p.once) && (!d || p.context === d) && i(this, f);
    else {
      for (var y = 0, g = [], S = p.length; y < S; y++)
        (p[y].fn !== l || h && !p[y].once || d && p[y].context !== d) && g.push(p[y]);
      g.length ? this._events[f] = g.length === 1 ? g[0] : g : i(this, f);
    }
    return this;
  }, o.prototype.removeAllListeners = function(u) {
    var l;
    return u ? (l = t ? t + u : u, this._events[l] && i(this, l)) : (this._events = new n(), this._eventsCount = 0), this;
  }, o.prototype.off = o.prototype.removeListener, o.prototype.addListener = o.prototype.on, o.prefixed = t, o.EventEmitter = o, r.exports = o;
})(Wm);
var n0 = Wm.exports, uo = { exports: {} }, s0 = (r, e) => (e = e || (() => {
}), r.then(
  (t) => new Promise((n) => {
    n(e());
  }).then(() => t),
  (t) => new Promise((n) => {
    n(e());
  }).then(() => {
    throw t;
  })
));
const a0 = s0;
class Gm extends Error {
  constructor(e) {
    super(e), this.name = "TimeoutError";
  }
}
const Km = (r, e, t) => new Promise((n, s) => {
  if (typeof e != "number" || e < 0)
    throw new TypeError("Expected `milliseconds` to be a positive number");
  if (e === 1 / 0) {
    n(r);
    return;
  }
  const a = setTimeout(() => {
    if (typeof t == "function") {
      try {
        n(t());
      } catch (c) {
        s(c);
      }
      return;
    }
    const i = typeof t == "string" ? t : `Promise timed out after ${e} milliseconds`, o = t instanceof Error ? t : new Gm(i);
    typeof r.cancel == "function" && r.cancel(), s(o);
  }, e);
  a0(
    // eslint-disable-next-line promise/prefer-await-to-then
    r.then(n, s),
    () => {
      clearTimeout(a);
    }
  );
});
uo.exports = Km;
uo.exports.default = Km;
uo.exports.TimeoutError = Gm;
var i0 = uo.exports, ll = {}, dl = {};
Object.defineProperty(dl, "__esModule", { value: !0 });
function o0(r, e, t) {
  let n = 0, s = r.length;
  for (; s > 0; ) {
    const a = s / 2 | 0;
    let i = n + a;
    t(r[i], e) <= 0 ? (n = ++i, s -= a + 1) : s = a;
  }
  return n;
}
dl.default = o0;
Object.defineProperty(ll, "__esModule", { value: !0 });
const c0 = dl;
class u0 {
  constructor() {
    this._queue = [];
  }
  enqueue(e, t) {
    t = Object.assign({ priority: 0 }, t);
    const n = {
      priority: t.priority,
      run: e
    };
    if (this.size && this._queue[this.size - 1].priority >= t.priority) {
      this._queue.push(n);
      return;
    }
    const s = c0.default(this._queue, n, (a, i) => i.priority - a.priority);
    this._queue.splice(s, 0, n);
  }
  dequeue() {
    const e = this._queue.shift();
    return e == null ? void 0 : e.run;
  }
  filter(e) {
    return this._queue.filter((t) => t.priority === e.priority).map((t) => t.run);
  }
  get size() {
    return this._queue.length;
  }
}
ll.default = u0;
Object.defineProperty(Jm, "__esModule", { value: !0 });
const l0 = n0, Ym = i0, d0 = ll, Ra = () => {
}, h0 = new Ym.TimeoutError();
class f0 extends l0 {
  constructor(e) {
    var t, n, s, a;
    if (super(), this._intervalCount = 0, this._intervalEnd = 0, this._pendingCount = 0, this._resolveEmpty = Ra, this._resolveIdle = Ra, e = Object.assign({ carryoverConcurrencyCount: !1, intervalCap: 1 / 0, interval: 0, concurrency: 1 / 0, autoStart: !0, queueClass: d0.default }, e), !(typeof e.intervalCap == "number" && e.intervalCap >= 1))
      throw new TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${(n = (t = e.intervalCap) === null || t === void 0 ? void 0 : t.toString()) !== null && n !== void 0 ? n : ""}\` (${typeof e.intervalCap})`);
    if (e.interval === void 0 || !(Number.isFinite(e.interval) && e.interval >= 0))
      throw new TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${(a = (s = e.interval) === null || s === void 0 ? void 0 : s.toString()) !== null && a !== void 0 ? a : ""}\` (${typeof e.interval})`);
    this._carryoverConcurrencyCount = e.carryoverConcurrencyCount, this._isIntervalIgnored = e.intervalCap === 1 / 0 || e.interval === 0, this._intervalCap = e.intervalCap, this._interval = e.interval, this._queue = new e.queueClass(), this._queueClass = e.queueClass, this.concurrency = e.concurrency, this._timeout = e.timeout, this._throwOnTimeout = e.throwOnTimeout === !0, this._isPaused = e.autoStart === !1;
  }
  get _doesIntervalAllowAnother() {
    return this._isIntervalIgnored || this._intervalCount < this._intervalCap;
  }
  get _doesConcurrentAllowAnother() {
    return this._pendingCount < this._concurrency;
  }
  _next() {
    this._pendingCount--, this._tryToStartAnother(), this.emit("next");
  }
  _resolvePromises() {
    this._resolveEmpty(), this._resolveEmpty = Ra, this._pendingCount === 0 && (this._resolveIdle(), this._resolveIdle = Ra, this.emit("idle"));
  }
  _onResumeInterval() {
    this._onInterval(), this._initializeIntervalIfNeeded(), this._timeoutId = void 0;
  }
  _isIntervalPaused() {
    const e = Date.now();
    if (this._intervalId === void 0) {
      const t = this._intervalEnd - e;
      if (t < 0)
        this._intervalCount = this._carryoverConcurrencyCount ? this._pendingCount : 0;
      else
        return this._timeoutId === void 0 && (this._timeoutId = setTimeout(() => {
          this._onResumeInterval();
        }, t)), !0;
    }
    return !1;
  }
  _tryToStartAnother() {
    if (this._queue.size === 0)
      return this._intervalId && clearInterval(this._intervalId), this._intervalId = void 0, this._resolvePromises(), !1;
    if (!this._isPaused) {
      const e = !this._isIntervalPaused();
      if (this._doesIntervalAllowAnother && this._doesConcurrentAllowAnother) {
        const t = this._queue.dequeue();
        return t ? (this.emit("active"), t(), e && this._initializeIntervalIfNeeded(), !0) : !1;
      }
    }
    return !1;
  }
  _initializeIntervalIfNeeded() {
    this._isIntervalIgnored || this._intervalId !== void 0 || (this._intervalId = setInterval(() => {
      this._onInterval();
    }, this._interval), this._intervalEnd = Date.now() + this._interval);
  }
  _onInterval() {
    this._intervalCount === 0 && this._pendingCount === 0 && this._intervalId && (clearInterval(this._intervalId), this._intervalId = void 0), this._intervalCount = this._carryoverConcurrencyCount ? this._pendingCount : 0, this._processQueue();
  }
  /**
  Executes all queued functions until it reaches the limit.
  */
  _processQueue() {
    for (; this._tryToStartAnother(); )
      ;
  }
  get concurrency() {
    return this._concurrency;
  }
  set concurrency(e) {
    if (!(typeof e == "number" && e >= 1))
      throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${e}\` (${typeof e})`);
    this._concurrency = e, this._processQueue();
  }
  /**
  Adds a sync or async task to the queue. Always returns a promise.
  */
  async add(e, t = {}) {
    return new Promise((n, s) => {
      const a = async () => {
        this._pendingCount++, this._intervalCount++;
        try {
          const i = this._timeout === void 0 && t.timeout === void 0 ? e() : Ym.default(Promise.resolve(e()), t.timeout === void 0 ? this._timeout : t.timeout, () => {
            (t.throwOnTimeout === void 0 ? this._throwOnTimeout : t.throwOnTimeout) && s(h0);
          });
          n(await i);
        } catch (i) {
          s(i);
        }
        this._next();
      };
      this._queue.enqueue(a, t), this._tryToStartAnother(), this.emit("add");
    });
  }
  /**
      Same as `.add()`, but accepts an array of sync or async functions.
  
      @returns A promise that resolves when all functions are resolved.
      */
  async addAll(e, t) {
    return Promise.all(e.map(async (n) => this.add(n, t)));
  }
  /**
  Start (or resume) executing enqueued tasks within concurrency limit. No need to call this if queue is not paused (via `options.autoStart = false` or by `.pause()` method.)
  */
  start() {
    return this._isPaused ? (this._isPaused = !1, this._processQueue(), this) : this;
  }
  /**
  Put queue execution on hold.
  */
  pause() {
    this._isPaused = !0;
  }
  /**
  Clear the queue.
  */
  clear() {
    this._queue = new this._queueClass();
  }
  /**
      Can be called multiple times. Useful if you for example add additional items at a later time.
  
      @returns A promise that settles when the queue becomes empty.
      */
  async onEmpty() {
    if (this._queue.size !== 0)
      return new Promise((e) => {
        const t = this._resolveEmpty;
        this._resolveEmpty = () => {
          t(), e();
        };
      });
  }
  /**
      The difference with `.onEmpty` is that `.onIdle` guarantees that all work from the queue has finished. `.onEmpty` merely signals that the queue is empty, but it could mean that some promises haven't completed yet.
  
      @returns A promise that settles when the queue becomes empty, and all promises have completed; `queue.size === 0 && queue.pending === 0`.
      */
  async onIdle() {
    if (!(this._pendingCount === 0 && this._queue.size === 0))
      return new Promise((e) => {
        const t = this._resolveIdle;
        this._resolveIdle = () => {
          t(), e();
        };
      });
  }
  /**
  Size of the queue.
  */
  get size() {
    return this._queue.size;
  }
  /**
      Size of the queue, filtered by the given options.
  
      For example, this can be used to find the number of items remaining in the queue with a specific priority level.
      */
  sizeBy(e) {
    return this._queue.filter(e).length;
  }
  /**
  Number of pending promises.
  */
  get pending() {
    return this._pendingCount;
  }
  /**
  Whether the queue is currently paused.
  */
  get isPaused() {
    return this._isPaused;
  }
  get timeout() {
    return this._timeout;
  }
  /**
  Set the timeout for future operations.
  */
  set timeout(e) {
    this._timeout = e;
  }
}
var Dr = Jm.default = f0;
const p0 = [
  408,
  // Request Timeout
  425,
  // Too Early
  429,
  // Too Many Requests
  500,
  // Internal Server Error
  502,
  // Bad Gateway
  503,
  // Service Unavailable
  504
  // Gateway Timeout
];
let Vd = class {
  constructor(e) {
    Object.defineProperty(this, "maxConcurrency", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "maxRetries", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "maxQueueSizeBytes", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "queue", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "onFailedResponseHook", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "queueSizeBytes", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), this.maxConcurrency = e.maxConcurrency ?? 1 / 0, this.maxRetries = e.maxRetries ?? 6, this.maxQueueSizeBytes = e.maxQueueSizeBytes, "default" in Dr ? this.queue = new Dr.default({
      concurrency: this.maxConcurrency
    }) : this.queue = new Dr({ concurrency: this.maxConcurrency }), this.onFailedResponseHook = e == null ? void 0 : e.onFailedResponseHook;
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  call(e, ...t) {
    return this.callWithOptions({}, e, ...t);
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  callWithOptions(e, t, ...n) {
    const s = e.sizeBytes ?? 0;
    if (this.maxQueueSizeBytes !== void 0 && s > 0 && this.queueSizeBytes + s > this.maxQueueSizeBytes)
      return Promise.reject(new Error(`Queue size limit (${this.maxQueueSizeBytes} bytes) exceeded. Current queue size: ${this.queueSizeBytes} bytes, attempted addition: ${s} bytes.`));
    s > 0 && (this.queueSizeBytes += s);
    const a = this.onFailedResponseHook;
    let i = this.queue.add(() => r0(() => t(...n).catch((o) => {
      throw o instanceof Error ? o : new Error(o);
    }), {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      async onFailedAttempt({ error: o }) {
        if (o.message.startsWith("Cancel") || o.message.startsWith("TimeoutError") || o.name === "TimeoutError" || o.message.startsWith("AbortError") || (o == null ? void 0 : o.code) === "ECONNABORTED")
          throw o;
        const c = o == null ? void 0 : o.response;
        if (a && await a(c))
          return;
        const u = (c == null ? void 0 : c.status) ?? (o == null ? void 0 : o.status);
        if (u && !p0.includes(+u))
          throw o;
      },
      retries: this.maxRetries,
      randomize: !0
    }), { throwOnTimeout: !0 });
    return s > 0 && (i = i.finally(() => {
      this.queueSizeBytes -= s;
    })), e.signal ? Promise.race([
      i,
      new Promise((o, c) => {
        var u;
        (u = e.signal) == null || u.addEventListener("abort", () => {
          c(new Error("AbortError"));
        });
      })
    ]) : i;
  }
};
function qd(r) {
  return typeof (r == null ? void 0 : r._getType) == "function";
}
function Hd(r) {
  const e = {
    type: r._getType(),
    data: { content: r.content }
  };
  return r != null && r.additional_kwargs && Object.keys(r.additional_kwargs).length > 0 && (e.data.additional_kwargs = { ...r.additional_kwargs }), e;
}
var Dc = { exports: {} };
const m0 = "2.0.0", Xm = 256, g0 = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
9007199254740991, _0 = 16, y0 = Xm - 6, w0 = [
  "major",
  "premajor",
  "minor",
  "preminor",
  "patch",
  "prepatch",
  "prerelease"
];
var lo = {
  MAX_LENGTH: Xm,
  MAX_SAFE_COMPONENT_LENGTH: _0,
  MAX_SAFE_BUILD_LENGTH: y0,
  MAX_SAFE_INTEGER: g0,
  RELEASE_TYPES: w0,
  SEMVER_SPEC_VERSION: m0,
  FLAG_INCLUDE_PRERELEASE: 1,
  FLAG_LOOSE: 2
};
const v0 = typeof process == "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...r) => console.error("SEMVER", ...r) : () => {
};
var ho = v0;
(function(r, e) {
  const {
    MAX_SAFE_COMPONENT_LENGTH: t,
    MAX_SAFE_BUILD_LENGTH: n,
    MAX_LENGTH: s
  } = lo, a = ho;
  e = r.exports = {};
  const i = e.re = [], o = e.safeRe = [], c = e.src = [], u = e.safeSrc = [], l = e.t = {};
  let d = 0;
  const h = "[a-zA-Z0-9-]", f = [
    ["\\s", 1],
    ["\\d", s],
    [h, n]
  ], p = (g) => {
    for (const [S, _] of f)
      g = g.split(`${S}*`).join(`${S}{0,${_}}`).split(`${S}+`).join(`${S}{1,${_}}`);
    return g;
  }, y = (g, S, _) => {
    const w = p(S), T = d++;
    a(g, T, S), l[g] = T, c[T] = S, u[T] = w, i[T] = new RegExp(S, _ ? "g" : void 0), o[T] = new RegExp(w, _ ? "g" : void 0);
  };
  y("NUMERICIDENTIFIER", "0|[1-9]\\d*"), y("NUMERICIDENTIFIERLOOSE", "\\d+"), y("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${h}*`), y("MAINVERSION", `(${c[l.NUMERICIDENTIFIER]})\\.(${c[l.NUMERICIDENTIFIER]})\\.(${c[l.NUMERICIDENTIFIER]})`), y("MAINVERSIONLOOSE", `(${c[l.NUMERICIDENTIFIERLOOSE]})\\.(${c[l.NUMERICIDENTIFIERLOOSE]})\\.(${c[l.NUMERICIDENTIFIERLOOSE]})`), y("PRERELEASEIDENTIFIER", `(?:${c[l.NONNUMERICIDENTIFIER]}|${c[l.NUMERICIDENTIFIER]})`), y("PRERELEASEIDENTIFIERLOOSE", `(?:${c[l.NONNUMERICIDENTIFIER]}|${c[l.NUMERICIDENTIFIERLOOSE]})`), y("PRERELEASE", `(?:-(${c[l.PRERELEASEIDENTIFIER]}(?:\\.${c[l.PRERELEASEIDENTIFIER]})*))`), y("PRERELEASELOOSE", `(?:-?(${c[l.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${c[l.PRERELEASEIDENTIFIERLOOSE]})*))`), y("BUILDIDENTIFIER", `${h}+`), y("BUILD", `(?:\\+(${c[l.BUILDIDENTIFIER]}(?:\\.${c[l.BUILDIDENTIFIER]})*))`), y("FULLPLAIN", `v?${c[l.MAINVERSION]}${c[l.PRERELEASE]}?${c[l.BUILD]}?`), y("FULL", `^${c[l.FULLPLAIN]}$`), y("LOOSEPLAIN", `[v=\\s]*${c[l.MAINVERSIONLOOSE]}${c[l.PRERELEASELOOSE]}?${c[l.BUILD]}?`), y("LOOSE", `^${c[l.LOOSEPLAIN]}$`), y("GTLT", "((?:<|>)?=?)"), y("XRANGEIDENTIFIERLOOSE", `${c[l.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`), y("XRANGEIDENTIFIER", `${c[l.NUMERICIDENTIFIER]}|x|X|\\*`), y("XRANGEPLAIN", `[v=\\s]*(${c[l.XRANGEIDENTIFIER]})(?:\\.(${c[l.XRANGEIDENTIFIER]})(?:\\.(${c[l.XRANGEIDENTIFIER]})(?:${c[l.PRERELEASE]})?${c[l.BUILD]}?)?)?`), y("XRANGEPLAINLOOSE", `[v=\\s]*(${c[l.XRANGEIDENTIFIERLOOSE]})(?:\\.(${c[l.XRANGEIDENTIFIERLOOSE]})(?:\\.(${c[l.XRANGEIDENTIFIERLOOSE]})(?:${c[l.PRERELEASELOOSE]})?${c[l.BUILD]}?)?)?`), y("XRANGE", `^${c[l.GTLT]}\\s*${c[l.XRANGEPLAIN]}$`), y("XRANGELOOSE", `^${c[l.GTLT]}\\s*${c[l.XRANGEPLAINLOOSE]}$`), y("COERCEPLAIN", `(^|[^\\d])(\\d{1,${t}})(?:\\.(\\d{1,${t}}))?(?:\\.(\\d{1,${t}}))?`), y("COERCE", `${c[l.COERCEPLAIN]}(?:$|[^\\d])`), y("COERCEFULL", c[l.COERCEPLAIN] + `(?:${c[l.PRERELEASE]})?(?:${c[l.BUILD]})?(?:$|[^\\d])`), y("COERCERTL", c[l.COERCE], !0), y("COERCERTLFULL", c[l.COERCEFULL], !0), y("LONETILDE", "(?:~>?)"), y("TILDETRIM", `(\\s*)${c[l.LONETILDE]}\\s+`, !0), e.tildeTrimReplace = "$1~", y("TILDE", `^${c[l.LONETILDE]}${c[l.XRANGEPLAIN]}$`), y("TILDELOOSE", `^${c[l.LONETILDE]}${c[l.XRANGEPLAINLOOSE]}$`), y("LONECARET", "(?:\\^)"), y("CARETTRIM", `(\\s*)${c[l.LONECARET]}\\s+`, !0), e.caretTrimReplace = "$1^", y("CARET", `^${c[l.LONECARET]}${c[l.XRANGEPLAIN]}$`), y("CARETLOOSE", `^${c[l.LONECARET]}${c[l.XRANGEPLAINLOOSE]}$`), y("COMPARATORLOOSE", `^${c[l.GTLT]}\\s*(${c[l.LOOSEPLAIN]})$|^$`), y("COMPARATOR", `^${c[l.GTLT]}\\s*(${c[l.FULLPLAIN]})$|^$`), y("COMPARATORTRIM", `(\\s*)${c[l.GTLT]}\\s*(${c[l.LOOSEPLAIN]}|${c[l.XRANGEPLAIN]})`, !0), e.comparatorTrimReplace = "$1$2$3", y("HYPHENRANGE", `^\\s*(${c[l.XRANGEPLAIN]})\\s+-\\s+(${c[l.XRANGEPLAIN]})\\s*$`), y("HYPHENRANGELOOSE", `^\\s*(${c[l.XRANGEPLAINLOOSE]})\\s+-\\s+(${c[l.XRANGEPLAINLOOSE]})\\s*$`), y("STAR", "(<|>)?=?\\s*\\*"), y("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$"), y("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
})(Dc, Dc.exports);
var da = Dc.exports;
const b0 = Object.freeze({ loose: !0 }), S0 = Object.freeze({}), T0 = (r) => r ? typeof r != "object" ? b0 : r : S0;
var hl = T0;
const Jd = /^[0-9]+$/, Qm = (r, e) => {
  if (typeof r == "number" && typeof e == "number")
    return r === e ? 0 : r < e ? -1 : 1;
  const t = Jd.test(r), n = Jd.test(e);
  return t && n && (r = +r, e = +e), r === e ? 0 : t && !n ? -1 : n && !t ? 1 : r < e ? -1 : 1;
}, E0 = (r, e) => Qm(e, r);
var eg = {
  compareIdentifiers: Qm,
  rcompareIdentifiers: E0
};
const Na = ho, { MAX_LENGTH: Wd, MAX_SAFE_INTEGER: Pa } = lo, { safeRe: La, t: Ma } = da, x0 = hl, { compareIdentifiers: Xo } = eg;
let I0 = class _r {
  constructor(e, t) {
    if (t = x0(t), e instanceof _r) {
      if (e.loose === !!t.loose && e.includePrerelease === !!t.includePrerelease)
        return e;
      e = e.version;
    } else if (typeof e != "string")
      throw new TypeError(`Invalid version. Must be a string. Got type "${typeof e}".`);
    if (e.length > Wd)
      throw new TypeError(
        `version is longer than ${Wd} characters`
      );
    Na("SemVer", e, t), this.options = t, this.loose = !!t.loose, this.includePrerelease = !!t.includePrerelease;
    const n = e.trim().match(t.loose ? La[Ma.LOOSE] : La[Ma.FULL]);
    if (!n)
      throw new TypeError(`Invalid Version: ${e}`);
    if (this.raw = e, this.major = +n[1], this.minor = +n[2], this.patch = +n[3], this.major > Pa || this.major < 0)
      throw new TypeError("Invalid major version");
    if (this.minor > Pa || this.minor < 0)
      throw new TypeError("Invalid minor version");
    if (this.patch > Pa || this.patch < 0)
      throw new TypeError("Invalid patch version");
    n[4] ? this.prerelease = n[4].split(".").map((s) => {
      if (/^[0-9]+$/.test(s)) {
        const a = +s;
        if (a >= 0 && a < Pa)
          return a;
      }
      return s;
    }) : this.prerelease = [], this.build = n[5] ? n[5].split(".") : [], this.format();
  }
  format() {
    return this.version = `${this.major}.${this.minor}.${this.patch}`, this.prerelease.length && (this.version += `-${this.prerelease.join(".")}`), this.version;
  }
  toString() {
    return this.version;
  }
  compare(e) {
    if (Na("SemVer.compare", this.version, this.options, e), !(e instanceof _r)) {
      if (typeof e == "string" && e === this.version)
        return 0;
      e = new _r(e, this.options);
    }
    return e.version === this.version ? 0 : this.compareMain(e) || this.comparePre(e);
  }
  compareMain(e) {
    return e instanceof _r || (e = new _r(e, this.options)), this.major < e.major ? -1 : this.major > e.major ? 1 : this.minor < e.minor ? -1 : this.minor > e.minor ? 1 : this.patch < e.patch ? -1 : this.patch > e.patch ? 1 : 0;
  }
  comparePre(e) {
    if (e instanceof _r || (e = new _r(e, this.options)), this.prerelease.length && !e.prerelease.length)
      return -1;
    if (!this.prerelease.length && e.prerelease.length)
      return 1;
    if (!this.prerelease.length && !e.prerelease.length)
      return 0;
    let t = 0;
    do {
      const n = this.prerelease[t], s = e.prerelease[t];
      if (Na("prerelease compare", t, n, s), n === void 0 && s === void 0)
        return 0;
      if (s === void 0)
        return 1;
      if (n === void 0)
        return -1;
      if (n === s)
        continue;
      return Xo(n, s);
    } while (++t);
  }
  compareBuild(e) {
    e instanceof _r || (e = new _r(e, this.options));
    let t = 0;
    do {
      const n = this.build[t], s = e.build[t];
      if (Na("build compare", t, n, s), n === void 0 && s === void 0)
        return 0;
      if (s === void 0)
        return 1;
      if (n === void 0)
        return -1;
      if (n === s)
        continue;
      return Xo(n, s);
    } while (++t);
  }
  // preminor will bump the version up to the next minor release, and immediately
  // down to pre-release. premajor and prepatch work the same way.
  inc(e, t, n) {
    if (e.startsWith("pre")) {
      if (!t && n === !1)
        throw new Error("invalid increment argument: identifier is empty");
      if (t) {
        const s = `-${t}`.match(this.options.loose ? La[Ma.PRERELEASELOOSE] : La[Ma.PRERELEASE]);
        if (!s || s[1] !== t)
          throw new Error(`invalid identifier: ${t}`);
      }
    }
    switch (e) {
      case "premajor":
        this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", t, n);
        break;
      case "preminor":
        this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", t, n);
        break;
      case "prepatch":
        this.prerelease.length = 0, this.inc("patch", t, n), this.inc("pre", t, n);
        break;
      case "prerelease":
        this.prerelease.length === 0 && this.inc("patch", t, n), this.inc("pre", t, n);
        break;
      case "release":
        if (this.prerelease.length === 0)
          throw new Error(`version ${this.raw} is not a prerelease`);
        this.prerelease.length = 0;
        break;
      case "major":
        (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) && this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
        break;
      case "minor":
        (this.patch !== 0 || this.prerelease.length === 0) && this.minor++, this.patch = 0, this.prerelease = [];
        break;
      case "patch":
        this.prerelease.length === 0 && this.patch++, this.prerelease = [];
        break;
      case "pre": {
        const s = Number(n) ? 1 : 0;
        if (this.prerelease.length === 0)
          this.prerelease = [s];
        else {
          let a = this.prerelease.length;
          for (; --a >= 0; )
            typeof this.prerelease[a] == "number" && (this.prerelease[a]++, a = -2);
          if (a === -1) {
            if (t === this.prerelease.join(".") && n === !1)
              throw new Error("invalid increment argument: identifier already exists");
            this.prerelease.push(s);
          }
        }
        if (t) {
          let a = [t, s];
          n === !1 && (a = [t]), Xo(this.prerelease[0], t) === 0 ? isNaN(this.prerelease[1]) && (this.prerelease = a) : this.prerelease = a;
        }
        break;
      }
      default:
        throw new Error(`invalid increment argument: ${e}`);
    }
    return this.raw = this.format(), this.build.length && (this.raw += `+${this.build.join(".")}`), this;
  }
};
var fl = I0;
const Gd = fl, k0 = (r, e, t) => new Gd(r, t).compare(new Gd(e, t));
var cs = k0;
const O0 = cs, A0 = (r, e, t) => O0(r, e, t) > 0;
var $0 = A0;
const C0 = cs, R0 = (r, e, t) => C0(r, e, t) < 0;
var N0 = R0;
const P0 = cs, L0 = (r, e, t) => P0(r, e, t) === 0;
var M0 = L0;
const D0 = cs, j0 = (r, e, t) => D0(r, e, t) !== 0;
var F0 = j0;
const U0 = cs, z0 = (r, e, t) => U0(r, e, t) >= 0;
var B0 = z0;
const Z0 = cs, V0 = (r, e, t) => Z0(r, e, t) <= 0;
var q0 = V0;
const H0 = M0, J0 = F0, W0 = $0, G0 = B0, K0 = N0, Y0 = q0, X0 = (r, e, t, n) => {
  switch (e) {
    case "===":
      return typeof r == "object" && (r = r.version), typeof t == "object" && (t = t.version), r === t;
    case "!==":
      return typeof r == "object" && (r = r.version), typeof t == "object" && (t = t.version), r !== t;
    case "":
    case "=":
    case "==":
      return H0(r, t, n);
    case "!=":
      return J0(r, t, n);
    case ">":
      return W0(r, t, n);
    case ">=":
      return G0(r, t, n);
    case "<":
      return K0(r, t, n);
    case "<=":
      return Y0(r, t, n);
    default:
      throw new TypeError(`Invalid operator: ${e}`);
  }
};
var Q0 = X0;
const { safeRe: CR, t: RR } = da;
class eS {
  constructor() {
    this.max = 1e3, this.map = /* @__PURE__ */ new Map();
  }
  get(e) {
    const t = this.map.get(e);
    if (t !== void 0)
      return this.map.delete(e), this.map.set(e, t), t;
  }
  delete(e) {
    return this.map.delete(e);
  }
  set(e, t) {
    if (!this.delete(e) && t !== void 0) {
      if (this.map.size >= this.max) {
        const s = this.map.keys().next().value;
        this.delete(s);
      }
      this.map.set(e, t);
    }
    return this;
  }
}
var tS = eS, Qo, Kd;
function fr() {
  if (Kd) return Qo;
  Kd = 1;
  const r = /\s+/g;
  class e {
    constructor(D, U) {
      if (U = s(U), D instanceof e)
        return D.loose === !!U.loose && D.includePrerelease === !!U.includePrerelease ? D : new e(D.raw, U);
      if (D instanceof a)
        return this.raw = D.value, this.set = [[D]], this.formatted = void 0, this;
      if (this.options = U, this.loose = !!U.loose, this.includePrerelease = !!U.includePrerelease, this.raw = D.trim().replace(r, " "), this.set = this.raw.split("||").map((O) => this.parseRange(O.trim())).filter((O) => O.length), !this.set.length)
        throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
      if (this.set.length > 1) {
        const O = this.set[0];
        if (this.set = this.set.filter((P) => !y(P[0])), this.set.length === 0)
          this.set = [O];
        else if (this.set.length > 1) {
          for (const P of this.set)
            if (P.length === 1 && g(P[0])) {
              this.set = [P];
              break;
            }
        }
      }
      this.formatted = void 0;
    }
    get range() {
      if (this.formatted === void 0) {
        this.formatted = "";
        for (let D = 0; D < this.set.length; D++) {
          D > 0 && (this.formatted += "||");
          const U = this.set[D];
          for (let O = 0; O < U.length; O++)
            O > 0 && (this.formatted += " "), this.formatted += U[O].toString().trim();
        }
      }
      return this.formatted;
    }
    format() {
      return this.range;
    }
    toString() {
      return this.range;
    }
    parseRange(D) {
      const O = ((this.options.includePrerelease && f) | (this.options.loose && p)) + ":" + D, P = n.get(O);
      if (P)
        return P;
      const N = this.options.loose, j = N ? c[u.HYPHENRANGELOOSE] : c[u.HYPHENRANGE];
      D = D.replace(j, Se(this.options.includePrerelease)), i("hyphen replace", D), D = D.replace(c[u.COMPARATORTRIM], l), i("comparator trim", D), D = D.replace(c[u.TILDETRIM], d), i("tilde trim", D), D = D.replace(c[u.CARETTRIM], h), i("caret trim", D);
      let M = D.split(" ").map((ae) => _(ae, this.options)).join(" ").split(/\s+/).map((ae) => z(ae, this.options));
      N && (M = M.filter((ae) => (i("loose invalid filter", ae, this.options), !!ae.match(c[u.COMPARATORLOOSE])))), i("range list", M);
      const q = /* @__PURE__ */ new Map(), se = M.map((ae) => new a(ae, this.options));
      for (const ae of se) {
        if (y(ae))
          return [ae];
        q.set(ae.value, ae);
      }
      q.size > 1 && q.has("") && q.delete("");
      const Te = [...q.values()];
      return n.set(O, Te), Te;
    }
    intersects(D, U) {
      if (!(D instanceof e))
        throw new TypeError("a Range is required");
      return this.set.some((O) => S(O, U) && D.set.some((P) => S(P, U) && O.every((N) => P.every((j) => N.intersects(j, U)))));
    }
    // if ANY of the sets match ALL of its comparators, then pass
    test(D) {
      if (!D)
        return !1;
      if (typeof D == "string")
        try {
          D = new o(D, this.options);
        } catch {
          return !1;
        }
      for (let U = 0; U < this.set.length; U++)
        if (Oe(this.set[U], D, this.options))
          return !0;
      return !1;
    }
  }
  Qo = e;
  const t = tS, n = new t(), s = hl, a = fo(), i = ho, o = fl, {
    safeRe: c,
    t: u,
    comparatorTrimReplace: l,
    tildeTrimReplace: d,
    caretTrimReplace: h
  } = da, { FLAG_INCLUDE_PRERELEASE: f, FLAG_LOOSE: p } = lo, y = (Z) => Z.value === "<0.0.0-0", g = (Z) => Z.value === "", S = (Z, D) => {
    let U = !0;
    const O = Z.slice();
    let P = O.pop();
    for (; U && O.length; )
      U = O.every((N) => P.intersects(N, D)), P = O.pop();
    return U;
  }, _ = (Z, D) => (Z = Z.replace(c[u.BUILD], ""), i("comp", Z, D), Z = A(Z, D), i("caret", Z), Z = T(Z, D), i("tildes", Z), Z = E(Z, D), i("xrange", Z), Z = ne(Z, D), i("stars", Z), Z), w = (Z) => !Z || Z.toLowerCase() === "x" || Z === "*", T = (Z, D) => Z.trim().split(/\s+/).map((U) => x(U, D)).join(" "), x = (Z, D) => {
    const U = D.loose ? c[u.TILDELOOSE] : c[u.TILDE];
    return Z.replace(U, (O, P, N, j, M) => {
      i("tilde", Z, O, P, N, j, M);
      let q;
      return w(P) ? q = "" : w(N) ? q = `>=${P}.0.0 <${+P + 1}.0.0-0` : w(j) ? q = `>=${P}.${N}.0 <${P}.${+N + 1}.0-0` : M ? (i("replaceTilde pr", M), q = `>=${P}.${N}.${j}-${M} <${P}.${+N + 1}.0-0`) : q = `>=${P}.${N}.${j} <${P}.${+N + 1}.0-0`, i("tilde return", q), q;
    });
  }, A = (Z, D) => Z.trim().split(/\s+/).map((U) => R(U, D)).join(" "), R = (Z, D) => {
    i("caret", Z, D);
    const U = D.loose ? c[u.CARETLOOSE] : c[u.CARET], O = D.includePrerelease ? "-0" : "";
    return Z.replace(U, (P, N, j, M, q) => {
      i("caret", Z, P, N, j, M, q);
      let se;
      return w(N) ? se = "" : w(j) ? se = `>=${N}.0.0${O} <${+N + 1}.0.0-0` : w(M) ? N === "0" ? se = `>=${N}.${j}.0${O} <${N}.${+j + 1}.0-0` : se = `>=${N}.${j}.0${O} <${+N + 1}.0.0-0` : q ? (i("replaceCaret pr", q), N === "0" ? j === "0" ? se = `>=${N}.${j}.${M}-${q} <${N}.${j}.${+M + 1}-0` : se = `>=${N}.${j}.${M}-${q} <${N}.${+j + 1}.0-0` : se = `>=${N}.${j}.${M}-${q} <${+N + 1}.0.0-0`) : (i("no pr"), N === "0" ? j === "0" ? se = `>=${N}.${j}.${M}${O} <${N}.${j}.${+M + 1}-0` : se = `>=${N}.${j}.${M}${O} <${N}.${+j + 1}.0-0` : se = `>=${N}.${j}.${M} <${+N + 1}.0.0-0`), i("caret return", se), se;
    });
  }, E = (Z, D) => (i("replaceXRanges", Z, D), Z.split(/\s+/).map((U) => V(U, D)).join(" ")), V = (Z, D) => {
    Z = Z.trim();
    const U = D.loose ? c[u.XRANGELOOSE] : c[u.XRANGE];
    return Z.replace(U, (O, P, N, j, M, q) => {
      i("xRange", Z, O, P, N, j, M, q);
      const se = w(N), Te = se || w(j), ae = Te || w(M), b = ae;
      return P === "=" && b && (P = ""), q = D.includePrerelease ? "-0" : "", se ? P === ">" || P === "<" ? O = "<0.0.0-0" : O = "*" : P && b ? (Te && (j = 0), M = 0, P === ">" ? (P = ">=", Te ? (N = +N + 1, j = 0, M = 0) : (j = +j + 1, M = 0)) : P === "<=" && (P = "<", Te ? N = +N + 1 : j = +j + 1), P === "<" && (q = "-0"), O = `${P + N}.${j}.${M}${q}`) : Te ? O = `>=${N}.0.0${q} <${+N + 1}.0.0-0` : ae && (O = `>=${N}.${j}.0${q} <${N}.${+j + 1}.0-0`), i("xRange return", O), O;
    });
  }, ne = (Z, D) => (i("replaceStars", Z, D), Z.trim().replace(c[u.STAR], "")), z = (Z, D) => (i("replaceGTE0", Z, D), Z.trim().replace(c[D.includePrerelease ? u.GTE0PRE : u.GTE0], "")), Se = (Z) => (D, U, O, P, N, j, M, q, se, Te, ae, b) => (w(O) ? U = "" : w(P) ? U = `>=${O}.0.0${Z ? "-0" : ""}` : w(N) ? U = `>=${O}.${P}.0${Z ? "-0" : ""}` : j ? U = `>=${U}` : U = `>=${U}${Z ? "-0" : ""}`, w(se) ? q = "" : w(Te) ? q = `<${+se + 1}.0.0-0` : w(ae) ? q = `<${se}.${+Te + 1}.0-0` : b ? q = `<=${se}.${Te}.${ae}-${b}` : Z ? q = `<${se}.${Te}.${+ae + 1}-0` : q = `<=${q}`, `${U} ${q}`.trim()), Oe = (Z, D, U) => {
    for (let O = 0; O < Z.length; O++)
      if (!Z[O].test(D))
        return !1;
    if (D.prerelease.length && !U.includePrerelease) {
      for (let O = 0; O < Z.length; O++)
        if (i(Z[O].semver), Z[O].semver !== a.ANY && Z[O].semver.prerelease.length > 0) {
          const P = Z[O].semver;
          if (P.major === D.major && P.minor === D.minor && P.patch === D.patch)
            return !0;
        }
      return !1;
    }
    return !0;
  };
  return Qo;
}
var ec, Yd;
function fo() {
  if (Yd) return ec;
  Yd = 1;
  const r = Symbol("SemVer ANY");
  class e {
    static get ANY() {
      return r;
    }
    constructor(l, d) {
      if (d = t(d), l instanceof e) {
        if (l.loose === !!d.loose)
          return l;
        l = l.value;
      }
      l = l.trim().split(/\s+/).join(" "), i("comparator", l, d), this.options = d, this.loose = !!d.loose, this.parse(l), this.semver === r ? this.value = "" : this.value = this.operator + this.semver.version, i("comp", this);
    }
    parse(l) {
      const d = this.options.loose ? n[s.COMPARATORLOOSE] : n[s.COMPARATOR], h = l.match(d);
      if (!h)
        throw new TypeError(`Invalid comparator: ${l}`);
      this.operator = h[1] !== void 0 ? h[1] : "", this.operator === "=" && (this.operator = ""), h[2] ? this.semver = new o(h[2], this.options.loose) : this.semver = r;
    }
    toString() {
      return this.value;
    }
    test(l) {
      if (i("Comparator.test", l, this.options.loose), this.semver === r || l === r)
        return !0;
      if (typeof l == "string")
        try {
          l = new o(l, this.options);
        } catch {
          return !1;
        }
      return a(l, this.operator, this.semver, this.options);
    }
    intersects(l, d) {
      if (!(l instanceof e))
        throw new TypeError("a Comparator is required");
      return this.operator === "" ? this.value === "" ? !0 : new c(l.value, d).test(this.value) : l.operator === "" ? l.value === "" ? !0 : new c(this.value, d).test(l.semver) : (d = t(d), d.includePrerelease && (this.value === "<0.0.0-0" || l.value === "<0.0.0-0") || !d.includePrerelease && (this.value.startsWith("<0.0.0") || l.value.startsWith("<0.0.0")) ? !1 : !!(this.operator.startsWith(">") && l.operator.startsWith(">") || this.operator.startsWith("<") && l.operator.startsWith("<") || this.semver.version === l.semver.version && this.operator.includes("=") && l.operator.includes("=") || a(this.semver, "<", l.semver, d) && this.operator.startsWith(">") && l.operator.startsWith("<") || a(this.semver, ">", l.semver, d) && this.operator.startsWith("<") && l.operator.startsWith(">")));
    }
  }
  ec = e;
  const t = hl, { safeRe: n, t: s } = da, a = Q0, i = ho, o = fl, c = fr();
  return ec;
}
fr();
fr();
fr();
fr();
fr();
fr();
const rS = fo(), { ANY: NR } = rS;
fr();
fr();
fr();
const pl = fo(), { ANY: PR } = pl;
new pl(">=0.0.0-0");
new pl(">=0.0.0");
const tc = da, Xd = lo, Qd = eg;
fo();
fr();
tc.re, tc.src, tc.t, Xd.SEMVER_SPEC_VERSION, Xd.RELEASE_TYPES, Qd.compareIdentifiers, Qd.rcompareIdentifiers;
function Gr(r) {
  if (!r || r.split("/").length > 2 || r.startsWith("/") || r.endsWith("/") || r.split(":").length > 2)
    throw new Error(`Invalid identifier format: ${r}`);
  const [e, t] = r.split(":"), n = t || "latest";
  if (e.includes("/")) {
    const [s, a] = e.split("/", 2);
    if (!s || !a)
      throw new Error(`Invalid identifier format: ${r}`);
    return [s, a, n];
  } else {
    if (!e)
      throw new Error(`Invalid identifier format: ${r}`);
    return ["-", e, n];
  }
}
class nS extends Error {
  constructor(e) {
    super(e), Object.defineProperty(this, "status", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.name = "LangSmithConflictError", this.status = 409;
  }
}
async function re(r, e, t) {
  let n;
  if (r.ok) {
    t && (n = await r.text());
    return;
  }
  if (r.status === 403)
    try {
      const i = await r.json();
      (i == null ? void 0 : i.error) === "org_scoped_key_requires_workspace" && (n = "This API key is org-scoped and requires workspace specification. Please provide 'workspaceId' parameter, or set LANGSMITH_WORKSPACE_ID environment variable.");
    } catch {
      const o = new Error(`${r.status} ${r.statusText}`);
      throw o.status = r == null ? void 0 : r.status, o;
    }
  if (n === void 0)
    try {
      n = await r.text();
    } catch {
      n = "";
    }
  const s = `Failed to ${e}. Received status [${r.status}]: ${r.statusText}. Message: ${n}`;
  if (r.status === 409)
    throw new nS(s);
  const a = new Error(s);
  throw a.status = r.status, a;
}
const tg = "ERR_CONFLICTING_ENDPOINTS";
class sS extends Error {
  constructor() {
    super("You cannot provide both LANGSMITH_ENDPOINT / LANGCHAIN_ENDPOINT and LANGSMITH_RUNS_ENDPOINTS."), Object.defineProperty(this, "code", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: tg
    }), this.name = "ConflictingEndpointsError";
  }
}
function aS(r) {
  return typeof r == "object" && r !== null && r.code === tg;
}
var eh = "[...]", iS = { result: "[Circular]" }, Ti = [], Zn = [];
const oS = new TextEncoder();
function cS() {
  return {
    depthLimit: Number.MAX_SAFE_INTEGER,
    edgesLimit: Number.MAX_SAFE_INTEGER
  };
}
function Da(r) {
  return oS.encode(r);
}
function rg(r) {
  if (r && typeof r == "object" && r !== null) {
    if (r instanceof Map)
      return Object.fromEntries(r);
    if (r instanceof Set)
      return Array.from(r);
    if (r instanceof Date)
      return r.toISOString();
    if (r instanceof RegExp)
      return r.toString();
    if (r instanceof Error)
      return {
        name: r.name,
        message: r.message
      };
  } else if (typeof r == "bigint")
    return r.toString();
  return r;
}
function uS(r) {
  return function(e, t) {
    return rg(t);
  };
}
function jt(r, e, t, n, s) {
  var a;
  try {
    const i = JSON.stringify(r, uS(t), n);
    return Da(i);
  } catch (i) {
    if (!((a = i.message) != null && a.includes("Converting circular structure to JSON")))
      return console.warn(`[WARNING]: LangSmith received unserializable value.${e ? `
Context: ${e}` : ""}`), Da("[Unserializable]");
    Nt("SUPPRESS_CIRCULAR_JSON_WARNINGS") !== "true" && console.warn(`[WARNING]: LangSmith received circular JSON. This will decrease tracer performance. ${e ? `
Context: ${e}` : ""}`), typeof s > "u" && (s = cS()), jc(r, "", 0, [], void 0, 0, s);
    let o;
    try {
      Zn.length === 0 ? o = JSON.stringify(r, t, n) : o = JSON.stringify(r, lS(t), n);
    } catch {
      return Da("[unable to serialize, circular reference is too complex to analyze]");
    } finally {
      for (; Ti.length !== 0; ) {
        const c = Ti.pop();
        c.length === 4 ? Object.defineProperty(c[0], c[1], c[3]) : c[0][c[1]] = c[2];
      }
    }
    return Da(o);
  }
}
function rc(r, e, t, n) {
  var s = Object.getOwnPropertyDescriptor(n, t);
  s.get !== void 0 ? s.configurable ? (Object.defineProperty(n, t, { value: r }), Ti.push([n, t, e, s])) : Zn.push([e, t, r]) : (n[t] = r, Ti.push([n, t, e]));
}
function jc(r, e, t, n, s, a, i) {
  a += 1;
  var o;
  if (typeof r == "object" && r !== null) {
    for (o = 0; o < n.length; o++)
      if (n[o] === r) {
        rc(iS, r, e, s);
        return;
      }
    if (typeof i.depthLimit < "u" && a > i.depthLimit) {
      rc(eh, r, e, s);
      return;
    }
    if (typeof i.edgesLimit < "u" && t + 1 > i.edgesLimit) {
      rc(eh, r, e, s);
      return;
    }
    if (n.push(r), Array.isArray(r))
      for (o = 0; o < r.length; o++)
        jc(r[o], o, o, n, r, a, i);
    else {
      r = rg(r);
      var c = Object.keys(r);
      for (o = 0; o < c.length; o++) {
        var u = c[o];
        jc(r[u], u, o, n, r, a, i);
      }
    }
    n.pop();
  }
}
function lS(r) {
  return r = typeof r < "u" ? r : function(e, t) {
    return t;
  }, function(e, t) {
    if (Zn.length > 0)
      for (var n = 0; n < Zn.length; n++) {
        var s = Zn[n];
        if (s[1] === e && s[0] === t) {
          t = s[2], Zn.splice(n, 1);
          break;
        }
      }
    return r.call(this, e, t);
  };
}
function th(r, e) {
  const t = Zm(), n = e ?? Vm(), s = r.extra ?? {}, a = s.metadata;
  return r.extra = {
    ...s,
    runtime: {
      ...t,
      ...s == null ? void 0 : s.runtime
    },
    metadata: {
      ...n,
      ...n.revision_id || "revision_id" in r && r.revision_id ? {
        revision_id: ("revision_id" in r ? r.revision_id : void 0) ?? n.revision_id
      } : {},
      ...a
    }
  }, r;
}
const dS = (r) => {
  const e = (r == null ? void 0 : r.toString()) ?? Nt("TRACING_SAMPLING_RATE");
  if (e === void 0)
    return;
  const t = parseFloat(e);
  if (t < 0 || t > 1)
    throw new Error(`LANGSMITH_TRACING_SAMPLING_RATE must be between 0 and 1 if set. Got: ${t}`);
  return t;
}, hS = (r) => {
  const t = r.replace("http://", "").replace("https://", "").split("/")[0].split(":")[0];
  return t === "localhost" || t === "127.0.0.1" || t === "::1";
};
async function fS(r) {
  const e = [];
  for await (const t of r)
    e.push(t);
  return e;
}
function ja(r) {
  if (r !== void 0)
    return r.trim().replace(/^"(.*)"$/, "$1").replace(/^'(.*)'$/, "$1");
}
const pS = async (r) => {
  if ((r == null ? void 0 : r.status) === 429) {
    const e = parseInt(r.headers.get("retry-after") ?? "10", 10) * 1e3;
    if (e > 0)
      return await new Promise((t) => setTimeout(t, e)), !0;
  }
  return !1;
};
function rh(r) {
  return typeof r == "number" ? Number(r.toFixed(4)) : r;
}
const mS = 24 * 1024 * 1024, ng = 1024 * 1024 * 1024, gS = 1e4, _S = 100, nh = "https://api.smith.langchain.com";
class yS {
  constructor(e) {
    Object.defineProperty(this, "items", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "sizeBytes", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "maxSizeBytes", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.maxSizeBytes = e ?? ng;
  }
  peek() {
    return this.items[0];
  }
  push(e) {
    let t;
    const n = new Promise((a) => {
      t = a;
    }), s = jt(e.item, `Serializing run with id: ${e.item.id}`).length;
    return this.sizeBytes + s > this.maxSizeBytes && this.items.length > 0 ? (console.warn(`AutoBatchQueue size limit (${this.maxSizeBytes} bytes) exceeded. Dropping run with id: ${e.item.id}. Current queue size: ${this.sizeBytes} bytes, attempted addition: ${s} bytes.`), t(), n) : (this.items.push({
      action: e.action,
      payload: e.item,
      otelContext: e.otelContext,
      apiKey: e.apiKey,
      apiUrl: e.apiUrl,
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      itemPromiseResolve: t,
      itemPromise: n,
      size: s
    }), this.sizeBytes += s, n);
  }
  pop({ upToSizeBytes: e, upToSize: t }) {
    var a;
    if (e < 1)
      throw new Error("Number of bytes to pop off may not be less than 1.");
    const n = [];
    let s = 0;
    for (; s + (((a = this.peek()) == null ? void 0 : a.size) ?? 0) < e && this.items.length > 0 && n.length < t; ) {
      const i = this.items.shift();
      i && (n.push(i), s += i.size, this.sizeBytes -= i.size);
    }
    if (n.length === 0 && this.items.length > 0) {
      const i = this.items.shift();
      n.push(i), s += i.size, this.sizeBytes -= i.size;
    }
    return [
      n.map((i) => ({
        action: i.action,
        item: i.payload,
        otelContext: i.otelContext,
        apiKey: i.apiKey,
        apiUrl: i.apiUrl,
        size: i.size
      })),
      () => n.forEach((i) => i.itemPromiseResolve())
    ];
  }
}
class Js {
  get _fetch() {
    return this.fetchImplementation || Ob(this.debug);
  }
  constructor(e = {}) {
    var s;
    Object.defineProperty(this, "apiKey", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "apiUrl", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "webUrl", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "workspaceId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "caller", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "batchIngestCaller", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "timeout_ms", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_tenantId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: null
    }), Object.defineProperty(this, "hideInputs", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "hideOutputs", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "tracingSampleRate", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "filteredPostUuids", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: /* @__PURE__ */ new Set()
    }), Object.defineProperty(this, "autoBatchTracing", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "autoBatchQueue", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "autoBatchTimeout", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "autoBatchAggregationDelayMs", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 250
    }), Object.defineProperty(this, "batchSizeBytesLimit", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "batchSizeLimit", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "fetchOptions", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "settings", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "blockOnRootRunFinalization", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: Or("LANGSMITH_TRACING_BACKGROUND") === "false"
    }), Object.defineProperty(this, "traceBatchConcurrency", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 5
    }), Object.defineProperty(this, "_serverInfo", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_getServerInfoPromise", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "manualFlushMode", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "langSmithToOTELTranslator", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "fetchImplementation", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "cachedLSEnvVarsForMetadata", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "multipartStreamingDisabled", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "debug", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: Or("LANGSMITH_DEBUG") === "true"
    });
    const t = Js.getDefaultClientConfig();
    if (this.tracingSampleRate = dS(e.tracingSamplingRate), this.apiUrl = ja(e.apiUrl ?? t.apiUrl) ?? "", this.apiUrl.endsWith("/") && (this.apiUrl = this.apiUrl.slice(0, -1)), this.apiKey = ja(e.apiKey ?? t.apiKey), this.webUrl = ja(e.webUrl ?? t.webUrl), (s = this.webUrl) != null && s.endsWith("/") && (this.webUrl = this.webUrl.slice(0, -1)), this.workspaceId = ja(e.workspaceId ?? Nt("WORKSPACE_ID")), this.timeout_ms = e.timeout_ms ?? 9e4, this.caller = new Vd({
      ...e.callerOptions ?? {},
      maxRetries: 4,
      debug: e.debug ?? this.debug
    }), this.traceBatchConcurrency = e.traceBatchConcurrency ?? this.traceBatchConcurrency, this.traceBatchConcurrency < 1)
      throw new Error("Trace batch concurrency must be positive.");
    this.debug = e.debug ?? this.debug, this.fetchImplementation = e.fetchImplementation;
    const n = e.maxIngestMemoryBytes ?? ng;
    this.batchIngestCaller = new Vd({
      maxRetries: 4,
      maxConcurrency: this.traceBatchConcurrency,
      maxQueueSizeBytes: n,
      ...e.callerOptions ?? {},
      onFailedResponseHook: pS,
      debug: e.debug ?? this.debug
    }), this.hideInputs = e.hideInputs ?? e.anonymizer ?? t.hideInputs, this.hideOutputs = e.hideOutputs ?? e.anonymizer ?? t.hideOutputs, this.autoBatchTracing = e.autoBatchTracing ?? this.autoBatchTracing, this.autoBatchQueue = new yS(n), this.blockOnRootRunFinalization = e.blockOnRootRunFinalization ?? this.blockOnRootRunFinalization, this.batchSizeBytesLimit = e.batchSizeBytesLimit, this.batchSizeLimit = e.batchSizeLimit, this.fetchOptions = e.fetchOptions || {}, this.manualFlushMode = e.manualFlushMode ?? this.manualFlushMode, qm() && (this.langSmithToOTELTranslator = new Jb()), this.cachedLSEnvVarsForMetadata = Vm();
  }
  static getDefaultClientConfig() {
    const e = Nt("API_KEY"), t = Nt("ENDPOINT") ?? nh, n = Nt("HIDE_INPUTS") === "true", s = Nt("HIDE_OUTPUTS") === "true";
    return {
      apiUrl: t,
      apiKey: e,
      webUrl: void 0,
      hideInputs: n,
      hideOutputs: s
    };
  }
  getHostUrl() {
    return this.webUrl ? this.webUrl : hS(this.apiUrl) ? (this.webUrl = "http://localhost:3000", this.webUrl) : this.apiUrl.endsWith("/api/v1") ? (this.webUrl = this.apiUrl.replace("/api/v1", ""), this.webUrl) : this.apiUrl.includes("/api") && !this.apiUrl.split(".", 1)[0].endsWith("api") ? (this.webUrl = this.apiUrl.replace("/api", ""), this.webUrl) : this.apiUrl.split(".", 1)[0].includes("dev") ? (this.webUrl = "https://dev.smith.langchain.com", this.webUrl) : this.apiUrl.split(".", 1)[0].includes("eu") ? (this.webUrl = "https://eu.smith.langchain.com", this.webUrl) : this.apiUrl.split(".", 1)[0].includes("beta") ? (this.webUrl = "https://beta.smith.langchain.com", this.webUrl) : (this.webUrl = "https://smith.langchain.com", this.webUrl);
  }
  get headers() {
    const e = {
      "User-Agent": `langsmith-js/${Um}`
    };
    return this.apiKey && (e["x-api-key"] = `${this.apiKey}`), this.workspaceId && (e["x-tenant-id"] = this.workspaceId), e;
  }
  _getPlatformEndpointPath(e) {
    return this.apiUrl.slice(-3) !== "/v1" && this.apiUrl.slice(-4) !== "/v1/" ? `/v1/platform/${e}` : `/platform/${e}`;
  }
  async processInputs(e) {
    return this.hideInputs === !1 ? e : this.hideInputs === !0 ? {} : typeof this.hideInputs == "function" ? this.hideInputs(e) : e;
  }
  async processOutputs(e) {
    return this.hideOutputs === !1 ? e : this.hideOutputs === !0 ? {} : typeof this.hideOutputs == "function" ? this.hideOutputs(e) : e;
  }
  async prepareRunCreateOrUpdateInputs(e) {
    const t = { ...e };
    return t.inputs !== void 0 && (t.inputs = await this.processInputs(t.inputs)), t.outputs !== void 0 && (t.outputs = await this.processOutputs(t.outputs)), t;
  }
  async _getResponse(e, t) {
    const n = (t == null ? void 0 : t.toString()) ?? "", s = `${this.apiUrl}${e}?${n}`;
    return await this.caller.call(async () => {
      const i = await this._fetch(s, {
        method: "GET",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      return await re(i, `fetch ${e}`), i;
    });
  }
  async _get(e, t) {
    return (await this._getResponse(e, t)).json();
  }
  async *_getPaginated(e, t = new URLSearchParams(), n) {
    let s = Number(t.get("offset")) || 0;
    const a = Number(t.get("limit")) || 100;
    for (; ; ) {
      t.set("offset", String(s)), t.set("limit", String(a));
      const i = `${this.apiUrl}${e}?${t}`, o = await this.caller.call(async () => {
        const u = await this._fetch(i, {
          method: "GET",
          headers: this.headers,
          signal: AbortSignal.timeout(this.timeout_ms),
          ...this.fetchOptions
        });
        return await re(u, `fetch ${e}`), u;
      }), c = n ? n(await o.json()) : await o.json();
      if (c.length === 0 || (yield c, c.length < a))
        break;
      s += c.length;
    }
  }
  async *_getCursorPaginatedList(e, t = null, n = "POST", s = "runs") {
    const a = t ? { ...t } : {};
    for (; ; ) {
      const i = JSON.stringify(a), c = await (await this.caller.call(async () => {
        const l = await this._fetch(`${this.apiUrl}${e}`, {
          method: n,
          headers: { ...this.headers, "Content-Type": "application/json" },
          signal: AbortSignal.timeout(this.timeout_ms),
          ...this.fetchOptions,
          body: i
        });
        return await re(l, `fetch ${e}`), l;
      })).json();
      if (!c || !c[s])
        break;
      yield c[s];
      const u = c.cursors;
      if (!u || !u.next)
        break;
      a.cursor = u.next;
    }
  }
  // Allows mocking for tests
  _shouldSample() {
    return this.tracingSampleRate === void 0 ? !0 : Math.random() < this.tracingSampleRate;
  }
  _filterForSampling(e, t = !1) {
    if (this.tracingSampleRate === void 0)
      return e;
    if (t) {
      const n = [];
      for (const s of e)
        this.filteredPostUuids.has(s.trace_id) ? s.id === s.trace_id && this.filteredPostUuids.delete(s.trace_id) : n.push(s);
      return n;
    } else {
      const n = [];
      for (const s of e) {
        const a = s.trace_id ?? s.id;
        this.filteredPostUuids.has(a) || (s.id === a ? this._shouldSample() ? n.push(s) : this.filteredPostUuids.add(a) : n.push(s));
      }
      return n;
    }
  }
  async _getBatchSizeLimitBytes() {
    var t;
    const e = await this._ensureServerInfo();
    return this.batchSizeBytesLimit ?? ((t = e.batch_ingest_config) == null ? void 0 : t.size_limit_bytes) ?? mS;
  }
  /**
   * Get the maximum number of operations to batch in a single request.
   */
  async _getBatchSizeLimit() {
    var t;
    const e = await this._ensureServerInfo();
    return this.batchSizeLimit ?? ((t = e.batch_ingest_config) == null ? void 0 : t.size_limit) ?? _S;
  }
  async _getDatasetExamplesMultiPartSupport() {
    var t;
    return ((t = (await this._ensureServerInfo()).instance_flags) == null ? void 0 : t.dataset_examples_multipart_enabled) ?? !1;
  }
  drainAutoBatchQueue({ batchSizeLimitBytes: e, batchSizeLimit: t }) {
    const n = [];
    for (; this.autoBatchQueue.items.length > 0; ) {
      const [s, a] = this.autoBatchQueue.pop({
        upToSizeBytes: e,
        upToSize: t
      });
      if (!s.length) {
        a();
        break;
      }
      const i = s.reduce((u, l) => {
        const d = l.apiUrl ?? this.apiUrl, h = l.apiKey ?? this.apiKey, p = l.apiKey === this.apiKey && l.apiUrl === this.apiUrl ? "default" : `${d}|${h}`;
        return u[p] || (u[p] = []), u[p].push(l), u;
      }, {}), o = [];
      for (const [u, l] of Object.entries(i)) {
        const d = this._processBatch(l, {
          apiUrl: u === "default" ? void 0 : u.split("|")[0],
          apiKey: u === "default" ? void 0 : u.split("|")[1]
        });
        o.push(d);
      }
      const c = Promise.all(o).finally(a);
      n.push(c);
    }
    return Promise.all(n);
  }
  async _processBatch(e, t) {
    var s, a;
    if (!e.length)
      return;
    const n = e.reduce((i, o) => i + (o.size ?? 0), 0);
    try {
      if (this.langSmithToOTELTranslator !== void 0)
        this._sendBatchToOTELTranslator(e);
      else {
        const i = {
          runCreates: e.filter((c) => c.action === "create").map((c) => c.item),
          runUpdates: e.filter((c) => c.action === "update").map((c) => c.item)
        }, o = await this._ensureServerInfo();
        if ((s = o == null ? void 0 : o.batch_ingest_config) != null && s.use_multipart_endpoint) {
          const c = (a = o == null ? void 0 : o.instance_flags) == null ? void 0 : a.gzip_body_enabled;
          await this.multipartIngestRuns(i, {
            ...t,
            useGzip: c,
            sizeBytes: n
          });
        } else
          await this.batchIngestRuns(i, {
            ...t,
            sizeBytes: n
          });
      }
    } catch (i) {
      console.error("Error exporting batch:", i);
    }
  }
  _sendBatchToOTELTranslator(e) {
    if (this.langSmithToOTELTranslator !== void 0) {
      const t = /* @__PURE__ */ new Map(), n = [];
      for (const s of e)
        s.item.id && s.otelContext && (t.set(s.item.id, s.otelContext), s.action === "create" ? n.push({
          operation: "post",
          id: s.item.id,
          trace_id: s.item.trace_id ?? s.item.id,
          run: s.item
        }) : n.push({
          operation: "patch",
          id: s.item.id,
          trace_id: s.item.trace_id ?? s.item.id,
          run: s.item
        }));
      this.langSmithToOTELTranslator.exportBatch(n, t);
    }
  }
  async processRunOperation(e) {
    clearTimeout(this.autoBatchTimeout), this.autoBatchTimeout = void 0, e.item = th(e.item, this.cachedLSEnvVarsForMetadata);
    const t = this.autoBatchQueue.push(e);
    if (this.manualFlushMode)
      return t;
    const n = await this._getBatchSizeLimitBytes(), s = await this._getBatchSizeLimit();
    return (this.autoBatchQueue.sizeBytes > n || this.autoBatchQueue.items.length > s) && this.drainAutoBatchQueue({
      batchSizeLimitBytes: n,
      batchSizeLimit: s
    }), this.autoBatchQueue.items.length > 0 && (this.autoBatchTimeout = setTimeout(() => {
      this.autoBatchTimeout = void 0, this.drainAutoBatchQueue({
        batchSizeLimitBytes: n,
        batchSizeLimit: s
      });
    }, this.autoBatchAggregationDelayMs)), t;
  }
  async _getServerInfo() {
    const t = await (await this.caller.call(async () => {
      const n = await this._fetch(`${this.apiUrl}/info`, {
        method: "GET",
        headers: { Accept: "application/json" },
        signal: AbortSignal.timeout(gS),
        ...this.fetchOptions
      });
      return await re(n, "get server info"), n;
    })).json();
    return this.debug && console.log(`
=== LangSmith Server Configuration ===
` + JSON.stringify(t, null, 2) + `
`), t;
  }
  async _ensureServerInfo() {
    return this._getServerInfoPromise === void 0 && (this._getServerInfoPromise = (async () => {
      if (this._serverInfo === void 0)
        try {
          this._serverInfo = await this._getServerInfo();
        } catch (e) {
          console.warn(`[LANGSMITH]: Failed to fetch info on supported operations. Falling back to batch operations and default limits. Info: ${e.status ?? "Unspecified status code"} ${e.message}`);
        }
      return this._serverInfo ?? {};
    })()), this._getServerInfoPromise.then((e) => (this._serverInfo === void 0 && (this._getServerInfoPromise = void 0), e));
  }
  async _getSettings() {
    return this.settings || (this.settings = this._get("/settings")), await this.settings;
  }
  /**
   * Flushes current queued traces.
   */
  async flush() {
    const e = await this._getBatchSizeLimitBytes(), t = await this._getBatchSizeLimit();
    await this.drainAutoBatchQueue({
      batchSizeLimitBytes: e,
      batchSizeLimit: t
    });
  }
  _cloneCurrentOTELContext() {
    const e = Hm(), t = Zb();
    if (this.langSmithToOTELTranslator !== void 0) {
      const n = e.getActiveSpan();
      if (n)
        return e.setSpan(t.active(), n);
    }
  }
  async createRun(e, t) {
    if (!this._filterForSampling([e]).length)
      return;
    const n = {
      ...this.headers,
      "Content-Type": "application/json"
    }, s = e.project_name;
    delete e.project_name;
    const a = await this.prepareRunCreateOrUpdateInputs({
      session_name: s,
      ...e,
      start_time: e.start_time ?? Date.now()
    });
    if (this.autoBatchTracing && a.trace_id !== void 0 && a.dotted_order !== void 0) {
      const c = this._cloneCurrentOTELContext();
      this.processRunOperation({
        action: "create",
        item: a,
        otelContext: c,
        apiKey: t == null ? void 0 : t.apiKey,
        apiUrl: t == null ? void 0 : t.apiUrl
      }).catch(console.error);
      return;
    }
    const i = th(a, this.cachedLSEnvVarsForMetadata);
    (t == null ? void 0 : t.apiKey) !== void 0 && (n["x-api-key"] = t.apiKey), (t == null ? void 0 : t.workspaceId) !== void 0 && (n["x-tenant-id"] = t.workspaceId);
    const o = jt(i, `Creating run with id: ${i.id}`);
    await this.caller.call(async () => {
      const c = await this._fetch(`${(t == null ? void 0 : t.apiUrl) ?? this.apiUrl}/runs`, {
        method: "POST",
        headers: n,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: o
      });
      return await re(c, "create run", !0), c;
    });
  }
  /**
   * Batch ingest/upsert multiple runs in the Langsmith system.
   * @param runs
   */
  async batchIngestRuns({ runCreates: e, runUpdates: t }, n) {
    if (e === void 0 && t === void 0)
      return;
    let s = await Promise.all((e == null ? void 0 : e.map((c) => this.prepareRunCreateOrUpdateInputs(c))) ?? []), a = await Promise.all((t == null ? void 0 : t.map((c) => this.prepareRunCreateOrUpdateInputs(c))) ?? []);
    if (s.length > 0 && a.length > 0) {
      const c = s.reduce((l, d) => (d.id && (l[d.id] = d), l), {}), u = [];
      for (const l of a)
        l.id !== void 0 && c[l.id] ? c[l.id] = {
          ...c[l.id],
          ...l
        } : u.push(l);
      s = Object.values(c), a = u;
    }
    const i = {
      post: s,
      patch: a
    };
    if (!i.post.length && !i.patch.length)
      return;
    const o = {
      post: [],
      patch: []
    };
    for (const c of ["post", "patch"]) {
      const u = c, l = i[u].reverse();
      let d = l.pop();
      for (; d !== void 0; )
        o[u].push(d), d = l.pop();
    }
    if (o.post.length > 0 || o.patch.length > 0) {
      const c = o.post.map((u) => u.id).concat(o.patch.map((u) => u.id)).join(",");
      await this._postBatchIngestRuns(jt(o, `Ingesting runs with ids: ${c}`), n);
    }
  }
  async _postBatchIngestRuns(e, t) {
    const n = {
      ...this.headers,
      "Content-Type": "application/json",
      Accept: "application/json"
    };
    (t == null ? void 0 : t.apiKey) !== void 0 && (n["x-api-key"] = t.apiKey), await this.batchIngestCaller.callWithOptions({ sizeBytes: t == null ? void 0 : t.sizeBytes }, async () => {
      const s = await this._fetch(`${(t == null ? void 0 : t.apiUrl) ?? this.apiUrl}/runs/batch`, {
        method: "POST",
        headers: n,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: e
      });
      return await re(s, "batch create run", !0), s;
    });
  }
  /**
   * Batch ingest/upsert multiple runs in the Langsmith system.
   * @param runs
   */
  async multipartIngestRuns({ runCreates: e, runUpdates: t }, n) {
    if (e === void 0 && t === void 0)
      return;
    const s = {};
    let a = [];
    for (const d of e ?? []) {
      const h = await this.prepareRunCreateOrUpdateInputs(d);
      h.id !== void 0 && h.attachments !== void 0 && (s[h.id] = h.attachments), delete h.attachments, a.push(h);
    }
    let i = [];
    for (const d of t ?? [])
      i.push(await this.prepareRunCreateOrUpdateInputs(d));
    if (a.find((d) => d.trace_id === void 0 || d.dotted_order === void 0) !== void 0)
      throw new Error('Multipart ingest requires "trace_id" and "dotted_order" to be set when creating a run');
    if (i.find((d) => d.trace_id === void 0 || d.dotted_order === void 0) !== void 0)
      throw new Error('Multipart ingest requires "trace_id" and "dotted_order" to be set when updating a run');
    if (a.length > 0 && i.length > 0) {
      const d = a.reduce((f, p) => (p.id && (f[p.id] = p), f), {}), h = [];
      for (const f of i)
        f.id !== void 0 && d[f.id] ? d[f.id] = {
          ...d[f.id],
          ...f
        } : h.push(f);
      a = Object.values(d), i = h;
    }
    if (a.length === 0 && i.length === 0)
      return;
    const u = [], l = [];
    for (const [d, h] of [
      ["post", a],
      ["patch", i]
    ])
      for (const f of h) {
        const { inputs: p, outputs: y, events: g, extra: S, error: _, serialized: w, attachments: T, ...x } = f, A = { inputs: p, outputs: y, events: g, extra: S, error: _, serialized: w }, R = jt(x, `Serializing for multipart ingestion of run with id: ${x.id}`);
        l.push({
          name: `${d}.${x.id}`,
          payload: new Blob([R], {
            type: `application/json; length=${R.length}`
            // encoding=gzip
          })
        });
        for (const [E, V] of Object.entries(A)) {
          if (V === void 0)
            continue;
          const ne = jt(V, `Serializing ${E} for multipart ingestion of run with id: ${x.id}`);
          l.push({
            name: `${d}.${x.id}.${E}`,
            payload: new Blob([ne], {
              type: `application/json; length=${ne.length}`
            })
          });
        }
        if (x.id !== void 0) {
          const E = s[x.id];
          if (E) {
            delete s[x.id];
            for (const [V, ne] of Object.entries(E)) {
              let z, Se;
              if (Array.isArray(ne) ? [z, Se] = ne : (z = ne.mimeType, Se = ne.data), V.includes(".")) {
                console.warn(`Skipping attachment '${V}' for run ${x.id}: Invalid attachment name. Attachment names must not contain periods ('.'). Please rename the attachment and try again.`);
                continue;
              }
              l.push({
                name: `attachment.${x.id}.${V}`,
                payload: new Blob([Se], {
                  type: `${z}; length=${Se.byteLength}`
                })
              });
            }
          }
        }
        u.push(`trace=${x.trace_id},id=${x.id}`);
      }
    await this._sendMultipartRequest(l, u.join("; "), n);
  }
  async _createNodeFetchBody(e, t) {
    const n = [];
    for (const i of e)
      n.push(new Blob([`--${t}\r
`])), n.push(new Blob([
        `Content-Disposition: form-data; name="${i.name}"\r
`,
        `Content-Type: ${i.payload.type}\r
\r
`
      ])), n.push(i.payload), n.push(new Blob([`\r
`]));
    return n.push(new Blob([`--${t}--\r
`])), await new Blob(n).arrayBuffer();
  }
  async _createMultipartStream(e, t) {
    const n = new TextEncoder();
    return new ReadableStream({
      async start(a) {
        const i = async (o) => {
          typeof o == "string" ? a.enqueue(n.encode(o)) : a.enqueue(o);
        };
        for (const o of e) {
          await i(`--${t}\r
`), await i(`Content-Disposition: form-data; name="${o.name}"\r
`), await i(`Content-Type: ${o.payload.type}\r
\r
`);
          const u = o.payload.stream().getReader();
          try {
            let l;
            for (; !(l = await u.read()).done; )
              a.enqueue(l.value);
          } finally {
            u.releaseLock();
          }
          await i(`\r
`);
        }
        await i(`--${t}--\r
`), a.close();
      }
    });
  }
  async _sendMultipartRequest(e, t, n) {
    const s = "----LangSmithFormBoundary" + Math.random().toString(36).slice(2), a = kb(), i = () => this._createNodeFetchBody(e, s), o = () => this._createMultipartStream(e, s), c = async (u) => this.batchIngestCaller.callWithOptions({ sizeBytes: n == null ? void 0 : n.sizeBytes }, async () => {
      const l = await u(), d = {
        ...this.headers,
        "Content-Type": `multipart/form-data; boundary=${s}`
      };
      (n == null ? void 0 : n.apiKey) !== void 0 && (d["x-api-key"] = n.apiKey);
      let h = l;
      n != null && n.useGzip && typeof l == "object" && "pipeThrough" in l && (h = l.pipeThrough(new CompressionStream("gzip")), d["Content-Encoding"] = "gzip");
      const f = await this._fetch(`${(n == null ? void 0 : n.apiUrl) ?? this.apiUrl}/runs/multipart`, {
        method: "POST",
        headers: d,
        body: h,
        duplex: "half",
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      return await re(f, "Failed to send multipart request", !0), f;
    });
    try {
      let u, l = !1;
      !a && !this.multipartStreamingDisabled && Bm() !== "bun" ? (l = !0, u = await c(o)) : u = await c(i), (!this.multipartStreamingDisabled || l) && u.status === 422 && ((n == null ? void 0 : n.apiUrl) ?? this.apiUrl) !== nh && (console.warn(`Streaming multipart upload to ${(n == null ? void 0 : n.apiUrl) ?? this.apiUrl}/runs/multipart failed. This usually means the host does not support chunked uploads. Retrying with a buffered upload for operation "${t}".`), this.multipartStreamingDisabled = !0, u = await c(i));
    } catch (u) {
      console.warn(`${u.message.trim()}

Context: ${t}`);
    }
  }
  async updateRun(e, t, n) {
    ye(e), t.inputs && (t.inputs = await this.processInputs(t.inputs)), t.outputs && (t.outputs = await this.processOutputs(t.outputs));
    const s = { ...t, id: e };
    if (!this._filterForSampling([s], !0).length)
      return;
    if (this.autoBatchTracing && s.trace_id !== void 0 && s.dotted_order !== void 0) {
      const o = this._cloneCurrentOTELContext();
      if (t.end_time !== void 0 && s.parent_run_id === void 0 && this.blockOnRootRunFinalization && !this.manualFlushMode) {
        await this.processRunOperation({
          action: "update",
          item: s,
          otelContext: o,
          apiKey: n == null ? void 0 : n.apiKey,
          apiUrl: n == null ? void 0 : n.apiUrl
        }).catch(console.error);
        return;
      } else
        this.processRunOperation({
          action: "update",
          item: s,
          otelContext: o,
          apiKey: n == null ? void 0 : n.apiKey,
          apiUrl: n == null ? void 0 : n.apiUrl
        }).catch(console.error);
      return;
    }
    const a = {
      ...this.headers,
      "Content-Type": "application/json"
    };
    (n == null ? void 0 : n.apiKey) !== void 0 && (a["x-api-key"] = n.apiKey), (n == null ? void 0 : n.workspaceId) !== void 0 && (a["x-tenant-id"] = n.workspaceId);
    const i = jt(t, `Serializing payload to update run with id: ${e}`);
    await this.caller.call(async () => {
      const o = await this._fetch(`${(n == null ? void 0 : n.apiUrl) ?? this.apiUrl}/runs/${e}`, {
        method: "PATCH",
        headers: a,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: i
      });
      return await re(o, "update run", !0), o;
    });
  }
  async readRun(e, { loadChildRuns: t } = { loadChildRuns: !1 }) {
    ye(e);
    let n = await this._get(`/runs/${e}`);
    return t && (n = await this._loadChildRuns(n)), n;
  }
  async getRunUrl({ runId: e, run: t, projectOpts: n }) {
    if (t !== void 0) {
      let s;
      t.session_id ? s = t.session_id : n != null && n.projectName ? s = (await this.readProject({ projectName: n == null ? void 0 : n.projectName })).id : n != null && n.projectId ? s = n == null ? void 0 : n.projectId : s = (await this.readProject({
        projectName: Nt("PROJECT") || "default"
      })).id;
      const a = await this._getTenantId();
      return `${this.getHostUrl()}/o/${a}/projects/p/${s}/r/${t.id}?poll=true`;
    } else if (e !== void 0) {
      const s = await this.readRun(e);
      if (!s.app_path)
        throw new Error(`Run ${e} has no app_path`);
      return `${this.getHostUrl()}${s.app_path}`;
    } else
      throw new Error("Must provide either runId or run");
  }
  async _loadChildRuns(e) {
    var a;
    const t = await fS(this.listRuns({
      isRoot: !1,
      projectId: e.session_id,
      traceId: e.trace_id
    })), n = {}, s = {};
    t.sort((i, o) => ((i == null ? void 0 : i.dotted_order) ?? "").localeCompare((o == null ? void 0 : o.dotted_order) ?? ""));
    for (const i of t) {
      if (i.parent_run_id === null || i.parent_run_id === void 0)
        throw new Error(`Child run ${i.id} has no parent`);
      (a = i.dotted_order) != null && a.startsWith(e.dotted_order ?? "") && i.id !== e.id && (i.parent_run_id in n || (n[i.parent_run_id] = []), n[i.parent_run_id].push(i), s[i.id] = i);
    }
    e.child_runs = n[e.id] || [];
    for (const i in n)
      i !== e.id && (s[i].child_runs = n[i]);
    return e;
  }
  /**
   * List runs from the LangSmith server.
   * @param projectId - The ID of the project to filter by.
   * @param projectName - The name of the project to filter by.
   * @param parentRunId - The ID of the parent run to filter by.
   * @param traceId - The ID of the trace to filter by.
   * @param referenceExampleId - The ID of the reference example to filter by.
   * @param startTime - The start time to filter by.
   * @param isRoot - Indicates whether to only return root runs.
   * @param runType - The run type to filter by.
   * @param error - Indicates whether to filter by error runs.
   * @param id - The ID of the run to filter by.
   * @param query - The query string to filter by.
   * @param filter - The filter string to apply to the run spans.
   * @param traceFilter - The filter string to apply on the root run of the trace.
   * @param treeFilter - The filter string to apply on other runs in the trace.
   * @param limit - The maximum number of runs to retrieve.
   * @returns {AsyncIterable<Run>} - The runs.
   *
   * @example
   * // List all runs in a project
   * const projectRuns = client.listRuns({ projectName: "<your_project>" });
   *
   * @example
   * // List LLM and Chat runs in the last 24 hours
   * const todaysLLMRuns = client.listRuns({
   *   projectName: "<your_project>",
   *   start_time: new Date(Date.now() - 24 * 60 * 60 * 1000),
   *   run_type: "llm",
   * });
   *
   * @example
   * // List traces in a project
   * const rootRuns = client.listRuns({
   *   projectName: "<your_project>",
   *   execution_order: 1,
   * });
   *
   * @example
   * // List runs without errors
   * const correctRuns = client.listRuns({
   *   projectName: "<your_project>",
   *   error: false,
   * });
   *
   * @example
   * // List runs by run ID
   * const runIds = [
   *   "a36092d2-4ad5-4fb4-9c0d-0dba9a2ed836",
   *   "9398e6be-964f-4aa4-8ae9-ad78cd4b7074",
   * ];
   * const selectedRuns = client.listRuns({ run_ids: runIds });
   *
   * @example
   * // List all "chain" type runs that took more than 10 seconds and had `total_tokens` greater than 5000
   * const chainRuns = client.listRuns({
   *   projectName: "<your_project>",
   *   filter: 'and(eq(run_type, "chain"), gt(latency, 10), gt(total_tokens, 5000))',
   * });
   *
   * @example
   * // List all runs called "extractor" whose root of the trace was assigned feedback "user_score" score of 1
   * const goodExtractorRuns = client.listRuns({
   *   projectName: "<your_project>",
   *   filter: 'eq(name, "extractor")',
   *   traceFilter: 'and(eq(feedback_key, "user_score"), eq(feedback_score, 1))',
   * });
   *
   * @example
   * // List all runs that started after a specific timestamp and either have "error" not equal to null or a "Correctness" feedback score equal to 0
   * const complexRuns = client.listRuns({
   *   projectName: "<your_project>",
   *   filter: 'and(gt(start_time, "2023-07-15T12:34:56Z"), or(neq(error, null), and(eq(feedback_key, "Correctness"), eq(feedback_score, 0.0))))',
   * });
   *
   * @example
   * // List all runs where `tags` include "experimental" or "beta" and `latency` is greater than 2 seconds
   * const taggedRuns = client.listRuns({
   *   projectName: "<your_project>",
   *   filter: 'and(or(has(tags, "experimental"), has(tags, "beta")), gt(latency, 2))',
   * });
   */
  async *listRuns(e) {
    const { projectId: t, projectName: n, parentRunId: s, traceId: a, referenceExampleId: i, startTime: o, executionOrder: c, isRoot: u, runType: l, error: d, id: h, query: f, filter: p, traceFilter: y, treeFilter: g, limit: S, select: _, order: w } = e;
    let T = [];
    if (t && (T = Array.isArray(t) ? t : [t]), n) {
      const E = Array.isArray(n) ? n : [n], V = await Promise.all(E.map((ne) => this.readProject({ projectName: ne }).then((z) => z.id)));
      T.push(...V);
    }
    const x = [
      "app_path",
      "completion_cost",
      "completion_tokens",
      "dotted_order",
      "end_time",
      "error",
      "events",
      "extra",
      "feedback_stats",
      "first_token_time",
      "id",
      "inputs",
      "name",
      "outputs",
      "parent_run_id",
      "parent_run_ids",
      "prompt_cost",
      "prompt_tokens",
      "reference_example_id",
      "run_type",
      "session_id",
      "start_time",
      "status",
      "tags",
      "total_cost",
      "total_tokens",
      "trace_id"
    ], A = {
      session: T.length ? T : null,
      run_type: l,
      reference_example: i,
      query: f,
      filter: p,
      trace_filter: y,
      tree_filter: g,
      execution_order: c,
      parent_run: s,
      start_time: o ? o.toISOString() : null,
      error: d,
      id: h,
      limit: S,
      trace: a,
      select: _ || x,
      is_root: u,
      order: w
    };
    A.select.includes("child_run_ids") && Mc("Deprecated: 'child_run_ids' in the listRuns select parameter is deprecated and will be removed in a future version.");
    let R = 0;
    for await (const E of this._getCursorPaginatedList("/runs/query", A))
      if (S) {
        if (R >= S)
          break;
        if (E.length + R > S) {
          yield* E.slice(0, S - R);
          break;
        }
        R += E.length, yield* E;
      } else
        yield* E;
  }
  async *listGroupRuns(e) {
    const { projectId: t, projectName: n, groupBy: s, filter: a, startTime: i, endTime: o, limit: c, offset: u } = e, d = {
      session_id: t || (await this.readProject({ projectName: n })).id,
      group_by: s,
      filter: a,
      start_time: i ? i.toISOString() : null,
      end_time: o ? o.toISOString() : null,
      limit: Number(c) || 100
    };
    let h = Number(u) || 0;
    const f = "/runs/group", p = `${this.apiUrl}${f}`;
    for (; ; ) {
      const y = {
        ...d,
        offset: h
      }, g = Object.fromEntries(Object.entries(y).filter(([A, R]) => R !== void 0)), S = JSON.stringify(g), w = await (await this.caller.call(async () => {
        const A = await this._fetch(p, {
          method: "POST",
          headers: { ...this.headers, "Content-Type": "application/json" },
          signal: AbortSignal.timeout(this.timeout_ms),
          ...this.fetchOptions,
          body: S
        });
        return await re(A, `Failed to fetch ${f}`), A;
      })).json(), { groups: T, total: x } = w;
      if (T.length === 0)
        break;
      for (const A of T)
        yield A;
      if (h += T.length, h >= x)
        break;
    }
  }
  async getRunStats({ id: e, trace: t, parentRun: n, runType: s, projectNames: a, projectIds: i, referenceExampleIds: o, startTime: c, endTime: u, error: l, query: d, filter: h, traceFilter: f, treeFilter: p, isRoot: y, dataSourceType: g }) {
    let S = i || [];
    a && (S = [
      ...i || [],
      ...await Promise.all(a.map((R) => this.readProject({ projectName: R }).then((E) => E.id)))
    ]);
    const w = Object.fromEntries(Object.entries({
      id: e,
      trace: t,
      parent_run: n,
      run_type: s,
      session: S,
      reference_example: o,
      start_time: c,
      end_time: u,
      error: l,
      query: d,
      filter: h,
      trace_filter: f,
      tree_filter: p,
      is_root: y,
      data_source_type: g
    }).filter(([R, E]) => E !== void 0)), T = JSON.stringify(w);
    return await (await this.caller.call(async () => {
      const R = await this._fetch(`${this.apiUrl}/runs/stats`, {
        method: "POST",
        headers: { ...this.headers, "Content-Type": "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: T
      });
      return await re(R, "get run stats"), R;
    })).json();
  }
  async shareRun(e, { shareId: t } = {}) {
    const n = {
      run_id: e,
      share_token: t || fs()
    };
    ye(e);
    const s = JSON.stringify(n), i = await (await this.caller.call(async () => {
      const o = await this._fetch(`${this.apiUrl}/runs/${e}/share`, {
        method: "PUT",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: s
      });
      return await re(o, "share run"), o;
    })).json();
    if (i === null || !("share_token" in i))
      throw new Error("Invalid response from server");
    return `${this.getHostUrl()}/public/${i.share_token}/r`;
  }
  async unshareRun(e) {
    ye(e), await this.caller.call(async () => {
      const t = await this._fetch(`${this.apiUrl}/runs/${e}/share`, {
        method: "DELETE",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      return await re(t, "unshare run", !0), t;
    });
  }
  async readRunSharedLink(e) {
    ye(e);
    const n = await (await this.caller.call(async () => {
      const s = await this._fetch(`${this.apiUrl}/runs/${e}/share`, {
        method: "GET",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      return await re(s, "read run shared link"), s;
    })).json();
    if (!(n === null || !("share_token" in n)))
      return `${this.getHostUrl()}/public/${n.share_token}/r`;
  }
  async listSharedRuns(e, { runIds: t } = {}) {
    const n = new URLSearchParams({
      share_token: e
    });
    if (t !== void 0)
      for (const i of t)
        n.append("id", i);
    return ye(e), await (await this.caller.call(async () => {
      const i = await this._fetch(`${this.apiUrl}/public/${e}/runs${n}`, {
        method: "GET",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      return await re(i, "list shared runs"), i;
    })).json();
  }
  async readDatasetSharedSchema(e, t) {
    if (!e && !t)
      throw new Error("Either datasetId or datasetName must be given");
    e || (e = (await this.readDataset({ datasetName: t })).id), ye(e);
    const s = await (await this.caller.call(async () => {
      const a = await this._fetch(`${this.apiUrl}/datasets/${e}/share`, {
        method: "GET",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      return await re(a, "read dataset shared schema"), a;
    })).json();
    return s.url = `${this.getHostUrl()}/public/${s.share_token}/d`, s;
  }
  async shareDataset(e, t) {
    if (!e && !t)
      throw new Error("Either datasetId or datasetName must be given");
    e || (e = (await this.readDataset({ datasetName: t })).id);
    const n = {
      dataset_id: e
    };
    ye(e);
    const s = JSON.stringify(n), i = await (await this.caller.call(async () => {
      const o = await this._fetch(`${this.apiUrl}/datasets/${e}/share`, {
        method: "PUT",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: s
      });
      return await re(o, "share dataset"), o;
    })).json();
    return i.url = `${this.getHostUrl()}/public/${i.share_token}/d`, i;
  }
  async unshareDataset(e) {
    ye(e), await this.caller.call(async () => {
      const t = await this._fetch(`${this.apiUrl}/datasets/${e}/share`, {
        method: "DELETE",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      return await re(t, "unshare dataset", !0), t;
    });
  }
  async readSharedDataset(e) {
    return ye(e), await (await this.caller.call(async () => {
      const s = await this._fetch(`${this.apiUrl}/public/${e}/datasets`, {
        method: "GET",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      return await re(s, "read shared dataset"), s;
    })).json();
  }
  /**
   * Get shared examples.
   *
   * @param {string} shareToken The share token to get examples for. A share token is the UUID (or LangSmith URL, including UUID) generated when explicitly marking an example as public.
   * @param {Object} [options] Additional options for listing the examples.
   * @param {string[] | undefined} [options.exampleIds] A list of example IDs to filter by.
   * @returns {Promise<Example[]>} The shared examples.
   */
  async listSharedExamples(e, t) {
    const n = {};
    t != null && t.exampleIds && (n.id = t.exampleIds);
    const s = new URLSearchParams();
    Object.entries(n).forEach(([o, c]) => {
      Array.isArray(c) ? c.forEach((u) => s.append(o, u)) : s.append(o, c);
    });
    const a = await this.caller.call(async () => {
      const o = await this._fetch(`${this.apiUrl}/public/${e}/examples?${s.toString()}`, {
        method: "GET",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      return await re(o, "list shared examples"), o;
    }), i = await a.json();
    if (!a.ok)
      throw "detail" in i ? new Error(`Failed to list shared examples.
Status: ${a.status}
Message: ${Array.isArray(i.detail) ? i.detail.join(`
`) : "Unspecified error"}`) : new Error(`Failed to list shared examples: ${a.status} ${a.statusText}`);
    return i.map((o) => ({
      ...o,
      _hostUrl: this.getHostUrl()
    }));
  }
  async createProject({ projectName: e, description: t = null, metadata: n = null, upsert: s = !1, projectExtra: a = null, referenceDatasetId: i = null }) {
    const o = s ? "?upsert=true" : "", c = `${this.apiUrl}/sessions${o}`, u = a || {};
    n && (u.metadata = n);
    const l = {
      name: e,
      extra: u,
      description: t
    };
    i !== null && (l.reference_dataset_id = i);
    const d = JSON.stringify(l);
    return await (await this.caller.call(async () => {
      const p = await this._fetch(c, {
        method: "POST",
        headers: { ...this.headers, "Content-Type": "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: d
      });
      return await re(p, "create project"), p;
    })).json();
  }
  async updateProject(e, { name: t = null, description: n = null, metadata: s = null, projectExtra: a = null, endTime: i = null }) {
    const o = `${this.apiUrl}/sessions/${e}`;
    let c = a;
    s && (c = { ...c || {}, metadata: s });
    const u = JSON.stringify({
      name: t,
      extra: c,
      description: n,
      end_time: i ? new Date(i).toISOString() : null
    });
    return await (await this.caller.call(async () => {
      const h = await this._fetch(o, {
        method: "PATCH",
        headers: { ...this.headers, "Content-Type": "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: u
      });
      return await re(h, "update project"), h;
    })).json();
  }
  async hasProject({ projectId: e, projectName: t }) {
    let n = "/sessions";
    const s = new URLSearchParams();
    if (e !== void 0 && t !== void 0)
      throw new Error("Must provide either projectName or projectId, not both");
    if (e !== void 0)
      ye(e), n += `/${e}`;
    else if (t !== void 0)
      s.append("name", t);
    else
      throw new Error("Must provide projectName or projectId");
    const a = await this.caller.call(async () => {
      const i = await this._fetch(`${this.apiUrl}${n}?${s}`, {
        method: "GET",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      return await re(i, "has project"), i;
    });
    try {
      const i = await a.json();
      return a.ok ? Array.isArray(i) ? i.length > 0 : !0 : !1;
    } catch {
      return !1;
    }
  }
  async readProject({ projectId: e, projectName: t, includeStats: n }) {
    let s = "/sessions";
    const a = new URLSearchParams();
    if (e !== void 0 && t !== void 0)
      throw new Error("Must provide either projectName or projectId, not both");
    if (e !== void 0)
      ye(e), s += `/${e}`;
    else if (t !== void 0)
      a.append("name", t);
    else
      throw new Error("Must provide projectName or projectId");
    n !== void 0 && a.append("include_stats", n.toString());
    const i = await this._get(s, a);
    let o;
    if (Array.isArray(i)) {
      if (i.length === 0)
        throw new Error(`Project[id=${e}, name=${t}] not found`);
      o = i[0];
    } else
      o = i;
    return o;
  }
  async getProjectUrl({ projectId: e, projectName: t }) {
    if (e === void 0 && t === void 0)
      throw new Error("Must provide either projectName or projectId");
    const n = await this.readProject({ projectId: e, projectName: t }), s = await this._getTenantId();
    return `${this.getHostUrl()}/o/${s}/projects/p/${n.id}`;
  }
  async getDatasetUrl({ datasetId: e, datasetName: t }) {
    if (e === void 0 && t === void 0)
      throw new Error("Must provide either datasetName or datasetId");
    const n = await this.readDataset({ datasetId: e, datasetName: t }), s = await this._getTenantId();
    return `${this.getHostUrl()}/o/${s}/datasets/${n.id}`;
  }
  async _getTenantId() {
    if (this._tenantId !== null)
      return this._tenantId;
    const e = new URLSearchParams({ limit: "1" });
    for await (const t of this._getPaginated("/sessions", e))
      return this._tenantId = t[0].tenant_id, t[0].tenant_id;
    throw new Error("No projects found to resolve tenant.");
  }
  async *listProjects({ projectIds: e, name: t, nameContains: n, referenceDatasetId: s, referenceDatasetName: a, includeStats: i, datasetVersion: o, referenceFree: c, metadata: u } = {}) {
    const l = new URLSearchParams();
    if (e !== void 0)
      for (const d of e)
        l.append("id", d);
    if (t !== void 0 && l.append("name", t), n !== void 0 && l.append("name_contains", n), s !== void 0)
      l.append("reference_dataset", s);
    else if (a !== void 0) {
      const d = await this.readDataset({
        datasetName: a
      });
      l.append("reference_dataset", d.id);
    }
    i !== void 0 && l.append("include_stats", i.toString()), o !== void 0 && l.append("dataset_version", o), c !== void 0 && l.append("reference_free", c.toString()), u !== void 0 && l.append("metadata", JSON.stringify(u));
    for await (const d of this._getPaginated("/sessions", l))
      yield* d;
  }
  async deleteProject({ projectId: e, projectName: t }) {
    let n;
    if (e === void 0 && t === void 0)
      throw new Error("Must provide projectName or projectId");
    if (e !== void 0 && t !== void 0)
      throw new Error("Must provide either projectName or projectId, not both");
    e === void 0 ? n = (await this.readProject({ projectName: t })).id : n = e, ye(n), await this.caller.call(async () => {
      const s = await this._fetch(`${this.apiUrl}/sessions/${n}`, {
        method: "DELETE",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      return await re(s, `delete session ${n} (${t})`, !0), s;
    });
  }
  async uploadCsv({ csvFile: e, fileName: t, inputKeys: n, outputKeys: s, description: a, dataType: i, name: o }) {
    const c = `${this.apiUrl}/datasets/upload`, u = new FormData();
    return u.append("file", e, t), n.forEach((h) => {
      u.append("input_keys", h);
    }), s.forEach((h) => {
      u.append("output_keys", h);
    }), a && u.append("description", a), i && u.append("data_type", i), o && u.append("name", o), await (await this.caller.call(async () => {
      const h = await this._fetch(c, {
        method: "POST",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: u
      });
      return await re(h, "upload CSV"), h;
    })).json();
  }
  async createDataset(e, { description: t, dataType: n, inputsSchema: s, outputsSchema: a, metadata: i } = {}) {
    const o = {
      name: e,
      description: t,
      extra: i ? { metadata: i } : void 0
    };
    n && (o.data_type = n), s && (o.inputs_schema_definition = s), a && (o.outputs_schema_definition = a);
    const c = JSON.stringify(o);
    return await (await this.caller.call(async () => {
      const d = await this._fetch(`${this.apiUrl}/datasets`, {
        method: "POST",
        headers: { ...this.headers, "Content-Type": "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: c
      });
      return await re(d, "create dataset"), d;
    })).json();
  }
  async readDataset({ datasetId: e, datasetName: t }) {
    let n = "/datasets";
    const s = new URLSearchParams({ limit: "1" });
    if (e && t)
      throw new Error("Must provide either datasetName or datasetId, not both");
    if (e)
      ye(e), n += `/${e}`;
    else if (t)
      s.append("name", t);
    else
      throw new Error("Must provide datasetName or datasetId");
    const a = await this._get(n, s);
    let i;
    if (Array.isArray(a)) {
      if (a.length === 0)
        throw new Error(`Dataset[id=${e}, name=${t}] not found`);
      i = a[0];
    } else
      i = a;
    return i;
  }
  async hasDataset({ datasetId: e, datasetName: t }) {
    try {
      return await this.readDataset({ datasetId: e, datasetName: t }), !0;
    } catch (n) {
      if (
        // eslint-disable-next-line no-instanceof/no-instanceof
        n instanceof Error && n.message.toLocaleLowerCase().includes("not found")
      )
        return !1;
      throw n;
    }
  }
  async diffDatasetVersions({ datasetId: e, datasetName: t, fromVersion: n, toVersion: s }) {
    let a = e;
    if (a === void 0 && t === void 0)
      throw new Error("Must provide either datasetName or datasetId");
    if (a !== void 0 && t !== void 0)
      throw new Error("Must provide either datasetName or datasetId, not both");
    a === void 0 && (a = (await this.readDataset({ datasetName: t })).id);
    const i = new URLSearchParams({
      from_version: typeof n == "string" ? n : n.toISOString(),
      to_version: typeof s == "string" ? s : s.toISOString()
    });
    return await this._get(`/datasets/${a}/versions/diff`, i);
  }
  async readDatasetOpenaiFinetuning({ datasetId: e, datasetName: t }) {
    const n = "/datasets";
    if (e === void 0) if (t !== void 0)
      e = (await this.readDataset({ datasetName: t })).id;
    else
      throw new Error("Must provide either datasetName or datasetId");
    return (await (await this._getResponse(`${n}/${e}/openai_ft`)).text()).trim().split(`
`).map((o) => JSON.parse(o));
  }
  async *listDatasets({ limit: e = 100, offset: t = 0, datasetIds: n, datasetName: s, datasetNameContains: a, metadata: i } = {}) {
    const o = "/datasets", c = new URLSearchParams({
      limit: e.toString(),
      offset: t.toString()
    });
    if (n !== void 0)
      for (const u of n)
        c.append("id", u);
    s !== void 0 && c.append("name", s), a !== void 0 && c.append("name_contains", a), i !== void 0 && c.append("metadata", JSON.stringify(i));
    for await (const u of this._getPaginated(o, c))
      yield* u;
  }
  /**
   * Update a dataset
   * @param props The dataset details to update
   * @returns The updated dataset
   */
  async updateDataset(e) {
    const { datasetId: t, datasetName: n, ...s } = e;
    if (!t && !n)
      throw new Error("Must provide either datasetName or datasetId");
    const a = t ?? (await this.readDataset({ datasetName: n })).id;
    ye(a);
    const i = JSON.stringify(s);
    return await (await this.caller.call(async () => {
      const c = await this._fetch(`${this.apiUrl}/datasets/${a}`, {
        method: "PATCH",
        headers: { ...this.headers, "Content-Type": "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: i
      });
      return await re(c, "update dataset"), c;
    })).json();
  }
  /**
   * Updates a tag on a dataset.
   *
   * If the tag is already assigned to a different version of this dataset,
   * the tag will be moved to the new version. The as_of parameter is used to
   * determine which version of the dataset to apply the new tags to.
   *
   * It must be an exact version of the dataset to succeed. You can
   * use the "readDatasetVersion" method to find the exact version
   * to apply the tags to.
   * @param params.datasetId The ID of the dataset to update. Must be provided if "datasetName" is not provided.
   * @param params.datasetName The name of the dataset to update. Must be provided if "datasetId" is not provided.
   * @param params.asOf The timestamp of the dataset to apply the new tags to.
   * @param params.tag The new tag to apply to the dataset.
   */
  async updateDatasetTag(e) {
    const { datasetId: t, datasetName: n, asOf: s, tag: a } = e;
    if (!t && !n)
      throw new Error("Must provide either datasetName or datasetId");
    const i = t ?? (await this.readDataset({ datasetName: n })).id;
    ye(i);
    const o = JSON.stringify({
      as_of: typeof s == "string" ? s : s.toISOString(),
      tag: a
    });
    await this.caller.call(async () => {
      const c = await this._fetch(`${this.apiUrl}/datasets/${i}/tags`, {
        method: "PUT",
        headers: { ...this.headers, "Content-Type": "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: o
      });
      return await re(c, "update dataset tags", !0), c;
    });
  }
  async deleteDataset({ datasetId: e, datasetName: t }) {
    let n = "/datasets", s = e;
    if (e !== void 0 && t !== void 0)
      throw new Error("Must provide either datasetName or datasetId, not both");
    if (t !== void 0 && (s = (await this.readDataset({ datasetName: t })).id), s !== void 0)
      ye(s), n += `/${s}`;
    else
      throw new Error("Must provide datasetName or datasetId");
    await this.caller.call(async () => {
      const a = await this._fetch(this.apiUrl + n, {
        method: "DELETE",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      return await re(a, `delete ${n}`, !0), a;
    });
  }
  async indexDataset({ datasetId: e, datasetName: t, tag: n }) {
    let s = e;
    if (!s && !t)
      throw new Error("Must provide either datasetName or datasetId");
    if (s && t)
      throw new Error("Must provide either datasetName or datasetId, not both");
    s || (s = (await this.readDataset({ datasetName: t })).id), ye(s);
    const i = JSON.stringify({
      tag: n
    });
    await (await this.caller.call(async () => {
      const c = await this._fetch(`${this.apiUrl}/datasets/${s}/index`, {
        method: "POST",
        headers: { ...this.headers, "Content-Type": "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: i
      });
      return await re(c, "index dataset"), c;
    })).json();
  }
  /**
   * Lets you run a similarity search query on a dataset.
   *
   * Requires the dataset to be indexed. Please see the `indexDataset` method to set up indexing.
   *
   * @param inputs      The input on which to run the similarity search. Must have the
   *                    same schema as the dataset.
   *
   * @param datasetId   The dataset to search for similar examples.
   *
   * @param limit       The maximum number of examples to return. Will return the top `limit` most
   *                    similar examples in order of most similar to least similar. If no similar
   *                    examples are found, random examples will be returned.
   *
   * @param filter      A filter string to apply to the search. Only examples will be returned that
   *                    match the filter string. Some examples of filters
   *
   *                    - eq(metadata.mykey, "value")
   *                    - and(neq(metadata.my.nested.key, "value"), neq(metadata.mykey, "value"))
   *                    - or(eq(metadata.mykey, "value"), eq(metadata.mykey, "othervalue"))
   *
   * @returns           A list of similar examples.
   *
   *
   * @example
   * dataset_id = "123e4567-e89b-12d3-a456-426614174000"
   * inputs = {"text": "How many people live in Berlin?"}
   * limit = 5
   * examples = await client.similarExamples(inputs, dataset_id, limit)
   */
  async similarExamples(e, t, n, { filter: s } = {}) {
    const a = {
      limit: n,
      inputs: e
    };
    s !== void 0 && (a.filter = s), ye(t);
    const i = JSON.stringify(a);
    return (await (await this.caller.call(async () => {
      const u = await this._fetch(`${this.apiUrl}/datasets/${t}/search`, {
        headers: { ...this.headers, "Content-Type": "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        method: "POST",
        body: i
      });
      return await re(u, "fetch similar examples"), u;
    })).json()).examples;
  }
  async createExample(e, t, n) {
    var l;
    if (sh(e) && (t !== void 0 || n !== void 0))
      throw new Error("Cannot provide outputs or options when using ExampleCreate object");
    let s = t ? n == null ? void 0 : n.datasetId : e.dataset_id;
    const a = t ? n == null ? void 0 : n.datasetName : e.dataset_name;
    if (s === void 0 && a === void 0)
      throw new Error("Must provide either datasetName or datasetId");
    if (s !== void 0 && a !== void 0)
      throw new Error("Must provide either datasetName or datasetId, not both");
    s === void 0 && (s = (await this.readDataset({ datasetName: a })).id);
    const i = (t ? n == null ? void 0 : n.createdAt : e.created_at) || /* @__PURE__ */ new Date();
    let o;
    sh(e) ? o = e : o = {
      inputs: e,
      outputs: t,
      created_at: i == null ? void 0 : i.toISOString(),
      id: n == null ? void 0 : n.exampleId,
      metadata: n == null ? void 0 : n.metadata,
      split: n == null ? void 0 : n.split,
      source_run_id: n == null ? void 0 : n.sourceRunId,
      use_source_run_io: n == null ? void 0 : n.useSourceRunIO,
      use_source_run_attachments: n == null ? void 0 : n.useSourceRunAttachments,
      attachments: n == null ? void 0 : n.attachments
    };
    const c = await this._uploadExamplesMultipart(s, [o]);
    return await this.readExample(((l = c.example_ids) == null ? void 0 : l[0]) ?? fs());
  }
  async createExamples(e) {
    if (Array.isArray(e)) {
      if (e.length === 0)
        return [];
      const _ = e;
      let w = _[0].dataset_id;
      const T = _[0].dataset_name;
      if (w === void 0 && T === void 0)
        throw new Error("Must provide either datasetName or datasetId");
      if (w !== void 0 && T !== void 0)
        throw new Error("Must provide either datasetName or datasetId, not both");
      w === void 0 && (w = (await this.readDataset({ datasetName: T })).id);
      const x = await this._uploadExamplesMultipart(w, _);
      return await Promise.all(x.example_ids.map((R) => this.readExample(R)));
    }
    const { inputs: t, outputs: n, metadata: s, splits: a, sourceRunIds: i, useSourceRunIOs: o, useSourceRunAttachments: c, attachments: u, exampleIds: l, datasetId: d, datasetName: h } = e;
    if (t === void 0)
      throw new Error("Must provide inputs when using legacy parameters");
    let f = d;
    const p = h;
    if (f === void 0 && p === void 0)
      throw new Error("Must provide either datasetName or datasetId");
    if (f !== void 0 && p !== void 0)
      throw new Error("Must provide either datasetName or datasetId, not both");
    f === void 0 && (f = (await this.readDataset({ datasetName: p })).id);
    const y = t.map((_, w) => ({
      dataset_id: f,
      inputs: _,
      outputs: n == null ? void 0 : n[w],
      metadata: s == null ? void 0 : s[w],
      split: a == null ? void 0 : a[w],
      id: l == null ? void 0 : l[w],
      attachments: u == null ? void 0 : u[w],
      source_run_id: i == null ? void 0 : i[w],
      use_source_run_io: o == null ? void 0 : o[w],
      use_source_run_attachments: c == null ? void 0 : c[w]
    })), g = await this._uploadExamplesMultipart(f, y);
    return await Promise.all(g.example_ids.map((_) => this.readExample(_)));
  }
  async createLLMExample(e, t, n) {
    return this.createExample({ input: e }, { output: t }, n);
  }
  async createChatExample(e, t, n) {
    const s = e.map((i) => qd(i) ? Hd(i) : i), a = qd(t) ? Hd(t) : t;
    return this.createExample({ input: s }, { output: a }, n);
  }
  async readExample(e) {
    ye(e);
    const t = `/examples/${e}`, n = await this._get(t), { attachment_urls: s, ...a } = n, i = a;
    return s && (i.attachments = Object.entries(s).reduce((o, [c, u]) => (o[c.slice(11)] = {
      presigned_url: u.presigned_url,
      mime_type: u.mime_type
    }, o), {})), i;
  }
  async *listExamples({ datasetId: e, datasetName: t, exampleIds: n, asOf: s, splits: a, inlineS3Urls: i, metadata: o, limit: c, offset: u, filter: l, includeAttachments: d } = {}) {
    let h;
    if (e !== void 0 && t !== void 0)
      throw new Error("Must provide either datasetName or datasetId, not both");
    if (e !== void 0)
      h = e;
    else if (t !== void 0)
      h = (await this.readDataset({ datasetName: t })).id;
    else
      throw new Error("Must provide a datasetName or datasetId");
    const f = new URLSearchParams({ dataset: h }), p = s ? typeof s == "string" ? s : s == null ? void 0 : s.toISOString() : void 0;
    p && f.append("as_of", p);
    const y = i ?? !0;
    if (f.append("inline_s3_urls", y.toString()), n !== void 0)
      for (const S of n)
        f.append("id", S);
    if (a !== void 0)
      for (const S of a)
        f.append("splits", S);
    if (o !== void 0) {
      const S = JSON.stringify(o);
      f.append("metadata", S);
    }
    c !== void 0 && f.append("limit", c.toString()), u !== void 0 && f.append("offset", u.toString()), l !== void 0 && f.append("filter", l), d === !0 && ["attachment_urls", "outputs", "metadata"].forEach((S) => f.append("select", S));
    let g = 0;
    for await (const S of this._getPaginated("/examples", f)) {
      for (const _ of S) {
        const { attachment_urls: w, ...T } = _, x = T;
        w && (x.attachments = Object.entries(w).reduce((A, [R, E]) => (A[R.slice(11)] = {
          presigned_url: E.presigned_url,
          mime_type: E.mime_type || void 0
        }, A), {})), yield x, g++;
      }
      if (c !== void 0 && g >= c)
        break;
    }
  }
  async deleteExample(e) {
    ye(e);
    const t = `/examples/${e}`;
    await this.caller.call(async () => {
      const n = await this._fetch(this.apiUrl + t, {
        method: "DELETE",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      return await re(n, `delete ${t}`, !0), n;
    });
  }
  /**
   * Delete multiple examples by ID.
   * @param exampleIds - The IDs of the examples to delete
   * @param options - Optional settings for deletion
   * @param options.hardDelete - If true, permanently delete examples. If false (default), soft delete them.
   */
  async deleteExamples(e, t) {
    if (e.forEach((n) => ye(n)), t != null && t.hardDelete) {
      const n = this._getPlatformEndpointPath("datasets/examples/delete");
      await this.caller.call(async () => {
        const s = await this._fetch(`${this.apiUrl}${n}`, {
          method: "POST",
          headers: { ...this.headers, "Content-Type": "application/json" },
          body: JSON.stringify({
            example_ids: e,
            hard_delete: !0
          }),
          signal: AbortSignal.timeout(this.timeout_ms),
          ...this.fetchOptions
        });
        return await re(s, "hard delete examples", !0), s;
      });
    } else {
      const n = new URLSearchParams();
      e.forEach((s) => n.append("example_ids", s)), await this.caller.call(async () => {
        const s = await this._fetch(`${this.apiUrl}/examples?${n.toString()}`, {
          method: "DELETE",
          headers: this.headers,
          signal: AbortSignal.timeout(this.timeout_ms),
          ...this.fetchOptions
        });
        return await re(s, "delete examples", !0), s;
      });
    }
  }
  async updateExample(e, t) {
    let n;
    t ? n = e : n = e.id, ye(n);
    let s;
    t ? s = { id: n, ...t } : s = e;
    let a;
    return s.dataset_id !== void 0 ? a = s.dataset_id : a = (await this.readExample(n)).dataset_id, this._updateExamplesMultipart(a, [s]);
  }
  async updateExamples(e) {
    let t;
    return e[0].dataset_id === void 0 ? t = (await this.readExample(e[0].id)).dataset_id : t = e[0].dataset_id, this._updateExamplesMultipart(t, e);
  }
  /**
   * Get dataset version by closest date or exact tag.
   *
   * Use this to resolve the nearest version to a given timestamp or for a given tag.
   *
   * @param options The options for getting the dataset version
   * @param options.datasetId The ID of the dataset
   * @param options.datasetName The name of the dataset
   * @param options.asOf The timestamp of the dataset to retrieve
   * @param options.tag The tag of the dataset to retrieve
   * @returns The dataset version
   */
  async readDatasetVersion({ datasetId: e, datasetName: t, asOf: n, tag: s }) {
    let a;
    if (e ? a = e : a = (await this.readDataset({ datasetName: t })).id, ye(a), n && s || !n && !s)
      throw new Error("Exactly one of asOf and tag must be specified.");
    const i = new URLSearchParams();
    return n !== void 0 && i.append("as_of", typeof n == "string" ? n : n.toISOString()), s !== void 0 && i.append("tag", s), await (await this.caller.call(async () => {
      const c = await this._fetch(`${this.apiUrl}/datasets/${a}/version?${i.toString()}`, {
        method: "GET",
        headers: { ...this.headers },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      return await re(c, "read dataset version"), c;
    })).json();
  }
  async listDatasetSplits({ datasetId: e, datasetName: t, asOf: n }) {
    let s;
    if (e === void 0 && t === void 0)
      throw new Error("Must provide dataset name or ID");
    if (e !== void 0 && t !== void 0)
      throw new Error("Must provide either datasetName or datasetId, not both");
    e === void 0 ? s = (await this.readDataset({ datasetName: t })).id : s = e, ye(s);
    const a = new URLSearchParams(), i = n ? typeof n == "string" ? n : n == null ? void 0 : n.toISOString() : void 0;
    return i && a.append("as_of", i), await this._get(`/datasets/${s}/splits`, a);
  }
  async updateDatasetSplits({ datasetId: e, datasetName: t, splitName: n, exampleIds: s, remove: a = !1 }) {
    let i;
    if (e === void 0 && t === void 0)
      throw new Error("Must provide dataset name or ID");
    if (e !== void 0 && t !== void 0)
      throw new Error("Must provide either datasetName or datasetId, not both");
    e === void 0 ? i = (await this.readDataset({ datasetName: t })).id : i = e, ye(i);
    const o = {
      split_name: n,
      examples: s.map((u) => (ye(u), u)),
      remove: a
    }, c = JSON.stringify(o);
    await this.caller.call(async () => {
      const u = await this._fetch(`${this.apiUrl}/datasets/${i}/splits`, {
        method: "PUT",
        headers: { ...this.headers, "Content-Type": "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: c
      });
      return await re(u, "update dataset splits", !0), u;
    });
  }
  /**
   * @deprecated This method is deprecated and will be removed in future LangSmith versions, use `evaluate` from `langsmith/evaluation` instead.
   */
  async evaluateRun(e, t, { sourceInfo: n, loadChildRuns: s, referenceExample: a } = { loadChildRuns: !1 }) {
    Mc("This method is deprecated and will be removed in future LangSmith versions, use `evaluate` from `langsmith/evaluation` instead.");
    let i;
    if (typeof e == "string")
      i = await this.readRun(e, { loadChildRuns: s });
    else if (typeof e == "object" && "id" in e)
      i = e;
    else
      throw new Error(`Invalid run type: ${typeof e}`);
    i.reference_example_id !== null && i.reference_example_id !== void 0 && (a = await this.readExample(i.reference_example_id));
    const o = await t.evaluateRun(i, a), [c, u] = await this._logEvaluationFeedback(o, i, n);
    return u[0];
  }
  async createFeedback(e, t, { score: n, value: s, correction: a, comment: i, sourceInfo: o, feedbackSourceType: c = "api", sourceRunId: u, feedbackId: l, feedbackConfig: d, projectId: h, comparativeExperimentId: f }) {
    var _;
    if (!e && !h)
      throw new Error("One of runId or projectId must be provided");
    if (e && h)
      throw new Error("Only one of runId or projectId can be provided");
    const p = {
      type: c ?? "api",
      metadata: o ?? {}
    };
    u !== void 0 && (p == null ? void 0 : p.metadata) !== void 0 && !p.metadata.__run && (p.metadata.__run = { run_id: u }), (p == null ? void 0 : p.metadata) !== void 0 && ((_ = p.metadata.__run) == null ? void 0 : _.run_id) !== void 0 && ye(p.metadata.__run.run_id);
    const y = {
      id: l ?? fs(),
      run_id: e,
      key: t,
      score: rh(n),
      value: s,
      correction: a,
      comment: i,
      feedback_source: p,
      comparative_experiment_id: f,
      feedbackConfig: d,
      session_id: h
    }, g = JSON.stringify(y), S = `${this.apiUrl}/feedback`;
    return await this.caller.call(async () => {
      const w = await this._fetch(S, {
        method: "POST",
        headers: { ...this.headers, "Content-Type": "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: g
      });
      return await re(w, "create feedback", !0), w;
    }), y;
  }
  async updateFeedback(e, { score: t, value: n, correction: s, comment: a }) {
    const i = {};
    t != null && (i.score = rh(t)), n != null && (i.value = n), s != null && (i.correction = s), a != null && (i.comment = a), ye(e);
    const o = JSON.stringify(i);
    await this.caller.call(async () => {
      const c = await this._fetch(`${this.apiUrl}/feedback/${e}`, {
        method: "PATCH",
        headers: { ...this.headers, "Content-Type": "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: o
      });
      return await re(c, "update feedback", !0), c;
    });
  }
  async readFeedback(e) {
    ye(e);
    const t = `/feedback/${e}`;
    return await this._get(t);
  }
  async deleteFeedback(e) {
    ye(e);
    const t = `/feedback/${e}`;
    await this.caller.call(async () => {
      const n = await this._fetch(this.apiUrl + t, {
        method: "DELETE",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      return await re(n, `delete ${t}`, !0), n;
    });
  }
  async *listFeedback({ runIds: e, feedbackKeys: t, feedbackSourceTypes: n } = {}) {
    const s = new URLSearchParams();
    if (e)
      for (const a of e)
        ye(a), s.append("run", a);
    if (t)
      for (const a of t)
        s.append("key", a);
    if (n)
      for (const a of n)
        s.append("source", a);
    for await (const a of this._getPaginated("/feedback", s))
      yield* a;
  }
  /**
   * Creates a presigned feedback token and URL.
   *
   * The token can be used to authorize feedback metrics without
   * needing an API key. This is useful for giving browser-based
   * applications the ability to submit feedback without needing
   * to expose an API key.
   *
   * @param runId The ID of the run.
   * @param feedbackKey The feedback key.
   * @param options Additional options for the token.
   * @param options.expiration The expiration time for the token.
   *
   * @returns A promise that resolves to a FeedbackIngestToken.
   */
  async createPresignedFeedbackToken(e, t, { expiration: n, feedbackConfig: s } = {}) {
    const a = {
      run_id: e,
      feedback_key: t,
      feedback_config: s
    };
    n ? typeof n == "string" ? a.expires_at = n : (n != null && n.hours || n != null && n.minutes || n != null && n.days) && (a.expires_in = n) : a.expires_in = {
      hours: 3
    };
    const i = JSON.stringify(a);
    return await (await this.caller.call(async () => {
      const c = await this._fetch(`${this.apiUrl}/feedback/tokens`, {
        method: "POST",
        headers: { ...this.headers, "Content-Type": "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: i
      });
      return await re(c, "create presigned feedback token"), c;
    })).json();
  }
  async createComparativeExperiment({ name: e, experimentIds: t, referenceDatasetId: n, createdAt: s, description: a, metadata: i, id: o }) {
    var d;
    if (t.length === 0)
      throw new Error("At least one experiment is required");
    if (n || (n = (await this.readProject({
      projectId: t[0]
    })).reference_dataset_id), !n == null)
      throw new Error("A reference dataset is required");
    const c = {
      id: o,
      name: e,
      experiment_ids: t,
      reference_dataset_id: n,
      description: a,
      created_at: (d = s ?? /* @__PURE__ */ new Date()) == null ? void 0 : d.toISOString(),
      extra: {}
    };
    i && (c.extra.metadata = i);
    const u = JSON.stringify(c);
    return (await this.caller.call(async () => {
      const h = await this._fetch(`${this.apiUrl}/datasets/comparative`, {
        method: "POST",
        headers: { ...this.headers, "Content-Type": "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: u
      });
      return await re(h, "create comparative experiment"), h;
    })).json();
  }
  /**
   * Retrieves a list of presigned feedback tokens for a given run ID.
   * @param runId The ID of the run.
   * @returns An async iterable of FeedbackIngestToken objects.
   */
  async *listPresignedFeedbackTokens(e) {
    ye(e);
    const t = new URLSearchParams({ run_id: e });
    for await (const n of this._getPaginated("/feedback/tokens", t))
      yield* n;
  }
  _selectEvalResults(e) {
    let t;
    return "results" in e ? t = e.results : Array.isArray(e) ? t = e : t = [e], t;
  }
  async _logEvaluationFeedback(e, t, n) {
    const s = this._selectEvalResults(e), a = [];
    for (const i of s) {
      let o = n || {};
      i.evaluatorInfo && (o = { ...i.evaluatorInfo, ...o });
      let c = null;
      i.targetRunId ? c = i.targetRunId : t && (c = t.id), a.push(await this.createFeedback(c, i.key, {
        score: i.score,
        value: i.value,
        comment: i.comment,
        correction: i.correction,
        sourceInfo: o,
        sourceRunId: i.sourceRunId,
        feedbackConfig: i.feedbackConfig,
        feedbackSourceType: "model"
      }));
    }
    return [s, a];
  }
  async logEvaluationFeedback(e, t, n) {
    const [s] = await this._logEvaluationFeedback(e, t, n);
    return s;
  }
  /**
   * API for managing annotation queues
   */
  /**
   * List the annotation queues on the LangSmith API.
   * @param options - The options for listing annotation queues
   * @param options.queueIds - The IDs of the queues to filter by
   * @param options.name - The name of the queue to filter by
   * @param options.nameContains - The substring that the queue name should contain
   * @param options.limit - The maximum number of queues to return
   * @returns An iterator of AnnotationQueue objects
   */
  async *listAnnotationQueues(e = {}) {
    const { queueIds: t, name: n, nameContains: s, limit: a } = e, i = new URLSearchParams();
    t && t.forEach((c, u) => {
      ye(c, `queueIds[${u}]`), i.append("ids", c);
    }), n && i.append("name", n), s && i.append("name_contains", s), i.append("limit", (a !== void 0 ? Math.min(a, 100) : 100).toString());
    let o = 0;
    for await (const c of this._getPaginated("/annotation-queues", i))
      if (yield* c, o++, a !== void 0 && o >= a)
        break;
  }
  /**
   * Create an annotation queue on the LangSmith API.
   * @param options - The options for creating an annotation queue
   * @param options.name - The name of the annotation queue
   * @param options.description - The description of the annotation queue
   * @param options.queueId - The ID of the annotation queue
   * @returns The created AnnotationQueue object
   */
  async createAnnotationQueue(e) {
    const { name: t, description: n, queueId: s, rubricInstructions: a } = e, i = {
      name: t,
      description: n,
      id: s || fs(),
      rubric_instructions: a
    }, o = JSON.stringify(Object.fromEntries(Object.entries(i).filter(([u, l]) => l !== void 0)));
    return (await this.caller.call(async () => {
      const u = await this._fetch(`${this.apiUrl}/annotation-queues`, {
        method: "POST",
        headers: { ...this.headers, "Content-Type": "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: o
      });
      return await re(u, "create annotation queue"), u;
    })).json();
  }
  /**
   * Read an annotation queue with the specified queue ID.
   * @param queueId - The ID of the annotation queue to read
   * @returns The AnnotationQueueWithDetails object
   */
  async readAnnotationQueue(e) {
    return (await this.caller.call(async () => {
      const n = await this._fetch(`${this.apiUrl}/annotation-queues/${ye(e, "queueId")}`, {
        method: "GET",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      return await re(n, "read annotation queue"), n;
    })).json();
  }
  /**
   * Update an annotation queue with the specified queue ID.
   * @param queueId - The ID of the annotation queue to update
   * @param options - The options for updating the annotation queue
   * @param options.name - The new name for the annotation queue
   * @param options.description - The new description for the annotation queue
   */
  async updateAnnotationQueue(e, t) {
    const { name: n, description: s, rubricInstructions: a } = t, i = JSON.stringify({
      name: n,
      description: s,
      rubric_instructions: a
    });
    await this.caller.call(async () => {
      const o = await this._fetch(`${this.apiUrl}/annotation-queues/${ye(e, "queueId")}`, {
        method: "PATCH",
        headers: { ...this.headers, "Content-Type": "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: i
      });
      return await re(o, "update annotation queue", !0), o;
    });
  }
  /**
   * Delete an annotation queue with the specified queue ID.
   * @param queueId - The ID of the annotation queue to delete
   */
  async deleteAnnotationQueue(e) {
    await this.caller.call(async () => {
      const t = await this._fetch(`${this.apiUrl}/annotation-queues/${ye(e, "queueId")}`, {
        method: "DELETE",
        headers: { ...this.headers, Accept: "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      return await re(t, "delete annotation queue", !0), t;
    });
  }
  /**
   * Add runs to an annotation queue with the specified queue ID.
   * @param queueId - The ID of the annotation queue
   * @param runIds - The IDs of the runs to be added to the annotation queue
   */
  async addRunsToAnnotationQueue(e, t) {
    const n = JSON.stringify(t.map((s, a) => ye(s, `runIds[${a}]`).toString()));
    await this.caller.call(async () => {
      const s = await this._fetch(`${this.apiUrl}/annotation-queues/${ye(e, "queueId")}/runs`, {
        method: "POST",
        headers: { ...this.headers, "Content-Type": "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: n
      });
      return await re(s, "add runs to annotation queue", !0), s;
    });
  }
  /**
   * Get a run from an annotation queue at the specified index.
   * @param queueId - The ID of the annotation queue
   * @param index - The index of the run to retrieve
   * @returns A Promise that resolves to a RunWithAnnotationQueueInfo object
   * @throws {Error} If the run is not found at the given index or for other API-related errors
   */
  async getRunFromAnnotationQueue(e, t) {
    const n = `/annotation-queues/${ye(e, "queueId")}/run`;
    return (await this.caller.call(async () => {
      const a = await this._fetch(`${this.apiUrl}${n}/${t}`, {
        method: "GET",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      return await re(a, "get run from annotation queue"), a;
    })).json();
  }
  /**
   * Delete a run from an an annotation queue.
   * @param queueId - The ID of the annotation queue to delete the run from
   * @param queueRunId - The ID of the run to delete from the annotation queue
   */
  async deleteRunFromAnnotationQueue(e, t) {
    await this.caller.call(async () => {
      const n = await this._fetch(`${this.apiUrl}/annotation-queues/${ye(e, "queueId")}/runs/${ye(t, "queueRunId")}`, {
        method: "DELETE",
        headers: { ...this.headers, Accept: "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      return await re(n, "delete run from annotation queue", !0), n;
    });
  }
  /**
   * Get the size of an annotation queue.
   * @param queueId - The ID of the annotation queue
   */
  async getSizeFromAnnotationQueue(e) {
    return (await this.caller.call(async () => {
      const n = await this._fetch(`${this.apiUrl}/annotation-queues/${ye(e, "queueId")}/size`, {
        method: "GET",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      return await re(n, "get size from annotation queue"), n;
    })).json();
  }
  async _currentTenantIsOwner(e) {
    const t = await this._getSettings();
    return e == "-" || t.tenant_handle === e;
  }
  async _ownerConflictError(e, t) {
    const n = await this._getSettings();
    return new Error(`Cannot ${e} for another tenant.

      Current tenant: ${n.tenant_handle}

      Requested tenant: ${t}`);
  }
  async _getLatestCommitHash(e) {
    const n = await (await this.caller.call(async () => {
      const s = await this._fetch(`${this.apiUrl}/commits/${e}/?limit=1&offset=0`, {
        method: "GET",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      return await re(s, "get latest commit hash"), s;
    })).json();
    if (n.commits.length !== 0)
      return n.commits[0].commit_hash;
  }
  async _likeOrUnlikePrompt(e, t) {
    const [n, s, a] = Gr(e), i = JSON.stringify({ like: t });
    return (await this.caller.call(async () => {
      const c = await this._fetch(`${this.apiUrl}/likes/${n}/${s}`, {
        method: "POST",
        headers: { ...this.headers, "Content-Type": "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: i
      });
      return await re(c, `${t ? "like" : "unlike"} prompt`), c;
    })).json();
  }
  async _getPromptUrl(e) {
    const [t, n, s] = Gr(e);
    if (await this._currentTenantIsOwner(t)) {
      const a = await this._getSettings();
      return s !== "latest" ? `${this.getHostUrl()}/prompts/${n}/${s.substring(0, 8)}?organizationId=${a.id}` : `${this.getHostUrl()}/prompts/${n}?organizationId=${a.id}`;
    } else
      return s !== "latest" ? `${this.getHostUrl()}/hub/${t}/${n}/${s.substring(0, 8)}` : `${this.getHostUrl()}/hub/${t}/${n}`;
  }
  async promptExists(e) {
    return !!await this.getPrompt(e);
  }
  async likePrompt(e) {
    return this._likeOrUnlikePrompt(e, !0);
  }
  async unlikePrompt(e) {
    return this._likeOrUnlikePrompt(e, !1);
  }
  async *listCommits(e) {
    for await (const t of this._getPaginated(`/commits/${e}/`, new URLSearchParams(), (n) => n.commits))
      yield* t;
  }
  async *listPrompts(e) {
    const t = new URLSearchParams();
    t.append("sort_field", (e == null ? void 0 : e.sortField) ?? "updated_at"), t.append("sort_direction", "desc"), t.append("is_archived", (!!(e != null && e.isArchived)).toString()), (e == null ? void 0 : e.isPublic) !== void 0 && t.append("is_public", e.isPublic.toString()), e != null && e.query && t.append("query", e.query);
    for await (const n of this._getPaginated("/repos", t, (s) => s.repos))
      yield* n;
  }
  async getPrompt(e) {
    const [t, n, s] = Gr(e), a = await this.caller.call(async () => {
      const o = await this._fetch(`${this.apiUrl}/repos/${t}/${n}`, {
        method: "GET",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      return (o == null ? void 0 : o.status) === 404 ? null : (await re(o, "get prompt"), o);
    }), i = await (a == null ? void 0 : a.json());
    return i != null && i.repo ? i.repo : null;
  }
  async createPrompt(e, t) {
    const n = await this._getSettings();
    if (t != null && t.isPublic && !n.tenant_handle)
      throw new Error(`Cannot create a public prompt without first

        creating a LangChain Hub handle.
        You can add a handle by creating a public prompt at:

        https://smith.langchain.com/prompts`);
    const [s, a, i] = Gr(e);
    if (!await this._currentTenantIsOwner(s))
      throw await this._ownerConflictError("create a prompt", s);
    const o = {
      repo_handle: a,
      ...(t == null ? void 0 : t.description) && { description: t.description },
      ...(t == null ? void 0 : t.readme) && { readme: t.readme },
      ...(t == null ? void 0 : t.tags) && { tags: t.tags },
      is_public: !!(t != null && t.isPublic)
    }, c = JSON.stringify(o), u = await this.caller.call(async () => {
      const d = await this._fetch(`${this.apiUrl}/repos/`, {
        method: "POST",
        headers: { ...this.headers, "Content-Type": "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: c
      });
      return await re(d, "create prompt"), d;
    }), { repo: l } = await u.json();
    return l;
  }
  async createCommit(e, t, n) {
    if (!await this.promptExists(e))
      throw new Error("Prompt does not exist, you must create it first.");
    const [s, a, i] = Gr(e), o = (n == null ? void 0 : n.parentCommitHash) === "latest" || !(n != null && n.parentCommitHash) ? await this._getLatestCommitHash(`${s}/${a}`) : n == null ? void 0 : n.parentCommitHash, c = {
      manifest: JSON.parse(JSON.stringify(t)),
      parent_commit: o
    }, u = JSON.stringify(c), d = await (await this.caller.call(async () => {
      const h = await this._fetch(`${this.apiUrl}/commits/${s}/${a}`, {
        method: "POST",
        headers: { ...this.headers, "Content-Type": "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: u
      });
      return await re(h, "create commit"), h;
    })).json();
    return this._getPromptUrl(`${s}/${a}${d.commit_hash ? `:${d.commit_hash}` : ""}`);
  }
  /**
   * Update examples with attachments using multipart form data.
   * @param updates List of ExampleUpdateWithAttachments objects to upsert
   * @returns Promise with the update response
   */
  async updateExamplesMultipart(e, t = []) {
    return this._updateExamplesMultipart(e, t);
  }
  async _updateExamplesMultipart(e, t = []) {
    var i;
    if (!await this._getDatasetExamplesMultiPartSupport())
      throw new Error("Your LangSmith deployment does not allow using the multipart examples endpoint, please upgrade your deployment to the latest version.");
    const n = new FormData();
    for (const o of t) {
      const c = o.id, u = {
        ...o.metadata && { metadata: o.metadata },
        ...o.split && { split: o.split }
      }, l = jt(u, `Serializing body for example with id: ${c}`), d = new Blob([l], {
        type: "application/json"
      });
      if (n.append(c, d), o.inputs) {
        const h = jt(o.inputs, `Serializing inputs for example with id: ${c}`), f = new Blob([h], {
          type: "application/json"
        });
        n.append(`${c}.inputs`, f);
      }
      if (o.outputs) {
        const h = jt(o.outputs, `Serializing outputs whle updating example with id: ${c}`), f = new Blob([h], {
          type: "application/json"
        });
        n.append(`${c}.outputs`, f);
      }
      if (o.attachments)
        for (const [h, f] of Object.entries(o.attachments)) {
          let p, y;
          Array.isArray(f) ? [p, y] = f : (p = f.mimeType, y = f.data);
          const g = new Blob([y], {
            type: `${p}; length=${y.byteLength}`
          });
          n.append(`${c}.attachment.${h}`, g);
        }
      if (o.attachments_operations) {
        const h = jt(o.attachments_operations, `Serializing attachments while updating example with id: ${c}`), f = new Blob([h], {
          type: "application/json"
        });
        n.append(`${c}.attachments_operations`, f);
      }
    }
    const s = e ?? ((i = t[0]) == null ? void 0 : i.dataset_id);
    return (await this.caller.call(async () => {
      const o = await this._fetch(`${this.apiUrl}${this._getPlatformEndpointPath(`datasets/${s}/examples`)}`, {
        method: "PATCH",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: n
      });
      return await re(o, "update examples"), o;
    })).json();
  }
  /**
   * Upload examples with attachments using multipart form data.
   * @param uploads List of ExampleUploadWithAttachments objects to upload
   * @returns Promise with the upload response
   * @deprecated This method is deprecated and will be removed in future LangSmith versions, please use `createExamples` instead
   */
  async uploadExamplesMultipart(e, t = []) {
    return this._uploadExamplesMultipart(e, t);
  }
  async _uploadExamplesMultipart(e, t = []) {
    if (!await this._getDatasetExamplesMultiPartSupport())
      throw new Error("Your LangSmith deployment does not allow using the multipart examples endpoint, please upgrade your deployment to the latest version.");
    const n = new FormData();
    for (const a of t) {
      const i = (a.id ?? fs()).toString(), o = {
        created_at: a.created_at,
        ...a.metadata && { metadata: a.metadata },
        ...a.split && { split: a.split },
        ...a.source_run_id && { source_run_id: a.source_run_id },
        ...a.use_source_run_io && {
          use_source_run_io: a.use_source_run_io
        },
        ...a.use_source_run_attachments && {
          use_source_run_attachments: a.use_source_run_attachments
        }
      }, c = jt(o, `Serializing body for uploaded example with id: ${i}`), u = new Blob([c], {
        type: "application/json"
      });
      if (n.append(i, u), a.inputs) {
        const l = jt(a.inputs, `Serializing inputs for uploaded example with id: ${i}`), d = new Blob([l], {
          type: "application/json"
        });
        n.append(`${i}.inputs`, d);
      }
      if (a.outputs) {
        const l = jt(a.outputs, `Serializing outputs for uploaded example with id: ${i}`), d = new Blob([l], {
          type: "application/json"
        });
        n.append(`${i}.outputs`, d);
      }
      if (a.attachments)
        for (const [l, d] of Object.entries(a.attachments)) {
          let h, f;
          Array.isArray(d) ? [h, f] = d : (h = d.mimeType, f = d.data);
          const p = new Blob([f], {
            type: `${h}; length=${f.byteLength}`
          });
          n.append(`${i}.attachment.${l}`, p);
        }
    }
    return (await this.caller.call(async () => {
      const a = await this._fetch(`${this.apiUrl}${this._getPlatformEndpointPath(`datasets/${e}/examples`)}`, {
        method: "POST",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: n
      });
      return await re(a, "upload examples"), a;
    })).json();
  }
  async updatePrompt(e, t) {
    if (!await this.promptExists(e))
      throw new Error("Prompt does not exist, you must create it first.");
    const [n, s] = Gr(e);
    if (!await this._currentTenantIsOwner(n))
      throw await this._ownerConflictError("update a prompt", n);
    const a = {};
    if ((t == null ? void 0 : t.description) !== void 0 && (a.description = t.description), (t == null ? void 0 : t.readme) !== void 0 && (a.readme = t.readme), (t == null ? void 0 : t.tags) !== void 0 && (a.tags = t.tags), (t == null ? void 0 : t.isPublic) !== void 0 && (a.is_public = t.isPublic), (t == null ? void 0 : t.isArchived) !== void 0 && (a.is_archived = t.isArchived), Object.keys(a).length === 0)
      throw new Error("No valid update options provided");
    const i = JSON.stringify(a);
    return (await this.caller.call(async () => {
      const c = await this._fetch(`${this.apiUrl}/repos/${n}/${s}`, {
        method: "PATCH",
        headers: {
          ...this.headers,
          "Content-Type": "application/json"
        },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: i
      });
      return await re(c, "update prompt"), c;
    })).json();
  }
  async deletePrompt(e) {
    if (!await this.promptExists(e))
      throw new Error("Prompt does not exist, you must create it first.");
    const [t, n, s] = Gr(e);
    if (!await this._currentTenantIsOwner(t))
      throw await this._ownerConflictError("delete a prompt", t);
    return (await this.caller.call(async () => {
      const i = await this._fetch(`${this.apiUrl}/repos/${t}/${n}`, {
        method: "DELETE",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      return await re(i, "delete prompt"), i;
    })).json();
  }
  async pullPromptCommit(e, t) {
    const [n, s, a] = Gr(e), o = await (await this.caller.call(async () => {
      const c = await this._fetch(`${this.apiUrl}/commits/${n}/${s}/${a}${t != null && t.includeModel ? "?include_model=true" : ""}`, {
        method: "GET",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      return await re(c, "pull prompt commit"), c;
    })).json();
    return {
      owner: n,
      repo: s,
      commit_hash: o.commit_hash,
      manifest: o.manifest,
      examples: o.examples
    };
  }
  /**
   * This method should not be used directly, use `import { pull } from "langchain/hub"` instead.
   * Using this method directly returns the JSON string of the prompt rather than a LangChain object.
   * @private
   */
  async _pullPrompt(e, t) {
    const n = await this.pullPromptCommit(e, {
      includeModel: t == null ? void 0 : t.includeModel
    });
    return JSON.stringify(n.manifest);
  }
  async pushPrompt(e, t) {
    return await this.promptExists(e) ? t && Object.keys(t).some((s) => s !== "object") && await this.updatePrompt(e, {
      description: t == null ? void 0 : t.description,
      readme: t == null ? void 0 : t.readme,
      tags: t == null ? void 0 : t.tags,
      isPublic: t == null ? void 0 : t.isPublic
    }) : await this.createPrompt(e, {
      description: t == null ? void 0 : t.description,
      readme: t == null ? void 0 : t.readme,
      tags: t == null ? void 0 : t.tags,
      isPublic: t == null ? void 0 : t.isPublic
    }), t != null && t.object ? await this.createCommit(e, t == null ? void 0 : t.object, {
      parentCommitHash: t == null ? void 0 : t.parentCommitHash
    }) : await this._getPromptUrl(e);
  }
  /**
     * Clone a public dataset to your own langsmith tenant.
     * This operation is idempotent. If you already have a dataset with the given name,
     * this function will do nothing.
  
     * @param {string} tokenOrUrl The token of the public dataset to clone.
     * @param {Object} [options] Additional options for cloning the dataset.
     * @param {string} [options.sourceApiUrl] The URL of the langsmith server where the data is hosted. Defaults to the API URL of your current client.
     * @param {string} [options.datasetName] The name of the dataset to create in your tenant. Defaults to the name of the public dataset.
     * @returns {Promise<void>}
     */
  async clonePublicDataset(e, t = {}) {
    const { sourceApiUrl: n = this.apiUrl, datasetName: s } = t, [a, i] = this.parseTokenOrUrl(e, n), o = new Js({
      apiUrl: a,
      // Placeholder API key not needed anymore in most cases, but
      // some private deployments may have API key-based rate limiting
      // that would cause this to fail if we provide no value.
      apiKey: "placeholder"
    }), c = await o.readSharedDataset(i), u = s || c.name;
    try {
      if (await this.hasDataset({ datasetId: u })) {
        console.log(`Dataset ${u} already exists in your tenant. Skipping.`);
        return;
      }
    } catch {
    }
    const l = await o.listSharedExamples(i), d = await this.createDataset(u, {
      description: c.description,
      dataType: c.data_type || "kv",
      inputsSchema: c.inputs_schema_definition ?? void 0,
      outputsSchema: c.outputs_schema_definition ?? void 0
    });
    try {
      await this.createExamples({
        inputs: l.map((h) => h.inputs),
        outputs: l.flatMap((h) => h.outputs ? [h.outputs] : []),
        datasetId: d.id
      });
    } catch (h) {
      throw console.error(`An error occurred while creating dataset ${u}. You should delete it manually.`), h;
    }
  }
  parseTokenOrUrl(e, t, n = 2, s = "dataset") {
    try {
      return ye(e), [t, e];
    } catch {
    }
    try {
      const i = new URL(e).pathname.split("/").filter((o) => o !== "");
      if (i.length >= n) {
        const o = i[i.length - n];
        return [t, o];
      } else
        throw new Error(`Invalid public ${s} URL: ${e}`);
    } catch {
      throw new Error(`Invalid public ${s} URL or token: ${e}`);
    }
  }
  /**
   * Awaits all pending trace batches. Useful for environments where
   * you need to be sure that all tracing requests finish before execution ends,
   * such as serverless environments.
   *
   * @example
   * ```
   * import { Client } from "langsmith";
   *
   * const client = new Client();
   *
   * try {
   *   // Tracing happens here
   *   ...
   * } finally {
   *   await client.awaitPendingTraceBatches();
   * }
   * ```
   *
   * @returns A promise that resolves once all currently pending traces have sent.
   */
  async awaitPendingTraceBatches() {
    var e, t;
    if (this.manualFlushMode)
      return console.warn("[WARNING]: When tracing in manual flush mode, you must call `await client.flush()` manually to submit trace batches."), Promise.resolve();
    await Promise.all([
      ...this.autoBatchQueue.items.map(({ itemPromise: n }) => n),
      this.batchIngestCaller.queue.onIdle()
    ]), this.langSmithToOTELTranslator !== void 0 && await ((t = (e = Vb()) == null ? void 0 : e.DEFAULT_LANGSMITH_SPAN_PROCESSOR) == null ? void 0 : t.forceFlush());
  }
}
function sh(r) {
  return "dataset_id" in r || "dataset_name" in r;
}
const wS = (r) => !!["TRACING_V2", "TRACING"].find((t) => Nt(t) === "true"), en = Symbol.for("lc:context_variables"), nc = Symbol.for("langsmith:replica_trace_roots");
function ah(r, e) {
  if (en in r)
    return r[en][e];
}
function vS(r, e, t) {
  const n = en in r ? (
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    r[en]
  ) : {};
  n[e] = t, r[en] = n;
}
const xs = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
function ih(r) {
  const t = Object.keys(r).sort().map((n) => `${n}:${r[n] ?? ""}`).join("|");
  return Es(t, xs);
}
function bS(r) {
  return r.replace(/[-:.]/g, "");
}
function sg(r, e = 1) {
  const t = e.toFixed(0).slice(0, 3).padStart(3, "0");
  return `${new Date(r).toISOString().slice(0, -1)}${t}Z`;
}
function ag(r, e, t = 1) {
  const n = sg(r, t);
  return {
    dottedOrder: bS(n) + e,
    microsecondPrecisionDatestring: n
  };
}
class Ei {
  constructor(e, t, n, s) {
    Object.defineProperty(this, "metadata", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "tags", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "project_name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "replicas", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.metadata = e, this.tags = t, this.project_name = n, this.replicas = s;
  }
  static fromHeader(e) {
    const t = e.split(",");
    let n = {}, s = [], a, i;
    for (const o of t) {
      const [c, u] = o.split("="), l = decodeURIComponent(u);
      c === "langsmith-metadata" ? n = JSON.parse(l) : c === "langsmith-tags" ? s = l.split(",") : c === "langsmith-project" ? a = l : c === "langsmith-replicas" && (i = JSON.parse(l));
    }
    return new Ei(n, s, a, i);
  }
  toHeader() {
    const e = [];
    return this.metadata && Object.keys(this.metadata).length > 0 && e.push(`langsmith-metadata=${encodeURIComponent(JSON.stringify(this.metadata))}`), this.tags && this.tags.length > 0 && e.push(`langsmith-tags=${encodeURIComponent(this.tags.join(","))}`), this.project_name && e.push(`langsmith-project=${encodeURIComponent(this.project_name)}`), e.join(",");
  }
}
class Ct {
  constructor(e) {
    var o;
    if (Object.defineProperty(this, "id", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "run_type", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "project_name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "parent_run", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "parent_run_id", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "child_runs", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "start_time", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "end_time", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "extra", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "tags", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "error", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "serialized", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "inputs", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "outputs", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "reference_example_id", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "client", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "events", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "trace_id", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "dotted_order", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "tracingEnabled", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "execution_order", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "child_execution_order", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "attachments", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "replicas", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "distributedParentId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_serialized_start_time", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), SS(e)) {
      Object.assign(this, { ...e });
      return;
    }
    const t = Ct.getDefaultConfig(), { metadata: n, ...s } = e, a = s.client ?? Ct.getSharedClient(), i = {
      ...n,
      ...(o = s == null ? void 0 : s.extra) == null ? void 0 : o.metadata
    };
    if (s.extra = { ...s.extra, metadata: i }, "id" in s && s.id == null && delete s.id, Object.assign(this, { ...t, ...s, client: a }), this.execution_order ?? (this.execution_order = 1), this.child_execution_order ?? (this.child_execution_order = 1), this.dotted_order || (this._serialized_start_time = sg(this.start_time, this.execution_order)), this.id || (this.id = $b(this._serialized_start_time ?? this.start_time)), this.trace_id || (this.parent_run ? this.trace_id = this.parent_run.trace_id ?? this.id : this.trace_id = this.id), this.replicas = IS(this.replicas), !this.dotted_order) {
      const { dottedOrder: c } = ag(this.start_time, this.id, this.execution_order);
      this.parent_run ? this.dotted_order = this.parent_run.dotted_order + "." + c : this.dotted_order = c;
    }
  }
  set metadata(e) {
    var t;
    this.extra = {
      ...this.extra,
      metadata: {
        ...(t = this.extra) == null ? void 0 : t.metadata,
        ...e
      }
    };
  }
  get metadata() {
    var e;
    return (e = this.extra) == null ? void 0 : e.metadata;
  }
  static getDefaultConfig() {
    const e = Date.now();
    return {
      run_type: "chain",
      project_name: Fm(),
      child_runs: [],
      api_url: Or("LANGCHAIN_ENDPOINT") ?? "http://localhost:1984",
      api_key: Or("LANGCHAIN_API_KEY"),
      caller_options: {},
      start_time: e,
      serialized: {},
      inputs: {},
      extra: {}
    };
  }
  static getSharedClient() {
    return Ct.sharedClient || (Ct.sharedClient = new Js()), Ct.sharedClient;
  }
  createChild(e) {
    var l, d, h, f, p, y, g;
    const t = this.child_execution_order + 1, n = (l = this.replicas) == null ? void 0 : l.map((S) => {
      const { reroot: _, ...w } = S;
      return w;
    }), s = e.replicas ?? n, a = new Ct({
      ...e,
      parent_run: this,
      project_name: this.project_name,
      replicas: s,
      client: this.client,
      tracingEnabled: this.tracingEnabled,
      execution_order: t,
      child_execution_order: t
    });
    en in this && (a[en] = this[en]);
    const i = Symbol.for("lc:child_config"), o = ((d = e.extra) == null ? void 0 : d[i]) ?? this.extra[i];
    if (ES(o)) {
      const S = { ...o }, _ = TS(S.callbacks) ? (f = (h = S.callbacks).copy) == null ? void 0 : f.call(h) : void 0;
      _ && (Object.assign(_, { _parentRunId: a.id }), (g = (y = (p = _.handlers) == null ? void 0 : p.find(ig)) == null ? void 0 : y.updateFromRunTree) == null || g.call(y, a), S.callbacks = _), a.extra[i] = S;
    }
    const c = /* @__PURE__ */ new Set();
    let u = this;
    for (; u != null && !c.has(u.id); )
      c.add(u.id), u.child_execution_order = Math.max(u.child_execution_order, t), u = u.parent_run;
    return this.child_runs.push(a), a;
  }
  async end(e, t, n = Date.now(), s) {
    this.outputs = this.outputs ?? e, this.error = this.error ?? t, this.end_time = this.end_time ?? n, s && Object.keys(s).length > 0 && (this.extra = this.extra ? { ...this.extra, metadata: { ...this.extra.metadata, ...s } } : { metadata: s });
  }
  _convertToCreate(e, t, n = !0) {
    var o, c;
    const s = e.extra ?? {};
    if (((o = s == null ? void 0 : s.runtime) == null ? void 0 : o.library) === void 0 && (s.runtime || (s.runtime = {}), t))
      for (const [u, l] of Object.entries(t))
        s.runtime[u] || (s.runtime[u] = l);
    let a, i;
    return n ? (i = ((c = e.parent_run) == null ? void 0 : c.id) ?? e.parent_run_id, a = []) : (a = e.child_runs.map((u) => this._convertToCreate(u, t, n)), i = void 0), {
      id: e.id,
      name: e.name,
      start_time: e._serialized_start_time ?? e.start_time,
      end_time: e.end_time,
      run_type: e.run_type,
      reference_example_id: e.reference_example_id,
      extra: s,
      serialized: e.serialized,
      error: e.error,
      inputs: e.inputs,
      outputs: e.outputs,
      session_name: e.project_name,
      child_runs: a,
      parent_run_id: i,
      trace_id: e.trace_id,
      dotted_order: e.dotted_order,
      tags: e.tags,
      attachments: e.attachments,
      events: e.events
    };
  }
  _sliceParentId(e, t) {
    if (t.dotted_order) {
      const n = t.dotted_order.split(".");
      let s = null;
      for (let a = 0; a < n.length; a++)
        if (n[a].slice(-36) === e) {
          s = a;
          break;
        }
      if (s !== null) {
        const a = n.slice(s + 1);
        t.dotted_order = a.join("."), a.length > 0 ? t.trace_id = a[0].slice(-36) : t.trace_id = t.id;
      }
    }
    t.parent_run_id === e && (t.parent_run_id = void 0);
  }
  _setReplicaTraceRoot(e, t) {
    const n = ah(this, nc) ?? {};
    n[e] = t, vS(this, nc, n);
    for (const s of this.child_runs)
      s._setReplicaTraceRoot(e, t);
  }
  _remapForProject(e) {
    const { projectName: t, runtimeEnv: n, excludeChildRuns: s = !0, reroot: a = !1, distributedParentId: i, apiUrl: o, apiKey: c, workspaceId: u } = e, l = this._convertToCreate(this, n, s);
    if (t === this.project_name)
      return {
        ...l,
        session_name: t
      };
    if (a) {
      if (i)
        this._sliceParentId(i, l);
      else if (l.parent_run_id = void 0, l.dotted_order) {
        const _ = l.dotted_order.split(".");
        _.length > 0 && (l.dotted_order = _[_.length - 1], l.trace_id = l.id);
      }
      const S = ih({
        projectName: t,
        apiUrl: o,
        apiKey: c,
        workspaceId: u
      });
      this._setReplicaTraceRoot(S, l.id);
    }
    let d;
    if (!a) {
      const S = ah(this, nc) ?? {}, _ = ih({
        projectName: t,
        apiUrl: o,
        apiKey: c,
        workspaceId: u
      });
      if (d = S[_], d && (l.trace_id = d, l.dotted_order)) {
        const w = l.dotted_order.split(".");
        let T = null;
        for (let x = 0; x < w.length; x++)
          if (w[x].slice(-36) === d) {
            T = x;
            break;
          }
        if (T !== null) {
          const x = w.slice(T);
          l.dotted_order = x.join(".");
        }
      }
    }
    const h = l.id, f = Es(`${h}:${t}`, xs);
    let p;
    l.trace_id ? p = Es(`${l.trace_id}:${t}`, xs) : p = f;
    let y;
    l.parent_run_id && (y = Es(`${l.parent_run_id}:${t}`, xs));
    let g;
    return l.dotted_order && (g = l.dotted_order.split(".").map((w) => {
      const T = w.slice(-36), x = Es(`${T}:${t}`, xs);
      return w.slice(0, -36) + x;
    }).join(".")), {
      ...l,
      id: f,
      trace_id: p,
      parent_run_id: y,
      dotted_order: g,
      session_name: t
    };
  }
  async postRun(e = !0) {
    try {
      const t = Zm();
      if (this.replicas && this.replicas.length > 0)
        for (const { projectName: n, apiKey: s, apiUrl: a, workspaceId: i, reroot: o } of this.replicas) {
          const c = this._remapForProject({
            projectName: n ?? this.project_name,
            runtimeEnv: t,
            excludeChildRuns: !0,
            reroot: o,
            distributedParentId: this.distributedParentId,
            apiUrl: a,
            apiKey: s,
            workspaceId: i
          });
          await this.client.createRun(c, {
            apiKey: s,
            apiUrl: a,
            workspaceId: i
          });
        }
      else {
        const n = this._convertToCreate(this, t, e);
        await this.client.createRun(n);
      }
      if (!e) {
        Mc("Posting with excludeChildRuns=false is deprecated and will be removed in a future version.");
        for (const n of this.child_runs)
          await n.postRun(!1);
      }
    } catch (t) {
      console.error(`Error in postRun for run ${this.id}:`, t);
    }
  }
  async patchRun(e) {
    var t;
    if (this.replicas && this.replicas.length > 0)
      for (const { projectName: n, apiKey: s, apiUrl: a, workspaceId: i, updates: o, reroot: c } of this.replicas) {
        const u = this._remapForProject({
          projectName: n ?? this.project_name,
          runtimeEnv: void 0,
          excludeChildRuns: !0,
          reroot: c,
          distributedParentId: this.distributedParentId,
          apiUrl: a,
          apiKey: s,
          workspaceId: i
        }), l = {
          id: u.id,
          name: u.name,
          run_type: u.run_type,
          start_time: u.start_time,
          outputs: u.outputs,
          error: u.error,
          parent_run_id: u.parent_run_id,
          session_name: u.session_name,
          reference_example_id: u.reference_example_id,
          end_time: u.end_time,
          dotted_order: u.dotted_order,
          trace_id: u.trace_id,
          events: u.events,
          tags: u.tags,
          extra: u.extra,
          attachments: this.attachments,
          ...o
        };
        e != null && e.excludeInputs || (l.inputs = u.inputs), await this.client.updateRun(u.id, l, {
          apiKey: s,
          apiUrl: a,
          workspaceId: i
        });
      }
    else
      try {
        const n = {
          name: this.name,
          run_type: this.run_type,
          start_time: this._serialized_start_time ?? this.start_time,
          end_time: this.end_time,
          error: this.error,
          outputs: this.outputs,
          parent_run_id: ((t = this.parent_run) == null ? void 0 : t.id) ?? this.parent_run_id,
          reference_example_id: this.reference_example_id,
          extra: this.extra,
          events: this.events,
          dotted_order: this.dotted_order,
          trace_id: this.trace_id,
          tags: this.tags,
          attachments: this.attachments,
          session_name: this.project_name
        };
        e != null && e.excludeInputs || (n.inputs = this.inputs), await this.client.updateRun(this.id, n);
      } catch (n) {
        console.error(`Error in patchRun for run ${this.id}`, n);
      }
  }
  toJSON() {
    return this._convertToCreate(this, void 0, !1);
  }
  /**
   * Add an event to the run tree.
   * @param event - A single event or string to add
   */
  addEvent(e) {
    this.events || (this.events = []), typeof e == "string" ? this.events.push({
      name: "event",
      time: (/* @__PURE__ */ new Date()).toISOString(),
      message: e
    }) : this.events.push({
      ...e,
      time: e.time ?? (/* @__PURE__ */ new Date()).toISOString()
    });
  }
  static fromRunnableConfig(e, t) {
    var u, l, d, h;
    const n = e == null ? void 0 : e.callbacks;
    let s, a, i, o = wS();
    if (n) {
      const f = ((u = n == null ? void 0 : n.getParentRunId) == null ? void 0 : u.call(n)) ?? "", p = (l = n == null ? void 0 : n.handlers) == null ? void 0 : l.find((y) => (y == null ? void 0 : y.name) == "langchain_tracer");
      s = (d = p == null ? void 0 : p.getRun) == null ? void 0 : d.call(p, f), a = p == null ? void 0 : p.projectName, i = p == null ? void 0 : p.client, o = o || !!p;
    }
    return s ? new Ct({
      name: s.name,
      id: s.id,
      trace_id: s.trace_id,
      dotted_order: s.dotted_order,
      client: i,
      tracingEnabled: o,
      project_name: a,
      tags: [
        ...new Set(((s == null ? void 0 : s.tags) ?? []).concat((e == null ? void 0 : e.tags) ?? []))
      ],
      extra: {
        metadata: {
          ...(h = s == null ? void 0 : s.extra) == null ? void 0 : h.metadata,
          ...e == null ? void 0 : e.metadata
        }
      }
    }).createChild(t) : new Ct({
      ...t,
      client: i,
      tracingEnabled: o,
      project_name: a
    });
  }
  static fromDottedOrder(e) {
    return this.fromHeaders({ "langsmith-trace": e });
  }
  static fromHeaders(e, t) {
    var l;
    const n = "get" in e && typeof e.get == "function" ? {
      "langsmith-trace": e.get("langsmith-trace"),
      baggage: e.get("baggage")
    } : e, s = n["langsmith-trace"];
    if (!s || typeof s != "string")
      return;
    const a = s.trim(), i = a.split(".").map((d) => {
      const [h, f] = d.split("Z");
      return { strTime: h, time: Date.parse(h + "Z"), uuid: f };
    }), o = i[0].uuid, c = {
      ...t,
      name: (t == null ? void 0 : t.name) ?? "parent",
      run_type: (t == null ? void 0 : t.run_type) ?? "chain",
      start_time: (t == null ? void 0 : t.start_time) ?? Date.now(),
      id: (l = i.at(-1)) == null ? void 0 : l.uuid,
      trace_id: o,
      dotted_order: a
    };
    if (n.baggage && typeof n.baggage == "string") {
      const d = Ei.fromHeader(n.baggage);
      c.metadata = d.metadata, c.tags = d.tags, c.project_name = d.project_name, c.replicas = d.replicas;
    }
    const u = new Ct(c);
    return u.distributedParentId = u.id, u;
  }
  toHeaders(e) {
    var n;
    const t = {
      "langsmith-trace": this.dotted_order,
      baggage: new Ei((n = this.extra) == null ? void 0 : n.metadata, this.tags, this.project_name, this.replicas).toHeader()
    };
    if (e)
      for (const [s, a] of Object.entries(t))
        e.set(s, a);
    return t;
  }
}
Object.defineProperty(Ct, "sharedClient", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: null
});
function SS(r) {
  return r != null && typeof r.createChild == "function" && typeof r.postRun == "function";
}
function ig(r) {
  return typeof r == "object" && r != null && typeof r.name == "string" && r.name === "langchain_tracer";
}
function oh(r) {
  return Array.isArray(r) && r.some((e) => ig(e));
}
function TS(r) {
  return typeof r == "object" && r != null && Array.isArray(r.handlers);
}
function ES(r) {
  var e;
  return r != null && typeof r.callbacks == "object" && // Callback manager with a langchain tracer
  (oh((e = r.callbacks) == null ? void 0 : e.handlers) || // Or it's an array with a LangChainTracerLike object within it
  oh(r.callbacks));
}
function xS() {
  const r = Or("LANGSMITH_RUNS_ENDPOINTS");
  if (!r)
    return [];
  try {
    const e = JSON.parse(r);
    if (Array.isArray(e)) {
      const t = [];
      for (const n of e) {
        if (typeof n != "object" || n === null) {
          console.warn(`Invalid item type in LANGSMITH_RUNS_ENDPOINTS: expected object, got ${typeof n}`);
          continue;
        }
        if (typeof n.api_url != "string") {
          console.warn(`Invalid api_url type in LANGSMITH_RUNS_ENDPOINTS: expected string, got ${typeof n.api_url}`);
          continue;
        }
        if (typeof n.api_key != "string") {
          console.warn(`Invalid api_key type in LANGSMITH_RUNS_ENDPOINTS: expected string, got ${typeof n.api_key}`);
          continue;
        }
        t.push({
          apiUrl: n.api_url.replace(/\/$/, ""),
          apiKey: n.api_key
        });
      }
      return t;
    } else if (typeof e == "object" && e !== null) {
      kS(e);
      const t = [];
      for (const [n, s] of Object.entries(e)) {
        const a = n.replace(/\/$/, "");
        if (typeof s == "string")
          t.push({
            apiUrl: a,
            apiKey: s
          });
        else {
          console.warn(`Invalid value type in LANGSMITH_RUNS_ENDPOINTS for URL ${n}: expected string, got ${typeof s}`);
          continue;
        }
      }
      return t;
    } else
      return console.warn(`Invalid LANGSMITH_RUNS_ENDPOINTS â€“ must be valid JSON array of objects with api_url and api_key properties, or object mapping url->apiKey, got ${typeof e}`), [];
  } catch (e) {
    if (aS(e))
      throw e;
    return console.warn("Invalid LANGSMITH_RUNS_ENDPOINTS â€“ must be valid JSON array of objects with api_url and api_key properties, or object mapping url->apiKey"), [];
  }
}
function IS(r) {
  return r ? r.map((e) => Array.isArray(e) ? {
    projectName: e[0],
    updates: e[1]
  } : e) : xS();
}
function kS(r) {
  if (Object.keys(r).length > 0 && Nt("ENDPOINT"))
    throw new sS();
}
var OS = {};
Ae(OS, {
  BaseTracer: () => us,
  isBaseTracer: () => Fn
});
const AS = (r) => {
  if (r)
    return r.events = r.events ?? [], r.child_runs = r.child_runs ?? [], r;
};
function Fc(r, e) {
  if (r)
    return new Ct({
      ...r,
      start_time: r._serialized_start_time ?? r.start_time,
      parent_run: Fc(e),
      child_runs: r.child_runs.map((t) => Fc(t)).filter((t) => t !== void 0),
      extra: {
        ...r.extra,
        runtime: Lm()
      },
      tracingEnabled: !1
    });
}
function sc(r, e) {
  return r && !Array.isArray(r) && typeof r == "object" ? r : { [e]: r };
}
function Fn(r) {
  return typeof r._addRunToRunMap == "function";
}
var us = class extends la {
  constructor(e) {
    super(...arguments);
    /** @deprecated Use `runTreeMap` instead. */
    v(this, "runMap", /* @__PURE__ */ new Map());
    v(this, "runTreeMap", /* @__PURE__ */ new Map());
    v(this, "usesRunTreeMap", !1);
  }
  copy() {
    return this;
  }
  getRunById(e) {
    if (e !== void 0)
      return this.usesRunTreeMap ? AS(this.runTreeMap.get(e)) : this.runMap.get(e);
  }
  stringifyError(e) {
    return e instanceof Error ? e.message + (e != null && e.stack ? `

${e.stack}` : "") : typeof e == "string" ? e : `${e}`;
  }
  _addChildRun(e, t) {
    e.child_runs.push(t);
  }
  _addRunToRunMap(e) {
    const { dottedOrder: t, microsecondPrecisionDatestring: n } = ag(new Date(e.start_time).getTime(), e.id, e.execution_order), s = { ...e }, a = this.getRunById(s.parent_run_id);
    if (s.parent_run_id !== void 0 ? a && (this._addChildRun(a, s), a.child_execution_order = Math.max(a.child_execution_order, s.child_execution_order), s.trace_id = a.trace_id, a.dotted_order !== void 0 && (s.dotted_order = [a.dotted_order, t].join("."), s._serialized_start_time = n)) : (s.trace_id = s.id, s.dotted_order = t, s._serialized_start_time = n), this.usesRunTreeMap) {
      const i = Fc(s, a);
      i !== void 0 && this.runTreeMap.set(s.id, i);
    } else this.runMap.set(s.id, s);
    return s;
  }
  async _endTrace(e) {
    var n;
    const t = e.parent_run_id !== void 0 && this.getRunById(e.parent_run_id);
    t ? t.child_execution_order = Math.max(t.child_execution_order, e.child_execution_order) : await this.persistRun(e), await ((n = this.onRunUpdate) == null ? void 0 : n.call(this, e)), this.usesRunTreeMap ? this.runTreeMap.delete(e.id) : this.runMap.delete(e.id);
  }
  _getExecutionOrder(e) {
    const t = e !== void 0 && this.getRunById(e);
    return t ? t.child_execution_order + 1 : 1;
  }
  /**
  * Create and add a run to the run map for LLM start events.
  * This must sometimes be done synchronously to avoid race conditions
  * when callbacks are backgrounded, so we expose it as a separate method here.
  */
  _createRunForLLMStart(e, t, n, s, a, i, o, c) {
    const u = this._getExecutionOrder(s), l = Date.now(), d = o ? {
      ...a,
      metadata: o
    } : a, h = {
      id: n,
      name: c ?? e.id[e.id.length - 1],
      parent_run_id: s,
      start_time: l,
      serialized: e,
      events: [{
        name: "start",
        time: new Date(l).toISOString()
      }],
      inputs: { prompts: t },
      execution_order: u,
      child_runs: [],
      child_execution_order: u,
      run_type: "llm",
      extra: d ?? {},
      tags: i || []
    };
    return this._addRunToRunMap(h);
  }
  async handleLLMStart(e, t, n, s, a, i, o, c) {
    var l, d;
    const u = this.getRunById(n) ?? this._createRunForLLMStart(e, t, n, s, a, i, o, c);
    return await ((l = this.onRunCreate) == null ? void 0 : l.call(this, u)), await ((d = this.onLLMStart) == null ? void 0 : d.call(this, u)), u;
  }
  /**
  * Create and add a run to the run map for chat model start events.
  * This must sometimes be done synchronously to avoid race conditions
  * when callbacks are backgrounded, so we expose it as a separate method here.
  */
  _createRunForChatModelStart(e, t, n, s, a, i, o, c) {
    const u = this._getExecutionOrder(s), l = Date.now(), d = o ? {
      ...a,
      metadata: o
    } : a, h = {
      id: n,
      name: c ?? e.id[e.id.length - 1],
      parent_run_id: s,
      start_time: l,
      serialized: e,
      events: [{
        name: "start",
        time: new Date(l).toISOString()
      }],
      inputs: { messages: t },
      execution_order: u,
      child_runs: [],
      child_execution_order: u,
      run_type: "llm",
      extra: d ?? {},
      tags: i || []
    };
    return this._addRunToRunMap(h);
  }
  async handleChatModelStart(e, t, n, s, a, i, o, c) {
    var l, d;
    const u = this.getRunById(n) ?? this._createRunForChatModelStart(e, t, n, s, a, i, o, c);
    return await ((l = this.onRunCreate) == null ? void 0 : l.call(this, u)), await ((d = this.onLLMStart) == null ? void 0 : d.call(this, u)), u;
  }
  async handleLLMEnd(e, t, n, s, a) {
    var o;
    const i = this.getRunById(t);
    if (!i || (i == null ? void 0 : i.run_type) !== "llm") throw new Error("No LLM run to end.");
    return i.end_time = Date.now(), i.outputs = e, i.events.push({
      name: "end",
      time: new Date(i.end_time).toISOString()
    }), i.extra = {
      ...i.extra,
      ...a
    }, await ((o = this.onLLMEnd) == null ? void 0 : o.call(this, i)), await this._endTrace(i), i;
  }
  async handleLLMError(e, t, n, s, a) {
    var o;
    const i = this.getRunById(t);
    if (!i || (i == null ? void 0 : i.run_type) !== "llm") throw new Error("No LLM run to end.");
    return i.end_time = Date.now(), i.error = this.stringifyError(e), i.events.push({
      name: "error",
      time: new Date(i.end_time).toISOString()
    }), i.extra = {
      ...i.extra,
      ...a
    }, await ((o = this.onLLMError) == null ? void 0 : o.call(this, i)), await this._endTrace(i), i;
  }
  /**
  * Create and add a run to the run map for chain start events.
  * This must sometimes be done synchronously to avoid race conditions
  * when callbacks are backgrounded, so we expose it as a separate method here.
  */
  _createRunForChainStart(e, t, n, s, a, i, o, c) {
    const u = this._getExecutionOrder(s), l = Date.now(), d = {
      id: n,
      name: c ?? e.id[e.id.length - 1],
      parent_run_id: s,
      start_time: l,
      serialized: e,
      events: [{
        name: "start",
        time: new Date(l).toISOString()
      }],
      inputs: t,
      execution_order: u,
      child_execution_order: u,
      run_type: o ?? "chain",
      child_runs: [],
      extra: i ? { metadata: i } : {},
      tags: a || []
    };
    return this._addRunToRunMap(d);
  }
  async handleChainStart(e, t, n, s, a, i, o, c) {
    var l, d;
    const u = this.getRunById(n) ?? this._createRunForChainStart(e, t, n, s, a, i, o, c);
    return await ((l = this.onRunCreate) == null ? void 0 : l.call(this, u)), await ((d = this.onChainStart) == null ? void 0 : d.call(this, u)), u;
  }
  async handleChainEnd(e, t, n, s, a) {
    var o;
    const i = this.getRunById(t);
    if (!i) throw new Error("No chain run to end.");
    return i.end_time = Date.now(), i.outputs = sc(e, "output"), i.events.push({
      name: "end",
      time: new Date(i.end_time).toISOString()
    }), (a == null ? void 0 : a.inputs) !== void 0 && (i.inputs = sc(a.inputs, "input")), await ((o = this.onChainEnd) == null ? void 0 : o.call(this, i)), await this._endTrace(i), i;
  }
  async handleChainError(e, t, n, s, a) {
    var o;
    const i = this.getRunById(t);
    if (!i) throw new Error("No chain run to end.");
    return i.end_time = Date.now(), i.error = this.stringifyError(e), i.events.push({
      name: "error",
      time: new Date(i.end_time).toISOString()
    }), (a == null ? void 0 : a.inputs) !== void 0 && (i.inputs = sc(a.inputs, "input")), await ((o = this.onChainError) == null ? void 0 : o.call(this, i)), await this._endTrace(i), i;
  }
  /**
  * Create and add a run to the run map for tool start events.
  * This must sometimes be done synchronously to avoid race conditions
  * when callbacks are backgrounded, so we expose it as a separate method here.
  */
  _createRunForToolStart(e, t, n, s, a, i, o) {
    const c = this._getExecutionOrder(s), u = Date.now(), l = {
      id: n,
      name: o ?? e.id[e.id.length - 1],
      parent_run_id: s,
      start_time: u,
      serialized: e,
      events: [{
        name: "start",
        time: new Date(u).toISOString()
      }],
      inputs: { input: t },
      execution_order: c,
      child_execution_order: c,
      run_type: "tool",
      child_runs: [],
      extra: i ? { metadata: i } : {},
      tags: a || []
    };
    return this._addRunToRunMap(l);
  }
  async handleToolStart(e, t, n, s, a, i, o) {
    var u, l;
    const c = this.getRunById(n) ?? this._createRunForToolStart(e, t, n, s, a, i, o);
    return await ((u = this.onRunCreate) == null ? void 0 : u.call(this, c)), await ((l = this.onToolStart) == null ? void 0 : l.call(this, c)), c;
  }
  async handleToolEnd(e, t) {
    var s;
    const n = this.getRunById(t);
    if (!n || (n == null ? void 0 : n.run_type) !== "tool") throw new Error("No tool run to end");
    return n.end_time = Date.now(), n.outputs = { output: e }, n.events.push({
      name: "end",
      time: new Date(n.end_time).toISOString()
    }), await ((s = this.onToolEnd) == null ? void 0 : s.call(this, n)), await this._endTrace(n), n;
  }
  async handleToolError(e, t) {
    var s;
    const n = this.getRunById(t);
    if (!n || (n == null ? void 0 : n.run_type) !== "tool") throw new Error("No tool run to end");
    return n.end_time = Date.now(), n.error = this.stringifyError(e), n.events.push({
      name: "error",
      time: new Date(n.end_time).toISOString()
    }), await ((s = this.onToolError) == null ? void 0 : s.call(this, n)), await this._endTrace(n), n;
  }
  async handleAgentAction(e, t) {
    var a;
    const n = this.getRunById(t);
    if (!n || (n == null ? void 0 : n.run_type) !== "chain") return;
    const s = n;
    s.actions = s.actions || [], s.actions.push(e), s.events.push({
      name: "agent_action",
      time: (/* @__PURE__ */ new Date()).toISOString(),
      kwargs: { action: e }
    }), await ((a = this.onAgentAction) == null ? void 0 : a.call(this, n));
  }
  async handleAgentEnd(e, t) {
    var s;
    const n = this.getRunById(t);
    !n || (n == null ? void 0 : n.run_type) !== "chain" || (n.events.push({
      name: "agent_end",
      time: (/* @__PURE__ */ new Date()).toISOString(),
      kwargs: { action: e }
    }), await ((s = this.onAgentEnd) == null ? void 0 : s.call(this, n)));
  }
  /**
  * Create and add a run to the run map for retriever start events.
  * This must sometimes be done synchronously to avoid race conditions
  * when callbacks are backgrounded, so we expose it as a separate method here.
  */
  _createRunForRetrieverStart(e, t, n, s, a, i, o) {
    const c = this._getExecutionOrder(s), u = Date.now(), l = {
      id: n,
      name: o ?? e.id[e.id.length - 1],
      parent_run_id: s,
      start_time: u,
      serialized: e,
      events: [{
        name: "start",
        time: new Date(u).toISOString()
      }],
      inputs: { query: t },
      execution_order: c,
      child_execution_order: c,
      run_type: "retriever",
      child_runs: [],
      extra: i ? { metadata: i } : {},
      tags: a || []
    };
    return this._addRunToRunMap(l);
  }
  async handleRetrieverStart(e, t, n, s, a, i, o) {
    var u, l;
    const c = this.getRunById(n) ?? this._createRunForRetrieverStart(e, t, n, s, a, i, o);
    return await ((u = this.onRunCreate) == null ? void 0 : u.call(this, c)), await ((l = this.onRetrieverStart) == null ? void 0 : l.call(this, c)), c;
  }
  async handleRetrieverEnd(e, t) {
    var s;
    const n = this.getRunById(t);
    if (!n || (n == null ? void 0 : n.run_type) !== "retriever") throw new Error("No retriever run to end");
    return n.end_time = Date.now(), n.outputs = { documents: e }, n.events.push({
      name: "end",
      time: new Date(n.end_time).toISOString()
    }), await ((s = this.onRetrieverEnd) == null ? void 0 : s.call(this, n)), await this._endTrace(n), n;
  }
  async handleRetrieverError(e, t) {
    var s;
    const n = this.getRunById(t);
    if (!n || (n == null ? void 0 : n.run_type) !== "retriever") throw new Error("No retriever run to end");
    return n.end_time = Date.now(), n.error = this.stringifyError(e), n.events.push({
      name: "error",
      time: new Date(n.end_time).toISOString()
    }), await ((s = this.onRetrieverError) == null ? void 0 : s.call(this, n)), await this._endTrace(n), n;
  }
  async handleText(e, t) {
    var s;
    const n = this.getRunById(t);
    !n || (n == null ? void 0 : n.run_type) !== "chain" || (n.events.push({
      name: "text",
      time: (/* @__PURE__ */ new Date()).toISOString(),
      kwargs: { text: e }
    }), await ((s = this.onText) == null ? void 0 : s.call(this, n)));
  }
  async handleLLMNewToken(e, t, n, s, a, i) {
    var c;
    const o = this.getRunById(n);
    if (!o || (o == null ? void 0 : o.run_type) !== "llm") throw new Error('Invalid "runId" provided to "handleLLMNewToken" callback.');
    return o.events.push({
      name: "new_token",
      time: (/* @__PURE__ */ new Date()).toISOString(),
      kwargs: {
        token: e,
        idx: t,
        chunk: i == null ? void 0 : i.chunk
      }
    }), await ((c = this.onLLMNewToken) == null ? void 0 : c.call(this, o, e, { chunk: i == null ? void 0 : i.chunk })), o;
  }
}, ml = { exports: {} };
ml.exports;
(function(r) {
  const t = (a = 0) => (i) => `\x1B[${38 + a};5;${i}m`, n = (a = 0) => (i, o, c) => `\x1B[${38 + a};2;${i};${o};${c}m`;
  function s() {
    const a = /* @__PURE__ */ new Map(), i = {
      modifier: {
        reset: [0, 0],
        // 21 isn't widely supported and 22 does the same thing
        bold: [1, 22],
        dim: [2, 22],
        italic: [3, 23],
        underline: [4, 24],
        overline: [53, 55],
        inverse: [7, 27],
        hidden: [8, 28],
        strikethrough: [9, 29]
      },
      color: {
        black: [30, 39],
        red: [31, 39],
        green: [32, 39],
        yellow: [33, 39],
        blue: [34, 39],
        magenta: [35, 39],
        cyan: [36, 39],
        white: [37, 39],
        // Bright color
        blackBright: [90, 39],
        redBright: [91, 39],
        greenBright: [92, 39],
        yellowBright: [93, 39],
        blueBright: [94, 39],
        magentaBright: [95, 39],
        cyanBright: [96, 39],
        whiteBright: [97, 39]
      },
      bgColor: {
        bgBlack: [40, 49],
        bgRed: [41, 49],
        bgGreen: [42, 49],
        bgYellow: [43, 49],
        bgBlue: [44, 49],
        bgMagenta: [45, 49],
        bgCyan: [46, 49],
        bgWhite: [47, 49],
        // Bright color
        bgBlackBright: [100, 49],
        bgRedBright: [101, 49],
        bgGreenBright: [102, 49],
        bgYellowBright: [103, 49],
        bgBlueBright: [104, 49],
        bgMagentaBright: [105, 49],
        bgCyanBright: [106, 49],
        bgWhiteBright: [107, 49]
      }
    };
    i.color.gray = i.color.blackBright, i.bgColor.bgGray = i.bgColor.bgBlackBright, i.color.grey = i.color.blackBright, i.bgColor.bgGrey = i.bgColor.bgBlackBright;
    for (const [o, c] of Object.entries(i)) {
      for (const [u, l] of Object.entries(c))
        i[u] = {
          open: `\x1B[${l[0]}m`,
          close: `\x1B[${l[1]}m`
        }, c[u] = i[u], a.set(l[0], l[1]);
      Object.defineProperty(i, o, {
        value: c,
        enumerable: !1
      });
    }
    return Object.defineProperty(i, "codes", {
      value: a,
      enumerable: !1
    }), i.color.close = "\x1B[39m", i.bgColor.close = "\x1B[49m", i.color.ansi256 = t(), i.color.ansi16m = n(), i.bgColor.ansi256 = t(10), i.bgColor.ansi16m = n(10), Object.defineProperties(i, {
      rgbToAnsi256: {
        value: (o, c, u) => o === c && c === u ? o < 8 ? 16 : o > 248 ? 231 : Math.round((o - 8) / 247 * 24) + 232 : 16 + 36 * Math.round(o / 255 * 5) + 6 * Math.round(c / 255 * 5) + Math.round(u / 255 * 5),
        enumerable: !1
      },
      hexToRgb: {
        value: (o) => {
          const c = /(?<colorString>[a-f\d]{6}|[a-f\d]{3})/i.exec(o.toString(16));
          if (!c)
            return [0, 0, 0];
          let { colorString: u } = c.groups;
          u.length === 3 && (u = u.split("").map((d) => d + d).join(""));
          const l = Number.parseInt(u, 16);
          return [
            l >> 16 & 255,
            l >> 8 & 255,
            l & 255
          ];
        },
        enumerable: !1
      },
      hexToAnsi256: {
        value: (o) => i.rgbToAnsi256(...i.hexToRgb(o)),
        enumerable: !1
      }
    }), i;
  }
  Object.defineProperty(r, "exports", {
    enumerable: !0,
    get: s
  });
})(ml);
var $S = ml.exports;
const og = /* @__PURE__ */ Ku($S);
var CS = {};
Ae(CS, { ConsoleCallbackHandler: () => Uc });
function Et(r, e) {
  return `${r.open}${e}${r.close}`;
}
function Jt(r, e) {
  try {
    return JSON.stringify(r, null, 2);
  } catch {
    return e;
  }
}
function ch(r) {
  return typeof r == "string" ? r.trim() : r == null ? r : Jt(r, r.toString());
}
function Kr(r) {
  if (!r.end_time) return "";
  const e = r.end_time - r.start_time;
  return e < 1e3 ? `${e}ms` : `${(e / 1e3).toFixed(2)}s`;
}
const { color: $t } = og;
var Uc = class extends us {
  constructor() {
    super(...arguments);
    v(this, "name", "console_callback_handler");
  }
  /**
  * Method used to persist the run. In this case, it simply returns a
  * resolved promise as there's no persistence logic.
  * @param _run The run to persist.
  * @returns A resolved promise.
  */
  persistRun(e) {
    return Promise.resolve();
  }
  /**
  * Method used to get all the parent runs of a given run.
  * @param run The run whose parents are to be retrieved.
  * @returns An array of parent runs.
  */
  getParents(e) {
    const t = [];
    let n = e;
    for (; n.parent_run_id; ) {
      const s = this.runMap.get(n.parent_run_id);
      if (s)
        t.push(s), n = s;
      else break;
    }
    return t;
  }
  /**
  * Method used to get a string representation of the run's lineage, which
  * is used in logging.
  * @param run The run whose lineage is to be retrieved.
  * @returns A string representation of the run's lineage.
  */
  getBreadcrumbs(e) {
    const n = [...this.getParents(e).reverse(), e].map((s, a, i) => {
      const o = `${s.execution_order}:${s.run_type}:${s.name}`;
      return a === i.length - 1 ? Et(og.bold, o) : o;
    }).join(" > ");
    return Et($t.grey, n);
  }
  /**
  * Method used to log the start of a chain run.
  * @param run The chain run that has started.
  * @returns void
  */
  onChainStart(e) {
    const t = this.getBreadcrumbs(e);
    console.log(`${Et($t.green, "[chain/start]")} [${t}] Entering Chain run with input: ${Jt(e.inputs, "[inputs]")}`);
  }
  /**
  * Method used to log the end of a chain run.
  * @param run The chain run that has ended.
  * @returns void
  */
  onChainEnd(e) {
    const t = this.getBreadcrumbs(e);
    console.log(`${Et($t.cyan, "[chain/end]")} [${t}] [${Kr(e)}] Exiting Chain run with output: ${Jt(e.outputs, "[outputs]")}`);
  }
  /**
  * Method used to log any errors of a chain run.
  * @param run The chain run that has errored.
  * @returns void
  */
  onChainError(e) {
    const t = this.getBreadcrumbs(e);
    console.log(`${Et($t.red, "[chain/error]")} [${t}] [${Kr(e)}] Chain run errored with error: ${Jt(e.error, "[error]")}`);
  }
  /**
  * Method used to log the start of an LLM run.
  * @param run The LLM run that has started.
  * @returns void
  */
  onLLMStart(e) {
    const t = this.getBreadcrumbs(e), n = "prompts" in e.inputs ? { prompts: e.inputs.prompts.map((s) => s.trim()) } : e.inputs;
    console.log(`${Et($t.green, "[llm/start]")} [${t}] Entering LLM run with input: ${Jt(n, "[inputs]")}`);
  }
  /**
  * Method used to log the end of an LLM run.
  * @param run The LLM run that has ended.
  * @returns void
  */
  onLLMEnd(e) {
    const t = this.getBreadcrumbs(e);
    console.log(`${Et($t.cyan, "[llm/end]")} [${t}] [${Kr(e)}] Exiting LLM run with output: ${Jt(e.outputs, "[response]")}`);
  }
  /**
  * Method used to log any errors of an LLM run.
  * @param run The LLM run that has errored.
  * @returns void
  */
  onLLMError(e) {
    const t = this.getBreadcrumbs(e);
    console.log(`${Et($t.red, "[llm/error]")} [${t}] [${Kr(e)}] LLM run errored with error: ${Jt(e.error, "[error]")}`);
  }
  /**
  * Method used to log the start of a tool run.
  * @param run The tool run that has started.
  * @returns void
  */
  onToolStart(e) {
    const t = this.getBreadcrumbs(e);
    console.log(`${Et($t.green, "[tool/start]")} [${t}] Entering Tool run with input: "${ch(e.inputs.input)}"`);
  }
  /**
  * Method used to log the end of a tool run.
  * @param run The tool run that has ended.
  * @returns void
  */
  onToolEnd(e) {
    var n;
    const t = this.getBreadcrumbs(e);
    console.log(`${Et($t.cyan, "[tool/end]")} [${t}] [${Kr(e)}] Exiting Tool run with output: "${ch((n = e.outputs) == null ? void 0 : n.output)}"`);
  }
  /**
  * Method used to log any errors of a tool run.
  * @param run The tool run that has errored.
  * @returns void
  */
  onToolError(e) {
    const t = this.getBreadcrumbs(e);
    console.log(`${Et($t.red, "[tool/error]")} [${t}] [${Kr(e)}] Tool run errored with error: ${Jt(e.error, "[error]")}`);
  }
  /**
  * Method used to log the start of a retriever run.
  * @param run The retriever run that has started.
  * @returns void
  */
  onRetrieverStart(e) {
    const t = this.getBreadcrumbs(e);
    console.log(`${Et($t.green, "[retriever/start]")} [${t}] Entering Retriever run with input: ${Jt(e.inputs, "[inputs]")}`);
  }
  /**
  * Method used to log the end of a retriever run.
  * @param run The retriever run that has ended.
  * @returns void
  */
  onRetrieverEnd(e) {
    const t = this.getBreadcrumbs(e);
    console.log(`${Et($t.cyan, "[retriever/end]")} [${t}] [${Kr(e)}] Exiting Retriever run with output: ${Jt(e.outputs, "[outputs]")}`);
  }
  /**
  * Method used to log any errors of a retriever run.
  * @param run The retriever run that has errored.
  * @returns void
  */
  onRetrieverError(e) {
    const t = this.getBreadcrumbs(e);
    console.log(`${Et($t.red, "[retriever/error]")} [${t}] [${Kr(e)}] Retriever run errored with error: ${Jt(e.error, "[error]")}`);
  }
  /**
  * Method used to log the action selected by the agent.
  * @param run The run in which the agent action occurred.
  * @returns void
  */
  onAgentAction(e) {
    const t = e, n = this.getBreadcrumbs(e);
    console.log(`${Et($t.blue, "[agent/action]")} [${n}] Agent selected action: ${Jt(t.actions[t.actions.length - 1], "[action]")}`);
  }
};
let ac;
const cg = () => {
  if (ac === void 0) {
    const r = Er("LANGCHAIN_CALLBACKS_BACKGROUND") === "false" ? { blockOnRootRunFinalization: !0 } : {};
    ac = new Js(r);
  }
  return ac;
};
let RS = class {
  getStore() {
  }
  run(e, t) {
    return t();
  }
};
const ic = Symbol.for("ls:tracing_async_local_storage"), NS = new RS();
let PS = class {
  getInstance() {
    return globalThis[ic] ?? NS;
  }
  initializeGlobalInstance(e) {
    globalThis[ic] === void 0 && (globalThis[ic] = e);
  }
};
const LS = new PS();
function MS(r = !1) {
  const e = LS.getInstance().getStore();
  if (!r && e === void 0)
    throw new Error(`Could not get the current run tree.

Please make sure you are calling this method within a traceable function and that tracing is enabled.`);
  return e;
}
function gl(r) {
  return typeof r == "function" && "langsmith:traceable" in r;
}
var DS = {};
Ae(DS, { LangChainTracer: () => ui });
var ui = class ug extends us {
  constructor(t = {}) {
    super(t);
    v(this, "name", "langchain_tracer");
    v(this, "projectName");
    v(this, "exampleId");
    v(this, "client");
    v(this, "replicas");
    v(this, "usesRunTreeMap", !0);
    const { exampleId: n, projectName: s, client: a, replicas: i } = t;
    this.projectName = s ?? Fm(), this.replicas = i, this.exampleId = n, this.client = a ?? cg();
    const o = ug.getTraceableRunTree();
    o && this.updateFromRunTree(o);
  }
  async persistRun(t) {
  }
  async onRunCreate(t) {
    const n = this.getRunTreeWithTracingConfig(t.id);
    await (n == null ? void 0 : n.postRun());
  }
  async onRunUpdate(t) {
    const n = this.getRunTreeWithTracingConfig(t.id);
    await (n == null ? void 0 : n.patchRun());
  }
  getRun(t) {
    return this.runTreeMap.get(t);
  }
  updateFromRunTree(t) {
    this.runTreeMap.set(t.id, t);
    let n = t;
    const s = /* @__PURE__ */ new Set();
    for (; n.parent_run && !(s.has(n.id) || (s.add(n.id), !n.parent_run)); )
      n = n.parent_run;
    s.clear();
    const a = [n];
    for (; a.length > 0; ) {
      const i = a.shift();
      !i || s.has(i.id) || (s.add(i.id), this.runTreeMap.set(i.id, i), i.child_runs && a.push(...i.child_runs));
    }
    this.client = t.client ?? this.client, this.replicas = t.replicas ?? this.replicas, this.projectName = t.project_name ?? this.projectName, this.exampleId = t.reference_example_id ?? this.exampleId;
  }
  getRunTreeWithTracingConfig(t) {
    const n = this.runTreeMap.get(t);
    if (n)
      return new Ct({
        ...n,
        client: this.client,
        project_name: this.projectName,
        replicas: this.replicas,
        reference_example_id: this.exampleId,
        tracingEnabled: !0
      });
  }
  static getTraceableRunTree() {
    try {
      return MS(!0);
    } catch {
      return;
    }
  }
};
let yn;
function jS() {
  const r = "default" in Dr ? Dr.default : Dr;
  return new r({
    autoStart: !0,
    concurrency: 1
  });
}
function FS() {
  return typeof yn > "u" && (yn = jS()), yn;
}
async function tt(r, e) {
  if (e === !0) {
    const t = Hs();
    t !== void 0 ? await t.run(void 0, async () => r()) : await r();
  } else
    yn = FS(), yn.add(async () => {
      const t = Hs();
      t !== void 0 ? await t.run(void 0, async () => r()) : await r();
    });
}
async function US() {
  const r = cg();
  await Promise.allSettled([typeof yn < "u" ? yn.onIdle() : Promise.resolve(), r.awaitPendingTraceBatches()]);
}
var zS = {};
Ae(zS, {
  awaitAllCallbacks: () => US,
  consumeCallback: () => tt
});
const BS = (r) => !![
  "LANGSMITH_TRACING_V2",
  "LANGCHAIN_TRACING_V2",
  "LANGSMITH_TRACING",
  "LANGCHAIN_TRACING"
].find((t) => Er(t) === "true");
function lg(r) {
  var n;
  const e = Hs();
  if (e === void 0) return;
  const t = e.getStore();
  return (n = t == null ? void 0 : t[js]) == null ? void 0 : n[r];
}
const ZS = Symbol("lc:configure_hooks"), VS = () => lg(ZS) || [];
var qS = {};
Ae(qS, {
  BaseCallbackManager: () => dg,
  BaseRunManager: () => ha,
  CallbackManager: () => Pt,
  CallbackManagerForChainRun: () => fg,
  CallbackManagerForLLMRun: () => zc,
  CallbackManagerForRetrieverRun: () => hg,
  CallbackManagerForToolRun: () => pg,
  ensureHandler: () => Ws,
  parseCallbackConfigArg: () => po
});
function po(r) {
  return r ? Array.isArray(r) || "name" in r ? { callbacks: r } : r : {};
}
var dg = class {
  setHandler(r) {
    return this.setHandlers([r]);
  }
}, ha = class {
  constructor(r, e, t, n, s, a, i, o) {
    this.runId = r, this.handlers = e, this.inheritableHandlers = t, this.tags = n, this.inheritableTags = s, this.metadata = a, this.inheritableMetadata = i, this._parentRunId = o;
  }
  get parentRunId() {
    return this._parentRunId;
  }
  async handleText(r) {
    await Promise.all(this.handlers.map((e) => tt(async () => {
      var t;
      try {
        await ((t = e.handleText) == null ? void 0 : t.call(e, r, this.runId, this._parentRunId, this.tags));
      } catch (n) {
        if ((e.raiseError ? console.error : console.warn)(`Error in handler ${e.constructor.name}, handleText: ${n}`), e.raiseError) throw n;
      }
    }, e.awaitHandlers)));
  }
  async handleCustomEvent(r, e, t, n, s) {
    await Promise.all(this.handlers.map((a) => tt(async () => {
      var i;
      try {
        await ((i = a.handleCustomEvent) == null ? void 0 : i.call(a, r, e, this.runId, this.tags, this.metadata));
      } catch (o) {
        if ((a.raiseError ? console.error : console.warn)(`Error in handler ${a.constructor.name}, handleCustomEvent: ${o}`), a.raiseError) throw o;
      }
    }, a.awaitHandlers)));
  }
}, hg = class extends ha {
  getChild(r) {
    const e = new Pt(this.runId);
    return e.setHandlers(this.inheritableHandlers), e.addTags(this.inheritableTags), e.addMetadata(this.inheritableMetadata), r && e.addTags([r], !1), e;
  }
  async handleRetrieverEnd(r) {
    await Promise.all(this.handlers.map((e) => tt(async () => {
      var t;
      if (!e.ignoreRetriever) try {
        await ((t = e.handleRetrieverEnd) == null ? void 0 : t.call(e, r, this.runId, this._parentRunId, this.tags));
      } catch (n) {
        if ((e.raiseError ? console.error : console.warn)(`Error in handler ${e.constructor.name}, handleRetriever`), e.raiseError) throw n;
      }
    }, e.awaitHandlers)));
  }
  async handleRetrieverError(r) {
    await Promise.all(this.handlers.map((e) => tt(async () => {
      var t;
      if (!e.ignoreRetriever) try {
        await ((t = e.handleRetrieverError) == null ? void 0 : t.call(e, r, this.runId, this._parentRunId, this.tags));
      } catch (n) {
        if ((e.raiseError ? console.error : console.warn)(`Error in handler ${e.constructor.name}, handleRetrieverError: ${n}`), e.raiseError) throw r;
      }
    }, e.awaitHandlers)));
  }
}, zc = class extends ha {
  async handleLLMNewToken(r, e, t, n, s, a) {
    await Promise.all(this.handlers.map((i) => tt(async () => {
      var o;
      if (!i.ignoreLLM) try {
        await ((o = i.handleLLMNewToken) == null ? void 0 : o.call(i, r, e ?? {
          prompt: 0,
          completion: 0
        }, this.runId, this._parentRunId, this.tags, a));
      } catch (c) {
        if ((i.raiseError ? console.error : console.warn)(`Error in handler ${i.constructor.name}, handleLLMNewToken: ${c}`), i.raiseError) throw c;
      }
    }, i.awaitHandlers)));
  }
  async handleLLMError(r, e, t, n, s) {
    await Promise.all(this.handlers.map((a) => tt(async () => {
      var i;
      if (!a.ignoreLLM) try {
        await ((i = a.handleLLMError) == null ? void 0 : i.call(a, r, this.runId, this._parentRunId, this.tags, s));
      } catch (o) {
        if ((a.raiseError ? console.error : console.warn)(`Error in handler ${a.constructor.name}, handleLLMError: ${o}`), a.raiseError) throw o;
      }
    }, a.awaitHandlers)));
  }
  async handleLLMEnd(r, e, t, n, s) {
    await Promise.all(this.handlers.map((a) => tt(async () => {
      var i;
      if (!a.ignoreLLM) try {
        await ((i = a.handleLLMEnd) == null ? void 0 : i.call(a, r, this.runId, this._parentRunId, this.tags, s));
      } catch (o) {
        if ((a.raiseError ? console.error : console.warn)(`Error in handler ${a.constructor.name}, handleLLMEnd: ${o}`), a.raiseError) throw o;
      }
    }, a.awaitHandlers)));
  }
}, fg = class extends ha {
  getChild(r) {
    const e = new Pt(this.runId);
    return e.setHandlers(this.inheritableHandlers), e.addTags(this.inheritableTags), e.addMetadata(this.inheritableMetadata), r && e.addTags([r], !1), e;
  }
  async handleChainError(r, e, t, n, s) {
    await Promise.all(this.handlers.map((a) => tt(async () => {
      var i;
      if (!a.ignoreChain) try {
        await ((i = a.handleChainError) == null ? void 0 : i.call(a, r, this.runId, this._parentRunId, this.tags, s));
      } catch (o) {
        if ((a.raiseError ? console.error : console.warn)(`Error in handler ${a.constructor.name}, handleChainError: ${o}`), a.raiseError) throw o;
      }
    }, a.awaitHandlers)));
  }
  async handleChainEnd(r, e, t, n, s) {
    await Promise.all(this.handlers.map((a) => tt(async () => {
      var i;
      if (!a.ignoreChain) try {
        await ((i = a.handleChainEnd) == null ? void 0 : i.call(a, r, this.runId, this._parentRunId, this.tags, s));
      } catch (o) {
        if ((a.raiseError ? console.error : console.warn)(`Error in handler ${a.constructor.name}, handleChainEnd: ${o}`), a.raiseError) throw o;
      }
    }, a.awaitHandlers)));
  }
  async handleAgentAction(r) {
    await Promise.all(this.handlers.map((e) => tt(async () => {
      var t;
      if (!e.ignoreAgent) try {
        await ((t = e.handleAgentAction) == null ? void 0 : t.call(e, r, this.runId, this._parentRunId, this.tags));
      } catch (n) {
        if ((e.raiseError ? console.error : console.warn)(`Error in handler ${e.constructor.name}, handleAgentAction: ${n}`), e.raiseError) throw n;
      }
    }, e.awaitHandlers)));
  }
  async handleAgentEnd(r) {
    await Promise.all(this.handlers.map((e) => tt(async () => {
      var t;
      if (!e.ignoreAgent) try {
        await ((t = e.handleAgentEnd) == null ? void 0 : t.call(e, r, this.runId, this._parentRunId, this.tags));
      } catch (n) {
        if ((e.raiseError ? console.error : console.warn)(`Error in handler ${e.constructor.name}, handleAgentEnd: ${n}`), e.raiseError) throw n;
      }
    }, e.awaitHandlers)));
  }
}, pg = class extends ha {
  getChild(r) {
    const e = new Pt(this.runId);
    return e.setHandlers(this.inheritableHandlers), e.addTags(this.inheritableTags), e.addMetadata(this.inheritableMetadata), r && e.addTags([r], !1), e;
  }
  async handleToolError(r) {
    await Promise.all(this.handlers.map((e) => tt(async () => {
      var t;
      if (!e.ignoreAgent) try {
        await ((t = e.handleToolError) == null ? void 0 : t.call(e, r, this.runId, this._parentRunId, this.tags));
      } catch (n) {
        if ((e.raiseError ? console.error : console.warn)(`Error in handler ${e.constructor.name}, handleToolError: ${n}`), e.raiseError) throw n;
      }
    }, e.awaitHandlers)));
  }
  async handleToolEnd(r) {
    await Promise.all(this.handlers.map((e) => tt(async () => {
      var t;
      if (!e.ignoreAgent) try {
        await ((t = e.handleToolEnd) == null ? void 0 : t.call(e, r, this.runId, this._parentRunId, this.tags));
      } catch (n) {
        if ((e.raiseError ? console.error : console.warn)(`Error in handler ${e.constructor.name}, handleToolEnd: ${n}`), e.raiseError) throw n;
      }
    }, e.awaitHandlers)));
  }
}, Pt = class Is extends dg {
  constructor(t, n) {
    super();
    v(this, "handlers", []);
    v(this, "inheritableHandlers", []);
    v(this, "tags", []);
    v(this, "inheritableTags", []);
    v(this, "metadata", {});
    v(this, "inheritableMetadata", {});
    v(this, "name", "callback_manager");
    v(this, "_parentRunId");
    this.handlers = (n == null ? void 0 : n.handlers) ?? this.handlers, this.inheritableHandlers = (n == null ? void 0 : n.inheritableHandlers) ?? this.inheritableHandlers, this.tags = (n == null ? void 0 : n.tags) ?? this.tags, this.inheritableTags = (n == null ? void 0 : n.inheritableTags) ?? this.inheritableTags, this.metadata = (n == null ? void 0 : n.metadata) ?? this.metadata, this.inheritableMetadata = (n == null ? void 0 : n.inheritableMetadata) ?? this.inheritableMetadata, this._parentRunId = t;
  }
  /**
  * Gets the parent run ID, if any.
  *
  * @returns The parent run ID.
  */
  getParentRunId() {
    return this._parentRunId;
  }
  async handleLLMStart(t, n, s = void 0, a = void 0, i = void 0, o = void 0, c = void 0, u = void 0) {
    return Promise.all(n.map(async (l, d) => {
      const h = d === 0 && s ? s : Lr();
      return await Promise.all(this.handlers.map((f) => {
        if (!f.ignoreLLM)
          return Fn(f) && f._createRunForLLMStart(t, [l], h, this._parentRunId, i, this.tags, this.metadata, u), tt(async () => {
            var p;
            try {
              await ((p = f.handleLLMStart) == null ? void 0 : p.call(f, t, [l], h, this._parentRunId, i, this.tags, this.metadata, u));
            } catch (y) {
              if ((f.raiseError ? console.error : console.warn)(`Error in handler ${f.constructor.name}, handleLLMStart: ${y}`), f.raiseError) throw y;
            }
          }, f.awaitHandlers);
      })), new zc(h, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);
    }));
  }
  async handleChatModelStart(t, n, s = void 0, a = void 0, i = void 0, o = void 0, c = void 0, u = void 0) {
    return Promise.all(n.map(async (l, d) => {
      const h = d === 0 && s ? s : Lr();
      return await Promise.all(this.handlers.map((f) => {
        if (!f.ignoreLLM)
          return Fn(f) && f._createRunForChatModelStart(t, [l], h, this._parentRunId, i, this.tags, this.metadata, u), tt(async () => {
            var p, y;
            try {
              if (f.handleChatModelStart) await ((p = f.handleChatModelStart) == null ? void 0 : p.call(f, t, [l], h, this._parentRunId, i, this.tags, this.metadata, u));
              else if (f.handleLLMStart) {
                const g = sl(l);
                await ((y = f.handleLLMStart) == null ? void 0 : y.call(f, t, [g], h, this._parentRunId, i, this.tags, this.metadata, u));
              }
            } catch (g) {
              if ((f.raiseError ? console.error : console.warn)(`Error in handler ${f.constructor.name}, handleLLMStart: ${g}`), f.raiseError) throw g;
            }
          }, f.awaitHandlers);
      })), new zc(h, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);
    }));
  }
  async handleChainStart(t, n, s = Lr(), a = void 0, i = void 0, o = void 0, c = void 0) {
    return await Promise.all(this.handlers.map((u) => {
      if (!u.ignoreChain)
        return Fn(u) && u._createRunForChainStart(t, n, s, this._parentRunId, this.tags, this.metadata, a, c), tt(async () => {
          var l;
          try {
            await ((l = u.handleChainStart) == null ? void 0 : l.call(u, t, n, s, this._parentRunId, this.tags, this.metadata, a, c));
          } catch (d) {
            if ((u.raiseError ? console.error : console.warn)(`Error in handler ${u.constructor.name}, handleChainStart: ${d}`), u.raiseError) throw d;
          }
        }, u.awaitHandlers);
    })), new fg(s, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);
  }
  async handleToolStart(t, n, s = Lr(), a = void 0, i = void 0, o = void 0, c = void 0) {
    return await Promise.all(this.handlers.map((u) => {
      if (!u.ignoreAgent)
        return Fn(u) && u._createRunForToolStart(t, n, s, this._parentRunId, this.tags, this.metadata, c), tt(async () => {
          var l;
          try {
            await ((l = u.handleToolStart) == null ? void 0 : l.call(u, t, n, s, this._parentRunId, this.tags, this.metadata, c));
          } catch (d) {
            if ((u.raiseError ? console.error : console.warn)(`Error in handler ${u.constructor.name}, handleToolStart: ${d}`), u.raiseError) throw d;
          }
        }, u.awaitHandlers);
    })), new pg(s, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);
  }
  async handleRetrieverStart(t, n, s = Lr(), a = void 0, i = void 0, o = void 0, c = void 0) {
    return await Promise.all(this.handlers.map((u) => {
      if (!u.ignoreRetriever)
        return Fn(u) && u._createRunForRetrieverStart(t, n, s, this._parentRunId, this.tags, this.metadata, c), tt(async () => {
          var l;
          try {
            await ((l = u.handleRetrieverStart) == null ? void 0 : l.call(u, t, n, s, this._parentRunId, this.tags, this.metadata, c));
          } catch (d) {
            if ((u.raiseError ? console.error : console.warn)(`Error in handler ${u.constructor.name}, handleRetrieverStart: ${d}`), u.raiseError) throw d;
          }
        }, u.awaitHandlers);
    })), new hg(s, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);
  }
  async handleCustomEvent(t, n, s, a, i) {
    await Promise.all(this.handlers.map((o) => tt(async () => {
      var c;
      if (!o.ignoreCustomEvent) try {
        await ((c = o.handleCustomEvent) == null ? void 0 : c.call(o, t, n, s, this.tags, this.metadata));
      } catch (u) {
        if ((o.raiseError ? console.error : console.warn)(`Error in handler ${o.constructor.name}, handleCustomEvent: ${u}`), o.raiseError) throw u;
      }
    }, o.awaitHandlers)));
  }
  addHandler(t, n = !0) {
    this.handlers.push(t), n && this.inheritableHandlers.push(t);
  }
  removeHandler(t) {
    this.handlers = this.handlers.filter((n) => n !== t), this.inheritableHandlers = this.inheritableHandlers.filter((n) => n !== t);
  }
  setHandlers(t, n = !0) {
    this.handlers = [], this.inheritableHandlers = [];
    for (const s of t) this.addHandler(s, n);
  }
  addTags(t, n = !0) {
    this.removeTags(t), this.tags.push(...t), n && this.inheritableTags.push(...t);
  }
  removeTags(t) {
    this.tags = this.tags.filter((n) => !t.includes(n)), this.inheritableTags = this.inheritableTags.filter((n) => !t.includes(n));
  }
  addMetadata(t, n = !0) {
    this.metadata = {
      ...this.metadata,
      ...t
    }, n && (this.inheritableMetadata = {
      ...this.inheritableMetadata,
      ...t
    });
  }
  removeMetadata(t) {
    for (const n of Object.keys(t))
      delete this.metadata[n], delete this.inheritableMetadata[n];
  }
  copy(t = [], n = !0) {
    const s = new Is(this._parentRunId);
    for (const a of this.handlers) {
      const i = this.inheritableHandlers.includes(a);
      s.addHandler(a, i);
    }
    for (const a of this.tags) {
      const i = this.inheritableTags.includes(a);
      s.addTags([a], i);
    }
    for (const a of Object.keys(this.metadata)) {
      const i = Object.keys(this.inheritableMetadata).includes(a);
      s.addMetadata({ [a]: this.metadata[a] }, i);
    }
    for (const a of t)
      s.handlers.filter((i) => i.name === "console_callback_handler").some((i) => i.name === a.name) || s.addHandler(a, n);
    return s;
  }
  static fromHandlers(t) {
    class n extends la {
      constructor() {
        super();
        v(this, "name", Lr());
        Object.assign(this, t);
      }
    }
    const s = new this();
    return s.addHandler(new n()), s;
  }
  static configure(t, n, s, a, i, o, c) {
    return this._configureSync(t, n, s, a, i, o, c);
  }
  static _configureSync(t, n, s, a, i, o, c) {
    var f;
    let u;
    (t || n) && (Array.isArray(t) || !t ? (u = new Is(), u.setHandlers((t == null ? void 0 : t.map(Ws)) ?? [], !0)) : u = t, u = u.copy(Array.isArray(n) ? n.map(Ws) : n == null ? void 0 : n.handlers, !1));
    const l = Er("LANGCHAIN_VERBOSE") === "true" || (c == null ? void 0 : c.verbose), d = ((f = ui.getTraceableRunTree()) == null ? void 0 : f.tracingEnabled) || BS(), h = d || (Er("LANGCHAIN_TRACING") ?? !1);
    if (l || h) {
      if (u || (u = new Is()), l && !u.handlers.some((p) => p.name === Uc.prototype.name)) {
        const p = new Uc();
        u.addHandler(p, !0);
      }
      if (h && !u.handlers.some((p) => p.name === "langchain_tracer") && d) {
        const p = new ui();
        u.addHandler(p, !0);
      }
      if (d) {
        const p = ui.getTraceableRunTree();
        if (p && u._parentRunId === void 0) {
          u._parentRunId = p.id;
          const y = u.handlers.find((g) => g.name === "langchain_tracer");
          y == null || y.updateFromRunTree(p);
        }
      }
    }
    for (const { contextVar: p, inheritable: y = !0, handlerClass: g, envVar: S } of VS()) {
      const _ = S && Er(S) === "true" && g;
      let w;
      const T = p !== void 0 ? lg(p) : void 0;
      T && Mm(T) ? w = T : _ && (w = new g({})), w !== void 0 && (u || (u = new Is()), u.handlers.some((x) => x.name === w.name) || u.addHandler(w, y));
    }
    return (s || a) && u && (u.addTags(s ?? []), u.addTags(a ?? [], !1)), (i || o) && u && (u.addMetadata(i ?? {}), u.addMetadata(o ?? {}, !1)), u;
  }
};
function Ws(r) {
  return "name" in r ? r : la.fromMethods(r);
}
var mg = class {
  getStore() {
  }
  run(r, e) {
    return e();
  }
  enterWith(r) {
  }
};
const HS = new mg(), uh = Symbol.for("lc:child_config");
var JS = class {
  getInstance() {
    return Hs() ?? HS;
  }
  getRunnableConfig() {
    var e, t;
    return (t = (e = this.getInstance().getStore()) == null ? void 0 : e.extra) == null ? void 0 : t[uh];
  }
  runWithConfig(r, e, t) {
    var u;
    const n = Pt._configureSync(r == null ? void 0 : r.callbacks, void 0, r == null ? void 0 : r.tags, void 0, r == null ? void 0 : r.metadata), s = this.getInstance(), a = s.getStore(), i = n == null ? void 0 : n.getParentRunId(), o = (u = n == null ? void 0 : n.handlers) == null ? void 0 : u.find((l) => (l == null ? void 0 : l.name) === "langchain_tracer");
    let c;
    return o && i ? c = o.getRunTreeWithTracingConfig(i) : t || (c = new Ct({
      name: "<runnable_lambda>",
      tracingEnabled: !1
    })), c && (c.extra = {
      ...c.extra,
      [uh]: r
    }), a !== void 0 && a[js] !== void 0 && (c === void 0 && (c = {}), c[js] = a[js]), s.run(c, e);
  }
  initializeGlobalInstance(r) {
    Hs() === void 0 && Mv(r);
  }
};
const lr = new JS();
var WS = {};
Ae(WS, {
  AsyncLocalStorageProviderSingleton: () => lr,
  MockAsyncLocalStorage: () => mg,
  _CONTEXT_VARIABLES_KEY: () => js
});
const oc = 25;
async function Zt(r) {
  return Pt._configureSync(r == null ? void 0 : r.callbacks, void 0, r == null ? void 0 : r.tags, void 0, r == null ? void 0 : r.metadata);
}
function xi(...r) {
  const e = {};
  for (const t of r.filter((n) => !!n)) for (const n of Object.keys(t)) if (n === "metadata") e[n] = {
    ...e[n],
    ...t[n]
  };
  else if (n === "tags") {
    const s = e[n] ?? [];
    e[n] = [...new Set(s.concat(t[n] ?? []))];
  } else if (n === "configurable") e[n] = {
    ...e[n],
    ...t[n]
  };
  else if (n === "timeout")
    e.timeout === void 0 ? e.timeout = t.timeout : t.timeout !== void 0 && (e.timeout = Math.min(e.timeout, t.timeout));
  else if (n === "signal")
    e.signal === void 0 ? e.signal = t.signal : t.signal !== void 0 && ("any" in AbortSignal ? e.signal = AbortSignal.any([e.signal, t.signal]) : e.signal = t.signal);
  else if (n === "callbacks") {
    const s = e.callbacks, a = t.callbacks;
    if (Array.isArray(a)) if (!s) e.callbacks = a;
    else if (Array.isArray(s)) e.callbacks = s.concat(a);
    else {
      const i = s.copy();
      for (const o of a) i.addHandler(Ws(o), !0);
      e.callbacks = i;
    }
    else if (a) if (!s) e.callbacks = a;
    else if (Array.isArray(s)) {
      const i = a.copy();
      for (const o of s) i.addHandler(Ws(o), !0);
      e.callbacks = i;
    } else e.callbacks = new Pt(a._parentRunId, {
      handlers: s.handlers.concat(a.handlers),
      inheritableHandlers: s.inheritableHandlers.concat(a.inheritableHandlers),
      tags: Array.from(new Set(s.tags.concat(a.tags))),
      inheritableTags: Array.from(new Set(s.inheritableTags.concat(a.inheritableTags))),
      metadata: {
        ...s.metadata,
        ...a.metadata
      }
    });
  } else {
    const s = n;
    e[s] = t[s] ?? e[s];
  }
  return e;
}
const GS = /* @__PURE__ */ new Set([
  "string",
  "number",
  "boolean"
]);
function Ce(r) {
  var n;
  const e = lr.getRunnableConfig();
  let t = {
    tags: [],
    metadata: {},
    recursionLimit: 25,
    runId: void 0
  };
  if (e) {
    const { runId: s, runName: a, ...i } = e;
    t = Object.entries(i).reduce((o, [c, u]) => (u !== void 0 && (o[c] = u), o), t);
  }
  if (r && (t = Object.entries(r).reduce((s, [a, i]) => (i !== void 0 && (s[a] = i), s), t)), t != null && t.configurable)
    for (const s of Object.keys(t.configurable)) GS.has(typeof t.configurable[s]) && !((n = t.metadata) != null && n[s]) && (t.metadata || (t.metadata = {}), t.metadata[s] = t.configurable[s]);
  if (t.timeout !== void 0) {
    if (t.timeout <= 0) throw new Error("Timeout must be a positive number");
    const s = AbortSignal.timeout(t.timeout);
    t.signal !== void 0 ? "any" in AbortSignal && (t.signal = AbortSignal.any([t.signal, s])) : t.signal = s, delete t.timeout;
  }
  return t;
}
function Be(r = {}, { callbacks: e, maxConcurrency: t, recursionLimit: n, runName: s, configurable: a, runId: i } = {}) {
  const o = Ce(r);
  return e !== void 0 && (delete o.runName, o.callbacks = e), n !== void 0 && (o.recursionLimit = n), t !== void 0 && (o.maxConcurrency = t), s !== void 0 && (o.runName = s), a !== void 0 && (o.configurable = {
    ...o.configurable,
    ...a
  }), i !== void 0 && delete o.runId, o;
}
function Ur(r) {
  if (r)
    return {
      configurable: r.configurable,
      recursionLimit: r.recursionLimit,
      callbacks: r.callbacks,
      tags: r.tags,
      metadata: r.metadata,
      maxConcurrency: r.maxConcurrency,
      timeout: r.timeout,
      signal: r.signal,
      store: r.store
    };
}
async function zr(r, e) {
  if (e === void 0) return r;
  let t;
  return Promise.race([r.catch((n) => {
    if (!(e != null && e.aborted))
      throw n;
  }), new Promise((n, s) => {
    t = () => {
      s(Gs(e));
    }, e.addEventListener("abort", t), e.aborted && s(Gs(e));
  })]).finally(() => e.removeEventListener("abort", t));
}
function Gs(r) {
  return (r == null ? void 0 : r.reason) instanceof Error ? r.reason : typeof (r == null ? void 0 : r.reason) == "string" ? new Error(r.reason) : /* @__PURE__ */ new Error("Aborted");
}
var KS = {};
Ae(KS, {
  AsyncGeneratorWithSetup: () => kn,
  IterableReadableStream: () => dr,
  atee: () => _l,
  concat: () => sn,
  pipeGeneratorWithSetup: () => gg
});
var dr = class Bc extends ReadableStream {
  constructor() {
    super(...arguments);
    v(this, "reader");
  }
  ensureReader() {
    this.reader || (this.reader = this.getReader());
  }
  async next() {
    this.ensureReader();
    try {
      const t = await this.reader.read();
      return t.done ? (this.reader.releaseLock(), {
        done: !0,
        value: void 0
      }) : {
        done: !1,
        value: t.value
      };
    } catch (t) {
      throw this.reader.releaseLock(), t;
    }
  }
  async return() {
    if (this.ensureReader(), this.locked) {
      const t = this.reader.cancel();
      this.reader.releaseLock(), await t;
    }
    return {
      done: !0,
      value: void 0
    };
  }
  async throw(t) {
    if (this.ensureReader(), this.locked) {
      const n = this.reader.cancel();
      this.reader.releaseLock(), await n;
    }
    throw t;
  }
  [Symbol.asyncIterator]() {
    return this;
  }
  async [Symbol.asyncDispose]() {
    await this.return();
  }
  static fromReadableStream(t) {
    const n = t.getReader();
    return new Bc({
      start(s) {
        return a();
        function a() {
          return n.read().then(({ done: i, value: o }) => {
            if (i) {
              s.close();
              return;
            }
            return s.enqueue(o), a();
          });
        }
      },
      cancel() {
        n.releaseLock();
      }
    });
  }
  static fromAsyncGenerator(t) {
    return new Bc({
      async pull(n) {
        const { value: s, done: a } = await t.next();
        a && n.close(), n.enqueue(s);
      },
      async cancel(n) {
        await t.return(n);
      }
    });
  }
};
function _l(r, e = 2) {
  const t = Array.from({ length: e }, () => []);
  return t.map(async function* (s) {
    for (; ; ) if (s.length === 0) {
      const a = await r.next();
      for (const i of t) i.push(a);
    } else {
      if (s[0].done) return;
      yield s.shift().value;
    }
  });
}
function sn(r, e) {
  if (Array.isArray(r) && Array.isArray(e)) return r.concat(e);
  if (typeof r == "string" && typeof e == "string") return r + e;
  if (typeof r == "number" && typeof e == "number") return r + e;
  if ("concat" in r && typeof r.concat == "function") return r.concat(e);
  if (typeof r == "object" && typeof e == "object") {
    const t = { ...r };
    for (const [n, s] of Object.entries(e)) n in t && !Array.isArray(t[n]) ? t[n] = sn(t[n], s) : t[n] = s;
    return t;
  } else throw new Error(`Cannot concat ${typeof r} and ${typeof e}`);
}
var kn = class {
  constructor(r) {
    v(this, "generator");
    v(this, "setup");
    v(this, "config");
    v(this, "signal");
    v(this, "firstResult");
    v(this, "firstResultUsed", !1);
    var e;
    this.generator = r.generator, this.config = r.config, this.signal = r.signal ?? ((e = this.config) == null ? void 0 : e.signal), this.setup = new Promise((t, n) => {
      lr.runWithConfig(Ur(r.config), async () => {
        this.firstResult = r.generator.next(), r.startSetup ? this.firstResult.then(r.startSetup).then(t, n) : this.firstResult.then((s) => t(void 0), n);
      }, !0);
    });
  }
  async next(...r) {
    var e;
    return (e = this.signal) == null || e.throwIfAborted(), this.firstResultUsed ? lr.runWithConfig(Ur(this.config), this.signal ? async () => zr(this.generator.next(...r), this.signal) : async () => this.generator.next(...r), !0) : (this.firstResultUsed = !0, this.firstResult);
  }
  async return(r) {
    return this.generator.return(r);
  }
  async throw(r) {
    return this.generator.throw(r);
  }
  [Symbol.asyncIterator]() {
    return this;
  }
  async [Symbol.asyncDispose]() {
    await this.return();
  }
};
async function gg(r, e, t, n, ...s) {
  const a = new kn({
    generator: e,
    startSetup: t,
    signal: n
  }), i = await a.setup;
  return {
    output: r(a, i, ...s),
    setup: i
  };
}
/*!
* https://github.com/Starcounter-Jack/JSON-Patch
* (c) 2017-2022 Joachim Wester
* MIT licensed
*/
const YS = Object.prototype.hasOwnProperty;
function Zc(r, e) {
  return YS.call(r, e);
}
function Vc(r) {
  if (Array.isArray(r)) {
    const t = new Array(r.length);
    for (let n = 0; n < t.length; n++) t[n] = "" + n;
    return t;
  }
  if (Object.keys) return Object.keys(r);
  let e = [];
  for (let t in r) Zc(r, t) && e.push(t);
  return e;
}
function cr(r) {
  switch (typeof r) {
    case "object":
      return JSON.parse(JSON.stringify(r));
    case "undefined":
      return null;
    default:
      return r;
  }
}
function qc(r) {
  let e = 0;
  const t = r.length;
  let n;
  for (; e < t; ) {
    if (n = r.charCodeAt(e), n >= 48 && n <= 57) {
      e++;
      continue;
    }
    return !1;
  }
  return !0;
}
function Pn(r) {
  return r.indexOf("/") === -1 && r.indexOf("~") === -1 ? r : r.replace(/~/g, "~0").replace(/\//g, "~1");
}
function XS(r) {
  return r.replace(/~1/g, "/").replace(/~0/g, "~");
}
function Hc(r) {
  if (r === void 0) return !0;
  if (r) {
    if (Array.isArray(r)) {
      for (let t = 0, n = r.length; t < n; t++) if (Hc(r[t])) return !0;
    } else if (typeof r == "object") {
      const t = Vc(r), n = t.length;
      for (var e = 0; e < n; e++) if (Hc(r[t[e]])) return !0;
    }
  }
  return !1;
}
function lh(r, e) {
  const t = [r];
  for (const n in e) {
    const s = typeof e[n] == "object" ? JSON.stringify(e[n], null, 2) : e[n];
    typeof s < "u" && t.push(`${n}: ${s}`);
  }
  return t.join(`
`);
}
var QS = class extends Error {
  constructor(r, e, t, n, s) {
    super(lh(r, {
      name: e,
      index: t,
      operation: n,
      tree: s
    })), this.name = e, this.index = t, this.operation = n, this.tree = s, Object.setPrototypeOf(this, new.target.prototype), this.message = lh(r, {
      name: e,
      index: t,
      operation: n,
      tree: s
    });
  }
}, _g = {};
Ae(_g, {
  JsonPatchError: () => Ge,
  _areEquals: () => Ks,
  applyOperation: () => wn,
  applyPatch: () => Yn,
  applyReducer: () => rT,
  deepClone: () => eT,
  getValueByPointer: () => Ii,
  validate: () => yg,
  validator: () => ki
});
const Ge = QS, eT = cr, Vn = {
  add: function(r, e, t) {
    return r[e] = this.value, { newDocument: t };
  },
  remove: function(r, e, t) {
    var n = r[e];
    return delete r[e], {
      newDocument: t,
      removed: n
    };
  },
  replace: function(r, e, t) {
    var n = r[e];
    return r[e] = this.value, {
      newDocument: t,
      removed: n
    };
  },
  move: function(r, e, t) {
    let n = Ii(t, this.path);
    n && (n = cr(n));
    const s = wn(t, {
      op: "remove",
      path: this.from
    }).removed;
    return wn(t, {
      op: "add",
      path: this.path,
      value: s
    }), {
      newDocument: t,
      removed: n
    };
  },
  copy: function(r, e, t) {
    const n = Ii(t, this.from);
    return wn(t, {
      op: "add",
      path: this.path,
      value: cr(n)
    }), { newDocument: t };
  },
  test: function(r, e, t) {
    return {
      newDocument: t,
      test: Ks(r[e], this.value)
    };
  },
  _get: function(r, e, t) {
    return this.value = r[e], { newDocument: t };
  }
};
var tT = {
  add: function(r, e, t) {
    return qc(e) ? r.splice(e, 0, this.value) : r[e] = this.value, {
      newDocument: t,
      index: e
    };
  },
  remove: function(r, e, t) {
    var n = r.splice(e, 1);
    return {
      newDocument: t,
      removed: n[0]
    };
  },
  replace: function(r, e, t) {
    var n = r[e];
    return r[e] = this.value, {
      newDocument: t,
      removed: n
    };
  },
  move: Vn.move,
  copy: Vn.copy,
  test: Vn.test,
  _get: Vn._get
};
function Ii(r, e) {
  if (e == "") return r;
  var t = {
    op: "_get",
    path: e
  };
  return wn(r, t), t.value;
}
function wn(r, e, t = !1, n = !0, s = !0, a = 0) {
  if (t && (typeof t == "function" ? t(e, 0, r, e.path) : ki(e, 0)), e.path === "") {
    let i = { newDocument: r };
    if (e.op === "add")
      return i.newDocument = e.value, i;
    if (e.op === "replace")
      return i.newDocument = e.value, i.removed = r, i;
    if (e.op === "move" || e.op === "copy")
      return i.newDocument = Ii(r, e.from), e.op === "move" && (i.removed = r), i;
    if (e.op === "test") {
      if (i.test = Ks(r, e.value), i.test === !1) throw new Ge("Test operation failed", "TEST_OPERATION_FAILED", a, e, r);
      return i.newDocument = r, i;
    } else {
      if (e.op === "remove")
        return i.removed = r, i.newDocument = null, i;
      if (e.op === "_get")
        return e.value = r, i;
      if (t) throw new Ge("Operation `op` property is not one of operations defined in RFC-6902", "OPERATION_OP_INVALID", a, e, r);
      return i;
    }
  } else {
    n || (r = cr(r));
    const o = (e.path || "").split("/");
    let c = r, u = 1, l = o.length, d, h, f;
    for (typeof t == "function" ? f = t : f = ki; ; ) {
      if (h = o[u], h && h.indexOf("~") != -1 && (h = XS(h)), s && (h == "__proto__" || h == "prototype" && u > 0 && o[u - 1] == "constructor")) throw new TypeError("JSON-Patch: modifying `__proto__` or `constructor/prototype` prop is banned for security reasons, if this was on purpose, please set `banPrototypeModifications` flag false and pass it to this function. More info in fast-json-patch README");
      if (t && d === void 0 && (c[h] === void 0 ? d = o.slice(0, u).join("/") : u == l - 1 && (d = e.path), d !== void 0 && f(e, 0, r, d)), u++, Array.isArray(c)) {
        if (h === "-") h = c.length;
        else {
          if (t && !qc(h)) throw new Ge("Expected an unsigned base-10 integer value, making the new referenced value the array element with the zero-based index", "OPERATION_PATH_ILLEGAL_ARRAY_INDEX", a, e, r);
          qc(h) && (h = ~~h);
        }
        if (u >= l) {
          if (t && e.op === "add" && h > c.length) throw new Ge("The specified index MUST NOT be greater than the number of elements in the array", "OPERATION_VALUE_OUT_OF_BOUNDS", a, e, r);
          const p = tT[e.op].call(e, c, h, r);
          if (p.test === !1) throw new Ge("Test operation failed", "TEST_OPERATION_FAILED", a, e, r);
          return p;
        }
      } else if (u >= l) {
        const p = Vn[e.op].call(e, c, h, r);
        if (p.test === !1) throw new Ge("Test operation failed", "TEST_OPERATION_FAILED", a, e, r);
        return p;
      }
      if (c = c[h], t && u < l && (!c || typeof c != "object")) throw new Ge("Cannot perform operation at the desired path", "OPERATION_PATH_UNRESOLVABLE", a, e, r);
    }
  }
}
function Yn(r, e, t, n = !0, s = !0) {
  if (t && !Array.isArray(e))
    throw new Ge("Patch sequence must be an array", "SEQUENCE_NOT_AN_ARRAY");
  n || (r = cr(r));
  const a = new Array(e.length);
  for (let i = 0, o = e.length; i < o; i++)
    a[i] = wn(r, e[i], t, !0, s, i), r = a[i].newDocument;
  return a.newDocument = r, a;
}
function rT(r, e, t) {
  const n = wn(r, e);
  if (n.test === !1) throw new Ge("Test operation failed", "TEST_OPERATION_FAILED", t, e, r);
  return n.newDocument;
}
function ki(r, e, t, n) {
  if (typeof r != "object" || r === null || Array.isArray(r)) throw new Ge("Operation is not an object", "OPERATION_NOT_AN_OBJECT", e, r, t);
  if (Vn[r.op]) {
    if (typeof r.path != "string") throw new Ge("Operation `path` property is not a string", "OPERATION_PATH_INVALID", e, r, t);
    if (r.path.indexOf("/") !== 0 && r.path.length > 0) throw new Ge('Operation `path` property must start with "/"', "OPERATION_PATH_INVALID", e, r, t);
    if ((r.op === "move" || r.op === "copy") && typeof r.from != "string") throw new Ge("Operation `from` property is not present (applicable in `move` and `copy` operations)", "OPERATION_FROM_REQUIRED", e, r, t);
    if ((r.op === "add" || r.op === "replace" || r.op === "test") && r.value === void 0) throw new Ge("Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)", "OPERATION_VALUE_REQUIRED", e, r, t);
    if ((r.op === "add" || r.op === "replace" || r.op === "test") && Hc(r.value)) throw new Ge("Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)", "OPERATION_VALUE_CANNOT_CONTAIN_UNDEFINED", e, r, t);
    if (t) {
      if (r.op == "add") {
        var s = r.path.split("/").length, a = n.split("/").length;
        if (s !== a + 1 && s !== a) throw new Ge("Cannot perform an `add` operation at the desired path", "OPERATION_PATH_CANNOT_ADD", e, r, t);
      } else if (r.op === "replace" || r.op === "remove" || r.op === "_get") {
        if (r.path !== n) throw new Ge("Cannot perform the operation at a path that does not exist", "OPERATION_PATH_UNRESOLVABLE", e, r, t);
      } else if (r.op === "move" || r.op === "copy") {
        var i = {
          op: "_get",
          path: r.from,
          value: void 0
        }, o = yg([i], t);
        if (o && o.name === "OPERATION_PATH_UNRESOLVABLE") throw new Ge("Cannot perform the operation from a path that does not exist", "OPERATION_FROM_UNRESOLVABLE", e, r, t);
      }
    }
  } else throw new Ge("Operation `op` property is not one of operations defined in RFC-6902", "OPERATION_OP_INVALID", e, r, t);
}
function yg(r, e, t) {
  try {
    if (!Array.isArray(r)) throw new Ge("Patch sequence must be an array", "SEQUENCE_NOT_AN_ARRAY");
    if (e) Yn(cr(e), cr(r), t || !0);
    else {
      t = t || ki;
      for (var n = 0; n < r.length; n++) t(r[n], n, e, void 0);
    }
  } catch (s) {
    if (s instanceof Ge) return s;
    throw s;
  }
}
function Ks(r, e) {
  if (r === e) return !0;
  if (r && e && typeof r == "object" && typeof e == "object") {
    var t = Array.isArray(r), n = Array.isArray(e), s, a, i;
    if (t && n) {
      if (a = r.length, a != e.length) return !1;
      for (s = a; s-- !== 0; ) if (!Ks(r[s], e[s])) return !1;
      return !0;
    }
    if (t != n) return !1;
    var o = Object.keys(r);
    if (a = o.length, a !== Object.keys(e).length) return !1;
    for (s = a; s-- !== 0; ) if (!e.hasOwnProperty(o[s])) return !1;
    for (s = a; s-- !== 0; )
      if (i = o[s], !Ks(r[i], e[i])) return !1;
    return !0;
  }
  return r !== r && e !== e;
}
function wg(r, e, t, n, s) {
  if (e !== r) {
    typeof e.toJSON == "function" && (e = e.toJSON());
    for (var a = Vc(e), i = Vc(r), o = !1, c = i.length - 1; c >= 0; c--) {
      var u = i[c], l = r[u];
      if (Zc(e, u) && !(e[u] === void 0 && l !== void 0 && Array.isArray(e) === !1)) {
        var d = e[u];
        typeof l == "object" && l != null && typeof d == "object" && d != null && Array.isArray(l) === Array.isArray(d) ? wg(l, d, t, n + "/" + Pn(u), s) : l !== d && (s && t.push({
          op: "test",
          path: n + "/" + Pn(u),
          value: cr(l)
        }), t.push({
          op: "replace",
          path: n + "/" + Pn(u),
          value: cr(d)
        }));
      } else Array.isArray(r) === Array.isArray(e) ? (s && t.push({
        op: "test",
        path: n + "/" + Pn(u),
        value: cr(l)
      }), t.push({
        op: "remove",
        path: n + "/" + Pn(u)
      }), o = !0) : (s && t.push({
        op: "test",
        path: n,
        value: r
      }), t.push({
        op: "replace",
        path: n,
        value: e
      }));
    }
    if (!(!o && a.length == i.length))
      for (var c = 0; c < a.length; c++) {
        var u = a[c];
        !Zc(r, u) && e[u] !== void 0 && t.push({
          op: "add",
          path: n + "/" + Pn(u),
          value: cr(e[u])
        });
      }
  }
}
function yl(r, e, t = !1) {
  var n = [];
  return wg(r, e, n, "", t), n;
}
({
  ..._g
});
var nT = {};
Ae(nT, {
  LogStreamCallbackHandler: () => Wc,
  RunLog: () => wl,
  RunLogPatch: () => Mr,
  isLogStreamHandler: () => vg
});
var Mr = class {
  constructor(r) {
    v(this, "ops");
    this.ops = r.ops ?? [];
  }
  concat(r) {
    const e = this.ops.concat(r.ops), t = Yn({}, e);
    return new wl({
      ops: e,
      state: t[t.length - 1].newDocument
    });
  }
}, wl = class Jc extends Mr {
  constructor(t) {
    super(t);
    v(this, "state");
    this.state = t.state;
  }
  concat(t) {
    const n = this.ops.concat(t.ops), s = Yn(this.state, t.ops);
    return new Jc({
      ops: n,
      state: s[s.length - 1].newDocument
    });
  }
  static fromRunLogPatch(t) {
    const n = Yn({}, t.ops);
    return new Jc({
      ops: t.ops,
      state: n[n.length - 1].newDocument
    });
  }
};
const vg = (r) => r.name === "log_stream_tracer";
async function dh(r, e) {
  if (e === "original") throw new Error("Do not assign inputs with original schema drop the key for now. When inputs are added to streamLog they should be added with standardized schema for streaming events.");
  const { inputs: t } = r;
  if ([
    "retriever",
    "llm",
    "prompt"
  ].includes(r.run_type)) return t;
  if (!(Object.keys(t).length === 1 && (t == null ? void 0 : t.input) === ""))
    return t.input;
}
async function hh(r, e) {
  const { outputs: t } = r;
  return e === "original" || [
    "retriever",
    "llm",
    "prompt"
  ].includes(r.run_type) ? t : t !== void 0 && Object.keys(t).length === 1 && (t == null ? void 0 : t.output) !== void 0 ? t.output : t;
}
function sT(r) {
  return r !== void 0 && r.message !== void 0;
}
var Wc = class extends us {
  constructor(e) {
    super({
      _awaitHandler: !0,
      ...e
    });
    v(this, "autoClose", !0);
    v(this, "includeNames");
    v(this, "includeTypes");
    v(this, "includeTags");
    v(this, "excludeNames");
    v(this, "excludeTypes");
    v(this, "excludeTags");
    v(this, "_schemaFormat", "original");
    v(this, "rootId");
    v(this, "keyMapByRunId", {});
    v(this, "counterMapByRunName", {});
    v(this, "transformStream");
    v(this, "writer");
    v(this, "receiveStream");
    v(this, "name", "log_stream_tracer");
    v(this, "lc_prefer_streaming", !0);
    this.autoClose = (e == null ? void 0 : e.autoClose) ?? !0, this.includeNames = e == null ? void 0 : e.includeNames, this.includeTypes = e == null ? void 0 : e.includeTypes, this.includeTags = e == null ? void 0 : e.includeTags, this.excludeNames = e == null ? void 0 : e.excludeNames, this.excludeTypes = e == null ? void 0 : e.excludeTypes, this.excludeTags = e == null ? void 0 : e.excludeTags, this._schemaFormat = (e == null ? void 0 : e._schemaFormat) ?? this._schemaFormat, this.transformStream = new TransformStream(), this.writer = this.transformStream.writable.getWriter(), this.receiveStream = dr.fromReadableStream(this.transformStream.readable);
  }
  [Symbol.asyncIterator]() {
    return this.receiveStream;
  }
  async persistRun(e) {
  }
  _includeRun(e) {
    if (e.id === this.rootId) return !1;
    const t = e.tags ?? [];
    let n = this.includeNames === void 0 && this.includeTags === void 0 && this.includeTypes === void 0;
    return this.includeNames !== void 0 && (n = n || this.includeNames.includes(e.name)), this.includeTypes !== void 0 && (n = n || this.includeTypes.includes(e.run_type)), this.includeTags !== void 0 && (n = n || t.find((s) => {
      var a;
      return (a = this.includeTags) == null ? void 0 : a.includes(s);
    }) !== void 0), this.excludeNames !== void 0 && (n = n && !this.excludeNames.includes(e.name)), this.excludeTypes !== void 0 && (n = n && !this.excludeTypes.includes(e.run_type)), this.excludeTags !== void 0 && (n = n && t.every((s) => {
      var a;
      return !((a = this.excludeTags) != null && a.includes(s));
    })), n;
  }
  async *tapOutputIterable(e, t) {
    for await (const n of t) {
      if (e !== this.rootId) {
        const s = this.keyMapByRunId[e];
        s && await this.writer.write(new Mr({ ops: [{
          op: "add",
          path: `/logs/${s}/streamed_output/-`,
          value: n
        }] }));
      }
      yield n;
    }
  }
  async onRunCreate(e) {
    var s;
    if (this.rootId === void 0 && (this.rootId = e.id, await this.writer.write(new Mr({ ops: [{
      op: "replace",
      path: "",
      value: {
        id: e.id,
        name: e.name,
        type: e.run_type,
        streamed_output: [],
        final_output: void 0,
        logs: {}
      }
    }] }))), !this._includeRun(e)) return;
    this.counterMapByRunName[e.name] === void 0 && (this.counterMapByRunName[e.name] = 0), this.counterMapByRunName[e.name] += 1;
    const t = this.counterMapByRunName[e.name];
    this.keyMapByRunId[e.id] = t === 1 ? e.name : `${e.name}:${t}`;
    const n = {
      id: e.id,
      name: e.name,
      type: e.run_type,
      tags: e.tags ?? [],
      metadata: ((s = e.extra) == null ? void 0 : s.metadata) ?? {},
      start_time: new Date(e.start_time).toISOString(),
      streamed_output: [],
      streamed_output_str: [],
      final_output: void 0,
      end_time: void 0
    };
    this._schemaFormat === "streaming_events" && (n.inputs = await dh(e, this._schemaFormat)), await this.writer.write(new Mr({ ops: [{
      op: "add",
      path: `/logs/${this.keyMapByRunId[e.id]}`,
      value: n
    }] }));
  }
  async onRunUpdate(e) {
    try {
      const t = this.keyMapByRunId[e.id];
      if (t === void 0) return;
      const n = [];
      this._schemaFormat === "streaming_events" && n.push({
        op: "replace",
        path: `/logs/${t}/inputs`,
        value: await dh(e, this._schemaFormat)
      }), n.push({
        op: "add",
        path: `/logs/${t}/final_output`,
        value: await hh(e, this._schemaFormat)
      }), e.end_time !== void 0 && n.push({
        op: "add",
        path: `/logs/${t}/end_time`,
        value: new Date(e.end_time).toISOString()
      });
      const s = new Mr({ ops: n });
      await this.writer.write(s);
    } finally {
      if (e.id === this.rootId) {
        const t = new Mr({ ops: [{
          op: "replace",
          path: "/final_output",
          value: await hh(e, this._schemaFormat)
        }] });
        await this.writer.write(t), this.autoClose && await this.writer.close();
      }
    }
  }
  async onLLMNewToken(e, t, n) {
    const s = this.keyMapByRunId[e.id];
    if (s === void 0) return;
    const a = e.inputs.messages !== void 0;
    let i;
    a ? sT(n == null ? void 0 : n.chunk) ? i = n == null ? void 0 : n.chunk : i = new Ar({
      id: `run-${e.id}`,
      content: t
    }) : i = t;
    const o = new Mr({ ops: [{
      op: "add",
      path: `/logs/${s}/streamed_output_str/-`,
      value: t
    }, {
      op: "add",
      path: `/logs/${s}/streamed_output/-`,
      value: i
    }] });
    await this.writer.write(o);
  }
}, aT = {};
Ae(aT, {
  ChatGenerationChunk: () => Qn,
  GenerationChunk: () => Xn,
  RUN_KEY: () => Ys
});
const Ys = "__run";
var Xn = class bg {
  constructor(e) {
    v(this, "text");
    v(this, "generationInfo");
    this.text = e.text, this.generationInfo = e.generationInfo;
  }
  concat(e) {
    return new bg({
      text: this.text + e.text,
      generationInfo: {
        ...this.generationInfo,
        ...e.generationInfo
      }
    });
  }
}, Qn = class Sg extends Xn {
  constructor(t) {
    super(t);
    v(this, "message");
    this.message = t.message;
  }
  concat(t) {
    return new Sg({
      text: this.text + t.text,
      generationInfo: {
        ...this.generationInfo,
        ...t.generationInfo
      },
      message: this.message.concat(t.message)
    });
  }
};
function Fa({ name: r, serialized: e }) {
  return r !== void 0 ? r : (e == null ? void 0 : e.name) !== void 0 ? e.name : (e == null ? void 0 : e.id) !== void 0 && Array.isArray(e == null ? void 0 : e.id) ? e.id[e.id.length - 1] : "Unnamed";
}
const iT = (r) => r.name === "event_stream_tracer";
var oT = class extends us {
  constructor(e) {
    super({
      _awaitHandler: !0,
      ...e
    });
    v(this, "autoClose", !0);
    v(this, "includeNames");
    v(this, "includeTypes");
    v(this, "includeTags");
    v(this, "excludeNames");
    v(this, "excludeTypes");
    v(this, "excludeTags");
    v(this, "runInfoMap", /* @__PURE__ */ new Map());
    v(this, "tappedPromises", /* @__PURE__ */ new Map());
    v(this, "transformStream");
    v(this, "writer");
    v(this, "receiveStream");
    v(this, "name", "event_stream_tracer");
    v(this, "lc_prefer_streaming", !0);
    this.autoClose = (e == null ? void 0 : e.autoClose) ?? !0, this.includeNames = e == null ? void 0 : e.includeNames, this.includeTypes = e == null ? void 0 : e.includeTypes, this.includeTags = e == null ? void 0 : e.includeTags, this.excludeNames = e == null ? void 0 : e.excludeNames, this.excludeTypes = e == null ? void 0 : e.excludeTypes, this.excludeTags = e == null ? void 0 : e.excludeTags, this.transformStream = new TransformStream(), this.writer = this.transformStream.writable.getWriter(), this.receiveStream = dr.fromReadableStream(this.transformStream.readable);
  }
  [Symbol.asyncIterator]() {
    return this.receiveStream;
  }
  async persistRun(e) {
  }
  _includeRun(e) {
    const t = e.tags ?? [];
    let n = this.includeNames === void 0 && this.includeTags === void 0 && this.includeTypes === void 0;
    return this.includeNames !== void 0 && (n = n || this.includeNames.includes(e.name)), this.includeTypes !== void 0 && (n = n || this.includeTypes.includes(e.runType)), this.includeTags !== void 0 && (n = n || t.find((s) => {
      var a;
      return (a = this.includeTags) == null ? void 0 : a.includes(s);
    }) !== void 0), this.excludeNames !== void 0 && (n = n && !this.excludeNames.includes(e.name)), this.excludeTypes !== void 0 && (n = n && !this.excludeTypes.includes(e.runType)), this.excludeTags !== void 0 && (n = n && t.every((s) => {
      var a;
      return !((a = this.excludeTags) != null && a.includes(s));
    })), n;
  }
  async *tapOutputIterable(e, t) {
    const n = await t.next();
    if (n.done) return;
    const s = this.runInfoMap.get(e);
    if (s === void 0) {
      yield n.value;
      return;
    }
    function a(o, c) {
      return o === "llm" && typeof c == "string" ? new Xn({ text: c }) : c;
    }
    let i = this.tappedPromises.get(e);
    if (i === void 0) {
      let o;
      i = new Promise((c) => {
        o = c;
      }), this.tappedPromises.set(e, i);
      try {
        const c = {
          event: `on_${s.runType}_stream`,
          run_id: e,
          name: s.name,
          tags: s.tags,
          metadata: s.metadata,
          data: {}
        };
        await this.send({
          ...c,
          data: { chunk: a(s.runType, n.value) }
        }, s), yield n.value;
        for await (const u of t)
          s.runType !== "tool" && s.runType !== "retriever" && await this.send({
            ...c,
            data: { chunk: a(s.runType, u) }
          }, s), yield u;
      } finally {
        o == null || o();
      }
    } else {
      yield n.value;
      for await (const o of t) yield o;
    }
  }
  async send(e, t) {
    this._includeRun(t) && await this.writer.write(e);
  }
  async sendEndEvent(e, t) {
    const n = this.tappedPromises.get(e.run_id);
    n !== void 0 ? n.then(() => {
      this.send(e, t);
    }) : await this.send(e, t);
  }
  async onLLMStart(e) {
    var i, o;
    const t = Fa(e), n = e.inputs.messages !== void 0 ? "chat_model" : "llm", s = {
      tags: e.tags ?? [],
      metadata: ((i = e.extra) == null ? void 0 : i.metadata) ?? {},
      name: t,
      runType: n,
      inputs: e.inputs
    };
    this.runInfoMap.set(e.id, s);
    const a = `on_${n}_start`;
    await this.send({
      event: a,
      data: { input: e.inputs },
      name: t,
      tags: e.tags ?? [],
      run_id: e.id,
      metadata: ((o = e.extra) == null ? void 0 : o.metadata) ?? {}
    }, s);
  }
  async onLLMNewToken(e, t, n) {
    const s = this.runInfoMap.get(e.id);
    let a, i;
    if (s === void 0) throw new Error(`onLLMNewToken: Run ID ${e.id} not found in run map.`);
    if (this.runInfoMap.size !== 1) {
      if (s.runType === "chat_model")
        i = "on_chat_model_stream", (n == null ? void 0 : n.chunk) === void 0 ? a = new Ar({
          content: t,
          id: `run-${e.id}`
        }) : a = n.chunk.message;
      else if (s.runType === "llm")
        i = "on_llm_stream", (n == null ? void 0 : n.chunk) === void 0 ? a = new Xn({ text: t }) : a = n.chunk;
      else throw new Error(`Unexpected run type ${s.runType}`);
      await this.send({
        event: i,
        data: { chunk: a },
        run_id: e.id,
        name: s.name,
        tags: s.tags,
        metadata: s.metadata
      }, s);
    }
  }
  async onLLMEnd(e) {
    var i, o, c;
    const t = this.runInfoMap.get(e.id);
    this.runInfoMap.delete(e.id);
    let n;
    if (t === void 0) throw new Error(`onLLMEnd: Run ID ${e.id} not found in run map.`);
    const s = (i = e.outputs) == null ? void 0 : i.generations;
    let a;
    if (t.runType === "chat_model") {
      for (const u of s ?? []) {
        if (a !== void 0) break;
        a = (o = u[0]) == null ? void 0 : o.message;
      }
      n = "on_chat_model_end";
    } else if (t.runType === "llm")
      a = {
        generations: s == null ? void 0 : s.map((u) => u.map((l) => ({
          text: l.text,
          generationInfo: l.generationInfo
        }))),
        llmOutput: ((c = e.outputs) == null ? void 0 : c.llmOutput) ?? {}
      }, n = "on_llm_end";
    else throw new Error(`onLLMEnd: Unexpected run type: ${t.runType}`);
    await this.sendEndEvent({
      event: n,
      data: {
        output: a,
        input: t.inputs
      },
      run_id: e.id,
      name: t.name,
      tags: t.tags,
      metadata: t.metadata
    }, t);
  }
  async onChainStart(e) {
    var i, o;
    const t = Fa(e), n = e.run_type ?? "chain", s = {
      tags: e.tags ?? [],
      metadata: ((i = e.extra) == null ? void 0 : i.metadata) ?? {},
      name: t,
      runType: e.run_type
    };
    let a = {};
    e.inputs.input === "" && Object.keys(e.inputs).length === 1 ? (a = {}, s.inputs = {}) : e.inputs.input !== void 0 ? (a.input = e.inputs.input, s.inputs = e.inputs.input) : (a.input = e.inputs, s.inputs = e.inputs), this.runInfoMap.set(e.id, s), await this.send({
      event: `on_${n}_start`,
      data: a,
      name: t,
      tags: e.tags ?? [],
      run_id: e.id,
      metadata: ((o = e.extra) == null ? void 0 : o.metadata) ?? {}
    }, s);
  }
  async onChainEnd(e) {
    var o;
    const t = this.runInfoMap.get(e.id);
    if (this.runInfoMap.delete(e.id), t === void 0) throw new Error(`onChainEnd: Run ID ${e.id} not found in run map.`);
    const n = `on_${e.run_type}_end`, s = e.inputs ?? t.inputs ?? {}, i = {
      output: ((o = e.outputs) == null ? void 0 : o.output) ?? e.outputs,
      input: s
    };
    s.input && Object.keys(s).length === 1 && (i.input = s.input, t.inputs = s.input), await this.sendEndEvent({
      event: n,
      data: i,
      run_id: e.id,
      name: t.name,
      tags: t.tags,
      metadata: t.metadata ?? {}
    }, t);
  }
  async onToolStart(e) {
    var s, a;
    const t = Fa(e), n = {
      tags: e.tags ?? [],
      metadata: ((s = e.extra) == null ? void 0 : s.metadata) ?? {},
      name: t,
      runType: "tool",
      inputs: e.inputs ?? {}
    };
    this.runInfoMap.set(e.id, n), await this.send({
      event: "on_tool_start",
      data: { input: e.inputs ?? {} },
      name: t,
      run_id: e.id,
      tags: e.tags ?? [],
      metadata: ((a = e.extra) == null ? void 0 : a.metadata) ?? {}
    }, n);
  }
  async onToolEnd(e) {
    var s;
    const t = this.runInfoMap.get(e.id);
    if (this.runInfoMap.delete(e.id), t === void 0) throw new Error(`onToolEnd: Run ID ${e.id} not found in run map.`);
    if (t.inputs === void 0) throw new Error(`onToolEnd: Run ID ${e.id} is a tool call, and is expected to have traced inputs.`);
    const n = ((s = e.outputs) == null ? void 0 : s.output) === void 0 ? e.outputs : e.outputs.output;
    await this.sendEndEvent({
      event: "on_tool_end",
      data: {
        output: n,
        input: t.inputs
      },
      run_id: e.id,
      name: t.name,
      tags: t.tags,
      metadata: t.metadata
    }, t);
  }
  async onRetrieverStart(e) {
    var a, i;
    const t = Fa(e), s = {
      tags: e.tags ?? [],
      metadata: ((a = e.extra) == null ? void 0 : a.metadata) ?? {},
      name: t,
      runType: "retriever",
      inputs: { query: e.inputs.query }
    };
    this.runInfoMap.set(e.id, s), await this.send({
      event: "on_retriever_start",
      data: { input: { query: e.inputs.query } },
      name: t,
      tags: e.tags ?? [],
      run_id: e.id,
      metadata: ((i = e.extra) == null ? void 0 : i.metadata) ?? {}
    }, s);
  }
  async onRetrieverEnd(e) {
    var n;
    const t = this.runInfoMap.get(e.id);
    if (this.runInfoMap.delete(e.id), t === void 0) throw new Error(`onRetrieverEnd: Run ID ${e.id} not found in run map.`);
    await this.sendEndEvent({
      event: "on_retriever_end",
      data: {
        output: ((n = e.outputs) == null ? void 0 : n.documents) ?? e.outputs,
        input: t.inputs
      },
      run_id: e.id,
      name: t.name,
      tags: t.tags,
      metadata: t.metadata
    }, t);
  }
  async handleCustomEvent(e, t, n) {
    const s = this.runInfoMap.get(n);
    if (s === void 0) throw new Error(`handleCustomEvent: Run ID ${n} not found in run map.`);
    await this.send({
      event: "on_custom_event",
      run_id: n,
      name: e,
      tags: s.tags,
      metadata: s.metadata,
      data: t
    }, s);
  }
  async finish() {
    const e = [...this.tappedPromises.values()];
    Promise.all(e).finally(() => {
      this.writer.close();
    });
  }
};
const cT = Object.prototype.toString, uT = (r) => cT.call(r) === "[object Error]", lT = /* @__PURE__ */ new Set([
  "network error",
  "Failed to fetch",
  "NetworkError when attempting to fetch resource.",
  "The Internet connection appears to be offline.",
  "Network request failed",
  "fetch failed",
  "terminated",
  " A network error occurred.",
  "Network connection lost"
]);
function dT(r) {
  if (!(r && uT(r) && r.name === "TypeError" && typeof r.message == "string")) return !1;
  const { message: t, stack: n } = r;
  return t === "Load failed" ? n === void 0 || "__sentry_captured__" in r : t.startsWith("error sending request for url") ? !0 : lT.has(t);
}
function hT(r) {
  if (typeof r == "number") {
    if (r < 0) throw new TypeError("Expected `retries` to be a non-negative number.");
    if (Number.isNaN(r)) throw new TypeError("Expected `retries` to be a valid number or Infinity, got NaN.");
  } else if (r !== void 0) throw new TypeError("Expected `retries` to be a number or Infinity.");
}
function Ua(r, e, { min: t = 0, allowInfinity: n = !1 } = {}) {
  if (e !== void 0) {
    if (typeof e != "number" || Number.isNaN(e)) throw new TypeError(`Expected \`${r}\` to be a number${n ? " or Infinity" : ""}.`);
    if (!n && !Number.isFinite(e)) throw new TypeError(`Expected \`${r}\` to be a finite number.`);
    if (e < t) throw new TypeError(`Expected \`${r}\` to be â‰¥ ${t}.`);
  }
}
var fT = class extends Error {
  constructor(r) {
    super(), r instanceof Error ? (this.originalError = r, { message: r } = r) : (this.originalError = new Error(r), this.originalError.stack = this.stack), this.name = "AbortError", this.message = r;
  }
};
function pT(r, e) {
  const t = Math.max(1, r + 1), n = e.randomize ? Math.random() + 1 : 1;
  let s = Math.round(n * e.minTimeout * e.factor ** (t - 1));
  return s = Math.min(s, e.maxTimeout), s;
}
function fh(r, e) {
  return Number.isFinite(e) ? e - (performance.now() - r) : e;
}
async function mT({ error: r, attemptNumber: e, retriesConsumed: t, startTime: n, options: s }) {
  var f, p, y;
  const a = r instanceof Error ? r : /* @__PURE__ */ new TypeError(`Non-error was thrown: "${r}". You should only throw errors.`);
  if (a instanceof fT) throw a.originalError;
  const i = Number.isFinite(s.retries) ? Math.max(0, s.retries - t) : s.retries, o = s.maxRetryTime ?? Number.POSITIVE_INFINITY, c = Object.freeze({
    error: a,
    attemptNumber: e,
    retriesLeft: i,
    retriesConsumed: t
  });
  if (await s.onFailedAttempt(c), fh(n, o) <= 0) throw a;
  const u = await s.shouldConsumeRetry(c), l = fh(n, o);
  if (l <= 0 || i <= 0) throw a;
  if (a instanceof TypeError && !dT(a)) {
    if (u) throw a;
    return (f = s.signal) == null || f.throwIfAborted(), !1;
  }
  if (!await s.shouldRetry(c)) throw a;
  if (!u)
    return (p = s.signal) == null || p.throwIfAborted(), !1;
  const d = pT(t, s), h = Math.min(d, l);
  return h > 0 && await new Promise((g, S) => {
    var T, x;
    const _ = () => {
      var A;
      clearTimeout(w), (A = s.signal) == null || A.removeEventListener("abort", _), S(s.signal.reason);
    }, w = setTimeout(() => {
      var A;
      (A = s.signal) == null || A.removeEventListener("abort", _), g();
    }, h);
    s.unref && ((T = w.unref) == null || T.call(w)), (x = s.signal) == null || x.addEventListener("abort", _, { once: !0 });
  }), (y = s.signal) == null || y.throwIfAborted(), !0;
}
async function Gc(r, e = {}) {
  var a, i, o;
  if (e = { ...e }, hT(e.retries), Object.hasOwn(e, "forever")) throw new Error("The `forever` option is no longer supported. For many use-cases, you can set `retries: Infinity` instead.");
  e.retries ?? (e.retries = 10), e.factor ?? (e.factor = 2), e.minTimeout ?? (e.minTimeout = 1e3), e.maxTimeout ?? (e.maxTimeout = Number.POSITIVE_INFINITY), e.maxRetryTime ?? (e.maxRetryTime = Number.POSITIVE_INFINITY), e.randomize ?? (e.randomize = !1), e.onFailedAttempt ?? (e.onFailedAttempt = () => {
  }), e.shouldRetry ?? (e.shouldRetry = () => !0), e.shouldConsumeRetry ?? (e.shouldConsumeRetry = () => !0), Ua("factor", e.factor, {
    min: 0,
    allowInfinity: !1
  }), Ua("minTimeout", e.minTimeout, {
    min: 0,
    allowInfinity: !1
  }), Ua("maxTimeout", e.maxTimeout, {
    min: 0,
    allowInfinity: !0
  }), Ua("maxRetryTime", e.maxRetryTime, {
    min: 0,
    allowInfinity: !0
  }), e.factor > 0 || (e.factor = 1), (a = e.signal) == null || a.throwIfAborted();
  let t = 0, n = 0;
  const s = performance.now();
  for (; !Number.isFinite(e.retries) || n <= e.retries; ) {
    t++;
    try {
      (i = e.signal) == null || i.throwIfAborted();
      const c = await r(t);
      return (o = e.signal) == null || o.throwIfAborted(), c;
    } catch (c) {
      await mT({
        error: c,
        attemptNumber: t,
        retriesConsumed: n,
        startTime: s,
        options: e
      }) && n++;
    }
  }
  throw new Error("Retry attempts exhausted without throwing an error.");
}
var gT = {};
Ae(gT, { AsyncCaller: () => fa });
const _T = [
  400,
  401,
  402,
  403,
  404,
  405,
  406,
  407,
  409
], yT = (r) => {
  var t, n;
  if (r.message.startsWith("Cancel") || r.message.startsWith("AbortError") || r.name === "AbortError" || (r == null ? void 0 : r.code) === "ECONNABORTED") throw r;
  const e = ((t = r == null ? void 0 : r.response) == null ? void 0 : t.status) ?? (r == null ? void 0 : r.status);
  if (e && _T.includes(+e)) throw r;
  if (((n = r == null ? void 0 : r.error) == null ? void 0 : n.code) === "insufficient_quota") {
    const s = new Error(r == null ? void 0 : r.message);
    throw s.name = "InsufficientQuotaError", s;
  }
};
var fa = class {
  constructor(r) {
    v(this, "maxConcurrency");
    v(this, "maxRetries");
    v(this, "onFailedAttempt");
    v(this, "queue");
    this.maxConcurrency = r.maxConcurrency ?? 1 / 0, this.maxRetries = r.maxRetries ?? 6, this.onFailedAttempt = r.onFailedAttempt ?? yT;
    const e = "default" in Dr ? Dr.default : Dr;
    this.queue = new e({ concurrency: this.maxConcurrency });
  }
  async call(r, ...e) {
    return this.queue.add(() => Gc(() => r(...e).catch((t) => {
      throw t instanceof Error ? t : new Error(t);
    }), {
      onFailedAttempt: ({ error: t }) => {
        var n;
        return (n = this.onFailedAttempt) == null ? void 0 : n.call(this, t);
      },
      retries: this.maxRetries,
      randomize: !0
    }), { throwOnTimeout: !0 });
  }
  callWithOptions(r, e, ...t) {
    if (r.signal) {
      let n;
      return Promise.race([this.call(e, ...t), new Promise((s, a) => {
        var i;
        n = () => {
          a(Gs(r.signal));
        }, (i = r.signal) == null || i.addEventListener("abort", n);
      })]).finally(() => {
        r.signal && n && r.signal.removeEventListener("abort", n);
      });
    }
    return this.call(e, ...t);
  }
  fetch(...r) {
    return this.call(() => fetch(...r).then((e) => e.ok ? e : Promise.reject(e)));
  }
}, Tg = class extends us {
  constructor({ config: e, onStart: t, onEnd: n, onError: s }) {
    super({ _awaitHandler: !0 });
    v(this, "name", "RootListenersTracer");
    /** The Run's ID. Type UUID */
    v(this, "rootId");
    v(this, "config");
    v(this, "argOnStart");
    v(this, "argOnEnd");
    v(this, "argOnError");
    this.config = e, this.argOnStart = t, this.argOnEnd = n, this.argOnError = s;
  }
  /**
  * This is a legacy method only called once for an entire run tree
  * therefore not useful here
  * @param {Run} _ Not used
  */
  persistRun(e) {
    return Promise.resolve();
  }
  async onRunCreate(e) {
    this.rootId || (this.rootId = e.id, this.argOnStart && await this.argOnStart(e, this.config));
  }
  async onRunUpdate(e) {
    e.id === this.rootId && (e.error ? this.argOnError && await this.argOnError(e, this.config) : this.argOnEnd && await this.argOnEnd(e, this.config));
  }
};
function vl(r) {
  return r ? r.lc_runnable : !1;
}
var wT = class {
  constructor(r) {
    v(this, "includeNames");
    v(this, "includeTypes");
    v(this, "includeTags");
    v(this, "excludeNames");
    v(this, "excludeTypes");
    v(this, "excludeTags");
    this.includeNames = r.includeNames, this.includeTypes = r.includeTypes, this.includeTags = r.includeTags, this.excludeNames = r.excludeNames, this.excludeTypes = r.excludeTypes, this.excludeTags = r.excludeTags;
  }
  includeEvent(r, e) {
    let t = this.includeNames === void 0 && this.includeTypes === void 0 && this.includeTags === void 0;
    const n = r.tags ?? [];
    return this.includeNames !== void 0 && (t = t || this.includeNames.includes(r.name)), this.includeTypes !== void 0 && (t = t || this.includeTypes.includes(e)), this.includeTags !== void 0 && (t = t || n.some((s) => {
      var a;
      return (a = this.includeTags) == null ? void 0 : a.includes(s);
    })), this.excludeNames !== void 0 && (t = t && !this.excludeNames.includes(r.name)), this.excludeTypes !== void 0 && (t = t && !this.excludeTypes.includes(e)), this.excludeTags !== void 0 && (t = t && n.every((s) => {
      var a;
      return !((a = this.excludeTags) != null && a.includes(s));
    })), t;
  }
};
const vT = (r) => btoa(r).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
function L(r, e, t) {
  function n(o, c) {
    if (o._zod || Object.defineProperty(o, "_zod", {
      value: {
        def: c,
        constr: i,
        traits: /* @__PURE__ */ new Set()
      },
      enumerable: !1
    }), o._zod.traits.has(r))
      return;
    o._zod.traits.add(r), e(o, c);
    const u = i.prototype, l = Object.keys(u);
    for (let d = 0; d < l.length; d++) {
      const h = l[d];
      h in o || (o[h] = u[h].bind(o));
    }
  }
  const s = (t == null ? void 0 : t.Parent) ?? Object;
  class a extends s {
  }
  Object.defineProperty(a, "name", { value: r });
  function i(o) {
    var c;
    const u = t != null && t.Parent ? new a() : this;
    n(u, o), (c = u._zod).deferred ?? (c.deferred = []);
    for (const l of u._zod.deferred)
      l();
    return u;
  }
  return Object.defineProperty(i, "init", { value: n }), Object.defineProperty(i, Symbol.hasInstance, {
    value: (o) => {
      var c, u;
      return t != null && t.Parent && o instanceof t.Parent ? !0 : (u = (c = o == null ? void 0 : o._zod) == null ? void 0 : c.traits) == null ? void 0 : u.has(r);
    }
  }), Object.defineProperty(i, "name", { value: r }), i;
}
class Wn extends Error {
  constructor() {
    super("Encountered Promise during synchronous parse. Use .parseAsync() instead.");
  }
}
class Eg extends Error {
  constructor(e) {
    super(`Encountered unidirectional transform during encode: ${e}`), this.name = "ZodEncodeError";
  }
}
const xg = {};
function Tn(r) {
  return xg;
}
function Ig(r) {
  const e = Object.values(r).filter((n) => typeof n == "number");
  return Object.entries(r).filter(([n, s]) => e.indexOf(+n) === -1).map(([n, s]) => s);
}
function Kc(r, e) {
  return typeof e == "bigint" ? e.toString() : e;
}
function bl(r) {
  return {
    get value() {
      {
        const e = r();
        return Object.defineProperty(this, "value", { value: e }), e;
      }
    }
  };
}
function Sl(r) {
  return r == null;
}
function Tl(r) {
  const e = r.startsWith("^") ? 1 : 0, t = r.endsWith("$") ? r.length - 1 : r.length;
  return r.slice(e, t);
}
function bT(r, e) {
  const t = (r.toString().split(".")[1] || "").length, n = e.toString();
  let s = (n.split(".")[1] || "").length;
  if (s === 0 && /\d?e-\d?/.test(n)) {
    const c = n.match(/\d?e-(\d?)/);
    c != null && c[1] && (s = Number.parseInt(c[1]));
  }
  const a = t > s ? t : s, i = Number.parseInt(r.toFixed(a).replace(".", "")), o = Number.parseInt(e.toFixed(a).replace(".", ""));
  return i % o / 10 ** a;
}
const ph = Symbol("evaluating");
function ze(r, e, t) {
  let n;
  Object.defineProperty(r, e, {
    get() {
      if (n !== ph)
        return n === void 0 && (n = ph, n = t()), n;
    },
    set(s) {
      Object.defineProperty(r, e, {
        value: s
        // configurable: true,
      });
    },
    configurable: !0
  });
}
function On(r, e, t) {
  Object.defineProperty(r, e, {
    value: t,
    writable: !0,
    enumerable: !0,
    configurable: !0
  });
}
function An(...r) {
  const e = {};
  for (const t of r) {
    const n = Object.getOwnPropertyDescriptors(t);
    Object.assign(e, n);
  }
  return Object.defineProperties({}, e);
}
function mh(r) {
  return JSON.stringify(r);
}
function ST(r) {
  return r.toLowerCase().trim().replace(/[^\w\s-]/g, "").replace(/[\s_-]+/g, "-").replace(/^-+|-+$/g, "");
}
const kg = "captureStackTrace" in Error ? Error.captureStackTrace : (...r) => {
};
function Oi(r) {
  return typeof r == "object" && r !== null && !Array.isArray(r);
}
const TT = bl(() => {
  var r;
  if (typeof navigator < "u" && ((r = navigator == null ? void 0 : navigator.userAgent) != null && r.includes("Cloudflare")))
    return !1;
  try {
    const e = Function;
    return new e(""), !0;
  } catch {
    return !1;
  }
});
function Xs(r) {
  if (Oi(r) === !1)
    return !1;
  const e = r.constructor;
  if (e === void 0 || typeof e != "function")
    return !0;
  const t = e.prototype;
  return !(Oi(t) === !1 || Object.prototype.hasOwnProperty.call(t, "isPrototypeOf") === !1);
}
function Og(r) {
  return Xs(r) ? { ...r } : Array.isArray(r) ? [...r] : r;
}
const ET = /* @__PURE__ */ new Set(["string", "number", "symbol"]);
function mo(r) {
  return r.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function bt(r, e, t) {
  const n = new r._zod.constr(e ?? r._zod.def);
  return (!e || t != null && t.parent) && (n._zod.parent = r), n;
}
function le(r) {
  const e = r;
  if (!e)
    return {};
  if (typeof e == "string")
    return { error: () => e };
  if ((e == null ? void 0 : e.message) !== void 0) {
    if ((e == null ? void 0 : e.error) !== void 0)
      throw new Error("Cannot specify both `message` and `error` params");
    e.error = e.message;
  }
  return delete e.message, typeof e.error == "string" ? { ...e, error: () => e.error } : e;
}
function xT(r) {
  return Object.keys(r).filter((e) => r[e]._zod.optin === "optional" && r[e]._zod.optout === "optional");
}
const IT = {
  safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],
  int32: [-2147483648, 2147483647],
  uint32: [0, 4294967295],
  float32: [-34028234663852886e22, 34028234663852886e22],
  float64: [-Number.MAX_VALUE, Number.MAX_VALUE]
};
function kT(r, e) {
  const t = r._zod.def, n = An(r._zod.def, {
    get shape() {
      const s = {};
      for (const a in e) {
        if (!(a in t.shape))
          throw new Error(`Unrecognized key: "${a}"`);
        e[a] && (s[a] = t.shape[a]);
      }
      return On(this, "shape", s), s;
    },
    checks: []
  });
  return bt(r, n);
}
function OT(r, e) {
  const t = r._zod.def, n = An(r._zod.def, {
    get shape() {
      const s = { ...r._zod.def.shape };
      for (const a in e) {
        if (!(a in t.shape))
          throw new Error(`Unrecognized key: "${a}"`);
        e[a] && delete s[a];
      }
      return On(this, "shape", s), s;
    },
    checks: []
  });
  return bt(r, n);
}
function Ag(r, e) {
  if (!Xs(e))
    throw new Error("Invalid input to extend: expected a plain object");
  const t = r._zod.def.checks;
  if (t && t.length > 0)
    throw new Error("Object schemas containing refinements cannot be extended. Use `.safeExtend()` instead.");
  const s = An(r._zod.def, {
    get shape() {
      const a = { ...r._zod.def.shape, ...e };
      return On(this, "shape", a), a;
    },
    checks: []
  });
  return bt(r, s);
}
function AT(r, e) {
  if (!Xs(e))
    throw new Error("Invalid input to safeExtend: expected a plain object");
  const t = {
    ...r._zod.def,
    get shape() {
      const n = { ...r._zod.def.shape, ...e };
      return On(this, "shape", n), n;
    },
    checks: r._zod.def.checks
  };
  return bt(r, t);
}
function $T(r, e) {
  const t = An(r._zod.def, {
    get shape() {
      const n = { ...r._zod.def.shape, ...e._zod.def.shape };
      return On(this, "shape", n), n;
    },
    get catchall() {
      return e._zod.def.catchall;
    },
    checks: []
    // delete existing checks
  });
  return bt(r, t);
}
function $g(r, e, t) {
  const n = An(e._zod.def, {
    get shape() {
      const s = e._zod.def.shape, a = { ...s };
      if (t)
        for (const i in t) {
          if (!(i in s))
            throw new Error(`Unrecognized key: "${i}"`);
          t[i] && (a[i] = r ? new r({
            type: "optional",
            innerType: s[i]
          }) : s[i]);
        }
      else
        for (const i in s)
          a[i] = r ? new r({
            type: "optional",
            innerType: s[i]
          }) : s[i];
      return On(this, "shape", a), a;
    },
    checks: []
  });
  return bt(e, n);
}
function CT(r, e, t) {
  const n = An(e._zod.def, {
    get shape() {
      const s = e._zod.def.shape, a = { ...s };
      if (t)
        for (const i in t) {
          if (!(i in a))
            throw new Error(`Unrecognized key: "${i}"`);
          t[i] && (a[i] = new r({
            type: "nonoptional",
            innerType: s[i]
          }));
        }
      else
        for (const i in s)
          a[i] = new r({
            type: "nonoptional",
            innerType: s[i]
          });
      return On(this, "shape", a), a;
    },
    checks: []
  });
  return bt(e, n);
}
function qn(r, e = 0) {
  var t;
  if (r.aborted === !0)
    return !0;
  for (let n = e; n < r.issues.length; n++)
    if (((t = r.issues[n]) == null ? void 0 : t.continue) !== !0)
      return !0;
  return !1;
}
function Cg(r, e) {
  return e.map((t) => {
    var n;
    return (n = t).path ?? (n.path = []), t.path.unshift(r), t;
  });
}
function za(r) {
  return typeof r == "string" ? r : r == null ? void 0 : r.message;
}
function En(r, e, t) {
  var s, a, i, o, c, u;
  const n = { ...r, path: r.path ?? [] };
  if (!r.message) {
    const l = za((i = (a = (s = r.inst) == null ? void 0 : s._zod.def) == null ? void 0 : a.error) == null ? void 0 : i.call(a, r)) ?? za((o = e == null ? void 0 : e.error) == null ? void 0 : o.call(e, r)) ?? za((c = t.customError) == null ? void 0 : c.call(t, r)) ?? za((u = t.localeError) == null ? void 0 : u.call(t, r)) ?? "Invalid input";
    n.message = l;
  }
  return delete n.inst, delete n.continue, e != null && e.reportInput || delete n.input, n;
}
function El(r) {
  return Array.isArray(r) ? "array" : typeof r == "string" ? "string" : "unknown";
}
function Qs(...r) {
  const [e, t, n] = r;
  return typeof e == "string" ? {
    message: e,
    code: "custom",
    input: t,
    inst: n
  } : { ...e };
}
const Rg = (r, e) => {
  r.name = "$ZodError", Object.defineProperty(r, "_zod", {
    value: r._zod,
    enumerable: !1
  }), Object.defineProperty(r, "issues", {
    value: e,
    enumerable: !1
  }), r.message = JSON.stringify(e, Kc, 2), Object.defineProperty(r, "toString", {
    value: () => r.message,
    enumerable: !1
  });
}, Ng = L("$ZodError", Rg), go = L("$ZodError", Rg, { Parent: Error });
function RT(r, e = (t) => t.message) {
  const t = {}, n = [];
  for (const s of r.issues)
    s.path.length > 0 ? (t[s.path[0]] = t[s.path[0]] || [], t[s.path[0]].push(e(s))) : n.push(e(s));
  return { formErrors: n, fieldErrors: t };
}
function NT(r, e = (t) => t.message) {
  const t = { _errors: [] }, n = (s) => {
    for (const a of s.issues)
      if (a.code === "invalid_union" && a.errors.length)
        a.errors.map((i) => n({ issues: i }));
      else if (a.code === "invalid_key")
        n({ issues: a.issues });
      else if (a.code === "invalid_element")
        n({ issues: a.issues });
      else if (a.path.length === 0)
        t._errors.push(e(a));
      else {
        let i = t, o = 0;
        for (; o < a.path.length; ) {
          const c = a.path[o];
          o === a.path.length - 1 ? (i[c] = i[c] || { _errors: [] }, i[c]._errors.push(e(a))) : i[c] = i[c] || { _errors: [] }, i = i[c], o++;
        }
      }
  };
  return n(r), t;
}
function PT(r) {
  const e = [], t = r.map((n) => typeof n == "object" ? n.key : n);
  for (const n of t)
    typeof n == "number" ? e.push(`[${n}]`) : typeof n == "symbol" ? e.push(`[${JSON.stringify(String(n))}]`) : /[^\w$]/.test(n) ? e.push(`[${JSON.stringify(n)}]`) : (e.length && e.push("."), e.push(n));
  return e.join("");
}
function LT(r) {
  var n;
  const e = [], t = [...r.issues].sort((s, a) => (s.path ?? []).length - (a.path ?? []).length);
  for (const s of t)
    e.push(`âœ– ${s.message}`), (n = s.path) != null && n.length && e.push(`  â†’ at ${PT(s.path)}`);
  return e.join(`
`);
}
const _o = (r) => (e, t, n, s) => {
  const a = n ? Object.assign(n, { async: !1 }) : { async: !1 }, i = e._zod.run({ value: t, issues: [] }, a);
  if (i instanceof Promise)
    throw new Wn();
  if (i.issues.length) {
    const o = new ((s == null ? void 0 : s.Err) ?? r)(i.issues.map((c) => En(c, a, Tn())));
    throw kg(o, s == null ? void 0 : s.callee), o;
  }
  return i.value;
}, yo = /* @__PURE__ */ _o(go), wo = (r) => async (e, t, n, s) => {
  const a = n ? Object.assign(n, { async: !0 }) : { async: !0 };
  let i = e._zod.run({ value: t, issues: [] }, a);
  if (i instanceof Promise && (i = await i), i.issues.length) {
    const o = new ((s == null ? void 0 : s.Err) ?? r)(i.issues.map((c) => En(c, a, Tn())));
    throw kg(o, s == null ? void 0 : s.callee), o;
  }
  return i.value;
}, Pg = /* @__PURE__ */ wo(go), vo = (r) => (e, t, n) => {
  const s = n ? { ...n, async: !1 } : { async: !1 }, a = e._zod.run({ value: t, issues: [] }, s);
  if (a instanceof Promise)
    throw new Wn();
  return a.issues.length ? {
    success: !1,
    error: new (r ?? Ng)(a.issues.map((i) => En(i, s, Tn())))
  } : { success: !0, data: a.value };
}, MT = /* @__PURE__ */ vo(go), bo = (r) => async (e, t, n) => {
  const s = n ? Object.assign(n, { async: !0 }) : { async: !0 };
  let a = e._zod.run({ value: t, issues: [] }, s);
  return a instanceof Promise && (a = await a), a.issues.length ? {
    success: !1,
    error: new r(a.issues.map((i) => En(i, s, Tn())))
  } : { success: !0, data: a.value };
}, DT = /* @__PURE__ */ bo(go), jT = (r) => (e, t, n) => {
  const s = n ? Object.assign(n, { direction: "backward" }) : { direction: "backward" };
  return _o(r)(e, t, s);
}, FT = (r) => (e, t, n) => _o(r)(e, t, n), UT = (r) => async (e, t, n) => {
  const s = n ? Object.assign(n, { direction: "backward" }) : { direction: "backward" };
  return wo(r)(e, t, s);
}, zT = (r) => async (e, t, n) => wo(r)(e, t, n), BT = (r) => (e, t, n) => {
  const s = n ? Object.assign(n, { direction: "backward" }) : { direction: "backward" };
  return vo(r)(e, t, s);
}, ZT = (r) => (e, t, n) => vo(r)(e, t, n), VT = (r) => async (e, t, n) => {
  const s = n ? Object.assign(n, { direction: "backward" }) : { direction: "backward" };
  return bo(r)(e, t, s);
}, qT = (r) => async (e, t, n) => bo(r)(e, t, n), HT = /^[cC][^\s-]{8,}$/, JT = /^[0-9a-z]+$/, WT = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/, GT = /^[0-9a-vA-V]{20}$/, KT = /^[A-Za-z0-9]{27}$/, YT = /^[a-zA-Z0-9_-]{21}$/, XT = /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/, QT = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/, gh = (r) => r ? new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${r}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`) : /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/, eE = /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/, tE = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
function rE() {
  return new RegExp(tE, "u");
}
const nE = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/, sE = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$/, aE = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/, iE = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/, oE = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/, Lg = /^[A-Za-z0-9_-]*$/, cE = /^\+(?:[0-9]){6,14}[0-9]$/, Mg = "(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))", uE = /* @__PURE__ */ new RegExp(`^${Mg}$`);
function Dg(r) {
  const e = "(?:[01]\\d|2[0-3]):[0-5]\\d";
  return typeof r.precision == "number" ? r.precision === -1 ? `${e}` : r.precision === 0 ? `${e}:[0-5]\\d` : `${e}:[0-5]\\d\\.\\d{${r.precision}}` : `${e}(?::[0-5]\\d(?:\\.\\d+)?)?`;
}
function lE(r) {
  return new RegExp(`^${Dg(r)}$`);
}
function dE(r) {
  const e = Dg({ precision: r.precision }), t = ["Z"];
  r.local && t.push(""), r.offset && t.push("([+-](?:[01]\\d|2[0-3]):[0-5]\\d)");
  const n = `${e}(?:${t.join("|")})`;
  return new RegExp(`^${Mg}T(?:${n})$`);
}
const hE = (r) => {
  const e = r ? `[\\s\\S]{${(r == null ? void 0 : r.minimum) ?? 0},${(r == null ? void 0 : r.maximum) ?? ""}}` : "[\\s\\S]*";
  return new RegExp(`^${e}$`);
}, fE = /^-?\d+$/, pE = /^-?\d+(?:\.\d+)?/, mE = /^(?:true|false)$/i, gE = /^[^A-Z]*$/, _E = /^[^a-z]*$/, Lt = /* @__PURE__ */ L("$ZodCheck", (r, e) => {
  var t;
  r._zod ?? (r._zod = {}), r._zod.def = e, (t = r._zod).onattach ?? (t.onattach = []);
}), jg = {
  number: "number",
  bigint: "bigint",
  object: "date"
}, Fg = /* @__PURE__ */ L("$ZodCheckLessThan", (r, e) => {
  Lt.init(r, e);
  const t = jg[typeof e.value];
  r._zod.onattach.push((n) => {
    const s = n._zod.bag, a = (e.inclusive ? s.maximum : s.exclusiveMaximum) ?? Number.POSITIVE_INFINITY;
    e.value < a && (e.inclusive ? s.maximum = e.value : s.exclusiveMaximum = e.value);
  }), r._zod.check = (n) => {
    (e.inclusive ? n.value <= e.value : n.value < e.value) || n.issues.push({
      origin: t,
      code: "too_big",
      maximum: e.value,
      input: n.value,
      inclusive: e.inclusive,
      inst: r,
      continue: !e.abort
    });
  };
}), Ug = /* @__PURE__ */ L("$ZodCheckGreaterThan", (r, e) => {
  Lt.init(r, e);
  const t = jg[typeof e.value];
  r._zod.onattach.push((n) => {
    const s = n._zod.bag, a = (e.inclusive ? s.minimum : s.exclusiveMinimum) ?? Number.NEGATIVE_INFINITY;
    e.value > a && (e.inclusive ? s.minimum = e.value : s.exclusiveMinimum = e.value);
  }), r._zod.check = (n) => {
    (e.inclusive ? n.value >= e.value : n.value > e.value) || n.issues.push({
      origin: t,
      code: "too_small",
      minimum: e.value,
      input: n.value,
      inclusive: e.inclusive,
      inst: r,
      continue: !e.abort
    });
  };
}), yE = /* @__PURE__ */ L("$ZodCheckMultipleOf", (r, e) => {
  Lt.init(r, e), r._zod.onattach.push((t) => {
    var n;
    (n = t._zod.bag).multipleOf ?? (n.multipleOf = e.value);
  }), r._zod.check = (t) => {
    if (typeof t.value != typeof e.value)
      throw new Error("Cannot mix number and bigint in multiple_of check.");
    (typeof t.value == "bigint" ? t.value % e.value === BigInt(0) : bT(t.value, e.value) === 0) || t.issues.push({
      origin: typeof t.value,
      code: "not_multiple_of",
      divisor: e.value,
      input: t.value,
      inst: r,
      continue: !e.abort
    });
  };
}), wE = /* @__PURE__ */ L("$ZodCheckNumberFormat", (r, e) => {
  var i;
  Lt.init(r, e), e.format = e.format || "float64";
  const t = (i = e.format) == null ? void 0 : i.includes("int"), n = t ? "int" : "number", [s, a] = IT[e.format];
  r._zod.onattach.push((o) => {
    const c = o._zod.bag;
    c.format = e.format, c.minimum = s, c.maximum = a, t && (c.pattern = fE);
  }), r._zod.check = (o) => {
    const c = o.value;
    if (t) {
      if (!Number.isInteger(c)) {
        o.issues.push({
          expected: n,
          format: e.format,
          code: "invalid_type",
          continue: !1,
          input: c,
          inst: r
        });
        return;
      }
      if (!Number.isSafeInteger(c)) {
        c > 0 ? o.issues.push({
          input: c,
          code: "too_big",
          maximum: Number.MAX_SAFE_INTEGER,
          note: "Integers must be within the safe integer range.",
          inst: r,
          origin: n,
          continue: !e.abort
        }) : o.issues.push({
          input: c,
          code: "too_small",
          minimum: Number.MIN_SAFE_INTEGER,
          note: "Integers must be within the safe integer range.",
          inst: r,
          origin: n,
          continue: !e.abort
        });
        return;
      }
    }
    c < s && o.issues.push({
      origin: "number",
      input: c,
      code: "too_small",
      minimum: s,
      inclusive: !0,
      inst: r,
      continue: !e.abort
    }), c > a && o.issues.push({
      origin: "number",
      input: c,
      code: "too_big",
      maximum: a,
      inst: r
    });
  };
}), vE = /* @__PURE__ */ L("$ZodCheckMaxLength", (r, e) => {
  var t;
  Lt.init(r, e), (t = r._zod.def).when ?? (t.when = (n) => {
    const s = n.value;
    return !Sl(s) && s.length !== void 0;
  }), r._zod.onattach.push((n) => {
    const s = n._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    e.maximum < s && (n._zod.bag.maximum = e.maximum);
  }), r._zod.check = (n) => {
    const s = n.value;
    if (s.length <= e.maximum)
      return;
    const i = El(s);
    n.issues.push({
      origin: i,
      code: "too_big",
      maximum: e.maximum,
      inclusive: !0,
      input: s,
      inst: r,
      continue: !e.abort
    });
  };
}), bE = /* @__PURE__ */ L("$ZodCheckMinLength", (r, e) => {
  var t;
  Lt.init(r, e), (t = r._zod.def).when ?? (t.when = (n) => {
    const s = n.value;
    return !Sl(s) && s.length !== void 0;
  }), r._zod.onattach.push((n) => {
    const s = n._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    e.minimum > s && (n._zod.bag.minimum = e.minimum);
  }), r._zod.check = (n) => {
    const s = n.value;
    if (s.length >= e.minimum)
      return;
    const i = El(s);
    n.issues.push({
      origin: i,
      code: "too_small",
      minimum: e.minimum,
      inclusive: !0,
      input: s,
      inst: r,
      continue: !e.abort
    });
  };
}), SE = /* @__PURE__ */ L("$ZodCheckLengthEquals", (r, e) => {
  var t;
  Lt.init(r, e), (t = r._zod.def).when ?? (t.when = (n) => {
    const s = n.value;
    return !Sl(s) && s.length !== void 0;
  }), r._zod.onattach.push((n) => {
    const s = n._zod.bag;
    s.minimum = e.length, s.maximum = e.length, s.length = e.length;
  }), r._zod.check = (n) => {
    const s = n.value, a = s.length;
    if (a === e.length)
      return;
    const i = El(s), o = a > e.length;
    n.issues.push({
      origin: i,
      ...o ? { code: "too_big", maximum: e.length } : { code: "too_small", minimum: e.length },
      inclusive: !0,
      exact: !0,
      input: n.value,
      inst: r,
      continue: !e.abort
    });
  };
}), So = /* @__PURE__ */ L("$ZodCheckStringFormat", (r, e) => {
  var t, n;
  Lt.init(r, e), r._zod.onattach.push((s) => {
    const a = s._zod.bag;
    a.format = e.format, e.pattern && (a.patterns ?? (a.patterns = /* @__PURE__ */ new Set()), a.patterns.add(e.pattern));
  }), e.pattern ? (t = r._zod).check ?? (t.check = (s) => {
    e.pattern.lastIndex = 0, !e.pattern.test(s.value) && s.issues.push({
      origin: "string",
      code: "invalid_format",
      format: e.format,
      input: s.value,
      ...e.pattern ? { pattern: e.pattern.toString() } : {},
      inst: r,
      continue: !e.abort
    });
  }) : (n = r._zod).check ?? (n.check = () => {
  });
}), TE = /* @__PURE__ */ L("$ZodCheckRegex", (r, e) => {
  So.init(r, e), r._zod.check = (t) => {
    e.pattern.lastIndex = 0, !e.pattern.test(t.value) && t.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "regex",
      input: t.value,
      pattern: e.pattern.toString(),
      inst: r,
      continue: !e.abort
    });
  };
}), EE = /* @__PURE__ */ L("$ZodCheckLowerCase", (r, e) => {
  e.pattern ?? (e.pattern = gE), So.init(r, e);
}), xE = /* @__PURE__ */ L("$ZodCheckUpperCase", (r, e) => {
  e.pattern ?? (e.pattern = _E), So.init(r, e);
}), IE = /* @__PURE__ */ L("$ZodCheckIncludes", (r, e) => {
  Lt.init(r, e);
  const t = mo(e.includes), n = new RegExp(typeof e.position == "number" ? `^.{${e.position}}${t}` : t);
  e.pattern = n, r._zod.onattach.push((s) => {
    const a = s._zod.bag;
    a.patterns ?? (a.patterns = /* @__PURE__ */ new Set()), a.patterns.add(n);
  }), r._zod.check = (s) => {
    s.value.includes(e.includes, e.position) || s.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "includes",
      includes: e.includes,
      input: s.value,
      inst: r,
      continue: !e.abort
    });
  };
}), kE = /* @__PURE__ */ L("$ZodCheckStartsWith", (r, e) => {
  Lt.init(r, e);
  const t = new RegExp(`^${mo(e.prefix)}.*`);
  e.pattern ?? (e.pattern = t), r._zod.onattach.push((n) => {
    const s = n._zod.bag;
    s.patterns ?? (s.patterns = /* @__PURE__ */ new Set()), s.patterns.add(t);
  }), r._zod.check = (n) => {
    n.value.startsWith(e.prefix) || n.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "starts_with",
      prefix: e.prefix,
      input: n.value,
      inst: r,
      continue: !e.abort
    });
  };
}), OE = /* @__PURE__ */ L("$ZodCheckEndsWith", (r, e) => {
  Lt.init(r, e);
  const t = new RegExp(`.*${mo(e.suffix)}$`);
  e.pattern ?? (e.pattern = t), r._zod.onattach.push((n) => {
    const s = n._zod.bag;
    s.patterns ?? (s.patterns = /* @__PURE__ */ new Set()), s.patterns.add(t);
  }), r._zod.check = (n) => {
    n.value.endsWith(e.suffix) || n.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "ends_with",
      suffix: e.suffix,
      input: n.value,
      inst: r,
      continue: !e.abort
    });
  };
}), AE = /* @__PURE__ */ L("$ZodCheckOverwrite", (r, e) => {
  Lt.init(r, e), r._zod.check = (t) => {
    t.value = e.tx(t.value);
  };
});
class $E {
  constructor(e = []) {
    this.content = [], this.indent = 0, this && (this.args = e);
  }
  indented(e) {
    this.indent += 1, e(this), this.indent -= 1;
  }
  write(e) {
    if (typeof e == "function") {
      e(this, { execution: "sync" }), e(this, { execution: "async" });
      return;
    }
    const n = e.split(`
`).filter((i) => i), s = Math.min(...n.map((i) => i.length - i.trimStart().length)), a = n.map((i) => i.slice(s)).map((i) => " ".repeat(this.indent * 2) + i);
    for (const i of a)
      this.content.push(i);
  }
  compile() {
    const e = Function, t = this == null ? void 0 : this.args, s = [...((this == null ? void 0 : this.content) ?? [""]).map((a) => `  ${a}`)];
    return new e(...t, s.join(`
`));
  }
}
const CE = {
  major: 4,
  minor: 1,
  patch: 13
}, Xe = /* @__PURE__ */ L("$ZodType", (r, e) => {
  var s;
  var t;
  r ?? (r = {}), r._zod.def = e, r._zod.bag = r._zod.bag || {}, r._zod.version = CE;
  const n = [...r._zod.def.checks ?? []];
  r._zod.traits.has("$ZodCheck") && n.unshift(r);
  for (const a of n)
    for (const i of a._zod.onattach)
      i(r);
  if (n.length === 0)
    (t = r._zod).deferred ?? (t.deferred = []), (s = r._zod.deferred) == null || s.push(() => {
      r._zod.run = r._zod.parse;
    });
  else {
    const a = (o, c, u) => {
      let l = qn(o), d;
      for (const h of c) {
        if (h._zod.def.when) {
          if (!h._zod.def.when(o))
            continue;
        } else if (l)
          continue;
        const f = o.issues.length, p = h._zod.check(o);
        if (p instanceof Promise && (u == null ? void 0 : u.async) === !1)
          throw new Wn();
        if (d || p instanceof Promise)
          d = (d ?? Promise.resolve()).then(async () => {
            await p, o.issues.length !== f && (l || (l = qn(o, f)));
          });
        else {
          if (o.issues.length === f)
            continue;
          l || (l = qn(o, f));
        }
      }
      return d ? d.then(() => o) : o;
    }, i = (o, c, u) => {
      if (qn(o))
        return o.aborted = !0, o;
      const l = a(c, n, u);
      if (l instanceof Promise) {
        if (u.async === !1)
          throw new Wn();
        return l.then((d) => r._zod.parse(d, u));
      }
      return r._zod.parse(l, u);
    };
    r._zod.run = (o, c) => {
      if (c.skipChecks)
        return r._zod.parse(o, c);
      if (c.direction === "backward") {
        const l = r._zod.parse({ value: o.value, issues: [] }, { ...c, skipChecks: !0 });
        return l instanceof Promise ? l.then((d) => i(d, o, c)) : i(l, o, c);
      }
      const u = r._zod.parse(o, c);
      if (u instanceof Promise) {
        if (c.async === !1)
          throw new Wn();
        return u.then((l) => a(l, n, c));
      }
      return a(u, n, c);
    };
  }
  r["~standard"] = {
    validate: (a) => {
      var i;
      try {
        const o = MT(r, a);
        return o.success ? { value: o.data } : { issues: (i = o.error) == null ? void 0 : i.issues };
      } catch {
        return DT(r, a).then((c) => {
          var u;
          return c.success ? { value: c.data } : { issues: (u = c.error) == null ? void 0 : u.issues };
        });
      }
    },
    vendor: "zod",
    version: 1
  };
}), xl = /* @__PURE__ */ L("$ZodString", (r, e) => {
  var t;
  Xe.init(r, e), r._zod.pattern = [...((t = r == null ? void 0 : r._zod.bag) == null ? void 0 : t.patterns) ?? []].pop() ?? hE(r._zod.bag), r._zod.parse = (n, s) => {
    if (e.coerce)
      try {
        n.value = String(n.value);
      } catch {
      }
    return typeof n.value == "string" || n.issues.push({
      expected: "string",
      code: "invalid_type",
      input: n.value,
      inst: r
    }), n;
  };
}), Ve = /* @__PURE__ */ L("$ZodStringFormat", (r, e) => {
  So.init(r, e), xl.init(r, e);
}), RE = /* @__PURE__ */ L("$ZodGUID", (r, e) => {
  e.pattern ?? (e.pattern = QT), Ve.init(r, e);
}), NE = /* @__PURE__ */ L("$ZodUUID", (r, e) => {
  if (e.version) {
    const n = {
      v1: 1,
      v2: 2,
      v3: 3,
      v4: 4,
      v5: 5,
      v6: 6,
      v7: 7,
      v8: 8
    }[e.version];
    if (n === void 0)
      throw new Error(`Invalid UUID version: "${e.version}"`);
    e.pattern ?? (e.pattern = gh(n));
  } else
    e.pattern ?? (e.pattern = gh());
  Ve.init(r, e);
}), PE = /* @__PURE__ */ L("$ZodEmail", (r, e) => {
  e.pattern ?? (e.pattern = eE), Ve.init(r, e);
}), LE = /* @__PURE__ */ L("$ZodURL", (r, e) => {
  Ve.init(r, e), r._zod.check = (t) => {
    try {
      const n = t.value.trim(), s = new URL(n);
      e.hostname && (e.hostname.lastIndex = 0, e.hostname.test(s.hostname) || t.issues.push({
        code: "invalid_format",
        format: "url",
        note: "Invalid hostname",
        pattern: e.hostname.source,
        input: t.value,
        inst: r,
        continue: !e.abort
      })), e.protocol && (e.protocol.lastIndex = 0, e.protocol.test(s.protocol.endsWith(":") ? s.protocol.slice(0, -1) : s.protocol) || t.issues.push({
        code: "invalid_format",
        format: "url",
        note: "Invalid protocol",
        pattern: e.protocol.source,
        input: t.value,
        inst: r,
        continue: !e.abort
      })), e.normalize ? t.value = s.href : t.value = n;
      return;
    } catch {
      t.issues.push({
        code: "invalid_format",
        format: "url",
        input: t.value,
        inst: r,
        continue: !e.abort
      });
    }
  };
}), ME = /* @__PURE__ */ L("$ZodEmoji", (r, e) => {
  e.pattern ?? (e.pattern = rE()), Ve.init(r, e);
}), DE = /* @__PURE__ */ L("$ZodNanoID", (r, e) => {
  e.pattern ?? (e.pattern = YT), Ve.init(r, e);
}), jE = /* @__PURE__ */ L("$ZodCUID", (r, e) => {
  e.pattern ?? (e.pattern = HT), Ve.init(r, e);
}), FE = /* @__PURE__ */ L("$ZodCUID2", (r, e) => {
  e.pattern ?? (e.pattern = JT), Ve.init(r, e);
}), UE = /* @__PURE__ */ L("$ZodULID", (r, e) => {
  e.pattern ?? (e.pattern = WT), Ve.init(r, e);
}), zE = /* @__PURE__ */ L("$ZodXID", (r, e) => {
  e.pattern ?? (e.pattern = GT), Ve.init(r, e);
}), BE = /* @__PURE__ */ L("$ZodKSUID", (r, e) => {
  e.pattern ?? (e.pattern = KT), Ve.init(r, e);
}), ZE = /* @__PURE__ */ L("$ZodISODateTime", (r, e) => {
  e.pattern ?? (e.pattern = dE(e)), Ve.init(r, e);
}), VE = /* @__PURE__ */ L("$ZodISODate", (r, e) => {
  e.pattern ?? (e.pattern = uE), Ve.init(r, e);
}), qE = /* @__PURE__ */ L("$ZodISOTime", (r, e) => {
  e.pattern ?? (e.pattern = lE(e)), Ve.init(r, e);
}), HE = /* @__PURE__ */ L("$ZodISODuration", (r, e) => {
  e.pattern ?? (e.pattern = XT), Ve.init(r, e);
}), JE = /* @__PURE__ */ L("$ZodIPv4", (r, e) => {
  e.pattern ?? (e.pattern = nE), Ve.init(r, e), r._zod.bag.format = "ipv4";
}), WE = /* @__PURE__ */ L("$ZodIPv6", (r, e) => {
  e.pattern ?? (e.pattern = sE), Ve.init(r, e), r._zod.bag.format = "ipv6", r._zod.check = (t) => {
    try {
      new URL(`http://[${t.value}]`);
    } catch {
      t.issues.push({
        code: "invalid_format",
        format: "ipv6",
        input: t.value,
        inst: r,
        continue: !e.abort
      });
    }
  };
}), GE = /* @__PURE__ */ L("$ZodCIDRv4", (r, e) => {
  e.pattern ?? (e.pattern = aE), Ve.init(r, e);
}), KE = /* @__PURE__ */ L("$ZodCIDRv6", (r, e) => {
  e.pattern ?? (e.pattern = iE), Ve.init(r, e), r._zod.check = (t) => {
    const n = t.value.split("/");
    try {
      if (n.length !== 2)
        throw new Error();
      const [s, a] = n;
      if (!a)
        throw new Error();
      const i = Number(a);
      if (`${i}` !== a)
        throw new Error();
      if (i < 0 || i > 128)
        throw new Error();
      new URL(`http://[${s}]`);
    } catch {
      t.issues.push({
        code: "invalid_format",
        format: "cidrv6",
        input: t.value,
        inst: r,
        continue: !e.abort
      });
    }
  };
});
function zg(r) {
  if (r === "")
    return !0;
  if (r.length % 4 !== 0)
    return !1;
  try {
    return atob(r), !0;
  } catch {
    return !1;
  }
}
const YE = /* @__PURE__ */ L("$ZodBase64", (r, e) => {
  e.pattern ?? (e.pattern = oE), Ve.init(r, e), r._zod.bag.contentEncoding = "base64", r._zod.check = (t) => {
    zg(t.value) || t.issues.push({
      code: "invalid_format",
      format: "base64",
      input: t.value,
      inst: r,
      continue: !e.abort
    });
  };
});
function XE(r) {
  if (!Lg.test(r))
    return !1;
  const e = r.replace(/[-_]/g, (n) => n === "-" ? "+" : "/"), t = e.padEnd(Math.ceil(e.length / 4) * 4, "=");
  return zg(t);
}
const QE = /* @__PURE__ */ L("$ZodBase64URL", (r, e) => {
  e.pattern ?? (e.pattern = Lg), Ve.init(r, e), r._zod.bag.contentEncoding = "base64url", r._zod.check = (t) => {
    XE(t.value) || t.issues.push({
      code: "invalid_format",
      format: "base64url",
      input: t.value,
      inst: r,
      continue: !e.abort
    });
  };
}), ex = /* @__PURE__ */ L("$ZodE164", (r, e) => {
  e.pattern ?? (e.pattern = cE), Ve.init(r, e);
});
function tx(r, e = null) {
  try {
    const t = r.split(".");
    if (t.length !== 3)
      return !1;
    const [n] = t;
    if (!n)
      return !1;
    const s = JSON.parse(atob(n));
    return !("typ" in s && (s == null ? void 0 : s.typ) !== "JWT" || !s.alg || e && (!("alg" in s) || s.alg !== e));
  } catch {
    return !1;
  }
}
const rx = /* @__PURE__ */ L("$ZodJWT", (r, e) => {
  Ve.init(r, e), r._zod.check = (t) => {
    tx(t.value, e.alg) || t.issues.push({
      code: "invalid_format",
      format: "jwt",
      input: t.value,
      inst: r,
      continue: !e.abort
    });
  };
}), Bg = /* @__PURE__ */ L("$ZodNumber", (r, e) => {
  Xe.init(r, e), r._zod.pattern = r._zod.bag.pattern ?? pE, r._zod.parse = (t, n) => {
    if (e.coerce)
      try {
        t.value = Number(t.value);
      } catch {
      }
    const s = t.value;
    if (typeof s == "number" && !Number.isNaN(s) && Number.isFinite(s))
      return t;
    const a = typeof s == "number" ? Number.isNaN(s) ? "NaN" : Number.isFinite(s) ? void 0 : "Infinity" : void 0;
    return t.issues.push({
      expected: "number",
      code: "invalid_type",
      input: s,
      inst: r,
      ...a ? { received: a } : {}
    }), t;
  };
}), nx = /* @__PURE__ */ L("$ZodNumberFormat", (r, e) => {
  wE.init(r, e), Bg.init(r, e);
}), sx = /* @__PURE__ */ L("$ZodBoolean", (r, e) => {
  Xe.init(r, e), r._zod.pattern = mE, r._zod.parse = (t, n) => {
    if (e.coerce)
      try {
        t.value = !!t.value;
      } catch {
      }
    const s = t.value;
    return typeof s == "boolean" || t.issues.push({
      expected: "boolean",
      code: "invalid_type",
      input: s,
      inst: r
    }), t;
  };
}), Zg = /* @__PURE__ */ L("$ZodUnknown", (r, e) => {
  Xe.init(r, e), r._zod.parse = (t) => t;
}), Vg = /* @__PURE__ */ L("$ZodNever", (r, e) => {
  Xe.init(r, e), r._zod.parse = (t, n) => (t.issues.push({
    expected: "never",
    code: "invalid_type",
    input: t.value,
    inst: r
  }), t);
});
function _h(r, e, t) {
  r.issues.length && e.issues.push(...Cg(t, r.issues)), e.value[t] = r.value;
}
const ax = /* @__PURE__ */ L("$ZodArray", (r, e) => {
  Xe.init(r, e), r._zod.parse = (t, n) => {
    const s = t.value;
    if (!Array.isArray(s))
      return t.issues.push({
        expected: "array",
        code: "invalid_type",
        input: s,
        inst: r
      }), t;
    t.value = Array(s.length);
    const a = [];
    for (let i = 0; i < s.length; i++) {
      const o = s[i], c = e.element._zod.run({
        value: o,
        issues: []
      }, n);
      c instanceof Promise ? a.push(c.then((u) => _h(u, t, i))) : _h(c, t, i);
    }
    return a.length ? Promise.all(a).then(() => t) : t;
  };
});
function Ai(r, e, t, n) {
  r.issues.length && e.issues.push(...Cg(t, r.issues)), r.value === void 0 ? t in n && (e.value[t] = void 0) : e.value[t] = r.value;
}
function qg(r) {
  var n, s, a, i;
  const e = Object.keys(r.shape);
  for (const o of e)
    if (!((i = (a = (s = (n = r.shape) == null ? void 0 : n[o]) == null ? void 0 : s._zod) == null ? void 0 : a.traits) != null && i.has("$ZodType")))
      throw new Error(`Invalid element at key "${o}": expected a Zod schema`);
  const t = xT(r.shape);
  return {
    ...r,
    keys: e,
    keySet: new Set(e),
    numKeys: e.length,
    optionalKeys: new Set(t)
  };
}
function Hg(r, e, t, n, s, a) {
  const i = [], o = s.keySet, c = s.catchall._zod, u = c.def.type;
  for (const l in e) {
    if (o.has(l))
      continue;
    if (u === "never") {
      i.push(l);
      continue;
    }
    const d = c.run({ value: e[l], issues: [] }, n);
    d instanceof Promise ? r.push(d.then((h) => Ai(h, t, l, e))) : Ai(d, t, l, e);
  }
  return i.length && t.issues.push({
    code: "unrecognized_keys",
    keys: i,
    input: e,
    inst: a
  }), r.length ? Promise.all(r).then(() => t) : t;
}
const ix = /* @__PURE__ */ L("$ZodObject", (r, e) => {
  Xe.init(r, e);
  const t = Object.getOwnPropertyDescriptor(e, "shape");
  if (!(t != null && t.get)) {
    const o = e.shape;
    Object.defineProperty(e, "shape", {
      get: () => {
        const c = { ...o };
        return Object.defineProperty(e, "shape", {
          value: c
        }), c;
      }
    });
  }
  const n = bl(() => qg(e));
  ze(r._zod, "propValues", () => {
    const o = e.shape, c = {};
    for (const u in o) {
      const l = o[u]._zod;
      if (l.values) {
        c[u] ?? (c[u] = /* @__PURE__ */ new Set());
        for (const d of l.values)
          c[u].add(d);
      }
    }
    return c;
  });
  const s = Oi, a = e.catchall;
  let i;
  r._zod.parse = (o, c) => {
    i ?? (i = n.value);
    const u = o.value;
    if (!s(u))
      return o.issues.push({
        expected: "object",
        code: "invalid_type",
        input: u,
        inst: r
      }), o;
    o.value = {};
    const l = [], d = i.shape;
    for (const h of i.keys) {
      const p = d[h]._zod.run({ value: u[h], issues: [] }, c);
      p instanceof Promise ? l.push(p.then((y) => Ai(y, o, h, u))) : Ai(p, o, h, u);
    }
    return a ? Hg(l, u, o, c, n.value, r) : l.length ? Promise.all(l).then(() => o) : o;
  };
}), ox = /* @__PURE__ */ L("$ZodObjectJIT", (r, e) => {
  ix.init(r, e);
  const t = r._zod.parse, n = bl(() => qg(e)), s = (h) => {
    const f = new $E(["shape", "payload", "ctx"]), p = n.value, y = (w) => {
      const T = mh(w);
      return `shape[${T}]._zod.run({ value: input[${T}], issues: [] }, ctx)`;
    };
    f.write("const input = payload.value;");
    const g = /* @__PURE__ */ Object.create(null);
    let S = 0;
    for (const w of p.keys)
      g[w] = `key_${S++}`;
    f.write("const newResult = {};");
    for (const w of p.keys) {
      const T = g[w], x = mh(w);
      f.write(`const ${T} = ${y(w)};`), f.write(`
        if (${T}.issues.length) {
          payload.issues = payload.issues.concat(${T}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${x}, ...iss.path] : [${x}]
          })));
        }
        
        
        if (${T}.value === undefined) {
          if (${x} in input) {
            newResult[${x}] = undefined;
          }
        } else {
          newResult[${x}] = ${T}.value;
        }
        
      `);
    }
    f.write("payload.value = newResult;"), f.write("return payload;");
    const _ = f.compile();
    return (w, T) => _(h, w, T);
  };
  let a;
  const i = Oi, o = !xg.jitless, u = o && TT.value, l = e.catchall;
  let d;
  r._zod.parse = (h, f) => {
    d ?? (d = n.value);
    const p = h.value;
    return i(p) ? o && u && (f == null ? void 0 : f.async) === !1 && f.jitless !== !0 ? (a || (a = s(e.shape)), h = a(h, f), l ? Hg([], p, h, f, d, r) : h) : t(h, f) : (h.issues.push({
      expected: "object",
      code: "invalid_type",
      input: p,
      inst: r
    }), h);
  };
});
function yh(r, e, t, n) {
  for (const a of r)
    if (a.issues.length === 0)
      return e.value = a.value, e;
  const s = r.filter((a) => !qn(a));
  return s.length === 1 ? (e.value = s[0].value, s[0]) : (e.issues.push({
    code: "invalid_union",
    input: e.value,
    inst: t,
    errors: r.map((a) => a.issues.map((i) => En(i, n, Tn())))
  }), e);
}
const cx = /* @__PURE__ */ L("$ZodUnion", (r, e) => {
  Xe.init(r, e), ze(r._zod, "optin", () => e.options.some((s) => s._zod.optin === "optional") ? "optional" : void 0), ze(r._zod, "optout", () => e.options.some((s) => s._zod.optout === "optional") ? "optional" : void 0), ze(r._zod, "values", () => {
    if (e.options.every((s) => s._zod.values))
      return new Set(e.options.flatMap((s) => Array.from(s._zod.values)));
  }), ze(r._zod, "pattern", () => {
    if (e.options.every((s) => s._zod.pattern)) {
      const s = e.options.map((a) => a._zod.pattern);
      return new RegExp(`^(${s.map((a) => Tl(a.source)).join("|")})$`);
    }
  });
  const t = e.options.length === 1, n = e.options[0]._zod.run;
  r._zod.parse = (s, a) => {
    if (t)
      return n(s, a);
    let i = !1;
    const o = [];
    for (const c of e.options) {
      const u = c._zod.run({
        value: s.value,
        issues: []
      }, a);
      if (u instanceof Promise)
        o.push(u), i = !0;
      else {
        if (u.issues.length === 0)
          return u;
        o.push(u);
      }
    }
    return i ? Promise.all(o).then((c) => yh(c, s, r, a)) : yh(o, s, r, a);
  };
}), ux = /* @__PURE__ */ L("$ZodIntersection", (r, e) => {
  Xe.init(r, e), r._zod.parse = (t, n) => {
    const s = t.value, a = e.left._zod.run({ value: s, issues: [] }, n), i = e.right._zod.run({ value: s, issues: [] }, n);
    return a instanceof Promise || i instanceof Promise ? Promise.all([a, i]).then(([c, u]) => wh(t, c, u)) : wh(t, a, i);
  };
});
function Yc(r, e) {
  if (r === e)
    return { valid: !0, data: r };
  if (r instanceof Date && e instanceof Date && +r == +e)
    return { valid: !0, data: r };
  if (Xs(r) && Xs(e)) {
    const t = Object.keys(e), n = Object.keys(r).filter((a) => t.indexOf(a) !== -1), s = { ...r, ...e };
    for (const a of n) {
      const i = Yc(r[a], e[a]);
      if (!i.valid)
        return {
          valid: !1,
          mergeErrorPath: [a, ...i.mergeErrorPath]
        };
      s[a] = i.data;
    }
    return { valid: !0, data: s };
  }
  if (Array.isArray(r) && Array.isArray(e)) {
    if (r.length !== e.length)
      return { valid: !1, mergeErrorPath: [] };
    const t = [];
    for (let n = 0; n < r.length; n++) {
      const s = r[n], a = e[n], i = Yc(s, a);
      if (!i.valid)
        return {
          valid: !1,
          mergeErrorPath: [n, ...i.mergeErrorPath]
        };
      t.push(i.data);
    }
    return { valid: !0, data: t };
  }
  return { valid: !1, mergeErrorPath: [] };
}
function wh(r, e, t) {
  if (e.issues.length && r.issues.push(...e.issues), t.issues.length && r.issues.push(...t.issues), qn(r))
    return r;
  const n = Yc(e.value, t.value);
  if (!n.valid)
    throw new Error(`Unmergable intersection. Error path: ${JSON.stringify(n.mergeErrorPath)}`);
  return r.value = n.data, r;
}
const lx = /* @__PURE__ */ L("$ZodEnum", (r, e) => {
  Xe.init(r, e);
  const t = Ig(e.entries), n = new Set(t);
  r._zod.values = n, r._zod.pattern = new RegExp(`^(${t.filter((s) => ET.has(typeof s)).map((s) => typeof s == "string" ? mo(s) : s.toString()).join("|")})$`), r._zod.parse = (s, a) => {
    const i = s.value;
    return n.has(i) || s.issues.push({
      code: "invalid_value",
      values: t,
      input: i,
      inst: r
    }), s;
  };
}), dx = /* @__PURE__ */ L("$ZodTransform", (r, e) => {
  Xe.init(r, e), r._zod.parse = (t, n) => {
    if (n.direction === "backward")
      throw new Eg(r.constructor.name);
    const s = e.transform(t.value, t);
    if (n.async)
      return (s instanceof Promise ? s : Promise.resolve(s)).then((i) => (t.value = i, t));
    if (s instanceof Promise)
      throw new Wn();
    return t.value = s, t;
  };
});
function vh(r, e) {
  return r.issues.length && e === void 0 ? { issues: [], value: void 0 } : r;
}
const Il = /* @__PURE__ */ L("$ZodOptional", (r, e) => {
  Xe.init(r, e), r._zod.optin = "optional", r._zod.optout = "optional", ze(r._zod, "values", () => e.innerType._zod.values ? /* @__PURE__ */ new Set([...e.innerType._zod.values, void 0]) : void 0), ze(r._zod, "pattern", () => {
    const t = e.innerType._zod.pattern;
    return t ? new RegExp(`^(${Tl(t.source)})?$`) : void 0;
  }), r._zod.parse = (t, n) => {
    if (e.innerType._zod.optin === "optional") {
      const s = e.innerType._zod.run(t, n);
      return s instanceof Promise ? s.then((a) => vh(a, t.value)) : vh(s, t.value);
    }
    return t.value === void 0 ? t : e.innerType._zod.run(t, n);
  };
}), hx = /* @__PURE__ */ L("$ZodNullable", (r, e) => {
  Xe.init(r, e), ze(r._zod, "optin", () => e.innerType._zod.optin), ze(r._zod, "optout", () => e.innerType._zod.optout), ze(r._zod, "pattern", () => {
    const t = e.innerType._zod.pattern;
    return t ? new RegExp(`^(${Tl(t.source)}|null)$`) : void 0;
  }), ze(r._zod, "values", () => e.innerType._zod.values ? /* @__PURE__ */ new Set([...e.innerType._zod.values, null]) : void 0), r._zod.parse = (t, n) => t.value === null ? t : e.innerType._zod.run(t, n);
}), fx = /* @__PURE__ */ L("$ZodDefault", (r, e) => {
  Xe.init(r, e), r._zod.optin = "optional", ze(r._zod, "values", () => e.innerType._zod.values), r._zod.parse = (t, n) => {
    if (n.direction === "backward")
      return e.innerType._zod.run(t, n);
    if (t.value === void 0)
      return t.value = e.defaultValue, t;
    const s = e.innerType._zod.run(t, n);
    return s instanceof Promise ? s.then((a) => bh(a, e)) : bh(s, e);
  };
});
function bh(r, e) {
  return r.value === void 0 && (r.value = e.defaultValue), r;
}
const px = /* @__PURE__ */ L("$ZodPrefault", (r, e) => {
  Xe.init(r, e), r._zod.optin = "optional", ze(r._zod, "values", () => e.innerType._zod.values), r._zod.parse = (t, n) => (n.direction === "backward" || t.value === void 0 && (t.value = e.defaultValue), e.innerType._zod.run(t, n));
}), mx = /* @__PURE__ */ L("$ZodNonOptional", (r, e) => {
  Xe.init(r, e), ze(r._zod, "values", () => {
    const t = e.innerType._zod.values;
    return t ? new Set([...t].filter((n) => n !== void 0)) : void 0;
  }), r._zod.parse = (t, n) => {
    const s = e.innerType._zod.run(t, n);
    return s instanceof Promise ? s.then((a) => Sh(a, r)) : Sh(s, r);
  };
});
function Sh(r, e) {
  return !r.issues.length && r.value === void 0 && r.issues.push({
    code: "invalid_type",
    expected: "nonoptional",
    input: r.value,
    inst: e
  }), r;
}
const gx = /* @__PURE__ */ L("$ZodCatch", (r, e) => {
  Xe.init(r, e), ze(r._zod, "optin", () => e.innerType._zod.optin), ze(r._zod, "optout", () => e.innerType._zod.optout), ze(r._zod, "values", () => e.innerType._zod.values), r._zod.parse = (t, n) => {
    if (n.direction === "backward")
      return e.innerType._zod.run(t, n);
    const s = e.innerType._zod.run(t, n);
    return s instanceof Promise ? s.then((a) => (t.value = a.value, a.issues.length && (t.value = e.catchValue({
      ...t,
      error: {
        issues: a.issues.map((i) => En(i, n, Tn()))
      },
      input: t.value
    }), t.issues = []), t)) : (t.value = s.value, s.issues.length && (t.value = e.catchValue({
      ...t,
      error: {
        issues: s.issues.map((a) => En(a, n, Tn()))
      },
      input: t.value
    }), t.issues = []), t);
  };
}), _x = /* @__PURE__ */ L("$ZodPipe", (r, e) => {
  Xe.init(r, e), ze(r._zod, "values", () => e.in._zod.values), ze(r._zod, "optin", () => e.in._zod.optin), ze(r._zod, "optout", () => e.out._zod.optout), ze(r._zod, "propValues", () => e.in._zod.propValues), r._zod.parse = (t, n) => {
    if (n.direction === "backward") {
      const a = e.out._zod.run(t, n);
      return a instanceof Promise ? a.then((i) => Ba(i, e.in, n)) : Ba(a, e.in, n);
    }
    const s = e.in._zod.run(t, n);
    return s instanceof Promise ? s.then((a) => Ba(a, e.out, n)) : Ba(s, e.out, n);
  };
});
function Ba(r, e, t) {
  return r.issues.length ? (r.aborted = !0, r) : e._zod.run({ value: r.value, issues: r.issues }, t);
}
const yx = /* @__PURE__ */ L("$ZodReadonly", (r, e) => {
  Xe.init(r, e), ze(r._zod, "propValues", () => e.innerType._zod.propValues), ze(r._zod, "values", () => e.innerType._zod.values), ze(r._zod, "optin", () => {
    var t, n;
    return (n = (t = e.innerType) == null ? void 0 : t._zod) == null ? void 0 : n.optin;
  }), ze(r._zod, "optout", () => {
    var t, n;
    return (n = (t = e.innerType) == null ? void 0 : t._zod) == null ? void 0 : n.optout;
  }), r._zod.parse = (t, n) => {
    if (n.direction === "backward")
      return e.innerType._zod.run(t, n);
    const s = e.innerType._zod.run(t, n);
    return s instanceof Promise ? s.then(Th) : Th(s);
  };
});
function Th(r) {
  return r.value = Object.freeze(r.value), r;
}
const wx = /* @__PURE__ */ L("$ZodCustom", (r, e) => {
  Lt.init(r, e), Xe.init(r, e), r._zod.parse = (t, n) => t, r._zod.check = (t) => {
    const n = t.value, s = e.fn(n);
    if (s instanceof Promise)
      return s.then((a) => Eh(a, t, n, r));
    Eh(s, t, n, r);
  };
});
function Eh(r, e, t, n) {
  if (!r) {
    const s = {
      code: "custom",
      input: t,
      inst: n,
      // incorporates params.error into issue reporting
      path: [...n._zod.def.path ?? []],
      // incorporates params.error into issue reporting
      continue: !n._zod.def.abort
      // params: inst._zod.def.params,
    };
    n._zod.def.params && (s.params = n._zod.def.params), e.issues.push(Qs(s));
  }
}
var xh;
class Jg {
  constructor() {
    this._map = /* @__PURE__ */ new WeakMap(), this._idmap = /* @__PURE__ */ new Map();
  }
  add(e, ...t) {
    const n = t[0];
    if (this._map.set(e, n), n && typeof n == "object" && "id" in n) {
      if (this._idmap.has(n.id))
        throw new Error(`ID ${n.id} already exists in the registry`);
      this._idmap.set(n.id, e);
    }
    return this;
  }
  clear() {
    return this._map = /* @__PURE__ */ new WeakMap(), this._idmap = /* @__PURE__ */ new Map(), this;
  }
  remove(e) {
    const t = this._map.get(e);
    return t && typeof t == "object" && "id" in t && this._idmap.delete(t.id), this._map.delete(e), this;
  }
  get(e) {
    const t = e._zod.parent;
    if (t) {
      const n = { ...this.get(t) ?? {} };
      delete n.id;
      const s = { ...n, ...this._map.get(e) };
      return Object.keys(s).length ? s : void 0;
    }
    return this._map.get(e);
  }
  has(e) {
    return this._map.has(e);
  }
}
function vx() {
  return new Jg();
}
(xh = globalThis).__zod_globalRegistry ?? (xh.__zod_globalRegistry = vx());
const pt = globalThis.__zod_globalRegistry;
function bx(r, e) {
  return new r({
    type: "string",
    ...le(e)
  });
}
function Sx(r, e) {
  return new r({
    type: "string",
    format: "email",
    check: "string_format",
    abort: !1,
    ...le(e)
  });
}
function Ih(r, e) {
  return new r({
    type: "string",
    format: "guid",
    check: "string_format",
    abort: !1,
    ...le(e)
  });
}
function Tx(r, e) {
  return new r({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    ...le(e)
  });
}
function Ex(r, e) {
  return new r({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    version: "v4",
    ...le(e)
  });
}
function xx(r, e) {
  return new r({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    version: "v6",
    ...le(e)
  });
}
function Ix(r, e) {
  return new r({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    version: "v7",
    ...le(e)
  });
}
function kx(r, e) {
  return new r({
    type: "string",
    format: "url",
    check: "string_format",
    abort: !1,
    ...le(e)
  });
}
function Ox(r, e) {
  return new r({
    type: "string",
    format: "emoji",
    check: "string_format",
    abort: !1,
    ...le(e)
  });
}
function Ax(r, e) {
  return new r({
    type: "string",
    format: "nanoid",
    check: "string_format",
    abort: !1,
    ...le(e)
  });
}
function $x(r, e) {
  return new r({
    type: "string",
    format: "cuid",
    check: "string_format",
    abort: !1,
    ...le(e)
  });
}
function Cx(r, e) {
  return new r({
    type: "string",
    format: "cuid2",
    check: "string_format",
    abort: !1,
    ...le(e)
  });
}
function Rx(r, e) {
  return new r({
    type: "string",
    format: "ulid",
    check: "string_format",
    abort: !1,
    ...le(e)
  });
}
function Nx(r, e) {
  return new r({
    type: "string",
    format: "xid",
    check: "string_format",
    abort: !1,
    ...le(e)
  });
}
function Px(r, e) {
  return new r({
    type: "string",
    format: "ksuid",
    check: "string_format",
    abort: !1,
    ...le(e)
  });
}
function Lx(r, e) {
  return new r({
    type: "string",
    format: "ipv4",
    check: "string_format",
    abort: !1,
    ...le(e)
  });
}
function Mx(r, e) {
  return new r({
    type: "string",
    format: "ipv6",
    check: "string_format",
    abort: !1,
    ...le(e)
  });
}
function Dx(r, e) {
  return new r({
    type: "string",
    format: "cidrv4",
    check: "string_format",
    abort: !1,
    ...le(e)
  });
}
function jx(r, e) {
  return new r({
    type: "string",
    format: "cidrv6",
    check: "string_format",
    abort: !1,
    ...le(e)
  });
}
function Fx(r, e) {
  return new r({
    type: "string",
    format: "base64",
    check: "string_format",
    abort: !1,
    ...le(e)
  });
}
function Ux(r, e) {
  return new r({
    type: "string",
    format: "base64url",
    check: "string_format",
    abort: !1,
    ...le(e)
  });
}
function zx(r, e) {
  return new r({
    type: "string",
    format: "e164",
    check: "string_format",
    abort: !1,
    ...le(e)
  });
}
function Bx(r, e) {
  return new r({
    type: "string",
    format: "jwt",
    check: "string_format",
    abort: !1,
    ...le(e)
  });
}
function Zx(r, e) {
  return new r({
    type: "string",
    format: "datetime",
    check: "string_format",
    offset: !1,
    local: !1,
    precision: null,
    ...le(e)
  });
}
function Vx(r, e) {
  return new r({
    type: "string",
    format: "date",
    check: "string_format",
    ...le(e)
  });
}
function qx(r, e) {
  return new r({
    type: "string",
    format: "time",
    check: "string_format",
    precision: null,
    ...le(e)
  });
}
function Hx(r, e) {
  return new r({
    type: "string",
    format: "duration",
    check: "string_format",
    ...le(e)
  });
}
function Jx(r, e) {
  return new r({
    type: "number",
    checks: [],
    ...le(e)
  });
}
function Wx(r, e) {
  return new r({
    type: "number",
    check: "number_format",
    abort: !1,
    format: "safeint",
    ...le(e)
  });
}
function Gx(r, e) {
  return new r({
    type: "boolean",
    ...le(e)
  });
}
function Wg(r) {
  return new r({
    type: "unknown"
  });
}
function Gg(r, e) {
  return new r({
    type: "never",
    ...le(e)
  });
}
function kh(r, e) {
  return new Fg({
    check: "less_than",
    ...le(e),
    value: r,
    inclusive: !1
  });
}
function cc(r, e) {
  return new Fg({
    check: "less_than",
    ...le(e),
    value: r,
    inclusive: !0
  });
}
function Oh(r, e) {
  return new Ug({
    check: "greater_than",
    ...le(e),
    value: r,
    inclusive: !1
  });
}
function uc(r, e) {
  return new Ug({
    check: "greater_than",
    ...le(e),
    value: r,
    inclusive: !0
  });
}
function Ah(r, e) {
  return new yE({
    check: "multiple_of",
    ...le(e),
    value: r
  });
}
function Kg(r, e) {
  return new vE({
    check: "max_length",
    ...le(e),
    maximum: r
  });
}
function $i(r, e) {
  return new bE({
    check: "min_length",
    ...le(e),
    minimum: r
  });
}
function Yg(r, e) {
  return new SE({
    check: "length_equals",
    ...le(e),
    length: r
  });
}
function Kx(r, e) {
  return new TE({
    check: "string_format",
    format: "regex",
    ...le(e),
    pattern: r
  });
}
function Yx(r) {
  return new EE({
    check: "string_format",
    format: "lowercase",
    ...le(r)
  });
}
function Xx(r) {
  return new xE({
    check: "string_format",
    format: "uppercase",
    ...le(r)
  });
}
function Qx(r, e) {
  return new IE({
    check: "string_format",
    format: "includes",
    ...le(e),
    includes: r
  });
}
function eI(r, e) {
  return new kE({
    check: "string_format",
    format: "starts_with",
    ...le(e),
    prefix: r
  });
}
function tI(r, e) {
  return new OE({
    check: "string_format",
    format: "ends_with",
    ...le(e),
    suffix: r
  });
}
function ls(r) {
  return new AE({
    check: "overwrite",
    tx: r
  });
}
function rI(r) {
  return ls((e) => e.normalize(r));
}
function nI() {
  return ls((r) => r.trim());
}
function sI() {
  return ls((r) => r.toLowerCase());
}
function aI() {
  return ls((r) => r.toUpperCase());
}
function iI() {
  return ls((r) => ST(r));
}
function oI(r, e, t) {
  return new r({
    type: "array",
    element: e,
    // get element() {
    //   return element;
    // },
    ...le(t)
  });
}
function cI(r, e, t) {
  return new r({
    type: "custom",
    check: "custom",
    fn: e,
    ...le(t)
  });
}
function uI(r) {
  const e = lI((t) => (t.addIssue = (n) => {
    if (typeof n == "string")
      t.issues.push(Qs(n, t.value, e._zod.def));
    else {
      const s = n;
      s.fatal && (s.continue = !1), s.code ?? (s.code = "custom"), s.input ?? (s.input = t.value), s.inst ?? (s.inst = e), s.continue ?? (s.continue = !e._zod.def.abort), t.issues.push(Qs(s));
    }
  }, r(t.value, t)));
  return e;
}
function lI(r, e) {
  const t = new Lt({
    check: "custom",
    ...le(e)
  });
  return t._zod.check = r, t;
}
class $h {
  constructor(e) {
    this.counter = 0, this.metadataRegistry = (e == null ? void 0 : e.metadata) ?? pt, this.target = (e == null ? void 0 : e.target) ?? "draft-2020-12", this.unrepresentable = (e == null ? void 0 : e.unrepresentable) ?? "throw", this.override = (e == null ? void 0 : e.override) ?? (() => {
    }), this.io = (e == null ? void 0 : e.io) ?? "output", this.seen = /* @__PURE__ */ new Map();
  }
  process(e, t = { path: [], schemaPath: [] }) {
    var d, h, f;
    var n;
    const s = e._zod.def, a = {
      guid: "uuid",
      url: "uri",
      datetime: "date-time",
      json_string: "json-string",
      regex: ""
      // do not set
    }, i = this.seen.get(e);
    if (i)
      return i.count++, t.schemaPath.includes(e) && (i.cycle = t.path), i.schema;
    const o = { schema: {}, count: 1, cycle: void 0, path: t.path };
    this.seen.set(e, o);
    const c = (h = (d = e._zod).toJSONSchema) == null ? void 0 : h.call(d);
    if (c)
      o.schema = c;
    else {
      const p = {
        ...t,
        schemaPath: [...t.schemaPath, e],
        path: t.path
      }, y = e._zod.parent;
      if (y)
        o.ref = y, this.process(y, p), this.seen.get(y).isParent = !0;
      else {
        const g = o.schema;
        switch (s.type) {
          case "string": {
            const S = g;
            S.type = "string";
            const { minimum: _, maximum: w, format: T, patterns: x, contentEncoding: A } = e._zod.bag;
            if (typeof _ == "number" && (S.minLength = _), typeof w == "number" && (S.maxLength = w), T && (S.format = a[T] ?? T, S.format === "" && delete S.format), A && (S.contentEncoding = A), x && x.size > 0) {
              const R = [...x];
              R.length === 1 ? S.pattern = R[0].source : R.length > 1 && (o.schema.allOf = [
                ...R.map((E) => ({
                  ...this.target === "draft-7" || this.target === "draft-4" || this.target === "openapi-3.0" ? { type: "string" } : {},
                  pattern: E.source
                }))
              ]);
            }
            break;
          }
          case "number": {
            const S = g, { minimum: _, maximum: w, format: T, multipleOf: x, exclusiveMaximum: A, exclusiveMinimum: R } = e._zod.bag;
            typeof T == "string" && T.includes("int") ? S.type = "integer" : S.type = "number", typeof R == "number" && (this.target === "draft-4" || this.target === "openapi-3.0" ? (S.minimum = R, S.exclusiveMinimum = !0) : S.exclusiveMinimum = R), typeof _ == "number" && (S.minimum = _, typeof R == "number" && this.target !== "draft-4" && (R >= _ ? delete S.minimum : delete S.exclusiveMinimum)), typeof A == "number" && (this.target === "draft-4" || this.target === "openapi-3.0" ? (S.maximum = A, S.exclusiveMaximum = !0) : S.exclusiveMaximum = A), typeof w == "number" && (S.maximum = w, typeof A == "number" && this.target !== "draft-4" && (A <= w ? delete S.maximum : delete S.exclusiveMaximum)), typeof x == "number" && (S.multipleOf = x);
            break;
          }
          case "boolean": {
            const S = g;
            S.type = "boolean";
            break;
          }
          case "bigint": {
            if (this.unrepresentable === "throw")
              throw new Error("BigInt cannot be represented in JSON Schema");
            break;
          }
          case "symbol": {
            if (this.unrepresentable === "throw")
              throw new Error("Symbols cannot be represented in JSON Schema");
            break;
          }
          case "null": {
            this.target === "openapi-3.0" ? (g.type = "string", g.nullable = !0, g.enum = [null]) : g.type = "null";
            break;
          }
          case "any":
            break;
          case "unknown":
            break;
          case "undefined": {
            if (this.unrepresentable === "throw")
              throw new Error("Undefined cannot be represented in JSON Schema");
            break;
          }
          case "void": {
            if (this.unrepresentable === "throw")
              throw new Error("Void cannot be represented in JSON Schema");
            break;
          }
          case "never": {
            g.not = {};
            break;
          }
          case "date": {
            if (this.unrepresentable === "throw")
              throw new Error("Date cannot be represented in JSON Schema");
            break;
          }
          case "array": {
            const S = g, { minimum: _, maximum: w } = e._zod.bag;
            typeof _ == "number" && (S.minItems = _), typeof w == "number" && (S.maxItems = w), S.type = "array", S.items = this.process(s.element, { ...p, path: [...p.path, "items"] });
            break;
          }
          case "object": {
            const S = g;
            S.type = "object", S.properties = {};
            const _ = s.shape;
            for (const x in _)
              S.properties[x] = this.process(_[x], {
                ...p,
                path: [...p.path, "properties", x]
              });
            const w = new Set(Object.keys(_)), T = new Set([...w].filter((x) => {
              const A = s.shape[x]._zod;
              return this.io === "input" ? A.optin === void 0 : A.optout === void 0;
            }));
            T.size > 0 && (S.required = Array.from(T)), ((f = s.catchall) == null ? void 0 : f._zod.def.type) === "never" ? S.additionalProperties = !1 : s.catchall ? s.catchall && (S.additionalProperties = this.process(s.catchall, {
              ...p,
              path: [...p.path, "additionalProperties"]
            })) : this.io === "output" && (S.additionalProperties = !1);
            break;
          }
          case "union": {
            const S = g, _ = s.discriminator !== void 0, w = s.options.map((T, x) => this.process(T, {
              ...p,
              path: [...p.path, _ ? "oneOf" : "anyOf", x]
            }));
            _ ? S.oneOf = w : S.anyOf = w;
            break;
          }
          case "intersection": {
            const S = g, _ = this.process(s.left, {
              ...p,
              path: [...p.path, "allOf", 0]
            }), w = this.process(s.right, {
              ...p,
              path: [...p.path, "allOf", 1]
            }), T = (A) => "allOf" in A && Object.keys(A).length === 1, x = [
              ...T(_) ? _.allOf : [_],
              ...T(w) ? w.allOf : [w]
            ];
            S.allOf = x;
            break;
          }
          case "tuple": {
            const S = g;
            S.type = "array";
            const _ = this.target === "draft-2020-12" ? "prefixItems" : "items", w = this.target === "draft-2020-12" || this.target === "openapi-3.0" ? "items" : "additionalItems", T = s.items.map((E, V) => this.process(E, {
              ...p,
              path: [...p.path, _, V]
            })), x = s.rest ? this.process(s.rest, {
              ...p,
              path: [...p.path, w, ...this.target === "openapi-3.0" ? [s.items.length] : []]
            }) : null;
            this.target === "draft-2020-12" ? (S.prefixItems = T, x && (S.items = x)) : this.target === "openapi-3.0" ? (S.items = {
              anyOf: T
            }, x && S.items.anyOf.push(x), S.minItems = T.length, x || (S.maxItems = T.length)) : (S.items = T, x && (S.additionalItems = x));
            const { minimum: A, maximum: R } = e._zod.bag;
            typeof A == "number" && (S.minItems = A), typeof R == "number" && (S.maxItems = R);
            break;
          }
          case "record": {
            const S = g;
            S.type = "object", (this.target === "draft-7" || this.target === "draft-2020-12") && (S.propertyNames = this.process(s.keyType, {
              ...p,
              path: [...p.path, "propertyNames"]
            })), S.additionalProperties = this.process(s.valueType, {
              ...p,
              path: [...p.path, "additionalProperties"]
            });
            break;
          }
          case "map": {
            if (this.unrepresentable === "throw")
              throw new Error("Map cannot be represented in JSON Schema");
            break;
          }
          case "set": {
            if (this.unrepresentable === "throw")
              throw new Error("Set cannot be represented in JSON Schema");
            break;
          }
          case "enum": {
            const S = g, _ = Ig(s.entries);
            _.every((w) => typeof w == "number") && (S.type = "number"), _.every((w) => typeof w == "string") && (S.type = "string"), S.enum = _;
            break;
          }
          case "literal": {
            const S = g, _ = [];
            for (const w of s.values)
              if (w === void 0) {
                if (this.unrepresentable === "throw")
                  throw new Error("Literal `undefined` cannot be represented in JSON Schema");
              } else if (typeof w == "bigint") {
                if (this.unrepresentable === "throw")
                  throw new Error("BigInt literals cannot be represented in JSON Schema");
                _.push(Number(w));
              } else
                _.push(w);
            if (_.length !== 0) if (_.length === 1) {
              const w = _[0];
              S.type = w === null ? "null" : typeof w, this.target === "draft-4" || this.target === "openapi-3.0" ? S.enum = [w] : S.const = w;
            } else
              _.every((w) => typeof w == "number") && (S.type = "number"), _.every((w) => typeof w == "string") && (S.type = "string"), _.every((w) => typeof w == "boolean") && (S.type = "string"), _.every((w) => w === null) && (S.type = "null"), S.enum = _;
            break;
          }
          case "file": {
            const S = g, _ = {
              type: "string",
              format: "binary",
              contentEncoding: "binary"
            }, { minimum: w, maximum: T, mime: x } = e._zod.bag;
            w !== void 0 && (_.minLength = w), T !== void 0 && (_.maxLength = T), x ? x.length === 1 ? (_.contentMediaType = x[0], Object.assign(S, _)) : S.anyOf = x.map((A) => ({ ..._, contentMediaType: A })) : Object.assign(S, _);
            break;
          }
          case "transform": {
            if (this.unrepresentable === "throw")
              throw new Error("Transforms cannot be represented in JSON Schema");
            break;
          }
          case "nullable": {
            const S = this.process(s.innerType, p);
            this.target === "openapi-3.0" ? (o.ref = s.innerType, g.nullable = !0) : g.anyOf = [S, { type: "null" }];
            break;
          }
          case "nonoptional": {
            this.process(s.innerType, p), o.ref = s.innerType;
            break;
          }
          case "success": {
            const S = g;
            S.type = "boolean";
            break;
          }
          case "default": {
            this.process(s.innerType, p), o.ref = s.innerType, g.default = JSON.parse(JSON.stringify(s.defaultValue));
            break;
          }
          case "prefault": {
            this.process(s.innerType, p), o.ref = s.innerType, this.io === "input" && (g._prefault = JSON.parse(JSON.stringify(s.defaultValue)));
            break;
          }
          case "catch": {
            this.process(s.innerType, p), o.ref = s.innerType;
            let S;
            try {
              S = s.catchValue(void 0);
            } catch {
              throw new Error("Dynamic catch values are not supported in JSON Schema");
            }
            g.default = S;
            break;
          }
          case "nan": {
            if (this.unrepresentable === "throw")
              throw new Error("NaN cannot be represented in JSON Schema");
            break;
          }
          case "template_literal": {
            const S = g, _ = e._zod.pattern;
            if (!_)
              throw new Error("Pattern not found in template literal");
            S.type = "string", S.pattern = _.source;
            break;
          }
          case "pipe": {
            const S = this.io === "input" ? s.in._zod.def.type === "transform" ? s.out : s.in : s.out;
            this.process(S, p), o.ref = S;
            break;
          }
          case "readonly": {
            this.process(s.innerType, p), o.ref = s.innerType, g.readOnly = !0;
            break;
          }
          case "promise": {
            this.process(s.innerType, p), o.ref = s.innerType;
            break;
          }
          case "optional": {
            this.process(s.innerType, p), o.ref = s.innerType;
            break;
          }
          case "lazy": {
            const S = e._zod.innerType;
            this.process(S, p), o.ref = S;
            break;
          }
          case "custom": {
            if (this.unrepresentable === "throw")
              throw new Error("Custom types cannot be represented in JSON Schema");
            break;
          }
          case "function": {
            if (this.unrepresentable === "throw")
              throw new Error("Function types cannot be represented in JSON Schema");
            break;
          }
        }
      }
    }
    const u = this.metadataRegistry.get(e);
    return u && Object.assign(o.schema, u), this.io === "input" && It(e) && (delete o.schema.examples, delete o.schema.default), this.io === "input" && o.schema._prefault && ((n = o.schema).default ?? (n.default = o.schema._prefault)), delete o.schema._prefault, this.seen.get(e).schema;
  }
  emit(e, t) {
    var l, d, h, f, p, y;
    const n = {
      cycles: (t == null ? void 0 : t.cycles) ?? "ref",
      reused: (t == null ? void 0 : t.reused) ?? "inline",
      // unrepresentable: _params?.unrepresentable ?? "throw",
      // uri: _params?.uri ?? ((id) => `${id}`),
      external: (t == null ? void 0 : t.external) ?? void 0
    }, s = this.seen.get(e);
    if (!s)
      throw new Error("Unprocessed schema. This is a bug in Zod.");
    const a = (g) => {
      var x;
      const S = this.target === "draft-2020-12" ? "$defs" : "definitions";
      if (n.external) {
        const A = (x = n.external.registry.get(g[0])) == null ? void 0 : x.id, R = n.external.uri ?? ((V) => V);
        if (A)
          return { ref: R(A) };
        const E = g[1].defId ?? g[1].schema.id ?? `schema${this.counter++}`;
        return g[1].defId = E, { defId: E, ref: `${R("__shared")}#/${S}/${E}` };
      }
      if (g[1] === s)
        return { ref: "#" };
      const w = `#/${S}/`, T = g[1].schema.id ?? `__schema${this.counter++}`;
      return { defId: T, ref: w + T };
    }, i = (g) => {
      if (g[1].schema.$ref)
        return;
      const S = g[1], { ref: _, defId: w } = a(g);
      S.def = { ...S.schema }, w && (S.defId = w);
      const T = S.schema;
      for (const x in T)
        delete T[x];
      T.$ref = _;
    };
    if (n.cycles === "throw")
      for (const g of this.seen.entries()) {
        const S = g[1];
        if (S.cycle)
          throw new Error(`Cycle detected: #/${(l = S.cycle) == null ? void 0 : l.join("/")}/<root>

Set the \`cycles\` parameter to \`"ref"\` to resolve cyclical schemas with defs.`);
      }
    for (const g of this.seen.entries()) {
      const S = g[1];
      if (e === g[0]) {
        i(g);
        continue;
      }
      if (n.external) {
        const w = (d = n.external.registry.get(g[0])) == null ? void 0 : d.id;
        if (e !== g[0] && w) {
          i(g);
          continue;
        }
      }
      if ((h = this.metadataRegistry.get(g[0])) == null ? void 0 : h.id) {
        i(g);
        continue;
      }
      if (S.cycle) {
        i(g);
        continue;
      }
      if (S.count > 1 && n.reused === "ref") {
        i(g);
        continue;
      }
    }
    const o = (g, S) => {
      const _ = this.seen.get(g), w = _.def ?? _.schema, T = { ...w };
      if (_.ref === null)
        return;
      const x = _.ref;
      if (_.ref = null, x) {
        o(x, S);
        const A = this.seen.get(x).schema;
        A.$ref && (S.target === "draft-7" || S.target === "draft-4" || S.target === "openapi-3.0") ? (w.allOf = w.allOf ?? [], w.allOf.push(A)) : (Object.assign(w, A), Object.assign(w, T));
      }
      _.isParent || this.override({
        zodSchema: g,
        jsonSchema: w,
        path: _.path ?? []
      });
    };
    for (const g of [...this.seen.entries()].reverse())
      o(g[0], { target: this.target });
    const c = {};
    if (this.target === "draft-2020-12" ? c.$schema = "https://json-schema.org/draft/2020-12/schema" : this.target === "draft-7" ? c.$schema = "http://json-schema.org/draft-07/schema#" : this.target === "draft-4" ? c.$schema = "http://json-schema.org/draft-04/schema#" : this.target === "openapi-3.0" || console.warn(`Invalid target: ${this.target}`), (f = n.external) != null && f.uri) {
      const g = (p = n.external.registry.get(e)) == null ? void 0 : p.id;
      if (!g)
        throw new Error("Schema is missing an `id` property");
      c.$id = n.external.uri(g);
    }
    Object.assign(c, s.def);
    const u = ((y = n.external) == null ? void 0 : y.defs) ?? {};
    for (const g of this.seen.entries()) {
      const S = g[1];
      S.def && S.defId && (u[S.defId] = S.def);
    }
    n.external || Object.keys(u).length > 0 && (this.target === "draft-2020-12" ? c.$defs = u : c.definitions = u);
    try {
      return JSON.parse(JSON.stringify(c));
    } catch {
      throw new Error("Error converting schema to JSON.");
    }
  }
}
function Ci(r, e) {
  if (r instanceof Jg) {
    const n = new $h(e), s = {};
    for (const o of r._idmap.entries()) {
      const [c, u] = o;
      n.process(u);
    }
    const a = {}, i = {
      registry: r,
      uri: e == null ? void 0 : e.uri,
      defs: s
    };
    for (const o of r._idmap.entries()) {
      const [c, u] = o;
      a[c] = n.emit(u, {
        ...e,
        external: i
      });
    }
    if (Object.keys(s).length > 0) {
      const o = n.target === "draft-2020-12" ? "$defs" : "definitions";
      a.__shared = {
        [o]: s
      };
    }
    return { schemas: a };
  }
  const t = new $h(e);
  return t.process(r), t.emit(r, e);
}
function It(r, e) {
  const t = e ?? { seen: /* @__PURE__ */ new Set() };
  if (t.seen.has(r))
    return !1;
  t.seen.add(r);
  const n = r._zod.def;
  if (n.type === "transform")
    return !0;
  if (n.type === "array")
    return It(n.element, t);
  if (n.type === "set")
    return It(n.valueType, t);
  if (n.type === "lazy")
    return It(n.getter(), t);
  if (n.type === "promise" || n.type === "optional" || n.type === "nonoptional" || n.type === "nullable" || n.type === "readonly" || n.type === "default" || n.type === "prefault")
    return It(n.innerType, t);
  if (n.type === "intersection")
    return It(n.left, t) || It(n.right, t);
  if (n.type === "record" || n.type === "map")
    return It(n.keyType, t) || It(n.valueType, t);
  if (n.type === "pipe")
    return It(n.in, t) || It(n.out, t);
  if (n.type === "object") {
    for (const s in n.shape)
      if (It(n.shape[s], t))
        return !0;
    return !1;
  }
  if (n.type === "union") {
    for (const s of n.options)
      if (It(s, t))
        return !0;
    return !1;
  }
  if (n.type === "tuple") {
    for (const s of n.items)
      if (It(s, t))
        return !0;
    return !!(n.rest && It(n.rest, t));
  }
  return !1;
}
function qe(r) {
  if (typeof r != "object" || r === null) return !1;
  const e = r;
  if (!("_zod" in e)) return !1;
  const t = e._zod;
  return typeof t == "object" && t !== null && "def" in t;
}
function nt(r) {
  if (typeof r != "object" || r === null) return !1;
  const e = r;
  if (!("_def" in e) || "_zod" in e) return !1;
  const t = e._def;
  return typeof t == "object" && t != null && "typeName" in t;
}
function dI(r) {
  return qe(r) && console.warn("[WARNING] Attempting to use Zod 4 schema in a context where Zod 3 schema is expected. This may cause unexpected behavior."), nt(r);
}
function br(r) {
  return !r || typeof r != "object" || Array.isArray(r) ? !1 : !!(qe(r) || nt(r));
}
function Xg(r) {
  return typeof r == "object" && r !== null && "_def" in r && typeof r._def == "object" && r._def !== null && "typeName" in r._def && r._def.typeName === "ZodLiteral";
}
function Qg(r) {
  return qe(r) ? typeof r == "object" && r !== null && "_zod" in r && typeof r._zod == "object" && r._zod !== null && "def" in r._zod && typeof r._zod.def == "object" && r._zod.def !== null && "type" in r._zod.def && r._zod.def.type === "literal" : !1;
}
function hI(r) {
  return !!(Xg(r) || Qg(r));
}
async function e_(r, e) {
  if (qe(r)) try {
    return {
      success: !0,
      data: await Pg(r, e)
    };
  } catch (t) {
    return {
      success: !1,
      error: t
    };
  }
  if (nt(r)) return await r.safeParseAsync(e);
  throw new Error("Schema must be an instance of z3.ZodType or z4.$ZodType");
}
async function To(r, e) {
  if (qe(r)) return await Pg(r, e);
  if (nt(r)) return await r.parseAsync(e);
  throw new Error("Schema must be an instance of z3.ZodType or z4.$ZodType");
}
function fI(r, e) {
  if (qe(r)) try {
    return {
      success: !0,
      data: yo(r, e)
    };
  } catch (t) {
    return {
      success: !1,
      error: t
    };
  }
  if (nt(r)) return r.safeParse(e);
  throw new Error("Schema must be an instance of z3.ZodType or z4.$ZodType");
}
function pI(r, e) {
  if (qe(r)) return yo(r, e);
  if (nt(r)) return r.parse(e);
  throw new Error("Schema must be an instance of z3.ZodType or z4.$ZodType");
}
function Eo(r) {
  var e;
  if (qe(r)) return (e = pt.get(r)) == null ? void 0 : e.description;
  if (nt(r) || "description" in r && typeof r.description == "string") return r.description;
}
function mI(r) {
  if (!br(r)) return !1;
  if (nt(r)) {
    const e = r._def;
    if (e.typeName === "ZodObject") {
      const t = r;
      return !t.shape || Object.keys(t.shape).length === 0;
    }
    if (e.typeName === "ZodRecord") return !0;
  }
  if (qe(r)) {
    const e = r._zod.def;
    if (e.type === "object") {
      const t = r;
      return !t.shape || Object.keys(t.shape).length === 0;
    }
    if (e.type === "record") return !0;
  }
  return typeof r == "object" && r !== null && !("shape" in r);
}
function kl(r) {
  return br(r) ? nt(r) ? r._def.typeName === "ZodString" : qe(r) ? r._zod.def.type === "string" : !1 : !1;
}
function Ol(r) {
  return typeof r == "object" && r !== null && "_def" in r && typeof r._def == "object" && r._def !== null && "typeName" in r._def && r._def.typeName === "ZodObject";
}
function xr(r) {
  return qe(r) ? typeof r == "object" && r !== null && "_zod" in r && typeof r._zod == "object" && r._zod !== null && "def" in r._zod && typeof r._zod.def == "object" && r._zod.def !== null && "type" in r._zod.def && r._zod.def.type === "object" : !1;
}
function xo(r) {
  return qe(r) ? typeof r == "object" && r !== null && "_zod" in r && typeof r._zod == "object" && r._zod !== null && "def" in r._zod && typeof r._zod.def == "object" && r._zod.def !== null && "type" in r._zod.def && r._zod.def.type === "array" : !1;
}
function t_(r) {
  return qe(r) ? typeof r == "object" && r !== null && "_zod" in r && typeof r._zod == "object" && r._zod !== null && "def" in r._zod && typeof r._zod.def == "object" && r._zod.def !== null && "type" in r._zod.def && r._zod.def.type === "optional" : !1;
}
function r_(r) {
  return qe(r) ? typeof r == "object" && r !== null && "_zod" in r && typeof r._zod == "object" && r._zod !== null && "def" in r._zod && typeof r._zod.def == "object" && r._zod.def !== null && "type" in r._zod.def && r._zod.def.type === "nullable" : !1;
}
function gI(r) {
  return !!(Ol(r) || xr(r));
}
function Xc(r) {
  if (nt(r)) return r.shape;
  if (qe(r)) return r._zod.def.shape;
  throw new Error("Schema must be an instance of z3.ZodObject or z4.$ZodObject");
}
function _I(r, e) {
  if (nt(r)) return r.extend(e);
  if (qe(r)) return Ag(r, e);
  throw new Error("Schema must be an instance of z3.ZodObject or z4.$ZodObject");
}
function yI(r) {
  if (nt(r)) return r.partial();
  if (qe(r)) return $g(Il, r, void 0);
  throw new Error("Schema must be an instance of z3.ZodObject or z4.$ZodObject");
}
function Ri(r, e = !1) {
  if (nt(r)) return r.strict();
  if (xr(r)) {
    const t = r._zod.def.shape;
    if (e) for (const [a, i] of Object.entries(r._zod.def.shape)) {
      if (xr(i)) {
        const c = Ri(i, e);
        t[a] = c;
      } else if (xo(i)) {
        let c = i._zod.def.element;
        xr(c) && (c = Ri(c, e)), t[a] = bt(i, {
          ...i._zod.def,
          element: c
        });
      } else t[a] = i;
      const o = pt.get(i);
      o && pt.add(t[a], o);
    }
    const n = bt(r, {
      ...r._zod.def,
      shape: t,
      catchall: Gg(Vg)
    }), s = pt.get(r);
    return s && pt.add(n, s), n;
  }
  throw new Error("Schema must be an instance of z3.ZodObject or z4.$ZodObject");
}
function Qc(r, e = !1) {
  if (Ol(r)) return r.passthrough();
  if (xr(r)) {
    const t = r._zod.def.shape;
    if (e) for (const [a, i] of Object.entries(r._zod.def.shape)) {
      if (xr(i)) {
        const c = Qc(i, e);
        t[a] = c;
      } else if (xo(i)) {
        let c = i._zod.def.element;
        xr(c) && (c = Qc(c, e)), t[a] = bt(i, {
          ...i._zod.def,
          element: c
        });
      } else t[a] = i;
      const o = pt.get(i);
      o && pt.add(t[a], o);
    }
    const n = bt(r, {
      ...r._zod.def,
      shape: t,
      catchall: Wg(Zg)
    }), s = pt.get(r);
    return s && pt.add(n, s), n;
  }
  throw new Error("Schema must be an instance of z3.ZodObject or z4.$ZodObject");
}
function wI(r) {
  if (nt(r)) try {
    const e = r.parse(void 0);
    return () => e;
  } catch {
    return;
  }
  if (qe(r)) try {
    const e = yo(r, void 0);
    return () => e;
  } catch {
    return;
  }
}
function vI(r) {
  return nt(r) && "typeName" in r._def && r._def.typeName === "ZodEffects";
}
function bI(r) {
  return qe(r) && r._zod.def.type === "pipe";
}
function hn(r, e, t) {
  const n = t.get(r);
  if (n !== void 0) return n;
  if (nt(r))
    return vI(r) ? hn(r._def.schema, e, t) : r;
  if (qe(r)) {
    let s = r;
    if (bI(r) && (s = hn(r._zod.def.in, e, t)), e) {
      if (xr(s)) {
        const i = s._zod.def.shape;
        for (const [o, c] of Object.entries(s._zod.def.shape)) i[o] = hn(c, e, t);
        s = bt(s, {
          ...s._zod.def,
          shape: i
        });
      } else if (xo(s)) {
        const i = hn(s._zod.def.element, e, t);
        s = bt(s, {
          ...s._zod.def,
          element: i
        });
      } else if (t_(s)) {
        const i = hn(s._zod.def.innerType, e, t);
        s = bt(s, {
          ...s._zod.def,
          innerType: i
        });
      } else if (r_(s)) {
        const i = hn(s._zod.def.innerType, e, t);
        s = bt(s, {
          ...s._zod.def,
          innerType: i
        });
      }
    }
    const a = pt.get(r);
    return a && pt.add(s, a), t.set(r, s), s;
  }
  throw new Error("Schema must be an instance of z3.ZodType or z4.$ZodType");
}
function n_(r, e = !1) {
  return hn(r, e, /* @__PURE__ */ new WeakMap());
}
function SI(r, e) {
  if (nt(r)) {
    const t = Xc(r), n = {};
    for (const [s, a] of Object.entries(t)) e(s, a) ? n[s] = a.optional() : n[s] = a;
    return r.extend(n);
  }
  if (qe(r)) {
    const t = Xc(r), n = { ...r._zod.def.shape };
    for (const [i, o] of Object.entries(t)) e(i, o) && (n[i] = new Il({
      type: "optional",
      innerType: o
    }));
    const s = bt(r, {
      ...r._zod.def,
      shape: n
    }), a = pt.get(r);
    return a && pt.add(s, a), s;
  }
  throw new Error("Schema must be an instance of z3.ZodObject or z4.$ZodObject");
}
function s_(r) {
  return r instanceof Error && (r.constructor.name === "ZodError" || r.constructor.name === "$ZodError");
}
function lc(r) {
  return r.replace(/[^a-zA-Z-_0-9]/g, "_");
}
const TI = [
  "*",
  "_",
  "`"
];
function EI(r) {
  let e = "";
  for (const [t, n] of Object.entries(r)) e += `	classDef ${t} ${n};
`;
  return e;
}
function xI(r, e, t) {
  const { firstNode: n, lastNode: s, nodeColors: a, withStyles: i = !0, curveStyle: o = "linear", wrapLabelNWords: c = 9 } = t ?? {};
  let u = i ? `%%{init: {'flowchart': {'curve': '${o}'}}}%%
graph TD;
` : `graph TD;
`;
  if (i) {
    const f = "default", p = { [f]: "{0}({1})" };
    n !== void 0 && (p[n] = "{0}([{1}]):::first"), s !== void 0 && (p[s] = "{0}([{1}]):::last");
    for (const [y, g] of Object.entries(r)) {
      const S = g.name.split(":").pop() ?? "";
      let w = TI.some((x) => S.startsWith(x) && S.endsWith(x)) ? `<p>${S}</p>` : S;
      Object.keys(g.metadata ?? {}).length && (w += `<hr/><small><em>${Object.entries(g.metadata ?? {}).map(([x, A]) => `${x} = ${A}`).join(`
`)}</em></small>`);
      const T = (p[y] ?? p[f]).replace("{0}", lc(y)).replace("{1}", w);
      u += `	${T}
`;
    }
  }
  const l = {};
  for (const f of e) {
    const p = f.source.split(":"), y = f.target.split(":"), g = p.filter((S, _) => S === y[_]).join(":");
    l[g] || (l[g] = []), l[g].push(f);
  }
  const d = /* @__PURE__ */ new Set();
  function h(f, p) {
    const y = f.length === 1 && f[0].source === f[0].target;
    if (p && !y) {
      const g = p.split(":").pop();
      if (d.has(g)) throw new Error(`Found duplicate subgraph '${g}' -- this likely means that you're reusing a subgraph node with the same name. Please adjust your graph to have subgraph nodes with unique names.`);
      d.add(g), u += `	subgraph ${g}
`;
    }
    for (const g of f) {
      const { source: S, target: _, data: w, conditional: T } = g;
      let x = "";
      if (w !== void 0) {
        let A = w;
        const R = A.split(" ");
        R.length > c && (A = Array.from({ length: Math.ceil(R.length / c) }, (E, V) => R.slice(V * c, (V + 1) * c).join(" ")).join("&nbsp;<br>&nbsp;")), x = T ? ` -. &nbsp;${A}&nbsp; .-> ` : ` -- &nbsp;${A}&nbsp; --> `;
      } else x = T ? " -.-> " : " --> ";
      u += `	${lc(S)}${x}${lc(_)};
`;
    }
    for (const g in l) g.startsWith(`${p}:`) && g !== p && h(l[g], g);
    p && !y && (u += `	end
`);
  }
  h(l[""] ?? [], "");
  for (const f in l) !f.includes(":") && f !== "" && h(l[f], f);
  return i && (u += EI(a ?? {})), u;
}
async function II(r, e) {
  let t = (e == null ? void 0 : e.backgroundColor) ?? "white";
  const n = (e == null ? void 0 : e.imageType) ?? "png", s = vT(r);
  t !== void 0 && (/^#(?:[0-9a-fA-F]{3}){1,2}$/.test(t) || (t = `!${t}`));
  const a = `https://mermaid.ink/img/${s}?bgColor=${t}&type=${n}`, i = await fetch(a);
  if (!i.ok) throw new Error([
    "Failed to render the graph using the Mermaid.INK API.",
    `Status code: ${i.status}`,
    `Status text: ${i.statusText}`
  ].join(`
`));
  return await i.blob();
}
const kI = Symbol("Let zodToJsonSchema decide on which parser to use"), OI = {
  name: void 0,
  $refStrategy: "root",
  basePath: ["#"],
  effectStrategy: "input",
  pipeStrategy: "all",
  dateStrategy: "format:date-time",
  mapStrategy: "entries",
  removeAdditionalStrategy: "passthrough",
  allowedAdditionalProperties: !0,
  rejectedAdditionalProperties: !1,
  definitionPath: "definitions",
  target: "jsonSchema7",
  strictUnions: !1,
  definitions: {},
  errorMessages: !1,
  markdownDescription: !1,
  patternStrategy: "escape",
  applyRegexFlags: !1,
  emailStrategy: "format:email",
  base64Strategy: "contentEncoding:base64",
  nameStrategy: "ref",
  openAiAnyTypeName: "OpenAiAnyType"
}, AI = (r) => ({
  ...OI,
  ...r
}), $I = (r) => {
  const e = AI(r), t = e.name !== void 0 ? [
    ...e.basePath,
    e.definitionPath,
    e.name
  ] : e.basePath;
  return {
    ...e,
    flags: { hasReferencedOpenAiAnyType: !1 },
    currentPath: t,
    propertyPath: void 0,
    seen: new Map(Object.entries(e.definitions).map(([n, s]) => [s._def, {
      def: s._def,
      path: [
        ...e.basePath,
        e.definitionPath,
        n
      ],
      jsonSchema: void 0
    }]))
  };
}, a_ = (r, e) => {
  let t = 0;
  for (; t < r.length && t < e.length && r[t] === e[t]; t++) ;
  return [(r.length - t).toString(), ...e.slice(t)].join("/");
};
function Vt(r) {
  if (r.target !== "openAi") return {};
  const e = [
    ...r.basePath,
    r.definitionPath,
    r.openAiAnyTypeName
  ];
  return r.flags.hasReferencedOpenAiAnyType = !0, { $ref: r.$refStrategy === "relative" ? a_(e, r.currentPath) : e.join("/") };
}
function i_(r, e, t, n) {
  n != null && n.errorMessages && t && (r.errorMessage = {
    ...r.errorMessage,
    [e]: t
  });
}
function De(r, e, t, n, s) {
  r[e] = t, i_(r, e, n, s);
}
var Re;
(function(r) {
  r.assertEqual = (s) => {
  };
  function e(s) {
  }
  r.assertIs = e;
  function t(s) {
    throw new Error();
  }
  r.assertNever = t, r.arrayToEnum = (s) => {
    const a = {};
    for (const i of s)
      a[i] = i;
    return a;
  }, r.getValidEnumValues = (s) => {
    const a = r.objectKeys(s).filter((o) => typeof s[s[o]] != "number"), i = {};
    for (const o of a)
      i[o] = s[o];
    return r.objectValues(i);
  }, r.objectValues = (s) => r.objectKeys(s).map(function(a) {
    return s[a];
  }), r.objectKeys = typeof Object.keys == "function" ? (s) => Object.keys(s) : (s) => {
    const a = [];
    for (const i in s)
      Object.prototype.hasOwnProperty.call(s, i) && a.push(i);
    return a;
  }, r.find = (s, a) => {
    for (const i of s)
      if (a(i))
        return i;
  }, r.isInteger = typeof Number.isInteger == "function" ? (s) => Number.isInteger(s) : (s) => typeof s == "number" && Number.isFinite(s) && Math.floor(s) === s;
  function n(s, a = " | ") {
    return s.map((i) => typeof i == "string" ? `'${i}'` : i).join(a);
  }
  r.joinValues = n, r.jsonStringifyReplacer = (s, a) => typeof a == "bigint" ? a.toString() : a;
})(Re || (Re = {}));
var Ch;
(function(r) {
  r.mergeShapes = (e, t) => ({
    ...e,
    ...t
    // second overwrites first
  });
})(Ch || (Ch = {}));
const ee = Re.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]), Yr = (r) => {
  switch (typeof r) {
    case "undefined":
      return ee.undefined;
    case "string":
      return ee.string;
    case "number":
      return Number.isNaN(r) ? ee.nan : ee.number;
    case "boolean":
      return ee.boolean;
    case "function":
      return ee.function;
    case "bigint":
      return ee.bigint;
    case "symbol":
      return ee.symbol;
    case "object":
      return Array.isArray(r) ? ee.array : r === null ? ee.null : r.then && typeof r.then == "function" && r.catch && typeof r.catch == "function" ? ee.promise : typeof Map < "u" && r instanceof Map ? ee.map : typeof Set < "u" && r instanceof Set ? ee.set : typeof Date < "u" && r instanceof Date ? ee.date : ee.object;
    default:
      return ee.unknown;
  }
}, B = Re.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
class Br extends Error {
  get errors() {
    return this.issues;
  }
  constructor(e) {
    super(), this.issues = [], this.addIssue = (n) => {
      this.issues = [...this.issues, n];
    }, this.addIssues = (n = []) => {
      this.issues = [...this.issues, ...n];
    };
    const t = new.target.prototype;
    Object.setPrototypeOf ? Object.setPrototypeOf(this, t) : this.__proto__ = t, this.name = "ZodError", this.issues = e;
  }
  format(e) {
    const t = e || function(a) {
      return a.message;
    }, n = { _errors: [] }, s = (a) => {
      for (const i of a.issues)
        if (i.code === "invalid_union")
          i.unionErrors.map(s);
        else if (i.code === "invalid_return_type")
          s(i.returnTypeError);
        else if (i.code === "invalid_arguments")
          s(i.argumentsError);
        else if (i.path.length === 0)
          n._errors.push(t(i));
        else {
          let o = n, c = 0;
          for (; c < i.path.length; ) {
            const u = i.path[c];
            c === i.path.length - 1 ? (o[u] = o[u] || { _errors: [] }, o[u]._errors.push(t(i))) : o[u] = o[u] || { _errors: [] }, o = o[u], c++;
          }
        }
    };
    return s(this), n;
  }
  static assert(e) {
    if (!(e instanceof Br))
      throw new Error(`Not a ZodError: ${e}`);
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, Re.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(e = (t) => t.message) {
    const t = /* @__PURE__ */ Object.create(null), n = [];
    for (const s of this.issues)
      if (s.path.length > 0) {
        const a = s.path[0];
        t[a] = t[a] || [], t[a].push(e(s));
      } else
        n.push(e(s));
    return { formErrors: n, fieldErrors: t };
  }
  get formErrors() {
    return this.flatten();
  }
}
Br.create = (r) => new Br(r);
const eu = (r, e) => {
  let t;
  switch (r.code) {
    case B.invalid_type:
      r.received === ee.undefined ? t = "Required" : t = `Expected ${r.expected}, received ${r.received}`;
      break;
    case B.invalid_literal:
      t = `Invalid literal value, expected ${JSON.stringify(r.expected, Re.jsonStringifyReplacer)}`;
      break;
    case B.unrecognized_keys:
      t = `Unrecognized key(s) in object: ${Re.joinValues(r.keys, ", ")}`;
      break;
    case B.invalid_union:
      t = "Invalid input";
      break;
    case B.invalid_union_discriminator:
      t = `Invalid discriminator value. Expected ${Re.joinValues(r.options)}`;
      break;
    case B.invalid_enum_value:
      t = `Invalid enum value. Expected ${Re.joinValues(r.options)}, received '${r.received}'`;
      break;
    case B.invalid_arguments:
      t = "Invalid function arguments";
      break;
    case B.invalid_return_type:
      t = "Invalid function return type";
      break;
    case B.invalid_date:
      t = "Invalid date";
      break;
    case B.invalid_string:
      typeof r.validation == "object" ? "includes" in r.validation ? (t = `Invalid input: must include "${r.validation.includes}"`, typeof r.validation.position == "number" && (t = `${t} at one or more positions greater than or equal to ${r.validation.position}`)) : "startsWith" in r.validation ? t = `Invalid input: must start with "${r.validation.startsWith}"` : "endsWith" in r.validation ? t = `Invalid input: must end with "${r.validation.endsWith}"` : Re.assertNever(r.validation) : r.validation !== "regex" ? t = `Invalid ${r.validation}` : t = "Invalid";
      break;
    case B.too_small:
      r.type === "array" ? t = `Array must contain ${r.exact ? "exactly" : r.inclusive ? "at least" : "more than"} ${r.minimum} element(s)` : r.type === "string" ? t = `String must contain ${r.exact ? "exactly" : r.inclusive ? "at least" : "over"} ${r.minimum} character(s)` : r.type === "number" ? t = `Number must be ${r.exact ? "exactly equal to " : r.inclusive ? "greater than or equal to " : "greater than "}${r.minimum}` : r.type === "bigint" ? t = `Number must be ${r.exact ? "exactly equal to " : r.inclusive ? "greater than or equal to " : "greater than "}${r.minimum}` : r.type === "date" ? t = `Date must be ${r.exact ? "exactly equal to " : r.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(r.minimum))}` : t = "Invalid input";
      break;
    case B.too_big:
      r.type === "array" ? t = `Array must contain ${r.exact ? "exactly" : r.inclusive ? "at most" : "less than"} ${r.maximum} element(s)` : r.type === "string" ? t = `String must contain ${r.exact ? "exactly" : r.inclusive ? "at most" : "under"} ${r.maximum} character(s)` : r.type === "number" ? t = `Number must be ${r.exact ? "exactly" : r.inclusive ? "less than or equal to" : "less than"} ${r.maximum}` : r.type === "bigint" ? t = `BigInt must be ${r.exact ? "exactly" : r.inclusive ? "less than or equal to" : "less than"} ${r.maximum}` : r.type === "date" ? t = `Date must be ${r.exact ? "exactly" : r.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(r.maximum))}` : t = "Invalid input";
      break;
    case B.custom:
      t = "Invalid input";
      break;
    case B.invalid_intersection_types:
      t = "Intersection results could not be merged";
      break;
    case B.not_multiple_of:
      t = `Number must be a multiple of ${r.multipleOf}`;
      break;
    case B.not_finite:
      t = "Number must be finite";
      break;
    default:
      t = e.defaultError, Re.assertNever(r);
  }
  return { message: t };
};
let CI = eu;
function RI() {
  return CI;
}
const NI = (r) => {
  const { data: e, path: t, errorMaps: n, issueData: s } = r, a = [...t, ...s.path || []], i = {
    ...s,
    path: a
  };
  if (s.message !== void 0)
    return {
      ...s,
      path: a,
      message: s.message
    };
  let o = "";
  const c = n.filter((u) => !!u).slice().reverse();
  for (const u of c)
    o = u(i, { data: e, defaultError: o }).message;
  return {
    ...s,
    path: a,
    message: o
  };
};
function W(r, e) {
  const t = RI(), n = NI({
    issueData: e,
    data: r.data,
    path: r.path,
    errorMaps: [
      r.common.contextualErrorMap,
      // contextual error map is first priority
      r.schemaErrorMap,
      // then schema-bound map if available
      t,
      // then global override map
      t === eu ? void 0 : eu
      // then global default map
    ].filter((s) => !!s)
  });
  r.common.issues.push(n);
}
class qt {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    this.value === "valid" && (this.value = "dirty");
  }
  abort() {
    this.value !== "aborted" && (this.value = "aborted");
  }
  static mergeArray(e, t) {
    const n = [];
    for (const s of t) {
      if (s.status === "aborted")
        return be;
      s.status === "dirty" && e.dirty(), n.push(s.value);
    }
    return { status: e.value, value: n };
  }
  static async mergeObjectAsync(e, t) {
    const n = [];
    for (const s of t) {
      const a = await s.key, i = await s.value;
      n.push({
        key: a,
        value: i
      });
    }
    return qt.mergeObjectSync(e, n);
  }
  static mergeObjectSync(e, t) {
    const n = {};
    for (const s of t) {
      const { key: a, value: i } = s;
      if (a.status === "aborted" || i.status === "aborted")
        return be;
      a.status === "dirty" && e.dirty(), i.status === "dirty" && e.dirty(), a.value !== "__proto__" && (typeof i.value < "u" || s.alwaysSet) && (n[a.value] = i.value);
    }
    return { status: e.value, value: n };
  }
}
const be = Object.freeze({
  status: "aborted"
}), ks = (r) => ({ status: "dirty", value: r }), Gt = (r) => ({ status: "valid", value: r }), Rh = (r) => r.status === "aborted", Nh = (r) => r.status === "dirty", es = (r) => r.status === "valid", Ni = (r) => typeof Promise < "u" && r instanceof Promise;
var te;
(function(r) {
  r.errToObj = (e) => typeof e == "string" ? { message: e } : e || {}, r.toString = (e) => typeof e == "string" ? e : e == null ? void 0 : e.message;
})(te || (te = {}));
class an {
  constructor(e, t, n, s) {
    this._cachedPath = [], this.parent = e, this.data = t, this._path = n, this._key = s;
  }
  get path() {
    return this._cachedPath.length || (Array.isArray(this._key) ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)), this._cachedPath;
  }
}
const Ph = (r, e) => {
  if (es(e))
    return { success: !0, data: e.value };
  if (!r.common.issues.length)
    throw new Error("Validation failed but no issues detected.");
  return {
    success: !1,
    get error() {
      if (this._error)
        return this._error;
      const t = new Br(r.common.issues);
      return this._error = t, this._error;
    }
  };
};
function Ie(r) {
  if (!r)
    return {};
  const { errorMap: e, invalid_type_error: t, required_error: n, description: s } = r;
  if (e && (t || n))
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  return e ? { errorMap: e, description: s } : { errorMap: (i, o) => {
    const { message: c } = r;
    return i.code === "invalid_enum_value" ? { message: c ?? o.defaultError } : typeof o.data > "u" ? { message: c ?? n ?? o.defaultError } : i.code !== "invalid_type" ? { message: o.defaultError } : { message: c ?? t ?? o.defaultError };
  }, description: s };
}
let $e = class {
  get description() {
    return this._def.description;
  }
  _getType(e) {
    return Yr(e.data);
  }
  _getOrReturnCtx(e, t) {
    return t || {
      common: e.parent.common,
      data: e.data,
      parsedType: Yr(e.data),
      schemaErrorMap: this._def.errorMap,
      path: e.path,
      parent: e.parent
    };
  }
  _processInputParams(e) {
    return {
      status: new qt(),
      ctx: {
        common: e.parent.common,
        data: e.data,
        parsedType: Yr(e.data),
        schemaErrorMap: this._def.errorMap,
        path: e.path,
        parent: e.parent
      }
    };
  }
  _parseSync(e) {
    const t = this._parse(e);
    if (Ni(t))
      throw new Error("Synchronous parse encountered promise.");
    return t;
  }
  _parseAsync(e) {
    const t = this._parse(e);
    return Promise.resolve(t);
  }
  parse(e, t) {
    const n = this.safeParse(e, t);
    if (n.success)
      return n.data;
    throw n.error;
  }
  safeParse(e, t) {
    const n = {
      common: {
        issues: [],
        async: (t == null ? void 0 : t.async) ?? !1,
        contextualErrorMap: t == null ? void 0 : t.errorMap
      },
      path: (t == null ? void 0 : t.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: e,
      parsedType: Yr(e)
    }, s = this._parseSync({ data: e, path: n.path, parent: n });
    return Ph(n, s);
  }
  "~validate"(e) {
    var n, s;
    const t = {
      common: {
        issues: [],
        async: !!this["~standard"].async
      },
      path: [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: e,
      parsedType: Yr(e)
    };
    if (!this["~standard"].async)
      try {
        const a = this._parseSync({ data: e, path: [], parent: t });
        return es(a) ? {
          value: a.value
        } : {
          issues: t.common.issues
        };
      } catch (a) {
        (s = (n = a == null ? void 0 : a.message) == null ? void 0 : n.toLowerCase()) != null && s.includes("encountered") && (this["~standard"].async = !0), t.common = {
          issues: [],
          async: !0
        };
      }
    return this._parseAsync({ data: e, path: [], parent: t }).then((a) => es(a) ? {
      value: a.value
    } : {
      issues: t.common.issues
    });
  }
  async parseAsync(e, t) {
    const n = await this.safeParseAsync(e, t);
    if (n.success)
      return n.data;
    throw n.error;
  }
  async safeParseAsync(e, t) {
    const n = {
      common: {
        issues: [],
        contextualErrorMap: t == null ? void 0 : t.errorMap,
        async: !0
      },
      path: (t == null ? void 0 : t.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: e,
      parsedType: Yr(e)
    }, s = this._parse({ data: e, path: n.path, parent: n }), a = await (Ni(s) ? s : Promise.resolve(s));
    return Ph(n, a);
  }
  refine(e, t) {
    const n = (s) => typeof t == "string" || typeof t > "u" ? { message: t } : typeof t == "function" ? t(s) : t;
    return this._refinement((s, a) => {
      const i = e(s), o = () => a.addIssue({
        code: B.custom,
        ...n(s)
      });
      return typeof Promise < "u" && i instanceof Promise ? i.then((c) => c ? !0 : (o(), !1)) : i ? !0 : (o(), !1);
    });
  }
  refinement(e, t) {
    return this._refinement((n, s) => e(n) ? !0 : (s.addIssue(typeof t == "function" ? t(n, s) : t), !1));
  }
  _refinement(e) {
    return new rs({
      schema: this,
      typeName: C.ZodEffects,
      effect: { type: "refinement", refinement: e }
    });
  }
  superRefine(e) {
    return this._refinement(e);
  }
  constructor(e) {
    this.spa = this.safeParseAsync, this._def = e, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.readonly = this.readonly.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this), this["~standard"] = {
      version: 1,
      vendor: "zod",
      validate: (t) => this["~validate"](t)
    };
  }
  optional() {
    return tn.create(this, this._def);
  }
  nullable() {
    return ns.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ts.create(this);
  }
  promise() {
    return Di.create(this, this._def);
  }
  or(e) {
    return Li.create([this, e], this._def);
  }
  and(e) {
    return Mi.create(this, e, this._def);
  }
  transform(e) {
    return new rs({
      ...Ie(this._def),
      schema: this,
      typeName: C.ZodEffects,
      effect: { type: "transform", transform: e }
    });
  }
  default(e) {
    const t = typeof e == "function" ? e : () => e;
    return new iu({
      ...Ie(this._def),
      innerType: this,
      defaultValue: t,
      typeName: C.ZodDefault
    });
  }
  brand() {
    return new rk({
      typeName: C.ZodBranded,
      type: this,
      ...Ie(this._def)
    });
  }
  catch(e) {
    const t = typeof e == "function" ? e : () => e;
    return new ou({
      ...Ie(this._def),
      innerType: this,
      catchValue: t,
      typeName: C.ZodCatch
    });
  }
  describe(e) {
    const t = this.constructor;
    return new t({
      ...this._def,
      description: e
    });
  }
  pipe(e) {
    return $l.create(this, e);
  }
  readonly() {
    return cu.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
};
const PI = /^c[^\s-]{8,}$/i, LI = /^[0-9a-z]+$/, MI = /^[0-9A-HJKMNP-TV-Z]{26}$/i, DI = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i, jI = /^[a-z0-9_-]{21}$/i, FI = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/, UI = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/, zI = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i, BI = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
let dc;
const ZI = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/, VI = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/, qI = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/, HI = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/, JI = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/, WI = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/, o_ = "((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))", GI = new RegExp(`^${o_}$`);
function c_(r) {
  let e = "[0-5]\\d";
  r.precision ? e = `${e}\\.\\d{${r.precision}}` : r.precision == null && (e = `${e}(\\.\\d+)?`);
  const t = r.precision ? "+" : "?";
  return `([01]\\d|2[0-3]):[0-5]\\d(:${e})${t}`;
}
function KI(r) {
  return new RegExp(`^${c_(r)}$`);
}
function YI(r) {
  let e = `${o_}T${c_(r)}`;
  const t = [];
  return t.push(r.local ? "Z?" : "Z"), r.offset && t.push("([+-]\\d{2}:?\\d{2})"), e = `${e}(${t.join("|")})`, new RegExp(`^${e}$`);
}
function XI(r, e) {
  return !!((e === "v4" || !e) && ZI.test(r) || (e === "v6" || !e) && qI.test(r));
}
function QI(r, e) {
  if (!FI.test(r))
    return !1;
  try {
    const [t] = r.split(".");
    if (!t)
      return !1;
    const n = t.replace(/-/g, "+").replace(/_/g, "/").padEnd(t.length + (4 - t.length % 4) % 4, "="), s = JSON.parse(atob(n));
    return !(typeof s != "object" || s === null || "typ" in s && (s == null ? void 0 : s.typ) !== "JWT" || !s.alg || e && s.alg !== e);
  } catch {
    return !1;
  }
}
function ek(r, e) {
  return !!((e === "v4" || !e) && VI.test(r) || (e === "v6" || !e) && HI.test(r));
}
let tu = class Os extends $e {
  _parse(e) {
    if (this._def.coerce && (e.data = String(e.data)), this._getType(e) !== ee.string) {
      const a = this._getOrReturnCtx(e);
      return W(a, {
        code: B.invalid_type,
        expected: ee.string,
        received: a.parsedType
      }), be;
    }
    const n = new qt();
    let s;
    for (const a of this._def.checks)
      if (a.kind === "min")
        e.data.length < a.value && (s = this._getOrReturnCtx(e, s), W(s, {
          code: B.too_small,
          minimum: a.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: a.message
        }), n.dirty());
      else if (a.kind === "max")
        e.data.length > a.value && (s = this._getOrReturnCtx(e, s), W(s, {
          code: B.too_big,
          maximum: a.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: a.message
        }), n.dirty());
      else if (a.kind === "length") {
        const i = e.data.length > a.value, o = e.data.length < a.value;
        (i || o) && (s = this._getOrReturnCtx(e, s), i ? W(s, {
          code: B.too_big,
          maximum: a.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: a.message
        }) : o && W(s, {
          code: B.too_small,
          minimum: a.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: a.message
        }), n.dirty());
      } else if (a.kind === "email")
        zI.test(e.data) || (s = this._getOrReturnCtx(e, s), W(s, {
          validation: "email",
          code: B.invalid_string,
          message: a.message
        }), n.dirty());
      else if (a.kind === "emoji")
        dc || (dc = new RegExp(BI, "u")), dc.test(e.data) || (s = this._getOrReturnCtx(e, s), W(s, {
          validation: "emoji",
          code: B.invalid_string,
          message: a.message
        }), n.dirty());
      else if (a.kind === "uuid")
        DI.test(e.data) || (s = this._getOrReturnCtx(e, s), W(s, {
          validation: "uuid",
          code: B.invalid_string,
          message: a.message
        }), n.dirty());
      else if (a.kind === "nanoid")
        jI.test(e.data) || (s = this._getOrReturnCtx(e, s), W(s, {
          validation: "nanoid",
          code: B.invalid_string,
          message: a.message
        }), n.dirty());
      else if (a.kind === "cuid")
        PI.test(e.data) || (s = this._getOrReturnCtx(e, s), W(s, {
          validation: "cuid",
          code: B.invalid_string,
          message: a.message
        }), n.dirty());
      else if (a.kind === "cuid2")
        LI.test(e.data) || (s = this._getOrReturnCtx(e, s), W(s, {
          validation: "cuid2",
          code: B.invalid_string,
          message: a.message
        }), n.dirty());
      else if (a.kind === "ulid")
        MI.test(e.data) || (s = this._getOrReturnCtx(e, s), W(s, {
          validation: "ulid",
          code: B.invalid_string,
          message: a.message
        }), n.dirty());
      else if (a.kind === "url")
        try {
          new URL(e.data);
        } catch {
          s = this._getOrReturnCtx(e, s), W(s, {
            validation: "url",
            code: B.invalid_string,
            message: a.message
          }), n.dirty();
        }
      else a.kind === "regex" ? (a.regex.lastIndex = 0, a.regex.test(e.data) || (s = this._getOrReturnCtx(e, s), W(s, {
        validation: "regex",
        code: B.invalid_string,
        message: a.message
      }), n.dirty())) : a.kind === "trim" ? e.data = e.data.trim() : a.kind === "includes" ? e.data.includes(a.value, a.position) || (s = this._getOrReturnCtx(e, s), W(s, {
        code: B.invalid_string,
        validation: { includes: a.value, position: a.position },
        message: a.message
      }), n.dirty()) : a.kind === "toLowerCase" ? e.data = e.data.toLowerCase() : a.kind === "toUpperCase" ? e.data = e.data.toUpperCase() : a.kind === "startsWith" ? e.data.startsWith(a.value) || (s = this._getOrReturnCtx(e, s), W(s, {
        code: B.invalid_string,
        validation: { startsWith: a.value },
        message: a.message
      }), n.dirty()) : a.kind === "endsWith" ? e.data.endsWith(a.value) || (s = this._getOrReturnCtx(e, s), W(s, {
        code: B.invalid_string,
        validation: { endsWith: a.value },
        message: a.message
      }), n.dirty()) : a.kind === "datetime" ? YI(a).test(e.data) || (s = this._getOrReturnCtx(e, s), W(s, {
        code: B.invalid_string,
        validation: "datetime",
        message: a.message
      }), n.dirty()) : a.kind === "date" ? GI.test(e.data) || (s = this._getOrReturnCtx(e, s), W(s, {
        code: B.invalid_string,
        validation: "date",
        message: a.message
      }), n.dirty()) : a.kind === "time" ? KI(a).test(e.data) || (s = this._getOrReturnCtx(e, s), W(s, {
        code: B.invalid_string,
        validation: "time",
        message: a.message
      }), n.dirty()) : a.kind === "duration" ? UI.test(e.data) || (s = this._getOrReturnCtx(e, s), W(s, {
        validation: "duration",
        code: B.invalid_string,
        message: a.message
      }), n.dirty()) : a.kind === "ip" ? XI(e.data, a.version) || (s = this._getOrReturnCtx(e, s), W(s, {
        validation: "ip",
        code: B.invalid_string,
        message: a.message
      }), n.dirty()) : a.kind === "jwt" ? QI(e.data, a.alg) || (s = this._getOrReturnCtx(e, s), W(s, {
        validation: "jwt",
        code: B.invalid_string,
        message: a.message
      }), n.dirty()) : a.kind === "cidr" ? ek(e.data, a.version) || (s = this._getOrReturnCtx(e, s), W(s, {
        validation: "cidr",
        code: B.invalid_string,
        message: a.message
      }), n.dirty()) : a.kind === "base64" ? JI.test(e.data) || (s = this._getOrReturnCtx(e, s), W(s, {
        validation: "base64",
        code: B.invalid_string,
        message: a.message
      }), n.dirty()) : a.kind === "base64url" ? WI.test(e.data) || (s = this._getOrReturnCtx(e, s), W(s, {
        validation: "base64url",
        code: B.invalid_string,
        message: a.message
      }), n.dirty()) : Re.assertNever(a);
    return { status: n.value, value: e.data };
  }
  _regex(e, t, n) {
    return this.refinement((s) => e.test(s), {
      validation: t,
      code: B.invalid_string,
      ...te.errToObj(n)
    });
  }
  _addCheck(e) {
    return new Os({
      ...this._def,
      checks: [...this._def.checks, e]
    });
  }
  email(e) {
    return this._addCheck({ kind: "email", ...te.errToObj(e) });
  }
  url(e) {
    return this._addCheck({ kind: "url", ...te.errToObj(e) });
  }
  emoji(e) {
    return this._addCheck({ kind: "emoji", ...te.errToObj(e) });
  }
  uuid(e) {
    return this._addCheck({ kind: "uuid", ...te.errToObj(e) });
  }
  nanoid(e) {
    return this._addCheck({ kind: "nanoid", ...te.errToObj(e) });
  }
  cuid(e) {
    return this._addCheck({ kind: "cuid", ...te.errToObj(e) });
  }
  cuid2(e) {
    return this._addCheck({ kind: "cuid2", ...te.errToObj(e) });
  }
  ulid(e) {
    return this._addCheck({ kind: "ulid", ...te.errToObj(e) });
  }
  base64(e) {
    return this._addCheck({ kind: "base64", ...te.errToObj(e) });
  }
  base64url(e) {
    return this._addCheck({
      kind: "base64url",
      ...te.errToObj(e)
    });
  }
  jwt(e) {
    return this._addCheck({ kind: "jwt", ...te.errToObj(e) });
  }
  ip(e) {
    return this._addCheck({ kind: "ip", ...te.errToObj(e) });
  }
  cidr(e) {
    return this._addCheck({ kind: "cidr", ...te.errToObj(e) });
  }
  datetime(e) {
    return typeof e == "string" ? this._addCheck({
      kind: "datetime",
      precision: null,
      offset: !1,
      local: !1,
      message: e
    }) : this._addCheck({
      kind: "datetime",
      precision: typeof (e == null ? void 0 : e.precision) > "u" ? null : e == null ? void 0 : e.precision,
      offset: (e == null ? void 0 : e.offset) ?? !1,
      local: (e == null ? void 0 : e.local) ?? !1,
      ...te.errToObj(e == null ? void 0 : e.message)
    });
  }
  date(e) {
    return this._addCheck({ kind: "date", message: e });
  }
  time(e) {
    return typeof e == "string" ? this._addCheck({
      kind: "time",
      precision: null,
      message: e
    }) : this._addCheck({
      kind: "time",
      precision: typeof (e == null ? void 0 : e.precision) > "u" ? null : e == null ? void 0 : e.precision,
      ...te.errToObj(e == null ? void 0 : e.message)
    });
  }
  duration(e) {
    return this._addCheck({ kind: "duration", ...te.errToObj(e) });
  }
  regex(e, t) {
    return this._addCheck({
      kind: "regex",
      regex: e,
      ...te.errToObj(t)
    });
  }
  includes(e, t) {
    return this._addCheck({
      kind: "includes",
      value: e,
      position: t == null ? void 0 : t.position,
      ...te.errToObj(t == null ? void 0 : t.message)
    });
  }
  startsWith(e, t) {
    return this._addCheck({
      kind: "startsWith",
      value: e,
      ...te.errToObj(t)
    });
  }
  endsWith(e, t) {
    return this._addCheck({
      kind: "endsWith",
      value: e,
      ...te.errToObj(t)
    });
  }
  min(e, t) {
    return this._addCheck({
      kind: "min",
      value: e,
      ...te.errToObj(t)
    });
  }
  max(e, t) {
    return this._addCheck({
      kind: "max",
      value: e,
      ...te.errToObj(t)
    });
  }
  length(e, t) {
    return this._addCheck({
      kind: "length",
      value: e,
      ...te.errToObj(t)
    });
  }
  /**
   * Equivalent to `.min(1)`
   */
  nonempty(e) {
    return this.min(1, te.errToObj(e));
  }
  trim() {
    return new Os({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new Os({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new Os({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((e) => e.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((e) => e.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((e) => e.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((e) => e.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((e) => e.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((e) => e.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((e) => e.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((e) => e.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((e) => e.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((e) => e.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((e) => e.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((e) => e.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((e) => e.kind === "ip");
  }
  get isCIDR() {
    return !!this._def.checks.find((e) => e.kind === "cidr");
  }
  get isBase64() {
    return !!this._def.checks.find((e) => e.kind === "base64");
  }
  get isBase64url() {
    return !!this._def.checks.find((e) => e.kind === "base64url");
  }
  get minLength() {
    let e = null;
    for (const t of this._def.checks)
      t.kind === "min" && (e === null || t.value > e) && (e = t.value);
    return e;
  }
  get maxLength() {
    let e = null;
    for (const t of this._def.checks)
      t.kind === "max" && (e === null || t.value < e) && (e = t.value);
    return e;
  }
};
tu.create = (r) => new tu({
  checks: [],
  typeName: C.ZodString,
  coerce: (r == null ? void 0 : r.coerce) ?? !1,
  ...Ie(r)
});
function tk(r, e) {
  const t = (r.toString().split(".")[1] || "").length, n = (e.toString().split(".")[1] || "").length, s = t > n ? t : n, a = Number.parseInt(r.toFixed(s).replace(".", "")), i = Number.parseInt(e.toFixed(s).replace(".", ""));
  return a % i / 10 ** s;
}
let Lh = class ru extends $e {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
  }
  _parse(e) {
    if (this._def.coerce && (e.data = Number(e.data)), this._getType(e) !== ee.number) {
      const a = this._getOrReturnCtx(e);
      return W(a, {
        code: B.invalid_type,
        expected: ee.number,
        received: a.parsedType
      }), be;
    }
    let n;
    const s = new qt();
    for (const a of this._def.checks)
      a.kind === "int" ? Re.isInteger(e.data) || (n = this._getOrReturnCtx(e, n), W(n, {
        code: B.invalid_type,
        expected: "integer",
        received: "float",
        message: a.message
      }), s.dirty()) : a.kind === "min" ? (a.inclusive ? e.data < a.value : e.data <= a.value) && (n = this._getOrReturnCtx(e, n), W(n, {
        code: B.too_small,
        minimum: a.value,
        type: "number",
        inclusive: a.inclusive,
        exact: !1,
        message: a.message
      }), s.dirty()) : a.kind === "max" ? (a.inclusive ? e.data > a.value : e.data >= a.value) && (n = this._getOrReturnCtx(e, n), W(n, {
        code: B.too_big,
        maximum: a.value,
        type: "number",
        inclusive: a.inclusive,
        exact: !1,
        message: a.message
      }), s.dirty()) : a.kind === "multipleOf" ? tk(e.data, a.value) !== 0 && (n = this._getOrReturnCtx(e, n), W(n, {
        code: B.not_multiple_of,
        multipleOf: a.value,
        message: a.message
      }), s.dirty()) : a.kind === "finite" ? Number.isFinite(e.data) || (n = this._getOrReturnCtx(e, n), W(n, {
        code: B.not_finite,
        message: a.message
      }), s.dirty()) : Re.assertNever(a);
    return { status: s.value, value: e.data };
  }
  gte(e, t) {
    return this.setLimit("min", e, !0, te.toString(t));
  }
  gt(e, t) {
    return this.setLimit("min", e, !1, te.toString(t));
  }
  lte(e, t) {
    return this.setLimit("max", e, !0, te.toString(t));
  }
  lt(e, t) {
    return this.setLimit("max", e, !1, te.toString(t));
  }
  setLimit(e, t, n, s) {
    return new ru({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: e,
          value: t,
          inclusive: n,
          message: te.toString(s)
        }
      ]
    });
  }
  _addCheck(e) {
    return new ru({
      ...this._def,
      checks: [...this._def.checks, e]
    });
  }
  int(e) {
    return this._addCheck({
      kind: "int",
      message: te.toString(e)
    });
  }
  positive(e) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !1,
      message: te.toString(e)
    });
  }
  negative(e) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !1,
      message: te.toString(e)
    });
  }
  nonpositive(e) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !0,
      message: te.toString(e)
    });
  }
  nonnegative(e) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !0,
      message: te.toString(e)
    });
  }
  multipleOf(e, t) {
    return this._addCheck({
      kind: "multipleOf",
      value: e,
      message: te.toString(t)
    });
  }
  finite(e) {
    return this._addCheck({
      kind: "finite",
      message: te.toString(e)
    });
  }
  safe(e) {
    return this._addCheck({
      kind: "min",
      inclusive: !0,
      value: Number.MIN_SAFE_INTEGER,
      message: te.toString(e)
    })._addCheck({
      kind: "max",
      inclusive: !0,
      value: Number.MAX_SAFE_INTEGER,
      message: te.toString(e)
    });
  }
  get minValue() {
    let e = null;
    for (const t of this._def.checks)
      t.kind === "min" && (e === null || t.value > e) && (e = t.value);
    return e;
  }
  get maxValue() {
    let e = null;
    for (const t of this._def.checks)
      t.kind === "max" && (e === null || t.value < e) && (e = t.value);
    return e;
  }
  get isInt() {
    return !!this._def.checks.find((e) => e.kind === "int" || e.kind === "multipleOf" && Re.isInteger(e.value));
  }
  get isFinite() {
    let e = null, t = null;
    for (const n of this._def.checks) {
      if (n.kind === "finite" || n.kind === "int" || n.kind === "multipleOf")
        return !0;
      n.kind === "min" ? (t === null || n.value > t) && (t = n.value) : n.kind === "max" && (e === null || n.value < e) && (e = n.value);
    }
    return Number.isFinite(t) && Number.isFinite(e);
  }
};
Lh.create = (r) => new Lh({
  checks: [],
  typeName: C.ZodNumber,
  coerce: (r == null ? void 0 : r.coerce) || !1,
  ...Ie(r)
});
class ea extends $e {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte;
  }
  _parse(e) {
    if (this._def.coerce)
      try {
        e.data = BigInt(e.data);
      } catch {
        return this._getInvalidInput(e);
      }
    if (this._getType(e) !== ee.bigint)
      return this._getInvalidInput(e);
    let n;
    const s = new qt();
    for (const a of this._def.checks)
      a.kind === "min" ? (a.inclusive ? e.data < a.value : e.data <= a.value) && (n = this._getOrReturnCtx(e, n), W(n, {
        code: B.too_small,
        type: "bigint",
        minimum: a.value,
        inclusive: a.inclusive,
        message: a.message
      }), s.dirty()) : a.kind === "max" ? (a.inclusive ? e.data > a.value : e.data >= a.value) && (n = this._getOrReturnCtx(e, n), W(n, {
        code: B.too_big,
        type: "bigint",
        maximum: a.value,
        inclusive: a.inclusive,
        message: a.message
      }), s.dirty()) : a.kind === "multipleOf" ? e.data % a.value !== BigInt(0) && (n = this._getOrReturnCtx(e, n), W(n, {
        code: B.not_multiple_of,
        multipleOf: a.value,
        message: a.message
      }), s.dirty()) : Re.assertNever(a);
    return { status: s.value, value: e.data };
  }
  _getInvalidInput(e) {
    const t = this._getOrReturnCtx(e);
    return W(t, {
      code: B.invalid_type,
      expected: ee.bigint,
      received: t.parsedType
    }), be;
  }
  gte(e, t) {
    return this.setLimit("min", e, !0, te.toString(t));
  }
  gt(e, t) {
    return this.setLimit("min", e, !1, te.toString(t));
  }
  lte(e, t) {
    return this.setLimit("max", e, !0, te.toString(t));
  }
  lt(e, t) {
    return this.setLimit("max", e, !1, te.toString(t));
  }
  setLimit(e, t, n, s) {
    return new ea({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: e,
          value: t,
          inclusive: n,
          message: te.toString(s)
        }
      ]
    });
  }
  _addCheck(e) {
    return new ea({
      ...this._def,
      checks: [...this._def.checks, e]
    });
  }
  positive(e) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !1,
      message: te.toString(e)
    });
  }
  negative(e) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !1,
      message: te.toString(e)
    });
  }
  nonpositive(e) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !0,
      message: te.toString(e)
    });
  }
  nonnegative(e) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !0,
      message: te.toString(e)
    });
  }
  multipleOf(e, t) {
    return this._addCheck({
      kind: "multipleOf",
      value: e,
      message: te.toString(t)
    });
  }
  get minValue() {
    let e = null;
    for (const t of this._def.checks)
      t.kind === "min" && (e === null || t.value > e) && (e = t.value);
    return e;
  }
  get maxValue() {
    let e = null;
    for (const t of this._def.checks)
      t.kind === "max" && (e === null || t.value < e) && (e = t.value);
    return e;
  }
}
ea.create = (r) => new ea({
  checks: [],
  typeName: C.ZodBigInt,
  coerce: (r == null ? void 0 : r.coerce) ?? !1,
  ...Ie(r)
});
let Mh = class extends $e {
  _parse(e) {
    if (this._def.coerce && (e.data = !!e.data), this._getType(e) !== ee.boolean) {
      const n = this._getOrReturnCtx(e);
      return W(n, {
        code: B.invalid_type,
        expected: ee.boolean,
        received: n.parsedType
      }), be;
    }
    return Gt(e.data);
  }
};
Mh.create = (r) => new Mh({
  typeName: C.ZodBoolean,
  coerce: (r == null ? void 0 : r.coerce) || !1,
  ...Ie(r)
});
class Pi extends $e {
  _parse(e) {
    if (this._def.coerce && (e.data = new Date(e.data)), this._getType(e) !== ee.date) {
      const a = this._getOrReturnCtx(e);
      return W(a, {
        code: B.invalid_type,
        expected: ee.date,
        received: a.parsedType
      }), be;
    }
    if (Number.isNaN(e.data.getTime())) {
      const a = this._getOrReturnCtx(e);
      return W(a, {
        code: B.invalid_date
      }), be;
    }
    const n = new qt();
    let s;
    for (const a of this._def.checks)
      a.kind === "min" ? e.data.getTime() < a.value && (s = this._getOrReturnCtx(e, s), W(s, {
        code: B.too_small,
        message: a.message,
        inclusive: !0,
        exact: !1,
        minimum: a.value,
        type: "date"
      }), n.dirty()) : a.kind === "max" ? e.data.getTime() > a.value && (s = this._getOrReturnCtx(e, s), W(s, {
        code: B.too_big,
        message: a.message,
        inclusive: !0,
        exact: !1,
        maximum: a.value,
        type: "date"
      }), n.dirty()) : Re.assertNever(a);
    return {
      status: n.value,
      value: new Date(e.data.getTime())
    };
  }
  _addCheck(e) {
    return new Pi({
      ...this._def,
      checks: [...this._def.checks, e]
    });
  }
  min(e, t) {
    return this._addCheck({
      kind: "min",
      value: e.getTime(),
      message: te.toString(t)
    });
  }
  max(e, t) {
    return this._addCheck({
      kind: "max",
      value: e.getTime(),
      message: te.toString(t)
    });
  }
  get minDate() {
    let e = null;
    for (const t of this._def.checks)
      t.kind === "min" && (e === null || t.value > e) && (e = t.value);
    return e != null ? new Date(e) : null;
  }
  get maxDate() {
    let e = null;
    for (const t of this._def.checks)
      t.kind === "max" && (e === null || t.value < e) && (e = t.value);
    return e != null ? new Date(e) : null;
  }
}
Pi.create = (r) => new Pi({
  checks: [],
  coerce: (r == null ? void 0 : r.coerce) || !1,
  typeName: C.ZodDate,
  ...Ie(r)
});
class Dh extends $e {
  _parse(e) {
    if (this._getType(e) !== ee.symbol) {
      const n = this._getOrReturnCtx(e);
      return W(n, {
        code: B.invalid_type,
        expected: ee.symbol,
        received: n.parsedType
      }), be;
    }
    return Gt(e.data);
  }
}
Dh.create = (r) => new Dh({
  typeName: C.ZodSymbol,
  ...Ie(r)
});
class jh extends $e {
  _parse(e) {
    if (this._getType(e) !== ee.undefined) {
      const n = this._getOrReturnCtx(e);
      return W(n, {
        code: B.invalid_type,
        expected: ee.undefined,
        received: n.parsedType
      }), be;
    }
    return Gt(e.data);
  }
}
jh.create = (r) => new jh({
  typeName: C.ZodUndefined,
  ...Ie(r)
});
class Fh extends $e {
  _parse(e) {
    if (this._getType(e) !== ee.null) {
      const n = this._getOrReturnCtx(e);
      return W(n, {
        code: B.invalid_type,
        expected: ee.null,
        received: n.parsedType
      }), be;
    }
    return Gt(e.data);
  }
}
Fh.create = (r) => new Fh({
  typeName: C.ZodNull,
  ...Ie(r)
});
class nu extends $e {
  constructor() {
    super(...arguments), this._any = !0;
  }
  _parse(e) {
    return Gt(e.data);
  }
}
nu.create = (r) => new nu({
  typeName: C.ZodAny,
  ...Ie(r)
});
let Uh = class extends $e {
  constructor() {
    super(...arguments), this._unknown = !0;
  }
  _parse(e) {
    return Gt(e.data);
  }
};
Uh.create = (r) => new Uh({
  typeName: C.ZodUnknown,
  ...Ie(r)
});
let on = class extends $e {
  _parse(e) {
    const t = this._getOrReturnCtx(e);
    return W(t, {
      code: B.invalid_type,
      expected: ee.never,
      received: t.parsedType
    }), be;
  }
};
on.create = (r) => new on({
  typeName: C.ZodNever,
  ...Ie(r)
});
class zh extends $e {
  _parse(e) {
    if (this._getType(e) !== ee.undefined) {
      const n = this._getOrReturnCtx(e);
      return W(n, {
        code: B.invalid_type,
        expected: ee.void,
        received: n.parsedType
      }), be;
    }
    return Gt(e.data);
  }
}
zh.create = (r) => new zh({
  typeName: C.ZodVoid,
  ...Ie(r)
});
let ts = class li extends $e {
  _parse(e) {
    const { ctx: t, status: n } = this._processInputParams(e), s = this._def;
    if (t.parsedType !== ee.array)
      return W(t, {
        code: B.invalid_type,
        expected: ee.array,
        received: t.parsedType
      }), be;
    if (s.exactLength !== null) {
      const i = t.data.length > s.exactLength.value, o = t.data.length < s.exactLength.value;
      (i || o) && (W(t, {
        code: i ? B.too_big : B.too_small,
        minimum: o ? s.exactLength.value : void 0,
        maximum: i ? s.exactLength.value : void 0,
        type: "array",
        inclusive: !0,
        exact: !0,
        message: s.exactLength.message
      }), n.dirty());
    }
    if (s.minLength !== null && t.data.length < s.minLength.value && (W(t, {
      code: B.too_small,
      minimum: s.minLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: s.minLength.message
    }), n.dirty()), s.maxLength !== null && t.data.length > s.maxLength.value && (W(t, {
      code: B.too_big,
      maximum: s.maxLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: s.maxLength.message
    }), n.dirty()), t.common.async)
      return Promise.all([...t.data].map((i, o) => s.type._parseAsync(new an(t, i, t.path, o)))).then((i) => qt.mergeArray(n, i));
    const a = [...t.data].map((i, o) => s.type._parseSync(new an(t, i, t.path, o)));
    return qt.mergeArray(n, a);
  }
  get element() {
    return this._def.type;
  }
  min(e, t) {
    return new li({
      ...this._def,
      minLength: { value: e, message: te.toString(t) }
    });
  }
  max(e, t) {
    return new li({
      ...this._def,
      maxLength: { value: e, message: te.toString(t) }
    });
  }
  length(e, t) {
    return new li({
      ...this._def,
      exactLength: { value: e, message: te.toString(t) }
    });
  }
  nonempty(e) {
    return this.min(1, e);
  }
};
ts.create = (r, e) => new ts({
  type: r,
  minLength: null,
  maxLength: null,
  exactLength: null,
  typeName: C.ZodArray,
  ...Ie(e)
});
function Un(r) {
  if (r instanceof Zr) {
    const e = {};
    for (const t in r.shape) {
      const n = r.shape[t];
      e[t] = tn.create(Un(n));
    }
    return new Zr({
      ...r._def,
      shape: () => e
    });
  } else return r instanceof ts ? new ts({
    ...r._def,
    type: Un(r.element)
  }) : r instanceof tn ? tn.create(Un(r.unwrap())) : r instanceof ns ? ns.create(Un(r.unwrap())) : r instanceof xn ? xn.create(r.items.map((e) => Un(e))) : r;
}
let Zr = class sr extends $e {
  constructor() {
    super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const e = this._def.shape(), t = Re.objectKeys(e);
    return this._cached = { shape: e, keys: t }, this._cached;
  }
  _parse(e) {
    if (this._getType(e) !== ee.object) {
      const u = this._getOrReturnCtx(e);
      return W(u, {
        code: B.invalid_type,
        expected: ee.object,
        received: u.parsedType
      }), be;
    }
    const { status: n, ctx: s } = this._processInputParams(e), { shape: a, keys: i } = this._getCached(), o = [];
    if (!(this._def.catchall instanceof on && this._def.unknownKeys === "strip"))
      for (const u in s.data)
        i.includes(u) || o.push(u);
    const c = [];
    for (const u of i) {
      const l = a[u], d = s.data[u];
      c.push({
        key: { status: "valid", value: u },
        value: l._parse(new an(s, d, s.path, u)),
        alwaysSet: u in s.data
      });
    }
    if (this._def.catchall instanceof on) {
      const u = this._def.unknownKeys;
      if (u === "passthrough")
        for (const l of o)
          c.push({
            key: { status: "valid", value: l },
            value: { status: "valid", value: s.data[l] }
          });
      else if (u === "strict")
        o.length > 0 && (W(s, {
          code: B.unrecognized_keys,
          keys: o
        }), n.dirty());
      else if (u !== "strip") throw new Error("Internal ZodObject error: invalid unknownKeys value.");
    } else {
      const u = this._def.catchall;
      for (const l of o) {
        const d = s.data[l];
        c.push({
          key: { status: "valid", value: l },
          value: u._parse(
            new an(s, d, s.path, l)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: l in s.data
        });
      }
    }
    return s.common.async ? Promise.resolve().then(async () => {
      const u = [];
      for (const l of c) {
        const d = await l.key, h = await l.value;
        u.push({
          key: d,
          value: h,
          alwaysSet: l.alwaysSet
        });
      }
      return u;
    }).then((u) => qt.mergeObjectSync(n, u)) : qt.mergeObjectSync(n, c);
  }
  get shape() {
    return this._def.shape();
  }
  strict(e) {
    return te.errToObj, new sr({
      ...this._def,
      unknownKeys: "strict",
      ...e !== void 0 ? {
        errorMap: (t, n) => {
          var a, i;
          const s = ((i = (a = this._def).errorMap) == null ? void 0 : i.call(a, t, n).message) ?? n.defaultError;
          return t.code === "unrecognized_keys" ? {
            message: te.errToObj(e).message ?? s
          } : {
            message: s
          };
        }
      } : {}
    });
  }
  strip() {
    return new sr({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new sr({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(e) {
    return new sr({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...e
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(e) {
    return new sr({
      unknownKeys: e._def.unknownKeys,
      catchall: e._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...e._def.shape()
      }),
      typeName: C.ZodObject
    });
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(e, t) {
    return this.augment({ [e]: t });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(e) {
    return new sr({
      ...this._def,
      catchall: e
    });
  }
  pick(e) {
    const t = {};
    for (const n of Re.objectKeys(e))
      e[n] && this.shape[n] && (t[n] = this.shape[n]);
    return new sr({
      ...this._def,
      shape: () => t
    });
  }
  omit(e) {
    const t = {};
    for (const n of Re.objectKeys(this.shape))
      e[n] || (t[n] = this.shape[n]);
    return new sr({
      ...this._def,
      shape: () => t
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return Un(this);
  }
  partial(e) {
    const t = {};
    for (const n of Re.objectKeys(this.shape)) {
      const s = this.shape[n];
      e && !e[n] ? t[n] = s : t[n] = s.optional();
    }
    return new sr({
      ...this._def,
      shape: () => t
    });
  }
  required(e) {
    const t = {};
    for (const n of Re.objectKeys(this.shape))
      if (e && !e[n])
        t[n] = this.shape[n];
      else {
        let a = this.shape[n];
        for (; a instanceof tn; )
          a = a._def.innerType;
        t[n] = a;
      }
    return new sr({
      ...this._def,
      shape: () => t
    });
  }
  keyof() {
    return u_(Re.objectKeys(this.shape));
  }
};
Zr.create = (r, e) => new Zr({
  shape: () => r,
  unknownKeys: "strip",
  catchall: on.create(),
  typeName: C.ZodObject,
  ...Ie(e)
});
Zr.strictCreate = (r, e) => new Zr({
  shape: () => r,
  unknownKeys: "strict",
  catchall: on.create(),
  typeName: C.ZodObject,
  ...Ie(e)
});
Zr.lazycreate = (r, e) => new Zr({
  shape: r,
  unknownKeys: "strip",
  catchall: on.create(),
  typeName: C.ZodObject,
  ...Ie(e)
});
let Li = class extends $e {
  _parse(e) {
    const { ctx: t } = this._processInputParams(e), n = this._def.options;
    function s(a) {
      for (const o of a)
        if (o.result.status === "valid")
          return o.result;
      for (const o of a)
        if (o.result.status === "dirty")
          return t.common.issues.push(...o.ctx.common.issues), o.result;
      const i = a.map((o) => new Br(o.ctx.common.issues));
      return W(t, {
        code: B.invalid_union,
        unionErrors: i
      }), be;
    }
    if (t.common.async)
      return Promise.all(n.map(async (a) => {
        const i = {
          ...t,
          common: {
            ...t.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await a._parseAsync({
            data: t.data,
            path: t.path,
            parent: i
          }),
          ctx: i
        };
      })).then(s);
    {
      let a;
      const i = [];
      for (const c of n) {
        const u = {
          ...t,
          common: {
            ...t.common,
            issues: []
          },
          parent: null
        }, l = c._parseSync({
          data: t.data,
          path: t.path,
          parent: u
        });
        if (l.status === "valid")
          return l;
        l.status === "dirty" && !a && (a = { result: l, ctx: u }), u.common.issues.length && i.push(u.common.issues);
      }
      if (a)
        return t.common.issues.push(...a.ctx.common.issues), a.result;
      const o = i.map((c) => new Br(c));
      return W(t, {
        code: B.invalid_union,
        unionErrors: o
      }), be;
    }
  }
  get options() {
    return this._def.options;
  }
};
Li.create = (r, e) => new Li({
  options: r,
  typeName: C.ZodUnion,
  ...Ie(e)
});
function su(r, e) {
  const t = Yr(r), n = Yr(e);
  if (r === e)
    return { valid: !0, data: r };
  if (t === ee.object && n === ee.object) {
    const s = Re.objectKeys(e), a = Re.objectKeys(r).filter((o) => s.indexOf(o) !== -1), i = { ...r, ...e };
    for (const o of a) {
      const c = su(r[o], e[o]);
      if (!c.valid)
        return { valid: !1 };
      i[o] = c.data;
    }
    return { valid: !0, data: i };
  } else if (t === ee.array && n === ee.array) {
    if (r.length !== e.length)
      return { valid: !1 };
    const s = [];
    for (let a = 0; a < r.length; a++) {
      const i = r[a], o = e[a], c = su(i, o);
      if (!c.valid)
        return { valid: !1 };
      s.push(c.data);
    }
    return { valid: !0, data: s };
  } else return t === ee.date && n === ee.date && +r == +e ? { valid: !0, data: r } : { valid: !1 };
}
let Mi = class extends $e {
  _parse(e) {
    const { status: t, ctx: n } = this._processInputParams(e), s = (a, i) => {
      if (Rh(a) || Rh(i))
        return be;
      const o = su(a.value, i.value);
      return o.valid ? ((Nh(a) || Nh(i)) && t.dirty(), { status: t.value, value: o.data }) : (W(n, {
        code: B.invalid_intersection_types
      }), be);
    };
    return n.common.async ? Promise.all([
      this._def.left._parseAsync({
        data: n.data,
        path: n.path,
        parent: n
      }),
      this._def.right._parseAsync({
        data: n.data,
        path: n.path,
        parent: n
      })
    ]).then(([a, i]) => s(a, i)) : s(this._def.left._parseSync({
      data: n.data,
      path: n.path,
      parent: n
    }), this._def.right._parseSync({
      data: n.data,
      path: n.path,
      parent: n
    }));
  }
};
Mi.create = (r, e, t) => new Mi({
  left: r,
  right: e,
  typeName: C.ZodIntersection,
  ...Ie(t)
});
class xn extends $e {
  _parse(e) {
    const { status: t, ctx: n } = this._processInputParams(e);
    if (n.parsedType !== ee.array)
      return W(n, {
        code: B.invalid_type,
        expected: ee.array,
        received: n.parsedType
      }), be;
    if (n.data.length < this._def.items.length)
      return W(n, {
        code: B.too_small,
        minimum: this._def.items.length,
        inclusive: !0,
        exact: !1,
        type: "array"
      }), be;
    !this._def.rest && n.data.length > this._def.items.length && (W(n, {
      code: B.too_big,
      maximum: this._def.items.length,
      inclusive: !0,
      exact: !1,
      type: "array"
    }), t.dirty());
    const a = [...n.data].map((i, o) => {
      const c = this._def.items[o] || this._def.rest;
      return c ? c._parse(new an(n, i, n.path, o)) : null;
    }).filter((i) => !!i);
    return n.common.async ? Promise.all(a).then((i) => qt.mergeArray(t, i)) : qt.mergeArray(t, a);
  }
  get items() {
    return this._def.items;
  }
  rest(e) {
    return new xn({
      ...this._def,
      rest: e
    });
  }
}
xn.create = (r, e) => {
  if (!Array.isArray(r))
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  return new xn({
    items: r,
    typeName: C.ZodTuple,
    rest: null,
    ...Ie(e)
  });
};
class Bh extends $e {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(e) {
    const { status: t, ctx: n } = this._processInputParams(e);
    if (n.parsedType !== ee.map)
      return W(n, {
        code: B.invalid_type,
        expected: ee.map,
        received: n.parsedType
      }), be;
    const s = this._def.keyType, a = this._def.valueType, i = [...n.data.entries()].map(([o, c], u) => ({
      key: s._parse(new an(n, o, n.path, [u, "key"])),
      value: a._parse(new an(n, c, n.path, [u, "value"]))
    }));
    if (n.common.async) {
      const o = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const c of i) {
          const u = await c.key, l = await c.value;
          if (u.status === "aborted" || l.status === "aborted")
            return be;
          (u.status === "dirty" || l.status === "dirty") && t.dirty(), o.set(u.value, l.value);
        }
        return { status: t.value, value: o };
      });
    } else {
      const o = /* @__PURE__ */ new Map();
      for (const c of i) {
        const u = c.key, l = c.value;
        if (u.status === "aborted" || l.status === "aborted")
          return be;
        (u.status === "dirty" || l.status === "dirty") && t.dirty(), o.set(u.value, l.value);
      }
      return { status: t.value, value: o };
    }
  }
}
Bh.create = (r, e, t) => new Bh({
  valueType: e,
  keyType: r,
  typeName: C.ZodMap,
  ...Ie(t)
});
class ta extends $e {
  _parse(e) {
    const { status: t, ctx: n } = this._processInputParams(e);
    if (n.parsedType !== ee.set)
      return W(n, {
        code: B.invalid_type,
        expected: ee.set,
        received: n.parsedType
      }), be;
    const s = this._def;
    s.minSize !== null && n.data.size < s.minSize.value && (W(n, {
      code: B.too_small,
      minimum: s.minSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: s.minSize.message
    }), t.dirty()), s.maxSize !== null && n.data.size > s.maxSize.value && (W(n, {
      code: B.too_big,
      maximum: s.maxSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: s.maxSize.message
    }), t.dirty());
    const a = this._def.valueType;
    function i(c) {
      const u = /* @__PURE__ */ new Set();
      for (const l of c) {
        if (l.status === "aborted")
          return be;
        l.status === "dirty" && t.dirty(), u.add(l.value);
      }
      return { status: t.value, value: u };
    }
    const o = [...n.data.values()].map((c, u) => a._parse(new an(n, c, n.path, u)));
    return n.common.async ? Promise.all(o).then((c) => i(c)) : i(o);
  }
  min(e, t) {
    return new ta({
      ...this._def,
      minSize: { value: e, message: te.toString(t) }
    });
  }
  max(e, t) {
    return new ta({
      ...this._def,
      maxSize: { value: e, message: te.toString(t) }
    });
  }
  size(e, t) {
    return this.min(e, t).max(e, t);
  }
  nonempty(e) {
    return this.min(1, e);
  }
}
ta.create = (r, e) => new ta({
  valueType: r,
  minSize: null,
  maxSize: null,
  typeName: C.ZodSet,
  ...Ie(e)
});
class Zh extends $e {
  get schema() {
    return this._def.getter();
  }
  _parse(e) {
    const { ctx: t } = this._processInputParams(e);
    return this._def.getter()._parse({ data: t.data, path: t.path, parent: t });
  }
}
Zh.create = (r, e) => new Zh({
  getter: r,
  typeName: C.ZodLazy,
  ...Ie(e)
});
class Vh extends $e {
  _parse(e) {
    if (e.data !== this._def.value) {
      const t = this._getOrReturnCtx(e);
      return W(t, {
        received: t.data,
        code: B.invalid_literal,
        expected: this._def.value
      }), be;
    }
    return { status: "valid", value: e.data };
  }
  get value() {
    return this._def.value;
  }
}
Vh.create = (r, e) => new Vh({
  value: r,
  typeName: C.ZodLiteral,
  ...Ie(e)
});
function u_(r, e) {
  return new Al({
    values: r,
    typeName: C.ZodEnum,
    ...Ie(e)
  });
}
let Al = class au extends $e {
  _parse(e) {
    if (typeof e.data != "string") {
      const t = this._getOrReturnCtx(e), n = this._def.values;
      return W(t, {
        expected: Re.joinValues(n),
        received: t.parsedType,
        code: B.invalid_type
      }), be;
    }
    if (this._cache || (this._cache = new Set(this._def.values)), !this._cache.has(e.data)) {
      const t = this._getOrReturnCtx(e), n = this._def.values;
      return W(t, {
        received: t.data,
        code: B.invalid_enum_value,
        options: n
      }), be;
    }
    return Gt(e.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const e = {};
    for (const t of this._def.values)
      e[t] = t;
    return e;
  }
  get Values() {
    const e = {};
    for (const t of this._def.values)
      e[t] = t;
    return e;
  }
  get Enum() {
    const e = {};
    for (const t of this._def.values)
      e[t] = t;
    return e;
  }
  extract(e, t = this._def) {
    return au.create(e, {
      ...this._def,
      ...t
    });
  }
  exclude(e, t = this._def) {
    return au.create(this.options.filter((n) => !e.includes(n)), {
      ...this._def,
      ...t
    });
  }
};
Al.create = u_;
class qh extends $e {
  _parse(e) {
    const t = Re.getValidEnumValues(this._def.values), n = this._getOrReturnCtx(e);
    if (n.parsedType !== ee.string && n.parsedType !== ee.number) {
      const s = Re.objectValues(t);
      return W(n, {
        expected: Re.joinValues(s),
        received: n.parsedType,
        code: B.invalid_type
      }), be;
    }
    if (this._cache || (this._cache = new Set(Re.getValidEnumValues(this._def.values))), !this._cache.has(e.data)) {
      const s = Re.objectValues(t);
      return W(n, {
        received: n.data,
        code: B.invalid_enum_value,
        options: s
      }), be;
    }
    return Gt(e.data);
  }
  get enum() {
    return this._def.values;
  }
}
qh.create = (r, e) => new qh({
  values: r,
  typeName: C.ZodNativeEnum,
  ...Ie(e)
});
class Di extends $e {
  unwrap() {
    return this._def.type;
  }
  _parse(e) {
    const { ctx: t } = this._processInputParams(e);
    if (t.parsedType !== ee.promise && t.common.async === !1)
      return W(t, {
        code: B.invalid_type,
        expected: ee.promise,
        received: t.parsedType
      }), be;
    const n = t.parsedType === ee.promise ? t.data : Promise.resolve(t.data);
    return Gt(n.then((s) => this._def.type.parseAsync(s, {
      path: t.path,
      errorMap: t.common.contextualErrorMap
    })));
  }
}
Di.create = (r, e) => new Di({
  type: r,
  typeName: C.ZodPromise,
  ...Ie(e)
});
class rs extends $e {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === C.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(e) {
    const { status: t, ctx: n } = this._processInputParams(e), s = this._def.effect || null, a = {
      addIssue: (i) => {
        W(n, i), i.fatal ? t.abort() : t.dirty();
      },
      get path() {
        return n.path;
      }
    };
    if (a.addIssue = a.addIssue.bind(a), s.type === "preprocess") {
      const i = s.transform(n.data, a);
      if (n.common.async)
        return Promise.resolve(i).then(async (o) => {
          if (t.value === "aborted")
            return be;
          const c = await this._def.schema._parseAsync({
            data: o,
            path: n.path,
            parent: n
          });
          return c.status === "aborted" ? be : c.status === "dirty" || t.value === "dirty" ? ks(c.value) : c;
        });
      {
        if (t.value === "aborted")
          return be;
        const o = this._def.schema._parseSync({
          data: i,
          path: n.path,
          parent: n
        });
        return o.status === "aborted" ? be : o.status === "dirty" || t.value === "dirty" ? ks(o.value) : o;
      }
    }
    if (s.type === "refinement") {
      const i = (o) => {
        const c = s.refinement(o, a);
        if (n.common.async)
          return Promise.resolve(c);
        if (c instanceof Promise)
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        return o;
      };
      if (n.common.async === !1) {
        const o = this._def.schema._parseSync({
          data: n.data,
          path: n.path,
          parent: n
        });
        return o.status === "aborted" ? be : (o.status === "dirty" && t.dirty(), i(o.value), { status: t.value, value: o.value });
      } else
        return this._def.schema._parseAsync({ data: n.data, path: n.path, parent: n }).then((o) => o.status === "aborted" ? be : (o.status === "dirty" && t.dirty(), i(o.value).then(() => ({ status: t.value, value: o.value }))));
    }
    if (s.type === "transform")
      if (n.common.async === !1) {
        const i = this._def.schema._parseSync({
          data: n.data,
          path: n.path,
          parent: n
        });
        if (!es(i))
          return be;
        const o = s.transform(i.value, a);
        if (o instanceof Promise)
          throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
        return { status: t.value, value: o };
      } else
        return this._def.schema._parseAsync({ data: n.data, path: n.path, parent: n }).then((i) => es(i) ? Promise.resolve(s.transform(i.value, a)).then((o) => ({
          status: t.value,
          value: o
        })) : be);
    Re.assertNever(s);
  }
}
rs.create = (r, e, t) => new rs({
  schema: r,
  typeName: C.ZodEffects,
  effect: e,
  ...Ie(t)
});
rs.createWithPreprocess = (r, e, t) => new rs({
  schema: e,
  effect: { type: "preprocess", transform: r },
  typeName: C.ZodEffects,
  ...Ie(t)
});
let tn = class extends $e {
  _parse(e) {
    return this._getType(e) === ee.undefined ? Gt(void 0) : this._def.innerType._parse(e);
  }
  unwrap() {
    return this._def.innerType;
  }
};
tn.create = (r, e) => new tn({
  innerType: r,
  typeName: C.ZodOptional,
  ...Ie(e)
});
let ns = class extends $e {
  _parse(e) {
    return this._getType(e) === ee.null ? Gt(null) : this._def.innerType._parse(e);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ns.create = (r, e) => new ns({
  innerType: r,
  typeName: C.ZodNullable,
  ...Ie(e)
});
let iu = class extends $e {
  _parse(e) {
    const { ctx: t } = this._processInputParams(e);
    let n = t.data;
    return t.parsedType === ee.undefined && (n = this._def.defaultValue()), this._def.innerType._parse({
      data: n,
      path: t.path,
      parent: t
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
};
iu.create = (r, e) => new iu({
  innerType: r,
  typeName: C.ZodDefault,
  defaultValue: typeof e.default == "function" ? e.default : () => e.default,
  ...Ie(e)
});
let ou = class extends $e {
  _parse(e) {
    const { ctx: t } = this._processInputParams(e), n = {
      ...t,
      common: {
        ...t.common,
        issues: []
      }
    }, s = this._def.innerType._parse({
      data: n.data,
      path: n.path,
      parent: {
        ...n
      }
    });
    return Ni(s) ? s.then((a) => ({
      status: "valid",
      value: a.status === "valid" ? a.value : this._def.catchValue({
        get error() {
          return new Br(n.common.issues);
        },
        input: n.data
      })
    })) : {
      status: "valid",
      value: s.status === "valid" ? s.value : this._def.catchValue({
        get error() {
          return new Br(n.common.issues);
        },
        input: n.data
      })
    };
  }
  removeCatch() {
    return this._def.innerType;
  }
};
ou.create = (r, e) => new ou({
  innerType: r,
  typeName: C.ZodCatch,
  catchValue: typeof e.catch == "function" ? e.catch : () => e.catch,
  ...Ie(e)
});
class Hh extends $e {
  _parse(e) {
    if (this._getType(e) !== ee.nan) {
      const n = this._getOrReturnCtx(e);
      return W(n, {
        code: B.invalid_type,
        expected: ee.nan,
        received: n.parsedType
      }), be;
    }
    return { status: "valid", value: e.data };
  }
}
Hh.create = (r) => new Hh({
  typeName: C.ZodNaN,
  ...Ie(r)
});
class rk extends $e {
  _parse(e) {
    const { ctx: t } = this._processInputParams(e), n = t.data;
    return this._def.type._parse({
      data: n,
      path: t.path,
      parent: t
    });
  }
  unwrap() {
    return this._def.type;
  }
}
class $l extends $e {
  _parse(e) {
    const { status: t, ctx: n } = this._processInputParams(e);
    if (n.common.async)
      return (async () => {
        const a = await this._def.in._parseAsync({
          data: n.data,
          path: n.path,
          parent: n
        });
        return a.status === "aborted" ? be : a.status === "dirty" ? (t.dirty(), ks(a.value)) : this._def.out._parseAsync({
          data: a.value,
          path: n.path,
          parent: n
        });
      })();
    {
      const s = this._def.in._parseSync({
        data: n.data,
        path: n.path,
        parent: n
      });
      return s.status === "aborted" ? be : s.status === "dirty" ? (t.dirty(), {
        status: "dirty",
        value: s.value
      }) : this._def.out._parseSync({
        data: s.value,
        path: n.path,
        parent: n
      });
    }
  }
  static create(e, t) {
    return new $l({
      in: e,
      out: t,
      typeName: C.ZodPipeline
    });
  }
}
let cu = class extends $e {
  _parse(e) {
    const t = this._def.innerType._parse(e), n = (s) => (es(s) && (s.value = Object.freeze(s.value)), s);
    return Ni(t) ? t.then((s) => n(s)) : n(t);
  }
  unwrap() {
    return this._def.innerType;
  }
};
cu.create = (r, e) => new cu({
  innerType: r,
  typeName: C.ZodReadonly,
  ...Ie(e)
});
var C;
(function(r) {
  r.ZodString = "ZodString", r.ZodNumber = "ZodNumber", r.ZodNaN = "ZodNaN", r.ZodBigInt = "ZodBigInt", r.ZodBoolean = "ZodBoolean", r.ZodDate = "ZodDate", r.ZodSymbol = "ZodSymbol", r.ZodUndefined = "ZodUndefined", r.ZodNull = "ZodNull", r.ZodAny = "ZodAny", r.ZodUnknown = "ZodUnknown", r.ZodNever = "ZodNever", r.ZodVoid = "ZodVoid", r.ZodArray = "ZodArray", r.ZodObject = "ZodObject", r.ZodUnion = "ZodUnion", r.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", r.ZodIntersection = "ZodIntersection", r.ZodTuple = "ZodTuple", r.ZodRecord = "ZodRecord", r.ZodMap = "ZodMap", r.ZodSet = "ZodSet", r.ZodFunction = "ZodFunction", r.ZodLazy = "ZodLazy", r.ZodLiteral = "ZodLiteral", r.ZodEnum = "ZodEnum", r.ZodEffects = "ZodEffects", r.ZodNativeEnum = "ZodNativeEnum", r.ZodOptional = "ZodOptional", r.ZodNullable = "ZodNullable", r.ZodDefault = "ZodDefault", r.ZodCatch = "ZodCatch", r.ZodPromise = "ZodPromise", r.ZodBranded = "ZodBranded", r.ZodPipeline = "ZodPipeline", r.ZodReadonly = "ZodReadonly";
})(C || (C = {}));
const Io = tu.create, Jh = nu.create;
on.create;
ts.create;
const ko = Zr.create;
Li.create;
Mi.create;
xn.create;
Al.create;
Di.create;
tn.create;
ns.create;
function nk(r, e) {
  var n, s, a;
  const t = { type: "array" };
  return (n = r.type) != null && n._def && ((a = (s = r.type) == null ? void 0 : s._def) == null ? void 0 : a.typeName) !== C.ZodAny && (t.items = Le(r.type._def, {
    ...e,
    currentPath: [...e.currentPath, "items"]
  })), r.minLength && De(t, "minItems", r.minLength.value, r.minLength.message, e), r.maxLength && De(t, "maxItems", r.maxLength.value, r.maxLength.message, e), r.exactLength && (De(t, "minItems", r.exactLength.value, r.exactLength.message, e), De(t, "maxItems", r.exactLength.value, r.exactLength.message, e)), t;
}
function sk(r, e) {
  const t = {
    type: "integer",
    format: "int64"
  };
  if (!r.checks) return t;
  for (const n of r.checks) switch (n.kind) {
    case "min":
      e.target === "jsonSchema7" ? n.inclusive ? De(t, "minimum", n.value, n.message, e) : De(t, "exclusiveMinimum", n.value, n.message, e) : (n.inclusive || (t.exclusiveMinimum = !0), De(t, "minimum", n.value, n.message, e));
      break;
    case "max":
      e.target === "jsonSchema7" ? n.inclusive ? De(t, "maximum", n.value, n.message, e) : De(t, "exclusiveMaximum", n.value, n.message, e) : (n.inclusive || (t.exclusiveMaximum = !0), De(t, "maximum", n.value, n.message, e));
      break;
    case "multipleOf":
      De(t, "multipleOf", n.value, n.message, e);
      break;
  }
  return t;
}
function ak() {
  return { type: "boolean" };
}
function l_(r, e) {
  return Le(r.type._def, e);
}
const ik = (r, e) => Le(r.innerType._def, e);
function d_(r, e, t) {
  const n = t ?? e.dateStrategy;
  if (Array.isArray(n)) return { anyOf: n.map((s) => d_(r, e, s)) };
  switch (n) {
    case "string":
    case "format:date-time":
      return {
        type: "string",
        format: "date-time"
      };
    case "format:date":
      return {
        type: "string",
        format: "date"
      };
    case "integer":
      return ok(r, e);
  }
}
const ok = (r, e) => {
  const t = {
    type: "integer",
    format: "unix-time"
  };
  if (e.target === "openApi3") return t;
  for (const n of r.checks) switch (n.kind) {
    case "min":
      De(t, "minimum", n.value, n.message, e);
      break;
    case "max":
      De(t, "maximum", n.value, n.message, e);
      break;
  }
  return t;
};
function ck(r, e) {
  return {
    ...Le(r.innerType._def, e),
    default: r.defaultValue()
  };
}
function uk(r, e) {
  return e.effectStrategy === "input" ? Le(r.schema._def, e) : Vt(e);
}
function lk(r) {
  return {
    type: "string",
    enum: Array.from(r.values)
  };
}
const dk = (r) => "type" in r && r.type === "string" ? !1 : "allOf" in r;
function hk(r, e) {
  const t = [Le(r.left._def, {
    ...e,
    currentPath: [
      ...e.currentPath,
      "allOf",
      "0"
    ]
  }), Le(r.right._def, {
    ...e,
    currentPath: [
      ...e.currentPath,
      "allOf",
      "1"
    ]
  })].filter((a) => !!a);
  let n = e.target === "jsonSchema2019-09" ? { unevaluatedProperties: !1 } : void 0;
  const s = [];
  return t.forEach((a) => {
    if (dk(a))
      s.push(...a.allOf), a.unevaluatedProperties === void 0 && (n = void 0);
    else {
      let i = a;
      if ("additionalProperties" in a && a.additionalProperties === !1) {
        const { additionalProperties: o, ...c } = a;
        i = c;
      } else n = void 0;
      s.push(i);
    }
  }), s.length ? {
    allOf: s,
    ...n
  } : void 0;
}
function fk(r, e) {
  const t = typeof r.value;
  return t !== "bigint" && t !== "number" && t !== "boolean" && t !== "string" ? { type: Array.isArray(r.value) ? "array" : "object" } : e.target === "openApi3" ? {
    type: t === "bigint" ? "integer" : t,
    enum: [r.value]
  } : {
    type: t === "bigint" ? "integer" : t,
    const: r.value
  };
}
let hc;
const Qt = {
  cuid: /^[cC][^\s-]{8,}$/,
  cuid2: /^[0-9a-z]+$/,
  ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,
  email: /^(?!\.)(?!.*\.\.)([a-zA-Z0-9_'+\-\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\-]*\.)+[a-zA-Z]{2,}$/,
  emoji: () => (hc === void 0 && (hc = RegExp("^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$", "u")), hc),
  uuid: /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/,
  ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
  ipv4Cidr: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/,
  ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,
  ipv6Cidr: /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,
  base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
  base64url: /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,
  nanoid: /^[a-zA-Z0-9_-]{21}$/,
  jwt: /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/
};
function h_(r, e) {
  const t = { type: "string" };
  if (r.checks) for (const n of r.checks) switch (n.kind) {
    case "min":
      De(t, "minLength", typeof t.minLength == "number" ? Math.max(t.minLength, n.value) : n.value, n.message, e);
      break;
    case "max":
      De(t, "maxLength", typeof t.maxLength == "number" ? Math.min(t.maxLength, n.value) : n.value, n.message, e);
      break;
    case "email":
      switch (e.emailStrategy) {
        case "format:email":
          er(t, "email", n.message, e);
          break;
        case "format:idn-email":
          er(t, "idn-email", n.message, e);
          break;
        case "pattern:zod":
          xt(t, Qt.email, n.message, e);
          break;
      }
      break;
    case "url":
      er(t, "uri", n.message, e);
      break;
    case "uuid":
      er(t, "uuid", n.message, e);
      break;
    case "regex":
      xt(t, n.regex, n.message, e);
      break;
    case "cuid":
      xt(t, Qt.cuid, n.message, e);
      break;
    case "cuid2":
      xt(t, Qt.cuid2, n.message, e);
      break;
    case "startsWith":
      xt(t, RegExp(`^${fc(n.value, e)}`), n.message, e);
      break;
    case "endsWith":
      xt(t, RegExp(`${fc(n.value, e)}$`), n.message, e);
      break;
    case "datetime":
      er(t, "date-time", n.message, e);
      break;
    case "date":
      er(t, "date", n.message, e);
      break;
    case "time":
      er(t, "time", n.message, e);
      break;
    case "duration":
      er(t, "duration", n.message, e);
      break;
    case "length":
      De(t, "minLength", typeof t.minLength == "number" ? Math.max(t.minLength, n.value) : n.value, n.message, e), De(t, "maxLength", typeof t.maxLength == "number" ? Math.min(t.maxLength, n.value) : n.value, n.message, e);
      break;
    case "includes":
      xt(t, RegExp(fc(n.value, e)), n.message, e);
      break;
    case "ip":
      n.version !== "v6" && er(t, "ipv4", n.message, e), n.version !== "v4" && er(t, "ipv6", n.message, e);
      break;
    case "base64url":
      xt(t, Qt.base64url, n.message, e);
      break;
    case "jwt":
      xt(t, Qt.jwt, n.message, e);
      break;
    case "cidr":
      n.version !== "v6" && xt(t, Qt.ipv4Cidr, n.message, e), n.version !== "v4" && xt(t, Qt.ipv6Cidr, n.message, e);
      break;
    case "emoji":
      xt(t, Qt.emoji(), n.message, e);
      break;
    case "ulid":
      xt(t, Qt.ulid, n.message, e);
      break;
    case "base64":
      switch (e.base64Strategy) {
        case "format:binary":
          er(t, "binary", n.message, e);
          break;
        case "contentEncoding:base64":
          De(t, "contentEncoding", "base64", n.message, e);
          break;
        case "pattern:zod":
          xt(t, Qt.base64, n.message, e);
          break;
      }
      break;
    case "nanoid":
      xt(t, Qt.nanoid, n.message, e);
      break;
  }
  return t;
}
function fc(r, e) {
  return e.patternStrategy === "escape" ? mk(r) : r;
}
const pk = /* @__PURE__ */ new Set("ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789");
function mk(r) {
  let e = "";
  for (let t = 0; t < r.length; t++)
    pk.has(r[t]) || (e += "\\"), e += r[t];
  return e;
}
function er(r, e, t, n) {
  var s;
  r.format || (s = r.anyOf) != null && s.some((a) => a.format) ? (r.anyOf || (r.anyOf = []), r.format && (r.anyOf.push({
    format: r.format,
    ...r.errorMessage && n.errorMessages && { errorMessage: { format: r.errorMessage.format } }
  }), delete r.format, r.errorMessage && (delete r.errorMessage.format, Object.keys(r.errorMessage).length === 0 && delete r.errorMessage)), r.anyOf.push({
    format: e,
    ...t && n.errorMessages && { errorMessage: { format: t } }
  })) : De(r, "format", e, t, n);
}
function xt(r, e, t, n) {
  var s;
  r.pattern || (s = r.allOf) != null && s.some((a) => a.pattern) ? (r.allOf || (r.allOf = []), r.pattern && (r.allOf.push({
    pattern: r.pattern,
    ...r.errorMessage && n.errorMessages && { errorMessage: { pattern: r.errorMessage.pattern } }
  }), delete r.pattern, r.errorMessage && (delete r.errorMessage.pattern, Object.keys(r.errorMessage).length === 0 && delete r.errorMessage)), r.allOf.push({
    pattern: Wh(e, n),
    ...t && n.errorMessages && { errorMessage: { pattern: t } }
  })) : De(r, "pattern", Wh(e, n), t, n);
}
function Wh(r, e) {
  var c;
  if (!e.applyRegexFlags || !r.flags) return r.source;
  const t = {
    i: r.flags.includes("i"),
    m: r.flags.includes("m"),
    s: r.flags.includes("s")
  }, n = t.i ? r.source.toLowerCase() : r.source;
  let s = "", a = !1, i = !1, o = !1;
  for (let u = 0; u < n.length; u++) {
    if (a) {
      s += n[u], a = !1;
      continue;
    }
    if (t.i) {
      if (i) {
        if (n[u].match(/[a-z]/)) {
          o ? (s += n[u], s += `${n[u - 2]}-${n[u]}`.toUpperCase(), o = !1) : n[u + 1] === "-" && ((c = n[u + 2]) != null && c.match(/[a-z]/)) ? (s += n[u], o = !0) : s += `${n[u]}${n[u].toUpperCase()}`;
          continue;
        }
      } else if (n[u].match(/[a-z]/)) {
        s += `[${n[u]}${n[u].toUpperCase()}]`;
        continue;
      }
    }
    if (t.m) {
      if (n[u] === "^") {
        s += `(^|(?<=[\r
]))`;
        continue;
      } else if (n[u] === "$") {
        s += `($|(?=[\r
]))`;
        continue;
      }
    }
    if (t.s && n[u] === ".") {
      s += i ? `${n[u]}\r
` : `[${n[u]}\r
]`;
      continue;
    }
    s += n[u], n[u] === "\\" ? a = !0 : i && n[u] === "]" ? i = !1 : !i && n[u] === "[" && (i = !0);
  }
  try {
    new RegExp(s);
  } catch {
    return console.warn(`Could not convert regex pattern at ${e.currentPath.join("/")} to a flag-independent form! Falling back to the flag-ignorant source`), r.source;
  }
  return s;
}
function f_(r, e) {
  var n, s, a, i, o, c;
  if (e.target === "openAi" && console.warn("Warning: OpenAI may not support records in schemas! Try an array of key-value pairs instead."), e.target === "openApi3" && ((n = r.keyType) == null ? void 0 : n._def.typeName) === C.ZodEnum) return {
    type: "object",
    required: r.keyType._def.values,
    properties: r.keyType._def.values.reduce((u, l) => ({
      ...u,
      [l]: Le(r.valueType._def, {
        ...e,
        currentPath: [
          ...e.currentPath,
          "properties",
          l
        ]
      }) ?? Vt(e)
    }), {}),
    additionalProperties: e.rejectedAdditionalProperties
  };
  const t = {
    type: "object",
    additionalProperties: Le(r.valueType._def, {
      ...e,
      currentPath: [...e.currentPath, "additionalProperties"]
    }) ?? e.allowedAdditionalProperties
  };
  if (e.target === "openApi3") return t;
  if (((s = r.keyType) == null ? void 0 : s._def.typeName) === C.ZodString && ((a = r.keyType._def.checks) != null && a.length)) {
    const { type: u, ...l } = h_(r.keyType._def, e);
    return {
      ...t,
      propertyNames: l
    };
  } else {
    if (((i = r.keyType) == null ? void 0 : i._def.typeName) === C.ZodEnum) return {
      ...t,
      propertyNames: { enum: r.keyType._def.values }
    };
    if (((o = r.keyType) == null ? void 0 : o._def.typeName) === C.ZodBranded && r.keyType._def.type._def.typeName === C.ZodString && ((c = r.keyType._def.type._def.checks) != null && c.length)) {
      const { type: u, ...l } = l_(r.keyType._def, e);
      return {
        ...t,
        propertyNames: l
      };
    }
  }
  return t;
}
function gk(r, e) {
  if (e.mapStrategy === "record") return f_(r, e);
  const t = Le(r.keyType._def, {
    ...e,
    currentPath: [
      ...e.currentPath,
      "items",
      "items",
      "0"
    ]
  }) || Vt(e), n = Le(r.valueType._def, {
    ...e,
    currentPath: [
      ...e.currentPath,
      "items",
      "items",
      "1"
    ]
  }) || Vt(e);
  return {
    type: "array",
    maxItems: 125,
    items: {
      type: "array",
      items: [t, n],
      minItems: 2,
      maxItems: 2
    }
  };
}
function _k(r) {
  const e = r.values, n = Object.keys(r.values).filter((a) => typeof e[e[a]] != "number").map((a) => e[a]), s = Array.from(new Set(n.map((a) => typeof a)));
  return {
    type: s.length === 1 ? s[0] === "string" ? "string" : "number" : ["string", "number"],
    enum: n
  };
}
function yk(r) {
  return r.target === "openAi" ? void 0 : { not: Vt({
    ...r,
    currentPath: [...r.currentPath, "not"]
  }) };
}
function wk(r) {
  return r.target === "openApi3" ? {
    enum: ["null"],
    nullable: !0
  } : { type: "null" };
}
const ji = {
  ZodString: "string",
  ZodNumber: "number",
  ZodBigInt: "integer",
  ZodBoolean: "boolean",
  ZodNull: "null"
};
function vk(r, e) {
  if (e.target === "openApi3") return Gh(r, e);
  const t = r.options instanceof Map ? Array.from(r.options.values()) : r.options;
  if (t.every((n) => n._def.typeName in ji && (!n._def.checks || !n._def.checks.length))) {
    const n = t.reduce((s, a) => {
      const i = ji[a._def.typeName];
      return i && !s.includes(i) ? [...s, i] : s;
    }, []);
    return { type: n.length > 1 ? n : n[0] };
  } else if (t.every((n) => n._def.typeName === "ZodLiteral" && !n.description)) {
    const n = t.reduce((s, a) => {
      const i = typeof a._def.value;
      switch (i) {
        case "string":
        case "number":
        case "boolean":
          return [...s, i];
        case "bigint":
          return [...s, "integer"];
        case "object":
          return a._def.value === null ? [...s, "null"] : s;
        case "symbol":
        case "undefined":
        case "function":
        default:
          return s;
      }
    }, []);
    if (n.length === t.length) {
      const s = n.filter((a, i, o) => o.indexOf(a) === i);
      return {
        type: s.length > 1 ? s : s[0],
        enum: t.reduce((a, i) => a.includes(i._def.value) ? a : [...a, i._def.value], [])
      };
    }
  } else if (t.every((n) => n._def.typeName === "ZodEnum")) return {
    type: "string",
    enum: t.reduce((n, s) => [...n, ...s._def.values.filter((a) => !n.includes(a))], [])
  };
  return Gh(r, e);
}
const Gh = (r, e) => {
  const t = (r.options instanceof Map ? Array.from(r.options.values()) : r.options).map((n, s) => Le(n._def, {
    ...e,
    currentPath: [
      ...e.currentPath,
      "anyOf",
      `${s}`
    ]
  })).filter((n) => !!n && (!e.strictUnions || typeof n == "object" && Object.keys(n).length > 0));
  return t.length ? { anyOf: t } : void 0;
};
function bk(r, e) {
  if ([
    "ZodString",
    "ZodNumber",
    "ZodBigInt",
    "ZodBoolean",
    "ZodNull"
  ].includes(r.innerType._def.typeName) && (!r.innerType._def.checks || !r.innerType._def.checks.length))
    return e.target === "openApi3" ? {
      type: ji[r.innerType._def.typeName],
      nullable: !0
    } : { type: [ji[r.innerType._def.typeName], "null"] };
  if (e.target === "openApi3") {
    const n = Le(r.innerType._def, {
      ...e,
      currentPath: [...e.currentPath]
    });
    return n && "$ref" in n ? {
      allOf: [n],
      nullable: !0
    } : n && {
      ...n,
      nullable: !0
    };
  }
  const t = Le(r.innerType._def, {
    ...e,
    currentPath: [
      ...e.currentPath,
      "anyOf",
      "0"
    ]
  });
  return t && { anyOf: [t, { type: "null" }] };
}
function Sk(r, e) {
  const t = { type: "number" };
  if (!r.checks) return t;
  for (const n of r.checks) switch (n.kind) {
    case "int":
      t.type = "integer", i_(t, "type", n.message, e);
      break;
    case "min":
      e.target === "jsonSchema7" ? n.inclusive ? De(t, "minimum", n.value, n.message, e) : De(t, "exclusiveMinimum", n.value, n.message, e) : (n.inclusive || (t.exclusiveMinimum = !0), De(t, "minimum", n.value, n.message, e));
      break;
    case "max":
      e.target === "jsonSchema7" ? n.inclusive ? De(t, "maximum", n.value, n.message, e) : De(t, "exclusiveMaximum", n.value, n.message, e) : (n.inclusive || (t.exclusiveMaximum = !0), De(t, "maximum", n.value, n.message, e));
      break;
    case "multipleOf":
      De(t, "multipleOf", n.value, n.message, e);
      break;
  }
  return t;
}
function Tk(r, e) {
  const t = e.target === "openAi", n = {
    type: "object",
    properties: {}
  }, s = [], a = r.shape();
  for (const o in a) {
    let c = a[o];
    if (c === void 0 || c._def === void 0) continue;
    let u = xk(c);
    u && t && (c._def.typeName === "ZodOptional" && (c = c._def.innerType), c.isNullable() || (c = c.nullable()), u = !1);
    const l = Le(c._def, {
      ...e,
      currentPath: [
        ...e.currentPath,
        "properties",
        o
      ],
      propertyPath: [
        ...e.currentPath,
        "properties",
        o
      ]
    });
    l !== void 0 && (n.properties[o] = l, u || s.push(o));
  }
  s.length && (n.required = s);
  const i = Ek(r, e);
  return i !== void 0 && (n.additionalProperties = i), n;
}
function Ek(r, e) {
  if (r.catchall._def.typeName !== "ZodNever") return Le(r.catchall._def, {
    ...e,
    currentPath: [...e.currentPath, "additionalProperties"]
  });
  switch (r.unknownKeys) {
    case "passthrough":
      return e.allowedAdditionalProperties;
    case "strict":
      return e.rejectedAdditionalProperties;
    case "strip":
      return e.removeAdditionalStrategy === "strict" ? e.allowedAdditionalProperties : e.rejectedAdditionalProperties;
  }
}
function xk(r) {
  try {
    return r.isOptional();
  } catch {
    return !0;
  }
}
const Ik = (r, e) => {
  var n;
  if (e.currentPath.toString() === ((n = e.propertyPath) == null ? void 0 : n.toString())) return Le(r.innerType._def, e);
  const t = Le(r.innerType._def, {
    ...e,
    currentPath: [
      ...e.currentPath,
      "anyOf",
      "1"
    ]
  });
  return t ? { anyOf: [{ not: Vt(e) }, t] } : Vt(e);
}, kk = (r, e) => {
  if (e.pipeStrategy === "input") return Le(r.in._def, e);
  if (e.pipeStrategy === "output") return Le(r.out._def, e);
  const t = Le(r.in._def, {
    ...e,
    currentPath: [
      ...e.currentPath,
      "allOf",
      "0"
    ]
  }), n = Le(r.out._def, {
    ...e,
    currentPath: [
      ...e.currentPath,
      "allOf",
      t ? "1" : "0"
    ]
  });
  return { allOf: [t, n].filter((s) => s !== void 0) };
};
function Ok(r, e) {
  return Le(r.type._def, e);
}
function Ak(r, e) {
  const n = {
    type: "array",
    uniqueItems: !0,
    items: Le(r.valueType._def, {
      ...e,
      currentPath: [...e.currentPath, "items"]
    })
  };
  return r.minSize && De(n, "minItems", r.minSize.value, r.minSize.message, e), r.maxSize && De(n, "maxItems", r.maxSize.value, r.maxSize.message, e), n;
}
function $k(r, e) {
  return r.rest ? {
    type: "array",
    minItems: r.items.length,
    items: r.items.map((t, n) => Le(t._def, {
      ...e,
      currentPath: [
        ...e.currentPath,
        "items",
        `${n}`
      ]
    })).reduce((t, n) => n === void 0 ? t : [...t, n], []),
    additionalItems: Le(r.rest._def, {
      ...e,
      currentPath: [...e.currentPath, "additionalItems"]
    })
  } : {
    type: "array",
    minItems: r.items.length,
    maxItems: r.items.length,
    items: r.items.map((t, n) => Le(t._def, {
      ...e,
      currentPath: [
        ...e.currentPath,
        "items",
        `${n}`
      ]
    })).reduce((t, n) => n === void 0 ? t : [...t, n], [])
  };
}
function Ck(r) {
  return { not: Vt(r) };
}
function Rk(r) {
  return Vt(r);
}
const Nk = (r, e) => Le(r.innerType._def, e), Pk = (r, e, t) => {
  switch (e) {
    case C.ZodString:
      return h_(r, t);
    case C.ZodNumber:
      return Sk(r, t);
    case C.ZodObject:
      return Tk(r, t);
    case C.ZodBigInt:
      return sk(r, t);
    case C.ZodBoolean:
      return ak();
    case C.ZodDate:
      return d_(r, t);
    case C.ZodUndefined:
      return Ck(t);
    case C.ZodNull:
      return wk(t);
    case C.ZodArray:
      return nk(r, t);
    case C.ZodUnion:
    case C.ZodDiscriminatedUnion:
      return vk(r, t);
    case C.ZodIntersection:
      return hk(r, t);
    case C.ZodTuple:
      return $k(r, t);
    case C.ZodRecord:
      return f_(r, t);
    case C.ZodLiteral:
      return fk(r, t);
    case C.ZodEnum:
      return lk(r);
    case C.ZodNativeEnum:
      return _k(r);
    case C.ZodNullable:
      return bk(r, t);
    case C.ZodOptional:
      return Ik(r, t);
    case C.ZodMap:
      return gk(r, t);
    case C.ZodSet:
      return Ak(r, t);
    case C.ZodLazy:
      return () => r.getter()._def;
    case C.ZodPromise:
      return Ok(r, t);
    case C.ZodNaN:
    case C.ZodNever:
      return yk(t);
    case C.ZodEffects:
      return uk(r, t);
    case C.ZodAny:
      return Vt(t);
    case C.ZodUnknown:
      return Rk(t);
    case C.ZodDefault:
      return ck(r, t);
    case C.ZodBranded:
      return l_(r, t);
    case C.ZodReadonly:
      return Nk(r, t);
    case C.ZodCatch:
      return ik(r, t);
    case C.ZodPipeline:
      return kk(r, t);
    case C.ZodFunction:
    case C.ZodVoid:
    case C.ZodSymbol:
      return;
    default:
      return /* @__PURE__ */ ((n) => {
      })();
  }
};
function Le(r, e, t = !1) {
  var o;
  const n = e.seen.get(r);
  if (e.override) {
    const c = (o = e.override) == null ? void 0 : o.call(e, r, e, n, t);
    if (c !== kI) return c;
  }
  if (n && !t) {
    const c = Lk(n, e);
    if (c !== void 0) return c;
  }
  const s = {
    def: r,
    path: e.currentPath,
    jsonSchema: void 0
  };
  e.seen.set(r, s);
  const a = Pk(r, r.typeName, e), i = typeof a == "function" ? Le(a(), e) : a;
  if (i && Mk(r, e, i), e.postProcess) {
    const c = e.postProcess(i, r, e);
    return s.jsonSchema = i, c;
  }
  return s.jsonSchema = i, i;
}
const Lk = (r, e) => {
  switch (e.$refStrategy) {
    case "root":
      return { $ref: r.path.join("/") };
    case "relative":
      return { $ref: a_(e.currentPath, r.path) };
    case "none":
    case "seen":
      return r.path.length < e.currentPath.length && r.path.every((t, n) => e.currentPath[n] === t) ? (console.warn(`Recursive reference detected at ${e.currentPath.join("/")}! Defaulting to any`), Vt(e)) : e.$refStrategy === "seen" ? Vt(e) : void 0;
  }
}, Mk = (r, e, t) => (r.description && (t.description = r.description, e.markdownDescription && (t.markdownDescription = r.description)), t), Dk = (r, e) => {
  const t = $I(e);
  let n;
  const s = Le(r._def, t, !1) ?? Vt(t);
  t.flags.hasReferencedOpenAiAnyType && (n || (n = {}), n[t.openAiAnyTypeName] || (n[t.openAiAnyTypeName] = {
    type: [
      "string",
      "number",
      "integer",
      "boolean",
      "array",
      "null"
    ],
    items: { $ref: t.$refStrategy === "relative" ? "1" : [
      ...t.basePath,
      t.definitionPath,
      t.openAiAnyTypeName
    ].join("/") }
  }));
  const a = n ? {
    ...s,
    [t.definitionPath]: n
  } : s;
  return t.target === "jsonSchema7" ? a.$schema = "http://json-schema.org/draft-07/schema#" : (t.target === "jsonSchema2019-09" || t.target === "openAi") && (a.$schema = "https://json-schema.org/draft/2019-09/schema#"), t.target === "openAi" && ("anyOf" in a || "oneOf" in a || "allOf" in a || "type" in a && Array.isArray(a.type)) && console.warn("Warning: OpenAI may not support schemas with unions as roots! Try wrapping it in an object property."), a;
};
function vn(r, e) {
  const t = typeof r;
  if (t !== typeof e)
    return !1;
  if (Array.isArray(r)) {
    if (!Array.isArray(e))
      return !1;
    const n = r.length;
    if (n !== e.length)
      return !1;
    for (let s = 0; s < n; s++)
      if (!vn(r[s], e[s]))
        return !1;
    return !0;
  }
  if (t === "object") {
    if (!r || !e)
      return r === e;
    const n = Object.keys(r), s = Object.keys(e);
    if (n.length !== s.length)
      return !1;
    for (const i of n)
      if (!vn(r[i], e[i]))
        return !1;
    return !0;
  }
  return r === e;
}
function ar(r) {
  return encodeURI(jk(r));
}
function jk(r) {
  return r.replace(/~/g, "~0").replace(/\//g, "~1");
}
const Fk = {
  prefixItems: !0,
  items: !0,
  allOf: !0,
  anyOf: !0,
  oneOf: !0
}, Uk = {
  $defs: !0,
  definitions: !0,
  properties: !0,
  patternProperties: !0,
  dependentSchemas: !0
}, zk = {
  id: !0,
  $id: !0,
  $ref: !0,
  $schema: !0,
  $anchor: !0,
  $vocabulary: !0,
  $comment: !0,
  default: !0,
  enum: !0,
  const: !0,
  required: !0,
  type: !0,
  maximum: !0,
  minimum: !0,
  exclusiveMaximum: !0,
  exclusiveMinimum: !0,
  multipleOf: !0,
  maxLength: !0,
  minLength: !0,
  pattern: !0,
  format: !0,
  maxItems: !0,
  minItems: !0,
  uniqueItems: !0,
  maxProperties: !0,
  minProperties: !0
};
let Bk = typeof self < "u" && self.location && self.location.origin !== "null" ? new URL(self.location.origin + self.location.pathname + location.search) : new URL("https://github.com/cfworker");
function Qr(r, e = /* @__PURE__ */ Object.create(null), t = Bk, n = "") {
  if (r && typeof r == "object" && !Array.isArray(r)) {
    const a = r.$id || r.id;
    if (a) {
      const i = new URL(a, t.href);
      i.hash.length > 1 ? e[i.href] = r : (i.hash = "", n === "" ? t = i : Qr(r, e, t));
    }
  } else if (r !== !0 && r !== !1)
    return e;
  const s = t.href + (n ? "#" + n : "");
  if (e[s] !== void 0)
    throw new Error(`Duplicate schema URI "${s}".`);
  if (e[s] = r, r === !0 || r === !1)
    return e;
  if (r.__absolute_uri__ === void 0 && Object.defineProperty(r, "__absolute_uri__", {
    enumerable: !1,
    value: s
  }), r.$ref && r.__absolute_ref__ === void 0) {
    const a = new URL(r.$ref, t.href);
    a.hash = a.hash, Object.defineProperty(r, "__absolute_ref__", {
      enumerable: !1,
      value: a.href
    });
  }
  if (r.$recursiveRef && r.__absolute_recursive_ref__ === void 0) {
    const a = new URL(r.$recursiveRef, t.href);
    a.hash = a.hash, Object.defineProperty(r, "__absolute_recursive_ref__", {
      enumerable: !1,
      value: a.href
    });
  }
  if (r.$anchor) {
    const a = new URL("#" + r.$anchor, t.href);
    e[a.href] = r;
  }
  for (let a in r) {
    if (zk[a])
      continue;
    const i = `${n}/${ar(a)}`, o = r[a];
    if (Array.isArray(o)) {
      if (Fk[a]) {
        const c = o.length;
        for (let u = 0; u < c; u++)
          Qr(o[u], e, t, `${i}/${u}`);
      }
    } else if (Uk[a])
      for (let c in o)
        Qr(o[c], e, t, `${i}/${ar(c)}`);
    else
      Qr(o, e, t, i);
  }
  return e;
}
const Zk = /^(\d\d\d\d)-(\d\d)-(\d\d)$/, Vk = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], qk = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d(?::?\d\d)?)?$/i, Hk = /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i, Jk = /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i, Wk = /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i, Gk = /^(?:(?:https?|ftp):\/\/)(?:\S+(?::\S*)?@)?(?:(?!10(?:\.\d{1,3}){3})(?!127(?:\.\d{1,3}){3})(?!169\.254(?:\.\d{1,3}){2})(?!192\.168(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z\u{00a1}-\u{ffff}0-9]+-?)*[a-z\u{00a1}-\u{ffff}0-9]+)(?:\.(?:[a-z\u{00a1}-\u{ffff}0-9]+-?)*[a-z\u{00a1}-\u{ffff}0-9]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu, Kk = /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i, Yk = /^(?:\/(?:[^~/]|~0|~1)*)*$/, Xk = /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i, Qk = /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/, eO = (r) => {
  if (r[0] === '"')
    return !1;
  const [e, t, ...n] = r.split("@");
  return !e || !t || n.length !== 0 || e.length > 64 || t.length > 253 || e[0] === "." || e.endsWith(".") || e.includes("..") || !/^[a-z0-9.-]+$/i.test(t) || !/^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+$/i.test(e) ? !1 : t.split(".").every((s) => /^[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?$/i.test(s));
}, tO = /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/, rO = /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i, nO = (r) => r.length > 1 && r.length < 80 && (/^P\d+([.,]\d+)?W$/.test(r) || /^P[\dYMDTHS]*(\d[.,]\d+)?[YMDHS]$/.test(r) && /^P([.,\d]+Y)?([.,\d]+M)?([.,\d]+D)?(T([.,\d]+H)?([.,\d]+M)?([.,\d]+S)?)?$/.test(r));
function gr(r) {
  return r.test.bind(r);
}
const Kh = {
  date: p_,
  time: m_.bind(void 0, !1),
  "date-time": iO,
  duration: nO,
  uri: uO,
  "uri-reference": gr(Jk),
  "uri-template": gr(Wk),
  url: gr(Gk),
  email: eO,
  hostname: gr(Hk),
  ipv4: gr(tO),
  ipv6: gr(rO),
  regex: dO,
  uuid: gr(Kk),
  "json-pointer": gr(Yk),
  "json-pointer-uri-fragment": gr(Xk),
  "relative-json-pointer": gr(Qk)
};
function sO(r) {
  return r % 4 === 0 && (r % 100 !== 0 || r % 400 === 0);
}
function p_(r) {
  const e = r.match(Zk);
  if (!e)
    return !1;
  const t = +e[1], n = +e[2], s = +e[3];
  return n >= 1 && n <= 12 && s >= 1 && s <= (n == 2 && sO(t) ? 29 : Vk[n]);
}
function m_(r, e) {
  const t = e.match(qk);
  if (!t)
    return !1;
  const n = +t[1], s = +t[2], a = +t[3], i = !!t[5];
  return (n <= 23 && s <= 59 && a <= 59 || n == 23 && s == 59 && a == 60) && (!r || i);
}
const aO = /t|\s/i;
function iO(r) {
  const e = r.split(aO);
  return e.length == 2 && p_(e[0]) && m_(!0, e[1]);
}
const oO = /\/|:/, cO = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
function uO(r) {
  return oO.test(r) && cO.test(r);
}
const lO = /[^\\]\\Z/;
function dO(r) {
  if (lO.test(r))
    return !1;
  try {
    return new RegExp(r, "u"), !0;
  } catch {
    return !1;
  }
}
function hO(r) {
  let e = 0, t = r.length, n = 0, s;
  for (; n < t; )
    e++, s = r.charCodeAt(n++), s >= 55296 && s <= 56319 && n < t && (s = r.charCodeAt(n), (s & 64512) == 56320 && n++);
  return e;
}
function Ze(r, e, t = "2019-09", n = Qr(e), s = !0, a = null, i = "#", o = "#", c = /* @__PURE__ */ Object.create(null)) {
  if (e === !0)
    return { valid: !0, errors: [] };
  if (e === !1)
    return {
      valid: !1,
      errors: [
        {
          instanceLocation: i,
          keyword: "false",
          keywordLocation: i,
          error: "False boolean schema."
        }
      ]
    };
  const u = typeof r;
  let l;
  switch (u) {
    case "boolean":
    case "number":
    case "string":
      l = u;
      break;
    case "object":
      r === null ? l = "null" : Array.isArray(r) ? l = "array" : l = "object";
      break;
    default:
      throw new Error(`Instances of "${u}" type are not supported.`);
  }
  const { $ref: d, $recursiveRef: h, $recursiveAnchor: f, type: p, const: y, enum: g, required: S, not: _, anyOf: w, allOf: T, oneOf: x, if: A, then: R, else: E, format: V, properties: ne, patternProperties: z, additionalProperties: Se, unevaluatedProperties: Oe, minProperties: Z, maxProperties: D, propertyNames: U, dependentRequired: O, dependentSchemas: P, dependencies: N, prefixItems: j, items: M, additionalItems: q, unevaluatedItems: se, contains: Te, minContains: ae, maxContains: b, minItems: m, maxItems: $, uniqueItems: I, minimum: de, maximum: me, exclusiveMinimum: Me, exclusiveMaximum: Ue, multipleOf: at, minLength: Yt, maxLength: Je, pattern: Ht, __absolute_ref__: $n, __absolute_recursive_ref__: wa } = e, J = [];
  if (f === !0 && a === null && (a = e), h === "#") {
    const fe = a === null ? n[wa] : a, oe = `${o}/$recursiveRef`, _e = Ze(r, a === null ? e : a, t, n, s, fe, i, oe, c);
    _e.valid || J.push({
      instanceLocation: i,
      keyword: "$recursiveRef",
      keywordLocation: oe,
      error: "A subschema had errors."
    }, ..._e.errors);
  }
  if (d !== void 0) {
    const oe = n[$n || d];
    if (oe === void 0) {
      let H = `Unresolved $ref "${d}".`;
      throw $n && $n !== d && (H += `  Absolute URI "${$n}".`), H += `
Known schemas:
- ${Object.keys(n).join(`
- `)}`, new Error(H);
    }
    const _e = `${o}/$ref`, X = Ze(r, oe, t, n, s, a, i, _e, c);
    if (X.valid || J.push({
      instanceLocation: i,
      keyword: "$ref",
      keywordLocation: _e,
      error: "A subschema had errors."
    }, ...X.errors), t === "4" || t === "7")
      return { valid: J.length === 0, errors: J };
  }
  if (Array.isArray(p)) {
    let fe = p.length, oe = !1;
    for (let _e = 0; _e < fe; _e++)
      if (l === p[_e] || p[_e] === "integer" && l === "number" && r % 1 === 0 && r === r) {
        oe = !0;
        break;
      }
    oe || J.push({
      instanceLocation: i,
      keyword: "type",
      keywordLocation: `${o}/type`,
      error: `Instance type "${l}" is invalid. Expected "${p.join('", "')}".`
    });
  } else p === "integer" ? (l !== "number" || r % 1 || r !== r) && J.push({
    instanceLocation: i,
    keyword: "type",
    keywordLocation: `${o}/type`,
    error: `Instance type "${l}" is invalid. Expected "${p}".`
  }) : p !== void 0 && l !== p && J.push({
    instanceLocation: i,
    keyword: "type",
    keywordLocation: `${o}/type`,
    error: `Instance type "${l}" is invalid. Expected "${p}".`
  });
  if (y !== void 0 && (l === "object" || l === "array" ? vn(r, y) || J.push({
    instanceLocation: i,
    keyword: "const",
    keywordLocation: `${o}/const`,
    error: `Instance does not match ${JSON.stringify(y)}.`
  }) : r !== y && J.push({
    instanceLocation: i,
    keyword: "const",
    keywordLocation: `${o}/const`,
    error: `Instance does not match ${JSON.stringify(y)}.`
  })), g !== void 0 && (l === "object" || l === "array" ? g.some((fe) => vn(r, fe)) || J.push({
    instanceLocation: i,
    keyword: "enum",
    keywordLocation: `${o}/enum`,
    error: `Instance does not match any of ${JSON.stringify(g)}.`
  }) : g.some((fe) => r === fe) || J.push({
    instanceLocation: i,
    keyword: "enum",
    keywordLocation: `${o}/enum`,
    error: `Instance does not match any of ${JSON.stringify(g)}.`
  })), _ !== void 0) {
    const fe = `${o}/not`;
    Ze(r, _, t, n, s, a, i, fe).valid && J.push({
      instanceLocation: i,
      keyword: "not",
      keywordLocation: fe,
      error: 'Instance matched "not" schema.'
    });
  }
  let un = [];
  if (w !== void 0) {
    const fe = `${o}/anyOf`, oe = J.length;
    let _e = !1;
    for (let X = 0; X < w.length; X++) {
      const H = w[X], ge = Object.create(c), pe = Ze(r, H, t, n, s, f === !0 ? a : null, i, `${fe}/${X}`, ge);
      J.push(...pe.errors), _e = _e || pe.valid, pe.valid && un.push(ge);
    }
    _e ? J.length = oe : J.splice(oe, 0, {
      instanceLocation: i,
      keyword: "anyOf",
      keywordLocation: fe,
      error: "Instance does not match any subschemas."
    });
  }
  if (T !== void 0) {
    const fe = `${o}/allOf`, oe = J.length;
    let _e = !0;
    for (let X = 0; X < T.length; X++) {
      const H = T[X], ge = Object.create(c), pe = Ze(r, H, t, n, s, f === !0 ? a : null, i, `${fe}/${X}`, ge);
      J.push(...pe.errors), _e = _e && pe.valid, pe.valid && un.push(ge);
    }
    _e ? J.length = oe : J.splice(oe, 0, {
      instanceLocation: i,
      keyword: "allOf",
      keywordLocation: fe,
      error: "Instance does not match every subschema."
    });
  }
  if (x !== void 0) {
    const fe = `${o}/oneOf`, oe = J.length, _e = x.filter((X, H) => {
      const ge = Object.create(c), pe = Ze(r, X, t, n, s, f === !0 ? a : null, i, `${fe}/${H}`, ge);
      return J.push(...pe.errors), pe.valid && un.push(ge), pe.valid;
    }).length;
    _e === 1 ? J.length = oe : J.splice(oe, 0, {
      instanceLocation: i,
      keyword: "oneOf",
      keywordLocation: fe,
      error: `Instance does not match exactly one subschema (${_e} matches).`
    });
  }
  if ((l === "object" || l === "array") && Object.assign(c, ...un), A !== void 0) {
    const fe = `${o}/if`;
    if (Ze(r, A, t, n, s, a, i, fe, c).valid) {
      if (R !== void 0) {
        const _e = Ze(r, R, t, n, s, a, i, `${o}/then`, c);
        _e.valid || J.push({
          instanceLocation: i,
          keyword: "if",
          keywordLocation: fe,
          error: 'Instance does not match "then" schema.'
        }, ..._e.errors);
      }
    } else if (E !== void 0) {
      const _e = Ze(r, E, t, n, s, a, i, `${o}/else`, c);
      _e.valid || J.push({
        instanceLocation: i,
        keyword: "if",
        keywordLocation: fe,
        error: 'Instance does not match "else" schema.'
      }, ..._e.errors);
    }
  }
  if (l === "object") {
    if (S !== void 0)
      for (const X of S)
        X in r || J.push({
          instanceLocation: i,
          keyword: "required",
          keywordLocation: `${o}/required`,
          error: `Instance does not have required property "${X}".`
        });
    const fe = Object.keys(r);
    if (Z !== void 0 && fe.length < Z && J.push({
      instanceLocation: i,
      keyword: "minProperties",
      keywordLocation: `${o}/minProperties`,
      error: `Instance does not have at least ${Z} properties.`
    }), D !== void 0 && fe.length > D && J.push({
      instanceLocation: i,
      keyword: "maxProperties",
      keywordLocation: `${o}/maxProperties`,
      error: `Instance does not have at least ${D} properties.`
    }), U !== void 0) {
      const X = `${o}/propertyNames`;
      for (const H in r) {
        const ge = `${i}/${ar(H)}`, pe = Ze(H, U, t, n, s, a, ge, X);
        pe.valid || J.push({
          instanceLocation: i,
          keyword: "propertyNames",
          keywordLocation: X,
          error: `Property name "${H}" does not match schema.`
        }, ...pe.errors);
      }
    }
    if (O !== void 0) {
      const X = `${o}/dependantRequired`;
      for (const H in O)
        if (H in r) {
          const ge = O[H];
          for (const pe of ge)
            pe in r || J.push({
              instanceLocation: i,
              keyword: "dependentRequired",
              keywordLocation: X,
              error: `Instance has "${H}" but does not have "${pe}".`
            });
        }
    }
    if (P !== void 0)
      for (const X in P) {
        const H = `${o}/dependentSchemas`;
        if (X in r) {
          const ge = Ze(r, P[X], t, n, s, a, i, `${H}/${ar(X)}`, c);
          ge.valid || J.push({
            instanceLocation: i,
            keyword: "dependentSchemas",
            keywordLocation: H,
            error: `Instance has "${X}" but does not match dependant schema.`
          }, ...ge.errors);
        }
      }
    if (N !== void 0) {
      const X = `${o}/dependencies`;
      for (const H in N)
        if (H in r) {
          const ge = N[H];
          if (Array.isArray(ge))
            for (const pe of ge)
              pe in r || J.push({
                instanceLocation: i,
                keyword: "dependencies",
                keywordLocation: X,
                error: `Instance has "${H}" but does not have "${pe}".`
              });
          else {
            const pe = Ze(r, ge, t, n, s, a, i, `${X}/${ar(H)}`);
            pe.valid || J.push({
              instanceLocation: i,
              keyword: "dependencies",
              keywordLocation: X,
              error: `Instance has "${H}" but does not match dependant schema.`
            }, ...pe.errors);
          }
        }
    }
    const oe = /* @__PURE__ */ Object.create(null);
    let _e = !1;
    if (ne !== void 0) {
      const X = `${o}/properties`;
      for (const H in ne) {
        if (!(H in r))
          continue;
        const ge = `${i}/${ar(H)}`, pe = Ze(r[H], ne[H], t, n, s, a, ge, `${X}/${ar(H)}`);
        if (pe.valid)
          c[H] = oe[H] = !0;
        else if (_e = s, J.push({
          instanceLocation: i,
          keyword: "properties",
          keywordLocation: X,
          error: `Property "${H}" does not match schema.`
        }, ...pe.errors), _e)
          break;
      }
    }
    if (!_e && z !== void 0) {
      const X = `${o}/patternProperties`;
      for (const H in z) {
        const ge = new RegExp(H, "u"), pe = z[H];
        for (const At in r) {
          if (!ge.test(At))
            continue;
          const Hl = `${i}/${ar(At)}`, Jl = Ze(r[At], pe, t, n, s, a, Hl, `${X}/${ar(H)}`);
          Jl.valid ? c[At] = oe[At] = !0 : (_e = s, J.push({
            instanceLocation: i,
            keyword: "patternProperties",
            keywordLocation: X,
            error: `Property "${At}" matches pattern "${H}" but does not match associated schema.`
          }, ...Jl.errors));
        }
      }
    }
    if (!_e && Se !== void 0) {
      const X = `${o}/additionalProperties`;
      for (const H in r) {
        if (oe[H])
          continue;
        const ge = `${i}/${ar(H)}`, pe = Ze(r[H], Se, t, n, s, a, ge, X);
        pe.valid ? c[H] = !0 : (_e = s, J.push({
          instanceLocation: i,
          keyword: "additionalProperties",
          keywordLocation: X,
          error: `Property "${H}" does not match additional properties schema.`
        }, ...pe.errors));
      }
    } else if (!_e && Oe !== void 0) {
      const X = `${o}/unevaluatedProperties`;
      for (const H in r)
        if (!c[H]) {
          const ge = `${i}/${ar(H)}`, pe = Ze(r[H], Oe, t, n, s, a, ge, X);
          pe.valid ? c[H] = !0 : J.push({
            instanceLocation: i,
            keyword: "unevaluatedProperties",
            keywordLocation: X,
            error: `Property "${H}" does not match unevaluated properties schema.`
          }, ...pe.errors);
        }
    }
  } else if (l === "array") {
    $ !== void 0 && r.length > $ && J.push({
      instanceLocation: i,
      keyword: "maxItems",
      keywordLocation: `${o}/maxItems`,
      error: `Array has too many items (${r.length} > ${$}).`
    }), m !== void 0 && r.length < m && J.push({
      instanceLocation: i,
      keyword: "minItems",
      keywordLocation: `${o}/minItems`,
      error: `Array has too few items (${r.length} < ${m}).`
    });
    const fe = r.length;
    let oe = 0, _e = !1;
    if (j !== void 0) {
      const X = `${o}/prefixItems`, H = Math.min(j.length, fe);
      for (; oe < H; oe++) {
        const ge = Ze(r[oe], j[oe], t, n, s, a, `${i}/${oe}`, `${X}/${oe}`);
        if (c[oe] = !0, !ge.valid && (_e = s, J.push({
          instanceLocation: i,
          keyword: "prefixItems",
          keywordLocation: X,
          error: "Items did not match schema."
        }, ...ge.errors), _e))
          break;
      }
    }
    if (M !== void 0) {
      const X = `${o}/items`;
      if (Array.isArray(M)) {
        const H = Math.min(M.length, fe);
        for (; oe < H; oe++) {
          const ge = Ze(r[oe], M[oe], t, n, s, a, `${i}/${oe}`, `${X}/${oe}`);
          if (c[oe] = !0, !ge.valid && (_e = s, J.push({
            instanceLocation: i,
            keyword: "items",
            keywordLocation: X,
            error: "Items did not match schema."
          }, ...ge.errors), _e))
            break;
        }
      } else
        for (; oe < fe; oe++) {
          const H = Ze(r[oe], M, t, n, s, a, `${i}/${oe}`, X);
          if (c[oe] = !0, !H.valid && (_e = s, J.push({
            instanceLocation: i,
            keyword: "items",
            keywordLocation: X,
            error: "Items did not match schema."
          }, ...H.errors), _e))
            break;
        }
      if (!_e && q !== void 0) {
        const H = `${o}/additionalItems`;
        for (; oe < fe; oe++) {
          const ge = Ze(r[oe], q, t, n, s, a, `${i}/${oe}`, H);
          c[oe] = !0, ge.valid || (_e = s, J.push({
            instanceLocation: i,
            keyword: "additionalItems",
            keywordLocation: H,
            error: "Items did not match additional items schema."
          }, ...ge.errors));
        }
      }
    }
    if (Te !== void 0)
      if (fe === 0 && ae === void 0)
        J.push({
          instanceLocation: i,
          keyword: "contains",
          keywordLocation: `${o}/contains`,
          error: "Array is empty. It must contain at least one item matching the schema."
        });
      else if (ae !== void 0 && fe < ae)
        J.push({
          instanceLocation: i,
          keyword: "minContains",
          keywordLocation: `${o}/minContains`,
          error: `Array has less items (${fe}) than minContains (${ae}).`
        });
      else {
        const X = `${o}/contains`, H = J.length;
        let ge = 0;
        for (let pe = 0; pe < fe; pe++) {
          const At = Ze(r[pe], Te, t, n, s, a, `${i}/${pe}`, X);
          At.valid ? (c[pe] = !0, ge++) : J.push(...At.errors);
        }
        ge >= (ae || 0) && (J.length = H), ae === void 0 && b === void 0 && ge === 0 ? J.splice(H, 0, {
          instanceLocation: i,
          keyword: "contains",
          keywordLocation: X,
          error: "Array does not contain item matching schema."
        }) : ae !== void 0 && ge < ae ? J.push({
          instanceLocation: i,
          keyword: "minContains",
          keywordLocation: `${o}/minContains`,
          error: `Array must contain at least ${ae} items matching schema. Only ${ge} items were found.`
        }) : b !== void 0 && ge > b && J.push({
          instanceLocation: i,
          keyword: "maxContains",
          keywordLocation: `${o}/maxContains`,
          error: `Array may contain at most ${b} items matching schema. ${ge} items were found.`
        });
      }
    if (!_e && se !== void 0) {
      const X = `${o}/unevaluatedItems`;
      for (oe; oe < fe; oe++) {
        if (c[oe])
          continue;
        const H = Ze(r[oe], se, t, n, s, a, `${i}/${oe}`, X);
        c[oe] = !0, H.valid || J.push({
          instanceLocation: i,
          keyword: "unevaluatedItems",
          keywordLocation: X,
          error: "Items did not match unevaluated items schema."
        }, ...H.errors);
      }
    }
    if (I)
      for (let X = 0; X < fe; X++) {
        const H = r[X], ge = typeof H == "object" && H !== null;
        for (let pe = 0; pe < fe; pe++) {
          if (X === pe)
            continue;
          const At = r[pe];
          (H === At || ge && (typeof At == "object" && At !== null) && vn(H, At)) && (J.push({
            instanceLocation: i,
            keyword: "uniqueItems",
            keywordLocation: `${o}/uniqueItems`,
            error: `Duplicate items at indexes ${X} and ${pe}.`
          }), X = Number.MAX_SAFE_INTEGER, pe = Number.MAX_SAFE_INTEGER);
        }
      }
  } else if (l === "number") {
    if (t === "4" ? (de !== void 0 && (Me === !0 && r <= de || r < de) && J.push({
      instanceLocation: i,
      keyword: "minimum",
      keywordLocation: `${o}/minimum`,
      error: `${r} is less than ${Me ? "or equal to " : ""} ${de}.`
    }), me !== void 0 && (Ue === !0 && r >= me || r > me) && J.push({
      instanceLocation: i,
      keyword: "maximum",
      keywordLocation: `${o}/maximum`,
      error: `${r} is greater than ${Ue ? "or equal to " : ""} ${me}.`
    })) : (de !== void 0 && r < de && J.push({
      instanceLocation: i,
      keyword: "minimum",
      keywordLocation: `${o}/minimum`,
      error: `${r} is less than ${de}.`
    }), me !== void 0 && r > me && J.push({
      instanceLocation: i,
      keyword: "maximum",
      keywordLocation: `${o}/maximum`,
      error: `${r} is greater than ${me}.`
    }), Me !== void 0 && r <= Me && J.push({
      instanceLocation: i,
      keyword: "exclusiveMinimum",
      keywordLocation: `${o}/exclusiveMinimum`,
      error: `${r} is less than ${Me}.`
    }), Ue !== void 0 && r >= Ue && J.push({
      instanceLocation: i,
      keyword: "exclusiveMaximum",
      keywordLocation: `${o}/exclusiveMaximum`,
      error: `${r} is greater than or equal to ${Ue}.`
    })), at !== void 0) {
      const fe = r % at;
      Math.abs(0 - fe) >= 11920929e-14 && Math.abs(at - fe) >= 11920929e-14 && J.push({
        instanceLocation: i,
        keyword: "multipleOf",
        keywordLocation: `${o}/multipleOf`,
        error: `${r} is not a multiple of ${at}.`
      });
    }
  } else if (l === "string") {
    const fe = Yt === void 0 && Je === void 0 ? 0 : hO(r);
    Yt !== void 0 && fe < Yt && J.push({
      instanceLocation: i,
      keyword: "minLength",
      keywordLocation: `${o}/minLength`,
      error: `String is too short (${fe} < ${Yt}).`
    }), Je !== void 0 && fe > Je && J.push({
      instanceLocation: i,
      keyword: "maxLength",
      keywordLocation: `${o}/maxLength`,
      error: `String is too long (${fe} > ${Je}).`
    }), Ht !== void 0 && !new RegExp(Ht, "u").test(r) && J.push({
      instanceLocation: i,
      keyword: "pattern",
      keywordLocation: `${o}/pattern`,
      error: "String does not match pattern."
    }), V !== void 0 && Kh[V] && !Kh[V](r) && J.push({
      instanceLocation: i,
      keyword: "format",
      keywordLocation: `${o}/format`,
      error: `String does not match format "${V}".`
    });
  }
  return { valid: J.length === 0, errors: J };
}
class fO {
  constructor(e, t = "2019-09", n = !0) {
    v(this, "schema");
    v(this, "draft");
    v(this, "shortCircuit");
    v(this, "lookup");
    this.schema = e, this.draft = t, this.shortCircuit = n, this.lookup = Qr(e);
  }
  validate(e) {
    return Ze(e, this.schema, this.draft, this.lookup, this.shortCircuit);
  }
  addSchema(e, t) {
    t && (e = { ...e, $id: t }), Qr(e, this.lookup);
  }
}
var pO = {};
Ae(pO, {
  Validator: () => fO,
  deepCompareStrict: () => vn,
  toJsonSchema: () => Sr,
  validatesOnlyStrings: () => Fs
});
function Sr(r) {
  if (qe(r)) {
    const e = n_(r, !0);
    if (xr(e)) {
      const t = Ri(e, !0);
      return Ci(t);
    } else return Ci(r);
  }
  return nt(r) ? Dk(r) : r;
}
function Fs(r) {
  if (!r || typeof r != "object" || Object.keys(r).length === 0 || Array.isArray(r)) return !1;
  if ("type" in r)
    return typeof r.type == "string" ? r.type === "string" : Array.isArray(r.type) ? r.type.every((e) => e === "string") : !1;
  if ("enum" in r) return Array.isArray(r.enum) && r.enum.length > 0 && r.enum.every((e) => typeof e == "string");
  if ("const" in r) return typeof r.const == "string";
  if ("allOf" in r && Array.isArray(r.allOf)) return r.allOf.some((e) => Fs(e));
  if ("anyOf" in r && Array.isArray(r.anyOf) || "oneOf" in r && Array.isArray(r.oneOf)) {
    const e = "anyOf" in r ? r.anyOf : r.oneOf;
    return e.length > 0 && e.every((t) => Fs(t));
  }
  if ("not" in r) return !1;
  if ("$ref" in r && typeof r.$ref == "string") {
    const e = r.$ref, t = Qr(r);
    return t[e] ? Fs(t[e]) : !1;
  }
  return !1;
}
var mO = {};
Ae(mO, { Graph: () => Cl });
function gO(r, e) {
  if (r !== void 0 && !ii(r)) return r;
  if (vl(e)) try {
    let t = e.getName();
    return t = t.startsWith("Runnable") ? t.slice(8) : t, t;
  } catch {
    return e.getName();
  }
  else return e.name ?? "UnknownSchema";
}
function _O(r) {
  return vl(r.data) ? {
    type: "runnable",
    data: {
      id: r.data.lc_id,
      name: r.data.getName()
    }
  } : {
    type: "schema",
    data: {
      ...Sr(r.data.schema),
      title: r.data.name
    }
  };
}
var Cl = class g_ {
  constructor(e) {
    v(this, "nodes", {});
    v(this, "edges", []);
    this.nodes = (e == null ? void 0 : e.nodes) ?? this.nodes, this.edges = (e == null ? void 0 : e.edges) ?? this.edges;
  }
  toJSON() {
    const e = {};
    return Object.values(this.nodes).forEach((t, n) => {
      e[t.id] = ii(t.id) ? n : t.id;
    }), {
      nodes: Object.values(this.nodes).map((t) => ({
        id: e[t.id],
        ..._O(t)
      })),
      edges: this.edges.map((t) => {
        const n = {
          source: e[t.source],
          target: e[t.target]
        };
        return typeof t.data < "u" && (n.data = t.data), typeof t.conditional < "u" && (n.conditional = t.conditional), n;
      })
    };
  }
  addNode(e, t, n) {
    if (t !== void 0 && this.nodes[t] !== void 0) throw new Error(`Node with id ${t} already exists`);
    const s = t ?? Lr(), a = {
      id: s,
      data: e,
      name: gO(t, e),
      metadata: n
    };
    return this.nodes[s] = a, a;
  }
  removeNode(e) {
    delete this.nodes[e.id], this.edges = this.edges.filter((t) => t.source !== e.id && t.target !== e.id);
  }
  addEdge(e, t, n, s) {
    if (this.nodes[e.id] === void 0) throw new Error(`Source node ${e.id} not in graph`);
    if (this.nodes[t.id] === void 0) throw new Error(`Target node ${t.id} not in graph`);
    const a = {
      source: e.id,
      target: t.id,
      data: n,
      conditional: s
    };
    return this.edges.push(a), a;
  }
  firstNode() {
    return Yh(this);
  }
  lastNode() {
    return Xh(this);
  }
  /**
  * Add all nodes and edges from another graph.
  * Note this doesn't check for duplicates, nor does it connect the graphs.
  */
  extend(e, t = "") {
    let n = t;
    Object.values(e.nodes).map((u) => u.id).every(ii) && (n = "");
    const a = (u) => n ? `${n}:${u}` : u;
    Object.entries(e.nodes).forEach(([u, l]) => {
      this.nodes[a(u)] = {
        ...l,
        id: a(u)
      };
    });
    const i = e.edges.map((u) => ({
      ...u,
      source: a(u.source),
      target: a(u.target)
    }));
    this.edges = [...this.edges, ...i];
    const o = e.firstNode(), c = e.lastNode();
    return [o ? {
      id: a(o.id),
      data: o.data
    } : void 0, c ? {
      id: a(c.id),
      data: c.data
    } : void 0];
  }
  trimFirstNode() {
    const e = this.firstNode();
    e && Yh(this, [e.id]) && this.removeNode(e);
  }
  trimLastNode() {
    const e = this.lastNode();
    e && Xh(this, [e.id]) && this.removeNode(e);
  }
  /**
  * Return a new graph with all nodes re-identified,
  * using their unique, readable names where possible.
  */
  reid() {
    const e = Object.fromEntries(Object.values(this.nodes).map((s) => [s.id, s.name])), t = /* @__PURE__ */ new Map();
    Object.values(e).forEach((s) => {
      t.set(s, (t.get(s) || 0) + 1);
    });
    const n = (s) => {
      const a = e[s];
      return ii(s) && t.get(a) === 1 ? a : s;
    };
    return new g_({
      nodes: Object.fromEntries(Object.entries(this.nodes).map(([s, a]) => [n(s), {
        ...a,
        id: n(s)
      }])),
      edges: this.edges.map((s) => ({
        ...s,
        source: n(s.source),
        target: n(s.target)
      }))
    });
  }
  drawMermaid(e) {
    const { withStyles: t, curveStyle: n, nodeColors: s = {
      default: "fill:#f2f0ff,line-height:1.2",
      first: "fill-opacity:0",
      last: "fill:#bfb6fc"
    }, wrapLabelNWords: a } = e ?? {}, i = this.reid(), o = i.firstNode(), c = i.lastNode();
    return xI(i.nodes, i.edges, {
      firstNode: o == null ? void 0 : o.id,
      lastNode: c == null ? void 0 : c.id,
      withStyles: t,
      curveStyle: n,
      nodeColors: s,
      wrapLabelNWords: a
    });
  }
  async drawMermaidPng(e) {
    const t = this.drawMermaid(e);
    return II(t, { backgroundColor: e == null ? void 0 : e.backgroundColor });
  }
};
function Yh(r, e = []) {
  const t = new Set(r.edges.filter((s) => !e.includes(s.source)).map((s) => s.target)), n = [];
  for (const s of Object.values(r.nodes)) !e.includes(s.id) && !t.has(s.id) && n.push(s);
  return n.length === 1 ? n[0] : void 0;
}
function Xh(r, e = []) {
  const t = new Set(r.edges.filter((s) => !e.includes(s.target)).map((s) => s.source)), n = [];
  for (const s of Object.values(r.nodes)) !e.includes(s.id) && !t.has(s.id) && n.push(s);
  return n.length === 1 ? n[0] : void 0;
}
function yO(r) {
  const e = new TextEncoder(), t = new ReadableStream({ async start(n) {
    for await (const s of r) n.enqueue(e.encode(`event: data
data: ${JSON.stringify(s)}

`));
    n.enqueue(e.encode(`event: end

`)), n.close();
  } });
  return dr.fromReadableStream(t);
}
function Qh(r) {
  return typeof r == "object" && r !== null && typeof r[Symbol.iterator] == "function" && typeof r.next == "function";
}
const wO = (r) => r != null && typeof r == "object" && "next" in r && typeof r.next == "function";
function uu(r) {
  return typeof r == "object" && r !== null && typeof r[Symbol.asyncIterator] == "function";
}
function* ef(r, e) {
  for (; ; ) {
    const { value: t, done: n } = lr.runWithConfig(Ur(r), e.next.bind(e), !0);
    if (n) break;
    yield t;
  }
}
async function* lu(r, e) {
  const t = e[Symbol.asyncIterator]();
  for (; ; ) {
    const { value: n, done: s } = await lr.runWithConfig(Ur(r), t.next.bind(e), !0);
    if (s) break;
    yield n;
  }
}
function ut(r, e) {
  return r && !Array.isArray(r) && !(r instanceof Date) && typeof r == "object" ? r : { [e]: r };
}
var Ye = class extends Kn {
  constructor() {
    super(...arguments);
    v(this, "lc_runnable", !0);
    v(this, "name");
  }
  getName(e) {
    const t = this.name ?? this.constructor.lc_name() ?? this.constructor.name;
    return e ? `${t}${e}` : t;
  }
  /**
  * Add retry logic to an existing runnable.
  * @param fields.stopAfterAttempt The number of attempts to retry.
  * @param fields.onFailedAttempt A function that is called when a retry fails.
  * @returns A new RunnableRetry that, when invoked, will retry according to the parameters.
  */
  withRetry(e) {
    return new Rl({
      bound: this,
      kwargs: {},
      config: {},
      maxAttemptNumber: e == null ? void 0 : e.stopAfterAttempt,
      ...e
    });
  }
  /**
  * Bind config to a Runnable, returning a new Runnable.
  * @param config New configuration parameters to attach to the new runnable.
  * @returns A new RunnableBinding with a config matching what's passed.
  */
  withConfig(e) {
    return new ss({
      bound: this,
      config: e,
      kwargs: {}
    });
  }
  /**
  * Create a new runnable from the current one that will try invoking
  * other passed fallback runnables if the initial invocation fails.
  * @param fields.fallbacks Other runnables to call if the runnable errors.
  * @returns A new RunnableWithFallbacks.
  */
  withFallbacks(e) {
    const t = Array.isArray(e) ? e : e.fallbacks;
    return new S_({
      runnable: this,
      fallbacks: t
    });
  }
  _getOptionsList(e, t = 0) {
    if (Array.isArray(e) && e.length !== t) throw new Error(`Passed "options" must be an array with the same length as the inputs, but got ${e.length} options for ${t} inputs`);
    if (Array.isArray(e)) return e.map(Ce);
    if (t > 1 && !Array.isArray(e) && e.runId) {
      console.warn("Provided runId will be used only for the first element of the batch.");
      const n = Object.fromEntries(Object.entries(e).filter(([s]) => s !== "runId"));
      return Array.from({ length: t }, (s, a) => Ce(a === 0 ? e : n));
    }
    return Array.from({ length: t }, () => Ce(e));
  }
  async batch(e, t, n) {
    var c;
    const s = this._getOptionsList(t ?? {}, e.length), a = ((c = s[0]) == null ? void 0 : c.maxConcurrency) ?? (n == null ? void 0 : n.maxConcurrency), i = new fa({
      maxConcurrency: a,
      onFailedAttempt: (u) => {
        throw u;
      }
    }), o = e.map((u, l) => i.call(async () => {
      try {
        return await this.invoke(u, s[l]);
      } catch (d) {
        if (n != null && n.returnExceptions) return d;
        throw d;
      }
    }));
    return Promise.all(o);
  }
  /**
  * Default streaming implementation.
  * Subclasses should override this method if they support streaming output.
  * @param input
  * @param options
  */
  async *_streamIterator(e, t) {
    yield this.invoke(e, t);
  }
  /**
  * Stream output in chunks.
  * @param input
  * @param options
  * @returns A readable stream that is also an iterable.
  */
  async stream(e, t) {
    const n = Ce(t), s = new kn({
      generator: this._streamIterator(e, n),
      config: n
    });
    return await s.setup, dr.fromAsyncGenerator(s);
  }
  _separateRunnableConfigFromCallOptions(e) {
    let t;
    e === void 0 ? t = Ce(e) : t = Ce({
      callbacks: e.callbacks,
      tags: e.tags,
      metadata: e.metadata,
      runName: e.runName,
      configurable: e.configurable,
      recursionLimit: e.recursionLimit,
      maxConcurrency: e.maxConcurrency,
      runId: e.runId,
      timeout: e.timeout,
      signal: e.signal
    });
    const n = { ...e };
    return delete n.callbacks, delete n.tags, delete n.metadata, delete n.runName, delete n.configurable, delete n.recursionLimit, delete n.maxConcurrency, delete n.runId, delete n.timeout, delete n.signal, [t, n];
  }
  async _callWithConfig(e, t, n) {
    const s = Ce(n), a = await Zt(s), i = await (a == null ? void 0 : a.handleChainStart(this.toJSON(), ut(t, "input"), s.runId, s == null ? void 0 : s.runType, void 0, void 0, (s == null ? void 0 : s.runName) ?? this.getName()));
    delete s.runId;
    let o;
    try {
      const c = e.call(this, t, s, i);
      o = await zr(c, n == null ? void 0 : n.signal);
    } catch (c) {
      throw await (i == null ? void 0 : i.handleChainError(c)), c;
    }
    return await (i == null ? void 0 : i.handleChainEnd(ut(o, "output"))), o;
  }
  /**
  * Internal method that handles batching and configuration for a runnable
  * It takes a function, input values, and optional configuration, and
  * returns a promise that resolves to the output values.
  * @param func The function to be executed for each input value.
  * @param input The input values to be processed.
  * @param config Optional configuration for the function execution.
  * @returns A promise that resolves to the output values.
  */
  async _batchWithConfig(e, t, n, s) {
    var u;
    const a = this._getOptionsList(n ?? {}, t.length), i = await Promise.all(a.map(Zt)), o = await Promise.all(i.map(async (l, d) => {
      const h = await (l == null ? void 0 : l.handleChainStart(this.toJSON(), ut(t[d], "input"), a[d].runId, a[d].runType, void 0, void 0, a[d].runName ?? this.getName()));
      return delete a[d].runId, h;
    }));
    let c;
    try {
      const l = e.call(this, t, a, o, s);
      c = await zr(l, (u = a == null ? void 0 : a[0]) == null ? void 0 : u.signal);
    } catch (l) {
      throw await Promise.all(o.map((d) => d == null ? void 0 : d.handleChainError(l))), l;
    }
    return await Promise.all(o.map((l) => l == null ? void 0 : l.handleChainEnd(ut(c, "output")))), c;
  }
  /** @internal */
  _concatOutputChunks(e, t) {
    return sn(e, t);
  }
  /**
  * Helper method to transform an Iterator of Input values into an Iterator of
  * Output values, with callbacks.
  * Use this to implement `stream()` or `transform()` in Runnable subclasses.
  */
  async *_transformStreamWithConfig(e, t, n) {
    let s, a = !0, i, o = !0;
    const c = Ce(n), u = await Zt(c), l = this;
    async function* d() {
      for await (const f of e) {
        if (a) if (s === void 0) s = f;
        else try {
          s = l._concatOutputChunks(s, f);
        } catch {
          s = void 0, a = !1;
        }
        yield f;
      }
    }
    let h;
    try {
      const f = await gg(t.bind(this), d(), async () => u == null ? void 0 : u.handleChainStart(this.toJSON(), { input: "" }, c.runId, c.runType, void 0, void 0, c.runName ?? this.getName()), n == null ? void 0 : n.signal, c);
      delete c.runId, h = f.setup;
      const p = h == null ? void 0 : h.handlers.find(iT);
      let y = f.output;
      p !== void 0 && h !== void 0 && (y = p.tapOutputIterable(h.runId, y));
      const g = h == null ? void 0 : h.handlers.find(vg);
      g !== void 0 && h !== void 0 && (y = g.tapOutputIterable(h.runId, y));
      for await (const S of y)
        if (yield S, o) if (i === void 0) i = S;
        else try {
          i = this._concatOutputChunks(i, S);
        } catch {
          i = void 0, o = !1;
        }
    } catch (f) {
      throw await (h == null ? void 0 : h.handleChainError(f, void 0, void 0, void 0, { inputs: ut(s, "input") })), f;
    }
    await (h == null ? void 0 : h.handleChainEnd(i ?? {}, void 0, void 0, void 0, { inputs: ut(s, "input") }));
  }
  getGraph(e) {
    const t = new Cl(), n = t.addNode({
      name: `${this.getName()}Input`,
      schema: Jh()
    }), s = t.addNode(this), a = t.addNode({
      name: `${this.getName()}Output`,
      schema: Jh()
    });
    return t.addEdge(n, s), t.addEdge(s, a), t;
  }
  /**
  * Create a new runnable sequence that runs each individual runnable in series,
  * piping the output of one runnable into another runnable or runnable-like.
  * @param coerceable A runnable, function, or object whose values are functions or runnables.
  * @returns A new runnable sequence.
  */
  pipe(e) {
    return new pa({
      first: this,
      last: ur(e)
    });
  }
  /**
  * Pick keys from the dict output of this runnable. Returns a new runnable.
  */
  pick(e) {
    return this.pipe(new T_(e));
  }
  /**
  * Assigns new fields to the dict output of this runnable. Returns a new runnable.
  */
  assign(e) {
    return this.pipe(new Nl(new ds({ steps: e })));
  }
  /**
  * Default implementation of transform, which buffers input and then calls stream.
  * Subclasses should override this method if they can start producing output while
  * input is still being generated.
  * @param generator
  * @param options
  */
  async *transform(e, t) {
    let n;
    for await (const s of e) n === void 0 ? n = s : n = this._concatOutputChunks(n, s);
    yield* this._streamIterator(n, Ce(t));
  }
  /**
  * Stream all output from a runnable, as reported to the callback system.
  * This includes all inner runs of LLMs, Retrievers, Tools, etc.
  * Output is streamed as Log objects, which include a list of
  * jsonpatch ops that describe how the state of the run has changed in each
  * step, and the final state of the run.
  * The jsonpatch ops can be applied in order to construct state.
  * @param input
  * @param options
  * @param streamOptions
  */
  async *streamLog(e, t, n) {
    const s = new Wc({
      ...n,
      autoClose: !1,
      _schemaFormat: "original"
    }), a = Ce(t);
    yield* this._streamLog(e, s, a);
  }
  async *_streamLog(e, t, n) {
    const { callbacks: s } = n;
    if (s === void 0) n.callbacks = [t];
    else if (Array.isArray(s)) n.callbacks = s.concat([t]);
    else {
      const c = s.copy();
      c.addHandler(t, !0), n.callbacks = c;
    }
    const a = this.stream(e, n);
    async function i() {
      try {
        const c = await a;
        for await (const u of c) {
          const l = new Mr({ ops: [{
            op: "add",
            path: "/streamed_output/-",
            value: u
          }] });
          await t.writer.write(l);
        }
      } finally {
        await t.writer.close();
      }
    }
    const o = i();
    try {
      for await (const c of t) yield c;
    } finally {
      await o;
    }
  }
  streamEvents(e, t, n) {
    let s;
    if (t.version === "v1") s = this._streamEventsV1(e, t, n);
    else if (t.version === "v2") s = this._streamEventsV2(e, t, n);
    else throw new Error('Only versions "v1" and "v2" of the schema are currently supported.');
    return t.encoding === "text/event-stream" ? yO(s) : dr.fromAsyncGenerator(s);
  }
  async *_streamEventsV2(e, t, n) {
    var p;
    const s = new oT({
      ...n,
      autoClose: !1
    }), a = Ce(t), i = a.runId ?? Lr();
    a.runId = i;
    const o = a.callbacks;
    if (o === void 0) a.callbacks = [s];
    else if (Array.isArray(o)) a.callbacks = o.concat(s);
    else {
      const y = o.copy();
      y.addHandler(s, !0), a.callbacks = y;
    }
    const c = new AbortController(), u = this;
    async function l() {
      let y, g = null;
      try {
        t != null && t.signal ? "any" in AbortSignal ? y = AbortSignal.any([c.signal, t.signal]) : (y = t.signal, g = () => {
          c.abort();
        }, t.signal.addEventListener("abort", g, { once: !0 })) : y = c.signal;
        const S = await u.stream(e, {
          ...a,
          signal: y
        }), _ = s.tapOutputIterable(i, S);
        for await (const w of _) if (c.signal.aborted) break;
      } finally {
        await s.finish(), y && g && y.removeEventListener("abort", g);
      }
    }
    const d = l();
    let h = !1, f;
    try {
      for await (const y of s) {
        if (!h) {
          y.data.input = e, h = !0, f = y.run_id, yield y;
          continue;
        }
        y.run_id === f && y.event.endsWith("_end") && (p = y.data) != null && p.input && delete y.data.input, yield y;
      }
    } finally {
      c.abort(), await d;
    }
  }
  async *_streamEventsV1(e, t, n) {
    let s, a = !1;
    const i = Ce(t), o = i.tags ?? [], c = i.metadata ?? {}, u = i.runName ?? this.getName(), l = new Wc({
      ...n,
      autoClose: !1,
      _schemaFormat: "streaming_events"
    }), d = new wT({ ...n }), h = this._streamLog(e, l, i);
    for await (const p of h) {
      if (s ? s = s.concat(p) : s = wl.fromRunLogPatch(p), s.state === void 0) throw new Error('Internal error: "streamEvents" state is missing. Please open a bug report.');
      if (!a) {
        a = !0;
        const _ = { ...s.state }, w = {
          run_id: _.id,
          event: `on_${_.type}_start`,
          name: u,
          tags: o,
          metadata: c,
          data: { input: e }
        };
        d.includeEvent(w, _.type) && (yield w);
      }
      const y = p.ops.filter((_) => _.path.startsWith("/logs/")).map((_) => _.path.split("/")[2]), g = [...new Set(y)];
      for (const _ of g) {
        let w, T = {};
        const x = s.state.logs[_];
        if (x.end_time === void 0 ? x.streamed_output.length > 0 ? w = "stream" : w = "start" : w = "end", w === "start")
          x.inputs !== void 0 && (T.input = x.inputs);
        else if (w === "end")
          x.inputs !== void 0 && (T.input = x.inputs), T.output = x.final_output;
        else if (w === "stream") {
          const A = x.streamed_output.length;
          if (A !== 1) throw new Error(`Expected exactly one chunk of streamed output, got ${A} instead. Encountered in: "${x.name}"`);
          T = { chunk: x.streamed_output[0] }, x.streamed_output = [];
        }
        yield {
          event: `on_${x.type}_${w}`,
          name: x.name,
          run_id: x.id,
          tags: x.tags,
          metadata: x.metadata,
          data: T
        };
      }
      const { state: S } = s;
      if (S.streamed_output.length > 0) {
        const _ = S.streamed_output.length;
        if (_ !== 1) throw new Error(`Expected exactly one chunk of streamed output, got ${_} instead. Encountered in: "${S.name}"`);
        const w = { chunk: S.streamed_output[0] };
        S.streamed_output = [];
        const T = {
          event: `on_${S.type}_stream`,
          run_id: S.id,
          tags: o,
          metadata: c,
          name: u,
          data: w
        };
        d.includeEvent(T, S.type) && (yield T);
      }
    }
    const f = s == null ? void 0 : s.state;
    if (f !== void 0) {
      const p = {
        event: `on_${f.type}_end`,
        name: u,
        run_id: f.id,
        tags: o,
        metadata: c,
        data: { output: f.final_output }
      };
      d.includeEvent(p, f.type) && (yield p);
    }
  }
  static isRunnable(e) {
    return vl(e);
  }
  /**
  * Bind lifecycle listeners to a Runnable, returning a new Runnable.
  * The Run object contains information about the run, including its id,
  * type, input, output, error, startTime, endTime, and any tags or metadata
  * added to the run.
  *
  * @param {Object} params - The object containing the callback functions.
  * @param {(run: Run) => void} params.onStart - Called before the runnable starts running, with the Run object.
  * @param {(run: Run) => void} params.onEnd - Called after the runnable finishes running, with the Run object.
  * @param {(run: Run) => void} params.onError - Called if the runnable throws an error, with the Run object.
  */
  withListeners({ onStart: e, onEnd: t, onError: n }) {
    return new ss({
      bound: this,
      config: {},
      configFactories: [(s) => ({ callbacks: [new Tg({
        config: s,
        onStart: e,
        onEnd: t,
        onError: n
      })] })]
    });
  }
  /**
  * Convert a runnable to a tool. Return a new instance of `RunnableToolLike`
  * which contains the runnable, name, description and schema.
  *
  * @template {T extends RunInput = RunInput} RunInput - The input type of the runnable. Should be the same as the `RunInput` type of the runnable.
  *
  * @param fields
  * @param {string | undefined} [fields.name] The name of the tool. If not provided, it will default to the name of the runnable.
  * @param {string | undefined} [fields.description] The description of the tool. Falls back to the description on the Zod schema if not provided, or undefined if neither are provided.
  * @param {z.ZodType<T>} [fields.schema] The Zod schema for the input of the tool. Infers the Zod type from the input type of the runnable.
  * @returns {RunnableToolLike<z.ZodType<T>, RunOutput>} An instance of `RunnableToolLike` which is a runnable that can be used as a tool.
  */
  asTool(e) {
    return EO(this, e);
  }
}, ss = class __ extends Ye {
  constructor(t) {
    super(t);
    v(this, "lc_namespace", ["langchain_core", "runnables"]);
    v(this, "lc_serializable", !0);
    v(this, "bound");
    v(this, "config");
    v(this, "kwargs");
    v(this, "configFactories");
    this.bound = t.bound, this.kwargs = t.kwargs, this.config = t.config, this.configFactories = t.configFactories;
  }
  static lc_name() {
    return "RunnableBinding";
  }
  getName(t) {
    return this.bound.getName(t);
  }
  async _mergeConfig(...t) {
    const n = xi(this.config, ...t);
    return xi(n, ...this.configFactories ? await Promise.all(this.configFactories.map(async (s) => await s(n))) : []);
  }
  withConfig(t) {
    return new this.constructor({
      bound: this.bound,
      kwargs: this.kwargs,
      config: {
        ...this.config,
        ...t
      }
    });
  }
  withRetry(t) {
    return new Rl({
      bound: this.bound,
      kwargs: this.kwargs,
      config: this.config,
      maxAttemptNumber: t == null ? void 0 : t.stopAfterAttempt,
      ...t
    });
  }
  async invoke(t, n) {
    return this.bound.invoke(t, await this._mergeConfig(n, this.kwargs));
  }
  async batch(t, n, s) {
    const a = Array.isArray(n) ? await Promise.all(n.map(async (i) => this._mergeConfig(Ce(i), this.kwargs))) : await this._mergeConfig(Ce(n), this.kwargs);
    return this.bound.batch(t, a, s);
  }
  /** @internal */
  _concatOutputChunks(t, n) {
    return this.bound._concatOutputChunks(t, n);
  }
  async *_streamIterator(t, n) {
    yield* this.bound._streamIterator(t, await this._mergeConfig(Ce(n), this.kwargs));
  }
  async stream(t, n) {
    return this.bound.stream(t, await this._mergeConfig(Ce(n), this.kwargs));
  }
  async *transform(t, n) {
    yield* this.bound.transform(t, await this._mergeConfig(Ce(n), this.kwargs));
  }
  streamEvents(t, n, s) {
    const a = this, i = async function* () {
      yield* a.bound.streamEvents(t, {
        ...await a._mergeConfig(Ce(n), a.kwargs),
        version: n.version
      }, s);
    };
    return dr.fromAsyncGenerator(i());
  }
  static isRunnableBinding(t) {
    return t.bound && Ye.isRunnable(t.bound);
  }
  /**
  * Bind lifecycle listeners to a Runnable, returning a new Runnable.
  * The Run object contains information about the run, including its id,
  * type, input, output, error, startTime, endTime, and any tags or metadata
  * added to the run.
  *
  * @param {Object} params - The object containing the callback functions.
  * @param {(run: Run) => void} params.onStart - Called before the runnable starts running, with the Run object.
  * @param {(run: Run) => void} params.onEnd - Called after the runnable finishes running, with the Run object.
  * @param {(run: Run) => void} params.onError - Called if the runnable throws an error, with the Run object.
  */
  withListeners({ onStart: t, onEnd: n, onError: s }) {
    return new __({
      bound: this.bound,
      kwargs: this.kwargs,
      config: this.config,
      configFactories: [(a) => ({ callbacks: [new Tg({
        config: a,
        onStart: t,
        onEnd: n,
        onError: s
      })] })]
    });
  }
}, vO = class y_ extends Ye {
  constructor(t) {
    super(t);
    v(this, "lc_serializable", !0);
    v(this, "lc_namespace", ["langchain_core", "runnables"]);
    v(this, "bound");
    this.bound = t.bound;
  }
  static lc_name() {
    return "RunnableEach";
  }
  /**
  * Invokes the runnable with the specified input and configuration.
  * @param input The input to invoke the runnable with.
  * @param config The configuration to invoke the runnable with.
  * @returns A promise that resolves to the output of the runnable.
  */
  async invoke(t, n) {
    return this._callWithConfig(this._invoke.bind(this), t, n);
  }
  /**
  * A helper method that is used to invoke the runnable with the specified input and configuration.
  * @param input The input to invoke the runnable with.
  * @param config The configuration to invoke the runnable with.
  * @returns A promise that resolves to the output of the runnable.
  */
  async _invoke(t, n, s) {
    return this.bound.batch(t, Be(n, { callbacks: s == null ? void 0 : s.getChild() }));
  }
  /**
  * Bind lifecycle listeners to a Runnable, returning a new Runnable.
  * The Run object contains information about the run, including its id,
  * type, input, output, error, startTime, endTime, and any tags or metadata
  * added to the run.
  *
  * @param {Object} params - The object containing the callback functions.
  * @param {(run: Run) => void} params.onStart - Called before the runnable starts running, with the Run object.
  * @param {(run: Run) => void} params.onEnd - Called after the runnable finishes running, with the Run object.
  * @param {(run: Run) => void} params.onError - Called if the runnable throws an error, with the Run object.
  */
  withListeners({ onStart: t, onEnd: n, onError: s }) {
    return new y_({ bound: this.bound.withListeners({
      onStart: t,
      onEnd: n,
      onError: s
    }) });
  }
}, Rl = class extends ss {
  constructor(e) {
    super(e);
    v(this, "lc_namespace", ["langchain_core", "runnables"]);
    v(this, "maxAttemptNumber", 3);
    v(this, "onFailedAttempt", () => {
    });
    this.maxAttemptNumber = e.maxAttemptNumber ?? this.maxAttemptNumber, this.onFailedAttempt = e.onFailedAttempt ?? this.onFailedAttempt;
  }
  static lc_name() {
    return "RunnableRetry";
  }
  _patchConfigForRetry(e, t, n) {
    const s = e > 1 ? `retry:attempt:${e}` : void 0;
    return Be(t, { callbacks: n == null ? void 0 : n.getChild(s) });
  }
  async _invoke(e, t, n) {
    return Gc((s) => super.invoke(e, this._patchConfigForRetry(s, t, n)), {
      onFailedAttempt: ({ error: s }) => this.onFailedAttempt(s, e),
      retries: Math.max(this.maxAttemptNumber - 1, 0),
      randomize: !0
    });
  }
  /**
  * Method that invokes the runnable with the specified input, run manager,
  * and config. It handles the retry logic by catching any errors and
  * recursively invoking itself with the updated config for the next retry
  * attempt.
  * @param input The input for the runnable.
  * @param runManager The run manager for the runnable.
  * @param config The config for the runnable.
  * @returns A promise that resolves to the output of the runnable.
  */
  async invoke(e, t) {
    return this._callWithConfig(this._invoke.bind(this), e, t);
  }
  async _batch(e, t, n, s) {
    const a = {};
    try {
      await Gc(async (i) => {
        const o = e.map((h, f) => f).filter((h) => a[h.toString()] === void 0 || a[h.toString()] instanceof Error), c = o.map((h) => e[h]), u = o.map((h) => this._patchConfigForRetry(i, t == null ? void 0 : t[h], n == null ? void 0 : n[h])), l = await super.batch(c, u, {
          ...s,
          returnExceptions: !0
        });
        let d;
        for (let h = 0; h < l.length; h += 1) {
          const f = l[h], p = o[h];
          f instanceof Error && d === void 0 && (d = f, d.input = c[h]), a[p.toString()] = f;
        }
        if (d) throw d;
        return l;
      }, {
        onFailedAttempt: ({ error: i }) => this.onFailedAttempt(i, i.input),
        retries: Math.max(this.maxAttemptNumber - 1, 0),
        randomize: !0
      });
    } catch (i) {
      if ((s == null ? void 0 : s.returnExceptions) !== !0) throw i;
    }
    return Object.keys(a).sort((i, o) => parseInt(i, 10) - parseInt(o, 10)).map((i) => a[parseInt(i, 10)]);
  }
  async batch(e, t, n) {
    return this._batchWithConfig(this._batch.bind(this), e, t, n);
  }
}, pa = class As extends Ye {
  constructor(t) {
    super(t);
    v(this, "first");
    v(this, "middle", []);
    v(this, "last");
    v(this, "omitSequenceTags", !1);
    v(this, "lc_serializable", !0);
    v(this, "lc_namespace", ["langchain_core", "runnables"]);
    this.first = t.first, this.middle = t.middle ?? this.middle, this.last = t.last, this.name = t.name, this.omitSequenceTags = t.omitSequenceTags ?? this.omitSequenceTags;
  }
  static lc_name() {
    return "RunnableSequence";
  }
  get steps() {
    return [
      this.first,
      ...this.middle,
      this.last
    ];
  }
  async invoke(t, n) {
    var u;
    const s = Ce(n), a = await Zt(s), i = await (a == null ? void 0 : a.handleChainStart(this.toJSON(), ut(t, "input"), s.runId, void 0, void 0, void 0, s == null ? void 0 : s.runName));
    delete s.runId;
    let o = t, c;
    try {
      const l = [this.first, ...this.middle];
      for (let d = 0; d < l.length; d += 1) {
        const f = l[d].invoke(o, Be(s, { callbacks: i == null ? void 0 : i.getChild(this.omitSequenceTags ? void 0 : `seq:step:${d + 1}`) }));
        o = await zr(f, n == null ? void 0 : n.signal);
      }
      if ((u = n == null ? void 0 : n.signal) != null && u.aborted) throw Gs(n.signal);
      c = await this.last.invoke(o, Be(s, { callbacks: i == null ? void 0 : i.getChild(this.omitSequenceTags ? void 0 : `seq:step:${this.steps.length}`) }));
    } catch (l) {
      throw await (i == null ? void 0 : i.handleChainError(l)), l;
    }
    return await (i == null ? void 0 : i.handleChainEnd(ut(c, "output"))), c;
  }
  async batch(t, n, s) {
    var u;
    const a = this._getOptionsList(n ?? {}, t.length), i = await Promise.all(a.map(Zt)), o = await Promise.all(i.map(async (l, d) => {
      const h = await (l == null ? void 0 : l.handleChainStart(this.toJSON(), ut(t[d], "input"), a[d].runId, void 0, void 0, void 0, a[d].runName));
      return delete a[d].runId, h;
    }));
    let c = t;
    try {
      for (let l = 0; l < this.steps.length; l += 1) {
        const h = this.steps[l].batch(c, o.map((f, p) => {
          const y = f == null ? void 0 : f.getChild(this.omitSequenceTags ? void 0 : `seq:step:${l + 1}`);
          return Be(a[p], { callbacks: y });
        }), s);
        c = await zr(h, (u = a[0]) == null ? void 0 : u.signal);
      }
    } catch (l) {
      throw await Promise.all(o.map((d) => d == null ? void 0 : d.handleChainError(l))), l;
    }
    return await Promise.all(o.map((l) => l == null ? void 0 : l.handleChainEnd(ut(c, "output")))), c;
  }
  /** @internal */
  _concatOutputChunks(t, n) {
    return this.last._concatOutputChunks(t, n);
  }
  async *_streamIterator(t, n) {
    var h;
    const s = await Zt(n), { runId: a, ...i } = n ?? {}, o = await (s == null ? void 0 : s.handleChainStart(this.toJSON(), ut(t, "input"), a, void 0, void 0, void 0, i == null ? void 0 : i.runName)), c = [
      this.first,
      ...this.middle,
      this.last
    ];
    let u = !0, l;
    async function* d() {
      yield t;
    }
    try {
      let f = c[0].transform(d(), Be(i, { callbacks: o == null ? void 0 : o.getChild(this.omitSequenceTags ? void 0 : "seq:step:1") }));
      for (let p = 1; p < c.length; p += 1)
        f = await c[p].transform(f, Be(i, { callbacks: o == null ? void 0 : o.getChild(this.omitSequenceTags ? void 0 : `seq:step:${p + 1}`) }));
      for await (const p of f)
        if ((h = n == null ? void 0 : n.signal) == null || h.throwIfAborted(), yield p, u) if (l === void 0) l = p;
        else try {
          l = this._concatOutputChunks(l, p);
        } catch {
          l = void 0, u = !1;
        }
    } catch (f) {
      throw await (o == null ? void 0 : o.handleChainError(f)), f;
    }
    await (o == null ? void 0 : o.handleChainEnd(ut(l, "output")));
  }
  getGraph(t) {
    const n = new Cl();
    let s = null;
    return this.steps.forEach((a, i) => {
      const o = a.getGraph(t);
      i !== 0 && o.trimFirstNode(), i !== this.steps.length - 1 && o.trimLastNode(), n.extend(o);
      const c = o.firstNode();
      if (!c) throw new Error(`Runnable ${a} has no first node`);
      s && n.addEdge(s, c), s = o.lastNode();
    }), n;
  }
  pipe(t) {
    return As.isRunnableSequence(t) ? new As({
      first: this.first,
      middle: this.middle.concat([
        this.last,
        t.first,
        ...t.middle
      ]),
      last: t.last,
      name: this.name ?? t.name
    }) : new As({
      first: this.first,
      middle: [...this.middle, this.last],
      last: ur(t),
      name: this.name
    });
  }
  static isRunnableSequence(t) {
    return Array.isArray(t.middle) && Ye.isRunnable(t);
  }
  static from([t, ...n], s) {
    let a = {};
    return typeof s == "string" ? a.name = s : s !== void 0 && (a = s), new As({
      ...a,
      first: ur(t),
      middle: n.slice(0, -1).map(ur),
      last: ur(n[n.length - 1])
    });
  }
}, ds = class w_ extends Ye {
  constructor(t) {
    super(t);
    v(this, "lc_namespace", ["langchain_core", "runnables"]);
    v(this, "lc_serializable", !0);
    v(this, "steps");
    this.steps = {};
    for (const [n, s] of Object.entries(t.steps)) this.steps[n] = ur(s);
  }
  static lc_name() {
    return "RunnableMap";
  }
  getStepsKeys() {
    return Object.keys(this.steps);
  }
  static from(t) {
    return new w_({ steps: t });
  }
  async invoke(t, n) {
    const s = Ce(n), a = await Zt(s), i = await (a == null ? void 0 : a.handleChainStart(this.toJSON(), { input: t }, s.runId, void 0, void 0, void 0, s == null ? void 0 : s.runName));
    delete s.runId;
    const o = {};
    try {
      const c = Object.entries(this.steps).map(async ([u, l]) => {
        o[u] = await l.invoke(t, Be(s, { callbacks: i == null ? void 0 : i.getChild(`map:key:${u}`) }));
      });
      await zr(Promise.all(c), n == null ? void 0 : n.signal);
    } catch (c) {
      throw await (i == null ? void 0 : i.handleChainError(c)), c;
    }
    return await (i == null ? void 0 : i.handleChainEnd(o)), o;
  }
  async *_transform(t, n, s) {
    const a = { ...this.steps }, i = _l(t, Object.keys(a).length), o = new Map(Object.entries(a).map(([c, u], l) => {
      const d = u.transform(i[l], Be(s, { callbacks: n == null ? void 0 : n.getChild(`map:key:${c}`) }));
      return [c, d.next().then((h) => ({
        key: c,
        gen: d,
        result: h
      }))];
    }));
    for (; o.size; ) {
      const c = Promise.race(o.values()), { key: u, result: l, gen: d } = await zr(c, s == null ? void 0 : s.signal);
      o.delete(u), l.done || (yield { [u]: l.value }, o.set(u, d.next().then((h) => ({
        key: u,
        gen: d,
        result: h
      }))));
    }
  }
  transform(t, n) {
    return this._transformStreamWithConfig(t, this._transform.bind(this), n);
  }
  async stream(t, n) {
    async function* s() {
      yield t;
    }
    const a = Ce(n), i = new kn({
      generator: this.transform(s(), a),
      config: a
    });
    return await i.setup, dr.fromAsyncGenerator(i);
  }
}, bO = class v_ extends Ye {
  constructor(t) {
    super(t);
    v(this, "lc_serializable", !1);
    v(this, "lc_namespace", ["langchain_core", "runnables"]);
    v(this, "func");
    if (!gl(t.func)) throw new Error("RunnableTraceable requires a function that is wrapped in traceable higher-order function");
    this.func = t.func;
  }
  async invoke(t, n) {
    const [s] = this._getOptionsList(n ?? {}, 1), a = await Zt(s), i = this.func(Be(s, { callbacks: a }), t);
    return zr(i, s == null ? void 0 : s.signal);
  }
  async *_streamIterator(t, n) {
    var i, o;
    const [s] = this._getOptionsList(n ?? {}, 1), a = await this.invoke(t, n);
    if (uu(a)) {
      for await (const c of a)
        (i = s == null ? void 0 : s.signal) == null || i.throwIfAborted(), yield c;
      return;
    }
    if (wO(a)) {
      for (; ; ) {
        (o = s == null ? void 0 : s.signal) == null || o.throwIfAborted();
        const c = a.next();
        if (c.done) break;
        yield c.value;
      }
      return;
    }
    yield a;
  }
  static from(t) {
    return new v_({ func: t });
  }
};
function SO(r) {
  if (gl(r)) throw new Error("RunnableLambda requires a function that is not wrapped in traceable higher-order function. This shouldn't happen.");
}
var qr = class b_ extends Ye {
  constructor(t) {
    if (gl(t.func)) return bO.from(t.func);
    super(t);
    v(this, "lc_namespace", ["langchain_core", "runnables"]);
    v(this, "func");
    SO(t.func), this.func = t.func;
  }
  static lc_name() {
    return "RunnableLambda";
  }
  static from(t) {
    return new b_({ func: t });
  }
  async _invoke(t, n, s) {
    return new Promise((a, i) => {
      const o = Be(n, {
        callbacks: s == null ? void 0 : s.getChild(),
        recursionLimit: ((n == null ? void 0 : n.recursionLimit) ?? oc) - 1
      });
      lr.runWithConfig(Ur(o), async () => {
        var c, u;
        try {
          let l = await this.func(t, { ...o });
          if (l && Ye.isRunnable(l)) {
            if ((n == null ? void 0 : n.recursionLimit) === 0) throw new Error("Recursion limit reached.");
            l = await l.invoke(t, {
              ...o,
              recursionLimit: (o.recursionLimit ?? oc) - 1
            });
          } else if (uu(l)) {
            let d;
            for await (const h of lu(o, l))
              if ((c = n == null ? void 0 : n.signal) == null || c.throwIfAborted(), d === void 0) d = h;
              else try {
                d = this._concatOutputChunks(d, h);
              } catch {
                d = h;
              }
            l = d;
          } else if (Qh(l)) {
            let d;
            for (const h of ef(o, l))
              if ((u = n == null ? void 0 : n.signal) == null || u.throwIfAborted(), d === void 0) d = h;
              else try {
                d = this._concatOutputChunks(d, h);
              } catch {
                d = h;
              }
            l = d;
          }
          a(l);
        } catch (l) {
          i(l);
        }
      });
    });
  }
  async invoke(t, n) {
    return this._callWithConfig(this._invoke.bind(this), t, n);
  }
  async *_transform(t, n, s) {
    var c, u;
    let a;
    for await (const l of t) if (a === void 0) a = l;
    else try {
      a = this._concatOutputChunks(a, l);
    } catch {
      a = l;
    }
    const i = Be(s, {
      callbacks: n == null ? void 0 : n.getChild(),
      recursionLimit: ((s == null ? void 0 : s.recursionLimit) ?? oc) - 1
    }), o = await new Promise((l, d) => {
      lr.runWithConfig(Ur(i), async () => {
        try {
          const h = await this.func(a, {
            ...i,
            config: i
          });
          l(h);
        } catch (h) {
          d(h);
        }
      });
    });
    if (o && Ye.isRunnable(o)) {
      if ((s == null ? void 0 : s.recursionLimit) === 0) throw new Error("Recursion limit reached.");
      const l = await o.stream(a, i);
      for await (const d of l) yield d;
    } else if (uu(o)) for await (const l of lu(i, o))
      (c = s == null ? void 0 : s.signal) == null || c.throwIfAborted(), yield l;
    else if (Qh(o)) for (const l of ef(i, o))
      (u = s == null ? void 0 : s.signal) == null || u.throwIfAborted(), yield l;
    else yield o;
  }
  transform(t, n) {
    return this._transformStreamWithConfig(t, this._transform.bind(this), n);
  }
  async stream(t, n) {
    async function* s() {
      yield t;
    }
    const a = Ce(n), i = new kn({
      generator: this.transform(s(), a),
      config: a
    });
    return await i.setup, dr.fromAsyncGenerator(i);
  }
}, TO = class extends ds {
}, S_ = class extends Ye {
  constructor(e) {
    super(e);
    v(this, "lc_namespace", ["langchain_core", "runnables"]);
    v(this, "lc_serializable", !0);
    v(this, "runnable");
    v(this, "fallbacks");
    this.runnable = e.runnable, this.fallbacks = e.fallbacks;
  }
  static lc_name() {
    return "RunnableWithFallbacks";
  }
  *runnables() {
    yield this.runnable;
    for (const e of this.fallbacks) yield e;
  }
  async invoke(e, t) {
    const n = Ce(t), s = await Zt(n), { runId: a, ...i } = n, o = await (s == null ? void 0 : s.handleChainStart(this.toJSON(), ut(e, "input"), a, void 0, void 0, void 0, i == null ? void 0 : i.runName)), c = Be(i, { callbacks: o == null ? void 0 : o.getChild() });
    return await lr.runWithConfig(c, async () => {
      var d;
      let l;
      for (const h of this.runnables()) {
        (d = n == null ? void 0 : n.signal) == null || d.throwIfAborted();
        try {
          const f = await h.invoke(e, c);
          return await (o == null ? void 0 : o.handleChainEnd(ut(f, "output"))), f;
        } catch (f) {
          l === void 0 && (l = f);
        }
      }
      throw l === void 0 ? new Error("No error stored at end of fallback.") : (await (o == null ? void 0 : o.handleChainError(l)), l);
    });
  }
  async *_streamIterator(e, t) {
    var d;
    const n = Ce(t), s = await Zt(n), { runId: a, ...i } = n, o = await (s == null ? void 0 : s.handleChainStart(this.toJSON(), ut(e, "input"), a, void 0, void 0, void 0, i == null ? void 0 : i.runName));
    let c, u;
    for (const h of this.runnables()) {
      (d = n == null ? void 0 : n.signal) == null || d.throwIfAborted();
      const f = Be(i, { callbacks: o == null ? void 0 : o.getChild() });
      try {
        const p = await h.stream(e, f);
        u = lu(f, p);
        break;
      } catch (p) {
        c === void 0 && (c = p);
      }
    }
    if (u === void 0) {
      const h = c ?? /* @__PURE__ */ new Error("No error stored at end of fallback.");
      throw await (o == null ? void 0 : o.handleChainError(h)), h;
    }
    let l;
    try {
      for await (const h of u) {
        yield h;
        try {
          l = l === void 0 ? l : this._concatOutputChunks(l, h);
        } catch {
          l = void 0;
        }
      }
    } catch (h) {
      throw await (o == null ? void 0 : o.handleChainError(h)), h;
    }
    await (o == null ? void 0 : o.handleChainEnd(ut(l, "output")));
  }
  async batch(e, t, n) {
    var c;
    if (n != null && n.returnExceptions) throw new Error("Not implemented.");
    const s = this._getOptionsList(t ?? {}, e.length), a = await Promise.all(s.map((u) => Zt(u))), i = await Promise.all(a.map(async (u, l) => {
      const d = await (u == null ? void 0 : u.handleChainStart(this.toJSON(), ut(e[l], "input"), s[l].runId, void 0, void 0, void 0, s[l].runName));
      return delete s[l].runId, d;
    }));
    let o;
    for (const u of this.runnables()) {
      (c = s[0].signal) == null || c.throwIfAborted();
      try {
        const l = await u.batch(e, i.map((d, h) => Be(s[h], { callbacks: d == null ? void 0 : d.getChild() })), n);
        return await Promise.all(i.map((d, h) => d == null ? void 0 : d.handleChainEnd(ut(l[h], "output")))), l;
      } catch (l) {
        o === void 0 && (o = l);
      }
    }
    throw o ? (await Promise.all(i.map((u) => u == null ? void 0 : u.handleChainError(o))), o) : new Error("No error stored at end of fallbacks.");
  }
};
function ur(r) {
  if (typeof r == "function") return new qr({ func: r });
  if (Ye.isRunnable(r)) return r;
  if (!Array.isArray(r) && typeof r == "object") {
    const e = {};
    for (const [t, n] of Object.entries(r)) e[t] = ur(n);
    return new ds({ steps: e });
  } else throw new Error(`Expected a Runnable, function or object.
Instead got an unsupported type.`);
}
var Nl = class extends Ye {
  constructor(e) {
    e instanceof ds && (e = { mapper: e });
    super(e);
    v(this, "lc_namespace", ["langchain_core", "runnables"]);
    v(this, "lc_serializable", !0);
    v(this, "mapper");
    this.mapper = e.mapper;
  }
  static lc_name() {
    return "RunnableAssign";
  }
  async invoke(e, t) {
    const n = await this.mapper.invoke(e, t);
    return {
      ...e,
      ...n
    };
  }
  async *_transform(e, t, n) {
    const s = this.mapper.getStepsKeys(), [a, i] = _l(e), o = this.mapper.transform(i, Be(n, { callbacks: t == null ? void 0 : t.getChild() })), c = o.next();
    for await (const u of a) {
      if (typeof u != "object" || Array.isArray(u)) throw new Error(`RunnableAssign can only be used with objects as input, got ${typeof u}`);
      const l = Object.fromEntries(Object.entries(u).filter(([d]) => !s.includes(d)));
      Object.keys(l).length > 0 && (yield l);
    }
    yield (await c).value;
    for await (const u of o) yield u;
  }
  transform(e, t) {
    return this._transformStreamWithConfig(e, this._transform.bind(this), t);
  }
  async stream(e, t) {
    async function* n() {
      yield e;
    }
    const s = Ce(t), a = new kn({
      generator: this.transform(n(), s),
      config: s
    });
    return await a.setup, dr.fromAsyncGenerator(a);
  }
}, T_ = class extends Ye {
  constructor(e) {
    (typeof e == "string" || Array.isArray(e)) && (e = { keys: e });
    super(e);
    v(this, "lc_namespace", ["langchain_core", "runnables"]);
    v(this, "lc_serializable", !0);
    v(this, "keys");
    this.keys = e.keys;
  }
  static lc_name() {
    return "RunnablePick";
  }
  async _pick(e) {
    if (typeof this.keys == "string") return e[this.keys];
    {
      const t = this.keys.map((n) => [n, e[n]]).filter((n) => n[1] !== void 0);
      return t.length === 0 ? void 0 : Object.fromEntries(t);
    }
  }
  async invoke(e, t) {
    return this._callWithConfig(this._pick.bind(this), e, t);
  }
  async *_transform(e) {
    for await (const t of e) {
      const n = await this._pick(t);
      n !== void 0 && (yield n);
    }
  }
  transform(e, t) {
    return this._transformStreamWithConfig(e, this._transform.bind(this), t);
  }
  async stream(e, t) {
    async function* n() {
      yield e;
    }
    const s = Ce(t), a = new kn({
      generator: this.transform(n(), s),
      config: s
    });
    return await a.setup, dr.fromAsyncGenerator(a);
  }
}, du = class extends ss {
  constructor(e) {
    const t = pa.from([qr.from(async (n) => {
      let s;
      if (Ms(n)) try {
        s = await To(this.schema, n.args);
      } catch {
        throw new bi("Received tool input did not match expected schema", JSON.stringify(n.args));
      }
      else s = n;
      return s;
    }).withConfig({ runName: `${e.name}:parse_input` }), e.bound]).withConfig({ runName: e.name });
    super({
      bound: t,
      config: e.config ?? {}
    });
    v(this, "name");
    v(this, "description");
    v(this, "schema");
    this.name = e.name, this.description = e.description, this.schema = e.schema;
  }
  static lc_name() {
    return "RunnableToolLike";
  }
};
function EO(r, e) {
  const t = e.name ?? r.getName(), n = e.description ?? Eo(e.schema);
  return kl(e.schema) ? new du({
    name: t,
    description: n,
    schema: ko({ input: Io() }).transform((s) => s.input),
    bound: r
  }) : new du({
    name: t,
    description: n,
    schema: e.schema,
    bound: r
  });
}
const Fi = (r, e) => {
  const t = [...new Set(e == null ? void 0 : e.map((s) => {
    if (typeof s == "string") return s;
    const a = new s({});
    if (!("getType" in a) || typeof a.getType != "function") throw new Error("Invalid type provided.");
    return a.getType();
  }))], n = r.getType();
  return t.some((s) => s === n);
};
function xO(r, e) {
  return Array.isArray(r) ? tf(r, e) : qr.from((t) => tf(t, r));
}
function tf(r, e = {}) {
  const { includeNames: t, excludeNames: n, includeTypes: s, excludeTypes: a, includeIds: i, excludeIds: o } = e, c = [];
  for (const u of r)
    if (!(n && u.name && n.includes(u.name))) {
      {
        if (a && Fi(u, a)) continue;
        if (o && u.id && o.includes(u.id)) continue;
      }
      s || i || t ? (t && u.name && t.some((l) => l === u.name) || s && Fi(u, s) || i && u.id && i.some((l) => l === u.id)) && c.push(u) : c.push(u);
    }
  return c;
}
function IO(r) {
  return Array.isArray(r) ? rf(r) : qr.from(rf);
}
function rf(r) {
  if (!r.length) return [];
  const e = [];
  for (const t of r) {
    const n = t, s = e.pop();
    if (!s) e.push(n);
    else if (n.getType() === "tool" || n.getType() !== s.getType()) e.push(s, n);
    else {
      const a = Si(s), i = Si(n), o = a.concat(i);
      typeof a.content == "string" && typeof i.content == "string" && (o.content = `${a.content}
${i.content}`), e.push(AO(o));
    }
  }
  return e;
}
function kO(r, e) {
  if (Array.isArray(r)) {
    const t = r;
    if (!e) throw new Error("Options parameter is required when providing messages.");
    return nf(t, e);
  } else {
    const t = r;
    return qr.from((n) => nf(n, t)).withConfig({ runName: "trim_messages" });
  }
}
async function nf(r, e) {
  const { maxTokens: t, tokenCounter: n, strategy: s = "last", allowPartial: a = !1, endOn: i, startOn: o, includeSystem: c = !1, textSplitter: u } = e;
  if (o && s === "first") throw new Error("`startOn` should only be specified if `strategy` is 'last'.");
  if (c && s === "first") throw new Error("`includeSystem` should only be specified if `strategy` is 'last'.");
  let l;
  "getNumTokens" in n ? l = async (h) => (await Promise.all(h.map((p) => n.getNumTokens(p.content)))).reduce((p, y) => p + y, 0) : l = async (h) => n(h);
  let d = x_;
  if (u && ("splitText" in u ? d = u.splitText : d = async (h) => u(h)), s === "first") return E_(r, {
    maxTokens: t,
    tokenCounter: l,
    textSplitter: d,
    partialStrategy: a ? "first" : void 0,
    endOn: i
  });
  if (s === "last") return OO(r, {
    maxTokens: t,
    tokenCounter: l,
    textSplitter: d,
    allowPartial: a,
    includeSystem: c,
    startOn: o,
    endOn: i
  });
  throw new Error(`Unrecognized strategy: '${s}'. Must be one of 'first' or 'last'.`);
}
async function E_(r, e) {
  const { maxTokens: t, tokenCounter: n, textSplitter: s, partialStrategy: a, endOn: i } = e;
  let o = [...r], c = 0;
  for (let u = 0; u < o.length; u += 1) {
    const l = u > 0 ? o.slice(0, -u) : o;
    if (await n(l) <= t) {
      c = o.length - u;
      break;
    }
  }
  if (c < o.length && a) {
    let u = !1;
    if (Array.isArray(o[c].content)) {
      const l = o[c];
      if (typeof l.content == "string") throw new Error("Expected content to be an array.");
      const d = l.content.length, h = a === "last" ? [...l.content].reverse() : l.content;
      for (let f = 1; f <= d; f += 1) {
        const p = a === "first" ? h.slice(0, f) : h.slice(-f), y = Object.fromEntries(Object.entries(l).filter(([_]) => _ !== "type" && !_.startsWith("lc_"))), g = Pl(l.getType(), {
          ...y,
          content: p
        }), S = [...o.slice(0, c), g];
        if (await n(S) <= t)
          o = S, c += 1, u = !0;
        else break;
      }
      u && a === "last" && (l.content = [...h].reverse());
    }
    if (!u) {
      const l = o[c];
      let d;
      if (Array.isArray(l.content) && l.content.some((h) => typeof h == "string" || h.type === "text")) {
        const h = l.content.find((f) => f.type === "text" && f.text);
        d = h == null ? void 0 : h.text;
      } else typeof l.content == "string" && (d = l.content);
      if (d) {
        const h = await s(d), f = h.length;
        a === "last" && h.reverse();
        for (let p = 0; p < f - 1; p += 1)
          if (h.pop(), l.content = h.join(""), await n([...o.slice(0, c), l]) <= t) {
            a === "last" && (l.content = [...h].reverse().join("")), o = [...o.slice(0, c), l], c += 1;
            break;
          }
      }
    }
  }
  if (i) {
    const u = Array.isArray(i) ? i : [i];
    for (; c > 0 && !Fi(o[c - 1], u); ) c -= 1;
  }
  return o.slice(0, c);
}
async function OO(r, e) {
  var l;
  const { allowPartial: t = !1, includeSystem: n = !1, endOn: s, startOn: a, ...i } = e;
  let o = r.map((d) => {
    const h = Object.fromEntries(Object.entries(d).filter(([f]) => f !== "type" && !f.startsWith("lc_")));
    return Pl(d.getType(), h, el(d));
  });
  if (s) {
    const d = Array.isArray(s) ? s : [s];
    for (; o.length > 0 && !Fi(o[o.length - 1], d); ) o = o.slice(0, -1);
  }
  const c = n && ((l = o[0]) == null ? void 0 : l.getType()) === "system";
  let u = c ? o.slice(0, 1).concat(o.slice(1).reverse()) : o.reverse();
  return u = await E_(u, {
    ...i,
    partialStrategy: t ? "last" : void 0,
    endOn: a
  }), c ? [u[0], ...u.slice(1).reverse()] : u.reverse();
}
const sf = {
  human: {
    message: zt,
    messageChunk: ua
  },
  ai: {
    message: Fe,
    messageChunk: Ar
  },
  system: {
    message: ct,
    messageChunk: nn
  },
  developer: {
    message: ct,
    messageChunk: nn
  },
  tool: {
    message: kr,
    messageChunk: ia
  },
  function: {
    message: ao,
    messageChunk: ca
  },
  generic: {
    message: In,
    messageChunk: oa
  },
  remove: {
    message: vi,
    messageChunk: vi
  }
};
function Pl(r, e, t) {
  var a;
  let n, s;
  switch (r) {
    case "human":
      t ? n = new ua(e) : s = new zt(e);
      break;
    case "ai":
      if (t) {
        let i = { ...e };
        "tool_calls" in i && (i = {
          ...i,
          tool_call_chunks: (a = i.tool_calls) == null ? void 0 : a.map((o) => ({
            ...o,
            type: "tool_call_chunk",
            index: void 0,
            args: JSON.stringify(o.args)
          }))
        }), n = new Ar(i);
      } else s = new Fe(e);
      break;
    case "system":
      t ? n = new nn(e) : s = new ct(e);
      break;
    case "developer":
      t ? n = new nn({
        ...e,
        additional_kwargs: {
          ...e.additional_kwargs,
          __openai_role__: "developer"
        }
      }) : s = new ct({
        ...e,
        additional_kwargs: {
          ...e.additional_kwargs,
          __openai_role__: "developer"
        }
      });
      break;
    case "tool":
      if ("tool_call_id" in e) t ? n = new ia(e) : s = new kr(e);
      else throw new Error("Can not convert ToolMessage to ToolMessageChunk if 'tool_call_id' field is not defined.");
      break;
    case "function":
      if (t) n = new ca(e);
      else {
        if (!e.name) throw new Error("FunctionMessage must have a 'name' field");
        s = new ao(e);
      }
      break;
    case "generic":
      if ("role" in e) t ? n = new oa(e) : s = new In(e);
      else throw new Error("Can not convert ChatMessage to ChatMessageChunk if 'role' field is not defined.");
      break;
    default:
      throw new Error(`Unrecognized message type ${r}`);
  }
  if (t && n) return n;
  if (s) return s;
  throw new Error(`Unrecognized message type ${r}`);
}
function AO(r) {
  const e = r.getType();
  let t;
  const n = Object.fromEntries(Object.entries(r).filter(([s]) => !["type", "tool_call_chunks"].includes(s) && !s.startsWith("lc_")));
  if (e in sf && (t = Pl(e, n)), !t) throw new Error(`Unrecognized message chunk class ${e}. Supported classes are ${Object.keys(sf)}`);
  return t;
}
function x_(r) {
  const e = r.split(`
`);
  return Promise.resolve([...e.slice(0, -1).map((t) => `${t}
`), e[e.length - 1]]);
}
const $O = [
  "tool_call",
  "tool_call_chunk",
  "invalid_tool_call",
  "server_tool_call",
  "server_tool_call_chunk",
  "server_tool_call_result"
], CO = [
  "image",
  "video",
  "audio",
  "text-plain",
  "file"
], RO = [
  "text",
  "reasoning",
  ...$O,
  ...CO
];
var NO = {};
Ae(NO, {
  AIMessage: () => Fe,
  AIMessageChunk: () => Ar,
  BaseMessage: () => Vr,
  BaseMessageChunk: () => cn,
  ChatMessage: () => In,
  ChatMessageChunk: () => oa,
  FunctionMessage: () => ao,
  FunctionMessageChunk: () => ca,
  HumanMessage: () => zt,
  HumanMessageChunk: () => ua,
  KNOWN_BLOCK_TYPES: () => RO,
  RemoveMessage: () => vi,
  SystemMessage: () => ct,
  SystemMessageChunk: () => nn,
  ToolMessage: () => kr,
  ToolMessageChunk: () => ia,
  _isMessageFieldWithRole: () => wm,
  _mergeDicts: () => Tt,
  _mergeLists: () => aa,
  _mergeObj: () => _m,
  _mergeStatus: () => gm,
  coerceMessageLikeToMessage: () => Ds,
  collapseToolCallChunks: () => Am,
  convertToChunk: () => Si,
  convertToOpenAIImageBlock: () => om,
  convertToProviderContentBlock: () => Gu,
  defaultTextSplitter: () => x_,
  defaultToolCallParser: () => rl,
  filterMessages: () => xO,
  getBufferString: () => sl,
  iife: () => Om,
  isAIMessage: () => oo,
  isAIMessageChunk: () => Lc,
  isBase64ContentBlock: () => Wu,
  isBaseMessage: () => Xr,
  isBaseMessageChunk: () => el,
  isChatMessage: () => mv,
  isChatMessageChunk: () => gv,
  isDataContentBlock: () => Ir,
  isDirectToolOutput: () => tl,
  isFunctionMessage: () => _v,
  isFunctionMessageChunk: () => yv,
  isHumanMessage: () => wv,
  isHumanMessageChunk: () => vv,
  isIDContentBlock: () => im,
  isMessage: () => cm,
  isOpenAIToolCallArray: () => dv,
  isPlainTextContentBlock: () => Mw,
  isSystemMessage: () => bv,
  isSystemMessageChunk: () => Sv,
  isToolMessage: () => Tm,
  isToolMessageChunk: () => Em,
  isURLContentBlock: () => Ju,
  mapChatMessagesToStoredMessages: () => Lv,
  mapStoredMessageToChatMessage: () => al,
  mapStoredMessagesToChatMessages: () => Pv,
  mergeContent: () => Fr,
  mergeMessageRuns: () => IO,
  mergeResponseMetadata: () => vm,
  mergeUsageMetadata: () => Sm,
  parseBase64DataUrl: () => Vs,
  parseMimeType: () => Nc,
  trimMessages: () => kO
});
const bn = (r) => r();
function ma(r) {
  return r ? !!(/^o\d/.test(r ?? "") || r.startsWith("gpt-5") && !r.startsWith("gpt-5-chat")) : !1;
}
function PO(r) {
  return r.role !== "system" && r.role !== "developer" && r.role !== "assistant" && r.role !== "user" && r.role !== "function" && r.role !== "tool" && console.warn(`Unknown message role: ${r.role}`), r.role;
}
function ga(r) {
  const e = r._getType();
  switch (e) {
    case "system":
      return "system";
    case "ai":
      return "assistant";
    case "human":
      return "user";
    case "function":
      return "function";
    case "tool":
      return "tool";
    case "generic":
      if (!In.isInstance(r)) throw new Error("Invalid generic chat message");
      return PO(r);
    default:
      throw new Error(`Unknown message type: ${e}`);
  }
}
function LO(r) {
  const { azureOpenAIApiDeploymentName: e, azureOpenAIApiInstanceName: t, azureOpenAIApiKey: n, azureOpenAIBasePath: s, baseURL: a, azureADTokenProvider: i, azureOpenAIEndpoint: o } = r;
  if ((n || i) && s && e) return `${s}/${e}`;
  if ((n || i) && o && e) return `${o}/openai/deployments/${e}`;
  if (n || i) {
    if (!t) throw new Error("azureOpenAIApiInstanceName is required when using azureOpenAIApiKey");
    if (!e) throw new Error("azureOpenAIApiDeploymentName is a required parameter when using azureOpenAIApiKey");
    return `https://${t}.openai.azure.com/openai/deployments/${e}`;
  }
  return a;
}
function af(r) {
  return typeof Headers < "u" && r !== null && typeof r == "object" && Object.prototype.toString.call(r) === "[object Headers]";
}
function MO(r) {
  const e = bn(() => {
    if (af(r)) return r;
    if (Array.isArray(r)) return new Headers(r);
    if (typeof r == "object" && r !== null && "values" in r && af(r.values)) return r.values;
    if (typeof r == "object" && r !== null) {
      const t = Object.entries(r).filter(([, n]) => typeof n == "string").map(([n, s]) => [n, s]);
      return new Headers(t);
    }
    return new Headers();
  });
  return Object.fromEntries(e.entries());
}
function DO() {
  let r = il();
  return (r === "node" || r === "deno") && (r = `(${r}/${process.version}; ${process.platform}; ${process.arch})`), r;
}
function jO(r, e = !1, t = "1.0.0") {
  const n = MO(r), s = DO(), a = `langchainjs${e ? "-azure" : ""}-openai`;
  return {
    ...n,
    "User-Agent": n["User-Agent"] ? `${a}/${t} (${s})${n["User-Agent"]}` : `${a}/${t} (${s})`
  };
}
function Ll(r) {
  return r !== void 0 && Array.isArray(r.lc_namespace);
}
function Ml(r) {
  return r !== void 0 && Ye.isRunnable(r) && "lc_name" in r.constructor && typeof r.constructor.lc_name == "function" && r.constructor.lc_name() === "RunnableToolLike";
}
function Dl(r) {
  return !!r && typeof r == "object" && "name" in r && "schema" in r && (br(r.schema) || r.schema != null && typeof r.schema == "object" && "type" in r.schema && typeof r.schema.type == "string" && [
    "null",
    "boolean",
    "object",
    "array",
    "number",
    "string"
  ].includes(r.schema.type));
}
function Oo(r) {
  return Dl(r) || Ml(r) || Ll(r);
}
var FO = {};
Ae(FO, {
  convertToOpenAIFunction: () => I_,
  convertToOpenAITool: () => k_,
  isLangChainTool: () => Oo,
  isRunnableToolLike: () => Ml,
  isStructuredTool: () => Ll,
  isStructuredToolParams: () => Dl
});
function I_(r, e) {
  const t = typeof e == "number" ? void 0 : e;
  return {
    name: r.name,
    description: r.description,
    parameters: Sr(r.schema),
    ...(t == null ? void 0 : t.strict) !== void 0 ? { strict: t.strict } : {}
  };
}
function k_(r, e) {
  const t = typeof e == "number" ? void 0 : e;
  let n;
  return Oo(r) ? n = {
    type: "function",
    function: I_(r)
  } : n = r, (t == null ? void 0 : t.strict) !== void 0 && (n.function.strict = t.strict), n;
}
var UO = {};
Ae(UO, {
  extendInteropZodObject: () => _I,
  getInteropZodDefaultGetter: () => wI,
  getInteropZodObjectShape: () => Xc,
  getSchemaDescription: () => Eo,
  interopParse: () => pI,
  interopParseAsync: () => To,
  interopSafeParse: () => fI,
  interopSafeParseAsync: () => e_,
  interopZodObjectMakeFieldsOptional: () => SI,
  interopZodObjectPartial: () => yI,
  interopZodObjectPassthrough: () => Qc,
  interopZodObjectStrict: () => Ri,
  interopZodTransformInputSchema: () => n_,
  isInteropZodError: () => s_,
  isInteropZodLiteral: () => hI,
  isInteropZodObject: () => gI,
  isInteropZodSchema: () => br,
  isShapelessZodSchema: () => mI,
  isSimpleStringZodSchema: () => kl,
  isZodArrayV4: () => xo,
  isZodLiteralV3: () => Xg,
  isZodLiteralV4: () => Qg,
  isZodNullableV4: () => r_,
  isZodObjectV3: () => Ol,
  isZodObjectV4: () => xr,
  isZodOptionalV4: () => t_,
  isZodSchema: () => dI,
  isZodSchemaV3: () => nt,
  isZodSchemaV4: () => qe
});
function zO(r, e) {
  let t;
  return Oo(r) ? t = k_(r) : t = r, (e == null ? void 0 : e.strict) !== void 0 && (t.function.strict = e.strict), t;
}
function BO(r) {
  return r.anyOf !== void 0 && Array.isArray(r.anyOf);
}
function ZO(r) {
  const e = ["namespace functions {", ""];
  for (const t of r)
    t.description && e.push(`// ${t.description}`), Object.keys(t.parameters.properties ?? {}).length > 0 ? (e.push(`type ${t.name} = (_: {`), e.push(O_(t.parameters, 0)), e.push("}) => any;")) : e.push(`type ${t.name} = () => any;`), e.push("");
  return e.push("} // namespace functions"), e.join(`
`);
}
function O_(r, e) {
  var n;
  const t = [];
  for (const [s, a] of Object.entries(r.properties ?? {}))
    a.description && e < 2 && t.push(`// ${a.description}`), (n = r.required) != null && n.includes(s) ? t.push(`${s}: ${Ui(a, e)},`) : t.push(`${s}?: ${Ui(a, e)},`);
  return t.map((s) => " ".repeat(e) + s).join(`
`);
}
function Ui(r, e) {
  if (BO(r)) return r.anyOf.map((t) => Ui(t, e)).join(" | ");
  switch (r.type) {
    case "string":
      return r.enum ? r.enum.map((t) => `"${t}"`).join(" | ") : "string";
    case "number":
      return r.enum ? r.enum.map((t) => `${t}`).join(" | ") : "number";
    case "integer":
      return r.enum ? r.enum.map((t) => `${t}`).join(" | ") : "number";
    case "boolean":
      return "boolean";
    case "null":
      return "null";
    case "object":
      return [
        "{",
        O_(r, e + 2),
        "}"
      ].join(`
`);
    case "array":
      return r.items ? `${Ui(r.items, e)}[]` : "any[]";
    default:
      return "";
  }
}
function A_(r) {
  if (r) return r === "any" || r === "required" ? "required" : r === "auto" ? "auto" : r === "none" ? "none" : typeof r == "string" ? {
    type: "function",
    function: { name: r }
  } : r;
}
function jl(r) {
  return "type" in r && r.type !== "function";
}
function VO(r) {
  return r != null && typeof r == "object" && "type" in r && r.type !== "function";
}
function zi(r) {
  return typeof r == "object" && r !== null && "metadata" in r && typeof r.metadata == "object" && r.metadata !== null && "customTool" in r.metadata && typeof r.metadata.customTool == "object" && r.metadata.customTool !== null;
}
function $_(r) {
  return "type" in r && r.type === "custom" && "custom" in r && typeof r.custom == "object" && r.custom !== null;
}
function qO(r) {
  if (r.type === "custom_tool_call")
    return {
      ...r,
      type: "tool_call",
      call_id: r.id,
      id: r.call_id,
      name: r.name,
      isCustomTool: !0,
      args: { input: r.input }
    };
}
function HO(r) {
  return r.type === "tool_call" && "isCustomTool" in r && r.isCustomTool === !0;
}
function JO(r) {
  const e = () => {
    if (r.custom.format) {
      if (r.custom.format.type === "grammar") return {
        type: "grammar",
        definition: r.custom.format.grammar.definition,
        syntax: r.custom.format.grammar.syntax
      };
      if (r.custom.format.type === "text") return { type: "text" };
    }
  };
  return {
    type: "custom",
    name: r.custom.name,
    description: r.custom.description,
    format: e()
  };
}
function WO(r) {
  const e = () => {
    if (r.format) {
      if (r.format.type === "grammar") return {
        type: "grammar",
        grammar: {
          definition: r.format.definition,
          syntax: r.format.syntax
        }
      };
      if (r.format.type === "text") return { type: "text" };
    }
  };
  return {
    type: "custom",
    custom: {
      name: r.name,
      description: r.description,
      format: e()
    }
  };
}
const GO = /* @__PURE__ */ L("ZodISODateTime", (r, e) => {
  ZE.init(r, e), He.init(r, e);
});
function KO(r) {
  return Zx(GO, r);
}
const YO = /* @__PURE__ */ L("ZodISODate", (r, e) => {
  VE.init(r, e), He.init(r, e);
});
function XO(r) {
  return Vx(YO, r);
}
const QO = /* @__PURE__ */ L("ZodISOTime", (r, e) => {
  qE.init(r, e), He.init(r, e);
});
function eA(r) {
  return qx(QO, r);
}
const tA = /* @__PURE__ */ L("ZodISODuration", (r, e) => {
  HE.init(r, e), He.init(r, e);
});
function rA(r) {
  return Hx(tA, r);
}
const nA = (r, e) => {
  Ng.init(r, e), r.name = "ZodError", Object.defineProperties(r, {
    format: {
      value: (t) => NT(r, t)
      // enumerable: false,
    },
    flatten: {
      value: (t) => RT(r, t)
      // enumerable: false,
    },
    addIssue: {
      value: (t) => {
        r.issues.push(t), r.message = JSON.stringify(r.issues, Kc, 2);
      }
      // enumerable: false,
    },
    addIssues: {
      value: (t) => {
        r.issues.push(...t), r.message = JSON.stringify(r.issues, Kc, 2);
      }
      // enumerable: false,
    },
    isEmpty: {
      get() {
        return r.issues.length === 0;
      }
      // enumerable: false,
    }
  });
}, Kt = L("ZodError", nA, {
  Parent: Error
}), sA = /* @__PURE__ */ _o(Kt), aA = /* @__PURE__ */ wo(Kt), iA = /* @__PURE__ */ vo(Kt), oA = /* @__PURE__ */ bo(Kt), cA = /* @__PURE__ */ jT(Kt), uA = /* @__PURE__ */ FT(Kt), lA = /* @__PURE__ */ UT(Kt), dA = /* @__PURE__ */ zT(Kt), hA = /* @__PURE__ */ BT(Kt), fA = /* @__PURE__ */ ZT(Kt), pA = /* @__PURE__ */ VT(Kt), mA = /* @__PURE__ */ qT(Kt), st = /* @__PURE__ */ L("ZodType", (r, e) => (Xe.init(r, e), r.def = e, r.type = e.type, Object.defineProperty(r, "_def", { value: e }), r.check = (...t) => r.clone(An(e, {
  checks: [
    ...e.checks ?? [],
    ...t.map((n) => typeof n == "function" ? { _zod: { check: n, def: { check: "custom" }, onattach: [] } } : n)
  ]
})), r.clone = (t, n) => bt(r, t, n), r.brand = () => r, r.register = (t, n) => (t.add(r, n), r), r.parse = (t, n) => sA(r, t, n, { callee: r.parse }), r.safeParse = (t, n) => iA(r, t, n), r.parseAsync = async (t, n) => aA(r, t, n, { callee: r.parseAsync }), r.safeParseAsync = async (t, n) => oA(r, t, n), r.spa = r.safeParseAsync, r.encode = (t, n) => cA(r, t, n), r.decode = (t, n) => uA(r, t, n), r.encodeAsync = async (t, n) => lA(r, t, n), r.decodeAsync = async (t, n) => dA(r, t, n), r.safeEncode = (t, n) => hA(r, t, n), r.safeDecode = (t, n) => fA(r, t, n), r.safeEncodeAsync = async (t, n) => pA(r, t, n), r.safeDecodeAsync = async (t, n) => mA(r, t, n), r.refine = (t, n) => r.check(a$(t, n)), r.superRefine = (t) => r.check(i$(t)), r.overwrite = (t) => r.check(ls(t)), r.optional = () => lf(r), r.nullable = () => df(r), r.nullish = () => lf(df(r)), r.nonoptional = (t) => XA(r, t), r.array = () => Zi(r), r.or = (t) => BA([r, t]), r.and = (t) => VA(r, t), r.transform = (t) => hf(r, HA(t)), r.default = (t) => GA(r, t), r.prefault = (t) => YA(r, t), r.catch = (t) => e$(r, t), r.pipe = (t) => hf(r, t), r.readonly = () => n$(r), r.describe = (t) => {
  const n = r.clone();
  return pt.add(n, { description: t }), n;
}, Object.defineProperty(r, "description", {
  get() {
    var t;
    return (t = pt.get(r)) == null ? void 0 : t.description;
  },
  configurable: !0
}), r.meta = (...t) => {
  if (t.length === 0)
    return pt.get(r);
  const n = r.clone();
  return pt.add(n, t[0]), n;
}, r.isOptional = () => r.safeParse(void 0).success, r.isNullable = () => r.safeParse(null).success, r)), C_ = /* @__PURE__ */ L("_ZodString", (r, e) => {
  xl.init(r, e), st.init(r, e);
  const t = r._zod.bag;
  r.format = t.format ?? null, r.minLength = t.minimum ?? null, r.maxLength = t.maximum ?? null, r.regex = (...n) => r.check(Kx(...n)), r.includes = (...n) => r.check(Qx(...n)), r.startsWith = (...n) => r.check(eI(...n)), r.endsWith = (...n) => r.check(tI(...n)), r.min = (...n) => r.check($i(...n)), r.max = (...n) => r.check(Kg(...n)), r.length = (...n) => r.check(Yg(...n)), r.nonempty = (...n) => r.check($i(1, ...n)), r.lowercase = (n) => r.check(Yx(n)), r.uppercase = (n) => r.check(Xx(n)), r.trim = () => r.check(nI()), r.normalize = (...n) => r.check(rI(...n)), r.toLowerCase = () => r.check(sI()), r.toUpperCase = () => r.check(aI()), r.slugify = () => r.check(iI());
}), gA = /* @__PURE__ */ L("ZodString", (r, e) => {
  xl.init(r, e), C_.init(r, e), r.email = (t) => r.check(Sx(_A, t)), r.url = (t) => r.check(kx(yA, t)), r.jwt = (t) => r.check(Bx(NA, t)), r.emoji = (t) => r.check(Ox(wA, t)), r.guid = (t) => r.check(Ih(of, t)), r.uuid = (t) => r.check(Tx(Za, t)), r.uuidv4 = (t) => r.check(Ex(Za, t)), r.uuidv6 = (t) => r.check(xx(Za, t)), r.uuidv7 = (t) => r.check(Ix(Za, t)), r.nanoid = (t) => r.check(Ax(vA, t)), r.guid = (t) => r.check(Ih(of, t)), r.cuid = (t) => r.check($x(bA, t)), r.cuid2 = (t) => r.check(Cx(SA, t)), r.ulid = (t) => r.check(Rx(TA, t)), r.base64 = (t) => r.check(Fx($A, t)), r.base64url = (t) => r.check(Ux(CA, t)), r.xid = (t) => r.check(Nx(EA, t)), r.ksuid = (t) => r.check(Px(xA, t)), r.ipv4 = (t) => r.check(Lx(IA, t)), r.ipv6 = (t) => r.check(Mx(kA, t)), r.cidrv4 = (t) => r.check(Dx(OA, t)), r.cidrv6 = (t) => r.check(jx(AA, t)), r.e164 = (t) => r.check(zx(RA, t)), r.datetime = (t) => r.check(KO(t)), r.date = (t) => r.check(XO(t)), r.time = (t) => r.check(eA(t)), r.duration = (t) => r.check(rA(t));
});
function G(r) {
  return bx(gA, r);
}
const He = /* @__PURE__ */ L("ZodStringFormat", (r, e) => {
  Ve.init(r, e), C_.init(r, e);
}), _A = /* @__PURE__ */ L("ZodEmail", (r, e) => {
  PE.init(r, e), He.init(r, e);
}), of = /* @__PURE__ */ L("ZodGUID", (r, e) => {
  RE.init(r, e), He.init(r, e);
}), Za = /* @__PURE__ */ L("ZodUUID", (r, e) => {
  NE.init(r, e), He.init(r, e);
}), yA = /* @__PURE__ */ L("ZodURL", (r, e) => {
  LE.init(r, e), He.init(r, e);
}), wA = /* @__PURE__ */ L("ZodEmoji", (r, e) => {
  ME.init(r, e), He.init(r, e);
}), vA = /* @__PURE__ */ L("ZodNanoID", (r, e) => {
  DE.init(r, e), He.init(r, e);
}), bA = /* @__PURE__ */ L("ZodCUID", (r, e) => {
  jE.init(r, e), He.init(r, e);
}), SA = /* @__PURE__ */ L("ZodCUID2", (r, e) => {
  FE.init(r, e), He.init(r, e);
}), TA = /* @__PURE__ */ L("ZodULID", (r, e) => {
  UE.init(r, e), He.init(r, e);
}), EA = /* @__PURE__ */ L("ZodXID", (r, e) => {
  zE.init(r, e), He.init(r, e);
}), xA = /* @__PURE__ */ L("ZodKSUID", (r, e) => {
  BE.init(r, e), He.init(r, e);
}), IA = /* @__PURE__ */ L("ZodIPv4", (r, e) => {
  JE.init(r, e), He.init(r, e);
}), kA = /* @__PURE__ */ L("ZodIPv6", (r, e) => {
  WE.init(r, e), He.init(r, e);
}), OA = /* @__PURE__ */ L("ZodCIDRv4", (r, e) => {
  GE.init(r, e), He.init(r, e);
}), AA = /* @__PURE__ */ L("ZodCIDRv6", (r, e) => {
  KE.init(r, e), He.init(r, e);
}), $A = /* @__PURE__ */ L("ZodBase64", (r, e) => {
  YE.init(r, e), He.init(r, e);
}), CA = /* @__PURE__ */ L("ZodBase64URL", (r, e) => {
  QE.init(r, e), He.init(r, e);
}), RA = /* @__PURE__ */ L("ZodE164", (r, e) => {
  ex.init(r, e), He.init(r, e);
}), NA = /* @__PURE__ */ L("ZodJWT", (r, e) => {
  rx.init(r, e), He.init(r, e);
}), R_ = /* @__PURE__ */ L("ZodNumber", (r, e) => {
  Bg.init(r, e), st.init(r, e), r.gt = (n, s) => r.check(Oh(n, s)), r.gte = (n, s) => r.check(uc(n, s)), r.min = (n, s) => r.check(uc(n, s)), r.lt = (n, s) => r.check(kh(n, s)), r.lte = (n, s) => r.check(cc(n, s)), r.max = (n, s) => r.check(cc(n, s)), r.int = (n) => r.check(cf(n)), r.safe = (n) => r.check(cf(n)), r.positive = (n) => r.check(Oh(0, n)), r.nonnegative = (n) => r.check(uc(0, n)), r.negative = (n) => r.check(kh(0, n)), r.nonpositive = (n) => r.check(cc(0, n)), r.multipleOf = (n, s) => r.check(Ah(n, s)), r.step = (n, s) => r.check(Ah(n, s)), r.finite = () => r;
  const t = r._zod.bag;
  r.minValue = Math.max(t.minimum ?? Number.NEGATIVE_INFINITY, t.exclusiveMinimum ?? Number.NEGATIVE_INFINITY) ?? null, r.maxValue = Math.min(t.maximum ?? Number.POSITIVE_INFINITY, t.exclusiveMaximum ?? Number.POSITIVE_INFINITY) ?? null, r.isInt = (t.format ?? "").includes("int") || Number.isSafeInteger(t.multipleOf ?? 0.5), r.isFinite = !0, r.format = t.format ?? null;
});
function Qe(r) {
  return Jx(R_, r);
}
const PA = /* @__PURE__ */ L("ZodNumberFormat", (r, e) => {
  nx.init(r, e), R_.init(r, e);
});
function cf(r) {
  return Wx(PA, r);
}
const LA = /* @__PURE__ */ L("ZodBoolean", (r, e) => {
  sx.init(r, e), st.init(r, e);
});
function Bi(r) {
  return Gx(LA, r);
}
const MA = /* @__PURE__ */ L("ZodUnknown", (r, e) => {
  Zg.init(r, e), st.init(r, e);
});
function uf() {
  return Wg(MA);
}
const DA = /* @__PURE__ */ L("ZodNever", (r, e) => {
  Vg.init(r, e), st.init(r, e);
});
function jA(r) {
  return Gg(DA, r);
}
const FA = /* @__PURE__ */ L("ZodArray", (r, e) => {
  ax.init(r, e), st.init(r, e), r.element = e.element, r.min = (t, n) => r.check($i(t, n)), r.nonempty = (t) => r.check($i(1, t)), r.max = (t, n) => r.check(Kg(t, n)), r.length = (t, n) => r.check(Yg(t, n)), r.unwrap = () => r.element;
});
function Zi(r, e) {
  return oI(FA, r, e);
}
const UA = /* @__PURE__ */ L("ZodObject", (r, e) => {
  ox.init(r, e), st.init(r, e), ze(r, "shape", () => e.shape), r.keyof = () => Gn(Object.keys(r._zod.def.shape)), r.catchall = (t) => r.clone({ ...r._zod.def, catchall: t }), r.passthrough = () => r.clone({ ...r._zod.def, catchall: uf() }), r.loose = () => r.clone({ ...r._zod.def, catchall: uf() }), r.strict = () => r.clone({ ...r._zod.def, catchall: jA() }), r.strip = () => r.clone({ ...r._zod.def, catchall: void 0 }), r.extend = (t) => Ag(r, t), r.safeExtend = (t) => AT(r, t), r.merge = (t) => $T(r, t), r.pick = (t) => kT(r, t), r.omit = (t) => OT(r, t), r.partial = (...t) => $g(N_, r, t[0]), r.required = (...t) => CT(P_, r, t[0]);
});
function Ee(r, e) {
  const t = {
    type: "object",
    shape: r ?? {},
    ...le(e)
  };
  return new UA(t);
}
const zA = /* @__PURE__ */ L("ZodUnion", (r, e) => {
  cx.init(r, e), st.init(r, e), r.options = e.options;
});
function BA(r, e) {
  return new zA({
    type: "union",
    options: r,
    ...le(e)
  });
}
const ZA = /* @__PURE__ */ L("ZodIntersection", (r, e) => {
  ux.init(r, e), st.init(r, e);
});
function VA(r, e) {
  return new ZA({
    type: "intersection",
    left: r,
    right: e
  });
}
const hu = /* @__PURE__ */ L("ZodEnum", (r, e) => {
  lx.init(r, e), st.init(r, e), r.enum = e.entries, r.options = Object.values(e.entries);
  const t = new Set(Object.keys(e.entries));
  r.extract = (n, s) => {
    const a = {};
    for (const i of n)
      if (t.has(i))
        a[i] = e.entries[i];
      else
        throw new Error(`Key ${i} not found in enum`);
    return new hu({
      ...e,
      checks: [],
      ...le(s),
      entries: a
    });
  }, r.exclude = (n, s) => {
    const a = { ...e.entries };
    for (const i of n)
      if (t.has(i))
        delete a[i];
      else
        throw new Error(`Key ${i} not found in enum`);
    return new hu({
      ...e,
      checks: [],
      ...le(s),
      entries: a
    });
  };
});
function Gn(r, e) {
  const t = Array.isArray(r) ? Object.fromEntries(r.map((n) => [n, n])) : r;
  return new hu({
    type: "enum",
    entries: t,
    ...le(e)
  });
}
const qA = /* @__PURE__ */ L("ZodTransform", (r, e) => {
  dx.init(r, e), st.init(r, e), r._zod.parse = (t, n) => {
    if (n.direction === "backward")
      throw new Eg(r.constructor.name);
    t.addIssue = (a) => {
      if (typeof a == "string")
        t.issues.push(Qs(a, t.value, e));
      else {
        const i = a;
        i.fatal && (i.continue = !1), i.code ?? (i.code = "custom"), i.input ?? (i.input = t.value), i.inst ?? (i.inst = r), t.issues.push(Qs(i));
      }
    };
    const s = e.transform(t.value, t);
    return s instanceof Promise ? s.then((a) => (t.value = a, t)) : (t.value = s, t);
  };
});
function HA(r) {
  return new qA({
    type: "transform",
    transform: r
  });
}
const N_ = /* @__PURE__ */ L("ZodOptional", (r, e) => {
  Il.init(r, e), st.init(r, e), r.unwrap = () => r._zod.def.innerType;
});
function lf(r) {
  return new N_({
    type: "optional",
    innerType: r
  });
}
const JA = /* @__PURE__ */ L("ZodNullable", (r, e) => {
  hx.init(r, e), st.init(r, e), r.unwrap = () => r._zod.def.innerType;
});
function df(r) {
  return new JA({
    type: "nullable",
    innerType: r
  });
}
const WA = /* @__PURE__ */ L("ZodDefault", (r, e) => {
  fx.init(r, e), st.init(r, e), r.unwrap = () => r._zod.def.innerType, r.removeDefault = r.unwrap;
});
function GA(r, e) {
  return new WA({
    type: "default",
    innerType: r,
    get defaultValue() {
      return typeof e == "function" ? e() : Og(e);
    }
  });
}
const KA = /* @__PURE__ */ L("ZodPrefault", (r, e) => {
  px.init(r, e), st.init(r, e), r.unwrap = () => r._zod.def.innerType;
});
function YA(r, e) {
  return new KA({
    type: "prefault",
    innerType: r,
    get defaultValue() {
      return typeof e == "function" ? e() : Og(e);
    }
  });
}
const P_ = /* @__PURE__ */ L("ZodNonOptional", (r, e) => {
  mx.init(r, e), st.init(r, e), r.unwrap = () => r._zod.def.innerType;
});
function XA(r, e) {
  return new P_({
    type: "nonoptional",
    innerType: r,
    ...le(e)
  });
}
const QA = /* @__PURE__ */ L("ZodCatch", (r, e) => {
  gx.init(r, e), st.init(r, e), r.unwrap = () => r._zod.def.innerType, r.removeCatch = r.unwrap;
});
function e$(r, e) {
  return new QA({
    type: "catch",
    innerType: r,
    catchValue: typeof e == "function" ? e : () => e
  });
}
const t$ = /* @__PURE__ */ L("ZodPipe", (r, e) => {
  _x.init(r, e), st.init(r, e), r.in = e.in, r.out = e.out;
});
function hf(r, e) {
  return new t$({
    type: "pipe",
    in: r,
    out: e
    // ...util.normalizeParams(params),
  });
}
const r$ = /* @__PURE__ */ L("ZodReadonly", (r, e) => {
  yx.init(r, e), st.init(r, e), r.unwrap = () => r._zod.def.innerType;
});
function n$(r) {
  return new r$({
    type: "readonly",
    innerType: r
  });
}
const s$ = /* @__PURE__ */ L("ZodCustom", (r, e) => {
  wx.init(r, e), st.init(r, e);
});
function a$(r, e = {}) {
  return cI(s$, r, e);
}
function i$(r) {
  return uI(r);
}
const o$ = Symbol("Let zodToJsonSchema decide on which parser to use"), ff = {
  name: void 0,
  $refStrategy: "root",
  effectStrategy: "input",
  pipeStrategy: "all",
  dateStrategy: "format:date-time",
  mapStrategy: "entries",
  nullableStrategy: "from-target",
  removeAdditionalStrategy: "passthrough",
  definitionPath: "definitions",
  target: "jsonSchema7",
  strictUnions: !1,
  errorMessages: !1,
  markdownDescription: !1,
  patternStrategy: "escape",
  applyRegexFlags: !1,
  emailStrategy: "format:email",
  base64Strategy: "contentEncoding:base64",
  nameStrategy: "ref"
}, c$ = (r) => typeof r == "string" ? {
  ...ff,
  basePath: ["#"],
  definitions: {},
  name: r
} : {
  ...ff,
  basePath: ["#"],
  definitions: {},
  ...r
}, fu = (r) => "_def" in r ? r._def : r;
function u$(r) {
  if (!r)
    return !0;
  for (const e in r)
    return !1;
  return !0;
}
const l$ = (r) => {
  const e = c$(r), t = e.name !== void 0 ? [...e.basePath, e.definitionPath, e.name] : e.basePath;
  return {
    ...e,
    currentPath: t,
    propertyPath: void 0,
    seenRefs: /* @__PURE__ */ new Set(),
    seen: new Map(Object.entries(e.definitions).map(([n, s]) => [
      fu(s),
      {
        def: fu(s),
        path: [...e.basePath, e.definitionPath, n],
        // Resolution of references will be forced even though seen, so it's ok that the schema is undefined here for now.
        jsonSchema: void 0
      }
    ]))
  };
};
function L_(r, e, t, n) {
  n != null && n.errorMessages && t && (r.errorMessage = {
    ...r.errorMessage,
    [e]: t
  });
}
function je(r, e, t, n, s) {
  r[e] = t, L_(r, e, n, s);
}
function d$() {
  return {};
}
function h$(r, e) {
  var n, s;
  const t = {
    type: "array"
  };
  return ((s = (n = r.type) == null ? void 0 : n._def) == null ? void 0 : s.typeName) !== C.ZodAny && (t.items = Ne(r.type._def, {
    ...e,
    currentPath: [...e.currentPath, "items"]
  })), r.minLength && je(t, "minItems", r.minLength.value, r.minLength.message, e), r.maxLength && je(t, "maxItems", r.maxLength.value, r.maxLength.message, e), r.exactLength && (je(t, "minItems", r.exactLength.value, r.exactLength.message, e), je(t, "maxItems", r.exactLength.value, r.exactLength.message, e)), t;
}
function f$(r, e) {
  const t = {
    type: "integer",
    format: "int64"
  };
  if (!r.checks)
    return t;
  for (const n of r.checks)
    switch (n.kind) {
      case "min":
        e.target === "jsonSchema7" ? n.inclusive ? je(t, "minimum", n.value, n.message, e) : je(t, "exclusiveMinimum", n.value, n.message, e) : (n.inclusive || (t.exclusiveMinimum = !0), je(t, "minimum", n.value, n.message, e));
        break;
      case "max":
        e.target === "jsonSchema7" ? n.inclusive ? je(t, "maximum", n.value, n.message, e) : je(t, "exclusiveMaximum", n.value, n.message, e) : (n.inclusive || (t.exclusiveMaximum = !0), je(t, "maximum", n.value, n.message, e));
        break;
      case "multipleOf":
        je(t, "multipleOf", n.value, n.message, e);
        break;
    }
  return t;
}
function p$() {
  return {
    type: "boolean"
  };
}
function m$(r, e) {
  return Ne(r.type._def, e);
}
const g$ = (r, e) => Ne(r.innerType._def, e);
function M_(r, e, t) {
  const n = t ?? e.dateStrategy;
  if (Array.isArray(n))
    return {
      anyOf: n.map((s, a) => M_(r, e, s))
    };
  switch (n) {
    case "string":
    case "format:date-time":
      return {
        type: "string",
        format: "date-time"
      };
    case "format:date":
      return {
        type: "string",
        format: "date"
      };
    case "integer":
      return _$(r, e);
  }
}
const _$ = (r, e) => {
  const t = {
    type: "integer",
    format: "unix-time"
  };
  if (e.target === "openApi3")
    return t;
  for (const n of r.checks)
    switch (n.kind) {
      case "min":
        je(
          t,
          "minimum",
          n.value,
          // This is in milliseconds
          n.message,
          e
        );
        break;
      case "max":
        je(
          t,
          "maximum",
          n.value,
          // This is in milliseconds
          n.message,
          e
        );
        break;
    }
  return t;
};
function y$(r, e) {
  return {
    ...Ne(r.innerType._def, e),
    default: r.defaultValue()
  };
}
function w$(r, e, t) {
  return e.effectStrategy === "input" ? Ne(r.schema._def, e, t) : {};
}
function v$(r) {
  return {
    type: "string",
    enum: [...r.values]
  };
}
const b$ = (r) => "type" in r && r.type === "string" ? !1 : "allOf" in r;
function S$(r, e) {
  const t = [
    Ne(r.left._def, {
      ...e,
      currentPath: [...e.currentPath, "allOf", "0"]
    }),
    Ne(r.right._def, {
      ...e,
      currentPath: [...e.currentPath, "allOf", "1"]
    })
  ].filter((a) => !!a);
  let n = e.target === "jsonSchema2019-09" ? { unevaluatedProperties: !1 } : void 0;
  const s = [];
  return t.forEach((a) => {
    if (b$(a))
      s.push(...a.allOf), a.unevaluatedProperties === void 0 && (n = void 0);
    else {
      let i = a;
      if ("additionalProperties" in a && a.additionalProperties === !1) {
        const { additionalProperties: o, ...c } = a;
        i = c;
      } else
        n = void 0;
      s.push(i);
    }
  }), s.length ? {
    allOf: s,
    ...n
  } : void 0;
}
function T$(r, e) {
  const t = typeof r.value;
  return t !== "bigint" && t !== "number" && t !== "boolean" && t !== "string" ? {
    type: Array.isArray(r.value) ? "array" : "object"
  } : e.target === "openApi3" ? {
    type: t === "bigint" ? "integer" : t,
    enum: [r.value]
  } : {
    type: t === "bigint" ? "integer" : t,
    const: r.value
  };
}
let pc;
const ln = {
  /**
   * `c` was changed to `[cC]` to replicate /i flag
   */
  cuid: /^[cC][^\s-]{8,}$/,
  cuid2: /^[0-9a-z]+$/,
  ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,
  /**
   * `a-z` was added to replicate /i flag
   */
  email: /^(?!\.)(?!.*\.\.)([a-zA-Z0-9_'+\-\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\-]*\.)+[a-zA-Z]{2,}$/,
  /**
   * Constructed a valid Unicode RegExp
   *
   * Lazily instantiate since this type of regex isn't supported
   * in all envs (e.g. React Native).
   *
   * See:
   * https://github.com/colinhacks/zod/issues/2433
   * Fix in Zod:
   * https://github.com/colinhacks/zod/commit/9340fd51e48576a75adc919bff65dbc4a5d4c99b
   */
  emoji: () => (pc === void 0 && (pc = RegExp("^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$", "u")), pc),
  base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
  nanoid: /^[a-zA-Z0-9_-]{21}$/
};
function D_(r, e) {
  const t = {
    type: "string"
  };
  function n(s) {
    return e.patternStrategy === "escape" ? E$(s) : s;
  }
  if (r.checks)
    for (const s of r.checks)
      switch (s.kind) {
        case "min":
          je(t, "minLength", typeof t.minLength == "number" ? Math.max(t.minLength, s.value) : s.value, s.message, e);
          break;
        case "max":
          je(t, "maxLength", typeof t.maxLength == "number" ? Math.min(t.maxLength, s.value) : s.value, s.message, e);
          break;
        case "email":
          switch (e.emailStrategy) {
            case "format:email":
              tr(t, "email", s.message, e);
              break;
            case "format:idn-email":
              tr(t, "idn-email", s.message, e);
              break;
            case "pattern:zod":
              rr(t, ln.email, s.message, e);
              break;
          }
          break;
        case "url":
          tr(t, "uri", s.message, e);
          break;
        case "uuid":
          tr(t, "uuid", s.message, e);
          break;
        case "regex":
          rr(t, s.regex, s.message, e);
          break;
        case "cuid":
          rr(t, ln.cuid, s.message, e);
          break;
        case "cuid2":
          rr(t, ln.cuid2, s.message, e);
          break;
        case "startsWith":
          rr(t, RegExp(`^${n(s.value)}`), s.message, e);
          break;
        case "endsWith":
          rr(t, RegExp(`${n(s.value)}$`), s.message, e);
          break;
        case "datetime":
          tr(t, "date-time", s.message, e);
          break;
        case "date":
          tr(t, "date", s.message, e);
          break;
        case "time":
          tr(t, "time", s.message, e);
          break;
        case "duration":
          tr(t, "duration", s.message, e);
          break;
        case "length":
          je(t, "minLength", typeof t.minLength == "number" ? Math.max(t.minLength, s.value) : s.value, s.message, e), je(t, "maxLength", typeof t.maxLength == "number" ? Math.min(t.maxLength, s.value) : s.value, s.message, e);
          break;
        case "includes": {
          rr(t, RegExp(n(s.value)), s.message, e);
          break;
        }
        case "ip": {
          s.version !== "v6" && tr(t, "ipv4", s.message, e), s.version !== "v4" && tr(t, "ipv6", s.message, e);
          break;
        }
        case "emoji":
          rr(t, ln.emoji, s.message, e);
          break;
        case "ulid": {
          rr(t, ln.ulid, s.message, e);
          break;
        }
        case "base64": {
          switch (e.base64Strategy) {
            case "format:binary": {
              tr(t, "binary", s.message, e);
              break;
            }
            case "contentEncoding:base64": {
              je(t, "contentEncoding", "base64", s.message, e);
              break;
            }
            case "pattern:zod": {
              rr(t, ln.base64, s.message, e);
              break;
            }
          }
          break;
        }
        case "nanoid":
          rr(t, ln.nanoid, s.message, e);
      }
  return t;
}
const E$ = (r) => Array.from(r).map((e) => /[a-zA-Z0-9]/.test(e) ? e : `\\${e}`).join(""), tr = (r, e, t, n) => {
  var s;
  r.format || (s = r.anyOf) != null && s.some((a) => a.format) ? (r.anyOf || (r.anyOf = []), r.format && (r.anyOf.push({
    format: r.format,
    ...r.errorMessage && n.errorMessages && {
      errorMessage: { format: r.errorMessage.format }
    }
  }), delete r.format, r.errorMessage && (delete r.errorMessage.format, Object.keys(r.errorMessage).length === 0 && delete r.errorMessage)), r.anyOf.push({
    format: e,
    ...t && n.errorMessages && { errorMessage: { format: t } }
  })) : je(r, "format", e, t, n);
}, rr = (r, e, t, n) => {
  var s;
  r.pattern || (s = r.allOf) != null && s.some((a) => a.pattern) ? (r.allOf || (r.allOf = []), r.pattern && (r.allOf.push({
    pattern: r.pattern,
    ...r.errorMessage && n.errorMessages && {
      errorMessage: { pattern: r.errorMessage.pattern }
    }
  }), delete r.pattern, r.errorMessage && (delete r.errorMessage.pattern, Object.keys(r.errorMessage).length === 0 && delete r.errorMessage)), r.allOf.push({
    pattern: pf(e, n),
    ...t && n.errorMessages && { errorMessage: { pattern: t } }
  })) : je(r, "pattern", pf(e, n), t, n);
}, pf = (r, e) => {
  var u;
  const t = typeof r == "function" ? r() : r;
  if (!e.applyRegexFlags || !t.flags)
    return t.source;
  const n = {
    i: t.flags.includes("i"),
    // Case-insensitive
    m: t.flags.includes("m"),
    // `^` and `$` matches adjacent to newline characters
    s: t.flags.includes("s")
    // `.` matches newlines
  }, s = n.i ? t.source.toLowerCase() : t.source;
  let a = "", i = !1, o = !1, c = !1;
  for (let l = 0; l < s.length; l++) {
    if (i) {
      a += s[l], i = !1;
      continue;
    }
    if (n.i) {
      if (o) {
        if (s[l].match(/[a-z]/)) {
          c ? (a += s[l], a += `${s[l - 2]}-${s[l]}`.toUpperCase(), c = !1) : s[l + 1] === "-" && ((u = s[l + 2]) != null && u.match(/[a-z]/)) ? (a += s[l], c = !0) : a += `${s[l]}${s[l].toUpperCase()}`;
          continue;
        }
      } else if (s[l].match(/[a-z]/)) {
        a += `[${s[l]}${s[l].toUpperCase()}]`;
        continue;
      }
    }
    if (n.m) {
      if (s[l] === "^") {
        a += `(^|(?<=[\r
]))`;
        continue;
      } else if (s[l] === "$") {
        a += `($|(?=[\r
]))`;
        continue;
      }
    }
    if (n.s && s[l] === ".") {
      a += o ? `${s[l]}\r
` : `[${s[l]}\r
]`;
      continue;
    }
    a += s[l], s[l] === "\\" ? i = !0 : o && s[l] === "]" ? o = !1 : !o && s[l] === "[" && (o = !0);
  }
  try {
    const l = new RegExp(a);
  } catch {
    return console.warn(`Could not convert regex pattern at ${e.currentPath.join("/")} to a flag-independent form! Falling back to the flag-ignorant source`), t.source;
  }
  return a;
};
function j_(r, e) {
  var n, s, a, i;
  if (e.target === "openApi3" && ((n = r.keyType) == null ? void 0 : n._def.typeName) === C.ZodEnum)
    return {
      type: "object",
      required: r.keyType._def.values,
      properties: r.keyType._def.values.reduce((o, c) => ({
        ...o,
        [c]: Ne(r.valueType._def, {
          ...e,
          currentPath: [...e.currentPath, "properties", c]
        }) ?? {}
      }), {}),
      additionalProperties: !1
    };
  const t = {
    type: "object",
    additionalProperties: Ne(r.valueType._def, {
      ...e,
      currentPath: [...e.currentPath, "additionalProperties"]
    }) ?? {}
  };
  if (e.target === "openApi3")
    return t;
  if (((s = r.keyType) == null ? void 0 : s._def.typeName) === C.ZodString && ((a = r.keyType._def.checks) != null && a.length)) {
    const o = Object.entries(D_(r.keyType._def, e)).reduce((c, [u, l]) => u === "type" ? c : { ...c, [u]: l }, {});
    return {
      ...t,
      propertyNames: o
    };
  } else if (((i = r.keyType) == null ? void 0 : i._def.typeName) === C.ZodEnum)
    return {
      ...t,
      propertyNames: {
        enum: r.keyType._def.values
      }
    };
  return t;
}
function x$(r, e) {
  if (e.mapStrategy === "record")
    return j_(r, e);
  const t = Ne(r.keyType._def, {
    ...e,
    currentPath: [...e.currentPath, "items", "items", "0"]
  }) || {}, n = Ne(r.valueType._def, {
    ...e,
    currentPath: [...e.currentPath, "items", "items", "1"]
  }) || {};
  return {
    type: "array",
    maxItems: 125,
    items: {
      type: "array",
      items: [t, n],
      minItems: 2,
      maxItems: 2
    }
  };
}
function I$(r) {
  const e = r.values, n = Object.keys(r.values).filter((a) => typeof e[e[a]] != "number").map((a) => e[a]), s = Array.from(new Set(n.map((a) => typeof a)));
  return {
    type: s.length === 1 ? s[0] === "string" ? "string" : "number" : ["string", "number"],
    enum: n
  };
}
function k$() {
  return {
    not: {}
  };
}
function O$(r) {
  return r.target === "openApi3" ? {
    enum: ["null"],
    nullable: !0
  } : {
    type: "null"
  };
}
const Vi = {
  ZodString: "string",
  ZodNumber: "number",
  ZodBigInt: "integer",
  ZodBoolean: "boolean",
  ZodNull: "null"
};
function A$(r, e) {
  if (e.target === "openApi3")
    return mf(r, e);
  const t = r.options instanceof Map ? Array.from(r.options.values()) : r.options;
  if (t.every((n) => n._def.typeName in Vi && (!n._def.checks || !n._def.checks.length))) {
    const n = t.reduce((s, a) => {
      const i = Vi[a._def.typeName];
      return i && !s.includes(i) ? [...s, i] : s;
    }, []);
    return {
      type: n.length > 1 ? n : n[0]
    };
  } else if (t.every((n) => n._def.typeName === "ZodLiteral" && !n.description)) {
    const n = t.reduce((s, a) => {
      const i = typeof a._def.value;
      switch (i) {
        case "string":
        case "number":
        case "boolean":
          return [...s, i];
        case "bigint":
          return [...s, "integer"];
        case "object":
          if (a._def.value === null)
            return [...s, "null"];
        case "symbol":
        case "undefined":
        case "function":
        default:
          return s;
      }
    }, []);
    if (n.length === t.length) {
      const s = n.filter((a, i, o) => o.indexOf(a) === i);
      return {
        type: s.length > 1 ? s : s[0],
        enum: t.reduce((a, i) => a.includes(i._def.value) ? a : [...a, i._def.value], [])
      };
    }
  } else if (t.every((n) => n._def.typeName === "ZodEnum"))
    return {
      type: "string",
      enum: t.reduce((n, s) => [...n, ...s._def.values.filter((a) => !n.includes(a))], [])
    };
  return mf(r, e);
}
const mf = (r, e) => {
  const t = (r.options instanceof Map ? Array.from(r.options.values()) : r.options).map((n, s) => Ne(n._def, {
    ...e,
    currentPath: [...e.currentPath, "anyOf", `${s}`]
  })).filter((n) => !!n && (!e.strictUnions || typeof n == "object" && Object.keys(n).length > 0));
  return t.length ? { anyOf: t } : void 0;
};
function $$(r, e) {
  if (["ZodString", "ZodNumber", "ZodBigInt", "ZodBoolean", "ZodNull"].includes(r.innerType._def.typeName) && (!r.innerType._def.checks || !r.innerType._def.checks.length))
    return e.target === "openApi3" || e.nullableStrategy === "property" ? {
      type: Vi[r.innerType._def.typeName],
      nullable: !0
    } : {
      type: [Vi[r.innerType._def.typeName], "null"]
    };
  if (e.target === "openApi3") {
    const n = Ne(r.innerType._def, {
      ...e,
      currentPath: [...e.currentPath]
    });
    return n && "$ref" in n ? { allOf: [n], nullable: !0 } : n && { ...n, nullable: !0 };
  }
  const t = Ne(r.innerType._def, {
    ...e,
    currentPath: [...e.currentPath, "anyOf", "0"]
  });
  return t && { anyOf: [t, { type: "null" }] };
}
function C$(r, e) {
  const t = {
    type: "number"
  };
  if (!r.checks)
    return t;
  for (const n of r.checks)
    switch (n.kind) {
      case "int":
        t.type = "integer", L_(t, "type", n.message, e);
        break;
      case "min":
        e.target === "jsonSchema7" ? n.inclusive ? je(t, "minimum", n.value, n.message, e) : je(t, "exclusiveMinimum", n.value, n.message, e) : (n.inclusive || (t.exclusiveMinimum = !0), je(t, "minimum", n.value, n.message, e));
        break;
      case "max":
        e.target === "jsonSchema7" ? n.inclusive ? je(t, "maximum", n.value, n.message, e) : je(t, "exclusiveMaximum", n.value, n.message, e) : (n.inclusive || (t.exclusiveMaximum = !0), je(t, "maximum", n.value, n.message, e));
        break;
      case "multipleOf":
        je(t, "multipleOf", n.value, n.message, e);
        break;
    }
  return t;
}
function R$(r, e) {
  return e.removeAdditionalStrategy === "strict" ? r.catchall._def.typeName === "ZodNever" ? r.unknownKeys !== "strict" : Ne(r.catchall._def, {
    ...e,
    currentPath: [...e.currentPath, "additionalProperties"]
  }) ?? !0 : r.catchall._def.typeName === "ZodNever" ? r.unknownKeys === "passthrough" : Ne(r.catchall._def, {
    ...e,
    currentPath: [...e.currentPath, "additionalProperties"]
  }) ?? !0;
}
function N$(r, e) {
  const t = {
    type: "object",
    ...Object.entries(r.shape()).reduce((n, [s, a]) => {
      var c;
      if (a === void 0 || a._def === void 0)
        return n;
      const i = [...e.currentPath, "properties", s], o = Ne(a._def, {
        ...e,
        currentPath: i,
        propertyPath: i
      });
      if (o === void 0)
        return n;
      if (e.openaiStrictMode && a.isOptional() && !a.isNullable() && typeof ((c = a._def) == null ? void 0 : c.defaultValue) > "u")
        throw new Error(`Zod field at \`${i.join("/")}\` uses \`.optional()\` without \`.nullable()\` which is not supported by the API. See: https://platform.openai.com/docs/guides/structured-outputs?api-mode=responses#all-fields-must-be-required`);
      return {
        properties: {
          ...n.properties,
          [s]: o
        },
        required: a.isOptional() && !e.openaiStrictMode ? n.required : [...n.required, s]
      };
    }, { properties: {}, required: [] }),
    additionalProperties: R$(r, e)
  };
  return t.required.length || delete t.required, t;
}
const P$ = (r, e) => {
  if (e.propertyPath && e.currentPath.slice(0, e.propertyPath.length).toString() === e.propertyPath.toString())
    return Ne(r.innerType._def, { ...e, currentPath: e.currentPath });
  const t = Ne(r.innerType._def, {
    ...e,
    currentPath: [...e.currentPath, "anyOf", "1"]
  });
  return t ? {
    anyOf: [
      {
        not: {}
      },
      t
    ]
  } : {};
}, L$ = (r, e) => {
  if (e.pipeStrategy === "input")
    return Ne(r.in._def, e);
  if (e.pipeStrategy === "output")
    return Ne(r.out._def, e);
  const t = Ne(r.in._def, {
    ...e,
    currentPath: [...e.currentPath, "allOf", "0"]
  }), n = Ne(r.out._def, {
    ...e,
    currentPath: [...e.currentPath, "allOf", t ? "1" : "0"]
  });
  return {
    allOf: [t, n].filter((s) => s !== void 0)
  };
};
function M$(r, e) {
  return Ne(r.type._def, e);
}
function D$(r, e) {
  const n = {
    type: "array",
    uniqueItems: !0,
    items: Ne(r.valueType._def, {
      ...e,
      currentPath: [...e.currentPath, "items"]
    })
  };
  return r.minSize && je(n, "minItems", r.minSize.value, r.minSize.message, e), r.maxSize && je(n, "maxItems", r.maxSize.value, r.maxSize.message, e), n;
}
function j$(r, e) {
  return r.rest ? {
    type: "array",
    minItems: r.items.length,
    items: r.items.map((t, n) => Ne(t._def, {
      ...e,
      currentPath: [...e.currentPath, "items", `${n}`]
    })).reduce((t, n) => n === void 0 ? t : [...t, n], []),
    additionalItems: Ne(r.rest._def, {
      ...e,
      currentPath: [...e.currentPath, "additionalItems"]
    })
  } : {
    type: "array",
    minItems: r.items.length,
    maxItems: r.items.length,
    items: r.items.map((t, n) => Ne(t._def, {
      ...e,
      currentPath: [...e.currentPath, "items", `${n}`]
    })).reduce((t, n) => n === void 0 ? t : [...t, n], [])
  };
}
function F$() {
  return {
    not: {}
  };
}
function U$() {
  return {};
}
const z$ = (r, e) => Ne(r.innerType._def, e);
function Ne(r, e, t = !1) {
  var i;
  const n = e.seen.get(r);
  if (e.override) {
    const o = (i = e.override) == null ? void 0 : i.call(e, r, e, n, t);
    if (o !== o$)
      return o;
  }
  if (n && !t) {
    const o = B$(n, e);
    if (o !== void 0)
      return "$ref" in o && e.seenRefs.add(o.$ref), o;
  }
  const s = { def: r, path: e.currentPath, jsonSchema: void 0 };
  e.seen.set(r, s);
  const a = V$(r, r.typeName, e, t);
  return a && q$(r, e, a), s.jsonSchema = a, a;
}
const B$ = (r, e) => {
  switch (e.$refStrategy) {
    case "root":
      return { $ref: r.path.join("/") };
    case "extract-to-root":
      const t = r.path.slice(e.basePath.length + 1).join("_");
      return t !== e.name && e.nameStrategy === "duplicate-ref" && (e.definitions[t] = r.def), { $ref: [...e.basePath, e.definitionPath, t].join("/") };
    case "relative":
      return { $ref: Z$(e.currentPath, r.path) };
    case "none":
    case "seen":
      return r.path.length < e.currentPath.length && r.path.every((n, s) => e.currentPath[s] === n) ? (console.warn(`Recursive reference detected at ${e.currentPath.join("/")}! Defaulting to any`), {}) : e.$refStrategy === "seen" ? {} : void 0;
  }
}, Z$ = (r, e) => {
  let t = 0;
  for (; t < r.length && t < e.length && r[t] === e[t]; t++)
    ;
  return [(r.length - t).toString(), ...e.slice(t)].join("/");
}, V$ = (r, e, t, n) => {
  switch (e) {
    case C.ZodString:
      return D_(r, t);
    case C.ZodNumber:
      return C$(r, t);
    case C.ZodObject:
      return N$(r, t);
    case C.ZodBigInt:
      return f$(r, t);
    case C.ZodBoolean:
      return p$();
    case C.ZodDate:
      return M_(r, t);
    case C.ZodUndefined:
      return F$();
    case C.ZodNull:
      return O$(t);
    case C.ZodArray:
      return h$(r, t);
    case C.ZodUnion:
    case C.ZodDiscriminatedUnion:
      return A$(r, t);
    case C.ZodIntersection:
      return S$(r, t);
    case C.ZodTuple:
      return j$(r, t);
    case C.ZodRecord:
      return j_(r, t);
    case C.ZodLiteral:
      return T$(r, t);
    case C.ZodEnum:
      return v$(r);
    case C.ZodNativeEnum:
      return I$(r);
    case C.ZodNullable:
      return $$(r, t);
    case C.ZodOptional:
      return P$(r, t);
    case C.ZodMap:
      return x$(r, t);
    case C.ZodSet:
      return D$(r, t);
    case C.ZodLazy:
      return Ne(r.getter()._def, t);
    case C.ZodPromise:
      return M$(r, t);
    case C.ZodNaN:
    case C.ZodNever:
      return k$();
    case C.ZodEffects:
      return w$(r, t, n);
    case C.ZodAny:
      return d$();
    case C.ZodUnknown:
      return U$();
    case C.ZodDefault:
      return y$(r, t);
    case C.ZodBranded:
      return m$(r, t);
    case C.ZodReadonly:
      return z$(r, t);
    case C.ZodCatch:
      return g$(r, t);
    case C.ZodPipeline:
      return L$(r, t);
    case C.ZodFunction:
    case C.ZodVoid:
    case C.ZodSymbol:
      return;
    default:
      return /* @__PURE__ */ ((s) => {
      })();
  }
}, q$ = (r, e, t) => (r.description && (t.description = r.description, e.markdownDescription && (t.markdownDescription = r.description)), t), H$ = (r, e) => {
  const t = l$(e), n = typeof e == "string" ? e : (e == null ? void 0 : e.nameStrategy) === "title" || e == null ? void 0 : e.name, s = Ne(r._def, n === void 0 ? t : {
    ...t,
    currentPath: [...t.basePath, t.definitionPath, n]
  }, !1) ?? {}, a = typeof e == "object" && e.name !== void 0 && e.nameStrategy === "title" ? e.name : void 0;
  a !== void 0 && (s.title = a);
  const i = (() => {
    if (u$(t.definitions))
      return;
    const c = {}, u = /* @__PURE__ */ new Set();
    for (let l = 0; l < 500; l++) {
      const d = Object.entries(t.definitions).filter(([h]) => !u.has(h));
      if (d.length === 0)
        break;
      for (const [h, f] of d)
        c[h] = Ne(fu(f), { ...t, currentPath: [...t.basePath, t.definitionPath, h] }, !0) ?? {}, u.add(h);
    }
    return c;
  })(), o = n === void 0 ? i ? {
    ...s,
    [t.definitionPath]: i
  } : s : t.nameStrategy === "duplicate-ref" ? {
    ...s,
    ...i || t.seenRefs.size ? {
      [t.definitionPath]: {
        ...i,
        // only actually duplicate the schema definition if it was ever referenced
        // otherwise the duplication is completely pointless
        ...t.seenRefs.size ? { [n]: s } : void 0
      }
    } : void 0
  } : {
    $ref: [...t.$refStrategy === "relative" ? [] : t.basePath, t.definitionPath, n].join("/"),
    [t.definitionPath]: {
      ...i,
      [n]: s
    }
  };
  return t.target === "jsonSchema7" ? o.$schema = "http://json-schema.org/draft-07/schema#" : t.target === "jsonSchema2019-09" && (o.$schema = "https://json-schema.org/draft/2019-09/schema#"), o;
};
function J$(r) {
  if (r.type !== "object")
    throw new Error(`Root schema must have type: 'object' but got type: ${r.type ? `'${r.type}'` : "undefined"}`);
  const e = structuredClone(r);
  return Nr(e, [], e);
}
function pu(r) {
  if (typeof r == "boolean")
    return !1;
  if (r.type === "null")
    return !0;
  for (const e of r.oneOf ?? [])
    if (pu(e))
      return !0;
  for (const e of r.anyOf ?? [])
    if (pu(e))
      return !0;
  return !1;
}
function Nr(r, e, t) {
  if (typeof r == "boolean")
    throw new TypeError(`Expected object schema but got boolean; path=${e.join("/")}`);
  if (!fn(r))
    throw new TypeError(`Expected ${JSON.stringify(r)} to be an object; path=${e.join("/")}`);
  const n = r.$defs;
  if (fn(n))
    for (const [h, f] of Object.entries(n))
      Nr(f, [...e, "$defs", h], t);
  const s = r.definitions;
  if (fn(s))
    for (const [h, f] of Object.entries(s))
      Nr(f, [...e, "definitions", h], t);
  r.type === "object" && !("additionalProperties" in r) && (r.additionalProperties = !1);
  const i = r.required ?? [], o = r.properties;
  if (fn(o)) {
    for (const [h, f] of Object.entries(o))
      if (!pu(f) && !i.includes(h))
        throw new Error(`Zod field at \`${[...e, "properties", h].join("/")}\` uses \`.optional()\` without \`.nullable()\` which is not supported by the API. See: https://platform.openai.com/docs/guides/structured-outputs?api-mode=responses#all-fields-must-be-required`);
    r.required = Object.keys(o), r.properties = Object.fromEntries(Object.entries(o).map(([h, f]) => [
      h,
      Nr(f, [...e, "properties", h], t)
    ]));
  }
  const c = r.items;
  fn(c) && (r.items = Nr(c, [...e, "items"], t));
  const u = r.anyOf;
  Array.isArray(u) && (r.anyOf = u.map((h, f) => Nr(h, [...e, "anyOf", String(f)], t)));
  const l = r.allOf;
  if (Array.isArray(l))
    if (l.length === 1) {
      const h = Nr(l[0], [...e, "allOf", "0"], t);
      Object.assign(r, h), delete r.allOf;
    } else
      r.allOf = l.map((h, f) => Nr(h, [...e, "allOf", String(f)], t));
  r.default === null && delete r.default;
  const d = r.$ref;
  if (d && G$(r, 1)) {
    if (typeof d != "string")
      throw new TypeError(`Received non-string $ref - ${d}; path=${e.join("/")}`);
    const h = W$(t, d);
    if (typeof h == "boolean")
      throw new Error(`Expected \`$ref: ${d}\` to resolve to an object schema but got boolean`);
    if (!fn(h))
      throw new Error(`Expected \`$ref: ${d}\` to resolve to an object but got ${JSON.stringify(h)}`);
    return Object.assign(r, { ...h, ...r }), delete r.$ref, Nr(r, e, t);
  }
  return r;
}
function W$(r, e) {
  if (!e.startsWith("#/"))
    throw new Error(`Unexpected $ref format ${JSON.stringify(e)}; Does not start with #/`);
  const t = e.slice(2).split("/");
  let n = r;
  for (const s of t) {
    if (!fn(n))
      throw new Error(`encountered non-object entry while resolving ${e} - ${JSON.stringify(n)}`);
    const a = n[s];
    if (a === void 0)
      throw new Error(`Key ${s} not found while resolving ${e}`);
    n = a;
  }
  return n;
}
function fn(r) {
  return typeof r == "object" && r !== null && !Array.isArray(r);
}
function G$(r, e) {
  let t = 0;
  for (const n in r)
    if (t++, t > e)
      return !0;
  return !1;
}
function K$(r, e) {
  return H$(r, {
    openaiStrictMode: !0,
    name: e.name,
    nameStrategy: "duplicate-ref",
    $refStrategy: "extract-to-root",
    nullableStrategy: "property"
  });
}
function Y$(r) {
  return J$(Ci(r, {
    target: "draft-7"
  }));
}
function X$(r) {
  return "_zod" in r;
}
function Q$(r, e, t) {
  return dw({
    type: "json_schema",
    json_schema: {
      ...t,
      name: e,
      strict: !0,
      schema: X$(r) ? Y$(r) : K$(r, { name: e })
    }
  }, (n) => r.parse(JSON.parse(n)));
}
const gf = [
  "jsonSchema",
  "functionCalling",
  "jsonMode"
];
function eC(r, e) {
  if (typeof e < "u" && !gf.includes(e)) throw new Error(`Invalid method: ${e}. Supported methods are: ${gf.join(", ")}`);
  const t = !r.startsWith("gpt-3") && !r.startsWith("gpt-4-") && r !== "gpt-4";
  if (t && !e) return "jsonSchema";
  if (!t && e === "jsonSchema") throw new Error(`JSON Schema is not supported for model "${r}". Please use a different method, e.g. "functionCalling" or "jsonMode".`);
  return e ?? "functionCalling";
}
function tC(r, e) {
  const t = { ...r };
  return Object.defineProperties(t, {
    $brand: {
      value: "auto-parseable-response-format",
      enumerable: !1
    },
    $parseRaw: {
      value: e,
      enumerable: !1
    }
  }), t;
}
function rC(r, e, t) {
  if (nt(r)) return Q$(r, e, t);
  if (qe(r)) return tC({
    type: "json_schema",
    json_schema: {
      ...t,
      name: e,
      strict: !0,
      schema: Ci(r, {
        cycles: "ref",
        reused: "ref",
        override(n) {
          n.jsonSchema.title = e;
        }
      })
    }
  }, (n) => yo(r, JSON.parse(n)));
  throw new Error("Unsupported schema response format");
}
function nC(r, e) {
  if (e && typeof e == "object" && "images" in e && Array.isArray(e.images)) {
    const t = e.images.filter((n) => {
      var s;
      return typeof ((s = n == null ? void 0 : n.image_url) == null ? void 0 : s.url) == "string";
    }).map((n) => ({
      type: "image",
      url: n.image_url.url
    }));
    return [{
      type: "text",
      text: r
    }, ...t];
  }
  return r;
}
const sC = {
  "gpt-4.1-nano": {
    maxInputTokens: 1047576,
    imageInputs: !0,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 32768,
    reasoningOutput: !1,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !0,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0,
    toolChoice: !0
  },
  "text-embedding-3-small": {
    maxInputTokens: 8191,
    imageInputs: !1,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 1536,
    reasoningOutput: !1,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !1,
    structuredOutput: !0,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0,
    toolChoice: !0
  },
  "gpt-4": {
    maxInputTokens: 8192,
    imageInputs: !1,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 8192,
    reasoningOutput: !1,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !0,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0,
    toolChoice: !0
  },
  "o1-pro": {
    maxInputTokens: 2e5,
    imageInputs: !0,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 1e5,
    reasoningOutput: !0,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !0,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0,
    toolChoice: !0
  },
  "gpt-4o-2024-05-13": {
    maxInputTokens: 128e3,
    imageInputs: !0,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 4096,
    reasoningOutput: !1,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !0,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0,
    toolChoice: !0
  },
  "gpt-4o-2024-08-06": {
    maxInputTokens: 128e3,
    imageInputs: !0,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 16384,
    reasoningOutput: !1,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !0,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0,
    toolChoice: !0
  },
  "gpt-4.1-mini": {
    maxInputTokens: 1047576,
    imageInputs: !0,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 32768,
    reasoningOutput: !1,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !0,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0,
    toolChoice: !0
  },
  "o3-deep-research": {
    maxInputTokens: 2e5,
    imageInputs: !0,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 1e5,
    reasoningOutput: !0,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !0,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0,
    toolChoice: !0
  },
  "gpt-3.5-turbo": {
    maxInputTokens: 16385,
    imageInputs: !1,
    audioInputs: !1,
    pdfInputs: !1,
    videoInputs: !1,
    maxOutputTokens: 4096,
    reasoningOutput: !1,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !1,
    structuredOutput: !1,
    imageUrlInputs: !1,
    pdfToolMessage: !1,
    imageToolMessage: !1,
    toolChoice: !0
  },
  "text-embedding-3-large": {
    maxInputTokens: 8191,
    imageInputs: !1,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 3072,
    reasoningOutput: !1,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !1,
    structuredOutput: !0,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0,
    toolChoice: !0
  },
  "gpt-4-turbo": {
    maxInputTokens: 128e3,
    imageInputs: !0,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 4096,
    reasoningOutput: !1,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !0,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0,
    toolChoice: !0
  },
  "o1-preview": {
    maxInputTokens: 128e3,
    imageInputs: !1,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 32768,
    reasoningOutput: !0,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !1,
    structuredOutput: !0,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0,
    toolChoice: !0
  },
  "o3-mini": {
    maxInputTokens: 2e5,
    imageInputs: !1,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 1e5,
    reasoningOutput: !0,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !0,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0,
    toolChoice: !0
  },
  "codex-mini-latest": {
    maxInputTokens: 2e5,
    imageInputs: !1,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 1e5,
    reasoningOutput: !0,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !0,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0,
    toolChoice: !0
  },
  "gpt-5-nano": {
    maxInputTokens: 4e5,
    imageInputs: !0,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 128e3,
    reasoningOutput: !0,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !0,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0,
    toolChoice: !0
  },
  "gpt-5-codex": {
    maxInputTokens: 4e5,
    imageInputs: !0,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 128e3,
    reasoningOutput: !0,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !0,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0,
    toolChoice: !0
  },
  "gpt-4o": {
    maxInputTokens: 128e3,
    imageInputs: !0,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 16384,
    reasoningOutput: !1,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !0,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0,
    toolChoice: !0
  },
  "gpt-4.1": {
    maxInputTokens: 1047576,
    imageInputs: !0,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 32768,
    reasoningOutput: !1,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !0,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0,
    toolChoice: !0
  },
  "o4-mini": {
    maxInputTokens: 2e5,
    imageInputs: !0,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 1e5,
    reasoningOutput: !0,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !0,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0,
    toolChoice: !0
  },
  o1: {
    maxInputTokens: 2e5,
    imageInputs: !0,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 1e5,
    reasoningOutput: !0,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !0,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0,
    toolChoice: !0
  },
  "gpt-5-mini": {
    maxInputTokens: 4e5,
    imageInputs: !0,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 128e3,
    reasoningOutput: !0,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !0,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0,
    toolChoice: !0
  },
  "o1-mini": {
    maxInputTokens: 128e3,
    imageInputs: !1,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 65536,
    reasoningOutput: !0,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !1,
    structuredOutput: !0,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0,
    toolChoice: !0
  },
  "text-embedding-ada-002": {
    maxInputTokens: 8192,
    imageInputs: !1,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 1536,
    reasoningOutput: !1,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !1,
    structuredOutput: !0,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0,
    toolChoice: !0
  },
  "o3-pro": {
    maxInputTokens: 2e5,
    imageInputs: !0,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 1e5,
    reasoningOutput: !0,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !0,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0,
    toolChoice: !0
  },
  "gpt-4o-2024-11-20": {
    maxInputTokens: 128e3,
    imageInputs: !0,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 16384,
    reasoningOutput: !1,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !0,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0,
    toolChoice: !0
  },
  o3: {
    maxInputTokens: 2e5,
    imageInputs: !0,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 1e5,
    reasoningOutput: !0,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !0,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0,
    toolChoice: !0
  },
  "o4-mini-deep-research": {
    maxInputTokens: 2e5,
    imageInputs: !0,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 1e5,
    reasoningOutput: !0,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !0,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0,
    toolChoice: !0
  },
  "gpt-5-chat-latest": {
    maxInputTokens: 4e5,
    imageInputs: !0,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 128e3,
    reasoningOutput: !0,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !1,
    structuredOutput: !0,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0,
    toolChoice: !0
  },
  "gpt-4o-mini": {
    maxInputTokens: 128e3,
    imageInputs: !0,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 16384,
    reasoningOutput: !1,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !0,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0,
    toolChoice: !0
  },
  "gpt-5": {
    maxInputTokens: 4e5,
    imageInputs: !0,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 128e3,
    reasoningOutput: !0,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !0,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0,
    toolChoice: !0
  },
  "gpt-5-pro": {
    maxInputTokens: 4e5,
    imageInputs: !0,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 272e3,
    reasoningOutput: !0,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !0,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0,
    toolChoice: !0
  }
};
var aC = sC, iC = {};
Ae(iC, {
  BasePromptValue: () => Ao,
  ChatPromptValue: () => U_,
  ImagePromptValue: () => oC,
  StringPromptValue: () => F_
});
var Ao = class extends Kn {
}, F_ = class extends Ao {
  constructor(e) {
    super({ value: e });
    v(this, "lc_namespace", ["langchain_core", "prompt_values"]);
    v(this, "lc_serializable", !0);
    v(this, "value");
    this.value = e;
  }
  static lc_name() {
    return "StringPromptValue";
  }
  toString() {
    return this.value;
  }
  toChatMessages() {
    return [new zt(this.value)];
  }
}, U_ = class extends Ao {
  constructor(e) {
    Array.isArray(e) && (e = { messages: e });
    super(e);
    v(this, "lc_namespace", ["langchain_core", "prompt_values"]);
    v(this, "lc_serializable", !0);
    v(this, "messages");
    this.messages = e.messages;
  }
  static lc_name() {
    return "ChatPromptValue";
  }
  toString() {
    return sl(this.messages);
  }
  toChatMessages() {
    return this.messages;
  }
}, oC = class extends Ao {
  constructor(e) {
    "imageUrl" in e || (e = { imageUrl: e });
    super(e);
    v(this, "lc_namespace", ["langchain_core", "prompt_values"]);
    v(this, "lc_serializable", !0);
    v(this, "imageUrl");
    /** @ignore */
    v(this, "value");
    this.imageUrl = e.imageUrl;
  }
  static lc_name() {
    return "ImagePromptValue";
  }
  toString() {
    return this.imageUrl.url;
  }
  toChatMessages() {
    return [new zt({ content: [{
      type: "image_url",
      image_url: {
        detail: this.imageUrl.detail,
        url: this.imageUrl.url
      }
    }] })];
  }
}, Q = "0123456789abcdef".split(""), cC = [
  -2147483648,
  8388608,
  32768,
  128
], nr = [
  24,
  16,
  8,
  0
], Va = [
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
], dt = [];
function hr(r, e) {
  e ? (dt[0] = dt[16] = dt[1] = dt[2] = dt[3] = dt[4] = dt[5] = dt[6] = dt[7] = dt[8] = dt[9] = dt[10] = dt[11] = dt[12] = dt[13] = dt[14] = dt[15] = 0, this.blocks = dt) : this.blocks = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
  ], r ? (this.h0 = 3238371032, this.h1 = 914150663, this.h2 = 812702999, this.h3 = 4144912697, this.h4 = 4290775857, this.h5 = 1750603025, this.h6 = 1694076839, this.h7 = 3204075428) : (this.h0 = 1779033703, this.h1 = 3144134277, this.h2 = 1013904242, this.h3 = 2773480762, this.h4 = 1359893119, this.h5 = 2600822924, this.h6 = 528734635, this.h7 = 1541459225), this.block = this.start = this.bytes = this.hBytes = 0, this.finalized = this.hashed = !1, this.first = !0, this.is224 = r;
}
hr.prototype.update = function(r) {
  if (!this.finalized) {
    var e, t = typeof r;
    if (t !== "string") {
      if (t === "object") {
        if (r === null) throw new Error(ERROR);
        if (ARRAY_BUFFER && r.constructor === ArrayBuffer) r = new Uint8Array(r);
        else if (!Array.isArray(r) && (!ARRAY_BUFFER || !ArrayBuffer.isView(r)))
          throw new Error(ERROR);
      } else throw new Error(ERROR);
      e = !0;
    }
    for (var n, s = 0, a, i = r.length, o = this.blocks; s < i; ) {
      if (this.hashed && (this.hashed = !1, o[0] = this.block, this.block = o[16] = o[1] = o[2] = o[3] = o[4] = o[5] = o[6] = o[7] = o[8] = o[9] = o[10] = o[11] = o[12] = o[13] = o[14] = o[15] = 0), e) for (a = this.start; s < i && a < 64; ++s) o[a >>> 2] |= r[s] << nr[a++ & 3];
      else for (a = this.start; s < i && a < 64; ++s)
        n = r.charCodeAt(s), n < 128 ? o[a >>> 2] |= n << nr[a++ & 3] : n < 2048 ? (o[a >>> 2] |= (192 | n >>> 6) << nr[a++ & 3], o[a >>> 2] |= (128 | n & 63) << nr[a++ & 3]) : n < 55296 || n >= 57344 ? (o[a >>> 2] |= (224 | n >>> 12) << nr[a++ & 3], o[a >>> 2] |= (128 | n >>> 6 & 63) << nr[a++ & 3], o[a >>> 2] |= (128 | n & 63) << nr[a++ & 3]) : (n = 65536 + ((n & 1023) << 10 | r.charCodeAt(++s) & 1023), o[a >>> 2] |= (240 | n >>> 18) << nr[a++ & 3], o[a >>> 2] |= (128 | n >>> 12 & 63) << nr[a++ & 3], o[a >>> 2] |= (128 | n >>> 6 & 63) << nr[a++ & 3], o[a >>> 2] |= (128 | n & 63) << nr[a++ & 3]);
      this.lastByteIndex = a, this.bytes += a - this.start, a >= 64 ? (this.block = o[16], this.start = a - 64, this.hash(), this.hashed = !0) : this.start = a;
    }
    return this.bytes > 4294967295 && (this.hBytes += this.bytes / 4294967296 << 0, this.bytes = this.bytes % 4294967296), this;
  }
};
hr.prototype.finalize = function() {
  if (!this.finalized) {
    this.finalized = !0;
    var r = this.blocks, e = this.lastByteIndex;
    r[16] = this.block, r[e >>> 2] |= cC[e & 3], this.block = r[16], e >= 56 && (this.hashed || this.hash(), r[0] = this.block, r[16] = r[1] = r[2] = r[3] = r[4] = r[5] = r[6] = r[7] = r[8] = r[9] = r[10] = r[11] = r[12] = r[13] = r[14] = r[15] = 0), r[14] = this.hBytes << 3 | this.bytes >>> 29, r[15] = this.bytes << 3, this.hash();
  }
};
hr.prototype.hash = function() {
  var r = this.h0, e = this.h1, t = this.h2, n = this.h3, s = this.h4, a = this.h5, i = this.h6, o = this.h7, c = this.blocks, u, l, d, h, f, p, y, g, S, _, w;
  for (u = 16; u < 64; ++u)
    f = c[u - 15], l = (f >>> 7 | f << 25) ^ (f >>> 18 | f << 14) ^ f >>> 3, f = c[u - 2], d = (f >>> 17 | f << 15) ^ (f >>> 19 | f << 13) ^ f >>> 10, c[u] = c[u - 16] + l + c[u - 7] + d << 0;
  for (w = e & t, u = 0; u < 64; u += 4)
    this.first ? (this.is224 ? (g = 300032, f = c[0] - 1413257819, o = f - 150054599 << 0, n = f + 24177077 << 0) : (g = 704751109, f = c[0] - 210244248, o = f - 1521486534 << 0, n = f + 143694565 << 0), this.first = !1) : (l = (r >>> 2 | r << 30) ^ (r >>> 13 | r << 19) ^ (r >>> 22 | r << 10), d = (s >>> 6 | s << 26) ^ (s >>> 11 | s << 21) ^ (s >>> 25 | s << 7), g = r & e, h = g ^ r & t ^ w, y = s & a ^ ~s & i, f = o + d + y + Va[u] + c[u], p = l + h, o = n + f << 0, n = f + p << 0), l = (n >>> 2 | n << 30) ^ (n >>> 13 | n << 19) ^ (n >>> 22 | n << 10), d = (o >>> 6 | o << 26) ^ (o >>> 11 | o << 21) ^ (o >>> 25 | o << 7), S = n & r, h = S ^ n & e ^ g, y = i & o ^ ~i & s, f = a + d + y + Va[u + 1] + c[u + 1], p = l + h, i = t + f << 0, t = f + p << 0, l = (t >>> 2 | t << 30) ^ (t >>> 13 | t << 19) ^ (t >>> 22 | t << 10), d = (i >>> 6 | i << 26) ^ (i >>> 11 | i << 21) ^ (i >>> 25 | i << 7), _ = t & n, h = _ ^ t & r ^ S, y = a & i ^ ~a & o, f = s + d + y + Va[u + 2] + c[u + 2], p = l + h, a = e + f << 0, e = f + p << 0, l = (e >>> 2 | e << 30) ^ (e >>> 13 | e << 19) ^ (e >>> 22 | e << 10), d = (a >>> 6 | a << 26) ^ (a >>> 11 | a << 21) ^ (a >>> 25 | a << 7), w = e & t, h = w ^ e & n ^ _, y = a & i ^ ~a & o, f = s + d + y + Va[u + 3] + c[u + 3], p = l + h, s = r + f << 0, r = f + p << 0, this.chromeBugWorkAround = !0;
  this.h0 = this.h0 + r << 0, this.h1 = this.h1 + e << 0, this.h2 = this.h2 + t << 0, this.h3 = this.h3 + n << 0, this.h4 = this.h4 + s << 0, this.h5 = this.h5 + a << 0, this.h6 = this.h6 + i << 0, this.h7 = this.h7 + o << 0;
};
hr.prototype.hex = function() {
  this.finalize();
  var r = this.h0, e = this.h1, t = this.h2, n = this.h3, s = this.h4, a = this.h5, i = this.h6, o = this.h7, c = Q[r >>> 28 & 15] + Q[r >>> 24 & 15] + Q[r >>> 20 & 15] + Q[r >>> 16 & 15] + Q[r >>> 12 & 15] + Q[r >>> 8 & 15] + Q[r >>> 4 & 15] + Q[r & 15] + Q[e >>> 28 & 15] + Q[e >>> 24 & 15] + Q[e >>> 20 & 15] + Q[e >>> 16 & 15] + Q[e >>> 12 & 15] + Q[e >>> 8 & 15] + Q[e >>> 4 & 15] + Q[e & 15] + Q[t >>> 28 & 15] + Q[t >>> 24 & 15] + Q[t >>> 20 & 15] + Q[t >>> 16 & 15] + Q[t >>> 12 & 15] + Q[t >>> 8 & 15] + Q[t >>> 4 & 15] + Q[t & 15] + Q[n >>> 28 & 15] + Q[n >>> 24 & 15] + Q[n >>> 20 & 15] + Q[n >>> 16 & 15] + Q[n >>> 12 & 15] + Q[n >>> 8 & 15] + Q[n >>> 4 & 15] + Q[n & 15] + Q[s >>> 28 & 15] + Q[s >>> 24 & 15] + Q[s >>> 20 & 15] + Q[s >>> 16 & 15] + Q[s >>> 12 & 15] + Q[s >>> 8 & 15] + Q[s >>> 4 & 15] + Q[s & 15] + Q[a >>> 28 & 15] + Q[a >>> 24 & 15] + Q[a >>> 20 & 15] + Q[a >>> 16 & 15] + Q[a >>> 12 & 15] + Q[a >>> 8 & 15] + Q[a >>> 4 & 15] + Q[a & 15] + Q[i >>> 28 & 15] + Q[i >>> 24 & 15] + Q[i >>> 20 & 15] + Q[i >>> 16 & 15] + Q[i >>> 12 & 15] + Q[i >>> 8 & 15] + Q[i >>> 4 & 15] + Q[i & 15];
  return this.is224 || (c += Q[o >>> 28 & 15] + Q[o >>> 24 & 15] + Q[o >>> 20 & 15] + Q[o >>> 16 & 15] + Q[o >>> 12 & 15] + Q[o >>> 8 & 15] + Q[o >>> 4 & 15] + Q[o & 15]), c;
};
hr.prototype.toString = hr.prototype.hex;
hr.prototype.digest = function() {
  this.finalize();
  var r = this.h0, e = this.h1, t = this.h2, n = this.h3, s = this.h4, a = this.h5, i = this.h6, o = this.h7, c = [
    r >>> 24 & 255,
    r >>> 16 & 255,
    r >>> 8 & 255,
    r & 255,
    e >>> 24 & 255,
    e >>> 16 & 255,
    e >>> 8 & 255,
    e & 255,
    t >>> 24 & 255,
    t >>> 16 & 255,
    t >>> 8 & 255,
    t & 255,
    n >>> 24 & 255,
    n >>> 16 & 255,
    n >>> 8 & 255,
    n & 255,
    s >>> 24 & 255,
    s >>> 16 & 255,
    s >>> 8 & 255,
    s & 255,
    a >>> 24 & 255,
    a >>> 16 & 255,
    a >>> 8 & 255,
    a & 255,
    i >>> 24 & 255,
    i >>> 16 & 255,
    i >>> 8 & 255,
    i & 255
  ];
  return this.is224 || c.push(o >>> 24 & 255, o >>> 16 & 255, o >>> 8 & 255, o & 255), c;
};
hr.prototype.array = hr.prototype.digest;
hr.prototype.arrayBuffer = function() {
  this.finalize();
  var r = /* @__PURE__ */ new ArrayBuffer(this.is224 ? 28 : 32), e = new DataView(r);
  return e.setUint32(0, this.h0), e.setUint32(4, this.h1), e.setUint32(8, this.h2), e.setUint32(12, this.h3), e.setUint32(16, this.h4), e.setUint32(20, this.h5), e.setUint32(24, this.h6), this.is224 || e.setUint32(28, this.h7), r;
};
const z_ = (...r) => new hr(!1, !0).update(r.join("")).hex();
var uC = {};
Ae(uC, { sha256: () => z_ });
var lC = {};
Ae(lC, {
  BaseCache: () => Z_,
  InMemoryCache: () => V_,
  defaultHashKeyEncoder: () => B_,
  deserializeStoredGeneration: () => dC,
  serializeGeneration: () => hC
});
const B_ = (...r) => z_(r.join("_"));
function dC(r) {
  return r.message !== void 0 ? {
    text: r.text,
    message: al(r.message)
  } : { text: r.text };
}
function hC(r) {
  const e = { text: r.text };
  return r.message !== void 0 && (e.message = r.message.toDict()), e;
}
var Z_ = class {
  constructor() {
    v(this, "keyEncoder", B_);
  }
  /**
  * Sets a custom key encoder function for the cache.
  * This function should take a prompt and an LLM key and return a string
  * that will be used as the cache key.
  * @param keyEncoderFn The custom key encoder function.
  */
  makeDefaultKeyEncoder(r) {
    this.keyEncoder = r;
  }
};
const fC = /* @__PURE__ */ new Map();
var V_ = class q_ extends Z_ {
  constructor(t) {
    super();
    v(this, "cache");
    this.cache = t ?? /* @__PURE__ */ new Map();
  }
  /**
  * Retrieves data from the cache using a prompt and an LLM key. If the
  * data is not found, it returns null.
  * @param prompt The prompt used to find the data.
  * @param llmKey The LLM key used to find the data.
  * @returns The data corresponding to the prompt and LLM key, or null if not found.
  */
  lookup(t, n) {
    return Promise.resolve(this.cache.get(this.keyEncoder(t, n)) ?? null);
  }
  /**
  * Updates the cache with new data using a prompt and an LLM key.
  * @param prompt The prompt used to store the data.
  * @param llmKey The LLM key used to store the data.
  * @param value The data to be stored.
  */
  async update(t, n, s) {
    this.cache.set(this.keyEncoder(t, n), s);
  }
  /**
  * Returns a global instance of InMemoryCache using a predefined global
  * map as the initial cache.
  * @returns A global instance of InMemoryCache.
  */
  static global() {
    return new q_(fC);
  }
}, $o = {};
$o.byteLength = gC;
$o.toByteArray = yC;
$o.fromByteArray = bC;
var wr = [], Wt = [], pC = typeof Uint8Array < "u" ? Uint8Array : Array, mc = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var Ln = 0, mC = mc.length; Ln < mC; ++Ln)
  wr[Ln] = mc[Ln], Wt[mc.charCodeAt(Ln)] = Ln;
Wt[45] = 62;
Wt[95] = 63;
function H_(r) {
  var e = r.length;
  if (e % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var t = r.indexOf("=");
  t === -1 && (t = e);
  var n = t === e ? 0 : 4 - t % 4;
  return [t, n];
}
function gC(r) {
  var e = H_(r), t = e[0], n = e[1];
  return (t + n) * 3 / 4 - n;
}
function _C(r, e, t) {
  return (e + t) * 3 / 4 - t;
}
function yC(r) {
  var e, t = H_(r), n = t[0], s = t[1], a = new pC(_C(r, n, s)), i = 0, o = s > 0 ? n - 4 : n, c;
  for (c = 0; c < o; c += 4)
    e = Wt[r.charCodeAt(c)] << 18 | Wt[r.charCodeAt(c + 1)] << 12 | Wt[r.charCodeAt(c + 2)] << 6 | Wt[r.charCodeAt(c + 3)], a[i++] = e >> 16 & 255, a[i++] = e >> 8 & 255, a[i++] = e & 255;
  return s === 2 && (e = Wt[r.charCodeAt(c)] << 2 | Wt[r.charCodeAt(c + 1)] >> 4, a[i++] = e & 255), s === 1 && (e = Wt[r.charCodeAt(c)] << 10 | Wt[r.charCodeAt(c + 1)] << 4 | Wt[r.charCodeAt(c + 2)] >> 2, a[i++] = e >> 8 & 255, a[i++] = e & 255), a;
}
function wC(r) {
  return wr[r >> 18 & 63] + wr[r >> 12 & 63] + wr[r >> 6 & 63] + wr[r & 63];
}
function vC(r, e, t) {
  for (var n, s = [], a = e; a < t; a += 3)
    n = (r[a] << 16 & 16711680) + (r[a + 1] << 8 & 65280) + (r[a + 2] & 255), s.push(wC(n));
  return s.join("");
}
function bC(r) {
  for (var e, t = r.length, n = t % 3, s = [], a = 16383, i = 0, o = t - n; i < o; i += a)
    s.push(vC(r, i, i + a > o ? o : i + a));
  return n === 1 ? (e = r[t - 1], s.push(
    wr[e >> 2] + wr[e << 4 & 63] + "=="
  )) : n === 2 && (e = (r[t - 2] << 8) + r[t - 1], s.push(
    wr[e >> 10] + wr[e >> 4 & 63] + wr[e << 2 & 63] + "="
  )), s.join("");
}
var SC = Object.defineProperty, TC = (r, e, t) => e in r ? SC(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t, EC = (r, e, t) => (TC(r, e + "", t), t);
function xC(r, e) {
  let t = Array.from(
    { length: r.length },
    (n, s) => ({ start: s, end: s + 1 })
  );
  for (; t.length > 1; ) {
    let n = null;
    for (let s = 0; s < t.length - 1; s++) {
      const a = r.slice(t[s].start, t[s + 1].end), i = e.get(a.join(","));
      i != null && (n == null || i < n[0]) && (n = [i, s]);
    }
    if (n != null) {
      const s = n[1];
      t[s] = { start: t[s].start, end: t[s + 1].end }, t.splice(s + 1, 1);
    } else
      break;
  }
  return t;
}
function IC(r, e) {
  return r.length === 1 ? [e.get(r.join(","))] : xC(r, e).map((t) => e.get(r.slice(t.start, t.end).join(","))).filter((t) => t != null);
}
function kC(r) {
  return r.replace(/[\\^$*+?.()|[\]{}]/g, "\\$&");
}
var mu = class {
  constructor(r, e) {
    /** @internal */
    v(this, "specialTokens");
    /** @internal */
    v(this, "inverseSpecialTokens");
    /** @internal */
    v(this, "patStr");
    /** @internal */
    v(this, "textEncoder", new TextEncoder());
    /** @internal */
    v(this, "textDecoder", new TextDecoder("utf-8"));
    /** @internal */
    v(this, "rankMap", /* @__PURE__ */ new Map());
    /** @internal */
    v(this, "textMap", /* @__PURE__ */ new Map());
    this.patStr = r.pat_str;
    const t = r.bpe_ranks.split(`
`).filter(Boolean).reduce((n, s) => {
      const [a, i, ...o] = s.split(" "), c = Number.parseInt(i, 10);
      return o.forEach((u, l) => n[u] = c + l), n;
    }, {});
    for (const [n, s] of Object.entries(t)) {
      const a = $o.toByteArray(n);
      this.rankMap.set(a.join(","), s), this.textMap.set(s, a);
    }
    this.specialTokens = { ...r.special_tokens, ...e }, this.inverseSpecialTokens = Object.entries(this.specialTokens).reduce((n, [s, a]) => (n[a] = this.textEncoder.encode(s), n), {});
  }
  encode(r, e = [], t = "all") {
    const n = new RegExp(this.patStr, "ug"), s = mu.specialTokenRegex(
      Object.keys(this.specialTokens)
    ), a = [], i = new Set(
      e === "all" ? Object.keys(this.specialTokens) : e
    ), o = new Set(
      t === "all" ? Object.keys(this.specialTokens).filter(
        (u) => !i.has(u)
      ) : t
    );
    if (o.size > 0) {
      const u = mu.specialTokenRegex([
        ...o
      ]), l = r.match(u);
      if (l != null)
        throw new Error(
          `The text contains a special token that is not allowed: ${l[0]}`
        );
    }
    let c = 0;
    for (; ; ) {
      let u = null, l = c;
      for (; s.lastIndex = l, u = s.exec(r), !(u == null || i.has(u[0])); )
        l = u.index + 1;
      const d = (u == null ? void 0 : u.index) ?? r.length;
      for (const f of r.substring(c, d).matchAll(n)) {
        const p = this.textEncoder.encode(f[0]), y = this.rankMap.get(p.join(","));
        if (y != null) {
          a.push(y);
          continue;
        }
        a.push(...IC(p, this.rankMap));
      }
      if (u == null)
        break;
      let h = this.specialTokens[u[0]];
      a.push(h), c = u.index + u[0].length;
    }
    return a;
  }
  decode(r) {
    const e = [];
    let t = 0;
    for (let a = 0; a < r.length; ++a) {
      const i = r[a], o = this.textMap.get(i) ?? this.inverseSpecialTokens[i];
      o != null && (e.push(o), t += o.length);
    }
    const n = new Uint8Array(t);
    let s = 0;
    for (const a of e)
      n.set(a, s), s += a.length;
    return this.textDecoder.decode(n);
  }
}, J_ = mu;
EC(J_, "specialTokenRegex", (r) => new RegExp(r.map((e) => kC(e)).join("|"), "g"));
function OC(r) {
  switch (r) {
    case "gpt2":
      return "gpt2";
    case "code-cushman-001":
    case "code-cushman-002":
    case "code-davinci-001":
    case "code-davinci-002":
    case "cushman-codex":
    case "davinci-codex":
    case "davinci-002":
    case "text-davinci-002":
    case "text-davinci-003":
      return "p50k_base";
    case "code-davinci-edit-001":
    case "text-davinci-edit-001":
      return "p50k_edit";
    case "ada":
    case "babbage":
    case "babbage-002":
    case "code-search-ada-code-001":
    case "code-search-babbage-code-001":
    case "curie":
    case "davinci":
    case "text-ada-001":
    case "text-babbage-001":
    case "text-curie-001":
    case "text-davinci-001":
    case "text-search-ada-doc-001":
    case "text-search-babbage-doc-001":
    case "text-search-curie-doc-001":
    case "text-search-davinci-doc-001":
    case "text-similarity-ada-001":
    case "text-similarity-babbage-001":
    case "text-similarity-curie-001":
    case "text-similarity-davinci-001":
      return "r50k_base";
    case "gpt-3.5-turbo-instruct-0914":
    case "gpt-3.5-turbo-instruct":
    case "gpt-3.5-turbo-16k-0613":
    case "gpt-3.5-turbo-16k":
    case "gpt-3.5-turbo-0613":
    case "gpt-3.5-turbo-0301":
    case "gpt-3.5-turbo":
    case "gpt-4-32k-0613":
    case "gpt-4-32k-0314":
    case "gpt-4-32k":
    case "gpt-4-0613":
    case "gpt-4-0314":
    case "gpt-4":
    case "gpt-3.5-turbo-1106":
    case "gpt-35-turbo":
    case "gpt-4-1106-preview":
    case "gpt-4-vision-preview":
    case "gpt-3.5-turbo-0125":
    case "gpt-4-turbo":
    case "gpt-4-turbo-2024-04-09":
    case "gpt-4-turbo-preview":
    case "gpt-4-0125-preview":
    case "text-embedding-ada-002":
    case "text-embedding-3-small":
    case "text-embedding-3-large":
      return "cl100k_base";
    case "gpt-4o":
    case "gpt-4o-2024-05-13":
    case "gpt-4o-2024-08-06":
    case "gpt-4o-2024-11-20":
    case "gpt-4o-mini-2024-07-18":
    case "gpt-4o-mini":
    case "gpt-4o-search-preview":
    case "gpt-4o-search-preview-2025-03-11":
    case "gpt-4o-mini-search-preview":
    case "gpt-4o-mini-search-preview-2025-03-11":
    case "gpt-4o-audio-preview":
    case "gpt-4o-audio-preview-2024-12-17":
    case "gpt-4o-audio-preview-2024-10-01":
    case "gpt-4o-mini-audio-preview":
    case "gpt-4o-mini-audio-preview-2024-12-17":
    case "o1":
    case "o1-2024-12-17":
    case "o1-mini":
    case "o1-mini-2024-09-12":
    case "o1-preview":
    case "o1-preview-2024-09-12":
    case "o1-pro":
    case "o1-pro-2025-03-19":
    case "o3":
    case "o3-2025-04-16":
    case "o3-mini":
    case "o3-mini-2025-01-31":
    case "o4-mini":
    case "o4-mini-2025-04-16":
    case "chatgpt-4o-latest":
    case "gpt-4o-realtime":
    case "gpt-4o-realtime-preview-2024-10-01":
    case "gpt-4o-realtime-preview-2024-12-17":
    case "gpt-4o-mini-realtime-preview":
    case "gpt-4o-mini-realtime-preview-2024-12-17":
    case "gpt-4.1":
    case "gpt-4.1-2025-04-14":
    case "gpt-4.1-mini":
    case "gpt-4.1-mini-2025-04-14":
    case "gpt-4.1-nano":
    case "gpt-4.1-nano-2025-04-14":
    case "gpt-4.5-preview":
    case "gpt-4.5-preview-2025-02-27":
    case "gpt-5":
    case "gpt-5-2025-08-07":
    case "gpt-5-nano":
    case "gpt-5-nano-2025-08-07":
    case "gpt-5-mini":
    case "gpt-5-mini-2025-08-07":
    case "gpt-5-chat-latest":
      return "o200k_base";
    default:
      throw new Error("Unknown model");
  }
}
var AC = {};
Ae(AC, {
  encodingForModel: () => Fl,
  getEncoding: () => W_
});
const qa = {}, $C = /* @__PURE__ */ new fa({});
async function W_(r) {
  return r in qa || (qa[r] = $C.fetch(`https://tiktoken.pages.dev/js/${r}.json`).then((e) => e.json()).then((e) => new J_(e)).catch((e) => {
    throw delete qa[r], e;
  })), await qa[r];
}
async function Fl(r) {
  return W_(OC(r));
}
var CC = {};
Ae(CC, {
  BaseLangChain: () => zl,
  BaseLanguageModel: () => Bl,
  calculateMaxTokens: () => NC,
  getEmbeddingContextSize: () => RC,
  getModelContextSize: () => G_,
  getModelNameForTiktoken: () => Co,
  isOpenAITool: () => Ul
});
const Co = (r) => r.startsWith("gpt-5") ? "gpt-5" : r.startsWith("gpt-3.5-turbo-16k") ? "gpt-3.5-turbo-16k" : r.startsWith("gpt-3.5-turbo-") ? "gpt-3.5-turbo" : r.startsWith("gpt-4-32k") ? "gpt-4-32k" : r.startsWith("gpt-4-") ? "gpt-4" : r.startsWith("gpt-4o") ? "gpt-4o" : r, RC = (r) => {
  switch (r) {
    case "text-embedding-ada-002":
      return 8191;
    default:
      return 2046;
  }
}, G_ = (r) => {
  switch (Co(r)) {
    case "gpt-5":
    case "gpt-5-turbo":
    case "gpt-5-turbo-preview":
      return 4e5;
    case "gpt-4o":
    case "gpt-4o-mini":
    case "gpt-4o-2024-05-13":
    case "gpt-4o-2024-08-06":
      return 128e3;
    case "gpt-4-turbo":
    case "gpt-4-turbo-preview":
    case "gpt-4-turbo-2024-04-09":
    case "gpt-4-0125-preview":
    case "gpt-4-1106-preview":
      return 128e3;
    case "gpt-4-32k":
    case "gpt-4-32k-0314":
    case "gpt-4-32k-0613":
      return 32768;
    case "gpt-4":
    case "gpt-4-0314":
    case "gpt-4-0613":
      return 8192;
    case "gpt-3.5-turbo-16k":
    case "gpt-3.5-turbo-16k-0613":
      return 16384;
    case "gpt-3.5-turbo":
    case "gpt-3.5-turbo-0301":
    case "gpt-3.5-turbo-0613":
    case "gpt-3.5-turbo-1106":
    case "gpt-3.5-turbo-0125":
      return 4096;
    case "text-davinci-003":
    case "text-davinci-002":
      return 4097;
    case "text-davinci-001":
      return 2049;
    case "text-curie-001":
    case "text-babbage-001":
    case "text-ada-001":
      return 2048;
    case "code-davinci-002":
    case "code-davinci-001":
      return 8e3;
    case "code-cushman-001":
      return 2048;
    case "claude-3-5-sonnet-20241022":
    case "claude-3-5-sonnet-20240620":
    case "claude-3-opus-20240229":
    case "claude-3-sonnet-20240229":
    case "claude-3-haiku-20240307":
    case "claude-2.1":
      return 2e5;
    case "claude-2.0":
    case "claude-instant-1.2":
      return 1e5;
    case "gemini-1.5-pro":
    case "gemini-1.5-pro-latest":
    case "gemini-1.5-flash":
    case "gemini-1.5-flash-latest":
      return 1e6;
    case "gemini-pro":
    case "gemini-pro-vision":
      return 32768;
    default:
      return 4097;
  }
};
function Ul(r) {
  return typeof r != "object" || !r ? !1 : !!("type" in r && r.type === "function" && "function" in r && typeof r.function == "object" && r.function && "name" in r.function && "parameters" in r.function);
}
const NC = async ({ prompt: r, modelName: e }) => {
  let t;
  try {
    t = (await Fl(Co(e))).encode(r).length;
  } catch {
    console.warn("Failed to calculate number of tokens, falling back to approximate count"), t = Math.ceil(r.length / 4);
  }
  return G_(e) - t;
}, PC = () => !1;
var zl = class extends Ye {
  constructor(e) {
    super(e);
    /**
    * Whether to print out response text.
    */
    v(this, "verbose");
    v(this, "callbacks");
    v(this, "tags");
    v(this, "metadata");
    this.verbose = e.verbose ?? PC(), this.callbacks = e.callbacks, this.tags = e.tags ?? [], this.metadata = e.metadata ?? {};
  }
  get lc_attributes() {
    return {
      callbacks: void 0,
      verbose: void 0
    };
  }
}, Bl = class extends zl {
  constructor({ callbacks: e, callbackManager: t, ...n }) {
    const { cache: s, ...a } = n;
    super({
      callbacks: e ?? t,
      ...a
    });
    /**
    * The async caller should be used by subclasses to make any async calls,
    * which will thus benefit from the concurrency and retry logic.
    */
    v(this, "caller");
    v(this, "cache");
    v(this, "_encoding");
    typeof s == "object" ? this.cache = s : s ? this.cache = V_.global() : this.cache = void 0, this.caller = new fa(n ?? {});
  }
  /**
  * Keys that the language model accepts as call options.
  */
  get callKeys() {
    return [
      "stop",
      "timeout",
      "signal",
      "tags",
      "metadata",
      "callbacks"
    ];
  }
  /**
  * Get the number of tokens in the content.
  * @param content The content to get the number of tokens for.
  * @returns The number of tokens in the content.
  */
  async getNumTokens(e) {
    let t;
    typeof e == "string" ? t = e : t = e.map((s) => typeof s == "string" ? s : s.type === "text" && "text" in s ? s.text : "").join("");
    let n = Math.ceil(t.length / 4);
    if (!this._encoding) try {
      this._encoding = await Fl("modelName" in this ? Co(this.modelName) : "gpt2");
    } catch (s) {
      console.warn("Failed to calculate number of tokens, falling back to approximate count", s);
    }
    if (this._encoding) try {
      n = this._encoding.encode(t).length;
    } catch (s) {
      console.warn("Failed to calculate number of tokens, falling back to approximate count", s);
    }
    return n;
  }
  static _convertInputToPromptValue(e) {
    return typeof e == "string" ? new F_(e) : Array.isArray(e) ? new U_(e.map(Ds)) : e;
  }
  /**
  * Get the identifying parameters of the LLM.
  */
  _identifyingParams() {
    return {};
  }
  /**
  * Create a unique cache key for a specific call to a specific language model.
  * @param callOptions Call options for the model
  * @returns A unique cache key.
  */
  _getSerializedCacheKeyParametersForCall({ config: e, ...t }) {
    const n = {
      ...this._identifyingParams(),
      ...t,
      _type: this._llmType(),
      _model: this._modelType()
    };
    return Object.entries(n).filter(([i, o]) => o !== void 0).map(([i, o]) => `${i}:${JSON.stringify(o)}`).sort().join(",");
  }
  /**
  * @deprecated
  * Return a json-like object representing this LLM.
  */
  serialize() {
    return {
      ...this._identifyingParams(),
      _type: this._llmType(),
      _model: this._modelType()
    };
  }
  /**
  * @deprecated
  * Load an LLM from a json-like object describing it.
  */
  static async deserialize(e) {
    throw new Error("Use .toJSON() instead");
  }
  /**
  * Return profiling information for the model.
  *
  * @returns {ModelProfile} An object describing the model's capabilities and constraints
  */
  get profile() {
    return {};
  }
}, as = class extends Ye {
  constructor(e) {
    super(e);
    v(this, "lc_namespace", ["langchain_core", "runnables"]);
    v(this, "lc_serializable", !0);
    v(this, "func");
    e && (this.func = e.func);
  }
  static lc_name() {
    return "RunnablePassthrough";
  }
  async invoke(e, t) {
    const n = Ce(t);
    return this.func && await this.func(e, n), this._callWithConfig((s) => Promise.resolve(s), e, n);
  }
  async *transform(e, t) {
    const n = Ce(t);
    let s, a = !0;
    for await (const i of this._transformStreamWithConfig(e, (o) => o, n))
      if (yield i, a) if (s === void 0) s = i;
      else try {
        s = sn(s, i);
      } catch {
        s = void 0, a = !1;
      }
    this.func && s !== void 0 && await this.func(s, n);
  }
  /**
  * A runnable that assigns key-value pairs to the input.
  *
  * The example below shows how you could use it with an inline function.
  *
  * @example
  * ```typescript
  * const prompt =
  *   PromptTemplate.fromTemplate(`Write a SQL query to answer the question using the following schema: {schema}
  * Question: {question}
  * SQL Query:`);
  *
  * // The `RunnablePassthrough.assign()` is used here to passthrough the input from the `.invoke()`
  * // call (in this example it's the question), along with any inputs passed to the `.assign()` method.
  * // In this case, we're passing the schema.
  * const sqlQueryGeneratorChain = RunnableSequence.from([
  *   RunnablePassthrough.assign({
  *     schema: async () => db.getTableInfo(),
  *   }),
  *   prompt,
  *   new ChatOpenAI({ model: "gpt-4o-mini" }).withConfig({ stop: ["\nSQLResult:"] }),
  *   new StringOutputParser(),
  * ]);
  * const result = await sqlQueryGeneratorChain.invoke({
  *   question: "How many employees are there?",
  * });
  * ```
  */
  static assign(e) {
    return new Nl(new ds({ steps: e }));
  }
};
const LC = (r) => r();
function gc(r) {
  const e = r.constructor;
  return new e({
    ...r,
    content: r.contentBlocks,
    response_metadata: {
      ...r.response_metadata,
      output_version: "v1"
    }
  });
}
var MC = {};
Ae(MC, {
  BaseChatModel: () => Zl,
  SimpleChatModel: () => DC
});
function _c(r) {
  const e = [];
  for (const t of r) {
    let n = t;
    if (Array.isArray(t.content)) for (let s = 0; s < t.content.length; s++) {
      const a = t.content[s];
      (Ju(a) || Wu(a)) && n === t && (n = new t.constructor({
        ...n,
        content: [
          ...t.content.slice(0, s),
          om(a),
          ...t.content.slice(s + 1)
        ]
      }));
    }
    e.push(n);
  }
  return e;
}
var Zl = class pn extends Bl {
  constructor(t) {
    super(t);
    v(this, "lc_namespace", [
      "langchain",
      "chat_models",
      this._llmType()
    ]);
    v(this, "disableStreaming", !1);
    v(this, "outputVersion");
    this.outputVersion = LC(() => {
      const n = t.outputVersion ?? Er("LC_OUTPUT_VERSION");
      return n && ["v0", "v1"].includes(n) ? n : "v0";
    });
  }
  get callKeys() {
    return [...super.callKeys, "outputVersion"];
  }
  _separateRunnableConfigFromCallOptionsCompat(t) {
    const [n, s] = super._separateRunnableConfigFromCallOptions(t);
    return s.signal = n.signal, [n, s];
  }
  /**
  * Invokes the chat model with a single input.
  * @param input The input for the language model.
  * @param options The call options.
  * @returns A Promise that resolves to a BaseMessageChunk.
  */
  async invoke(t, n) {
    const s = pn._convertInputToPromptValue(t);
    return (await this.generatePrompt([s], n, n == null ? void 0 : n.callbacks)).generations[0][0].message;
  }
  async *_streamResponseChunks(t, n, s) {
    throw new Error("Not implemented.");
  }
  async *_streamIterator(t, n) {
    var s;
    if (this._streamResponseChunks === pn.prototype._streamResponseChunks || this.disableStreaming) yield this.invoke(t, n);
    else {
      const i = pn._convertInputToPromptValue(t).toChatMessages(), [o, c] = this._separateRunnableConfigFromCallOptionsCompat(n), u = {
        ...o.metadata,
        ...this.getLsParams(c)
      }, l = await Pt.configure(o.callbacks, this.callbacks, o.tags, this.tags, u, this.metadata, { verbose: this.verbose }), d = {
        options: c,
        invocation_params: this == null ? void 0 : this.invocationParams(c),
        batch_size: 1
      }, h = c.outputVersion ?? this.outputVersion, f = await (l == null ? void 0 : l.handleChatModelStart(this.toJSON(), [_c(i)], o.runId, void 0, d, void 0, void 0, o.runName));
      let p, y;
      try {
        for await (const g of this._streamResponseChunks(i, c, f == null ? void 0 : f[0])) {
          if (g.message.id == null) {
            const S = (s = f == null ? void 0 : f.at(0)) == null ? void 0 : s.runId;
            S != null && g.message._updateId(`run-${S}`);
          }
          g.message.response_metadata = {
            ...g.generationInfo,
            ...g.message.response_metadata
          }, h === "v1" ? yield gc(g.message) : yield g.message, p ? p = p.concat(g) : p = g, Lc(g.message) && g.message.usage_metadata !== void 0 && (y = { tokenUsage: {
            promptTokens: g.message.usage_metadata.input_tokens,
            completionTokens: g.message.usage_metadata.output_tokens,
            totalTokens: g.message.usage_metadata.total_tokens
          } });
        }
      } catch (g) {
        throw await Promise.all((f ?? []).map((S) => S == null ? void 0 : S.handleLLMError(g))), g;
      }
      await Promise.all((f ?? []).map((g) => g == null ? void 0 : g.handleLLMEnd({
        generations: [[p]],
        llmOutput: y
      })));
    }
  }
  getLsParams(t) {
    const n = this.getName().startsWith("Chat") ? this.getName().replace("Chat", "") : this.getName();
    return {
      ls_model_type: "chat",
      ls_stop: t.stop,
      ls_provider: n
    };
  }
  /** @ignore */
  async _generateUncached(t, n, s, a) {
    var f, p;
    const i = t.map((y) => y.map(Ds));
    let o;
    if (a !== void 0 && a.length === i.length) o = a;
    else {
      const y = {
        ...s.metadata,
        ...this.getLsParams(n)
      }, g = await Pt.configure(s.callbacks, this.callbacks, s.tags, this.tags, y, this.metadata, { verbose: this.verbose }), S = {
        options: n,
        invocation_params: this == null ? void 0 : this.invocationParams(n),
        batch_size: 1
      };
      o = await (g == null ? void 0 : g.handleChatModelStart(this.toJSON(), i.map(_c), s.runId, void 0, S, void 0, void 0, s.runName));
    }
    const c = n.outputVersion ?? this.outputVersion, u = [], l = [];
    if (!!(o != null && o[0].handlers.find(ol)) && !this.disableStreaming && i.length === 1 && this._streamResponseChunks !== pn.prototype._streamResponseChunks) try {
      const y = await this._streamResponseChunks(i[0], n, o == null ? void 0 : o[0]);
      let g, S;
      for await (const _ of y) {
        if (_.message.id == null) {
          const w = (f = o == null ? void 0 : o.at(0)) == null ? void 0 : f.runId;
          w != null && _.message._updateId(`run-${w}`);
        }
        g === void 0 ? g = _ : g = sn(g, _), Lc(_.message) && _.message.usage_metadata !== void 0 && (S = { tokenUsage: {
          promptTokens: _.message.usage_metadata.input_tokens,
          completionTokens: _.message.usage_metadata.output_tokens,
          totalTokens: _.message.usage_metadata.total_tokens
        } });
      }
      if (g === void 0) throw new Error("Received empty response from chat model call.");
      u.push([g]), await (o == null ? void 0 : o[0].handleLLMEnd({
        generations: u,
        llmOutput: S
      }));
    } catch (y) {
      throw await (o == null ? void 0 : o[0].handleLLMError(y)), y;
    }
    else {
      const y = await Promise.allSettled(i.map(async (g, S) => {
        const _ = await this._generate(g, {
          ...n,
          promptIndex: S
        }, o == null ? void 0 : o[S]);
        if (c === "v1") for (const w of _.generations) w.message = gc(w.message);
        return _;
      }));
      await Promise.all(y.map(async (g, S) => {
        var _, w, T;
        if (g.status === "fulfilled") {
          const x = g.value;
          for (const A of x.generations) {
            if (A.message.id == null) {
              const R = (_ = o == null ? void 0 : o.at(0)) == null ? void 0 : _.runId;
              R != null && A.message._updateId(`run-${R}`);
            }
            A.message.response_metadata = {
              ...A.generationInfo,
              ...A.message.response_metadata
            };
          }
          return x.generations.length === 1 && (x.generations[0].message.response_metadata = {
            ...x.llmOutput,
            ...x.generations[0].message.response_metadata
          }), u[S] = x.generations, l[S] = x.llmOutput, (w = o == null ? void 0 : o[S]) == null ? void 0 : w.handleLLMEnd({
            generations: [x.generations],
            llmOutput: x.llmOutput
          });
        } else
          return await ((T = o == null ? void 0 : o[S]) == null ? void 0 : T.handleLLMError(g.reason)), Promise.reject(g.reason);
      }));
    }
    const h = {
      generations: u,
      llmOutput: l.length ? (p = this._combineLLMOutput) == null ? void 0 : p.call(this, ...l) : void 0
    };
    return Object.defineProperty(h, Ys, {
      value: o ? { runIds: o == null ? void 0 : o.map((y) => y.runId) } : void 0,
      configurable: !0
    }), h;
  }
  async _generateCached({ messages: t, cache: n, llmStringKey: s, parsedOptions: a, handledOptions: i }) {
    const o = t.map((_) => _.map(Ds)), c = {
      ...i.metadata,
      ...this.getLsParams(a)
    }, u = await Pt.configure(i.callbacks, this.callbacks, i.tags, this.tags, c, this.metadata, { verbose: this.verbose }), l = {
      options: a,
      invocation_params: this == null ? void 0 : this.invocationParams(a),
      batch_size: 1
    }, d = await (u == null ? void 0 : u.handleChatModelStart(this.toJSON(), o.map(_c), i.runId, void 0, l, void 0, void 0, i.runName)), h = [], p = (await Promise.allSettled(o.map(async (_, w) => {
      const T = pn._convertInputToPromptValue(_).toString(), x = await n.lookup(T, s);
      return x == null && h.push(w), x;
    }))).map((_, w) => ({
      result: _,
      runManager: d == null ? void 0 : d[w]
    })).filter(({ result: _ }) => _.status === "fulfilled" && _.value != null || _.status === "rejected"), y = a.outputVersion ?? this.outputVersion, g = [];
    await Promise.all(p.map(async ({ result: _, runManager: w }, T) => {
      if (_.status === "fulfilled") {
        const x = _.value;
        return g[T] = x.map((A) => ("message" in A && Xr(A.message) && oo(A.message) && (A.message.usage_metadata = {
          input_tokens: 0,
          output_tokens: 0,
          total_tokens: 0
        }, y === "v1" && (A.message = gc(A.message))), A.generationInfo = {
          ...A.generationInfo,
          tokenUsage: {}
        }, A)), x.length && await (w == null ? void 0 : w.handleLLMNewToken(x[0].text)), w == null ? void 0 : w.handleLLMEnd({ generations: [x] }, void 0, void 0, void 0, { cached: !0 });
      } else
        return await (w == null ? void 0 : w.handleLLMError(_.reason, void 0, void 0, void 0, { cached: !0 })), Promise.reject(_.reason);
    }));
    const S = {
      generations: g,
      missingPromptIndices: h,
      startedRunManagers: d
    };
    return Object.defineProperty(S, Ys, {
      value: d ? { runIds: d == null ? void 0 : d.map((_) => _.runId) } : void 0,
      configurable: !0
    }), S;
  }
  /**
  * Generates chat based on the input messages.
  * @param messages An array of arrays of BaseMessage instances.
  * @param options The call options or an array of stop sequences.
  * @param callbacks The callbacks for the language model.
  * @returns A Promise that resolves to an LLMResult.
  */
  async generate(t, n, s) {
    let a;
    Array.isArray(n) ? a = { stop: n } : a = n;
    const i = t.map((y) => y.map(Ds)), [o, c] = this._separateRunnableConfigFromCallOptionsCompat(a);
    if (o.callbacks = o.callbacks ?? s, !this.cache) return this._generateUncached(i, c, o);
    const { cache: u } = this, l = this._getSerializedCacheKeyParametersForCall(c), { generations: d, missingPromptIndices: h, startedRunManagers: f } = await this._generateCached({
      messages: i,
      cache: u,
      llmStringKey: l,
      parsedOptions: c,
      handledOptions: o
    });
    let p = {};
    if (h.length > 0) {
      const y = await this._generateUncached(h.map((g) => i[g]), c, o, f !== void 0 ? h.map((g) => f == null ? void 0 : f[g]) : void 0);
      await Promise.all(y.generations.map(async (g, S) => {
        const _ = h[S];
        d[_] = g;
        const w = pn._convertInputToPromptValue(i[_]).toString();
        return u.update(w, l, g);
      })), p = y.llmOutput ?? {};
    }
    return {
      generations: d,
      llmOutput: p
    };
  }
  /**
  * Get the parameters used to invoke the model
  */
  invocationParams(t) {
    return {};
  }
  _modelType() {
    return "base_chat_model";
  }
  /**
  * Generates a prompt based on the input prompt values.
  * @param promptValues An array of BasePromptValue instances.
  * @param options The call options or an array of stop sequences.
  * @param callbacks The callbacks for the language model.
  * @returns A Promise that resolves to an LLMResult.
  */
  async generatePrompt(t, n, s) {
    const a = t.map((i) => i.toChatMessages());
    return this.generate(a, n, s);
  }
  withStructuredOutput(t, n) {
    if (typeof this.bindTools != "function") throw new Error('Chat model must implement ".bindTools()" to use withStructuredOutput.');
    if (n != null && n.strict) throw new Error('"strict" mode is not supported for this model by default.');
    const s = t, a = n == null ? void 0 : n.name, i = Eo(s) ?? "A function available to call.", o = n == null ? void 0 : n.method, c = n == null ? void 0 : n.includeRaw;
    if (o === "jsonMode") throw new Error('Base withStructuredOutput implementation only supports "functionCalling" as a method.');
    let u = a ?? "extract", l;
    br(s) ? l = [{
      type: "function",
      function: {
        name: u,
        description: i,
        parameters: Sr(s)
      }
    }] : ("name" in s && (u = s.name), l = [{
      type: "function",
      function: {
        name: u,
        description: i,
        parameters: s
      }
    }]);
    const d = this.bindTools(l), h = qr.from((g) => {
      if (!Ar.isInstance(g)) throw new Error("Input is not an AIMessageChunk.");
      if (!g.tool_calls || g.tool_calls.length === 0) throw new Error("No tool calls found in the response.");
      const S = g.tool_calls.find((_) => _.name === u);
      if (!S) throw new Error(`No tool call found with name ${u}.`);
      return S.args;
    });
    if (!c) return d.pipe(h).withConfig({ runName: "StructuredOutput" });
    const f = as.assign({ parsed: (g, S) => h.invoke(g.raw, S) }), p = as.assign({ parsed: () => null }), y = f.withFallbacks({ fallbacks: [p] });
    return pa.from([{ raw: d }, y]).withConfig({ runName: "StructuredOutputRunnable" });
  }
}, DC = class extends Zl {
  async _generate(r, e, t) {
    const n = await this._call(r, e, t), s = new Fe(n);
    if (typeof s.content != "string") throw new Error("Cannot generate with a simple chat model when output is not a string.");
    return { generations: [{
      text: s.content,
      message: s
    }] };
  }
}, jC = class extends Ye {
  constructor(e) {
    super(e);
    v(this, "lc_namespace", ["langchain_core", "runnables"]);
    v(this, "lc_serializable", !0);
    v(this, "runnables");
    this.runnables = e.runnables;
  }
  static lc_name() {
    return "RouterRunnable";
  }
  async invoke(e, t) {
    const { key: n, input: s } = e, a = this.runnables[n];
    if (a === void 0) throw new Error(`No runnable associated with key "${n}".`);
    return a.invoke(s, Ce(t));
  }
  async batch(e, t, n) {
    var h;
    const s = e.map((f) => f.key), a = e.map((f) => f.input);
    if (s.find((f) => this.runnables[f] === void 0) !== void 0) throw new Error("One or more keys do not have a corresponding runnable.");
    const o = s.map((f) => this.runnables[f]), c = this._getOptionsList(t ?? {}, e.length), u = ((h = c[0]) == null ? void 0 : h.maxConcurrency) ?? (n == null ? void 0 : n.maxConcurrency), l = u && u > 0 ? u : e.length, d = [];
    for (let f = 0; f < a.length; f += l) {
      const p = a.slice(f, f + l).map((g, S) => o[S].invoke(g, c[S])), y = await Promise.all(p);
      d.push(y);
    }
    return d.flat();
  }
  async stream(e, t) {
    const { key: n, input: s } = e, a = this.runnables[n];
    if (a === void 0) throw new Error(`No runnable associated with key "${n}".`);
    return a.stream(s, t);
  }
}, FC = class extends Ye {
  constructor(e) {
    super(e);
    v(this, "lc_namespace", ["langchain_core", "runnables"]);
    v(this, "lc_serializable", !0);
    v(this, "default");
    v(this, "branches");
    this.branches = e.branches, this.default = e.default;
  }
  static lc_name() {
    return "RunnableBranch";
  }
  /**
  * Convenience method for instantiating a RunnableBranch from
  * RunnableLikes (objects, functions, or Runnables).
  *
  * Each item in the input except for the last one should be a
  * tuple with two items. The first is a "condition" RunnableLike that
  * returns "true" if the second RunnableLike in the tuple should run.
  *
  * The final item in the input should be a RunnableLike that acts as a
  * default branch if no other branches match.
  *
  * @example
  * ```ts
  * import { RunnableBranch } from "@langchain/core/runnables";
  *
  * const branch = RunnableBranch.from([
  *   [(x: number) => x > 0, (x: number) => x + 1],
  *   [(x: number) => x < 0, (x: number) => x - 1],
  *   (x: number) => x
  * ]);
  * ```
  * @param branches An array where the every item except the last is a tuple of [condition, runnable]
  *   pairs. The last item is a default runnable which is invoked if no other condition matches.
  * @returns A new RunnableBranch.
  */
  static from(e) {
    if (e.length < 1) throw new Error("RunnableBranch requires at least one branch");
    const n = e.slice(0, -1).map(([a, i]) => [ur(a), ur(i)]), s = ur(e[e.length - 1]);
    return new this({
      branches: n,
      default: s
    });
  }
  async _invoke(e, t, n) {
    let s;
    for (let a = 0; a < this.branches.length; a += 1) {
      const [i, o] = this.branches[a];
      if (await i.invoke(e, Be(t, { callbacks: n == null ? void 0 : n.getChild(`condition:${a + 1}`) }))) {
        s = await o.invoke(e, Be(t, { callbacks: n == null ? void 0 : n.getChild(`branch:${a + 1}`) }));
        break;
      }
    }
    return s || (s = await this.default.invoke(e, Be(t, { callbacks: n == null ? void 0 : n.getChild("branch:default") }))), s;
  }
  async invoke(e, t = {}) {
    return this._callWithConfig(this._invoke, e, t);
  }
  async *_streamIterator(e, t) {
    const n = await Zt(t), s = await (n == null ? void 0 : n.handleChainStart(this.toJSON(), ut(e, "input"), t == null ? void 0 : t.runId, void 0, void 0, void 0, t == null ? void 0 : t.runName));
    let a, i = !0, o;
    try {
      for (let c = 0; c < this.branches.length; c += 1) {
        const [u, l] = this.branches[c];
        if (await u.invoke(e, Be(t, { callbacks: s == null ? void 0 : s.getChild(`condition:${c + 1}`) }))) {
          o = await l.stream(e, Be(t, { callbacks: s == null ? void 0 : s.getChild(`branch:${c + 1}`) }));
          for await (const h of o)
            if (yield h, i) if (a === void 0) a = h;
            else try {
              a = sn(a, h);
            } catch {
              a = void 0, i = !1;
            }
          break;
        }
      }
      if (o === void 0) {
        o = await this.default.stream(e, Be(t, { callbacks: s == null ? void 0 : s.getChild("branch:default") }));
        for await (const c of o)
          if (yield c, i) if (a === void 0) a = c;
          else try {
            a = sn(a, c);
          } catch {
            a = void 0, i = !1;
          }
      }
    } catch (c) {
      throw await (s == null ? void 0 : s.handleChainError(c)), c;
    }
    await (s == null ? void 0 : s.handleChainEnd(a ?? {}));
  }
}, UC = class extends ss {
  constructor(e) {
    let t = qr.from((i, o) => this._enterHistory(i, o ?? {})).withConfig({ runName: "loadHistory" });
    const n = e.historyMessagesKey ?? e.inputMessagesKey;
    n && (t = as.assign({ [n]: t }).withConfig({ runName: "insertHistory" }));
    const s = t.pipe(e.runnable.withListeners({ onEnd: (i, o) => this._exitHistory(i, o ?? {}) })).withConfig({ runName: "RunnableWithMessageHistory" }), a = e.config ?? {};
    super({
      ...e,
      config: a,
      bound: s
    });
    v(this, "runnable");
    v(this, "inputMessagesKey");
    v(this, "outputMessagesKey");
    v(this, "historyMessagesKey");
    v(this, "getMessageHistory");
    this.runnable = e.runnable, this.getMessageHistory = e.getMessageHistory, this.inputMessagesKey = e.inputMessagesKey, this.outputMessagesKey = e.outputMessagesKey, this.historyMessagesKey = e.historyMessagesKey;
  }
  _getInputMessages(e) {
    let t;
    if (typeof e == "object" && !Array.isArray(e) && !Xr(e)) {
      let n;
      this.inputMessagesKey ? n = this.inputMessagesKey : Object.keys(e).length === 1 ? n = Object.keys(e)[0] : n = "input", Array.isArray(e[n]) && Array.isArray(e[n][0]) ? t = e[n][0] : t = e[n];
    } else t = e;
    if (typeof t == "string") return [new zt(t)];
    if (Array.isArray(t)) return t;
    if (Xr(t)) return [t];
    throw new Error(`Expected a string, BaseMessage, or array of BaseMessages.
Got ${JSON.stringify(t, null, 2)}`);
  }
  _getOutputMessages(e) {
    let t;
    if (!Array.isArray(e) && !Xr(e) && typeof e != "string") {
      let n;
      this.outputMessagesKey !== void 0 ? n = this.outputMessagesKey : Object.keys(e).length === 1 ? n = Object.keys(e)[0] : n = "output", e.generations !== void 0 ? t = e.generations[0][0].message : t = e[n];
    } else t = e;
    if (typeof t == "string") return [new Fe(t)];
    if (Array.isArray(t)) return t;
    if (Xr(t)) return [t];
    throw new Error(`Expected a string, BaseMessage, or array of BaseMessages. Received: ${JSON.stringify(t, null, 2)}`);
  }
  async _enterHistory(e, t) {
    var a;
    const s = await ((a = t == null ? void 0 : t.configurable) == null ? void 0 : a.messageHistory).getMessages();
    return this.historyMessagesKey === void 0 ? s.concat(this._getInputMessages(e)) : s;
  }
  async _exitHistory(e, t) {
    var c;
    const n = (c = t.configurable) == null ? void 0 : c.messageHistory;
    let s;
    Array.isArray(e.inputs) && Array.isArray(e.inputs[0]) ? s = e.inputs[0] : s = e.inputs;
    let a = this._getInputMessages(s);
    if (this.historyMessagesKey === void 0) {
      const u = await n.getMessages();
      a = a.slice(u.length);
    }
    const i = e.outputs;
    if (!i) throw new Error(`Output values from 'Run' undefined. Run: ${JSON.stringify(e, null, 2)}`);
    const o = this._getOutputMessages(i);
    await n.addMessages([...a, ...o]);
  }
  async _mergeConfig(...e) {
    const t = await super._mergeConfig(...e);
    if (!t.configurable || !t.configurable.sessionId) {
      const s = { [this.inputMessagesKey ?? "input"]: "foo" }, a = { configurable: { sessionId: "123" } };
      throw new Error(`sessionId is required. Pass it in as part of the config argument to .invoke() or .stream()
eg. chain.invoke(${JSON.stringify(s)}, ${JSON.stringify(a)})`);
    }
    const { sessionId: n } = t.configurable;
    return t.configurable.messageHistory = await this.getMessageHistory(n), t;
  }
}, zC = {};
Ae(zC, {
  RouterRunnable: () => jC,
  Runnable: () => Ye,
  RunnableAssign: () => Nl,
  RunnableBinding: () => ss,
  RunnableBranch: () => FC,
  RunnableEach: () => vO,
  RunnableLambda: () => qr,
  RunnableMap: () => ds,
  RunnableParallel: () => TO,
  RunnablePassthrough: () => as,
  RunnablePick: () => T_,
  RunnableRetry: () => Rl,
  RunnableSequence: () => pa,
  RunnableToolLike: () => du,
  RunnableWithFallbacks: () => S_,
  RunnableWithMessageHistory: () => UC,
  _coerceToRunnable: () => ur,
  ensureConfig: () => Ce,
  getCallbackManagerForConfig: () => Zt,
  mergeConfigs: () => xi,
  patchConfig: () => Be,
  pickRunnableConfigKeys: () => Ur,
  raceWithSignal: () => zr
});
var K_ = class extends Ye {
  /**
  * Parses the result of an LLM call with a given prompt. By default, it
  * simply calls `parseResult`.
  * @param generations The generations from an LLM call.
  * @param _prompt The prompt used in the LLM call.
  * @param callbacks Optional callbacks.
  * @returns A promise of the parsed output.
  */
  parseResultWithPrompt(r, e, t) {
    return this.parseResult(r, t);
  }
  _baseMessageToString(r) {
    return typeof r.content == "string" ? r.content : this._baseMessageContentToString(r.content);
  }
  _baseMessageContentToString(r) {
    return JSON.stringify(r);
  }
  /**
  * Calls the parser with a given input and optional configuration options.
  * If the input is a string, it creates a generation with the input as
  * text and calls `parseResult`. If the input is a `BaseMessage`, it
  * creates a generation with the input as a message and the content of the
  * input as text, and then calls `parseResult`.
  * @param input The input to the parser, which can be a string or a `BaseMessage`.
  * @param options Optional configuration options.
  * @returns A promise of the parsed output.
  */
  async invoke(r, e) {
    return typeof r == "string" ? this._callWithConfig(async (t, n) => this.parseResult([{ text: t }], n == null ? void 0 : n.callbacks), r, {
      ...e,
      runType: "parser"
    }) : this._callWithConfig(async (t, n) => this.parseResult([{
      message: t,
      text: this._baseMessageToString(t)
    }], n == null ? void 0 : n.callbacks), r, {
      ...e,
      runType: "parser"
    });
  }
}, Ro = class extends K_ {
  parseResult(r, e) {
    return this.parse(r[0].text, e);
  }
  async parseWithPrompt(r, e, t) {
    return this.parse(r, t);
  }
  /**
  * Return the string type key uniquely identifying this class of parser
  */
  _type() {
    throw new Error("_type not implemented");
  }
}, jr = class extends Error {
  constructor(e, t, n, s = !1) {
    super(e);
    v(this, "llmOutput");
    v(this, "observation");
    v(this, "sendToLLM");
    if (this.llmOutput = t, this.observation = n, this.sendToLLM = s, s && (n === void 0 || t === void 0))
      throw new Error("Arguments 'observation' & 'llmOutput' are required if 'sendToLlm' is true");
    Im(this, "OUTPUT_PARSING_FAILURE");
  }
}, _a = class extends Ro {
  async *_transform(r) {
    for await (const e of r) typeof e == "string" ? yield this.parseResult([{ text: e }]) : yield this.parseResult([{
      message: e,
      text: this._baseMessageToString(e)
    }]);
  }
  /**
  * Transforms an asynchronous generator of input into an asynchronous
  * generator of parsed output.
  * @param inputGenerator An asynchronous generator of input.
  * @param options A configuration object.
  * @returns An asynchronous generator of parsed output.
  */
  async *transform(r, e) {
    yield* this._transformStreamWithConfig(r, this._transform.bind(this), {
      ...e,
      runType: "parser"
    });
  }
}, No = class extends _a {
  constructor(e) {
    super(e);
    v(this, "diff", !1);
    this.diff = (e == null ? void 0 : e.diff) ?? this.diff;
  }
  async *_transform(e) {
    let t, n;
    for await (const s of e) {
      if (typeof s != "string" && typeof s.content != "string") throw new Error("Cannot handle non-string output.");
      let a;
      if (el(s)) {
        if (typeof s.content != "string") throw new Error("Cannot handle non-string message output.");
        a = new Qn({
          message: s,
          text: s.content
        });
      } else if (Xr(s)) {
        if (typeof s.content != "string") throw new Error("Cannot handle non-string message output.");
        a = new Qn({
          message: Si(s),
          text: s.content
        });
      } else a = new Xn({ text: s });
      n === void 0 ? n = a : n = n.concat(a);
      const i = await this.parsePartialResult([n]);
      i != null && !vn(i, t) && (this.diff ? yield this._diff(t, i) : yield i, t = i);
    }
  }
  getFormatInstructions() {
    return "";
  }
}, BC = {};
Ae(BC, {
  applyPatch: () => Yn,
  compare: () => yl
});
var gu = class extends No {
  constructor() {
    super(...arguments);
    v(this, "lc_namespace", ["langchain_core", "output_parsers"]);
    v(this, "lc_serializable", !0);
  }
  static lc_name() {
    return "JsonOutputParser";
  }
  /** @internal */
  _concatOutputChunks(e, t) {
    return this.diff ? super._concatOutputChunks(e, t) : t;
  }
  _diff(e, t) {
    if (t)
      return e ? yl(e, t) : [{
        op: "replace",
        path: "",
        value: t
      }];
  }
  async parsePartialResult(e) {
    return Pc(e[0].text);
  }
  async parse(e) {
    return Pc(e, JSON.parse);
  }
  getFormatInstructions() {
    return "";
  }
}, ZC = class extends _a {
  constructor() {
    super(...arguments);
    v(this, "lc_namespace", [
      "langchain_core",
      "output_parsers",
      "bytes"
    ]);
    v(this, "lc_serializable", !0);
    v(this, "textEncoder", new TextEncoder());
  }
  static lc_name() {
    return "BytesOutputParser";
  }
  parse(e) {
    return Promise.resolve(this.textEncoder.encode(e));
  }
  getFormatInstructions() {
    return "";
  }
}, ya = class extends _a {
  constructor() {
    super(...arguments);
    v(this, "re");
  }
  async *_transform(e) {
    let t = "";
    for await (const n of e)
      if (typeof n == "string" ? t += n : t += n.content, this.re) {
        const s = [...t.matchAll(this.re)];
        if (s.length > 1) {
          let a = 0;
          for (const i of s.slice(0, -1))
            yield [i[1]], a += (i.index ?? 0) + i[0].length;
          t = t.slice(a);
        }
      } else {
        const s = await this.parse(t);
        if (s.length > 1) {
          for (const a of s.slice(0, -1)) yield [a];
          t = s[s.length - 1];
        }
      }
    for (const n of await this.parse(t)) yield [n];
  }
}, VC = class extends ya {
  constructor() {
    super(...arguments);
    v(this, "lc_namespace", [
      "langchain_core",
      "output_parsers",
      "list"
    ]);
    v(this, "lc_serializable", !0);
  }
  static lc_name() {
    return "CommaSeparatedListOutputParser";
  }
  /**
  * Parses the given text into an array of strings, using a comma as the
  * separator. If the parsing fails, throws an OutputParserException.
  * @param text The text to parse.
  * @returns An array of strings obtained by splitting the input text at each comma.
  */
  async parse(e) {
    try {
      return e.trim().split(",").map((t) => t.trim());
    } catch {
      throw new jr(`Could not parse output: ${e}`, e);
    }
  }
  /**
  * Provides instructions on the expected format of the response for the
  * CommaSeparatedListOutputParser.
  * @returns A string containing instructions on the expected format of the response.
  */
  getFormatInstructions() {
    return "Your response should be a list of comma separated values, eg: `foo, bar, baz`";
  }
}, qC = class extends ya {
  constructor({ length: e, separator: t }) {
    super(...arguments);
    v(this, "lc_namespace", [
      "langchain_core",
      "output_parsers",
      "list"
    ]);
    v(this, "length");
    v(this, "separator");
    this.length = e, this.separator = t || ",";
  }
  /**
  * Parses the given text into an array of strings, using the specified
  * separator. If the parsing fails or the number of items in the list
  * doesn't match the expected length, throws an OutputParserException.
  * @param text The text to parse.
  * @returns An array of strings obtained by splitting the input text at each occurrence of the specified separator.
  */
  async parse(e) {
    try {
      const t = e.trim().split(this.separator).map((n) => n.trim());
      if (this.length !== void 0 && t.length !== this.length) throw new jr(`Incorrect number of items. Expected ${this.length}, got ${t.length}.`);
      return t;
    } catch (t) {
      throw Object.getPrototypeOf(t) === jr.prototype ? t : new jr(`Could not parse output: ${e}`);
    }
  }
  /**
  * Provides instructions on the expected format of the response for the
  * CustomListOutputParser, including the number of items and the
  * separator.
  * @returns A string containing instructions on the expected format of the response.
  */
  getFormatInstructions() {
    return `Your response should be a list of ${this.length === void 0 ? "" : `${this.length} `}items separated by "${this.separator}" (eg: \`foo${this.separator} bar${this.separator} baz\`)`;
  }
}, HC = class extends ya {
  constructor() {
    super(...arguments);
    v(this, "lc_namespace", [
      "langchain_core",
      "output_parsers",
      "list"
    ]);
    v(this, "lc_serializable", !0);
    v(this, "re", /\d+\.\s([^\n]+)/g);
  }
  static lc_name() {
    return "NumberedListOutputParser";
  }
  getFormatInstructions() {
    return `Your response should be a numbered list with each item on a new line. For example: 

1. foo

2. bar

3. baz`;
  }
  async parse(e) {
    return [...e.matchAll(this.re) ?? []].map((t) => t[1]);
  }
}, JC = class extends ya {
  constructor() {
    super(...arguments);
    v(this, "lc_namespace", [
      "langchain_core",
      "output_parsers",
      "list"
    ]);
    v(this, "lc_serializable", !0);
    v(this, "re", /^\s*[-*]\s([^\n]+)$/gm);
  }
  static lc_name() {
    return "NumberedListOutputParser";
  }
  getFormatInstructions() {
    return `Your response should be a numbered list with each item on a new line. For example: 

1. foo

2. bar

3. baz`;
  }
  async parse(e) {
    return [...e.matchAll(this.re) ?? []].map((t) => t[1]);
  }
}, WC = class extends _a {
  constructor() {
    super(...arguments);
    v(this, "lc_namespace", [
      "langchain_core",
      "output_parsers",
      "string"
    ]);
    v(this, "lc_serializable", !0);
  }
  static lc_name() {
    return "StrOutputParser";
  }
  /**
  * Parses a string output from an LLM call. This method is meant to be
  * implemented by subclasses to define how a string output from an LLM
  * should be parsed.
  * @param text The string output from an LLM call.
  * @param callbacks Optional callbacks.
  * @returns A promise of the parsed output.
  */
  parse(e) {
    return Promise.resolve(e);
  }
  getFormatInstructions() {
    return "";
  }
  _textContentToString(e) {
    return e.text;
  }
  _imageUrlContentToString(e) {
    throw new Error('Cannot coerce a multimodal "image_url" message part into a string.');
  }
  _messageContentToString(e) {
    switch (e.type) {
      case "text":
      case "text_delta":
        if ("text" in e) return this._textContentToString(e);
        break;
      case "image_url":
        if ("image_url" in e) return this._imageUrlContentToString(e);
        break;
      default:
        throw new Error(`Cannot coerce "${e.type}" message part into a string.`);
    }
    throw new Error(`Invalid content type: ${e.type}`);
  }
  _baseMessageContentToString(e) {
    return e.reduce((t, n) => t + this._messageContentToString(n), "");
  }
}, qi = class extends Ro {
  constructor(e) {
    super(e);
    v(this, "lc_namespace", [
      "langchain",
      "output_parsers",
      "structured"
    ]);
    this.schema = e;
  }
  static lc_name() {
    return "StructuredOutputParser";
  }
  toJSON() {
    return this.toJSONNotImplemented();
  }
  /**
  * Creates a new StructuredOutputParser from a Zod schema.
  * @param schema The Zod schema which the output should match
  * @returns A new instance of StructuredOutputParser.
  */
  static fromZodSchema(e) {
    return new this(e);
  }
  /**
  * Creates a new StructuredOutputParser from a set of names and
  * descriptions.
  * @param schemas An object where each key is a name and each value is a description
  * @returns A new instance of StructuredOutputParser.
  */
  static fromNamesAndDescriptions(e) {
    const t = ko(Object.fromEntries(Object.entries(e).map(([n, s]) => [n, Io().describe(s)])));
    return new this(t);
  }
  /**
  * Returns a markdown code snippet with a JSON object formatted according
  * to the schema.
  * @param options Optional. The options for formatting the instructions
  * @returns A markdown code snippet with a JSON object formatted according to the schema.
  */
  getFormatInstructions() {
    return `You must format your output as a JSON value that adheres to a given "JSON Schema" instance.

"JSON Schema" is a declarative language that allows you to annotate and validate JSON documents.

For example, the example "JSON Schema" instance {{"properties": {{"foo": {{"description": "a list of test words", "type": "array", "items": {{"type": "string"}}}}}}, "required": ["foo"]}}
would match an object with one required property, "foo". The "type" property specifies "foo" must be an "array", and the "description" property semantically describes it as "a list of test words". The items within "foo" must be strings.
Thus, the object {{"foo": ["bar", "baz"]}} is a well-formatted instance of this example "JSON Schema". The object {{"properties": {{"foo": ["bar", "baz"]}}}} is not well-formatted.

Your output will be parsed and type-checked according to the provided schema instance, so make sure all fields in your output match the schema exactly and there are no trailing commas!

Here is the JSON Schema instance your output must adhere to. Include the enclosing markdown codeblock:
\`\`\`json
${JSON.stringify(Sr(this.schema))}
\`\`\`
`;
  }
  /**
  * Parses the given text according to the schema.
  * @param text The text to parse
  * @returns The parsed output.
  */
  async parse(e) {
    var t, n;
    try {
      const s = e.trim(), i = (((t = s.match(/^```(?:json)?\s*([\s\S]*?)```/)) == null ? void 0 : t[1]) || ((n = s.match(/```json\s*([\s\S]*?)```/)) == null ? void 0 : n[1]) || s).replace(/"([^"\\]*(\\.[^"\\]*)*)"/g, (o, c) => `"${c.replace(/\n/g, "\\n")}"`).replace(/\n/g, "");
      return await To(this.schema, JSON.parse(i));
    } catch (s) {
      throw new jr(`Failed to parse. Text: "${e}". Error: ${s}`, e);
    }
  }
}, Y_ = class extends qi {
  static lc_name() {
    return "JsonMarkdownStructuredOutputParser";
  }
  getFormatInstructions(r) {
    const e = (r == null ? void 0 : r.interpolationDepth) ?? 1;
    if (e < 1) throw new Error("f string interpolation depth must be at least 1");
    return `Return a markdown code snippet with a JSON object formatted to look like:
\`\`\`json
${this._schemaToInstruction(Sr(this.schema)).replaceAll("{", "{".repeat(e)).replaceAll("}", "}".repeat(e))}
\`\`\``;
  }
  _schemaToInstruction(r, e = 2) {
    const t = r;
    if ("type" in t) {
      let n = !1, s;
      if (Array.isArray(t.type)) {
        const o = t.type.findIndex((c) => c === "null");
        o !== -1 && (n = !0, t.type.splice(o, 1)), s = t.type.join(" | ");
      } else s = t.type;
      if (t.type === "object" && t.properties) {
        const o = t.description ? ` // ${t.description}` : "";
        return `{
${Object.entries(t.properties).map(([u, l]) => {
          var h;
          const d = (h = t.required) != null && h.includes(u) ? "" : " (optional)";
          return `${" ".repeat(e)}"${u}": ${this._schemaToInstruction(l, e + 2)}${d}`;
        }).join(`
`)}
${" ".repeat(e - 2)}}${o}`;
      }
      if (t.type === "array" && t.items) {
        const o = t.description ? ` // ${t.description}` : "";
        return `array[
${" ".repeat(e)}${this._schemaToInstruction(t.items, e + 2)}
${" ".repeat(e - 2)}] ${o}`;
      }
      const a = n ? " (nullable)" : "", i = t.description ? ` // ${t.description}` : "";
      return `${s}${i}${a}`;
    }
    if ("anyOf" in t) return t.anyOf.map((n) => this._schemaToInstruction(n, e)).join(`
${" ".repeat(e - 2)}`);
    throw new Error("unsupported schema type");
  }
  static fromZodSchema(r) {
    return new this(r);
  }
  static fromNamesAndDescriptions(r) {
    const e = ko(Object.fromEntries(Object.entries(r).map(([t, n]) => [t, Io().describe(n)])));
    return new this(e);
  }
}, GC = class extends Ro {
  constructor({ inputSchema: e }) {
    super(...arguments);
    v(this, "structuredInputParser");
    this.structuredInputParser = new Y_(e);
  }
  async parse(e) {
    let t;
    try {
      t = await this.structuredInputParser.parse(e);
    } catch (n) {
      throw new jr(`Failed to parse. Text: "${e}". Error: ${n}`, e);
    }
    return this.outputProcessor(t);
  }
  getFormatInstructions() {
    return this.structuredInputParser.getFormatInstructions();
  }
};
const KC = function() {
  const r = {};
  r.parser = function(b, m) {
    return new t(b, m);
  }, r.SAXParser = t, r.SAXStream = u, r.createStream = c, r.MAX_BUFFER_LENGTH = 64 * 1024;
  const e = [
    "comment",
    "sgmlDecl",
    "textNode",
    "tagName",
    "doctype",
    "procInstName",
    "procInstBody",
    "entity",
    "attribName",
    "attribValue",
    "cdata",
    "script"
  ];
  r.EVENTS = [
    "text",
    "processinginstruction",
    "sgmldeclaration",
    "doctype",
    "comment",
    "opentagstart",
    "attribute",
    "opentag",
    "closetag",
    "opencdata",
    "cdata",
    "closecdata",
    "error",
    "end",
    "ready",
    "script",
    "opennamespace",
    "closenamespace"
  ];
  function t(b, m) {
    if (!(this instanceof t)) return new t(b, m);
    var $ = this;
    s($), $.q = $.c = "", $.bufferCheckPosition = r.MAX_BUFFER_LENGTH, $.opt = m || {}, $.opt.lowercase = $.opt.lowercase || $.opt.lowercasetags, $.looseCase = $.opt.lowercase ? "toLowerCase" : "toUpperCase", $.tags = [], $.closed = $.closedRoot = $.sawRoot = !1, $.tag = $.error = null, $.strict = !!b, $.noscript = !!(b || $.opt.noscript), $.state = E.BEGIN, $.strictEntities = $.opt.strictEntities, $.ENTITIES = $.strictEntities ? Object.create(r.XML_ENTITIES) : Object.create(r.ENTITIES), $.attribList = [], $.opt.xmlns && ($.ns = Object.create(p)), $.trackPosition = $.opt.position !== !1, $.trackPosition && ($.position = $.line = $.column = 0), ne($, "onready");
  }
  Object.create || (Object.create = function(b) {
    function m() {
    }
    m.prototype = b;
    var $ = new m();
    return $;
  }), Object.keys || (Object.keys = function(b) {
    var m = [];
    for (var $ in b) b.hasOwnProperty($) && m.push($);
    return m;
  });
  function n(b) {
    for (var m = Math.max(r.MAX_BUFFER_LENGTH, 10), $ = 0, I = 0, de = e.length; I < de; I++) {
      var me = b[e[I]].length;
      if (me > m) switch (e[I]) {
        case "textNode":
          Se(b);
          break;
        case "cdata":
          z(b, "oncdata", b.cdata), b.cdata = "";
          break;
        case "script":
          z(b, "onscript", b.script), b.script = "";
          break;
        default:
          Z(b, "Max buffer length exceeded: " + e[I]);
      }
      $ = Math.max($, me);
    }
    var Me = r.MAX_BUFFER_LENGTH - $;
    b.bufferCheckPosition = Me + b.position;
  }
  function s(b) {
    for (var m = 0, $ = e.length; m < $; m++) b[e[m]] = "";
  }
  function a(b) {
    Se(b), b.cdata !== "" && (z(b, "oncdata", b.cdata), b.cdata = ""), b.script !== "" && (z(b, "onscript", b.script), b.script = "");
  }
  t.prototype = {
    end: function() {
      D(this);
    },
    write: ae,
    resume: function() {
      return this.error = null, this;
    },
    close: function() {
      return this.write(null);
    },
    flush: function() {
      a(this);
    }
  };
  var i = ReadableStream;
  i || (i = function() {
  });
  var o = r.EVENTS.filter(function(b) {
    return b !== "error" && b !== "end";
  });
  function c(b, m) {
    return new u(b, m);
  }
  function u(b, m) {
    if (!(this instanceof u)) return new u(b, m);
    i.apply(this), this._parser = new t(b, m), this.writable = !0, this.readable = !0;
    var $ = this;
    this._parser.onend = function() {
      $.emit("end");
    }, this._parser.onerror = function(I) {
      $.emit("error", I), $._parser.error = null;
    }, this._decoder = null, o.forEach(function(I) {
      Object.defineProperty($, "on" + I, {
        get: function() {
          return $._parser["on" + I];
        },
        set: function(de) {
          if (!de)
            return $.removeAllListeners(I), $._parser["on" + I] = de, de;
          $.on(I, de);
        },
        enumerable: !0,
        configurable: !1
      });
    });
  }
  u.prototype = Object.create(i.prototype, { constructor: { value: u } }), u.prototype.write = function(b) {
    return this._parser.write(b.toString()), this.emit("data", b), !0;
  }, u.prototype.end = function(b) {
    return b && b.length && this.write(b), this._parser.end(), !0;
  }, u.prototype.on = function(b, m) {
    var $ = this;
    return !$._parser["on" + b] && o.indexOf(b) !== -1 && ($._parser["on" + b] = function() {
      var I = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments);
      I.splice(0, 0, b), $.emit.apply($, I);
    }), i.prototype.on.call($, b, m);
  };
  var l = "[CDATA[", d = "DOCTYPE", h = "http://www.w3.org/XML/1998/namespace", f = "http://www.w3.org/2000/xmlns/", p = {
    xml: h,
    xmlns: f
  }, y = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/, g = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/, S = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/, _ = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
  function w(b) {
    return b === " " || b === `
` || b === "\r" || b === "	";
  }
  function T(b) {
    return b === '"' || b === "'";
  }
  function x(b) {
    return b === ">" || w(b);
  }
  function A(b, m) {
    return b.test(m);
  }
  function R(b, m) {
    return !A(b, m);
  }
  var E = 0;
  r.STATE = {
    BEGIN: E++,
    BEGIN_WHITESPACE: E++,
    TEXT: E++,
    TEXT_ENTITY: E++,
    OPEN_WAKA: E++,
    SGML_DECL: E++,
    SGML_DECL_QUOTED: E++,
    DOCTYPE: E++,
    DOCTYPE_QUOTED: E++,
    DOCTYPE_DTD: E++,
    DOCTYPE_DTD_QUOTED: E++,
    COMMENT_STARTING: E++,
    COMMENT: E++,
    COMMENT_ENDING: E++,
    COMMENT_ENDED: E++,
    CDATA: E++,
    CDATA_ENDING: E++,
    CDATA_ENDING_2: E++,
    PROC_INST: E++,
    PROC_INST_BODY: E++,
    PROC_INST_ENDING: E++,
    OPEN_TAG: E++,
    OPEN_TAG_SLASH: E++,
    ATTRIB: E++,
    ATTRIB_NAME: E++,
    ATTRIB_NAME_SAW_WHITE: E++,
    ATTRIB_VALUE: E++,
    ATTRIB_VALUE_QUOTED: E++,
    ATTRIB_VALUE_CLOSED: E++,
    ATTRIB_VALUE_UNQUOTED: E++,
    ATTRIB_VALUE_ENTITY_Q: E++,
    ATTRIB_VALUE_ENTITY_U: E++,
    CLOSE_TAG: E++,
    CLOSE_TAG_SAW_WHITE: E++,
    SCRIPT: E++,
    SCRIPT_ENDING: E++
  }, r.XML_ENTITIES = {
    amp: "&",
    gt: ">",
    lt: "<",
    quot: '"',
    apos: "'"
  }, r.ENTITIES = {
    amp: "&",
    gt: ">",
    lt: "<",
    quot: '"',
    apos: "'",
    AElig: 198,
    Aacute: 193,
    Acirc: 194,
    Agrave: 192,
    Aring: 197,
    Atilde: 195,
    Auml: 196,
    Ccedil: 199,
    ETH: 208,
    Eacute: 201,
    Ecirc: 202,
    Egrave: 200,
    Euml: 203,
    Iacute: 205,
    Icirc: 206,
    Igrave: 204,
    Iuml: 207,
    Ntilde: 209,
    Oacute: 211,
    Ocirc: 212,
    Ograve: 210,
    Oslash: 216,
    Otilde: 213,
    Ouml: 214,
    THORN: 222,
    Uacute: 218,
    Ucirc: 219,
    Ugrave: 217,
    Uuml: 220,
    Yacute: 221,
    aacute: 225,
    acirc: 226,
    aelig: 230,
    agrave: 224,
    aring: 229,
    atilde: 227,
    auml: 228,
    ccedil: 231,
    eacute: 233,
    ecirc: 234,
    egrave: 232,
    eth: 240,
    euml: 235,
    iacute: 237,
    icirc: 238,
    igrave: 236,
    iuml: 239,
    ntilde: 241,
    oacute: 243,
    ocirc: 244,
    ograve: 242,
    oslash: 248,
    otilde: 245,
    ouml: 246,
    szlig: 223,
    thorn: 254,
    uacute: 250,
    ucirc: 251,
    ugrave: 249,
    uuml: 252,
    yacute: 253,
    yuml: 255,
    copy: 169,
    reg: 174,
    nbsp: 160,
    iexcl: 161,
    cent: 162,
    pound: 163,
    curren: 164,
    yen: 165,
    brvbar: 166,
    sect: 167,
    uml: 168,
    ordf: 170,
    laquo: 171,
    not: 172,
    shy: 173,
    macr: 175,
    deg: 176,
    plusmn: 177,
    sup1: 185,
    sup2: 178,
    sup3: 179,
    acute: 180,
    micro: 181,
    para: 182,
    middot: 183,
    cedil: 184,
    ordm: 186,
    raquo: 187,
    frac14: 188,
    frac12: 189,
    frac34: 190,
    iquest: 191,
    times: 215,
    divide: 247,
    OElig: 338,
    oelig: 339,
    Scaron: 352,
    scaron: 353,
    Yuml: 376,
    fnof: 402,
    circ: 710,
    tilde: 732,
    Alpha: 913,
    Beta: 914,
    Gamma: 915,
    Delta: 916,
    Epsilon: 917,
    Zeta: 918,
    Eta: 919,
    Theta: 920,
    Iota: 921,
    Kappa: 922,
    Lambda: 923,
    Mu: 924,
    Nu: 925,
    Xi: 926,
    Omicron: 927,
    Pi: 928,
    Rho: 929,
    Sigma: 931,
    Tau: 932,
    Upsilon: 933,
    Phi: 934,
    Chi: 935,
    Psi: 936,
    Omega: 937,
    alpha: 945,
    beta: 946,
    gamma: 947,
    delta: 948,
    epsilon: 949,
    zeta: 950,
    eta: 951,
    theta: 952,
    iota: 953,
    kappa: 954,
    lambda: 955,
    mu: 956,
    nu: 957,
    xi: 958,
    omicron: 959,
    pi: 960,
    rho: 961,
    sigmaf: 962,
    sigma: 963,
    tau: 964,
    upsilon: 965,
    phi: 966,
    chi: 967,
    psi: 968,
    omega: 969,
    thetasym: 977,
    upsih: 978,
    piv: 982,
    ensp: 8194,
    emsp: 8195,
    thinsp: 8201,
    zwnj: 8204,
    zwj: 8205,
    lrm: 8206,
    rlm: 8207,
    ndash: 8211,
    mdash: 8212,
    lsquo: 8216,
    rsquo: 8217,
    sbquo: 8218,
    ldquo: 8220,
    rdquo: 8221,
    bdquo: 8222,
    dagger: 8224,
    Dagger: 8225,
    bull: 8226,
    hellip: 8230,
    permil: 8240,
    prime: 8242,
    Prime: 8243,
    lsaquo: 8249,
    rsaquo: 8250,
    oline: 8254,
    frasl: 8260,
    euro: 8364,
    image: 8465,
    weierp: 8472,
    real: 8476,
    trade: 8482,
    alefsym: 8501,
    larr: 8592,
    uarr: 8593,
    rarr: 8594,
    darr: 8595,
    harr: 8596,
    crarr: 8629,
    lArr: 8656,
    uArr: 8657,
    rArr: 8658,
    dArr: 8659,
    hArr: 8660,
    forall: 8704,
    part: 8706,
    exist: 8707,
    empty: 8709,
    nabla: 8711,
    isin: 8712,
    notin: 8713,
    ni: 8715,
    prod: 8719,
    sum: 8721,
    minus: 8722,
    lowast: 8727,
    radic: 8730,
    prop: 8733,
    infin: 8734,
    ang: 8736,
    and: 8743,
    or: 8744,
    cap: 8745,
    cup: 8746,
    int: 8747,
    there4: 8756,
    sim: 8764,
    cong: 8773,
    asymp: 8776,
    ne: 8800,
    equiv: 8801,
    le: 8804,
    ge: 8805,
    sub: 8834,
    sup: 8835,
    nsub: 8836,
    sube: 8838,
    supe: 8839,
    oplus: 8853,
    otimes: 8855,
    perp: 8869,
    sdot: 8901,
    lceil: 8968,
    rceil: 8969,
    lfloor: 8970,
    rfloor: 8971,
    lang: 9001,
    rang: 9002,
    loz: 9674,
    spades: 9824,
    clubs: 9827,
    hearts: 9829,
    diams: 9830
  }, Object.keys(r.ENTITIES).forEach(function(b) {
    var m = r.ENTITIES[b], $ = typeof m == "number" ? String.fromCharCode(m) : m;
    r.ENTITIES[b] = $;
  });
  for (var V in r.STATE) r.STATE[r.STATE[V]] = V;
  E = r.STATE;
  function ne(b, m, $) {
    b[m] && b[m]($);
  }
  function z(b, m, $) {
    b.textNode && Se(b), ne(b, m, $);
  }
  function Se(b) {
    b.textNode = Oe(b.opt, b.textNode), b.textNode && ne(b, "ontext", b.textNode), b.textNode = "";
  }
  function Oe(b, m) {
    return b.trim && (m = m.trim()), b.normalize && (m = m.replace(/\s+/g, " ")), m;
  }
  function Z(b, m) {
    return Se(b), b.trackPosition && (m += `
Line: ` + b.line + `
Column: ` + b.column + `
Char: ` + b.c), m = new Error(m), b.error = m, ne(b, "onerror", m), b;
  }
  function D(b) {
    return b.sawRoot && !b.closedRoot && U(b, "Unclosed root tag"), b.state !== E.BEGIN && b.state !== E.BEGIN_WHITESPACE && b.state !== E.TEXT && Z(b, "Unexpected end"), Se(b), b.c = "", b.closed = !0, ne(b, "onend"), t.call(b, b.strict, b.opt), b;
  }
  function U(b, m) {
    if (typeof b != "object" || !(b instanceof t)) throw new Error("bad call to strictFail");
    b.strict && Z(b, m);
  }
  function O(b) {
    b.strict || (b.tagName = b.tagName[b.looseCase]());
    var m = b.tags[b.tags.length - 1] || b, $ = b.tag = {
      name: b.tagName,
      attributes: {}
    };
    b.opt.xmlns && ($.ns = m.ns), b.attribList.length = 0, z(b, "onopentagstart", $);
  }
  function P(b, m) {
    var $ = b.indexOf(":"), I = $ < 0 ? ["", b] : b.split(":"), de = I[0], me = I[1];
    return m && b === "xmlns" && (de = "xmlns", me = ""), {
      prefix: de,
      local: me
    };
  }
  function N(b) {
    if (b.strict || (b.attribName = b.attribName[b.looseCase]()), b.attribList.indexOf(b.attribName) !== -1 || b.tag.attributes.hasOwnProperty(b.attribName)) {
      b.attribName = b.attribValue = "";
      return;
    }
    if (b.opt.xmlns) {
      var m = P(b.attribName, !0), $ = m.prefix, I = m.local;
      if ($ === "xmlns") if (I === "xml" && b.attribValue !== h) U(b, "xml: prefix must be bound to " + h + `
Actual: ` + b.attribValue);
      else if (I === "xmlns" && b.attribValue !== f) U(b, "xmlns: prefix must be bound to " + f + `
Actual: ` + b.attribValue);
      else {
        var de = b.tag, me = b.tags[b.tags.length - 1] || b;
        de.ns === me.ns && (de.ns = Object.create(me.ns)), de.ns[I] = b.attribValue;
      }
      b.attribList.push([b.attribName, b.attribValue]);
    } else
      b.tag.attributes[b.attribName] = b.attribValue, z(b, "onattribute", {
        name: b.attribName,
        value: b.attribValue
      });
    b.attribName = b.attribValue = "";
  }
  function j(b, m) {
    if (b.opt.xmlns) {
      var $ = b.tag, I = P(b.tagName);
      $.prefix = I.prefix, $.local = I.local, $.uri = $.ns[I.prefix] || "", $.prefix && !$.uri && (U(b, "Unbound namespace prefix: " + JSON.stringify(b.tagName)), $.uri = I.prefix);
      var de = b.tags[b.tags.length - 1] || b;
      $.ns && de.ns !== $.ns && Object.keys($.ns).forEach(function(un) {
        z(b, "onopennamespace", {
          prefix: un,
          uri: $.ns[un]
        });
      });
      for (var me = 0, Me = b.attribList.length; me < Me; me++) {
        var Ue = b.attribList[me], at = Ue[0], Yt = Ue[1], Je = P(at, !0), Ht = Je.prefix, $n = Je.local, wa = Ht === "" ? "" : $.ns[Ht] || "", J = {
          name: at,
          value: Yt,
          prefix: Ht,
          local: $n,
          uri: wa
        };
        Ht && Ht !== "xmlns" && !wa && (U(b, "Unbound namespace prefix: " + JSON.stringify(Ht)), J.uri = Ht), b.tag.attributes[at] = J, z(b, "onattribute", J);
      }
      b.attribList.length = 0;
    }
    b.tag.isSelfClosing = !!m, b.sawRoot = !0, b.tags.push(b.tag), z(b, "onopentag", b.tag), m || (!b.noscript && b.tagName.toLowerCase() === "script" ? b.state = E.SCRIPT : b.state = E.TEXT, b.tag = null, b.tagName = ""), b.attribName = b.attribValue = "", b.attribList.length = 0;
  }
  function M(b) {
    if (!b.tagName) {
      U(b, "Weird empty close tag."), b.textNode += "</>", b.state = E.TEXT;
      return;
    }
    if (b.script) {
      if (b.tagName !== "script") {
        b.script += "</" + b.tagName + ">", b.tagName = "", b.state = E.SCRIPT;
        return;
      }
      z(b, "onscript", b.script), b.script = "";
    }
    var m = b.tags.length, $ = b.tagName;
    b.strict || ($ = $[b.looseCase]());
    for (var I = $; m--; ) {
      var de = b.tags[m];
      if (de.name !== I) U(b, "Unexpected close tag");
      else break;
    }
    if (m < 0) {
      U(b, "Unmatched closing tag: " + b.tagName), b.textNode += "</" + b.tagName + ">", b.state = E.TEXT;
      return;
    }
    b.tagName = $;
    for (var me = b.tags.length; me-- > m; ) {
      var Me = b.tag = b.tags.pop();
      b.tagName = b.tag.name, z(b, "onclosetag", b.tagName);
      var Ue = {};
      for (var at in Me.ns) Ue[at] = Me.ns[at];
      var Yt = b.tags[b.tags.length - 1] || b;
      b.opt.xmlns && Me.ns !== Yt.ns && Object.keys(Me.ns).forEach(function(Je) {
        var Ht = Me.ns[Je];
        z(b, "onclosenamespace", {
          prefix: Je,
          uri: Ht
        });
      });
    }
    m === 0 && (b.closedRoot = !0), b.tagName = b.attribValue = b.attribName = "", b.attribList.length = 0, b.state = E.TEXT;
  }
  function q(b) {
    var m = b.entity, $ = m.toLowerCase(), I, de = "";
    return b.ENTITIES[m] ? b.ENTITIES[m] : b.ENTITIES[$] ? b.ENTITIES[$] : (m = $, m.charAt(0) === "#" && (m.charAt(1) === "x" ? (m = m.slice(2), I = parseInt(m, 16), de = I.toString(16)) : (m = m.slice(1), I = parseInt(m, 10), de = I.toString(10))), m = m.replace(/^0+/, ""), isNaN(I) || de.toLowerCase() !== m ? (U(b, "Invalid character entity"), "&" + b.entity + ";") : String.fromCodePoint(I));
  }
  function se(b, m) {
    m === "<" ? (b.state = E.OPEN_WAKA, b.startTagPosition = b.position) : w(m) || (U(b, "Non-whitespace before first tag."), b.textNode = m, b.state = E.TEXT);
  }
  function Te(b, m) {
    var $ = "";
    return m < b.length && ($ = b.charAt(m)), $;
  }
  function ae(b) {
    var m = this;
    if (this.error) throw this.error;
    if (m.closed) return Z(m, "Cannot write after close. Assign an onready handler.");
    if (b === null) return D(m);
    typeof b == "object" && (b = b.toString());
    for (var $ = 0, I = ""; I = Te(b, $++), m.c = I, !!I; )
      switch (m.trackPosition && (m.position++, I === `
` ? (m.line++, m.column = 0) : m.column++), m.state) {
        case E.BEGIN:
          if (m.state = E.BEGIN_WHITESPACE, I === "\uFEFF") continue;
          se(m, I);
          continue;
        case E.BEGIN_WHITESPACE:
          se(m, I);
          continue;
        case E.TEXT:
          if (m.sawRoot && !m.closedRoot) {
            for (var de = $ - 1; I && I !== "<" && I !== "&"; )
              I = Te(b, $++), I && m.trackPosition && (m.position++, I === `
` ? (m.line++, m.column = 0) : m.column++);
            m.textNode += b.substring(de, $ - 1);
          }
          I === "<" && !(m.sawRoot && m.closedRoot && !m.strict) ? (m.state = E.OPEN_WAKA, m.startTagPosition = m.position) : (!w(I) && (!m.sawRoot || m.closedRoot) && U(m, "Text data outside of root node."), I === "&" ? m.state = E.TEXT_ENTITY : m.textNode += I);
          continue;
        case E.SCRIPT:
          I === "<" ? m.state = E.SCRIPT_ENDING : m.script += I;
          continue;
        case E.SCRIPT_ENDING:
          I === "/" ? m.state = E.CLOSE_TAG : (m.script += "<" + I, m.state = E.SCRIPT);
          continue;
        case E.OPEN_WAKA:
          if (I === "!")
            m.state = E.SGML_DECL, m.sgmlDecl = "";
          else if (!w(I)) if (A(y, I))
            m.state = E.OPEN_TAG, m.tagName = I;
          else if (I === "/")
            m.state = E.CLOSE_TAG, m.tagName = "";
          else if (I === "?")
            m.state = E.PROC_INST, m.procInstName = m.procInstBody = "";
          else {
            if (U(m, "Unencoded <"), m.startTagPosition + 1 < m.position) {
              var me = m.position - m.startTagPosition;
              I = new Array(me).join(" ") + I;
            }
            m.textNode += "<" + I, m.state = E.TEXT;
          }
          continue;
        case E.SGML_DECL:
          (m.sgmlDecl + I).toUpperCase() === l ? (z(m, "onopencdata"), m.state = E.CDATA, m.sgmlDecl = "", m.cdata = "") : m.sgmlDecl + I === "--" ? (m.state = E.COMMENT, m.comment = "", m.sgmlDecl = "") : (m.sgmlDecl + I).toUpperCase() === d ? (m.state = E.DOCTYPE, (m.doctype || m.sawRoot) && U(m, "Inappropriately located doctype declaration"), m.doctype = "", m.sgmlDecl = "") : I === ">" ? (z(m, "onsgmldeclaration", m.sgmlDecl), m.sgmlDecl = "", m.state = E.TEXT) : (T(I) && (m.state = E.SGML_DECL_QUOTED), m.sgmlDecl += I);
          continue;
        case E.SGML_DECL_QUOTED:
          I === m.q && (m.state = E.SGML_DECL, m.q = ""), m.sgmlDecl += I;
          continue;
        case E.DOCTYPE:
          I === ">" ? (m.state = E.TEXT, z(m, "ondoctype", m.doctype), m.doctype = !0) : (m.doctype += I, I === "[" ? m.state = E.DOCTYPE_DTD : T(I) && (m.state = E.DOCTYPE_QUOTED, m.q = I));
          continue;
        case E.DOCTYPE_QUOTED:
          m.doctype += I, I === m.q && (m.q = "", m.state = E.DOCTYPE);
          continue;
        case E.DOCTYPE_DTD:
          m.doctype += I, I === "]" ? m.state = E.DOCTYPE : T(I) && (m.state = E.DOCTYPE_DTD_QUOTED, m.q = I);
          continue;
        case E.DOCTYPE_DTD_QUOTED:
          m.doctype += I, I === m.q && (m.state = E.DOCTYPE_DTD, m.q = "");
          continue;
        case E.COMMENT:
          I === "-" ? m.state = E.COMMENT_ENDING : m.comment += I;
          continue;
        case E.COMMENT_ENDING:
          I === "-" ? (m.state = E.COMMENT_ENDED, m.comment = Oe(m.opt, m.comment), m.comment && z(m, "oncomment", m.comment), m.comment = "") : (m.comment += "-" + I, m.state = E.COMMENT);
          continue;
        case E.COMMENT_ENDED:
          I !== ">" ? (U(m, "Malformed comment"), m.comment += "--" + I, m.state = E.COMMENT) : m.state = E.TEXT;
          continue;
        case E.CDATA:
          I === "]" ? m.state = E.CDATA_ENDING : m.cdata += I;
          continue;
        case E.CDATA_ENDING:
          I === "]" ? m.state = E.CDATA_ENDING_2 : (m.cdata += "]" + I, m.state = E.CDATA);
          continue;
        case E.CDATA_ENDING_2:
          I === ">" ? (m.cdata && z(m, "oncdata", m.cdata), z(m, "onclosecdata"), m.cdata = "", m.state = E.TEXT) : I === "]" ? m.cdata += "]" : (m.cdata += "]]" + I, m.state = E.CDATA);
          continue;
        case E.PROC_INST:
          I === "?" ? m.state = E.PROC_INST_ENDING : w(I) ? m.state = E.PROC_INST_BODY : m.procInstName += I;
          continue;
        case E.PROC_INST_BODY:
          if (!m.procInstBody && w(I)) continue;
          I === "?" ? m.state = E.PROC_INST_ENDING : m.procInstBody += I;
          continue;
        case E.PROC_INST_ENDING:
          I === ">" ? (z(m, "onprocessinginstruction", {
            name: m.procInstName,
            body: m.procInstBody
          }), m.procInstName = m.procInstBody = "", m.state = E.TEXT) : (m.procInstBody += "?" + I, m.state = E.PROC_INST_BODY);
          continue;
        case E.OPEN_TAG:
          A(g, I) ? m.tagName += I : (O(m), I === ">" ? j(m) : I === "/" ? m.state = E.OPEN_TAG_SLASH : (w(I) || U(m, "Invalid character in tag name"), m.state = E.ATTRIB));
          continue;
        case E.OPEN_TAG_SLASH:
          I === ">" ? (j(m, !0), M(m)) : (U(m, "Forward-slash in opening tag not followed by >"), m.state = E.ATTRIB);
          continue;
        case E.ATTRIB:
          if (w(I)) continue;
          I === ">" ? j(m) : I === "/" ? m.state = E.OPEN_TAG_SLASH : A(y, I) ? (m.attribName = I, m.attribValue = "", m.state = E.ATTRIB_NAME) : U(m, "Invalid attribute name");
          continue;
        case E.ATTRIB_NAME:
          I === "=" ? m.state = E.ATTRIB_VALUE : I === ">" ? (U(m, "Attribute without value"), m.attribValue = m.attribName, N(m), j(m)) : w(I) ? m.state = E.ATTRIB_NAME_SAW_WHITE : A(g, I) ? m.attribName += I : U(m, "Invalid attribute name");
          continue;
        case E.ATTRIB_NAME_SAW_WHITE:
          if (I === "=") m.state = E.ATTRIB_VALUE;
          else {
            if (w(I)) continue;
            U(m, "Attribute without value"), m.tag.attributes[m.attribName] = "", m.attribValue = "", z(m, "onattribute", {
              name: m.attribName,
              value: ""
            }), m.attribName = "", I === ">" ? j(m) : A(y, I) ? (m.attribName = I, m.state = E.ATTRIB_NAME) : (U(m, "Invalid attribute name"), m.state = E.ATTRIB);
          }
          continue;
        case E.ATTRIB_VALUE:
          if (w(I)) continue;
          T(I) ? (m.q = I, m.state = E.ATTRIB_VALUE_QUOTED) : (U(m, "Unquoted attribute value"), m.state = E.ATTRIB_VALUE_UNQUOTED, m.attribValue = I);
          continue;
        case E.ATTRIB_VALUE_QUOTED:
          if (I !== m.q) {
            I === "&" ? m.state = E.ATTRIB_VALUE_ENTITY_Q : m.attribValue += I;
            continue;
          }
          N(m), m.q = "", m.state = E.ATTRIB_VALUE_CLOSED;
          continue;
        case E.ATTRIB_VALUE_CLOSED:
          w(I) ? m.state = E.ATTRIB : I === ">" ? j(m) : I === "/" ? m.state = E.OPEN_TAG_SLASH : A(y, I) ? (U(m, "No whitespace between attributes"), m.attribName = I, m.attribValue = "", m.state = E.ATTRIB_NAME) : U(m, "Invalid attribute name");
          continue;
        case E.ATTRIB_VALUE_UNQUOTED:
          if (!x(I)) {
            I === "&" ? m.state = E.ATTRIB_VALUE_ENTITY_U : m.attribValue += I;
            continue;
          }
          N(m), I === ">" ? j(m) : m.state = E.ATTRIB;
          continue;
        case E.CLOSE_TAG:
          if (m.tagName) I === ">" ? M(m) : A(g, I) ? m.tagName += I : m.script ? (m.script += "</" + m.tagName, m.tagName = "", m.state = E.SCRIPT) : (w(I) || U(m, "Invalid tagname in closing tag"), m.state = E.CLOSE_TAG_SAW_WHITE);
          else {
            if (w(I)) continue;
            R(y, I) ? m.script ? (m.script += "</" + I, m.state = E.SCRIPT) : U(m, "Invalid tagname in closing tag.") : m.tagName = I;
          }
          continue;
        case E.CLOSE_TAG_SAW_WHITE:
          if (w(I)) continue;
          I === ">" ? M(m) : U(m, "Invalid characters in closing tag");
          continue;
        case E.TEXT_ENTITY:
        case E.ATTRIB_VALUE_ENTITY_Q:
        case E.ATTRIB_VALUE_ENTITY_U:
          var Me, Ue;
          switch (m.state) {
            case E.TEXT_ENTITY:
              Me = E.TEXT, Ue = "textNode";
              break;
            case E.ATTRIB_VALUE_ENTITY_Q:
              Me = E.ATTRIB_VALUE_QUOTED, Ue = "attribValue";
              break;
            case E.ATTRIB_VALUE_ENTITY_U:
              Me = E.ATTRIB_VALUE_UNQUOTED, Ue = "attribValue";
              break;
          }
          if (I === ";") if (m.opt.unparsedEntities) {
            var at = q(m);
            m.entity = "", m.state = Me, m.write(at);
          } else
            m[Ue] += q(m), m.entity = "", m.state = Me;
          else A(m.entity.length ? _ : S, I) ? m.entity += I : (U(m, "Invalid character in entity name"), m[Ue] += "&" + m.entity + I, m.entity = "", m.state = Me);
          continue;
        default:
          throw new Error(m, "Unknown state: " + m.state);
      }
    return m.position >= m.bufferCheckPosition && n(m), m;
  }
  /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */
  return String.fromCodePoint || function() {
    var b = String.fromCharCode, m = Math.floor, $ = function() {
      var I = 16384, de = [], me, Me, Ue = -1, at = arguments.length;
      if (!at) return "";
      for (var Yt = ""; ++Ue < at; ) {
        var Je = Number(arguments[Ue]);
        if (!isFinite(Je) || Je < 0 || Je > 1114111 || m(Je) !== Je) throw RangeError("Invalid code point: " + Je);
        Je <= 65535 ? de.push(Je) : (Je -= 65536, me = (Je >> 10) + 55296, Me = Je % 1024 + 56320, de.push(me, Me)), (Ue + 1 === at || de.length > I) && (Yt += b.apply(null, de), de.length = 0);
      }
      return Yt;
    };
    Object.defineProperty ? Object.defineProperty(String, "fromCodePoint", {
      value: $,
      configurable: !0,
      writable: !0
    }) : String.fromCodePoint = $;
  }(), r;
}, YC = KC(), _u = `The output should be formatted as a XML file.
1. Output should conform to the tags below. 
2. If tags are not given, make them on your own.
3. Remember to always open and close all the tags.

As an example, for the tags ["foo", "bar", "baz"]:
1. String "<foo>
   <bar>
      <baz></baz>
   </bar>
</foo>" is a well-formatted instance of the schema. 
2. String "<foo>
   <bar>
   </foo>" is a badly-formatted instance.
3. String "<foo>
   <tag>
   </tag>
</foo>" is a badly-formatted instance.

Here are the output tags:
\`\`\`
{tags}
\`\`\``;
var XC = class extends No {
  constructor(e) {
    super(e);
    v(this, "tags");
    v(this, "lc_namespace", ["langchain_core", "output_parsers"]);
    v(this, "lc_serializable", !0);
    this.tags = e == null ? void 0 : e.tags;
  }
  static lc_name() {
    return "XMLOutputParser";
  }
  _diff(e, t) {
    if (t)
      return e ? yl(e, t) : [{
        op: "replace",
        path: "",
        value: t
      }];
  }
  async parsePartialResult(e) {
    return yu(e[0].text);
  }
  async parse(e) {
    return yu(e);
  }
  getFormatInstructions() {
    var t;
    return !!(this.tags && this.tags.length > 0) ? _u.replace("{tags}", ((t = this.tags) == null ? void 0 : t.join(", ")) ?? "") : _u;
  }
};
const QC = (r) => r.split(`
`).map((e) => e.replace(/^\s+/, "")).join(`
`).trim(), X_ = (r) => {
  if (Object.keys(r).length === 0) return {};
  const e = {};
  return r.children.length > 0 ? (e[r.name] = r.children.map(X_), e) : (e[r.name] = r.text ?? void 0, e);
};
function yu(r) {
  const e = QC(r), t = YC.parser(!0);
  let n = {};
  const s = [];
  t.onopentag = (o) => {
    const c = {
      name: o.name,
      attributes: o.attributes,
      children: [],
      text: "",
      isSelfClosing: o.isSelfClosing
    };
    s.length > 0 ? s[s.length - 1].children.push(c) : n = c, o.isSelfClosing || s.push(c);
  }, t.onclosetag = () => {
    if (s.length > 0) {
      const o = s.pop();
      s.length === 0 && o && (n = o);
    }
  }, t.ontext = (o) => {
    if (s.length > 0) {
      const c = s[s.length - 1];
      c.text += o;
    }
  }, t.onattribute = (o) => {
    if (s.length > 0) {
      const c = s[s.length - 1];
      c.attributes[o.name] = o.value;
    }
  };
  const a = /```(xml)?(.*)```/s.exec(e), i = a ? a[2] : e;
  return t.write(i).close(), n && n.name === "?xml" && (n = n.children[0]), X_(n);
}
var e1 = {};
Ae(e1, {
  AsymmetricStructuredOutputParser: () => GC,
  BaseCumulativeTransformOutputParser: () => No,
  BaseLLMOutputParser: () => K_,
  BaseOutputParser: () => Ro,
  BaseTransformOutputParser: () => _a,
  BytesOutputParser: () => ZC,
  CommaSeparatedListOutputParser: () => VC,
  CustomListOutputParser: () => qC,
  JsonMarkdownStructuredOutputParser: () => Y_,
  JsonOutputParser: () => gu,
  ListOutputParser: () => ya,
  MarkdownListOutputParser: () => JC,
  NumberedListOutputParser: () => HC,
  OutputParserException: () => jr,
  StringOutputParser: () => WC,
  StructuredOutputParser: () => qi,
  XMLOutputParser: () => XC,
  XML_FORMAT_INSTRUCTIONS: () => _u,
  parseJsonMarkdown: () => Pc,
  parsePartialJson: () => io,
  parseXMLMarkdown: () => yu
});
function Po(r, e) {
  if (r.function === void 0) return;
  let t;
  if (e != null && e.partial) try {
    t = io(r.function.arguments ?? "{}");
  } catch {
    return;
  }
  else try {
    t = JSON.parse(r.function.arguments);
  } catch (s) {
    throw new jr([
      `Function "${r.function.name}" arguments:`,
      "",
      r.function.arguments,
      "",
      "are not valid JSON.",
      `Error: ${s.message}`
    ].join(`
`));
  }
  const n = {
    name: r.function.name,
    args: t,
    type: "tool_call"
  };
  return e != null && e.returnId && (n.id = r.id), n;
}
function Q_(r) {
  if (r.id === void 0) throw new Error('All OpenAI tool calls must have an "id" field.');
  return {
    id: r.id,
    type: "function",
    function: {
      name: r.name,
      arguments: JSON.stringify(r.args)
    }
  };
}
function Hi(r, e) {
  var t, n;
  return {
    name: (t = r.function) == null ? void 0 : t.name,
    args: (n = r.function) == null ? void 0 : n.arguments,
    id: r.id,
    error: e,
    type: "invalid_tool_call"
  };
}
var ey = class extends No {
  constructor(e) {
    super(e);
    v(this, "returnId", !1);
    v(this, "lc_namespace", [
      "langchain",
      "output_parsers",
      "openai_tools"
    ]);
    v(this, "lc_serializable", !0);
    this.returnId = (e == null ? void 0 : e.returnId) ?? this.returnId;
  }
  static lc_name() {
    return "JsonOutputToolsParser";
  }
  _diff() {
    throw new Error("Not supported.");
  }
  async parse() {
    throw new Error("Not implemented.");
  }
  async parseResult(e) {
    return await this.parsePartialResult(e, !1);
  }
  /**
  * Parses the output and returns a JSON object. If `argsOnly` is true,
  * only the arguments of the function call are returned.
  * @param generations The output of the LLM to parse.
  * @returns A JSON object representation of the function call or its arguments.
  */
  async parsePartialResult(e, t = !0) {
    var i;
    const n = e[0].message;
    let s;
    if (oo(n) && ((i = n.tool_calls) != null && i.length) ? s = n.tool_calls.map((o) => {
      const { id: c, ...u } = o;
      return this.returnId ? {
        id: c,
        ...u
      } : u;
    }) : n.additional_kwargs.tool_calls !== void 0 && (s = JSON.parse(JSON.stringify(n.additional_kwargs.tool_calls)).map((c) => Po(c, {
      returnId: this.returnId,
      partial: t
    }))), !s) return [];
    const a = [];
    for (const o of s) if (o !== void 0) {
      const c = {
        type: o.name,
        args: o.args,
        id: o.id
      };
      a.push(c);
    }
    return a;
  }
}, wu = class extends ey {
  constructor(e) {
    super(e);
    v(this, "lc_namespace", [
      "langchain",
      "output_parsers",
      "openai_tools"
    ]);
    v(this, "lc_serializable", !0);
    v(this, "returnId", !1);
    /** The type of tool calls to return. */
    v(this, "keyName");
    /** Whether to return only the first tool call. */
    v(this, "returnSingle", !1);
    v(this, "zodSchema");
    this.keyName = e.keyName, this.returnSingle = e.returnSingle ?? this.returnSingle, this.zodSchema = e.zodSchema;
  }
  static lc_name() {
    return "JsonOutputKeyToolsParser";
  }
  async _validateResult(e) {
    var n;
    if (this.zodSchema === void 0) return e;
    const t = await e_(this.zodSchema, e);
    if (t.success) return t.data;
    throw new jr(`Failed to parse. Text: "${JSON.stringify(e, null, 2)}". Error: ${JSON.stringify((n = t.error) == null ? void 0 : n.issues)}`, JSON.stringify(e, null, 2));
  }
  async parsePartialResult(e) {
    const n = (await super.parsePartialResult(e)).filter((a) => a.type === this.keyName);
    let s = n;
    if (n.length)
      return this.returnId || (s = n.map((a) => a.args)), this.returnSingle ? s[0] : s;
  }
  async parseResult(e) {
    const n = (await super.parsePartialResult(e, !1)).filter((i) => i.type === this.keyName);
    let s = n;
    return n.length ? (this.returnId || (s = n.map((i) => i.args)), this.returnSingle ? this._validateResult(s[0]) : await Promise.all(s.map((i) => this._validateResult(i)))) : void 0;
  }
}, t1 = {};
Ae(t1, {
  JsonOutputKeyToolsParser: () => wu,
  JsonOutputToolsParser: () => ey,
  convertLangChainToolCallToOpenAI: () => Q_,
  makeInvalidToolCall: () => Hi,
  parseToolCall: () => Po
});
var Vl = class extends Zl {
  constructor(e) {
    var n, s, a, i;
    super(e ?? {});
    v(this, "temperature");
    v(this, "topP");
    v(this, "frequencyPenalty");
    v(this, "presencePenalty");
    v(this, "n");
    v(this, "logitBias");
    v(this, "model", "gpt-3.5-turbo");
    v(this, "modelKwargs");
    v(this, "stop");
    v(this, "stopSequences");
    v(this, "user");
    v(this, "timeout");
    v(this, "streaming", !1);
    v(this, "streamUsage", !0);
    v(this, "maxTokens");
    v(this, "logprobs");
    v(this, "topLogprobs");
    v(this, "apiKey");
    v(this, "organization");
    v(this, "__includeRawResponse");
    /** @internal */
    v(this, "client");
    /** @internal */
    v(this, "clientConfig");
    /**
    * Whether the model supports the `strict` argument when passing in tools.
    * If `undefined` the `strict` argument will not be passed to OpenAI.
    */
    v(this, "supportsStrictToolCalling");
    v(this, "audio");
    v(this, "modalities");
    v(this, "reasoning");
    /**
    * Must be set to `true` in tenancies with Zero Data Retention. Setting to `true` will disable
    * output storage in the Responses API, but this DOES NOT enable Zero Data Retention in your
    * OpenAI organization or project. This must be configured directly with OpenAI.
    *
    * See:
    * https://platform.openai.com/docs/guides/your-data
    * https://platform.openai.com/docs/api-reference/responses/create#responses-create-store
    *
    * @default false
    */
    v(this, "zdrEnabled");
    /**
    * Service tier to use for this request. Can be "auto", "default", or "flex" or "priority".
    * Specifies the service tier for prioritization and latency optimization.
    */
    v(this, "service_tier");
    /**
    * Used by OpenAI to cache responses for similar requests to optimize your cache
    * hit rates.
    * [Learn more](https://platform.openai.com/docs/guides/prompt-caching).
    */
    v(this, "promptCacheKey");
    /**
    * The verbosity of the model's response.
    */
    v(this, "verbosity");
    v(this, "defaultOptions");
    v(this, "lc_serializable", !0);
    const t = typeof ((n = e == null ? void 0 : e.configuration) == null ? void 0 : n.apiKey) == "string" || typeof ((s = e == null ? void 0 : e.configuration) == null ? void 0 : s.apiKey) == "function" ? (a = e == null ? void 0 : e.configuration) == null ? void 0 : a.apiKey : void 0;
    this.apiKey = (e == null ? void 0 : e.apiKey) ?? t ?? Er("OPENAI_API_KEY"), this.organization = ((i = e == null ? void 0 : e.configuration) == null ? void 0 : i.organization) ?? Er("OPENAI_ORGANIZATION"), this.model = (e == null ? void 0 : e.model) ?? (e == null ? void 0 : e.modelName) ?? this.model, this.modelKwargs = (e == null ? void 0 : e.modelKwargs) ?? {}, this.timeout = e == null ? void 0 : e.timeout, this.temperature = (e == null ? void 0 : e.temperature) ?? this.temperature, this.topP = (e == null ? void 0 : e.topP) ?? this.topP, this.frequencyPenalty = (e == null ? void 0 : e.frequencyPenalty) ?? this.frequencyPenalty, this.presencePenalty = (e == null ? void 0 : e.presencePenalty) ?? this.presencePenalty, this.logprobs = e == null ? void 0 : e.logprobs, this.topLogprobs = e == null ? void 0 : e.topLogprobs, this.n = (e == null ? void 0 : e.n) ?? this.n, this.logitBias = e == null ? void 0 : e.logitBias, this.stop = (e == null ? void 0 : e.stopSequences) ?? (e == null ? void 0 : e.stop), this.stopSequences = this.stop, this.user = e == null ? void 0 : e.user, this.__includeRawResponse = e == null ? void 0 : e.__includeRawResponse, this.audio = e == null ? void 0 : e.audio, this.modalities = e == null ? void 0 : e.modalities, this.reasoning = e == null ? void 0 : e.reasoning, this.maxTokens = (e == null ? void 0 : e.maxCompletionTokens) ?? (e == null ? void 0 : e.maxTokens), this.promptCacheKey = (e == null ? void 0 : e.promptCacheKey) ?? this.promptCacheKey, this.verbosity = (e == null ? void 0 : e.verbosity) ?? this.verbosity, this.disableStreaming = (e == null ? void 0 : e.disableStreaming) === !0, this.streaming = (e == null ? void 0 : e.streaming) === !0, this.disableStreaming && (this.streaming = !1), (e == null ? void 0 : e.streaming) === !1 && (this.disableStreaming = !0), this.streamUsage = (e == null ? void 0 : e.streamUsage) ?? this.streamUsage, this.disableStreaming && (this.streamUsage = !1), this.clientConfig = {
      apiKey: this.apiKey,
      organization: this.organization,
      dangerouslyAllowBrowser: !0,
      ...e == null ? void 0 : e.configuration
    }, (e == null ? void 0 : e.supportsStrictToolCalling) !== void 0 && (this.supportsStrictToolCalling = e.supportsStrictToolCalling), (e == null ? void 0 : e.service_tier) !== void 0 && (this.service_tier = e.service_tier), this.zdrEnabled = (e == null ? void 0 : e.zdrEnabled) ?? !1;
  }
  _llmType() {
    return "openai";
  }
  static lc_name() {
    return "ChatOpenAI";
  }
  get callKeys() {
    return [
      ...super.callKeys,
      "options",
      "function_call",
      "functions",
      "tools",
      "tool_choice",
      "promptIndex",
      "response_format",
      "seed",
      "reasoning",
      "service_tier"
    ];
  }
  get lc_secrets() {
    return {
      apiKey: "OPENAI_API_KEY",
      organization: "OPENAI_ORGANIZATION"
    };
  }
  get lc_aliases() {
    return {
      apiKey: "openai_api_key",
      modelName: "model"
    };
  }
  get lc_serializable_keys() {
    return [
      "configuration",
      "logprobs",
      "topLogprobs",
      "prefixMessages",
      "supportsStrictToolCalling",
      "modalities",
      "audio",
      "temperature",
      "maxTokens",
      "topP",
      "frequencyPenalty",
      "presencePenalty",
      "n",
      "logitBias",
      "user",
      "streaming",
      "streamUsage",
      "model",
      "modelName",
      "modelKwargs",
      "stop",
      "stopSequences",
      "timeout",
      "apiKey",
      "cache",
      "maxConcurrency",
      "maxRetries",
      "verbose",
      "callbacks",
      "tags",
      "metadata",
      "disableStreaming",
      "zdrEnabled",
      "reasoning",
      "promptCacheKey",
      "verbosity"
    ];
  }
  getLsParams(e) {
    const t = this.invocationParams(e);
    return {
      ls_provider: "openai",
      ls_model_name: this.model,
      ls_model_type: "chat",
      ls_temperature: t.temperature ?? void 0,
      ls_max_tokens: t.max_tokens ?? void 0,
      ls_stop: e.stop
    };
  }
  /** @ignore */
  _identifyingParams() {
    return {
      model_name: this.model,
      ...this.invocationParams(),
      ...this.clientConfig
    };
  }
  /**
  * Get the identifying parameters for the model
  */
  identifyingParams() {
    return this._identifyingParams();
  }
  /**
  * Returns backwards compatible reasoning parameters from constructor params and call options
  * @internal
  */
  _getReasoningParams(e) {
    if (!ma(this.model)) return;
    let t;
    return this.reasoning !== void 0 && (t = {
      ...t,
      ...this.reasoning
    }), (e == null ? void 0 : e.reasoning) !== void 0 && (t = {
      ...t,
      ...e.reasoning
    }), t;
  }
  /**
  * Returns an openai compatible response format from a set of options
  * @internal
  */
  _getResponseFormat(e) {
    return e && e.type === "json_schema" && e.json_schema.schema && br(e.json_schema.schema) ? rC(e.json_schema.schema, e.json_schema.name, { description: e.json_schema.description }) : e;
  }
  _combineCallOptions(e) {
    return {
      ...this.defaultOptions,
      ...e ?? {}
    };
  }
  /** @internal */
  _getClientOptions(e) {
    if (!this.client) {
      const n = { baseURL: this.clientConfig.baseURL }, s = LO(n), a = {
        ...this.clientConfig,
        baseURL: s,
        timeout: this.timeout,
        maxRetries: 0
      };
      a.baseURL || delete a.baseURL, a.defaultHeaders = jO(a.defaultHeaders), this.client = new xe(a);
    }
    return {
      ...this.clientConfig,
      ...e
    };
  }
  _convertChatOpenAIToolToCompletionsTool(e, t) {
    return zi(e) ? WO(e.metadata.customTool) : Ul(e) ? (t == null ? void 0 : t.strict) !== void 0 ? {
      ...e,
      function: {
        ...e.function,
        strict: t.strict
      }
    } : e : zO(e, t);
  }
  bindTools(e, t) {
    let n;
    return (t == null ? void 0 : t.strict) !== void 0 ? n = t.strict : this.supportsStrictToolCalling !== void 0 && (n = this.supportsStrictToolCalling), this.withConfig({
      tools: e.map((s) => jl(s) || zi(s) ? s : this._convertChatOpenAIToolToCompletionsTool(s, { strict: n })),
      ...t
    });
  }
  async stream(e, t) {
    return super.stream(e, this._combineCallOptions(t));
  }
  async invoke(e, t) {
    return super.invoke(e, this._combineCallOptions(t));
  }
  /** @ignore */
  _combineLLMOutput(...e) {
    return e.reduce((t, n) => (n && n.tokenUsage && (t.tokenUsage.completionTokens += n.tokenUsage.completionTokens ?? 0, t.tokenUsage.promptTokens += n.tokenUsage.promptTokens ?? 0, t.tokenUsage.totalTokens += n.tokenUsage.totalTokens ?? 0), t), { tokenUsage: {
      completionTokens: 0,
      promptTokens: 0,
      totalTokens: 0
    } });
  }
  async getNumTokensFromMessages(e) {
    let t = 0, n = 0, s = 0;
    this.model === "gpt-3.5-turbo-0301" ? (n = 4, s = -1) : (n = 3, s = 1);
    const a = await Promise.all(e.map(async (i) => {
      var h, f, p, y, g, S;
      const o = await this.getNumTokens(i.content), c = await this.getNumTokens(ga(i)), u = i.name !== void 0 ? s + await this.getNumTokens(i.name) : 0;
      let l = o + n + c + u;
      const d = i;
      if (d._getType() === "function" && (l -= 2), (h = d.additional_kwargs) != null && h.function_call && (l += 3), (f = d == null ? void 0 : d.additional_kwargs.function_call) != null && f.name && (l += await this.getNumTokens((p = d.additional_kwargs.function_call) == null ? void 0 : p.name)), (y = d.additional_kwargs.function_call) != null && y.arguments) try {
        l += await this.getNumTokens(JSON.stringify(JSON.parse((g = d.additional_kwargs.function_call) == null ? void 0 : g.arguments)));
      } catch (_) {
        console.error("Error parsing function arguments", _, JSON.stringify(d.additional_kwargs.function_call)), l += await this.getNumTokens((S = d.additional_kwargs.function_call) == null ? void 0 : S.arguments);
      }
      return t += l, l;
    }));
    return t += 3, {
      totalCount: t,
      countPerMessage: a
    };
  }
  /** @internal */
  async _getNumTokensFromGenerations(e) {
    return (await Promise.all(e.map(async (n) => {
      var s;
      return (s = n.message.additional_kwargs) != null && s.function_call ? (await this.getNumTokensFromMessages([n.message])).countPerMessage[0] : await this.getNumTokens(n.message.content);
    }))).reduce((n, s) => n + s, 0);
  }
  /** @internal */
  async _getEstimatedTokenCountFromPrompt(e, t, n) {
    let s = (await this.getNumTokensFromMessages(e)).totalCount;
    if (t && n !== "auto") {
      const a = ZO(t);
      s += await this.getNumTokens(a), s += 9;
    }
    return t && e.find((a) => a._getType() === "system") && (s -= 4), n === "none" ? s += 1 : typeof n == "object" && (s += await this.getNumTokens(n.name) + 4), s;
  }
  /**
  * Return profiling information for the model.
  *
  * Provides information about the model's capabilities and constraints,
  * including token limits, multimodal support, and advanced features like
  * tool calling and structured output.
  *
  * @returns {ModelProfile} An object describing the model's capabilities and constraints
  *
  * @example
  * ```typescript
  * const model = new ChatOpenAI({ model: "gpt-4o" });
  * const profile = model.profile;
  * console.log(profile.maxInputTokens); // 128000
  * console.log(profile.imageInputs); // true
  * ```
  */
  get profile() {
    return aC[this.model] ?? {};
  }
  /** @internal */
  _getStructuredOutputMethod(e) {
    const t = { ...e };
    if (!this.model.startsWith("gpt-3") && !this.model.startsWith("gpt-4-") && this.model !== "gpt-4") {
      if ((t == null ? void 0 : t.method) === void 0) return "jsonSchema";
    } else t.method === "jsonSchema" && console.warn(`[WARNING]: JSON Schema is not supported for model "${this.model}". Falling back to tool calling.`);
    return t.method;
  }
  /**
  * Add structured output to the model.
  *
  * The OpenAI model family supports the following structured output methods:
  * - `jsonSchema`: Use the `response_format` field in the response to return a JSON schema. Only supported with the `gpt-4o-mini`,
  *   `gpt-4o-mini-2024-07-18`, and `gpt-4o-2024-08-06` model snapshots and later.
  * - `functionCalling`: Function calling is useful when you are building an application that bridges the models and functionality
  *   of your application.
  * - `jsonMode`: JSON mode is a more basic version of the Structured Outputs feature. While JSON mode ensures that model
  *   output is valid JSON, Structured Outputs reliably matches the model's output to the schema you specify.
  *   We recommend you use `functionCalling` or `jsonSchema` if it is supported for your use case.
  *
  * The default method is `functionCalling`.
  *
  * @see https://platform.openai.com/docs/guides/structured-outputs
  * @param outputSchema - The schema to use for structured output.
  * @param config - The structured output method options.
  * @returns The model with structured output.
  */
  withStructuredOutput(e, t) {
    let n, s;
    const { schema: a, name: i, includeRaw: o } = {
      ...t,
      schema: e
    };
    if ((t == null ? void 0 : t.strict) !== void 0 && t.method === "jsonMode") throw new Error("Argument `strict` is only supported for `method` = 'function_calling'");
    const c = eC(this.model, t == null ? void 0 : t.method);
    if (c === "jsonMode") {
      br(a) ? s = qi.fromZodSchema(a) : s = new gu();
      const h = Sr(a);
      n = this.withConfig({
        outputVersion: "v0",
        response_format: { type: "json_object" },
        ls_structured_output_format: {
          kwargs: { method: "json_mode" },
          schema: {
            title: i ?? "extract",
            ...h
          }
        }
      });
    } else if (c === "jsonSchema") {
      const h = {
        name: i ?? "extract",
        description: Eo(a),
        schema: a,
        strict: t == null ? void 0 : t.strict
      }, f = Sr(h.schema);
      if (n = this.withConfig({
        outputVersion: "v0",
        response_format: {
          type: "json_schema",
          json_schema: h
        },
        ls_structured_output_format: {
          kwargs: { method: "json_schema" },
          schema: {
            title: h.name,
            description: h.description,
            ...f
          }
        }
      }), br(a)) {
        const p = qi.fromZodSchema(a);
        s = qr.from((y) => "parsed" in y.additional_kwargs ? y.additional_kwargs.parsed : p);
      } else s = new gu();
    } else {
      let h = i ?? "extract";
      if (br(a)) {
        const f = Sr(a);
        n = this.withConfig({
          outputVersion: "v0",
          tools: [{
            type: "function",
            function: {
              name: h,
              description: f.description,
              parameters: f
            }
          }],
          tool_choice: {
            type: "function",
            function: { name: h }
          },
          ls_structured_output_format: {
            kwargs: { method: "function_calling" },
            schema: {
              title: h,
              ...f
            }
          },
          ...(t == null ? void 0 : t.strict) !== void 0 ? { strict: t.strict } : {}
        }), s = new wu({
          returnSingle: !0,
          keyName: h,
          zodSchema: a
        });
      } else {
        let f;
        typeof a.name == "string" && typeof a.parameters == "object" && a.parameters != null ? (f = a, h = a.name) : (h = a.title ?? h, f = {
          name: h,
          description: a.description ?? "",
          parameters: a
        });
        const p = Sr(a);
        n = this.withConfig({
          outputVersion: "v0",
          tools: [{
            type: "function",
            function: f
          }],
          tool_choice: {
            type: "function",
            function: { name: h }
          },
          ls_structured_output_format: {
            kwargs: { method: "function_calling" },
            schema: {
              title: h,
              ...p
            }
          },
          ...(t == null ? void 0 : t.strict) !== void 0 ? { strict: t.strict } : {}
        }), s = new wu({
          returnSingle: !0,
          keyName: h
        });
      }
    }
    if (!o) return n.pipe(s);
    const u = as.assign({ parsed: (h, f) => s.invoke(h.raw, f) }), l = as.assign({ parsed: () => null }), d = u.withFallbacks({ fallbacks: [l] });
    return pa.from([{ raw: n }, d]);
  }
};
const ty = {
  providerName: "ChatOpenAI",
  fromStandardTextBlock(r) {
    return {
      type: "text",
      text: r.text
    };
  },
  fromStandardImageBlock(r) {
    var e, t;
    if (r.source_type === "url") return {
      type: "image_url",
      image_url: {
        url: r.url,
        ...(e = r.metadata) != null && e.detail ? { detail: r.metadata.detail } : {}
      }
    };
    if (r.source_type === "base64")
      return {
        type: "image_url",
        image_url: {
          url: `data:${r.mime_type ?? ""};base64,${r.data}`,
          ...(t = r.metadata) != null && t.detail ? { detail: r.metadata.detail } : {}
        }
      };
    throw new Error(`Image content blocks with source_type ${r.source_type} are not supported for ChatOpenAI`);
  },
  fromStandardAudioBlock(r) {
    if (r.source_type === "url") {
      const e = Vs({ dataUrl: r.url });
      if (!e) throw new Error(`URL audio blocks with source_type ${r.source_type} must be formatted as a data URL for ChatOpenAI`);
      const t = e.mime_type || r.mime_type || "";
      let n;
      try {
        n = Nc(t);
      } catch {
        throw new Error(`Audio blocks with source_type ${r.source_type} must have mime type of audio/wav or audio/mp3`);
      }
      if (n.type !== "audio" || n.subtype !== "wav" && n.subtype !== "mp3") throw new Error(`Audio blocks with source_type ${r.source_type} must have mime type of audio/wav or audio/mp3`);
      return {
        type: "input_audio",
        input_audio: {
          format: n.subtype,
          data: e.data
        }
      };
    }
    if (r.source_type === "base64") {
      let e;
      try {
        e = Nc(r.mime_type ?? "");
      } catch {
        throw new Error(`Audio blocks with source_type ${r.source_type} must have mime type of audio/wav or audio/mp3`);
      }
      if (e.type !== "audio" || e.subtype !== "wav" && e.subtype !== "mp3") throw new Error(`Audio blocks with source_type ${r.source_type} must have mime type of audio/wav or audio/mp3`);
      return {
        type: "input_audio",
        input_audio: {
          format: e.subtype,
          data: r.data
        }
      };
    }
    throw new Error(`Audio content blocks with source_type ${r.source_type} are not supported for ChatOpenAI`);
  },
  fromStandardFileBlock(r) {
    var e, t, n, s, a, i, o, c, u, l;
    if (r.source_type === "url") {
      if (!Vs({ dataUrl: r.url })) throw new Error(`URL file blocks with source_type ${r.source_type} must be formatted as a data URL for ChatOpenAI`);
      return {
        type: "file",
        file: {
          file_data: r.url,
          ...(e = r.metadata) != null && e.filename || (t = r.metadata) != null && t.name ? { filename: ((n = r.metadata) == null ? void 0 : n.filename) || ((s = r.metadata) == null ? void 0 : s.name) } : {}
        }
      };
    }
    if (r.source_type === "base64") return {
      type: "file",
      file: {
        file_data: `data:${r.mime_type ?? ""};base64,${r.data}`,
        ...(a = r.metadata) != null && a.filename || (i = r.metadata) != null && i.name || (o = r.metadata) != null && o.title ? { filename: ((c = r.metadata) == null ? void 0 : c.filename) || ((u = r.metadata) == null ? void 0 : u.name) || ((l = r.metadata) == null ? void 0 : l.title) } : {}
      }
    };
    if (r.source_type === "id") return {
      type: "file",
      file: { file_id: r.id }
    };
    throw new Error(`File content blocks with source_type ${r.source_type} are not supported for ChatOpenAI`);
  }
}, r1 = ({ message: r, rawResponse: e, includeRawResponse: t }) => {
  var s, a;
  const n = r.tool_calls;
  switch (r.role) {
    case "assistant": {
      const i = [], o = [];
      for (const d of n ?? []) try {
        i.push(Po(d, { returnId: !0 }));
      } catch (h) {
        o.push(Hi(d, h.message));
      }
      const c = {
        function_call: r.function_call,
        tool_calls: n
      };
      t !== void 0 && (c.__raw_response = e);
      const u = {
        model_provider: "openai",
        model_name: e.model,
        ...e.system_fingerprint ? {
          usage: { ...e.usage },
          system_fingerprint: e.system_fingerprint
        } : {}
      };
      r.audio && (c.audio = r.audio);
      const l = nC(r.content || "", (a = (s = e.choices) == null ? void 0 : s[0]) == null ? void 0 : a.message);
      return new Fe({
        content: l,
        tool_calls: i,
        invalid_tool_calls: o,
        additional_kwargs: c,
        response_metadata: u,
        id: e.id
      });
    }
    default:
      return new In(r.content || "", r.role ?? "unknown");
  }
}, n1 = ({ delta: r, rawResponse: e, includeRawResponse: t, defaultRole: n }) => {
  var c, u;
  const s = r.role ?? n, a = r.content ?? "";
  let i;
  r.function_call ? i = { function_call: r.function_call } : r.tool_calls ? i = { tool_calls: r.tool_calls } : i = {}, t && (i.__raw_response = e), r.audio && (i.audio = {
    ...r.audio,
    index: e.choices[0].index
  });
  const o = {
    model_provider: "openai",
    usage: { ...e.usage }
  };
  if (s === "user") return new ua({
    content: a,
    response_metadata: o
  });
  if (s === "assistant") {
    const l = [];
    if (Array.isArray(r.tool_calls)) for (const d of r.tool_calls) l.push({
      name: (c = d.function) == null ? void 0 : c.name,
      args: (u = d.function) == null ? void 0 : u.arguments,
      id: d.id,
      index: d.index,
      type: "tool_call_chunk"
    });
    return new Ar({
      content: a,
      tool_call_chunks: l,
      additional_kwargs: i,
      id: e.id,
      response_metadata: o
    });
  } else return s === "system" ? new nn({
    content: a,
    response_metadata: o
  }) : s === "developer" ? new nn({
    content: a,
    response_metadata: o,
    additional_kwargs: { __openai_role__: "developer" }
  }) : s === "function" ? new ca({
    content: a,
    additional_kwargs: i,
    name: r.name,
    response_metadata: o
  }) : s === "tool" ? new ia({
    content: a,
    additional_kwargs: i,
    tool_call_id: r.tool_call_id,
    response_metadata: o
  }) : new oa({
    content: a,
    role: s,
    response_metadata: o
  });
}, s1 = (r) => {
  if (r.type === "image") {
    if (r.url) return {
      type: "image_url",
      image_url: { url: r.url }
    };
    if (r.data) return {
      type: "image_url",
      image_url: { url: `data:${r.mimeType};base64,${r.data}` }
    };
  }
  if (r.type === "audio" && r.data) {
    const e = Om(() => {
      const [, t] = r.mimeType.split("/");
      return t === "wav" || t === "mp3" ? t : "wav";
    });
    return {
      type: "input_audio",
      input_audio: {
        data: r.data.toString(),
        format: e
      }
    };
  }
  if (r.type === "file") {
    if (r.data) return {
      type: "file",
      file: { file_data: r.data.toString() }
    };
    if (r.fileId) return {
      type: "file",
      file: { file_id: r.fileId }
    };
  }
}, a1 = ({ message: r, model: e }) => {
  let t = ga(r);
  if (t === "system" && ma(e) && (t = "developer"), t === "developer") return {
    role: "developer",
    content: r.contentBlocks.filter((s) => s.type === "text")
  };
  if (t === "system") return {
    role: "system",
    content: r.contentBlocks.filter((s) => s.type === "text")
  };
  if (t === "assistant") return {
    role: "assistant",
    content: r.contentBlocks.filter((s) => s.type === "text")
  };
  if (t === "tool" && kr.isInstance(r)) return {
    role: "tool",
    tool_call_id: r.tool_call_id,
    content: r.contentBlocks.filter((s) => s.type === "text")
  };
  if (t === "function") return {
    role: "function",
    name: r.name ?? "",
    content: r.contentBlocks.filter((s) => s.type === "text").join("")
  };
  function* n(s) {
    for (const a of s) {
      a.type === "text" && (yield {
        type: "text",
        text: a.text
      });
      const i = s1(a);
      i && (yield i);
    }
  }
  return {
    role: "user",
    content: Array.from(n(r.contentBlocks))
  };
}, _f = ({ messages: r, model: e }) => r.flatMap((t) => {
  var i, o;
  if ("output_version" in t.response_metadata && ((i = t.response_metadata) == null ? void 0 : i.output_version) === "v1") return a1({ message: t });
  let n = ga(t);
  n === "system" && ma(e) && (n = "developer");
  const s = typeof t.content == "string" ? t.content : t.content.map((c) => Ir(c) ? Gu(c, ty) : c), a = {
    role: n,
    content: s
  };
  if (t.name != null && (a.name = t.name), t.additional_kwargs.function_call != null && (a.function_call = t.additional_kwargs.function_call, a.content = ""), Fe.isInstance(t) && ((o = t.tool_calls) != null && o.length) ? (a.tool_calls = t.tool_calls.map(Q_), a.content = "") : (t.additional_kwargs.tool_calls != null && (a.tool_calls = t.additional_kwargs.tool_calls), kr.isInstance(t) && t.tool_call_id != null && (a.tool_call_id = t.tool_call_id)), t.additional_kwargs.audio && typeof t.additional_kwargs.audio == "object" && "id" in t.additional_kwargs.audio) {
    const c = {
      role: "assistant",
      audio: { id: t.additional_kwargs.audio.id }
    };
    return [a, c];
  }
  return a;
});
var i1 = class extends Vl {
  /** @internal */
  invocationParams(r, e) {
    var i;
    let t;
    (r == null ? void 0 : r.strict) !== void 0 ? t = r.strict : this.supportsStrictToolCalling !== void 0 && (t = this.supportsStrictToolCalling);
    let n = {};
    (r == null ? void 0 : r.stream_options) !== void 0 ? n = { stream_options: r.stream_options } : this.streamUsage && (this.streaming || e != null && e.streaming) && (n = { stream_options: { include_usage: !0 } });
    const s = {
      model: this.model,
      temperature: this.temperature,
      top_p: this.topP,
      frequency_penalty: this.frequencyPenalty,
      presence_penalty: this.presencePenalty,
      logprobs: this.logprobs,
      top_logprobs: this.topLogprobs,
      n: this.n,
      logit_bias: this.logitBias,
      stop: (r == null ? void 0 : r.stop) ?? this.stopSequences,
      user: this.user,
      stream: this.streaming,
      functions: r == null ? void 0 : r.functions,
      function_call: r == null ? void 0 : r.function_call,
      tools: (i = r == null ? void 0 : r.tools) != null && i.length ? r.tools.map((o) => this._convertChatOpenAIToolToCompletionsTool(o, { strict: t })) : void 0,
      tool_choice: A_(r == null ? void 0 : r.tool_choice),
      response_format: this._getResponseFormat(r == null ? void 0 : r.response_format),
      seed: r == null ? void 0 : r.seed,
      ...n,
      parallel_tool_calls: r == null ? void 0 : r.parallel_tool_calls,
      ...this.audio || r != null && r.audio ? { audio: this.audio || (r == null ? void 0 : r.audio) } : {},
      ...this.modalities || r != null && r.modalities ? { modalities: this.modalities || (r == null ? void 0 : r.modalities) } : {},
      ...this.modelKwargs,
      prompt_cache_key: (r == null ? void 0 : r.promptCacheKey) ?? this.promptCacheKey,
      verbosity: (r == null ? void 0 : r.verbosity) ?? this.verbosity
    };
    (r == null ? void 0 : r.prediction) !== void 0 && (s.prediction = r.prediction), this.service_tier !== void 0 && (s.service_tier = this.service_tier), (r == null ? void 0 : r.service_tier) !== void 0 && (s.service_tier = r.service_tier);
    const a = this._getReasoningParams(r);
    return a !== void 0 && a.effort !== void 0 && (s.reasoning_effort = a.effort), ma(s.model) ? s.max_completion_tokens = this.maxTokens === -1 ? void 0 : this.maxTokens : s.max_tokens = this.maxTokens === -1 ? void 0 : this.maxTokens, s;
  }
  async _generate(r, e, t) {
    var i, o;
    const n = {}, s = this.invocationParams(e), a = _f({
      messages: r,
      model: this.model
    });
    if (s.stream) {
      const c = this._streamResponseChunks(r, e, t), u = {};
      for await (const y of c) {
        y.message.response_metadata = {
          ...y.generationInfo,
          ...y.message.response_metadata
        };
        const g = ((i = y.generationInfo) == null ? void 0 : i.completion) ?? 0;
        u[g] === void 0 ? u[g] = y : u[g] = u[g].concat(y);
      }
      const l = Object.entries(u).sort(([y], [g]) => parseInt(y, 10) - parseInt(g, 10)).map(([y, g]) => g), { functions: d, function_call: h } = this.invocationParams(e), f = await this._getEstimatedTokenCountFromPrompt(r, d, h), p = await this._getNumTokensFromGenerations(l);
      return n.input_tokens = f, n.output_tokens = p, n.total_tokens = f + p, {
        generations: l,
        llmOutput: { estimatedTokenUsage: {
          promptTokens: n.input_tokens,
          completionTokens: n.output_tokens,
          totalTokens: n.total_tokens
        } }
      };
    } else {
      const c = await this.completionWithRetry({
        ...s,
        stream: !1,
        messages: a
      }, {
        signal: e == null ? void 0 : e.signal,
        ...e == null ? void 0 : e.options
      }), { completion_tokens: u, prompt_tokens: l, total_tokens: d, prompt_tokens_details: h, completion_tokens_details: f } = (c == null ? void 0 : c.usage) ?? {};
      u && (n.output_tokens = (n.output_tokens ?? 0) + u), l && (n.input_tokens = (n.input_tokens ?? 0) + l), d && (n.total_tokens = (n.total_tokens ?? 0) + d), ((h == null ? void 0 : h.audio_tokens) !== null || (h == null ? void 0 : h.cached_tokens) !== null) && (n.input_token_details = {
        ...(h == null ? void 0 : h.audio_tokens) !== null && { audio: h == null ? void 0 : h.audio_tokens },
        ...(h == null ? void 0 : h.cached_tokens) !== null && { cache_read: h == null ? void 0 : h.cached_tokens }
      }), ((f == null ? void 0 : f.audio_tokens) !== null || (f == null ? void 0 : f.reasoning_tokens) !== null) && (n.output_token_details = {
        ...(f == null ? void 0 : f.audio_tokens) !== null && { audio: f == null ? void 0 : f.audio_tokens },
        ...(f == null ? void 0 : f.reasoning_tokens) !== null && { reasoning: f == null ? void 0 : f.reasoning_tokens }
      });
      const p = [];
      for (const y of (c == null ? void 0 : c.choices) ?? []) {
        const S = {
          text: ((o = y.message) == null ? void 0 : o.content) ?? "",
          message: this._convertCompletionsMessageToBaseMessage(y.message ?? { role: "assistant" }, c)
        };
        S.generationInfo = {
          ...y.finish_reason ? { finish_reason: y.finish_reason } : {},
          ...y.logprobs ? { logprobs: y.logprobs } : {}
        }, oo(S.message) && (S.message.usage_metadata = n), S.message = new Fe(Object.fromEntries(Object.entries(S.message).filter(([_]) => !_.startsWith("lc_")))), p.push(S);
      }
      return {
        generations: p,
        llmOutput: { tokenUsage: {
          promptTokens: n.input_tokens,
          completionTokens: n.output_tokens,
          totalTokens: n.total_tokens
        } }
      };
    }
  }
  async *_streamResponseChunks(r, e, t) {
    var c, u, l, d, h, f, p, y, g, S;
    const n = _f({
      messages: r,
      model: this.model
    }), s = {
      ...this.invocationParams(e, { streaming: !0 }),
      messages: n,
      stream: !0
    };
    let a;
    const i = await this.completionWithRetry(s, e);
    let o;
    for await (const _ of i) {
      const w = (c = _ == null ? void 0 : _.choices) == null ? void 0 : c[0];
      if (_.usage && (o = _.usage), !w) continue;
      const { delta: T } = w;
      if (!T) continue;
      const x = this._convertCompletionsDeltaToBaseMessageChunk(T, _, a);
      a = T.role ?? a;
      const A = {
        prompt: e.promptIndex ?? 0,
        completion: w.index ?? 0
      };
      if (typeof x.content != "string") {
        console.log("[WARNING]: Received non-string content from OpenAI. This is currently not supported.");
        continue;
      }
      const R = { ...A };
      w.finish_reason != null && (R.finish_reason = w.finish_reason, R.system_fingerprint = _.system_fingerprint, R.model_name = _.model, R.service_tier = _.service_tier), this.logprobs && (R.logprobs = w.logprobs);
      const E = new Qn({
        message: x,
        text: x.content,
        generationInfo: R
      });
      yield E, await (t == null ? void 0 : t.handleLLMNewToken(E.text ?? "", A, void 0, void 0, void 0, { chunk: E }));
    }
    if (o) {
      const _ = {
        ...((u = o.prompt_tokens_details) == null ? void 0 : u.audio_tokens) !== null && { audio: (l = o.prompt_tokens_details) == null ? void 0 : l.audio_tokens },
        ...((d = o.prompt_tokens_details) == null ? void 0 : d.cached_tokens) !== null && { cache_read: (h = o.prompt_tokens_details) == null ? void 0 : h.cached_tokens }
      }, w = {
        ...((f = o.completion_tokens_details) == null ? void 0 : f.audio_tokens) !== null && { audio: (p = o.completion_tokens_details) == null ? void 0 : p.audio_tokens },
        ...((y = o.completion_tokens_details) == null ? void 0 : y.reasoning_tokens) !== null && { reasoning: (g = o.completion_tokens_details) == null ? void 0 : g.reasoning_tokens }
      };
      yield new Qn({
        message: new Ar({
          content: "",
          response_metadata: { usage: { ...o } },
          usage_metadata: {
            input_tokens: o.prompt_tokens,
            output_tokens: o.completion_tokens,
            total_tokens: o.total_tokens,
            ...Object.keys(_).length > 0 && { input_token_details: _ },
            ...Object.keys(w).length > 0 && { output_token_details: w }
          }
        }),
        text: ""
      });
    }
    if ((S = e.signal) != null && S.aborted) throw new Error("AbortError");
  }
  async completionWithRetry(r, e) {
    const t = this._getClientOptions(e), n = r.response_format && r.response_format.type === "json_schema";
    return this.caller.call(async () => {
      try {
        return n && !r.stream ? await this.client.chat.completions.parse(r, t) : await this.client.chat.completions.create(r, t);
      } catch (s) {
        throw am(s);
      }
    });
  }
  /**
  * @deprecated
  * This function was hoisted into a publicly accessible function from a
  * different export, but to maintain backwards compatibility with chat models
  * that depend on ChatOpenAICompletions, we'll keep it here as an overridable
  * method. This will be removed in a future release
  */
  _convertCompletionsDeltaToBaseMessageChunk(r, e, t) {
    return n1({
      delta: r,
      rawResponse: e,
      includeRawResponse: this.__includeRawResponse,
      defaultRole: t
    });
  }
  /**
  * @deprecated
  * This function was hoisted into a publicly accessible function from a
  * different export, but to maintain backwards compatibility with chat models
  * that depend on ChatOpenAICompletions, we'll keep it here as an overridable
  * method. This will be removed in a future release
  */
  _convertCompletionsMessageToBaseMessage(r, e) {
    return r1({
      message: r,
      rawResponse: e,
      includeRawResponse: this.__includeRawResponse
    });
  }
};
const Hn = "__openai_function_call_ids__", ry = (r) => {
  var n, s, a, i;
  const e = { ...((n = r == null ? void 0 : r.input_tokens_details) == null ? void 0 : n.cached_tokens) != null && { cache_read: (s = r == null ? void 0 : r.input_tokens_details) == null ? void 0 : s.cached_tokens } }, t = { ...((a = r == null ? void 0 : r.output_tokens_details) == null ? void 0 : a.reasoning_tokens) != null && { reasoning: (i = r == null ? void 0 : r.output_tokens_details) == null ? void 0 : i.reasoning_tokens } };
  return {
    input_tokens: (r == null ? void 0 : r.input_tokens) ?? 0,
    output_tokens: (r == null ? void 0 : r.output_tokens) ?? 0,
    total_tokens: (r == null ? void 0 : r.total_tokens) ?? 0,
    input_token_details: e,
    output_token_details: t
  };
}, ny = (r) => {
  if (r.error) {
    const o = new Error(r.error.message);
    throw o.name = r.error.code, o;
  }
  let e;
  const t = [], n = [], s = [], a = {
    model_provider: "openai",
    model: r.model,
    created_at: r.created_at,
    id: r.id,
    incomplete_details: r.incomplete_details,
    metadata: r.metadata,
    object: r.object,
    status: r.status,
    user: r.user,
    service_tier: r.service_tier,
    model_name: r.model
  }, i = {};
  for (const o of r.output) if (o.type === "message")
    e = o.id, t.push(...o.content.flatMap((c) => c.type === "output_text" ? ("parsed" in c && c.parsed != null && (i.parsed = c.parsed), {
      type: "text",
      text: c.text,
      annotations: c.annotations
    }) : c.type === "refusal" ? (i.refusal = c.refusal, []) : c));
  else if (o.type === "function_call") {
    const c = {
      function: {
        name: o.name,
        arguments: o.arguments
      },
      id: o.call_id
    };
    try {
      n.push(Po(c, { returnId: !0 }));
    } catch (u) {
      let l;
      typeof u == "object" && u != null && "message" in u && typeof u.message == "string" && (l = u.message), s.push(Hi(c, l));
    }
    i[Hn] ?? (i[Hn] = {}), o.id && (i[Hn][o.call_id] = o.id);
  } else if (o.type === "reasoning") i.reasoning = o;
  else if (o.type === "custom_tool_call") {
    const c = qO(o);
    c ? n.push(c) : s.push(Hi(o, "Malformed custom tool call"));
  } else
    i.tool_outputs ?? (i.tool_outputs = []), i.tool_outputs.push(o);
  return new Fe({
    id: e,
    content: t,
    tool_calls: n,
    invalid_tool_calls: s,
    usage_metadata: ry(r.usage),
    additional_kwargs: i,
    response_metadata: a
  });
}, o1 = (r) => {
  const e = (r.summary.length > 1 ? r.summary.reduce((t, n) => {
    const s = t[t.length - 1];
    return s.index === n.index ? s.text += n.text : t.push(n), t;
  }, [{ ...r.summary[0] }]) : r.summary).map((t) => Object.fromEntries(Object.entries(t).filter(([n]) => n !== "index")));
  return {
    ...r,
    summary: e
  };
}, c1 = (r) => {
  var c, u;
  const e = [];
  let t = {}, n;
  const s = [], a = { model_provider: "openai" }, i = {};
  let o;
  if (r.type === "response.output_text.delta") e.push({
    type: "text",
    text: r.delta,
    index: r.content_index
  });
  else if (r.type === "response.output_text.annotation.added") e.push({
    type: "text",
    text: "",
    annotations: [r.annotation],
    index: r.content_index
  });
  else if (r.type === "response.output_item.added" && r.item.type === "message") o = r.item.id;
  else if (r.type === "response.output_item.added" && r.item.type === "function_call")
    s.push({
      type: "tool_call_chunk",
      name: r.item.name,
      args: r.item.arguments,
      id: r.item.call_id,
      index: r.output_index
    }), i[Hn] = { [r.item.call_id]: r.item.id };
  else if (r.type === "response.output_item.done" && [
    "web_search_call",
    "file_search_call",
    "computer_call",
    "code_interpreter_call",
    "mcp_call",
    "mcp_list_tools",
    "mcp_approval_request",
    "image_generation_call",
    "custom_tool_call"
  ].includes(r.item.type)) i.tool_outputs = [r.item];
  else if (r.type === "response.created")
    a.id = r.response.id, a.model_name = r.response.model, a.model = r.response.model;
  else if (r.type === "response.completed") {
    const l = ny(r.response);
    n = ry(r.response.usage), ((u = (c = r.response.text) == null ? void 0 : c.format) == null ? void 0 : u.type) === "json_schema" && (i.parsed ?? (i.parsed = JSON.parse(l.text)));
    for (const [d, h] of Object.entries(r.response)) d !== "id" && (a[d] = h);
  } else if (r.type === "response.function_call_arguments.delta" || r.type === "response.custom_tool_call_input.delta") s.push({
    type: "tool_call_chunk",
    args: r.delta,
    index: r.output_index
  });
  else if (r.type === "response.web_search_call.completed" || r.type === "response.file_search_call.completed") t = { tool_outputs: {
    id: r.item_id,
    type: r.type.replace("response.", "").replace(".completed", ""),
    status: "completed"
  } };
  else if (r.type === "response.refusal.done") i.refusal = r.refusal;
  else if (r.type === "response.output_item.added" && "item" in r && r.item.type === "reasoning") {
    const l = r.item.summary ? r.item.summary.map((d, h) => ({
      ...d,
      index: h
    })) : void 0;
    i.reasoning = {
      id: r.item.id,
      type: r.item.type,
      ...l ? { summary: l } : {}
    };
  } else if (r.type === "response.reasoning_summary_part.added") i.reasoning = {
    type: "reasoning",
    summary: [{
      ...r.part,
      index: r.summary_index
    }]
  };
  else if (r.type === "response.reasoning_summary_text.delta") i.reasoning = {
    type: "reasoning",
    summary: [{
      text: r.delta,
      type: "summary_text",
      index: r.summary_index
    }]
  };
  else return r.type === "response.image_generation_call.partial_image", null;
  return new Qn({
    text: e.map((l) => l.text).join(""),
    message: new Ar({
      id: o,
      content: e,
      tool_call_chunks: s,
      usage_metadata: n,
      additional_kwargs: i,
      response_metadata: a
    }),
    generationInfo: t
  });
}, u1 = (r) => {
  var n;
  const e = Fe.isInstance(r) && ((n = r.response_metadata) == null ? void 0 : n.model_provider) === "openai";
  function* t() {
    const s = bn(() => {
      try {
        const _ = ga(r);
        return _ === "system" || _ === "developer" || _ === "assistant" || _ === "user" ? _ : "assistant";
      } catch {
        return "assistant";
      }
    });
    let a;
    const i = /* @__PURE__ */ new Set(), o = /* @__PURE__ */ new Set(), c = /* @__PURE__ */ new Map(), u = /* @__PURE__ */ new Map();
    function* l() {
      if (!a) return;
      const _ = a.content;
      (typeof _ == "string" && _.length > 0 || Array.isArray(_) && _.length > 0) && (yield a), a = void 0;
    }
    const d = (_) => {
      a || (a = {
        type: "message",
        role: s,
        content: []
      }), typeof a.content == "string" ? a.content = a.content.length > 0 ? [{
        type: "input_text",
        text: a.content
      }, ..._] : [..._] : a.content.push(..._);
    }, h = (_) => {
      if (typeof _ == "string") return _;
      try {
        return JSON.stringify(_ ?? {});
      } catch {
        return "{}";
      }
    }, f = (_) => {
      const w = bn(() => {
        var x;
        const T = (x = _.metadata) == null ? void 0 : x.detail;
        return T === "low" || T === "high" || T === "auto" ? T : "auto";
      });
      if (_.fileId) return {
        type: "input_image",
        detail: w,
        file_id: _.fileId
      };
      if (_.url) return {
        type: "input_image",
        detail: w,
        image_url: _.url
      };
      if (_.data) {
        const T = typeof _.data == "string" ? _.data : Buffer.from(_.data).toString("base64"), x = _.mimeType ?? "image/png";
        return {
          type: "input_image",
          detail: w,
          image_url: `data:${x};base64,${T}`
        };
      }
    }, p = (_) => {
      var T, x, A;
      const w = ((T = _.metadata) == null ? void 0 : T.filename) ?? ((x = _.metadata) == null ? void 0 : x.name) ?? ((A = _.metadata) == null ? void 0 : A.title);
      if (_.fileId && typeof w == "string") return {
        type: "input_file",
        file_id: _.fileId,
        ...w ? { filename: w } : {}
      };
      if (_.url && typeof w == "string") return {
        type: "input_file",
        file_url: _.url,
        ...w ? { filename: w } : {}
      };
      if (_.data && typeof w == "string") {
        const R = typeof _.data == "string" ? _.data : Buffer.from(_.data).toString("base64");
        return {
          type: "input_file",
          file_data: `data:${_.mimeType ?? "application/octet-stream"};base64,${R}`,
          ...w ? { filename: w } : {}
        };
      }
    }, y = (_) => {
      const w = bn(() => {
        if (Array.isArray(_.summary)) {
          const A = _.summary, R = (A == null ? void 0 : A.map((E) => E == null ? void 0 : E.text).filter((E) => typeof E == "string")) ?? [];
          if (R.length > 0) return R;
        }
        return _.reasoning ? [_.reasoning] : [];
      }), T = w.length > 0 ? w.map((A) => ({
        type: "summary_text",
        text: A
      })) : [{
        type: "summary_text",
        text: ""
      }], x = {
        type: "reasoning",
        id: _.id ?? "",
        summary: T
      };
      return _.reasoning && (x.content = [{
        type: "reasoning_text",
        text: _.reasoning
      }]), x;
    }, g = (_) => ({
      type: "function_call",
      name: _.name ?? "",
      call_id: _.id ?? "",
      arguments: h(_.args)
    }), S = (_) => {
      const w = h(_.output), T = _.status === "success" ? "completed" : _.status === "error" ? "incomplete" : void 0;
      return {
        type: "function_call_output",
        call_id: _.toolCallId ?? "",
        output: w,
        ...T ? { status: T } : {}
      };
    };
    for (const _ of r.contentBlocks) if (_.type === "text") d([{
      type: "input_text",
      text: _.text
    }]);
    else if (_.type !== "invalid_tool_call") {
      if (_.type === "reasoning")
        yield* l(), yield y(_);
      else if (_.type === "tool_call") {
        yield* l();
        const w = _.id ?? "";
        w && (i.add(w), c.delete(w)), yield g(_);
      } else if (_.type === "tool_call_chunk") {
        if (_.id) {
          const w = c.get(_.id) ?? {
            name: _.name,
            args: []
          };
          _.name && (w.name = _.name), _.args && w.args.push(_.args), c.set(_.id, w);
        }
      } else if (_.type === "server_tool_call") {
        yield* l();
        const w = _.id ?? "";
        w && (o.add(w), u.delete(w)), yield g(_);
      } else if (_.type === "server_tool_call_chunk") {
        if (_.id) {
          const w = u.get(_.id) ?? {
            name: _.name,
            args: []
          };
          _.name && (w.name = _.name), _.args && w.args.push(_.args), u.set(_.id, w);
        }
      } else if (_.type === "server_tool_call_result")
        yield* l(), yield S(_);
      else if (_.type !== "audio") if (_.type === "file") {
        const w = p(_);
        w && d([w]);
      } else if (_.type === "image") {
        const w = f(_);
        w && d([w]);
      } else if (_.type === "video") {
        const w = p(_);
        w && d([w]);
      } else _.type === "text-plain" ? _.text && d([{
        type: "input_text",
        text: _.text
      }]) : _.type === "non_standard" && e && (yield* l(), yield _.value);
    }
    yield* l();
    for (const [_, w] of c) {
      if (!_ || i.has(_)) continue;
      const T = w.args.join("");
      !w.name && !T || (yield {
        type: "function_call",
        call_id: _,
        name: w.name ?? "",
        arguments: T
      });
    }
    for (const [_, w] of u) {
      if (!_ || o.has(_)) continue;
      const T = w.args.join("");
      !w.name && !T || (yield {
        type: "function_call",
        call_id: _,
        name: w.name ?? "",
        arguments: T
      });
    }
  }
  return Array.from(t());
}, yf = ({ messages: r, zdrEnabled: e, model: t }) => r.flatMap((n) => {
  var o, c, u, l;
  const s = n.response_metadata;
  if ((s == null ? void 0 : s.output_version) === "v1") return u1(n);
  const a = n.additional_kwargs;
  let i = ga(n);
  if (i === "system" && ma(t) && (i = "developer"), i === "function") throw new Error("Function messages are not supported in Responses API");
  if (i === "tool") {
    const d = n;
    return (a == null ? void 0 : a.type) === "computer_call_output" ? {
      type: "computer_call_output",
      output: (() => {
        if (typeof d.content == "string") return {
          type: "computer_screenshot",
          image_url: d.content
        };
        if (Array.isArray(d.content)) {
          const f = d.content.find((y) => y.type === "computer_screenshot");
          if (f) return f;
          const p = d.content.find((y) => y.type === "image_url");
          if (p) return {
            type: "computer_screenshot",
            image_url: typeof p.image_url == "string" ? p.image_url : p.image_url.url
          };
        }
        throw new Error("Invalid computer call output");
      })(),
      call_id: d.tool_call_id
    } : (o = d.additional_kwargs) != null && o.customTool ? {
      type: "custom_tool_call_output",
      call_id: d.tool_call_id,
      output: d.content
    } : {
      type: "function_call_output",
      call_id: d.tool_call_id,
      id: (c = d.id) != null && c.startsWith("fc_") ? d.id : void 0,
      output: typeof d.content != "string" ? JSON.stringify(d.content) : d.content
    };
  }
  if (i === "assistant") {
    if (!e && (s == null ? void 0 : s.output) != null && Array.isArray(s == null ? void 0 : s.output) && (s == null ? void 0 : s.output.length) > 0 && (s != null && s.output.every((g) => "type" in g))) return s == null ? void 0 : s.output;
    const d = [];
    if (a != null && a.reasoning && !e) {
      const g = o1(a.reasoning);
      d.push(g);
    }
    let { content: h } = n;
    a != null && a.refusal && (typeof h == "string" && (h = [{
      type: "output_text",
      text: h,
      annotations: []
    }]), h = [...h, {
      type: "refusal",
      refusal: a.refusal
    }]), (typeof h == "string" || h.length > 0) && d.push({
      type: "message",
      role: "assistant",
      ...n.id && !e && n.id.startsWith("msg_") ? { id: n.id } : {},
      content: bn(() => typeof h == "string" ? h : h.flatMap((g) => g.type === "text" ? {
        type: "output_text",
        text: g.text,
        annotations: g.annotations ?? []
      } : g.type === "output_text" || g.type === "refusal" ? g : []))
    });
    const f = a == null ? void 0 : a[Hn];
    Fe.isInstance(n) && ((u = n.tool_calls) != null && u.length) ? d.push(...n.tool_calls.map((g) => HO(g) ? {
      type: "custom_tool_call",
      id: g.call_id,
      call_id: g.id ?? "",
      input: g.args.input,
      name: g.name
    } : {
      type: "function_call",
      name: g.name,
      arguments: JSON.stringify(g.args),
      call_id: g.id,
      ...e ? {} : { id: f == null ? void 0 : f[g.id] }
    })) : a != null && a.tool_calls && d.push(...a.tool_calls.map((g) => ({
      type: "function_call",
      name: g.function.name,
      call_id: g.id,
      arguments: g.function.arguments,
      ...e ? {} : { id: f == null ? void 0 : f[g.id] }
    })));
    const p = (l = s == null ? void 0 : s.output) != null && l.length ? s == null ? void 0 : s.output : a.tool_outputs, y = [
      "computer_call",
      "mcp_call",
      "code_interpreter_call",
      "image_generation_call"
    ];
    if (p != null) {
      const g = p, S = g == null ? void 0 : g.filter((_) => y.includes(_.type));
      S.length > 0 && d.push(...S);
    }
    return d;
  }
  if (i === "user" || i === "system" || i === "developer") {
    if (typeof n.content == "string") return {
      type: "message",
      role: i,
      content: n.content
    };
    const d = [], h = n.content.flatMap((f) => {
      if (f.type === "mcp_approval_response" && d.push({
        type: "mcp_approval_response",
        approval_request_id: f.approval_request_id,
        approve: f.approve
      }), Ir(f)) return Gu(f, ty);
      if (f.type === "text") return {
        type: "input_text",
        text: f.text
      };
      if (f.type === "image_url") {
        const p = bn(() => {
          if (typeof f.image_url == "string") return f.image_url;
          if (typeof f.image_url == "object" && f.image_url !== null && "url" in f.image_url) return f.image_url.url;
        }), y = bn(() => {
          if (typeof f.image_url == "string") return "auto";
          if (typeof f.image_url == "object" && f.image_url !== null && "detail" in f.image_url) return f.image_url.detail;
        });
        return {
          type: "input_image",
          image_url: p,
          detail: y
        };
      }
      return f.type === "input_text" || f.type === "input_image" || f.type === "input_file" ? f : [];
    });
    return h.length > 0 && d.push({
      type: "message",
      role: i,
      content: h
    }), d;
  }
  return console.warn(`Unsupported role found when converting to OpenAI Responses API: ${i}`), [];
});
var l1 = class extends Vl {
  invocationParams(r) {
    var s;
    let e;
    (r == null ? void 0 : r.strict) !== void 0 ? e = r.strict : this.supportsStrictToolCalling !== void 0 && (e = this.supportsStrictToolCalling);
    const t = {
      model: this.model,
      temperature: this.temperature,
      top_p: this.topP,
      user: this.user,
      stream: this.streaming,
      previous_response_id: r == null ? void 0 : r.previous_response_id,
      truncation: r == null ? void 0 : r.truncation,
      include: r == null ? void 0 : r.include,
      tools: (s = r == null ? void 0 : r.tools) != null && s.length ? this._reduceChatOpenAITools(r.tools, {
        stream: this.streaming,
        strict: e
      }) : void 0,
      tool_choice: VO(r == null ? void 0 : r.tool_choice) ? r == null ? void 0 : r.tool_choice : (() => {
        const a = A_(r == null ? void 0 : r.tool_choice);
        if (typeof a == "object" && "type" in a) {
          if (a.type === "function") return {
            type: "function",
            name: a.function.name
          };
          if (a.type === "allowed_tools") return {
            type: "allowed_tools",
            mode: a.allowed_tools.mode,
            tools: a.allowed_tools.tools
          };
          if (a.type === "custom") return {
            type: "custom",
            name: a.custom.name
          };
        }
      })(),
      text: (() => {
        if (r != null && r.text) return r.text;
        const a = this._getResponseFormat(r == null ? void 0 : r.response_format);
        return (a == null ? void 0 : a.type) === "json_schema" ? a.json_schema.schema != null ? {
          format: {
            type: "json_schema",
            schema: a.json_schema.schema,
            description: a.json_schema.description,
            name: a.json_schema.name,
            strict: a.json_schema.strict
          },
          verbosity: r == null ? void 0 : r.verbosity
        } : void 0 : {
          format: a,
          verbosity: r == null ? void 0 : r.verbosity
        };
      })(),
      parallel_tool_calls: r == null ? void 0 : r.parallel_tool_calls,
      max_output_tokens: this.maxTokens === -1 ? void 0 : this.maxTokens,
      prompt_cache_key: (r == null ? void 0 : r.promptCacheKey) ?? this.promptCacheKey,
      ...this.zdrEnabled ? { store: !1 } : {},
      ...this.modelKwargs
    }, n = this._getReasoningParams(r);
    return n !== void 0 && (t.reasoning = n), t;
  }
  async _generate(r, e) {
    var n;
    const t = this.invocationParams(e);
    if (t.stream) {
      const s = this._streamResponseChunks(r, e);
      let a;
      for await (const i of s)
        i.message.response_metadata = {
          ...i.generationInfo,
          ...i.message.response_metadata
        }, a = (a == null ? void 0 : a.concat(i)) ?? i;
      return {
        generations: a ? [a] : [],
        llmOutput: { estimatedTokenUsage: (n = a == null ? void 0 : a.message) == null ? void 0 : n.usage_metadata }
      };
    } else {
      const s = await this.completionWithRetry({
        input: yf({
          messages: r,
          zdrEnabled: this.zdrEnabled ?? !1,
          model: this.model
        }),
        ...t,
        stream: !1
      }, {
        signal: e == null ? void 0 : e.signal,
        ...e == null ? void 0 : e.options
      });
      return {
        generations: [{
          text: s.output_text,
          message: ny(s)
        }],
        llmOutput: {
          id: s.id,
          estimatedTokenUsage: s.usage ? {
            promptTokens: s.usage.input_tokens,
            completionTokens: s.usage.output_tokens,
            totalTokens: s.usage.total_tokens
          } : void 0
        }
      };
    }
  }
  async *_streamResponseChunks(r, e, t) {
    const n = await this.completionWithRetry({
      ...this.invocationParams(e),
      input: yf({
        messages: r,
        zdrEnabled: this.zdrEnabled ?? !1,
        model: this.model
      }),
      stream: !0
    }, e);
    for await (const s of n) {
      const a = c1(s);
      a != null && (yield a, await (t == null ? void 0 : t.handleLLMNewToken(a.text || "", {
        prompt: e.promptIndex ?? 0,
        completion: 0
      }, void 0, void 0, void 0, { chunk: a })));
    }
  }
  async completionWithRetry(r, e) {
    return this.caller.call(async () => {
      var n, s;
      const t = this._getClientOptions(e);
      try {
        return ((s = (n = r.text) == null ? void 0 : n.format) == null ? void 0 : s.type) === "json_schema" && !r.stream ? await this.client.responses.parse(r, t) : await this.client.responses.create(r, t);
      } catch (a) {
        throw am(a);
      }
    });
  }
  /** @internal */
  _reduceChatOpenAITools(r, e) {
    const t = [];
    for (const n of r) if (jl(n))
      n.type === "image_generation" && (e != null && e.stream) && (n.partial_images = 1), t.push(n);
    else if (zi(n)) {
      const s = n.metadata.customTool;
      t.push({
        type: "custom",
        name: s.name,
        description: s.description,
        format: s.format
      });
    } else Ul(n) ? t.push({
      type: "function",
      name: n.function.name,
      parameters: n.function.parameters,
      description: n.function.description,
      strict: (e == null ? void 0 : e.strict) ?? null
    }) : $_(n) && t.push(JO(n));
    return t;
  }
}, d1 = class sy extends Vl {
  constructor(t) {
    super(t);
    /**
    * Whether to use the responses API for all requests. If `false` the responses API will be used
    * only when required in order to fulfill the request.
    */
    v(this, "useResponsesApi", !1);
    v(this, "responses");
    v(this, "completions");
    this.fields = t, this.useResponsesApi = (t == null ? void 0 : t.useResponsesApi) ?? !1, this.responses = (t == null ? void 0 : t.responses) ?? new l1(t), this.completions = (t == null ? void 0 : t.completions) ?? new i1(t);
  }
  get lc_serializable_keys() {
    return [...super.lc_serializable_keys, "useResponsesApi"];
  }
  get callKeys() {
    return [...super.callKeys, "useResponsesApi"];
  }
  _useResponsesApi(t) {
    var i, o, c, u, l;
    const n = (i = t == null ? void 0 : t.tools) == null ? void 0 : i.some(jl), s = (t == null ? void 0 : t.previous_response_id) != null || (t == null ? void 0 : t.text) != null || (t == null ? void 0 : t.truncation) != null || (t == null ? void 0 : t.include) != null || ((o = t == null ? void 0 : t.reasoning) == null ? void 0 : o.summary) != null || ((c = this.reasoning) == null ? void 0 : c.summary) != null, a = ((u = t == null ? void 0 : t.tools) == null ? void 0 : u.some($_)) || ((l = t == null ? void 0 : t.tools) == null ? void 0 : l.some(zi));
    return this.useResponsesApi || n || s || a;
  }
  getLsParams(t) {
    const n = this._combineCallOptions(t);
    return this._useResponsesApi(t) ? this.responses.getLsParams(n) : this.completions.getLsParams(n);
  }
  invocationParams(t) {
    const n = this._combineCallOptions(t);
    return this._useResponsesApi(t) ? this.responses.invocationParams(n) : this.completions.invocationParams(n);
  }
  /** @ignore */
  async _generate(t, n, s) {
    return this._useResponsesApi(n) ? this.responses._generate(t, n) : this.completions._generate(t, n, s);
  }
  async *_streamResponseChunks(t, n, s) {
    if (this._useResponsesApi(n)) {
      yield* this.responses._streamResponseChunks(t, this._combineCallOptions(n), s);
      return;
    }
    yield* this.completions._streamResponseChunks(t, this._combineCallOptions(n), s);
  }
  withConfig(t) {
    const n = new sy(this.fields);
    return n.defaultOptions = {
      ...this.defaultOptions,
      ...t
    }, n;
  }
}, h1 = {};
Ae(h1, {
  BaseLLM: () => ay,
  LLM: () => f1
});
var ay = class $s extends Bl {
  constructor() {
    super(...arguments);
    v(this, "lc_namespace", [
      "langchain",
      "llms",
      this._llmType()
    ]);
  }
  /**
  * This method takes an input and options, and returns a string. It
  * converts the input to a prompt value and generates a result based on
  * the prompt.
  * @param input Input for the LLM.
  * @param options Options for the LLM call.
  * @returns A string result based on the prompt.
  */
  async invoke(t, n) {
    const s = $s._convertInputToPromptValue(t);
    return (await this.generatePrompt([s], n, n == null ? void 0 : n.callbacks)).generations[0][0].text;
  }
  async *_streamResponseChunks(t, n, s) {
    throw new Error("Not implemented.");
  }
  _separateRunnableConfigFromCallOptionsCompat(t) {
    const [n, s] = super._separateRunnableConfigFromCallOptions(t);
    return s.signal = n.signal, [n, s];
  }
  async *_streamIterator(t, n) {
    if (this._streamResponseChunks === $s.prototype._streamResponseChunks) yield this.invoke(t, n);
    else {
      const s = $s._convertInputToPromptValue(t), [a, i] = this._separateRunnableConfigFromCallOptionsCompat(n), o = await Pt.configure(a.callbacks, this.callbacks, a.tags, this.tags, a.metadata, this.metadata, { verbose: this.verbose }), c = {
        options: i,
        invocation_params: this == null ? void 0 : this.invocationParams(i),
        batch_size: 1
      }, u = await (o == null ? void 0 : o.handleLLMStart(this.toJSON(), [s.toString()], a.runId, void 0, c, void 0, void 0, a.runName));
      let l = new Xn({ text: "" });
      try {
        for await (const d of this._streamResponseChunks(s.toString(), i, u == null ? void 0 : u[0]))
          l ? l = l.concat(d) : l = d, typeof d.text == "string" && (yield d.text);
      } catch (d) {
        throw await Promise.all((u ?? []).map((h) => h == null ? void 0 : h.handleLLMError(d))), d;
      }
      await Promise.all((u ?? []).map((d) => d == null ? void 0 : d.handleLLMEnd({ generations: [[l]] })));
    }
  }
  /**
  * This method takes prompt values, options, and callbacks, and generates
  * a result based on the prompts.
  * @param promptValues Prompt values for the LLM.
  * @param options Options for the LLM call.
  * @param callbacks Callbacks for the LLM call.
  * @returns An LLMResult based on the prompts.
  */
  async generatePrompt(t, n, s) {
    const a = t.map((i) => i.toString());
    return this.generate(a, n, s);
  }
  /**
  * Get the parameters used to invoke the model
  */
  invocationParams(t) {
    return {};
  }
  _flattenLLMResult(t) {
    const n = [];
    for (let s = 0; s < t.generations.length; s += 1) {
      const a = t.generations[s];
      if (s === 0) n.push({
        generations: [a],
        llmOutput: t.llmOutput
      });
      else {
        const i = t.llmOutput ? {
          ...t.llmOutput,
          tokenUsage: {}
        } : void 0;
        n.push({
          generations: [a],
          llmOutput: i
        });
      }
    }
    return n;
  }
  /** @ignore */
  async _generateUncached(t, n, s, a) {
    let i;
    if (a !== void 0 && a.length === t.length) i = a;
    else {
      const l = await Pt.configure(s.callbacks, this.callbacks, s.tags, this.tags, s.metadata, this.metadata, { verbose: this.verbose }), d = {
        options: n,
        invocation_params: this == null ? void 0 : this.invocationParams(n),
        batch_size: t.length
      };
      i = await (l == null ? void 0 : l.handleLLMStart(this.toJSON(), t, s.runId, void 0, d, void 0, void 0, s == null ? void 0 : s.runName));
    }
    const o = !!(i != null && i[0].handlers.find(ol));
    let c;
    if (o && t.length === 1 && this._streamResponseChunks !== $s.prototype._streamResponseChunks) try {
      const l = await this._streamResponseChunks(t[0], n, i == null ? void 0 : i[0]);
      let d;
      for await (const h of l) d === void 0 ? d = h : d = sn(d, h);
      if (d === void 0) throw new Error("Received empty response from chat model call.");
      c = {
        generations: [[d]],
        llmOutput: {}
      }, await (i == null ? void 0 : i[0].handleLLMEnd(c));
    } catch (l) {
      throw await (i == null ? void 0 : i[0].handleLLMError(l)), l;
    }
    else {
      try {
        c = await this._generate(t, n, i == null ? void 0 : i[0]);
      } catch (d) {
        throw await Promise.all((i ?? []).map((h) => h == null ? void 0 : h.handleLLMError(d))), d;
      }
      const l = this._flattenLLMResult(c);
      await Promise.all((i ?? []).map((d, h) => d == null ? void 0 : d.handleLLMEnd(l[h])));
    }
    const u = (i == null ? void 0 : i.map((l) => l.runId)) || void 0;
    return Object.defineProperty(c, Ys, {
      value: u ? { runIds: u } : void 0,
      configurable: !0
    }), c;
  }
  async _generateCached({ prompts: t, cache: n, llmStringKey: s, parsedOptions: a, handledOptions: i, runId: o }) {
    const c = await Pt.configure(i.callbacks, this.callbacks, i.tags, this.tags, i.metadata, this.metadata, { verbose: this.verbose }), u = {
      options: a,
      invocation_params: this == null ? void 0 : this.invocationParams(a),
      batch_size: t.length
    }, l = await (c == null ? void 0 : c.handleLLMStart(this.toJSON(), t, o, void 0, u, void 0, void 0, i == null ? void 0 : i.runName)), d = [], f = (await Promise.allSettled(t.map(async (g, S) => {
      const _ = await n.lookup(g, s);
      return _ == null && d.push(S), _;
    }))).map((g, S) => ({
      result: g,
      runManager: l == null ? void 0 : l[S]
    })).filter(({ result: g }) => g.status === "fulfilled" && g.value != null || g.status === "rejected"), p = [];
    await Promise.all(f.map(async ({ result: g, runManager: S }, _) => {
      if (g.status === "fulfilled") {
        const w = g.value;
        return p[_] = w.map((T) => (T.generationInfo = {
          ...T.generationInfo,
          tokenUsage: {}
        }, T)), w.length && await (S == null ? void 0 : S.handleLLMNewToken(w[0].text)), S == null ? void 0 : S.handleLLMEnd({ generations: [w] }, void 0, void 0, void 0, { cached: !0 });
      } else
        return await (S == null ? void 0 : S.handleLLMError(g.reason, void 0, void 0, void 0, { cached: !0 })), Promise.reject(g.reason);
    }));
    const y = {
      generations: p,
      missingPromptIndices: d,
      startedRunManagers: l
    };
    return Object.defineProperty(y, Ys, {
      value: l ? { runIds: l == null ? void 0 : l.map((g) => g.runId) } : void 0,
      configurable: !0
    }), y;
  }
  /**
  * Run the LLM on the given prompts and input, handling caching.
  */
  async generate(t, n, s) {
    if (!Array.isArray(t)) throw new Error("Argument 'prompts' is expected to be a string[]");
    let a;
    Array.isArray(n) ? a = { stop: n } : a = n;
    const [i, o] = this._separateRunnableConfigFromCallOptionsCompat(a);
    if (i.callbacks = i.callbacks ?? s, !this.cache) return this._generateUncached(t, o, i);
    const { cache: c } = this, u = this._getSerializedCacheKeyParametersForCall(o), { generations: l, missingPromptIndices: d, startedRunManagers: h } = await this._generateCached({
      prompts: t,
      cache: c,
      llmStringKey: u,
      parsedOptions: o,
      handledOptions: i,
      runId: i.runId
    });
    let f = {};
    if (d.length > 0) {
      const p = await this._generateUncached(d.map((y) => t[y]), o, i, h !== void 0 ? d.map((y) => h == null ? void 0 : h[y]) : void 0);
      await Promise.all(p.generations.map(async (y, g) => {
        const S = d[g];
        return l[S] = y, c.update(t[S], u, y);
      })), f = p.llmOutput ?? {};
    }
    return {
      generations: l,
      llmOutput: f
    };
  }
  /**
  * Get the identifying parameters of the LLM.
  */
  _identifyingParams() {
    return {};
  }
  _modelType() {
    return "base_llm";
  }
}, f1 = class extends ay {
  async _generate(r, e, t) {
    return { generations: await Promise.all(r.map((s, a) => this._call(s, {
      ...e,
      promptIndex: a
    }, t).then((i) => [{ text: i }]))) };
  }
}, p1 = {};
Ae(p1, { chunkArray: () => m1 });
const m1 = (r, e) => r.reduce((t, n, s) => {
  const a = Math.floor(s / e), i = t[a] || [];
  return t[a] = i.concat([n]), t;
}, []);
var g1 = {};
Ae(g1, { Embeddings: () => _1 });
var _1 = class {
  constructor(r) {
    /**
    * The async caller should be used by subclasses to make any async calls,
    * which will thus benefit from the concurrency and retry logic.
    */
    v(this, "caller");
    this.caller = new fa(r ?? {});
  }
}, y1 = {};
Ae(y1, {
  BaseToolkit: () => w1,
  DynamicStructuredTool: () => cy,
  DynamicTool: () => oy,
  StructuredTool: () => Lo,
  Tool: () => iy,
  ToolInputParsingException: () => bi,
  isLangChainTool: () => Oo,
  isRunnableToolLike: () => Ml,
  isStructuredTool: () => Ll,
  isStructuredToolParams: () => Dl,
  tool: () => v1
});
var Lo = class extends zl {
  constructor(e) {
    super(e ?? {});
    /**
    * Optional provider-specific extra fields for the tool.
    *
    * This is used to pass provider-specific configuration that doesn't fit into
    * standard tool fields.
    */
    v(this, "extras");
    /**
    * Whether to return the tool's output directly.
    *
    * Setting this to true means that after the tool is called,
    * an agent should stop looping.
    */
    v(this, "returnDirect", !1);
    v(this, "verboseParsingErrors", !1);
    /**
    * The tool response format.
    *
    * If "content" then the output of the tool is interpreted as the contents of a
    * ToolMessage. If "content_and_artifact" then the output is expected to be a
    * two-tuple corresponding to the (content, artifact) of a ToolMessage.
    *
    * @default "content"
    */
    v(this, "responseFormat", "content");
    /**
    * Default config object for the tool runnable.
    */
    v(this, "defaultConfig");
    this.verboseParsingErrors = (e == null ? void 0 : e.verboseParsingErrors) ?? this.verboseParsingErrors, this.responseFormat = (e == null ? void 0 : e.responseFormat) ?? this.responseFormat, this.defaultConfig = (e == null ? void 0 : e.defaultConfig) ?? this.defaultConfig, this.metadata = (e == null ? void 0 : e.metadata) ?? this.metadata, this.extras = (e == null ? void 0 : e.extras) ?? this.extras;
  }
  get lc_namespace() {
    return ["langchain", "tools"];
  }
  /**
  * Invokes the tool with the provided input and configuration.
  * @param input The input for the tool.
  * @param config Optional configuration for the tool.
  * @returns A Promise that resolves with the tool's output.
  */
  async invoke(e, t) {
    let n, s = Ce(xi(this.defaultConfig, t));
    return Ms(e) ? (n = e.args, s = {
      ...s,
      toolCall: e
    }) : n = e, this.call(n, s);
  }
  /**
  * @deprecated Use .invoke() instead. Will be removed in 0.3.0.
  *
  * Calls the tool with the provided argument, configuration, and tags. It
  * parses the input according to the schema, handles any errors, and
  * manages callbacks.
  * @param arg The input argument for the tool.
  * @param configArg Optional configuration or callbacks for the tool.
  * @param tags Optional tags for the tool.
  * @returns A Promise that resolves with a string.
  */
  async call(e, t, n) {
    const s = Ms(e) ? e.args : e;
    let a;
    if (br(this.schema)) try {
      a = await To(this.schema, s);
    } catch (p) {
      let y = "Received tool input did not match expected schema";
      throw this.verboseParsingErrors && (y = `${y}
Details: ${p.message}`), s_(p) && (y = `${y}

${LT(p)}`), new bi(y, JSON.stringify(e));
    }
    else {
      const p = Ze(s, this.schema);
      if (!p.valid) {
        let y = "Received tool input did not match expected schema";
        throw this.verboseParsingErrors && (y = `${y}
Details: ${p.errors.map((g) => `${g.keywordLocation}: ${g.error}`).join(`
`)}`), new bi(y, JSON.stringify(e));
      }
      a = s;
    }
    const i = po(t), o = Pt.configure(i.callbacks, this.callbacks, i.tags || n, this.tags, i.metadata, this.metadata, { verbose: this.verbose }), c = await (o == null ? void 0 : o.handleToolStart(this.toJSON(), typeof e == "string" ? e : JSON.stringify(e), i.runId, void 0, void 0, void 0, i.runName));
    delete i.runId;
    let u;
    try {
      u = await this._call(a, c, i);
    } catch (p) {
      throw await (c == null ? void 0 : c.handleToolError(p)), p;
    }
    let l, d;
    if (this.responseFormat === "content_and_artifact") if (Array.isArray(u) && u.length === 2) [l, d] = u;
    else throw new Error(`Tool response format is "content_and_artifact" but the output was not a two-tuple.
Result: ${JSON.stringify(u)}`);
    else l = u;
    let h;
    Ms(e) && (h = e.id), !h && Tv(i) && (h = i.toolCall.id);
    const f = b1({
      content: l,
      artifact: d,
      toolCallId: h,
      name: this.name,
      metadata: this.metadata
    });
    return await (c == null ? void 0 : c.handleToolEnd(f)), f;
  }
}, iy = class extends Lo {
  constructor(e) {
    super(e);
    v(this, "schema", ko({ input: Io().optional() }).transform((e) => e.input));
  }
  /**
  * @deprecated Use .invoke() instead. Will be removed in 0.3.0.
  *
  * Calls the tool with the provided argument and callbacks. It handles
  * string inputs specifically.
  * @param arg The input argument for the tool, which can be a string, undefined, or an input of the tool's schema.
  * @param callbacks Optional callbacks for the tool.
  * @returns A Promise that resolves with a string.
  */
  call(e, t) {
    const n = typeof e == "string" || e == null ? { input: e } : e;
    return super.call(n, t);
  }
}, oy = class extends iy {
  constructor(e) {
    super(e);
    v(this, "name");
    v(this, "description");
    v(this, "func");
    this.name = e.name, this.description = e.description, this.func = e.func, this.returnDirect = e.returnDirect ?? this.returnDirect;
  }
  static lc_name() {
    return "DynamicTool";
  }
  /**
  * @deprecated Use .invoke() instead. Will be removed in 0.3.0.
  */
  async call(e, t) {
    const n = po(t);
    return n.runName === void 0 && (n.runName = this.name), super.call(e, n);
  }
  /** @ignore */
  async _call(e, t, n) {
    return this.func(e, t, n);
  }
}, cy = class extends Lo {
  constructor(e) {
    super(e);
    v(this, "name");
    v(this, "description");
    v(this, "func");
    v(this, "schema");
    this.name = e.name, this.description = e.description, this.func = e.func, this.returnDirect = e.returnDirect ?? this.returnDirect, this.schema = e.schema;
  }
  static lc_name() {
    return "DynamicStructuredTool";
  }
  /**
  * @deprecated Use .invoke() instead. Will be removed in 0.3.0.
  */
  async call(e, t, n) {
    const s = po(t);
    return s.runName === void 0 && (s.runName = this.name), super.call(e, s, n);
  }
  _call(e, t, n) {
    return this.func(e, t, n);
  }
}, w1 = class {
  getTools() {
    return this.tools;
  }
};
function v1(r, e) {
  var i;
  const t = kl(e.schema), n = Fs(e.schema);
  if (!e.schema || t || n) return new oy({
    ...e,
    description: e.description ?? ((i = e.schema) == null ? void 0 : i.description) ?? `${e.name} tool`,
    func: async (o, c, u) => new Promise((l, d) => {
      const h = Be(u, { callbacks: c == null ? void 0 : c.getChild() });
      lr.runWithConfig(Ur(h), async () => {
        try {
          l(r(o, h));
        } catch (f) {
          d(f);
        }
      });
    })
  });
  const s = e.schema, a = e.description ?? e.schema.description ?? `${e.name} tool`;
  return new cy({
    ...e,
    description: a,
    schema: s,
    func: async (o, c, u) => new Promise((l, d) => {
      let h;
      const f = () => {
        u != null && u.signal && h && u.signal.removeEventListener("abort", h);
      };
      u != null && u.signal && (h = () => {
        f(), d(Gs(u.signal));
      }, u.signal.addEventListener("abort", h));
      const p = Be(u, { callbacks: c == null ? void 0 : c.getChild() });
      lr.runWithConfig(Ur(p), async () => {
        var y;
        try {
          const g = await r(o, p);
          if ((y = u == null ? void 0 : u.signal) != null && y.aborted) {
            f();
            return;
          }
          f(), l(g);
        } catch (g) {
          f(), d(g);
        }
      });
    })
  });
}
function b1(r) {
  const { content: e, artifact: t, toolCallId: n, metadata: s } = r;
  return n && !tl(e) ? typeof e == "string" || Array.isArray(e) && e.every((a) => typeof a == "object") ? new kr({
    status: "success",
    content: e,
    artifact: t,
    tool_call_id: n,
    name: r.name,
    metadata: s
  }) : new kr({
    status: "success",
    content: S1(e),
    artifact: t,
    tool_call_id: n,
    name: r.name,
    metadata: s
  }) : e;
}
function S1(r) {
  try {
    return JSON.stringify(r, null, 2) ?? "";
  } catch {
    return `${r}`;
  }
}
var Hr = { exports: {} };
const T1 = "17.2.3", E1 = {
  version: T1
}, vu = by, Ji = If, x1 = Sy, I1 = ps, k1 = E1, ql = k1.version, wf = [
  "ðŸ” encrypt with Dotenvx: https://dotenvx.com",
  "ðŸ” prevent committing .env to code: https://dotenvx.com/precommit",
  "ðŸ” prevent building .env in docker: https://dotenvx.com/prebuild",
  "ðŸ“¡ add observability to secrets: https://dotenvx.com/ops",
  "ðŸ‘¥ sync secrets across teammates & machines: https://dotenvx.com/ops",
  "ðŸ—‚ï¸ backup and recover secrets: https://dotenvx.com/ops",
  "âœ… audit secrets and track compliance: https://dotenvx.com/ops",
  "ðŸ”„ add secrets lifecycle management: https://dotenvx.com/ops",
  "ðŸ”‘ add access controls to secrets: https://dotenvx.com/ops",
  "ðŸ› ï¸  run anywhere with `dotenvx run -- yourcommand`",
  "âš™ï¸  specify custom .env file path with { path: '/custom/path/.env' }",
  "âš™ï¸  enable debug logging with { debug: true }",
  "âš™ï¸  override existing env vars with { override: true }",
  "âš™ï¸  suppress all logs with { quiet: true }",
  "âš™ï¸  write to custom object with { processEnv: myObject }",
  "âš™ï¸  load multiple .env files with { path: ['.env.local', '.env'] }"
];
function O1() {
  return wf[Math.floor(Math.random() * wf.length)];
}
function Jn(r) {
  return typeof r == "string" ? !["false", "0", "no", "off", ""].includes(r.toLowerCase()) : !!r;
}
function A1() {
  return process.stdout.isTTY;
}
function $1(r) {
  return A1() ? `\x1B[2m${r}\x1B[0m` : r;
}
const C1 = /(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/mg;
function R1(r) {
  const e = {};
  let t = r.toString();
  t = t.replace(/\r\n?/mg, `
`);
  let n;
  for (; (n = C1.exec(t)) != null; ) {
    const s = n[1];
    let a = n[2] || "";
    a = a.trim();
    const i = a[0];
    a = a.replace(/^(['"`])([\s\S]*)\1$/mg, "$2"), i === '"' && (a = a.replace(/\\n/g, `
`), a = a.replace(/\\r/g, "\r")), e[s] = a;
  }
  return e;
}
function N1(r) {
  r = r || {};
  const e = dy(r);
  r.path = e;
  const t = lt.configDotenv(r);
  if (!t.parsed) {
    const i = new Error(`MISSING_DATA: Cannot parse ${e} for an unknown reason`);
    throw i.code = "MISSING_DATA", i;
  }
  const n = ly(r).split(","), s = n.length;
  let a;
  for (let i = 0; i < s; i++)
    try {
      const o = n[i].trim(), c = L1(t, o);
      a = lt.decrypt(c.ciphertext, c.key);
      break;
    } catch (o) {
      if (i + 1 >= s)
        throw o;
    }
  return lt.parse(a);
}
function P1(r) {
  console.error(`[dotenv@${ql}][WARN] ${r}`);
}
function Us(r) {
  console.log(`[dotenv@${ql}][DEBUG] ${r}`);
}
function uy(r) {
  console.log(`[dotenv@${ql}] ${r}`);
}
function ly(r) {
  return r && r.DOTENV_KEY && r.DOTENV_KEY.length > 0 ? r.DOTENV_KEY : process.env.DOTENV_KEY && process.env.DOTENV_KEY.length > 0 ? process.env.DOTENV_KEY : "";
}
function L1(r, e) {
  let t;
  try {
    t = new URL(e);
  } catch (o) {
    if (o.code === "ERR_INVALID_URL") {
      const c = new Error("INVALID_DOTENV_KEY: Wrong format. Must be in valid uri format like dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=development");
      throw c.code = "INVALID_DOTENV_KEY", c;
    }
    throw o;
  }
  const n = t.password;
  if (!n) {
    const o = new Error("INVALID_DOTENV_KEY: Missing key part");
    throw o.code = "INVALID_DOTENV_KEY", o;
  }
  const s = t.searchParams.get("environment");
  if (!s) {
    const o = new Error("INVALID_DOTENV_KEY: Missing environment part");
    throw o.code = "INVALID_DOTENV_KEY", o;
  }
  const a = `DOTENV_VAULT_${s.toUpperCase()}`, i = r.parsed[a];
  if (!i) {
    const o = new Error(`NOT_FOUND_DOTENV_ENVIRONMENT: Cannot locate environment ${a} in your .env.vault file.`);
    throw o.code = "NOT_FOUND_DOTENV_ENVIRONMENT", o;
  }
  return { ciphertext: i, key: n };
}
function dy(r) {
  let e = null;
  if (r && r.path && r.path.length > 0)
    if (Array.isArray(r.path))
      for (const t of r.path)
        vu.existsSync(t) && (e = t.endsWith(".vault") ? t : `${t}.vault`);
    else
      e = r.path.endsWith(".vault") ? r.path : `${r.path}.vault`;
  else
    e = Ji.resolve(process.cwd(), ".env.vault");
  return vu.existsSync(e) ? e : null;
}
function vf(r) {
  return r[0] === "~" ? Ji.join(x1.homedir(), r.slice(1)) : r;
}
function M1(r) {
  const e = Jn(process.env.DOTENV_CONFIG_DEBUG || r && r.debug), t = Jn(process.env.DOTENV_CONFIG_QUIET || r && r.quiet);
  (e || !t) && uy("Loading env from encrypted .env.vault");
  const n = lt._parseVault(r);
  let s = process.env;
  return r && r.processEnv != null && (s = r.processEnv), lt.populate(s, n, r), { parsed: n };
}
function D1(r) {
  const e = Ji.resolve(process.cwd(), ".env");
  let t = "utf8", n = process.env;
  r && r.processEnv != null && (n = r.processEnv);
  let s = Jn(n.DOTENV_CONFIG_DEBUG || r && r.debug), a = Jn(n.DOTENV_CONFIG_QUIET || r && r.quiet);
  r && r.encoding ? t = r.encoding : s && Us("No encoding is specified. UTF-8 is used by default");
  let i = [e];
  if (r && r.path)
    if (!Array.isArray(r.path))
      i = [vf(r.path)];
    else {
      i = [];
      for (const l of r.path)
        i.push(vf(l));
    }
  let o;
  const c = {};
  for (const l of i)
    try {
      const d = lt.parse(vu.readFileSync(l, { encoding: t }));
      lt.populate(c, d, r);
    } catch (d) {
      s && Us(`Failed to load ${l} ${d.message}`), o = d;
    }
  const u = lt.populate(n, c, r);
  if (s = Jn(n.DOTENV_CONFIG_DEBUG || s), a = Jn(n.DOTENV_CONFIG_QUIET || a), s || !a) {
    const l = Object.keys(u).length, d = [];
    for (const h of i)
      try {
        const f = Ji.relative(process.cwd(), h);
        d.push(f);
      } catch (f) {
        s && Us(`Failed to load ${h} ${f.message}`), o = f;
      }
    uy(`injecting env (${l}) from ${d.join(",")} ${$1(`-- tip: ${O1()}`)}`);
  }
  return o ? { parsed: c, error: o } : { parsed: c };
}
function j1(r) {
  if (ly(r).length === 0)
    return lt.configDotenv(r);
  const e = dy(r);
  return e ? lt._configVault(r) : (P1(`You set DOTENV_KEY but you are missing a .env.vault file at ${e}. Did you forget to build it?`), lt.configDotenv(r));
}
function F1(r, e) {
  const t = Buffer.from(e.slice(-64), "hex");
  let n = Buffer.from(r, "base64");
  const s = n.subarray(0, 12), a = n.subarray(-16);
  n = n.subarray(12, -16);
  try {
    const i = I1.createDecipheriv("aes-256-gcm", t, s);
    return i.setAuthTag(a), `${i.update(n)}${i.final()}`;
  } catch (i) {
    const o = i instanceof RangeError, c = i.message === "Invalid key length", u = i.message === "Unsupported state or unable to authenticate data";
    if (o || c) {
      const l = new Error("INVALID_DOTENV_KEY: It must be 64 characters long (or more)");
      throw l.code = "INVALID_DOTENV_KEY", l;
    } else if (u) {
      const l = new Error("DECRYPTION_FAILED: Please check your DOTENV_KEY");
      throw l.code = "DECRYPTION_FAILED", l;
    } else
      throw i;
  }
}
function U1(r, e, t = {}) {
  const n = !!(t && t.debug), s = !!(t && t.override), a = {};
  if (typeof e != "object") {
    const i = new Error("OBJECT_REQUIRED: Please check the processEnv argument being passed to populate");
    throw i.code = "OBJECT_REQUIRED", i;
  }
  for (const i of Object.keys(e))
    Object.prototype.hasOwnProperty.call(r, i) ? (s === !0 && (r[i] = e[i], a[i] = e[i]), n && Us(s === !0 ? `"${i}" is already defined and WAS overwritten` : `"${i}" is already defined and was NOT overwritten`)) : (r[i] = e[i], a[i] = e[i]);
  return a;
}
const lt = {
  configDotenv: D1,
  _configVault: M1,
  _parseVault: N1,
  config: j1,
  decrypt: F1,
  parse: R1,
  populate: U1
};
Hr.exports.configDotenv = lt.configDotenv;
Hr.exports._configVault = lt._configVault;
Hr.exports._parseVault = lt._parseVault;
Hr.exports.config = lt.config;
Hr.exports.decrypt = lt.decrypt;
Hr.exports.parse = lt.parse;
Hr.exports.populate = lt.populate;
Hr.exports = lt;
var z1 = Hr.exports;
const B1 = /* @__PURE__ */ Ku(z1);
class Z1 {
  constructor() {
    v(this, "storage", new Ty());
  }
  run(e, t) {
    return this.storage.run(e, t);
  }
  getRunId() {
    var e;
    return ((e = this.storage.getStore()) == null ? void 0 : e.runId) ?? null;
  }
  getRequesterWebContentsId() {
    var e;
    return ((e = this.storage.getStore()) == null ? void 0 : e.requesterWebContentsId) ?? null;
  }
  getBrowserContext() {
    var e;
    return ((e = this.storage.getStore()) == null ? void 0 : e.browserContext) ?? null;
  }
  setBrowserContext(e) {
    const t = this.storage.getStore();
    t && (t.browserContext = e);
  }
  getObserveOnly() {
    var e;
    return ((e = this.storage.getStore()) == null ? void 0 : e.observeOnly) ?? !1;
  }
  setObserveOnly(e) {
    const t = this.storage.getStore();
    t && (t.observeOnly = e);
  }
  getYoloMode() {
    var e;
    return ((e = this.storage.getStore()) == null ? void 0 : e.yoloMode) ?? !1;
  }
  setYoloMode(e) {
    const t = this.storage.getStore();
    t && (t.yoloMode = e);
  }
}
const ft = new Z1();
class V1 {
  constructor() {
    v(this, "baseDir", null);
  }
  getBaseDir() {
    if (this.baseDir) return this.baseDir;
    const e = Bt.getPath("userData");
    return this.baseDir = ke.join(e, "telemetry"), this.baseDir;
  }
  async ensureDir() {
    await Ke.mkdir(this.getBaseDir(), { recursive: !0 });
  }
  fileForRun(e) {
    return ke.join(this.getBaseDir(), `agent-run-${e}.jsonl`);
  }
  async appendLine(e, t) {
    await this.ensureDir(), await Ke.appendFile(e, JSON.stringify(t) + `
`, "utf8");
  }
  async emit(e) {
    const t = e.runId;
    t && await this.appendLine(this.fileForRun(t), e), await this.appendLine(ke.join(this.getBaseDir(), "agent-events.jsonl"), e);
  }
  async exportTrajectories(e) {
    await this.ensureDir();
    const t = this.getBaseDir(), s = (await Ke.readdir(t)).filter((i) => i.startsWith("agent-run-") && i.endsWith(".jsonl")), a = [];
    for (const i of s)
      try {
        const c = (await Ke.readFile(ke.join(t, i), "utf8")).trim().split(`
`).map((u) => {
          try {
            return JSON.parse(u);
          } catch {
            return null;
          }
        }).filter((u) => u !== null);
        c.length > 0 && a.push({
          runId: c[0].runId,
          timestamp: c[0].ts,
          eventCount: c.length,
          events: c
        });
      } catch (o) {
        console.error(`Failed to process trajectory file ${i}:`, o);
      }
    return await Ke.writeFile(e, JSON.stringify(a, null, 2)), a.length;
  }
}
const et = new V1();
class q1 {
  constructor() {
    v(this, "db");
    v(this, "encryptionKey", null);
    v(this, "DB_FILENAME", "audit_logs.db");
    const e = Bt.getPath("userData"), t = If.join(e, this.DB_FILENAME);
    this.db = new Ey(t), this.init();
  }
  async init() {
    this.db.exec(`
      CREATE TABLE IF NOT EXISTS audit_logs (
        id TEXT PRIMARY KEY,
        timestamp TEXT NOT NULL,
        actor TEXT NOT NULL,
        action TEXT NOT NULL,
        details TEXT,
        status TEXT NOT NULL
      )
    `), await this.loadOrGenerateKey();
  }
  async loadOrGenerateKey() {
    let e = await Rs.getSecret("audit_db_key");
    e || (e = ps.randomBytes(32).toString("hex"), await Rs.setSecret("audit_db_key", e)), this.encryptionKey = Buffer.from(e, "hex");
  }
  encrypt(e) {
    if (!this.encryptionKey) return e;
    const t = ps.randomBytes(16), n = ps.createCipheriv("aes-256-cbc", this.encryptionKey, t);
    let s = n.update(e);
    return s = Buffer.concat([s, n.final()]), t.toString("hex") + ":" + s.toString("hex");
  }
  decrypt(e) {
    if (!this.encryptionKey) return e;
    try {
      const t = e.split(":"), n = Buffer.from(t.shift(), "hex"), s = Buffer.from(t.join(":"), "hex"), a = ps.createDecipheriv("aes-256-cbc", this.encryptionKey, n);
      let i = a.update(s);
      return i = Buffer.concat([i, a.final()]), i.toString();
    } catch (t) {
      return console.error("Failed to decrypt log:", t), "[Encrypted Content]";
    }
  }
  async log(e) {
    this.encryptionKey || await this.loadOrGenerateKey();
    const t = Pe(), n = (/* @__PURE__ */ new Date()).toISOString(), s = JSON.stringify(e.details), a = this.encrypt(s);
    return this.db.prepare(`
      INSERT INTO audit_logs (id, timestamp, actor, action, details, status)
      VALUES (?, ?, ?, ?, ?, ?)
    `).run(t, n, e.actor, e.action, a, e.status), t;
  }
  getLogs(e = 100) {
    return this.db.prepare("SELECT * FROM audit_logs ORDER BY timestamp DESC LIMIT ?").all(e).map((s) => ({
      ...s,
      details: this.decrypt(s.details)
      // Attempt to decrypt on read
    }));
  }
}
const yt = new q1();
var bu = /* @__PURE__ */ ((r) => (r.ALLOW = "allow", r.DENY = "deny", r.NEEDS_APPROVAL = "needs_approval", r))(bu || {});
const Ha = {
  // Browser observation tools - LOW risk
  browser_observe: 0,
  browser_wait_for_selector: 0,
  browser_wait_for_url: 0,
  browser_wait_for_text: 0,
  browser_wait_for_text_in: 0,
  browser_find_text: 0,
  browser_get_text: 0,
  browser_extract_main_text: 1,
  // Extraction is risky but read-only
  // Browser navigation - LOW to MEDIUM risk
  browser_navigate: 0,
  browser_go_back: 0,
  browser_go_forward: 0,
  browser_reload: 0,
  // Browser interaction - MEDIUM risk
  browser_click: 1,
  browser_click_text: 1,
  browser_type: 1,
  browser_select: 1,
  browser_scroll: 1,
  browser_press_key: 1,
  browser_focus: 1,
  browser_clear: 1,
  // Complex browser operations - HIGH risk
  browser_execute_plan: 2,
  browser_screenshot: 1,
  // Mock SaaS operations - MEDIUM to HIGH risk
  jira_create_issue: 2,
  jira_update_issue: 1,
  jira_delete_issue: 2,
  confluence_create_page: 2,
  confluence_update_page: 1,
  confluence_delete_page: 2,
  trello_create_card: 1,
  trello_move_card: 1,
  trello_delete_card: 2,
  // Code and file operations - MEDIUM to HIGH risk
  code_read_file: 0,
  code_list_files: 0,
  code_search: 0,
  code_execute: 2,
  code_write_file: 2,
  code_delete_file: 2,
  // System operations - HIGH risk
  system_execute: 2,
  system_write_file: 2,
  system_delete_file: 2
  /* HIGH */
}, Cr = {
  // Local development - LOW risk
  localhost: 0,
  "127.0.0.1": 0,
  "0.0.0.0": 0,
  // Mock SaaS - LOW risk (sandboxed)
  "mock-saas.com": 0,
  "localhost:3000": 0,
  // Trusted domains - LOW risk
  "docs.example.com": 0,
  "help.example.com": 0,
  // Production domains - MEDIUM to HIGH risk
  "app.example.com": 1,
  "admin.example.com": 2,
  "api.example.com": 1,
  // External domains - HIGH risk
  "github.com": 1,
  "stackoverflow.com": 0,
  "google.com": 0
  /* LOW */
};
class H1 {
  constructor(e, t) {
    v(this, "rules", []);
    v(this, "telemetryService");
    v(this, "auditService");
    this.telemetryService = e, this.auditService = t, this.initializeDefaultRules();
  }
  initializeDefaultRules() {
    this.addRule({
      name: "observe-only-enforcement",
      description: "Block state-modifying tools in observe-only mode",
      priority: 1e3,
      match: (e) => !!e.observeOnly,
      evaluate: (e) => [
        "browser_observe",
        "browser_navigate",
        // Allowed to move around to observe
        "browser_go_back",
        "browser_go_forward",
        "browser_reload",
        "browser_scroll",
        "browser_wait_for_selector",
        "browser_wait_for_url",
        "browser_wait_for_text",
        "browser_wait_for_text_in",
        "browser_get_text",
        "browser_find_text",
        "browser_extract_main_text",
        "browser_screenshot",
        "code_read_file",
        "code_list_files",
        "code_search"
      ].includes(e.toolName) ? {
        decision: "allow",
        riskLevel: 0,
        reason: "Tool allowed in observe-only mode (pending further checks)",
        matchedRule: "observe-only-enforcement"
      } : {
        decision: "deny",
        riskLevel: 2,
        reason: "Tool execution denied: Observe-only mode is active",
        matchedRule: "observe-only-enforcement"
      }
    }), this.addRule({
      name: "dangerous-operations-deny",
      description: "Deny dangerous system operations",
      priority: 100,
      match: (e) => ["system_execute", "system_delete_file", "code_execute"].includes(e.toolName),
      evaluate: (e) => ({
        decision: "deny",
        riskLevel: 2,
        reason: "Dangerous system operations are not allowed",
        matchedRule: "dangerous-operations-deny"
      })
    }), this.addRule({
      name: "admin-bypass",
      description: "Allow low/medium risk operations in admin mode",
      priority: 90,
      match: (e) => e.userMode === "admin",
      evaluate: (e) => {
        const t = Ha[e.toolName] || 1, n = e.domain && Cr[e.domain] || 1, s = t > n ? t : n;
        return s === 2 ? {
          decision: "needs_approval",
          riskLevel: 2,
          reason: "High risk operation requires approval even in admin mode",
          matchedRule: "admin-bypass"
        } : {
          decision: "allow",
          riskLevel: s,
          reason: "Allowed in admin mode",
          matchedRule: "admin-bypass"
        };
      }
    }), this.addRule({
      name: "high-risk-domains",
      description: "Require approval for operations on high-risk domains",
      priority: 80,
      match: (e) => (e.domain ? Cr[e.domain] : 1) === 2,
      evaluate: (e) => ({
        decision: "needs_approval",
        riskLevel: 2,
        reason: `High risk domain: ${e.domain}`,
        matchedRule: "high-risk-domains"
      })
    }), this.addRule({
      name: "extract-main-text-gating",
      description: "Gate browser_extract_main_text to reduce sensitive data exposure",
      priority: 85,
      match: (e) => e.toolName === "browser_extract_main_text",
      evaluate: (e) => {
        const t = e.domain ? Cr[e.domain] : void 0;
        return (t === void 0 ? 2 : t) === 0 ? {
          decision: "needs_approval",
          riskLevel: 1,
          reason: "Extract main text requires approval",
          matchedRule: "extract-main-text-gating"
        } : {
          decision: "needs_approval",
          riskLevel: 2,
          reason: `Extract main text on non-low-risk domain: ${e.domain ?? "unknown"}`,
          matchedRule: "extract-main-text-gating"
        };
      }
    }), this.addRule({
      name: "external-file-operations",
      description: "File uploads/downloads on external domains need approval",
      priority: 70,
      match: (e) => {
        const t = ["code_write_file", "code_delete_file"], n = !!(e.domain && !(e.domain in Cr));
        return t.includes(e.toolName) && n;
      },
      evaluate: (e) => ({
        decision: "needs_approval",
        riskLevel: 2,
        reason: "File operations on external domains require approval",
        matchedRule: "external-file-operations"
      })
    }), this.addRule({
      name: "default-risk-evaluation",
      description: "Default evaluation based on tool and domain risk",
      priority: 0,
      match: () => !0,
      // Always matches as fallback
      evaluate: (e) => {
        const t = Ha[e.toolName] || 1, n = e.domain && Cr[e.domain] || 1, s = t > n ? t : n, a = this.evaluateArgsRisk(e), i = a > s ? a : s;
        return i === 2 ? {
          decision: "needs_approval",
          riskLevel: 2,
          reason: "High risk operation detected",
          matchedRule: "default-risk-evaluation"
        } : i === 1 && e.userMode !== "developer" ? {
          decision: "needs_approval",
          riskLevel: 1,
          reason: "Medium risk operation requires approval in standard mode",
          matchedRule: "default-risk-evaluation"
        } : {
          decision: "allow",
          riskLevel: i,
          reason: "Low risk operation allowed",
          matchedRule: "default-risk-evaluation"
        };
      }
    });
  }
  evaluateArgsRisk(e) {
    const { args: t } = e;
    if (!t || typeof t != "object") return 0;
    if (e.toolName === "browser_navigate" && t && typeof t.url == "string")
      try {
        const a = new URL(t.url), i = a.port ? `${a.hostname}:${a.port}` : a.hostname, o = Cr[i];
        if (o === 2 || o === void 0)
          return 2;
      } catch {
        return 2;
      }
    if (e.toolName === "browser_execute_plan")
      try {
        const a = Array.isArray(t == null ? void 0 : t.steps) ? t.steps : [];
        for (const i of a)
          if ((i == null ? void 0 : i.action) === "navigate" && typeof (i == null ? void 0 : i.url) == "string")
            try {
              const o = new URL(i.url), c = o.port ? `${o.hostname}:${o.port}` : o.hostname, u = Cr[c];
              if (u === 2 || u === void 0)
                return 2;
            } catch {
              return 2;
            }
      } catch {
        return 1;
      }
    const n = [
      /password/i,
      /token/i,
      /secret/i,
      /key/i,
      /delete/i,
      /drop\s+table/i,
      /rm\s+-rf/i,
      /sudo/i
    ], s = JSON.stringify(t).toLowerCase();
    for (const a of n)
      if (a.test(s))
        return 2;
    return t.value && typeof t.value == "string" && t.value.length > 1e4 ? 1 : 0;
  }
  addRule(e) {
    this.rules.push(e), this.rules.sort((t, n) => n.priority - t.priority);
  }
  removeRule(e) {
    this.rules = this.rules.filter((t) => t.name !== e);
  }
  async evaluate(e) {
    const t = Date.now(), n = e.runId;
    for (const s of this.rules)
      if (s.match(e)) {
        const a = s.evaluate(e), i = Date.now() - t, o = this.hashArgs(e.args);
        try {
          await this.telemetryService.emit({
            eventId: Pe(),
            runId: n,
            ts: (/* @__PURE__ */ new Date()).toISOString(),
            type: "policy_evaluation",
            name: "PolicyService",
            data: {
              toolName: e.toolName,
              domain: e.domain,
              userMode: e.userMode,
              decision: a.decision,
              riskLevel: a.riskLevel,
              matchedRule: s.name,
              durationMs: i,
              argsHash: o
            }
          });
        } catch {
        }
        try {
          await this.auditService.log({
            actor: "system",
            action: "policy_evaluation",
            details: {
              runId: n,
              toolName: e.toolName,
              domain: e.domain,
              userMode: e.userMode,
              decision: a.decision,
              riskLevel: a.riskLevel,
              reason: a.reason,
              matchedRule: s.name,
              durationMs: i,
              argsHash: o
            },
            status: "success"
          }).catch(() => {
          });
        } catch {
        }
        return a;
      }
    return {
      decision: "needs_approval",
      riskLevel: 1,
      reason: "No policy rule matched"
    };
  }
  hashArgs(e) {
    if (!e) return "";
    const t = JSON.stringify(e);
    let n = 0;
    for (let s = 0; s < t.length; s++) {
      const a = t.charCodeAt(s);
      n = (n << 5) - n + a, n = n & n;
    }
    return n.toString(36);
  }
  // Helper methods for policy management
  getRules() {
    return [...this.rules];
  }
  getToolRiskLevel(e) {
    return Ha[e] || 1;
  }
  getDomainRiskLevel(e) {
    return Cr[e] || 1;
  }
  // Update domain risk levels at runtime
  updateDomainRiskLevel(e, t) {
    Cr[e] = t;
  }
  // Update tool risk levels at runtime
  updateToolRiskLevel(e, t) {
    Ha[e] = t;
  }
}
class J1 {
  constructor() {
    v(this, "tools", /* @__PURE__ */ new Map());
    v(this, "approvalHandler", null);
    v(this, "policyService", null);
  }
  setApprovalHandler(e) {
    this.approvalHandler = e;
  }
  setPolicyService(e) {
    this.policyService = e;
  }
  getPolicyService() {
    return this.policyService;
  }
  register(e) {
    this.tools.has(e.name) && console.warn(`Tool with name ${e.name} is already registered. Overwriting.`), this.tools.set(e.name, e);
  }
  getTool(e) {
    return this.tools.get(e);
  }
  getAllTools() {
    return Array.from(this.tools.values());
  }
  async invokeToolInternal(e, t) {
    var l;
    const n = ft.getRunId() ?? void 0, s = (() => {
      try {
        return JSON.stringify(t ?? null);
      } catch {
        return "[unserializable_args]";
      }
    })(), a = rn.createHash("sha256").update(s).digest("hex"), i = Pe(), o = Date.now();
    try {
      await et.emit({
        eventId: Pe(),
        runId: n,
        ts: (/* @__PURE__ */ new Date()).toISOString(),
        type: "tool_call_start",
        name: e.name,
        data: { toolCallId: i, argsHash: a }
      });
    } catch {
    }
    try {
      yt.log({
        actor: "agent",
        action: "tool_call_start",
        details: { runId: n, toolName: e.name, toolCallId: i, argsHash: a },
        status: "pending"
      }).catch(() => {
      });
    } catch {
    }
    const c = this.approvalHandler, u = this.policyService;
    if (u) {
      const d = ft.getBrowserContext(), h = {
        toolName: e.name,
        args: t,
        url: d == null ? void 0 : d.url,
        domain: d == null ? void 0 : d.domain,
        userMode: "standard",
        observeOnly: ft.getObserveOnly(),
        runId: n
      }, f = await u.evaluate(h);
      if (f.decision === bu.DENY) {
        const p = Date.now() - o;
        try {
          await et.emit({
            eventId: Pe(),
            runId: n,
            ts: (/* @__PURE__ */ new Date()).toISOString(),
            type: "tool_call_end",
            name: e.name,
            data: { toolCallId: i, argsHash: a, durationMs: p, error: "Policy denied" }
          });
        } catch {
        }
        try {
          yt.log({
            actor: "system",
            action: "tool_call_denied",
            details: { runId: n, toolName: e.name, toolCallId: i, reason: f.reason },
            status: "failure"
          }).catch(() => {
          });
        } catch {
        }
        return `Operation denied by policy: ${f.reason}`;
      }
      if (f.decision === bu.NEEDS_APPROVAL && c)
        if (ft.getYoloMode())
          try {
            yt.log({
              actor: "system",
              action: "approval_auto_granted",
              details: { runId: n, toolName: e.name, toolCallId: i, reason: "YOLO mode" },
              status: "success"
            }).catch(() => {
            });
          } catch {
          }
        else {
          try {
            await et.emit({
              eventId: Pe(),
              runId: n,
              ts: (/* @__PURE__ */ new Date()).toISOString(),
              type: "approval_request",
              name: e.name,
              data: { toolCallId: i, argsHash: a, riskLevel: f.riskLevel }
            });
          } catch {
          }
          try {
            yt.log({
              actor: "system",
              action: "approval_request",
              details: { runId: n, toolName: e.name, toolCallId: i, argsHash: a, reason: f.reason },
              status: "pending"
            }).catch(() => {
            });
          } catch {
          }
          const p = await c(e.name, t);
          try {
            await et.emit({
              eventId: Pe(),
              runId: n,
              ts: (/* @__PURE__ */ new Date()).toISOString(),
              type: "approval_decision",
              name: e.name,
              data: { toolCallId: i, argsHash: a, approved: p }
            });
          } catch {
          }
          try {
            yt.log({
              actor: "system",
              action: "approval_decision",
              details: { runId: n, toolName: e.name, toolCallId: i, argsHash: a, approved: p },
              status: p ? "success" : "failure"
            }).catch(() => {
            });
          } catch {
          }
          if (!p) {
            const y = Date.now() - o;
            try {
              await et.emit({
                eventId: Pe(),
                runId: n,
                ts: (/* @__PURE__ */ new Date()).toISOString(),
                type: "tool_call_end",
                name: e.name,
                data: { toolCallId: i, argsHash: a, durationMs: y, error: "User denied" }
              });
            } catch {
            }
            try {
              yt.log({
                actor: "user",
                action: "tool_call_denied",
                details: { runId: n, toolName: e.name, toolCallId: i },
                status: "failure"
              }).catch(() => {
              });
            } catch {
            }
            return "User denied execution of this tool.";
          }
        }
    } else if (e.requiresApproval && c)
      if (ft.getYoloMode())
        try {
          yt.log({
            actor: "system",
            action: "approval_auto_granted",
            details: { runId: n, toolName: e.name, toolCallId: i, reason: "YOLO mode" },
            status: "success"
          }).catch(() => {
          });
        } catch {
        }
      else {
        try {
          await et.emit({
            eventId: Pe(),
            runId: n,
            ts: (/* @__PURE__ */ new Date()).toISOString(),
            type: "approval_request",
            name: e.name,
            data: { toolCallId: i, argsHash: a }
          });
        } catch {
        }
        try {
          yt.log({
            actor: "system",
            action: "approval_request",
            details: { runId: n, toolName: e.name, toolCallId: i, argsHash: a },
            status: "pending"
          }).catch(() => {
          });
        } catch {
        }
        const d = await c(e.name, t);
        try {
          await et.emit({
            eventId: Pe(),
            runId: n,
            ts: (/* @__PURE__ */ new Date()).toISOString(),
            type: "approval_decision",
            name: e.name,
            data: { toolCallId: i, argsHash: a, approved: d }
          });
        } catch {
        }
        try {
          yt.log({
            actor: "system",
            action: "approval_decision",
            details: { runId: n, toolName: e.name, toolCallId: i, argsHash: a, approved: d },
            status: d ? "success" : "failure"
          }).catch(() => {
          });
        } catch {
        }
        if (!d) {
          const h = Date.now() - o;
          try {
            await et.emit({
              eventId: Pe(),
              runId: n,
              ts: (/* @__PURE__ */ new Date()).toISOString(),
              type: "tool_call_end",
              name: e.name,
              data: { toolCallId: i, argsHash: a, durationMs: h, error: "User denied" }
            });
          } catch {
          }
          try {
            yt.log({
              actor: "user",
              action: "tool_call_denied",
              details: { runId: n, toolName: e.name, toolCallId: i },
              status: "failure"
            }).catch(() => {
            });
          } catch {
          }
          return "User denied execution of this tool.";
        }
      }
    try {
      const d = (l = e.schema) != null && l.parse ? e.schema.parse(t ?? {}) : t, h = await e.execute(d), f = Date.now() - o;
      try {
        await et.emit({
          eventId: Pe(),
          runId: n,
          ts: (/* @__PURE__ */ new Date()).toISOString(),
          type: "tool_call_end",
          name: e.name,
          data: { toolCallId: i, argsHash: a, durationMs: f, resultLength: String(h ?? "").length }
        });
      } catch {
      }
      try {
        yt.log({
          actor: "agent",
          action: "tool_call_end",
          details: { runId: n, toolName: e.name, toolCallId: i, durationMs: f },
          status: "success"
        }).catch(() => {
        });
      } catch {
      }
      return h;
    } catch (d) {
      const h = Date.now() - o;
      try {
        await et.emit({
          eventId: Pe(),
          runId: n,
          ts: (/* @__PURE__ */ new Date()).toISOString(),
          type: "tool_call_end",
          name: e.name,
          data: { toolCallId: i, argsHash: a, durationMs: h, error: String((d == null ? void 0 : d.message) ?? d) }
        });
      } catch {
      }
      try {
        yt.log({
          actor: "agent",
          action: "tool_call_end",
          details: { runId: n, toolName: e.name, toolCallId: i, durationMs: h, error: String((d == null ? void 0 : d.message) ?? d) },
          status: "failure"
        }).catch(() => {
        });
      } catch {
      }
      return `Tool execution failed: ${String((d == null ? void 0 : d.message) ?? d)}`;
    }
  }
  async invokeTool(e, t) {
    const n = this.tools.get(e);
    return n ? this.invokeToolInternal(n, t) : `Error: Tool '${e}' not found.`;
  }
  // Convert to LangChain tools format
  toLangChainTools() {
    const e = this;
    return this.getAllTools().map((t) => new class extends Lo {
      constructor() {
        super(...arguments);
        v(this, "name", t.name);
        v(this, "description", t.description);
        v(this, "schema", t.schema);
      }
      async _call(s) {
        return e.invokeToolInternal(t, s);
      }
    }());
  }
}
const we = new J1();
class W1 {
  constructor() {
    v(this, "storageFile");
    v(this, "skills", []);
    this.storageFile = ke.resolve(process.cwd(), "skill_library.json"), this.load(), this.registerTools();
  }
  async load() {
    var e;
    try {
      const t = await Ke.readFile(this.storageFile, "utf8");
      this.skills = JSON.parse(t);
    } catch {
      try {
        const t = ke.resolve(process.cwd(), "task_knowledge.json"), n = await Ke.readFile(t, "utf8"), s = JSON.parse(n);
        this.skills = s.map((a) => {
          const i = Date.now();
          return {
            id: Pe(),
            name: a.goal.toLowerCase().replace(/\s+/g, "_").slice(0, 50),
            description: a.goal,
            domain: "unknown",
            steps: a.steps,
            currentVersion: 1,
            stats: { successes: 0, failures: 0, lastUsed: i },
            versions: [{ version: 1, steps: a.steps, createdAt: i }],
            tags: a.trigger_keywords || []
          };
        }), await this.save();
      } catch {
        this.skills = [];
      }
    }
    for (const t of this.skills) {
      const n = Array.isArray(t == null ? void 0 : t.versions) ? t.versions : [];
      if (typeof t.currentVersion != "number") {
        const s = n.length > 0 ? Number(((e = n[n.length - 1]) == null ? void 0 : e.version) ?? n.length) : 1;
        t.currentVersion = s;
      }
      (!t.stats || typeof t.stats != "object") && (t.stats = { successes: 0, failures: 0, lastUsed: Date.now() }), typeof t.stats.successes != "number" && (t.stats.successes = 0), typeof t.stats.failures != "number" && (t.stats.failures = 0), typeof t.stats.partials != "number" && (t.stats.partials = 0), typeof t.stats.lastUsed != "number" && (t.stats.lastUsed = Date.now()), Array.isArray(t.tags) || (t.tags = []), Array.isArray(t.feedback) || (t.feedback = []), (!Array.isArray(t.embedding) || t.embedding.length === 0) && (t.embedding = this.computeEmbedding(this.buildSkillText(t)));
    }
    try {
      await this.save();
    } catch {
    }
  }
  normalizeText(e) {
    return String(e ?? "").toLowerCase().replace(/[^a-z0-9_\-\s/.:]+/g, " ").replace(/\s+/g, " ").trim();
  }
  tokenize(e) {
    const t = this.normalizeText(e);
    return t ? t.split(" ").filter(Boolean).slice(0, 400) : [];
  }
  computeEmbedding(e) {
    const n = new Array(256).fill(0), s = this.tokenize(e);
    for (const i of s) {
      let o = 2166136261;
      for (let u = 0; u < i.length; u++)
        o ^= i.charCodeAt(u), o = Math.imul(o, 16777619);
      const c = Math.abs(o) % 256;
      n[c] += 1;
    }
    let a = 0;
    for (const i of n) a += i * i;
    return a = Math.sqrt(a) || 1, n.map((i) => i / a);
  }
  cosineSimilarity(e, t) {
    if (!e || !t || e.length === 0 || t.length === 0) return 0;
    const n = Math.min(e.length, t.length);
    let s = 0;
    for (let a = 0; a < n; a++) s += e[a] * t[a];
    return s;
  }
  buildSkillText(e) {
    const t = (e.steps || []).map((n) => [n.action, n.url, n.selector, n.value, n.text].filter(Boolean).join(" ")).join(" ");
    return [e.name, e.description, e.domain, e.fingerprint ?? "", ...e.tags || [], t].filter(Boolean).join(" ");
  }
  async save() {
    try {
      await Ke.writeFile(this.storageFile, JSON.stringify(this.skills, null, 2));
    } catch (e) {
      console.error("Failed to save skill library:", e);
    }
  }
  findSkill(e, t, n) {
    const s = e.toLowerCase();
    let a = this.skills;
    t && (a = a.filter(
      (c) => c.domain === t || t.includes(c.domain) || c.domain === "unknown"
    )), n && (a = a.filter((c) => c.fingerprint ? n.includes(c.fingerprint) || c.fingerprint.includes(n) : !0));
    const i = this.computeEmbedding(e), o = a.map((c) => {
      let u = 0;
      c.name.replace(/_/g, " ").includes(s) && (u += 10), c.description.toLowerCase().includes(s) && (u += 5), c.tags.some((y) => s.includes(y.toLowerCase())) && (u += 3);
      const l = c.stats.partials ?? 0, d = c.stats.successes + c.stats.failures + l;
      if (d > 0) {
        const y = (c.stats.successes + 0.5 * l) / d;
        u += y * 2;
      }
      n && c.fingerprint && (n === c.fingerprint ? u += 3 : (n.includes(c.fingerprint) || c.fingerprint.includes(n)) && (u += 1));
      const h = this.cosineSimilarity(c.embedding, i);
      u += h * 10;
      const p = (Array.isArray(c.feedback) ? c.feedback : []).slice(-6);
      for (const y of p)
        y.label === "worked" && (u += 0.6), y.label === "partial" && (u += 0.2), y.label === "failed" && (u -= 0.6);
      return { skill: c, score: u };
    });
    return o.sort((c, u) => u.score - c.score), o.length > 0 && o[0].score > 0 ? o[0].skill : null;
  }
  addSkill(e) {
    const t = this.skills.findIndex(
      (n) => n.name === e.name && n.domain === e.domain
    );
    if (t >= 0) {
      const n = this.skills[t], s = (n.versions.length > 0 ? n.versions[n.versions.length - 1].version : 0) + 1;
      n.versions.push({
        version: s,
        steps: e.steps,
        createdAt: Date.now()
      }), n.steps = e.steps, n.description = e.description, n.domain = e.domain, n.fingerprint = e.fingerprint ?? n.fingerprint, n.currentVersion = s, n.tags = Array.from(/* @__PURE__ */ new Set([...n.tags, ...e.tags])), n.stats.lastUsed = Date.now(), n.stats.successes += 1, n.stats.lastOutcomeAt = Date.now(), n.stats.lastOutcomeSuccess = !0, n.embedding = this.computeEmbedding(this.buildSkillText(n)), this.skills[t] = n;
    } else {
      const n = {
        id: Pe(),
        name: e.name,
        description: e.description,
        domain: e.domain,
        fingerprint: e.fingerprint,
        steps: e.steps,
        currentVersion: 1,
        embedding: this.computeEmbedding(this.buildSkillText({
          id: "tmp",
          name: e.name,
          description: e.description,
          domain: e.domain,
          fingerprint: e.fingerprint,
          steps: e.steps,
          currentVersion: 1,
          stats: { successes: 1, failures: 0, partials: 0, lastUsed: Date.now(), lastOutcomeAt: Date.now(), lastOutcomeSuccess: !0 },
          versions: [{ version: 1, steps: e.steps, createdAt: Date.now() }],
          tags: e.tags
        })),
        stats: { successes: 1, failures: 0, partials: 0, lastUsed: Date.now(), lastOutcomeAt: Date.now(), lastOutcomeSuccess: !0 },
        feedback: [],
        versions: [{ version: 1, steps: e.steps, createdAt: Date.now() }],
        tags: e.tags
      };
      this.skills.push(n);
    }
    this.save();
  }
  recordOutcome(e, t) {
    this.recordFeedback(e, t ? "worked" : "failed");
  }
  recordFeedback(e, t, n) {
    const s = this.skills.find((c) => c.id === e);
    if (!s) return;
    t === "worked" && s.stats.successes++, t === "failed" && s.stats.failures++, t === "partial" && (s.stats.partials = (s.stats.partials ?? 0) + 1), s.stats.lastUsed = Date.now(), s.stats.lastOutcomeAt = Date.now(), s.stats.lastOutcomeSuccess = t === "worked";
    const a = ft.getRunId() ?? void 0, i = ft.getBrowserContext(), o = {
      ts: Date.now(),
      label: t,
      version: n ?? s.currentVersion,
      runId: a,
      domain: i == null ? void 0 : i.domain,
      fingerprint: (() => {
        const c = i == null ? void 0 : i.url;
        if (c)
          try {
            return new URL(c).pathname || void 0;
          } catch {
            return;
          }
      })()
    };
    Array.isArray(s.feedback) || (s.feedback = []), s.feedback.push(o), s.feedback.length > 200 && (s.feedback = s.feedback.slice(-200)), this.save();
  }
  rollbackSkill(e, t) {
    const n = this.skills.find((a) => a.id === e);
    if (!n) return !1;
    const s = n.versions.find((a) => a.version === t);
    return s ? (n.steps = s.steps, n.currentVersion = s.version, n.stats.lastUsed = Date.now(), this.save(), !0) : !1;
  }
  registerTools() {
    const e = Ee({
      name: G().describe('Short identifier for the skill (e.g. "create_jira_issue")'),
      description: G().describe("Description of what the skill does"),
      domain: G().optional().describe('Domain where this skill applies (e.g. "localhost:3000")'),
      fingerprint: G().optional().describe('Optional page fingerprint (e.g. "/jira" or "/aerocore/admin")'),
      steps: Zi(
        Ee({
          action: Gn(["navigate", "click", "type", "select", "wait"]),
          url: G().optional(),
          selector: G().optional(),
          value: G().optional(),
          text: G().optional()
        })
      ),
      tags: Zi(G()).describe("Keywords for retrieval")
    }), t = {
      name: "knowledge_save_skill",
      description: "Save a verified execution plan as a reusable skill.",
      schema: e,
      execute: async (o) => {
        const c = e.parse(o), u = ft.getBrowserContext(), l = c.domain ?? (u == null ? void 0 : u.domain) ?? "unknown", d = (() => {
          if (c.fingerprint) return c.fingerprint;
          const h = u == null ? void 0 : u.url;
          if (h)
            try {
              return new URL(h).pathname || void 0;
            } catch {
              return;
            }
        })();
        return this.addSkill({
          name: c.name,
          description: c.description,
          domain: l,
          fingerprint: d,
          steps: c.steps,
          tags: c.tags
        }), `Saved skill "${c.name}" for domain ${l}.`;
      }
    }, n = {
      name: "knowledge_search_skill",
      description: "Search for a saved skill matching the user request and domain.",
      schema: Ee({
        query: G().describe("User request description"),
        domain: G().optional().describe("Current domain context"),
        fingerprint: G().optional().describe("Optional page fingerprint for disambiguation")
      }),
      execute: async (o) => {
        const { query: c, domain: u, fingerprint: l } = o, d = ft.getBrowserContext(), h = u ?? (d == null ? void 0 : d.domain), f = l ?? (() => {
          const y = d == null ? void 0 : d.url;
          if (y)
            try {
              return new URL(y).pathname || void 0;
            } catch {
              return;
            }
        })(), p = this.findSkill(c, h, f);
        return JSON.stringify(p ? {
          found: !0,
          skill: {
            id: p.id,
            name: p.name,
            description: p.description,
            domain: p.domain,
            fingerprint: p.fingerprint,
            currentVersion: p.currentVersion,
            steps: p.steps,
            stats: p.stats
          }
        } : { found: !1 });
      }
    }, s = {
      name: "knowledge_record_outcome",
      description: "Record whether a skill execution succeeded or failed.",
      schema: Ee({
        skillId: G(),
        success: Bi().optional(),
        label: Gn(["worked", "failed", "partial"]).optional(),
        version: Qe().optional()
      }),
      execute: async (o) => {
        const { skillId: c, success: u, label: l, version: d } = o, h = l ?? (u === !0 ? "worked" : u === !1 ? "failed" : "worked");
        return this.recordFeedback(c, h, d), `Recorded ${h} for skill ${c}.`;
      }
    }, a = {
      name: "knowledge_rollback_skill",
      description: "Rollback a skill to a previous version.",
      schema: Ee({
        skillId: G(),
        version: Qe().describe("Version number to restore")
      }),
      execute: async (o) => {
        const { skillId: c, version: u } = o;
        return this.rollbackSkill(c, u) ? `Rolled back skill ${c} to version ${u}.` : `Failed to rollback skill ${c} to version ${u}.`;
      }
    }, i = {
      name: "knowledge_list_skills",
      description: "List saved skills for debugging and evaluation.",
      schema: Ee({
        domain: G().optional()
      }),
      execute: async (o) => {
        const { domain: c } = o ?? {}, u = ft.getBrowserContext(), l = c ?? (u == null ? void 0 : u.domain), h = (l ? this.skills.filter((f) => f.domain === l || f.domain === "unknown") : this.skills).map((f) => {
          const p = f.stats.successes + f.stats.failures, y = p > 0 ? f.stats.successes / p : null;
          return {
            id: f.id,
            name: f.name,
            domain: f.domain,
            fingerprint: f.fingerprint,
            currentVersion: f.currentVersion,
            successes: f.stats.successes,
            failures: f.stats.failures,
            successRate: y,
            versions: f.versions.map((g) => g.version),
            lastUsed: f.stats.lastUsed,
            tags: f.tags
          };
        }).sort((f, p) => (p.successRate ?? -1) - (f.successRate ?? -1));
        return JSON.stringify({ count: h.length, skills: h }, null, 2);
      }
    };
    we.register(t), we.register(n), we.register(s), we.register(a), we.register(i);
  }
}
const Ja = new W1();
B1.config();
const zn = [
  // Fast models
  {
    id: "llama-3.1-70b",
    name: "Llama 3.1 70B (Fast)",
    modelName: "meta/llama-3.1-70b-instruct",
    temperature: 0.1,
    maxTokens: 4096,
    supportsThinking: !1
  },
  {
    id: "llama-3.3-70b",
    name: "Llama 3.3 70B â­ Recommended",
    modelName: "meta/llama-3.3-70b-instruct",
    temperature: 0.1,
    maxTokens: 4096,
    supportsThinking: !1
  },
  {
    id: "qwen3-235b",
    name: "Qwen3 235B (Best Quality)",
    modelName: "qwen/qwen3-235b-a22b",
    temperature: 0.6,
    maxTokens: 4096,
    supportsThinking: !1
  },
  // Thinking models
  {
    id: "deepseek-v3.1",
    name: "DeepSeek V3.1 (Thinking)",
    modelName: "deepseek-ai/deepseek-v3.1-terminus",
    temperature: 0.2,
    maxTokens: 8192,
    supportsThinking: !0,
    extraBody: { chat_template_kwargs: { thinking: !0 } }
  },
  {
    id: "qwen3-80b",
    name: "Qwen3 80B (Thinking)",
    modelName: "qwen/qwen3-next-80b-a3b-thinking",
    temperature: 0.6,
    maxTokens: 4096,
    supportsThinking: !0
  },
  {
    id: "kimi-k2",
    name: "Kimi K2 (Thinking)",
    modelName: "moonshotai/kimi-k2-thinking",
    temperature: 1,
    maxTokens: 16384,
    supportsThinking: !0
  },
  {
    id: "nemotron-nano",
    name: "Nemotron Nano 30B (Thinking)",
    modelName: "nvidia/nemotron-3-nano-30b-a3b",
    temperature: 1,
    maxTokens: 16384,
    supportsThinking: !0,
    extraBody: { chat_template_kwargs: { enable_thinking: !0 } }
  },
  // Specialized models
  {
    id: "actions-policy-v1",
    name: "Actions Policy (Beta)",
    modelName: "custom/actions-policy-v1",
    temperature: 0,
    maxTokens: 2048,
    supportsThinking: !1
  }
], zs = class zs {
  constructor() {
    v(this, "model");
    v(this, "currentModelId", "llama-3.1-70b");
    v(this, "useActionsPolicy", !1);
    v(this, "agentMode", "do");
    v(this, "permissionMode", "permissions");
    v(this, "onStep");
    v(this, "conversationHistory", []);
    v(this, "systemPrompt");
    this.model = this.createModel("llama-3.1-70b"), this.systemPrompt = new ct("");
  }
  /**
   * Redact common secrets from text before sending to LLM
   */
  redactSecrets(e) {
    if (!e) return e;
    let t = e;
    const n = [
      // Bearer tokens
      { re: /Bearer\s+[a-zA-Z0-9\-\._]+/gi, repl: "Bearer [REDACTED_TOKEN]" },
      // Authorization header
      { re: /Authorization\s*:\s*Bearer\s+[a-zA-Z0-9\-\._]+/gi, repl: "Authorization: Bearer [REDACTED_TOKEN]" },
      // OpenAI sk- keys
      { re: /sk-[a-zA-Z0-9]{32,}/g, repl: "[REDACTED_OPENAI_KEY]" },
      // GitHub tokens
      { re: /gh[pousr]_[A-Za-z0-9_]{20,}/g, repl: "[REDACTED_GITHUB_TOKEN]" },
      // Slack tokens
      { re: /xox[baprs]-[A-Za-z0-9-]{10,}/g, repl: "[REDACTED_SLACK_TOKEN]" },
      // AWS Access Keys
      { re: /AKIA[0-9A-Z]{16}/g, repl: "[REDACTED_AWS_KEY]" },
      // JWT-like tokens
      { re: /\beyJ[a-zA-Z0-9_-]{10,}\.[a-zA-Z0-9_-]{10,}\.[a-zA-Z0-9_-]{10,}\b/g, repl: "[REDACTED_JWT]" },
      // Generic "password": "..." patterns (loose match)
      { re: /"(password|client_secret|access_token|id_token|refresh_token|api_key|apikey)"\s*:\s*"[^"]+"/gi, repl: '"$1": "[REDACTED]"' },
      // password=... / token=... forms
      { re: /(password|passwd|pwd|token|secret|api[_-]?key)\s*[:=]\s*[^\s\n"']+/gi, repl: "$1=[REDACTED]" },
      // Private Keys
      { re: /-----BEGIN [A-Z]+ PRIVATE KEY-----[\s\S]*?-----END [A-Z]+ PRIVATE KEY-----/g, repl: "[REDACTED_PRIVATE_KEY]" }
    ];
    for (const { re: s, repl: a } of n)
      t = t.replace(s, a);
    return t;
  }
  extractJsonObject(e) {
    const t = e.replace(/```json/g, "").replace(/```/g, "").trim(), n = t.indexOf("{");
    if (n === -1) return null;
    let s = !1, a = !1, i = 0;
    for (let o = n; o < t.length; o++) {
      const c = t[o];
      if (s) {
        a ? a = !1 : c === "\\" ? a = !0 : c === '"' && (s = !1);
        continue;
      }
      if (c === '"') {
        s = !0;
        continue;
      }
      if (c === "{" && i++, c === "}" && i--, i === 0) return t.slice(n, o + 1);
    }
    return null;
  }
  parseToolCall(e) {
    const t = e.replace(/```json/g, "").replace(/```/g, "").trim(), n = this.extractJsonObject(t) ?? (t.startsWith("{") ? t : null);
    if (!n) return null;
    const s = (h) => {
      try {
        return JSON.parse(h);
      } catch {
        return null;
      }
    }, a = s(n);
    if (a) return a;
    const i = n.replace(/,\s*([}\]])/g, "$1"), o = s(i);
    if (o) return o;
    const c = t.match(/"tool"\s*:\s*"([^"]+)"/);
    if (!c) return null;
    const u = c[1];
    if (u !== "final_response") return null;
    const l = t.match(/"message"\s*:\s*"([\s\S]*?)"\s*(?:,|\})/), d = l ? l[1] : "";
    return { tool: u, args: { message: d } };
  }
  /**
   * Toggle the use of the specialized actions policy model
   */
  toggleActionsPolicy(e) {
    this.useActionsPolicy = e, e ? this.setModel("actions-policy-v1") : this.setModel("llama-3.1-70b"), console.log(`[AgentService] Actions Policy Model: ${e ? "ENABLED" : "DISABLED"}`);
  }
  isActionsPolicyEnabled() {
    return this.useActionsPolicy;
  }
  /**
   * Set the agent mode (chat/read/do)
   */
  setAgentMode(e) {
    this.agentMode = e, console.log(`[AgentService] Agent Mode: ${e}`);
  }
  getAgentMode() {
    return this.agentMode;
  }
  /**
   * Set the permission mode (yolo/permissions) - only applies in 'do' mode
   */
  setPermissionMode(e) {
    this.permissionMode = e, console.log(`[AgentService] Permission Mode: ${e}`);
  }
  getPermissionMode() {
    return this.permissionMode;
  }
  /**
   * Check if YOLO mode is active (do mode + yolo permissions)
   */
  isYoloMode() {
    return this.agentMode === "do" && this.permissionMode === "yolo";
  }
  /**
   * Create a model instance from config
   */
  createModel(e) {
    const t = process.env.NVIDIA_API_KEY;
    t || console.warn("NVIDIA_API_KEY is not set in environment variables");
    const n = zn.find((a) => a.id === e) || zn[0];
    console.log(`[AgentService] Creating model: ${n.name} (${n.modelName})`);
    const s = {
      response_format: { type: "json_object" },
      ...n.extraBody
    };
    return new d1({
      configuration: {
        baseURL: "https://integrate.api.nvidia.com/v1",
        apiKey: t
      },
      modelName: n.modelName,
      temperature: n.temperature,
      maxTokens: n.maxTokens,
      streaming: !1,
      modelKwargs: s
    });
  }
  /**
   * Switch to a different model
   */
  setModel(e) {
    const t = zn.find((n) => n.id === e);
    if (!t) {
      console.error(`[AgentService] Unknown model: ${e}`);
      return;
    }
    this.currentModelId = e, this.model = this.createModel(e), console.log(`[AgentService] Switched to model: ${t.name}`);
  }
  /**
   * Get current model ID
   */
  getCurrentModelId() {
    return this.currentModelId;
  }
  /**
   * Get available models
   */
  static getAvailableModels() {
    return zn;
  }
  /**
   * Reset conversation history - call this when starting a new session
   */
  resetConversation() {
    this.conversationHistory = [], console.log("[AgentService] Conversation history cleared");
  }
  /**
   * Trim conversation history if it exceeds the max limit
   * Keeps the most recent messages
   */
  trimConversationHistory() {
    if (this.conversationHistory.length > zs.MAX_HISTORY_MESSAGES) {
      const e = this.conversationHistory.length - zs.MAX_HISTORY_MESSAGES;
      this.conversationHistory = this.conversationHistory.slice(e), console.log(`[AgentService] Trimmed ${e} old messages from conversation history`);
    }
  }
  setStepHandler(e) {
    this.onStep = e;
  }
  clearStepHandler() {
    this.onStep = void 0;
  }
  emitStep(e, t, n) {
    if (this.onStep) {
      const s = ft.getRunId() ?? void 0, a = {
        ...n ?? {},
        ts: (/* @__PURE__ */ new Date()).toISOString(),
        runId: s
      };
      this.onStep({ type: e, content: t, metadata: a });
    }
  }
  async chat(e, t) {
    return this.agentMode === "chat" ? this.chatOnly(e) : this.agentMode === "read" ? this.readOnly(e, t) : this.doMode(e, t);
  }
  /**
   * Chat-only mode: Regular chatbot, no browser access or tools
   */
  async chatOnly(e) {
    const t = this.redactSecrets(e), n = new ct("You are a helpful assistant. You are in CHAT mode - you cannot access the browser or use any tools. Just have a helpful conversation with the user. Respond naturally without JSON formatting.");
    this.conversationHistory.push(new zt(t)), this.trimConversationHistory();
    try {
      const s = await this.model.invoke([n, ...this.conversationHistory]), a = typeof s.content == "string" ? s.content : JSON.stringify(s.content);
      return this.conversationHistory.push(new Fe(a)), this.trimConversationHistory(), a;
    } catch (s) {
      return `Error: ${s.message}`;
    }
  }
  /**
   * Read-only mode: Can see browser state but cannot take actions
   */
  async readOnly(e, t) {
    const n = this.redactSecrets(e);
    let s = t || "Current browser state: No context provided";
    s = this.redactSecrets(s);
    const a = new ct(`You are a helpful assistant integrated into a browser. You are in READ mode - you can see what the user sees on their browser, but you CANNOT take any actions or use any tools.

Current browser state:
${s}

You can answer questions about what's on the page, explain content, summarize information, or help the user understand what they're looking at. But you cannot click, type, navigate, or modify anything. Respond naturally without JSON formatting.`);
    this.conversationHistory.push(new zt(n)), this.trimConversationHistory();
    try {
      const i = await this.model.invoke([a, ...this.conversationHistory]), o = typeof i.content == "string" ? i.content : JSON.stringify(i.content);
      return this.conversationHistory.push(new Fe(o)), this.trimConversationHistory(), o;
    } catch (i) {
      return `Error: ${i.message}`;
    }
  }
  /**
   * Do mode: Full agentic capabilities with tools
   */
  async doMode(e, t) {
    var o;
    const n = we.toLangChainTools();
    let s = !1, a = 0, i = null;
    try {
      let c = t || "Current browser state: No context provided";
      c = this.redactSecrets(c);
      const u = this.redactSecrets(e);
      this.systemPrompt = new ct(`You are a helpful enterprise assistant integrated into a browser. 
        
        You have access to the following tools:
        ${n.map((y) => {
        var g;
        return `- ${y.name}: ${y.description} (Args: ${JSON.stringify(((g = y.schema) == null ? void 0 : g.shape) || {})})`;
      }).join(`
`)}

        CRITICAL INSTRUCTIONS:
        1. You are an agent that MUST use tools to interact with the world.
        2. To call a tool, you MUST output a VALID JSON object in the following format:
           {
             "tool": "tool_name",
             "args": { "arg_name": "value" }
           }
        3. Do not output any other text when calling a tool. Just the JSON.
        4. If you have completed the task or need to ask the user something, output a JSON with tool "final_response":
           {
             "tool": "final_response",
             "args": { "message": "Your text here" }
           }

        PREFERRED WORKFLOW (SPEED & RELIABILITY):
        1. OBSERVE: If the page state is unknown, call 'browser_observe'.
        2. PLAN: For multi-step tasks (especially Mock SaaS), ALWAYS output ONE full 'browser_execute_plan' (include a final wait step for verification). This is significantly faster and more reliable than individual tool calls.
        3. EXECUTE: Submit the plan once. Avoid calling browser_click/browser_type in separate turns for multi-step tasks.

        CONVERSATION CONTEXT:
        - You have memory of the entire conversation. Use previous messages to understand context.
        - If the user refers to "it", "this page", "here", etc., use the conversation history and current browser state to understand what they mean.
        - ${c}

        JSON SAFETY:
        - Tool JSON must be valid JSON. If you include a CSS selector string, it MUST NOT contain unescaped double quotes (").
        - Prefer selectors returned by browser_observe like [data-testid=jira-create-button] that do not require quotes.
        - In final_response.message, do not include unescaped double quotes ("). If you need quotes, use single quotes inside the message, e.g. 'fix alignment'.

        VERIFICATION RULE (IMPORTANT):
        - Verify ONCE. Do not verify multiple times.
        - If you included a "wait" step in your execution plan and it passed, THAT IS YOUR VERIFICATION. You do not need to verify again.
        - If you must verify manually, use "browser_wait_for_text".
        - DO NOT guess container selectors (e.g. do not invent [data-testid=jira-issue-list]). Only use selectors you saw in "browser_observe" or the source code.
        
        WHITE-BOX MOCK SaaS MODE (mock-saas):
        - When the task targets the local Mock SaaS (e.g. URLs like http://localhost:3000/* or apps like Jira/Confluence/Trello/AeroCore in this repo), you MUST operate in this order:

        PHASE 0: RECALL (Check Memory)
        - Call "knowledge_search_skill" with the user's request and current domain.
        - If a skill is found, verify it briefly, then execute it using "browser_execute_plan".

        PHASE 1: PLAN (Read Code) - if no skill found
        - DO NOT touch the browser yet.
        - Use "code_search" or "code_list_files" to find the relevant React components.
        - Read "mock-saas/src/App.tsx" to find the correct route.
        - NOTE: AeroCore apps are under "/aerocore/*" (e.g. /aerocore/admin, /aerocore/dispatch).
        - Read the page/component source code (e.g. "JiraPage.tsx" or "AdminPage.tsx") to find:
          * Stable "data-testid" selectors.
          * WARNING: If a selector is inside a loop (e.g. [data-testid=jira-create-issue-button] inside columns), IT IS NOT UNIQUE. browser_click will refuse ambiguous matches. Prefer browser_click_text or disambiguate via withinSelector/matchText/index.
          * Validation logic (e.g. allowed values for priority).
          
        PHASE 2: EXECUTE (Run Plan)
        - Call "browser_execute_plan" with the full sequence.
        - Include a "wait" step at the end of your plan to verify the outcome automatically (e.g. wait for the text you just created).
        - Example plan:
          [
            { "action": "navigate", "url": "http://localhost:3000/jira" },
            { "action": "click", "selector": "[data-testid=jira-create-button]" },
            { "action": "type", "selector": "[data-testid=jira-summary-input]", "value": "Bug Report" },
            { "action": "select", "selector": "[data-testid=jira-status-select]", "value": "To Do" },
            { "action": "click", "selector": "[data-testid=jira-submit-create]" },
            { "action": "wait", "text": "Bug Report" }
          ]

        PHASE 3: LEARN (Save Memory)
        - If the execution (and its built-in wait) succeeded, call "knowledge_save_skill" IMMEDIATELY.
        - Then IMMEDIATELY send "final_response". Do not perform extra verifications.
        
        BROWSER AUTOMATION STRATEGY:
        - You have no eyes. You must use "browser_observe" to see the page.
        - For EXTERNAL WEBSITES (not localhost): Use the current browser state above. If you're already on a site (e.g. youtube.com), interact with it directly using browser_type, browser_click, browser_observe. Do NOT navigate away unless asked.
        - Step 1: Check current browser state. If already on the target site, skip navigation.
        - Step 2: Use "browser_observe" with scope="main" to see relevant page content.
        - Step 3: Prefer "browser_click_text" when you can describe a link/button by visible text (more robust than guessing aria-label/href).
        - Step 4: Use selectors returned by "browser_observe" (which are JSON-safe) for "browser_click", "browser_type", "browser_select". If browser_click says the selector is ambiguous, disambiguate via withinSelector/matchText/index or switch to browser_click_text.
        - Step 5: Verify outcomes using "browser_wait_for_text", "browser_wait_for_text_in", or "browser_extract_main_text".

        INFORMATION EXTRACTION (CRITICAL):
        - If the user asks you to "tell me", "find", "what is", "show me", "get", "read", or asks a question about page content, you MUST:
          1. Navigate to the page (if not already there)
          2. Call "browser_observe" to see the page content
          3. Read the "mainTextSnippet" from the observation result
          4. Extract the requested information from the text
          5. Return the answer in your final_response
        - DO NOT stop after just navigating. The user wants INFORMATION, not just navigation.
        - The "mainTextSnippet" in browser_observe output contains the visible text on the page - use it to answer questions.

        Example: Information Extraction
        User: "Go to wikipedia.org and tell me the featured article of the day"
        Assistant: { "tool": "browser_navigate", "args": { "url": "https://www.wikipedia.org" } }
        User: Tool Output: "Navigated to https://www.wikipedia.org"
        Assistant: { "tool": "browser_observe", "args": { "scope": "main" } }
        User: Tool Output: { "mainTextSnippet": "...Featured article: The Battle of...", ... }
        Assistant: { "tool": "final_response", "args": { "message": "The featured article of the day on Wikipedia is 'The Battle of...'" } }

        Example: Simple Navigation
        User: "Go to Jira"
        Assistant: { "tool": "browser_navigate", "args": { "url": "http://localhost:3000/jira" } }
        User: Tool Output: "Navigated to..."
        Assistant: { "tool": "browser_observe", "args": { "scope": "main" } }
        User: Tool Output: { "interactiveElements": [...] }
        Assistant: { "tool": "final_response", "args": { "message": "I have navigated to Jira." } }
        `);
      const l = new zt(`[${c}]

User request: ${u}`);
      this.conversationHistory.push(l), this.trimConversationHistory();
      const d = [
        this.systemPrompt,
        ...this.conversationHistory
      ], h = zn.find((y) => y.id === this.currentModelId), p = (h == null ? void 0 : h.supportsThinking) || (h == null ? void 0 : h.id) === "qwen3-235b" ? 9e4 : 45e3;
      for (let y = 0; y < 15; y++) {
        const g = ft.getRunId() ?? void 0, S = Pe(), _ = Date.now();
        this.emitStep("thought", `Calling model ${this.currentModelId} (turn ${y + 1})`, {
          phase: "llm_start",
          llmCallId: S,
          turnIndex: y,
          modelId: this.currentModelId
        });
        try {
          await et.emit({
            eventId: Pe(),
            runId: g,
            ts: (/* @__PURE__ */ new Date()).toISOString(),
            type: "llm_call_start",
            name: "agent_turn",
            data: {
              llmCallId: S,
              turnIndex: y,
              modelId: this.currentModelId,
              modelName: h == null ? void 0 : h.modelName,
              timeoutMs: p
            }
          });
        } catch {
        }
        const w = new Promise(
          (z, Se) => setTimeout(() => Se(new Error(`LLM call timed out after ${p / 1e3} seconds`)), p)
        );
        let T, x = null, A = 0;
        try {
          x = setInterval(() => {
            A += 1;
            const z = Date.now() - _;
            A <= 6 && this.emitStep("thought", `Still thinking... (${Math.round(z / 1e3)}s)`, {
              phase: "llm_wait",
              llmCallId: S,
              turnIndex: y,
              modelId: this.currentModelId,
              elapsedMs: z
            });
          }, 5e3), T = await Promise.race([
            this.model.invoke(d),
            w
          ]);
        } catch (z) {
          x && clearInterval(x);
          const Se = Date.now() - _;
          this.emitStep("observation", `LLM timed out after ${Math.round(Se)}ms`, {
            phase: "llm_end",
            ok: !1,
            llmCallId: S,
            turnIndex: y,
            modelId: this.currentModelId,
            durationMs: Se,
            errorMessage: String((z == null ? void 0 : z.message) ?? z)
          });
          try {
            await et.emit({
              eventId: Pe(),
              runId: g,
              ts: (/* @__PURE__ */ new Date()).toISOString(),
              type: "llm_call_end",
              name: "agent_turn",
              data: {
                llmCallId: S,
                turnIndex: y,
                ok: !1,
                durationMs: Se,
                errorMessage: String((z == null ? void 0 : z.message) ?? z)
              }
            });
          } catch {
          }
          return this.emitStep("observation", "Request timed out. Try a simpler request or switch to a faster model."), "The request timed out. Try breaking it into smaller steps or use a faster model.";
        }
        x && clearInterval(x);
        try {
          const z = Date.now() - _;
          this.emitStep("thought", `Model responded in ${Math.round(z)}ms`, {
            phase: "llm_end",
            ok: !0,
            llmCallId: S,
            turnIndex: y,
            modelId: this.currentModelId,
            durationMs: z
          }), await et.emit({
            eventId: Pe(),
            runId: g,
            ts: (/* @__PURE__ */ new Date()).toISOString(),
            type: "llm_call_end",
            name: "agent_turn",
            data: {
              llmCallId: S,
              turnIndex: y,
              ok: !0,
              durationMs: z,
              responseLength: String((T == null ? void 0 : T.content) ?? "").length
            }
          });
        } catch {
        }
        const R = T.content;
        console.log(`[Agent Turn ${y}] Raw Response:`, this.redactSecrets(R));
        const E = R.indexOf("{");
        if (E > 10) {
          const Se = R.slice(0, E).trim().replace(/```json/g, "").replace(/```/g, "").trim();
          Se.length > 5 && this.emitStep("thought", Se);
        }
        const V = this.parseToolCall(R);
        if (V && V.tool, !V || typeof V.tool != "string" || !V.args || typeof V.args != "object") {
          if (a++, this.emitStep("observation", `Model returned invalid JSON (attempt ${a}/3).`), console.warn("Failed to parse JSON response:", R), d.push(new Fe(this.redactSecrets(String((T == null ? void 0 : T.content) ?? "")))), d.push(
            new ct(
              `Error: Output ONLY valid JSON. Format: {"tool":"tool_name","args":{...}}
To finish: {"tool":"final_response","args":{"message":"your response"}}`
            )
          ), i && a >= 2)
            return `Done: ${i}`;
          if (a >= 3)
            return "I had trouble completing this task. Try a simpler request or switch to a thinking model (DeepSeek, Qwen).";
          continue;
        }
        if (V.tool !== "final_response" && this.emitStep("thought", `Decided to call ${V.tool}`), V.tool === "final_response") {
          const z = V.args, Se = typeof (z == null ? void 0 : z.message) == "string" ? z.message : "";
          if (!Se) {
            d.push(T), d.push(
              new ct(
                'Error: final_response must include args.message as a string. Example: {"tool":"final_response","args":{"message":"..."}}'
              )
            );
            continue;
          }
          if (s) {
            const Oe = d.slice(-8).map((U) => U.content ?? "").join(`
`), Z = /\b(created|created a|successfully|done|completed)\b/i.test(Se), D = /\bFound text:\b|\b\"found\":\s*[1-9]\d*\b/i.test(Oe) || /\bSaved plan for\b/i.test(Oe);
            if (Z && !D) {
              d.push(T), d.push(
                new ct(
                  "You must verify UI changes before claiming success. Use browser_wait_for_text or browser_find_text for the expected item title, then respond."
                )
              );
              continue;
            }
          }
          return this.conversationHistory.push(new Fe(this.redactSecrets(R))), Se;
        }
        const ne = n.find((z) => z.name === V.tool);
        if (ne) {
          console.log(`Executing tool: ${ne.name} with args:`, V.args);
          const z = Pe(), Se = Date.now();
          this.emitStep("action", `Executing ${ne.name}`, {
            tool: ne.name,
            args: V.args,
            toolCallId: z,
            phase: "tool_start"
          });
          try {
            const Oe = await ne.invoke(V.args), Z = Date.now() - Se;
            this.emitStep("observation", `Tool Output: ${Oe}`, {
              tool: ne.name,
              result: Oe,
              toolCallId: z,
              phase: "tool_end",
              durationMs: Z
            }), ne.name.startsWith("browser_") && (s = !0), (ne.name === "browser_wait_for_text" || ne.name === "browser_wait_for_text_in") && typeof Oe == "string" && Oe.startsWith("Found text") && (i = Oe);
            const D = String(Oe), U = V.tool;
            if (U === "browser_execute_plan" && D.startsWith("Plan completed successfully.")) {
              const M = "Completed the requested steps and verified the outcome.";
              return this.conversationHistory.push(
                new Fe(
                  JSON.stringify({ tool: "final_response", args: { message: M } })
                )
              ), M;
            }
            if (U === "browser_scroll" && !D.toLowerCase().includes("error")) {
              const M = "Scrolled the page.";
              return this.conversationHistory.push(new Fe(JSON.stringify({ tool: "final_response", args: { message: M } }))), M;
            }
            if (U === "browser_go_back" && !D.toLowerCase().includes("error")) {
              const M = "Went back to the previous page.";
              return this.conversationHistory.push(new Fe(JSON.stringify({ tool: "final_response", args: { message: M } }))), M;
            }
            if (U === "browser_go_forward" && !D.toLowerCase().includes("error")) {
              const M = "Went forward to the next page.";
              return this.conversationHistory.push(new Fe(JSON.stringify({ tool: "final_response", args: { message: M } }))), M;
            }
            if (U === "browser_reload" && !D.toLowerCase().includes("error")) {
              const M = "Reloaded the page.";
              return this.conversationHistory.push(new Fe(JSON.stringify({ tool: "final_response", args: { message: M } }))), M;
            }
            if (U === "browser_press_key" && !D.toLowerCase().includes("error")) {
              const q = `Pressed ${((o = V.args) == null ? void 0 : o.key) || "the key"}.`;
              return this.conversationHistory.push(new Fe(JSON.stringify({ tool: "final_response", args: { message: q } }))), q;
            }
            if (U === "browser_clear" && !D.toLowerCase().includes("error")) {
              const M = "Cleared the input field.";
              return this.conversationHistory.push(new Fe(JSON.stringify({ tool: "final_response", args: { message: M } }))), M;
            }
            const O = this.redactSecrets(R), P = this.redactSecrets(String(Oe ?? "")), N = new Fe(O), j = new ct(`Tool '${V.tool}' Output:
${P}`);
            d.push(N), d.push(j), this.conversationHistory.push(N), this.conversationHistory.push(j);
          } catch (Oe) {
            console.error(`Tool execution failed: ${Oe}`);
            const Z = Date.now() - Se;
            this.emitStep("observation", `Tool Execution Error: ${Oe.message}`, {
              tool: ne.name,
              toolCallId: z,
              phase: "tool_end",
              ok: !1,
              durationMs: Z,
              errorMessage: String((Oe == null ? void 0 : Oe.message) ?? Oe)
            });
            const D = new Fe(this.redactSecrets(R)), U = new ct(`Tool Execution Error: ${Oe.message}`);
            d.push(D), d.push(U), this.conversationHistory.push(D), this.conversationHistory.push(U);
          }
        } else {
          console.error(`Tool not found: ${V.tool}`);
          const z = new Fe(R), Se = new ct(`Error: Tool '${V.tool}' not found. Available tools: ${n.map((Oe) => Oe.name).join(", ")}`);
          d.push(z), d.push(Se), this.conversationHistory.push(z), this.conversationHistory.push(Se);
        }
      }
      return "I could not complete the task within the maximum number of steps. Try simplifying the request or check the browser is in the expected state.";
    } catch (c) {
      return console.error("Error in AgentService chat:", c), "Sorry, I encountered an error while processing your request.";
    }
  }
  // Future: Implement streaming support
  async *streamChat(e) {
    const t = await this.model.stream([
      new ct("You are a helpful enterprise assistant integrated into a browser."),
      new zt(e)
    ]);
    for await (const n of t)
      yield n.content;
  }
};
// Limit conversation history to prevent unbounded memory growth
// Each turn can have ~2-4 messages (user, AI, tool output, etc.)
// 50 messages â‰ˆ 12-25 turns of context
v(zs, "MAX_HISTORY_MESSAGES", 50);
let Su = zs;
const Ot = new Su();
class G1 {
  constructor() {
    v(this, "tabIdToWebContentsId", /* @__PURE__ */ new Map());
    v(this, "activeTabId", null);
  }
  registerWebview(e, t) {
    !e || !Number.isFinite(t) || this.tabIdToWebContentsId.set(e, {
      tabId: e,
      webContentsId: t,
      lastSeenAt: Date.now()
    });
  }
  setActiveTab(e) {
    this.activeTabId = e;
  }
  getActiveWebContents() {
    const e = this.activeTabId;
    if (e) {
      const s = this.tabIdToWebContentsId.get(e);
      if (s) {
        const a = Bs.fromId(s.webContentsId);
        if (a && !a.isDestroyed()) return a;
      }
    }
    const n = Bs.getAllWebContents().filter((s) => !s.isDestroyed()).filter((s) => s.getType() === "webview").filter((s) => {
      const a = s.getURL() || "";
      return !a.startsWith("devtools://") && !a.includes("localhost:5173") && !a.includes("localhost:5174") && !a.endsWith("index.html");
    });
    if (n.length === 0)
      throw new Error(
        "No active webview found. Open a tab and ensure the BrowserView is loaded."
      );
    return n[n.length - 1];
  }
}
const Cs = new G1();
class K1 {
  constructor() {
    v(this, "mockSaasRoutesCache", null);
    v(this, "observeCache", /* @__PURE__ */ new Map());
    v(this, "attachedWebContentsIds", /* @__PURE__ */ new Set());
    this.setupWebContentsInvalidation(), this.registerTools();
  }
  setupWebContentsInvalidation() {
    try {
      for (const e of Bs.getAllWebContents())
        this.attachWebContentsListeners(e);
    } catch {
    }
    try {
      Bt.on("web-contents-created", (e, t) => {
        this.attachWebContentsListeners(t);
      });
    } catch {
    }
  }
  attachWebContentsListeners(e) {
    try {
      if (!e || e.isDestroyed() || this.attachedWebContentsIds.has(e.id)) return;
      this.attachedWebContentsIds.add(e.id);
      const t = () => this.invalidateCache(e.id);
      e.on("did-start-navigation", t), e.on("did-navigate", t), e.on("did-navigate-in-page", t), e.on("dom-ready", t), e.on("destroyed", () => {
        this.invalidateCache(e.id), this.attachedWebContentsIds.delete(e.id);
      });
    } catch {
    }
  }
  invalidateCache(e) {
    this.observeCache.delete(e);
  }
  async getDomVersion(e) {
    try {
      const t = await e.executeJavaScript(
        `(() => {
          const w = window;
          if (typeof w.__enterprise_observe_dom_version !== 'number') {
            w.__enterprise_observe_dom_version = 0;
          }
          if (!w.__enterprise_observe_dom_observer) {
            const bump = () => { w.__enterprise_observe_dom_version += 1; };
            const obs = new MutationObserver(() => bump());
            const root = document.documentElement || document.body;
            if (root) {
              obs.observe(root, { subtree: true, childList: true, attributes: true, characterData: true });
            }
            w.__enterprise_observe_dom_observer = obs;
          }
          return w.__enterprise_observe_dom_version;
        })()`,
        !0
      );
      return Number(t) || 0;
    } catch {
      return 0;
    }
  }
  async delay(e) {
    await new Promise((t) => setTimeout(t, e));
  }
  async getMockSaasRoutes() {
    const e = Date.now();
    if (this.mockSaasRoutesCache && e - this.mockSaasRoutesCache.loadedAt < 1e4)
      return this.mockSaasRoutesCache.routes;
    const t = /* @__PURE__ */ new Set(["/", "/jira", "/confluence", "/trello"]), n = [
      ke.resolve(process.cwd(), "mock-saas", "src", "App.tsx"),
      ke.resolve(process.cwd(), "..", "mock-saas", "src", "App.tsx"),
      ke.resolve(process.cwd(), "..", "..", "mock-saas", "src", "App.tsx")
    ];
    let s = null;
    for (const a of n)
      try {
        if ((await Ke.stat(a)).isFile()) {
          s = a;
          break;
        }
      } catch {
      }
    if (!s)
      return this.mockSaasRoutesCache = { loadedAt: e, routes: t }, t;
    try {
      const a = await Ke.readFile(s, "utf8"), i = /* @__PURE__ */ new Set(), o = /<Route\s+(?:path|element)\s*=\s*["']([^"']+)["']/g;
      let c;
      for (; c = o.exec(a); ) {
        let l = c[1];
        l.endsWith("/*") && (l = l.replace("/*", ""), l === "/aerocore" && (i.add("/aerocore/admin"), i.add("/aerocore/dispatch"), i.add("/aerocore/fleet"), i.add("/aerocore/security"), i.add("/aerocore/hr"), i.add("/aerocore/cargo"), i.add("/aerocore/data"))), i.add(l);
      }
      const u = i.size > 0 ? i : t;
      return this.mockSaasRoutesCache = { loadedAt: e, routes: u }, u;
    } catch {
      return this.mockSaasRoutesCache = { loadedAt: e, routes: t }, t;
    }
  }
  async getTarget() {
    return Cs.getActiveWebContents();
  }
  async waitForSelector(e, t, n = 5e3) {
    const s = Date.now();
    for (; Date.now() - s < n; ) {
      if (await e.executeJavaScript(
        `Boolean(document.querySelector(${JSON.stringify(t)}))`,
        !0
      )) return;
      await this.delay(100);
    }
    throw new Error(`Timeout waiting for selector: ${t}`);
  }
  async querySelectorCount(e, t) {
    const n = await e.executeJavaScript(
      `document.querySelectorAll(${JSON.stringify(t)}).length`,
      !0
    );
    return Number(n) || 0;
  }
  registerTools() {
    const e = Ee({
      scope: Gn(["main", "document"]).optional().describe("Where to look for elements (default: main)"),
      maxElements: Qe().optional().describe("Max interactive elements to return (default: 80)"),
      forceRefresh: Bi().optional().describe("Ignore cache and force a fresh observation")
    }), t = {
      name: "browser_observe",
      description: "Analyze the current page URL/title and return visible interactive elements. Defaults to main content to avoid header/nav noise. Caches results for performance; use forceRefresh to bypass.",
      schema: e,
      execute: async (O) => {
        const { scope: P, maxElements: N, forceRefresh: j } = e.parse(O ?? {});
        try {
          const M = await this.getTarget(), q = M.id, se = M.getURL(), Te = JSON.stringify({ scope: P ?? "main", maxElements: N ?? 80 }), ae = await this.getDomVersion(M);
          if (!j) {
            const me = this.observeCache.get(q);
            if (me && me.url === se && me.argsKey === Te && me.domVersion === ae && Date.now() - me.timestamp < 5e3) {
              const Me = Date.now() - me.timestamp;
              return JSON.stringify(
                {
                  ...me.data,
                  _meta: {
                    cached: !0,
                    timestamp: me.timestamp,
                    ageMs: Me,
                    url: me.url,
                    title: me.title,
                    domVersion: me.domVersion,
                    args: { scope: P ?? "main", maxElements: N ?? 80 }
                  }
                },
                null,
                2
              );
            }
          }
          const b = se, m = await M.executeJavaScript("document.title", !0), $ = await M.executeJavaScript(
            `(() => {
                const escapeForSingleQuotes = (value) => {
                  if (typeof value !== 'string') return '';
                  return value.replace(/\\\\/g, '\\\\\\\\').replace(/'/g, "\\\\'");
                };

                const attrSelectorValue = (value) => {
                  if (typeof value !== 'string') return "''";
                  // If value is simple, avoid quotes entirely (JSON-safe and CSS-valid).
                  if (/^[a-zA-Z0-9_-]+$/.test(value)) return value;
                  return "'" + escapeForSingleQuotes(value) + "'";
                };

                const isVisible = (el) => {
                  if (!el || el.nodeType !== 1) return false;
                  const style = window.getComputedStyle(el);
                  if (!style) return false;
                  if (style.display === 'none' || style.visibility === 'hidden' || style.opacity === '0') return false;
                  if (style.pointerEvents === 'none') return false;
                  const rects = el.getClientRects();
                  if (!rects || rects.length === 0) return false;
                  const rect = el.getBoundingClientRect();
                  if (rect.width < 2 || rect.height < 2) return false;
                  // Prefer in-viewport elements (allow small offscreen buffer)
                  const vw = window.innerWidth || 0;
                  const vh = window.innerHeight || 0;
                  const buffer = 40;
                  if (rect.bottom < -buffer || rect.top > vh + buffer) return false;
                  if (rect.right < -buffer || rect.left > vw + buffer) return false;
                  return true;
                };

                const cssPath = (el) => {
                  if (!el || el.nodeType !== 1) return '';
                  const parts = [];
                  let cur = el;
                  let guard = 0;
                  while (cur && cur.nodeType === 1 && guard++ < 7) {
                    const tag = cur.tagName.toLowerCase();
                    if (cur.id) {
                      parts.unshift(tag + '#' + CSS.escape(cur.id));
                      break;
                    }

                    let part = tag;
                    const testId =
                      cur.getAttribute &&
                      (cur.getAttribute('data-testid') || cur.getAttribute('data-test-id'));
                    if (testId) {
                      part += '[data-testid=' + attrSelectorValue(testId) + ']';
                      parts.unshift(part);
                      break;
                    }

                    const classList = cur.classList ? Array.from(cur.classList) : [];
                    if (classList.length) {
                      part += '.' + classList.slice(0, 2).map((c) => CSS.escape(c)).join('.');
                    }

                    const parent = cur.parentElement;
                    if (parent) {
                      const sameTagSiblings = Array.from(parent.children).filter(
                        (sib) => sib.tagName === cur.tagName
                      );
                      if (sameTagSiblings.length > 1) {
                        part += ':nth-of-type(' + (sameTagSiblings.indexOf(cur) + 1) + ')';
                      }
                    }

                    parts.unshift(part);
                    cur = cur.parentElement;
                  }
                  return parts.join(' > ');
                };

                const bestSelector = (el) => {
                  if (!el || el.nodeType !== 1) return '';
                  if (el.id) return '#' + el.id;
                  const testId = el.getAttribute && (el.getAttribute('data-testid') || el.getAttribute('data-test-id'));
                  if (testId) return '[data-testid=' + attrSelectorValue(testId) + ']';
                  const name = el.getAttribute && el.getAttribute('name');
                  if (name) return el.tagName.toLowerCase() + '[name=' + attrSelectorValue(name) + ']';
                  const ariaLabel = el.getAttribute && el.getAttribute('aria-label');
                  if (ariaLabel) return el.tagName.toLowerCase() + '[aria-label=' + attrSelectorValue(ariaLabel) + ']';
                  const placeholder = el.getAttribute && el.getAttribute('placeholder');
                  if (placeholder) return el.tagName.toLowerCase() + '[placeholder=' + attrSelectorValue(placeholder) + ']';
                  if (el.className && typeof el.className === 'string') {
                    const classes = el.className.split(' ').filter((c) => c.trim()).slice(0, 3).join('.');
                    if (classes) return el.tagName.toLowerCase() + '.' + classes;
                  }
                  const path = cssPath(el);
                  return path || el.tagName.toLowerCase();
                };

                const requestedScope = ${JSON.stringify(P ?? "main")};
                const root =
                  requestedScope === 'document'
                    ? document
                    : (document.querySelector('main, [role="main"]') || document.body);

                const withinRoot = (el) => {
                  try { return root && root !== document ? root.contains(el) : true; } catch { return true; }
                };

                const selectorList = 'button, a, input, textarea, select, summary, [role="button"], [role="link"], [role="tab"]';
                const candidates = Array.from((root && root !== document ? root : document).querySelectorAll(selectorList));

                // Visible + within root + de-duplicate by selector+text+tag.
                const seen = new Set();
                const out = [];
                const limit = Math.max(1, Math.min(200, ${JSON.stringify(N ?? 80)}));

                for (const el of candidates) {
                  if (!withinRoot(el)) continue;
                  if (!isVisible(el)) continue;

                  const tag = el.tagName.toLowerCase();
                  const text = (el.textContent || '').substring(0, 80).trim().replace(/\\s+/g, ' ');
                  const placeholder = el.getAttribute('placeholder') || '';
                  const type = el.getAttribute('type') || '';
                  const role = el.getAttribute('role') || '';
                  const name = el.getAttribute('name') || '';
                  const disabled = 'disabled' in el ? Boolean(el.disabled) : el.getAttribute('aria-disabled') === 'true';
                  const selector = bestSelector(el);
                  const matches = selector ? document.querySelectorAll(selector).length : 0;
                  const value = 'value' in el ? String(el.value ?? '') : '';
                  const href = tag === 'a' ? (el.getAttribute('href') || '') : '';
                  const ariaLabel = el.getAttribute('aria-label') || '';

                  const key = [tag, selector, text].join('|');
                  if (seen.has(key)) continue;
                  seen.add(key);

                  out.push({ tag, text, placeholder, type, role, name, disabled, value, href, ariaLabel, selector, matches });
                  if (out.length >= limit) break;
                }

                // Provide a small main-text snippet so the agent can orient itself.
                const mainText = (() => {
                  const node =
                    (document.querySelector('main, [role="main"]') || document.body);
                  const raw = (node?.innerText || '').replace(/\\s+/g, ' ').trim();
                  return raw.slice(0, 1200);
                })();

                return { interactiveElements: out, mainTextSnippet: mainText, scope: requestedScope };
              })()`,
            !0
          ), I = { url: b, title: m, ...$ }, de = Date.now();
          return this.observeCache.set(q, {
            url: b,
            title: String(m ?? ""),
            argsKey: Te,
            data: I,
            timestamp: de,
            domVersion: ae
          }), JSON.stringify(
            {
              ...I,
              _meta: {
                cached: !1,
                timestamp: de,
                ageMs: 0,
                url: b,
                title: String(m ?? ""),
                domVersion: ae,
                args: { scope: P ?? "main", maxElements: N ?? 80 }
              }
            },
            null,
            2
          );
        } catch (M) {
          return `Failed to observe page: ${M.message}`;
        }
      }
    }, n = {
      name: "browser_go_back",
      description: "Navigate back in the browser history.",
      schema: Ee({}),
      execute: async () => {
        const O = await this.getTarget();
        return O.canGoBack() ? (O.goBack(), this.invalidateCache(O.id), await this.delay(500), "Navigated back") : "Cannot go back (no history)";
      }
    }, s = {
      name: "browser_go_forward",
      description: "Navigate forward in the browser history.",
      schema: Ee({}),
      execute: async () => {
        const O = await this.getTarget();
        return O.canGoForward() ? (O.goForward(), this.invalidateCache(O.id), await this.delay(500), "Navigated forward") : "Cannot go forward (no history)";
      }
    }, a = {
      name: "browser_reload",
      description: "Reload the current page.",
      schema: Ee({}),
      execute: async () => {
        const O = await this.getTarget();
        return O.reload(), this.invalidateCache(O.id), await this.delay(1e3), "Page reloading triggered";
      }
    }, i = {
      name: "browser_navigate",
      description: "Navigate the browser to a specific URL.",
      schema: Ee({
        url: G().describe("The URL to navigate to (must include http/https)"),
        waitForSelector: G().optional().describe("Optional selector to wait for after navigation"),
        waitForText: G().optional().describe("Optional text to wait for after navigation"),
        timeoutMs: Qe().optional().describe("Timeout in ms for optional waits (default 8000)")
      }),
      execute: async ({
        url: O,
        waitForSelector: P,
        waitForText: N,
        timeoutMs: j
      }) => {
        try {
          let M;
          try {
            M = await this.getTarget();
          } catch {
            const { BrowserWindow: Te } = await import("electron"), ae = Te.getAllWindows()[0];
            if (ae) {
              ae.webContents.send("browser:navigate-to", O), await this.delay(1500);
              try {
                M = await this.getTarget();
              } catch {
                return `Navigated to ${O} (webview initializing)`;
              }
            } else
              return "Failed to navigate: No browser window found";
          }
          try {
            const se = new _y(O);
            if ((se.hostname === "localhost" || se.hostname === "127.0.0.1") && se.port === "3000") {
              const Te = await this.getMockSaasRoutes(), ae = se.pathname.replace(/\/+$/, "") || "/";
              if (!Te.has(ae))
                return `Failed to navigate: Unknown mock-saas route ${ae}. Known routes: ${Array.from(
                  Te
                ).sort().join(", ")}. Navigate to /jira and use the Create button (it is a modal, not a /create route).`;
            }
          } catch {
          }
          this.invalidateCache(M.id);
          const q = j ?? 8e3;
          try {
            await M.loadURL(O);
          } catch (se) {
            if (!String((se == null ? void 0 : se.message) ?? se).includes("ERR_ABORTED") || (await this.delay(250), !M.getURL())) throw se;
          }
          if (P && await this.waitForSelector(M, P, q), N) {
            const se = Date.now(), Te = N.toLowerCase();
            for (; Date.now() - se < q && !await M.executeJavaScript(
              `document.body && document.body.innerText && document.body.innerText.toLowerCase().includes(${JSON.stringify(
                Te
              )})`,
              !0
            ); )
              await this.delay(150);
          }
          return `Navigated to ${M.getURL()}`;
        } catch (M) {
          return `Failed to navigate: ${M.message}`;
        }
      }
    }, c = {
      name: "browser_scroll",
      description: 'Scroll to an element or by an amount. Provide "selector" to scroll element into view, or "direction" (up/down/top/bottom) to scroll page.',
      schema: Ee({
        selector: G().optional().describe("CSS selector to scroll into view"),
        direction: Gn(["up", "down", "top", "bottom"]).optional().describe("Scroll direction if no selector provided"),
        amount: Qe().optional().describe("Pixels to scroll (default 500 for up/down)")
      }),
      execute: async ({ selector: O, direction: P, amount: N }) => {
        const j = await this.getTarget();
        if (this.invalidateCache(j.id), O)
          return await this.waitForSelector(j, O, 5e3), await j.executeJavaScript(
            `(() => {
               const el = document.querySelector(${JSON.stringify(O)});
               if (el) el.scrollIntoView({ behavior: 'smooth', block: 'center' });
             })()`,
            !0
          ), `Scrolled to element "${O}"`;
        if (P) {
          const M = N ?? 500;
          return await j.executeJavaScript(
            `(() => {
               const amt = ${JSON.stringify(M)};
               const dir = ${JSON.stringify(P)};
               if (dir === 'top') window.scrollTo({ top: 0, behavior: 'smooth' });
               else if (dir === 'bottom') window.scrollTo({ top: document.body.scrollHeight, behavior: 'smooth' });
               else if (dir === 'up') window.scrollBy({ top: -amt, behavior: 'smooth' });
               else window.scrollBy({ top: amt, behavior: 'smooth' });
             })()`,
            !0
          ), `Scrolled ${P}`;
        }
        return "No scroll action performed (provide selector or direction)";
      }
    }, l = {
      name: "browser_press_key",
      description: "Press a keyboard key (e.g. Enter, Escape, ArrowDown, Tab).",
      schema: Ee({
        key: G().describe("Key name (e.g. Enter, Escape, ArrowDown)")
      }),
      execute: async ({ key: O }) => {
        const P = await this.getTarget();
        try {
          return P.sendInputEvent({ type: "keyDown", keyCode: O }), P.sendInputEvent({ type: "keyUp", keyCode: O }), this.invalidateCache(P.id), `Pressed key: ${O}`;
        } catch (N) {
          return `Failed to press key: ${N.message}`;
        }
      }
    }, h = {
      name: "browser_wait_for_selector",
      description: "Wait for an element to appear in the DOM.",
      schema: Ee({
        selector: G().describe("CSS selector to wait for"),
        timeoutMs: Qe().optional().describe("Timeout in ms (default 5000)")
      }),
      execute: async ({ selector: O, timeoutMs: P }) => {
        const N = await this.getTarget(), j = P ?? 5e3;
        try {
          return await this.waitForSelector(N, O, j), `Element "${O}" appeared`;
        } catch {
          return `Timeout waiting for "${O}"`;
        }
      }
    }, p = {
      name: "browser_wait_for_url",
      description: "Wait for the URL to contain a specific string.",
      schema: Ee({
        urlPart: G().describe("Substring or full URL to wait for"),
        timeoutMs: Qe().optional().describe("Timeout in ms (default 5000)")
      }),
      execute: async ({ urlPart: O, timeoutMs: P }) => {
        const N = await this.getTarget(), j = P ?? 5e3, M = Date.now();
        for (; Date.now() - M < j; ) {
          if (N.getURL().includes(O)) return `URL matches "${O}"`;
          await this.delay(200);
        }
        return `Timeout waiting for URL to contain "${O}"`;
      }
    }, g = {
      name: "browser_focus",
      description: "Focus an element (e.g. input field).",
      schema: Ee({
        selector: G().describe("CSS selector to focus")
      }),
      execute: async ({ selector: O }) => {
        const P = await this.getTarget();
        return await this.waitForSelector(P, O, 5e3), await P.executeJavaScript(
          `(() => {
             const el = document.querySelector(${JSON.stringify(O)});
             if (el && typeof el.focus === 'function') el.focus();
           })()`,
          !0
        ), this.invalidateCache(P.id), `Focused "${O}"`;
      }
    }, _ = {
      name: "browser_clear",
      description: "Clear the value of an input or textarea.",
      schema: Ee({
        selector: G().describe("CSS selector of input to clear")
      }),
      execute: async ({ selector: O }) => {
        const P = await this.getTarget();
        return await this.waitForSelector(P, O, 5e3), await P.executeJavaScript(
          `(() => {
             const el = document.querySelector(${JSON.stringify(O)});
             if (!el) return { ok: false, error: 'Element not found' };
             const tag = (el.tagName || '').toLowerCase();
             const isEditable = tag === 'input' || tag === 'textarea' || Boolean(el.isContentEditable);
             if (!isEditable) return { ok: false, error: 'Element is not editable' };

             const setNativeValue = (node, value) => {
               const t = (node.tagName || '').toLowerCase();
               if (t === 'input') {
                 const setter = Object.getOwnPropertyDescriptor(window.HTMLInputElement.prototype, 'value')?.set;
                 if (setter) setter.call(node, value);
                 else node.value = value;
                 return;
               }
               if (t === 'textarea') {
                 const setter = Object.getOwnPropertyDescriptor(window.HTMLTextAreaElement.prototype, 'value')?.set;
                 if (setter) setter.call(node, value);
                 else node.value = value;
                 return;
               }
               if (node.isContentEditable) {
                 node.textContent = value;
                 return;
               }
               node.value = value;
             };

             setNativeValue(el, '');
             el.dispatchEvent(new InputEvent('input', { bubbles: true, data: '', inputType: 'deleteContentBackward' }));
             el.dispatchEvent(new Event('change', { bubbles: true }));
             return { ok: true };
           })()`,
          !0
        ), this.invalidateCache(P.id), `Cleared input "${O}"`;
      }
    }, T = {
      name: "browser_click",
      description: "Click an element on the current page. Safe + deterministic: if the selector matches multiple visible elements, you must disambiguate using withinSelector, matchText, or index (or use browser_click_text).",
      schema: Ee({
        selector: G().describe("CSS selector of the element to click"),
        withinSelector: G().optional().describe("Optional container selector to scope the search (must match exactly 1 element)"),
        index: Qe().optional().describe("Index of element if multiple match (0-based)"),
        matchText: G().optional().describe("Text content to match if multiple elements found")
      }),
      execute: async ({ selector: O, withinSelector: P, index: N, matchText: j }) => {
        try {
          const M = await this.getTarget();
          P && await this.waitForSelector(M, P, 5e3), await this.waitForSelector(M, O, 5e3);
          const q = await M.executeJavaScript(
            `(() => {
                // Helper to find elements including shadow DOM
                const findElements = (root, sel) => {
                  const results = [];
                  const queryDeep = (root) => {
                    const els = Array.from(root.querySelectorAll(sel));
                    results.push(...els);
                    if (root.shadowRoot) {
                      queryDeep(root.shadowRoot);
                    }
                    const walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT);
                    while (walker.nextNode()) {
                      const node = walker.currentNode;
                      if (node.shadowRoot) {
                        queryDeep(node.shadowRoot);
                      }
                    }
                  };
                  queryDeep(root);
                  return results;
                };

                const isVisible = (el) => {
                  if (!el || el.nodeType !== 1) return false;
                  const style = window.getComputedStyle(el);
                  if (!style) return false;
                  if (style.display === 'none' || style.visibility === 'hidden' || style.opacity === '0') return false;
                  if (style.pointerEvents === 'none') return false;
                  const rects = el.getClientRects();
                  if (!rects || rects.length === 0) return false;
                  const rect = el.getBoundingClientRect();
                  if (rect.width < 2 || rect.height < 2) return false;
                  const vw = window.innerWidth || 0;
                  const vh = window.innerHeight || 0;
                  const buffer = 40;
                  if (rect.bottom < -buffer || rect.top > vh + buffer) return false;
                  if (rect.right < -buffer || rect.left > vw + buffer) return false;
                  return true;
                };

                const describe = (el) => {
                  const tag = (el.tagName || '').toLowerCase();
                  const text = (el.innerText || el.textContent || '').replace(/s+/g, ' ').trim().slice(0, 80);
                  const ariaLabel = el.getAttribute?.('aria-label') || '';
                  const testId = el.getAttribute?.('data-testid') || el.getAttribute?.('data-test-id') || '';
                  const id = el.id || '';
                  return { tag, text, ariaLabel, testId, id };
                };

                const withinSel = ${JSON.stringify(P ?? "")};
                let root = document;
                if (withinSel) {
                  const roots = Array.from(document.querySelectorAll(withinSel)).filter(isVisible);
                  if (roots.length === 0) {
                    return { ok: false, error: 'Within selector not found (or not visible)', matches: 0 };
                  }
                  if (roots.length > 1) {
                    return { ok: false, error: 'Within selector is not unique', matches: roots.length, roots: roots.slice(0, 5).map(describe) };
                  }
                  root = roots[0];
                }

                let candidates = findElements(root, ${JSON.stringify(O)});
                candidates = candidates.filter(isVisible);
                
                // Filter by text if provided
                if (${JSON.stringify(j)}) {
                  const needle = ${JSON.stringify(j || "")}.toLowerCase();
                  candidates = candidates.filter(el => (el.innerText || '').toLowerCase().includes(needle));
                }

                if (candidates.length === 0) {
                  return { ok: false, error: 'Element not found (visible)', matches: 0 };
                }

                const idxProvided = ${JSON.stringify(N !== void 0)};
                const idx = ${JSON.stringify(N ?? 0)};

                if (candidates.length > 1 && !idxProvided) {
                  return {
                    ok: false,
                    error: 'Ambiguous selector (multiple visible matches)',
                    matches: candidates.length,
                    candidates: candidates.slice(0, 6).map(describe),
                  };
                }

                if (idx >= candidates.length) return { ok: false, error: 'Index out of bounds' };
                
                const el = candidates[idx];
                
                const isDisabled = ('disabled' in el && Boolean(el.disabled)) || el.getAttribute?.('aria-disabled') === 'true';
                if (isDisabled) return { ok: false, error: 'Element is disabled' };
                
                el.scrollIntoView({ block: 'center', inline: 'center' });
                
                // Try multiple click strategies
                try {
                  el.click(); // Standard click
                } catch (e) { console.error('Standard click failed', e); }
                
                // Dispatch events (crucial for React/Angular/Vue apps)
                const eventOpts = { bubbles: true, cancelable: true, view: window };
                el.dispatchEvent(new MouseEvent('mouseover', eventOpts));
                el.dispatchEvent(new MouseEvent('mousedown', eventOpts));
                el.dispatchEvent(new MouseEvent('mouseup', eventOpts));
                el.dispatchEvent(new MouseEvent('click', eventOpts));
                
                return { ok: true, matches: candidates.length, clicked: describe(el) };
              })()`,
            !0
          );
          if (!q.ok) {
            const se = `Refusing to click: ${q.error}. Selector=${JSON.stringify(
              O
            )}${P ? ` within=${JSON.stringify(P)}` : ""}.`;
            if (q.error === "Ambiguous selector (multiple visible matches)") {
              const Te = typeof q.matches == "number" ? q.matches : "multiple", ae = Array.isArray(q.candidates) ? q.candidates.map((b, m) => {
                const $ = [b.tag, b.testId ? `testId=${b.testId}` : "", b.id ? `id=${b.id}` : ""].filter(Boolean).join(" "), I = b.ariaLabel ? ` ariaLabel=${JSON.stringify(b.ariaLabel)}` : "", de = b.text ? ` text=${JSON.stringify(b.text)}` : "";
                return `#${m} ${$}${I}${de}`;
              }).join(`
`) : "";
              return `${se} Matched ${Te} visible elements.
Provide one of: {"index":0..}, {"matchText":"..."}, or {"withinSelector":"..."}.
Or prefer browser_click_text (more robust).
` + (ae ? `Candidates:
${ae}` : "");
            }
            if (q.error === "Within selector is not unique") {
              const Te = Array.isArray(q.roots) ? q.roots.map((ae, b) => {
                const m = [ae.tag, ae.testId ? `testId=${ae.testId}` : "", ae.id ? `id=${ae.id}` : ""].filter(Boolean).join(" "), $ = ae.text ? ` text=${JSON.stringify(ae.text)}` : "";
                return `#${b} ${m}${$}`;
              }).join(`
`) : "";
              return `${se} The withinSelector must match exactly 1 visible container.
` + (Te ? `Within candidates:
${Te}` : "");
            }
            return `${se} Try browser_click_text or refine your selector.`;
          }
          return this.invalidateCache(M.id), `Clicked element ${O}`;
        } catch (M) {
          return `Failed to click ${O}: ${M.message}`;
        }
      }
    }, x = {
      name: "browser_type",
      description: "Type text into an input field.",
      schema: Ee({
        selector: G().describe("CSS selector of the input"),
        text: G().describe("Text to type")
      }),
      execute: async ({ selector: O, text: P }) => {
        try {
          const N = await this.getTarget(), j = await this.querySelectorCount(N, O);
          if (j > 1)
            return `Refusing to type into non-unique selector (matches=${j}): ${O}`;
          await this.waitForSelector(N, O, 5e3);
          const M = await N.executeJavaScript(
            `(() => {
                const el = document.querySelector(${JSON.stringify(O)});
                if (!el) throw new Error('Element not found');
                const isDisabled = ('disabled' in el && Boolean(el.disabled)) || el.getAttribute?.('aria-disabled') === 'true';
                if (isDisabled) throw new Error('Element is disabled');
                el.scrollIntoView({ block: 'center', inline: 'center' });
                el.focus?.();

                const setNativeValue = (node, value) => {
                  const tag = node.tagName?.toLowerCase?.() || '';
                  if (tag === 'input') {
                    const setter = Object.getOwnPropertyDescriptor(window.HTMLInputElement.prototype, 'value')?.set;
                    if (setter) setter.call(node, value);
                    else node.value = value;
                    return;
                  }
                  if (tag === 'textarea') {
                    const setter = Object.getOwnPropertyDescriptor(window.HTMLTextAreaElement.prototype, 'value')?.set;
                    if (setter) setter.call(node, value);
                    else node.value = value;
                    return;
                  }
                  if (node.isContentEditable) {
                    node.textContent = value;
                    return;
                  }
                  node.value = value;
                };

                setNativeValue(el, '');
                el.dispatchEvent(new InputEvent('input', { bubbles: true, data: '', inputType: 'deleteContentBackward' }));
                setNativeValue(el, ${JSON.stringify(P)});
                el.dispatchEvent(new InputEvent('input', { bubbles: true, data: ${JSON.stringify(P)}, inputType: 'insertText' }));
                el.dispatchEvent(new Event('change', { bubbles: true }));
                return ('value' in el) ? String(el.value ?? '') : (el.textContent || '');
              })()`,
            !0
          );
          return this.invalidateCache(N.id), `Typed into ${O}. Current value: ${JSON.stringify(M)}`;
        } catch (N) {
          return `Failed to type into ${O}: ${N.message}`;
        }
      }
    }, A = {
      name: "browser_get_text",
      description: "Get the text content of an element.",
      schema: Ee({
        selector: G().describe("CSS selector")
      }),
      execute: async ({ selector: O }) => {
        try {
          const P = await this.getTarget();
          return await this.waitForSelector(P, O, 5e3), await P.executeJavaScript(
            `(() => {
                    const el = document.querySelector(${JSON.stringify(O)});
                    return el ? (el.textContent || '') : null;
                  })()`,
            !0
          ) || "Element found but has no text.";
        } catch (P) {
          return `Failed to get text: ${P.message}`;
        }
      }
    }, R = {
      name: "browser_screenshot",
      description: "Take a screenshot of the current page.",
      schema: Ee({
        path: G().optional().describe("Path to save the screenshot (optional)")
      }),
      execute: async ({ path: O }) => {
        const j = (await (await this.getTarget()).capturePage()).toPNG();
        if (O) {
          const M = ke.isAbsolute(O) ? O : ke.join(process.cwd(), O);
          return await Ke.writeFile(M, j), `Screenshot saved to ${M} (${j.length} bytes).`;
        }
        return `Screenshot taken (${j.length} bytes).`;
      }
    }, E = {
      name: "browser_find_text",
      description: "Find text on the current page and return matching elements/selectors.",
      schema: Ee({
        text: G().describe("Text to search for (case-insensitive substring match)"),
        maxMatches: Qe().optional().describe("Max results to return (default 10)")
      }),
      execute: async ({ text: O, maxMatches: P }) => {
        const j = await (await this.getTarget()).executeJavaScript(
          `(() => {
            const query = ${JSON.stringify(O)}.toLowerCase();
            const limit = Math.max(1, Math.min(50, ${JSON.stringify(P ?? 10)}));

            const escapeForSingleQuotes = (value) => {
              if (typeof value !== 'string') return '';
              return value.replace(/\\\\/g, '\\\\\\\\').replace(/'/g, "\\\\'");
            };

            const attrSelectorValue = (value) => {
              if (typeof value !== 'string') return "''";
              if (/^[a-zA-Z0-9_-]+$/.test(value)) return value;
              return "'" + escapeForSingleQuotes(value) + "'";
            };

            const selectorFor = (el) => {
              if (!el || el.nodeType !== 1) return '';
              if (el.id) return '#' + el.id;
              const testId = el.getAttribute && (el.getAttribute('data-testid') || el.getAttribute('data-test-id'));
              if (testId) return '[data-testid=' + attrSelectorValue(testId) + ']';
              const ariaLabel = el.getAttribute && el.getAttribute('aria-label');
              if (ariaLabel) return el.tagName.toLowerCase() + '[aria-label=' + attrSelectorValue(ariaLabel) + ']';
              const placeholder = el.getAttribute && el.getAttribute('placeholder');
              if (placeholder) return el.tagName.toLowerCase() + '[placeholder=' + attrSelectorValue(placeholder) + ']';
              return el.tagName.toLowerCase();
            };

            const out = [];
            const walker = document.createTreeWalker(document.body, NodeFilter.SHOW_TEXT);
            while (walker.nextNode()) {
              const node = walker.currentNode;
              const raw = node.nodeValue || '';
              const normalized = raw.replace(/\\s+/g, ' ').trim();
              if (!normalized) continue;
              if (!normalized.toLowerCase().includes(query)) continue;

              const parent = node.parentElement;
              if (!parent) continue;
              const el = parent.closest('button, a, [role="button"], [role="link"], input, textarea, select, div, span, p') || parent;
              const selector = selectorFor(el);
              out.push({
                selector,
                tag: el.tagName.toLowerCase(),
                text: (el.textContent || '').replace(/\\s+/g, ' ').trim().slice(0, 120),
              });
              if (out.length >= limit) break;
            }
            return out;
          })()`,
          !0
        );
        return JSON.stringify({ found: Array.isArray(j) ? j.length : 0, matches: j }, null, 2);
      }
    }, V = {
      name: "browser_wait_for_text",
      description: "Wait until text appears on the page (case-insensitive). Useful to verify actions succeeded.",
      schema: Ee({
        text: G().describe("Text to wait for"),
        timeoutMs: Qe().optional().describe("Timeout in ms (default 5000)")
      }),
      execute: async ({ text: O, timeoutMs: P }) => {
        const N = await this.getTarget(), j = Date.now(), M = P ?? 5e3;
        for (; Date.now() - j < M; ) {
          if (await N.executeJavaScript(
            `document.body && document.body.innerText && document.body.innerText.toLowerCase().includes(${JSON.stringify(
              O.toLowerCase()
            )})`,
            !0
          )) return `Found text: ${JSON.stringify(O)}`;
          await this.delay(150);
        }
        return `Did not find text within ${M}ms: ${JSON.stringify(O)}`;
      }
    }, ne = {
      name: "browser_wait_for_text_in",
      description: "Wait until text appears within a specific container selector (case-insensitive).",
      schema: Ee({
        selector: G().describe("CSS selector for the container"),
        text: G().describe("Text to wait for"),
        timeoutMs: Qe().optional().describe("Timeout in ms (default 5000)")
      }),
      execute: async ({
        selector: O,
        text: P,
        timeoutMs: N
      }) => {
        const j = await this.getTarget(), M = Date.now(), q = N ?? 5e3, se = P.toLowerCase();
        for (; Date.now() - M < q; ) {
          if (await j.executeJavaScript(
            `(() => {
              const root = document.querySelector(${JSON.stringify(O)});
              if (!root) return false;
              const text = (root.innerText || '').toLowerCase();
              return text.includes(${JSON.stringify(se)});
            })()`,
            !0
          )) return `Found text in ${O}: ${JSON.stringify(P)}`;
          await this.delay(150);
        }
        return `Did not find text in ${O} within ${q}ms: ${JSON.stringify(P)}`;
      }
    }, z = {
      name: "browser_select",
      description: "Set the value of a <select> element.",
      schema: Ee({
        selector: G().describe("CSS selector of the select element"),
        value: G().describe("Option value to set")
      }),
      execute: async ({ selector: O, value: P }) => {
        try {
          const N = await this.getTarget(), j = await this.querySelectorCount(N, O);
          if (j > 1)
            return `Refusing to select on non-unique selector (matches=${j}): ${O}`;
          await this.waitForSelector(N, O, 5e3);
          const M = await N.executeJavaScript(
            `(() => {
              const el = document.querySelector(${JSON.stringify(O)});
              if (!el) throw new Error('Element not found');
              const tag = el.tagName?.toLowerCase?.();
              if (tag !== 'select') throw new Error('Element is not a <select>');
              const isDisabled = Boolean(el.disabled) || el.getAttribute?.('aria-disabled') === 'true';
              if (isDisabled) throw new Error('Element is disabled');
              el.value = ${JSON.stringify(P)};
              el.dispatchEvent(new Event('input', { bubbles: true }));
              el.dispatchEvent(new Event('change', { bubbles: true }));
              return String(el.value ?? '');
            })()`,
            !0
          );
          return this.invalidateCache(N.id), `Selected value ${JSON.stringify(M)} on ${O}`;
        } catch (N) {
          return `Failed to select on ${O}: ${N.message}`;
        }
      }
    }, Se = {
      name: "browser_click_text",
      description: "Click a visible element by its text (avoids brittle selectors). Optionally filter by tag/role and choose index.",
      schema: Ee({
        text: G().describe("Visible text to match"),
        exact: Bi().optional().describe("Exact match (default false = substring match)"),
        role: G().optional().describe("ARIA role to filter (e.g. tab, button, link)"),
        tag: G().optional().describe("Tag name to filter (e.g. a, button)"),
        index: Qe().optional().describe("Which match to click (0-based, default 0)"),
        withinSelector: G().optional().describe("Limit search to a container selector")
      }),
      execute: async ({
        text: O,
        exact: P,
        role: N,
        tag: j,
        index: M,
        withinSelector: q
      }) => {
        try {
          const Te = await (await this.getTarget()).executeJavaScript(
            `(() => {
              const query = ${JSON.stringify(O)}.toLowerCase().trim();
              const exact = Boolean(${JSON.stringify(P ?? !1)});
              const role = ${JSON.stringify(N ?? "")}.toLowerCase().trim();
              const tag = ${JSON.stringify(j ?? "")}.toLowerCase().trim();
              const idx = Math.max(0, Math.floor(${JSON.stringify(M ?? 0)}));
              const root = ${q ? `document.querySelector(${JSON.stringify(q)})` : "document"} || document;

              const isVisible = (el) => {
                if (!el || el.nodeType !== 1) return false;
                const style = window.getComputedStyle(el);
                if (!style) return false;
                if (style.display === 'none' || style.visibility === 'hidden' || style.opacity === '0') return false;
                if (style.pointerEvents === 'none') return false;
                const rects = el.getClientRects();
                if (!rects || rects.length === 0) return false;
                const rect = el.getBoundingClientRect();
                if (rect.width < 2 || rect.height < 2) return false;
                const vw = window.innerWidth || 0;
                const vh = window.innerHeight || 0;
                const buffer = 40;
                if (rect.bottom < -buffer || rect.top > vh + buffer) return false;
                if (rect.right < -buffer || rect.left > vw + buffer) return false;
                return true;
              };

              const selector = 'button, a, [role="button"], [role="link"], [role="tab"], summary';
              const candidates = Array.from((root === document ? document : root).querySelectorAll(selector));
              const matches = [];
              for (const el of candidates) {
                if (!isVisible(el)) continue;
                if (tag && el.tagName.toLowerCase() !== tag) continue;
                if (role) {
                  const r = (el.getAttribute('role') || '').toLowerCase();
                  if (r !== role) continue;
                }
                const t = (el.textContent || '').replace(/\\s+/g, ' ').trim().toLowerCase();
                if (!t) continue;
                const ok = exact ? t === query : t.includes(query);
                if (!ok) continue;
                const disabled = ('disabled' in el && Boolean(el.disabled)) || el.getAttribute?.('aria-disabled') === 'true';
                matches.push({ el, text: t, disabled });
              }

              if (matches.length === 0) {
                return { ok: false, reason: 'No matching visible elements', matches: 0 };
              }
              const chosen = matches[Math.min(idx, matches.length - 1)];
              if (chosen.disabled) {
                return { ok: false, reason: 'Matched element is disabled', matches: matches.length };
              }
              const el = chosen.el;
              el.scrollIntoView({ block: 'center', inline: 'center' });
              el.dispatchEvent(new MouseEvent('mouseover', { bubbles: true }));
              el.dispatchEvent(new MouseEvent('mousedown', { bubbles: true }));
              el.dispatchEvent(new MouseEvent('mouseup', { bubbles: true }));
              el.click();
              return { ok: true, matches: matches.length, clickedText: chosen.text };
            })()`,
            !0
          );
          return `ClickText result: ${JSON.stringify(Te)}`;
        } catch (se) {
          return `Failed to click by text: ${se.message}`;
        }
      }
    }, Oe = {
      name: "browser_extract_main_text",
      description: "Extract visible text from the main content area (role=main/main tag) to support scraping/QA.",
      schema: Ee({
        maxChars: Qe().optional().describe("Max characters to return (default 2000, hard cap 4000)")
      }),
      execute: async ({ maxChars: O }) => {
        const P = await this.getTarget(), N = Math.max(1, Math.min(4e3, Math.floor(O ?? 2e3))), j = await P.executeJavaScript(
          `(() => {
            const node = document.querySelector('main, [role="main"]') || document.body;
            const raw = (node?.innerText || '').replace(/s+/g, ' ').trim();
            return raw.slice(0, ${JSON.stringify(N)});
          })()`,
          !0
        );
        return String(j ?? "");
      }
    }, Z = Ee({
      action: Gn(["navigate", "click", "type", "select", "wait"]),
      url: G().optional().describe("For navigate action"),
      selector: G().optional().describe("For click/type/select actions"),
      value: G().optional().describe("For type/select actions"),
      text: G().optional().describe("For wait action"),
      index: Qe().optional().describe("For click actions: index to disambiguate (0-based)"),
      matchText: G().optional().describe("For click actions: filter candidates by visible text"),
      withinSelector: G().optional().describe("For click actions: scope search to a unique container selector")
    }), D = Ee({
      steps: Zi(Z)
    }), U = {
      name: "browser_execute_plan",
      description: "Execute a batch of browser actions (navigate, click, type, select, wait). Use this for Mock SaaS tasks where you have read the code and know the selectors.",
      schema: D,
      execute: async (O) => {
        const N = D.parse(O ?? {}).steps, j = [], M = ft.getRunId() ?? void 0, q = Pe();
        if (!Array.isArray(N) || N.length === 0)
          return "Plan rejected: steps must be a non-empty array.";
        for (const [b, m] of N.entries()) {
          if (m.action === "navigate" && !m.url)
            return `Plan rejected: step ${b + 1} navigate is missing url.`;
          if (m.action === "click" && !m.selector)
            return `Plan rejected: step ${b + 1} click is missing selector.`;
          if (m.action === "type") {
            if (!m.selector) return `Plan rejected: step ${b + 1} type is missing selector.`;
            if (m.value === void 0) return `Plan rejected: step ${b + 1} type is missing value.`;
          }
          if (m.action === "select") {
            if (!m.selector) return `Plan rejected: step ${b + 1} select is missing selector.`;
            if (m.value === void 0) return `Plan rejected: step ${b + 1} select is missing value.`;
          }
          if (m.action === "wait" && !m.text)
            return `Plan rejected: step ${b + 1} wait is missing text.`;
        }
        if (N.some((b) => b.action === "click" || b.action === "type" || b.action === "select")) {
          const b = N[N.length - 1];
          if ((b == null ? void 0 : b.action) !== "wait" || !(b != null && b.text))
            return 'Plan rejected: plans with interactions must end with a verification wait step (action="wait" with text).';
        }
        const Te = we.getPolicyService();
        if (Te) {
          const b = ft.getBrowserContext();
          for (const [m, $] of N.entries()) {
            const I = (() => {
              switch ($.action) {
                case "navigate":
                  return "browser_navigate";
                case "click":
                  return "browser_click";
                case "type":
                  return "browser_type";
                case "select":
                  return "browser_select";
                case "wait":
                  return "browser_wait_for_text";
                default:
                  return "browser_execute_plan_step";
              }
            })(), de = (() => {
              switch ($.action) {
                case "navigate":
                  return { url: $.url };
                case "click":
                  return {
                    selector: $.selector,
                    index: $.index,
                    matchText: $.matchText,
                    withinSelector: $.withinSelector
                  };
                case "type":
                  return { selector: $.selector, text: $.value };
                case "select":
                  return { selector: $.selector, value: $.value };
                case "wait":
                  return { text: $.text };
              }
            })(), me = await Te.evaluate({
              toolName: I,
              args: de,
              url: b == null ? void 0 : b.url,
              domain: b == null ? void 0 : b.domain,
              userMode: "standard",
              observeOnly: ft.getObserveOnly(),
              runId: M
            });
            if (me.decision === "deny")
              return `Plan rejected by policy at step ${m + 1} (${I}): ${me.reason}`;
          }
        }
        const ae = (b) => {
          const m = String(b ?? "");
          return m.startsWith("Refusing") || m.startsWith("Failed") || m.startsWith("Timeout") || m.startsWith("Operation denied by policy") || m.startsWith("User denied") || m.startsWith("Tool execution failed");
        };
        for (const [b, m] of N.entries()) {
          const $ = Pe(), I = Date.now();
          try {
            await et.emit({
              eventId: Pe(),
              runId: M,
              ts: (/* @__PURE__ */ new Date()).toISOString(),
              type: "plan_step_start",
              name: "browser_execute_plan",
              data: {
                planId: q,
                stepId: $,
                stepIndex: b,
                action: String((m == null ? void 0 : m.action) ?? "")
              }
            });
          } catch {
          }
          try {
            const de = (() => {
              switch (m.action) {
                case "navigate":
                  return "browser_navigate";
                case "click":
                  return "browser_click";
                case "type":
                  return "browser_type";
                case "select":
                  return "browser_select";
                case "wait":
                  return "browser_wait_for_text";
                default:
                  return "browser_execute_plan_step";
              }
            })(), me = (() => {
              switch (m.action) {
                case "navigate":
                  return { url: m.url };
                case "click":
                  return {
                    selector: m.selector,
                    index: m.index,
                    matchText: m.matchText,
                    withinSelector: m.withinSelector
                  };
                case "type":
                  return { selector: m.selector, text: m.value };
                case "select":
                  return { selector: m.selector, value: m.value };
                case "wait":
                  return { text: m.text };
              }
            })(), Me = await we.invokeTool(de, me), Ue = String(Me ?? "");
            if (ae(Ue))
              throw new Error(Ue);
            if (m.action === "wait" && !Ue.startsWith("Found text"))
              throw new Error(Ue);
            const at = Date.now() - I;
            try {
              await et.emit({
                eventId: Pe(),
                runId: M,
                ts: (/* @__PURE__ */ new Date()).toISOString(),
                type: "plan_step_end",
                name: "browser_execute_plan",
                data: {
                  planId: q,
                  stepId: $,
                  stepIndex: b,
                  action: String((m == null ? void 0 : m.action) ?? ""),
                  ok: !0,
                  durationMs: at,
                  resultLength: String(Ue ?? "").length
                }
              });
            } catch {
            }
            j.push(`Step ${b + 1} (${m.action}): ${Ue}`);
          } catch (de) {
            const me = Date.now() - I;
            try {
              await et.emit({
                eventId: Pe(),
                runId: M,
                ts: (/* @__PURE__ */ new Date()).toISOString(),
                type: "plan_step_end",
                name: "browser_execute_plan",
                data: {
                  planId: q,
                  stepId: $,
                  stepIndex: b,
                  action: String((m == null ? void 0 : m.action) ?? ""),
                  ok: !1,
                  durationMs: me,
                  errorMessage: String((de == null ? void 0 : de.message) ?? de)
                }
              });
            } catch {
            }
            return j.push(`Step ${b + 1} (${m.action}) FAILED: ${de.message}`), `Plan execution stopped at step ${b + 1} due to error.
Results so far:
${j.join(`
`)}`;
          }
        }
        return `Plan completed successfully.
${j.join(`
`)}`;
      }
    };
    we.register(t), we.register(n), we.register(s), we.register(a), we.register(i), we.register(c), we.register(l), we.register(h), we.register(p), we.register(g), we.register(_), we.register(T), we.register(x), we.register(A), we.register(R), we.register(E), we.register(V), we.register(ne), we.register(z), we.register(Se), we.register(Oe), we.register(U);
  }
}
const Y1 = new K1(), bf = [
  {
    id: "aerocore-dispatch",
    name: "AeroCore Dispatch",
    description: "Create and dispatch a new job in AeroCore Dispatch",
    userMessage: "Go to AeroCore Dispatch and create a new dispatch job for cargo delivery from Warehouse A to Terminal 1",
    expectedOutcome: { type: "text_present", value: "Warehouse A" },
    timeoutMs: 6e4
  },
  {
    id: "aerocore-fleet",
    name: "AeroCore Fleet",
    description: "Add a new drone to the fleet",
    userMessage: "Navigate to AeroCore Fleet and add a new drone with serial DR-001",
    expectedOutcome: { type: "text_present", value: "DR-001" },
    timeoutMs: 6e4
  },
  {
    id: "aerocore-workforce",
    name: "AeroCore Workforce",
    description: "Create a new employee profile",
    userMessage: "Go to AeroCore Workforce and create a new employee profile for Jane Doe",
    expectedOutcome: { type: "text_present", value: "Jane Doe" },
    timeoutMs: 6e4
  },
  {
    id: "aerocore-cargo",
    name: "AeroCore Cargo",
    description: "Create a new shipment",
    userMessage: "Navigate to AeroCore Cargo and create a new shipment with ID SH-9987",
    expectedOutcome: { type: "text_present", value: "SH-9987" },
    timeoutMs: 6e4
  },
  {
    id: "aerocore-security",
    name: "AeroCore Security",
    description: "Create a security incident report",
    userMessage: "Go to AeroCore Security and file a new security incident report",
    expectedOutcome: { type: "text_present", value: "Incident" },
    timeoutMs: 6e4
  },
  {
    id: "aerocore-admin",
    name: "AeroCore Admin",
    description: "Update system settings",
    userMessage: "Navigate to AeroCore Admin and update the system timezone to UTC",
    expectedOutcome: { type: "text_present", value: "UTC" },
    timeoutMs: 6e4
  },
  {
    id: "aerocore-portal",
    name: "AeroCore Portal",
    description: "Create a new portal announcement",
    userMessage: "Go to AeroCore Portal and create a new announcement about system maintenance",
    expectedOutcome: { type: "text_present", value: "maintenance" },
    timeoutMs: 6e4
  },
  {
    id: "aerocore-datalake",
    name: "AeroCore Datalake",
    description: "Run a data query",
    userMessage: "Navigate to AeroCore Datalake and run a query for recent logs",
    expectedOutcome: { type: "text_present", value: "logs" },
    timeoutMs: 6e4
  },
  // Personal Browser Scenarios
  {
    id: "personal-wikipedia",
    name: "Wikipedia Navigation",
    description: "Navigate to Wikipedia and find the Featured Article",
    userMessage: `Go to wikipedia.org and verify that the "From today's featured article" section is present.`,
    expectedOutcome: { type: "text_present", value: "From today's featured article" },
    timeoutMs: 6e4
  },
  {
    id: "personal-todomvc",
    name: "TodoMVC Interaction",
    description: "Add and complete tasks in a React Todo app",
    userMessage: 'Go to https://todomvc.com/examples/react/dist/. Add a new todo item called "Review Agent Performance" and then press Enter.',
    expectedOutcome: { type: "text_present", value: "Review Agent Performance" },
    timeoutMs: 6e4
  },
  {
    id: "personal-hn",
    name: "Hacker News Retrieval",
    description: "Navigate to Hacker News",
    userMessage: 'Go to news.ycombinator.com and find the "Hacker News" header.',
    expectedOutcome: { type: "text_present", value: "Hacker News" },
    timeoutMs: 45e3
  },
  {
    id: "personal-duckduckgo",
    name: "Search Engine Usage",
    description: "Search using DuckDuckGo",
    userMessage: 'Go to duckduckgo.com, type "Enterprise Browser" into the search box, and search.',
    expectedOutcome: { type: "url_match", value: "duckduckgo.com/?q=Enterprise+Browser" },
    timeoutMs: 6e4
  }
];
class X1 {
  constructor() {
    v(this, "trajectory", []);
    v(this, "llmCalls", 0);
    v(this, "retries", 0);
  }
  async runSuite(e, t) {
    const n = e ? bf.filter((a) => a.id.includes(e)) : bf;
    console.log(`[Benchmark] Starting suite with ${n.length} scenarios (actionsPolicy=${t})...`);
    const s = [];
    for (const a of n) {
      console.log(`[Benchmark] Running scenario: ${a.name} (${a.id})`);
      const i = await this.runScenario(a, t);
      s.push(i), console.log(`[Benchmark] Scenario ${a.id} ${i.success ? "PASSED" : "FAILED"} in ${i.durationMs}ms (llmCalls=${i.llmCalls}, retries=${i.retries})`);
    }
    return s;
  }
  async runScenario(e, t) {
    const n = Pe(), s = Date.now();
    this.trajectory = [], this.llmCalls = 0, this.retries = 0;
    const a = (i) => {
      var o;
      this.trajectory.push({
        ts: (o = i.metadata) != null && o.ts ? new Date(i.metadata.ts).getTime() : Date.now(),
        type: i.type,
        content: i.content,
        metadata: i.metadata
      }), i.type === "llm_start" && this.llmCalls++;
    };
    try {
      await Ot.resetConversation(), Ot.toggleActionsPolicy(!!t), Ot.setStepHandler(a), await Ot.chat(e.userMessage);
      const i = await this.verifyOutcome(e);
      return {
        scenarioId: e.id,
        success: i,
        durationMs: Date.now() - s,
        steps: this.trajectory.length,
        llmCalls: this.llmCalls,
        retries: this.retries,
        runId: n,
        trajectory: [...this.trajectory]
      };
    } catch (i) {
      return {
        scenarioId: e.id,
        success: !1,
        durationMs: Date.now() - s,
        steps: this.trajectory.length,
        llmCalls: this.llmCalls,
        retries: this.retries,
        error: i.message,
        runId: n,
        trajectory: [...this.trajectory]
      };
    } finally {
      Ot.clearStepHandler();
    }
  }
  extractNormalizedPlan(e) {
    return e.filter((n) => {
      var s;
      return n.type === "action" && ((s = n.metadata) == null ? void 0 : s.tool);
    }).map((n) => {
      var a;
      const s = ((a = n.metadata) == null ? void 0 : a.toolArgs) ?? {};
      return {
        tool: n.metadata.tool,
        args: s,
        ts: n.ts
      };
    });
  }
  extractFeedbackLabels(e) {
    return e.filter((t) => {
      var n;
      return t.type === "observation" && ((n = t.content) == null ? void 0 : n.includes("Recorded"));
    }).map((t) => {
      var s;
      const n = (s = t.content) == null ? void 0 : s.match(/Recorded (worked|failed|partial)/i);
      return n ? n[1].toLowerCase() : void 0;
    }).filter(Boolean);
  }
  async exportTrajectories(e) {
    var i, o;
    const t = ke.join(Bt.getPath("userData"), "benchmark_datasets");
    await Ke.mkdir(t, { recursive: !0 });
    const n = (/* @__PURE__ */ new Date()).toISOString().replace(/[:.]/g, "-"), s = ke.join(t, `trajectories_${n}.jsonl`), a = [];
    for (const c of e) {
      if (!c.trajectory) continue;
      const u = this.extractNormalizedPlan(c.trajectory), l = this.extractFeedbackLabels(c.trajectory), d = (o = (i = c.trajectory.find((y) => {
        var g;
        return (g = y.metadata) == null ? void 0 : g.url;
      })) == null ? void 0 : i.metadata) == null ? void 0 : o.url, h = (() => {
        if (!d) return "unknown";
        try {
          return new URL(d).hostname;
        } catch {
          return "unknown";
        }
      })(), f = (() => {
        if (d)
          try {
            return new URL(d).pathname;
          } catch {
            return;
          }
      })(), p = {
        scenarioId: c.scenarioId,
        runId: c.runId,
        domain: h,
        fingerprint: f,
        normalizedPlan: u,
        steps: c.trajectory,
        outcome: c.success ? "success" : "failure",
        success: c.success,
        durationMs: c.durationMs,
        llmCalls: c.llmCalls,
        retries: c.retries,
        feedbackLabels: l
      };
      a.push(JSON.stringify(p));
    }
    return await Ke.writeFile(s, a.join(`
`), "utf8"), console.log(`[Benchmark] Exported ${e.length} trajectories to ${s}`), s;
  }
  async verifyOutcome(e) {
    const t = await Y1.getTarget();
    return e.expectedOutcome.type === "text_present" ? !!await t.executeJavaScript(
      `document.body.innerText.includes(${JSON.stringify(e.expectedOutcome.value)})`,
      !0
    ) : e.expectedOutcome.type === "url_match" ? (await t.getURL()).includes(e.expectedOutcome.value) : !1;
  }
}
const yc = new X1(), Q1 = 2e3, Sf = 2e5, eR = /* @__PURE__ */ new Set([
  "node_modules",
  ".git",
  "dist",
  "build",
  ".next",
  ".turbo",
  ".cache"
]), Tf = (r, e) => {
  const t = ke.relative(e, r);
  return t === "" || !t.startsWith(".." + ke.sep) && t !== "..";
};
class tR {
  constructor() {
    v(this, "mockSaasSrcRoot", null);
    v(this, "mockSaasSrcRootReal", null);
    this.registerTools();
  }
  async pathExists(e) {
    try {
      return await Ke.stat(e), !0;
    } catch {
      return !1;
    }
  }
  async getMockSaasSrcRoot() {
    if (this.mockSaasSrcRoot && this.mockSaasSrcRootReal)
      return { root: this.mockSaasSrcRoot, rootReal: this.mockSaasSrcRootReal };
    const e = [];
    e.push(process.cwd()), e.push(ke.dirname(process.cwd())), e.push(ke.dirname(ke.dirname(process.cwd())));
    try {
      e.push(Bt.getAppPath()), e.push(ke.dirname(Bt.getAppPath())), e.push(ke.dirname(ke.dirname(Bt.getAppPath())));
    } catch {
    }
    for (const t of e) {
      const n = ke.resolve(t, "mock-saas", "src");
      if (await this.pathExists(n)) {
        const s = await Ke.realpath(n);
        return this.mockSaasSrcRoot = n, this.mockSaasSrcRootReal = s, { root: n, rootReal: s };
      }
    }
    throw new Error(
      "mock-saas/src not found. This white-box tool only works when the repo contains mock-saas/src."
    );
  }
  normalizeUserPath(e) {
    return e.replace(/\\/g, "/").trim().replace(/^(\.\/)+/, "").replace(/^\/+/, "").replace(/^mock-saas\/src\//, "").replace(/^mock-saas\//, "").replace(/^src\//, "");
  }
  async resolvePathWithinMockSaasSrc(e) {
    const { rootReal: t } = await this.getMockSaasSrcRoot(), n = this.normalizeUserPath(e), s = ke.resolve(t, n);
    if (!Tf(s, t))
      throw new Error("Path escapes mock-saas/src. Access denied.");
    return s;
  }
  async listFilesRecursive(e, t, n, s) {
    if (n.length >= t) return;
    const a = await Ke.readdir(e, { withFileTypes: !0 });
    for (const i of a) {
      if (n.length >= t) return;
      if (i.name.startsWith(".") || eR.has(i.name)) continue;
      const o = ke.join(e, i.name);
      let c;
      try {
        c = await Ke.realpath(o);
      } catch {
        continue;
      }
      Tf(c, s) && (i.isDirectory() ? await this.listFilesRecursive(c, t, n, s) : i.isFile() && n.push(c));
    }
  }
  registerTools() {
    const e = Ee({
      dir: G().optional().describe('Directory within mock-saas/src to list (default: ".")'),
      maxFiles: Qe().int().min(1).max(5e3).optional().describe("Max files to return (default 500)")
    }), t = {
      name: "code_list_files",
      description: "List files under mock-saas/src (white-box access). Ignores node_modules/dist. Returns paths relative to mock-saas/src.",
      schema: e,
      execute: async (o) => {
        const { dir: c, maxFiles: u } = e.parse(o ?? {}), { rootReal: l } = await this.getMockSaasSrcRoot(), d = await this.resolvePathWithinMockSaasSrc(c ?? "."), h = [];
        await this.listFilesRecursive(d, u ?? 500, h, l);
        const f = h.map((p) => ke.relative(l, p).replace(/\\/g, "/")).sort();
        return JSON.stringify(
          {
            root: "mock-saas/src",
            dir: (c ?? ".").replace(/\\/g, "/"),
            count: f.length,
            files: f
          },
          null,
          2
        );
      }
    }, n = Ee({
      path: G().describe('File path within mock-saas/src (e.g. "pages/jira/JiraPage.tsx")'),
      startLine: Qe().int().min(1).optional().describe("Start line (1-based)"),
      maxLines: Qe().int().min(1).max(2e3).optional().describe("Max lines to return (default 200)"),
      maxBytes: Qe().int().min(1).max(2e6).optional().describe("Max bytes to read (default 200k)")
    }), s = {
      name: "code_read_file",
      description: "Read a file from mock-saas/src (white-box access). Use this to discover data-testid selectors and UI state logic.",
      schema: n,
      execute: async (o) => {
        const { path: c, startLine: u, maxLines: l, maxBytes: d } = n.parse(o), { rootReal: h } = await this.getMockSaasSrcRoot(), f = await this.resolvePathWithinMockSaasSrc(c), p = await Ke.stat(f);
        if (!p.isFile()) throw new Error("Not a file.");
        if (p.size > (d ?? Sf))
          throw new Error(
            `File too large (${p.size} bytes). Increase maxBytes (<=2,000,000) or read a smaller file.`
          );
        const g = (await Ke.readFile(f, "utf8")).split(/\r?\n/), S = g.length, _ = Math.max(1, u ?? 1), T = Math.min(S, _ + (l ?? 200) - 1), x = g.slice(_ - 1, T).join(`
`);
        return JSON.stringify(
          {
            root: "mock-saas/src",
            path: ke.relative(h, f).replace(/\\/g, "/"),
            totalLines: S,
            startLine: _,
            endLine: T,
            content: x
          },
          null,
          2
        );
      }
    }, a = Ee({
      query: G().min(1).describe("Text to search for"),
      dir: G().optional().describe('Directory within mock-saas/src to search (default ".")'),
      maxResults: Qe().int().min(1).max(200).optional().describe("Max matches to return (default 20)"),
      caseSensitive: Bi().optional().describe("Case-sensitive search (default false)"),
      maxFiles: Qe().int().min(1).max(5e3).optional().describe("Max files to scan (default 2000)")
    }), i = {
      name: "code_search",
      description: "Search for text within mock-saas/src (white-box access). Returns file/line previews to quickly find relevant components.",
      schema: a,
      execute: async (o) => {
        const { query: c, dir: u, maxResults: l, caseSensitive: d, maxFiles: h } = a.parse(o), { rootReal: f } = await this.getMockSaasSrcRoot(), p = await this.resolvePathWithinMockSaasSrc(u ?? "."), y = [];
        await this.listFilesRecursive(p, h ?? Q1, y, f);
        const g = d ? c : c.toLowerCase(), S = l ?? 20, _ = [];
        for (const w of y) {
          if (_.length >= S) break;
          let T;
          try {
            T = await Ke.stat(w);
          } catch {
            continue;
          }
          if (!T.isFile() || T.size > Sf * 2) continue;
          let x;
          try {
            x = await Ke.readFile(w, "utf8");
          } catch {
            continue;
          }
          const A = x.split(/\r?\n/);
          for (let R = 0; R < A.length && !(_.length >= S); R++)
            (d ? A[R] : A[R].toLowerCase()).includes(g) && _.push({
              path: ke.relative(f, w).replace(/\\/g, "/"),
              line: R + 1,
              preview: A[R].trim().slice(0, 200)
            });
        }
        return JSON.stringify(
          {
            root: "mock-saas/src",
            dir: (u ?? ".").replace(/\\/g, "/"),
            query: c,
            count: _.length,
            matches: _
          },
          null,
          2
        );
      }
    };
    we.register(t), we.register(s), we.register(i);
  }
}
new tR();
class rR {
  constructor() {
    v(this, "issues", [
      {
        key: "PROJ-1",
        summary: "Fix login page layout",
        description: "The login button is misaligned on mobile devices.",
        status: "To Do",
        assignee: "jdoe"
      },
      {
        key: "PROJ-2",
        summary: "Update API documentation",
        description: "The /v2/users endpoint docs are outdated.",
        status: "In Progress",
        assignee: "smitchell"
      },
      {
        key: "PROJ-3",
        summary: "Investigate server crash",
        description: "Server 3 crashed with OOM error last night.",
        status: "Done",
        assignee: "jdoe"
      }
    ]);
    this.registerTools();
  }
  async simulateDelay() {
    await new Promise((e) => setTimeout(e, 500));
  }
  registerTools() {
    const e = {
      name: "jira_list_issues",
      description: "List all Jira issues, optionally filtered by status.",
      schema: Ee({
        status: G().optional().describe("Filter by status (To Do, In Progress, Done)")
      }),
      execute: async ({ status: s }) => {
        await this.simulateDelay();
        let a = this.issues;
        return s && (a = a.filter((i) => i.status.toLowerCase() === s.toLowerCase())), JSON.stringify(a, null, 2);
      }
    }, t = {
      name: "jira_get_issue",
      description: "Get details of a specific Jira issue by key.",
      schema: Ee({
        key: G().describe("The issue key (e.g., PROJ-1)")
      }),
      execute: async ({ key: s }) => {
        await this.simulateDelay();
        const a = this.issues.find((i) => i.key === s);
        return a ? JSON.stringify(a, null, 2) : `Issue ${s} not found.`;
      }
    }, n = {
      name: "jira_create_issue",
      description: "Create a new Jira issue.",
      requiresApproval: !0,
      schema: Ee({
        summary: G().describe("The issue summary/title"),
        description: G().describe("The issue description"),
        assignee: G().optional().describe("The user to assign the issue to")
      }),
      execute: async ({ summary: s, description: a, assignee: i }) => {
        await this.simulateDelay();
        const o = `PROJ-${this.issues.length + 1}`, c = {
          key: o,
          summary: s,
          description: a,
          status: "To Do",
          assignee: i || "unassigned"
        };
        return this.issues.push(c), `Successfully created issue ${o}`;
      }
    };
    we.register(e), we.register(t), we.register(n);
  }
}
new rR();
class nR {
  constructor() {
    v(this, "pages", [
      {
        id: "1001",
        title: "Project Phoenix Architecture",
        space: "ENG",
        content: "Project Phoenix aims to unify the browser experience. Key components: Electron, React, LangChain.",
        lastUpdated: "2023-10-01"
      },
      {
        id: "1002",
        title: "Q4 Marketing Strategy",
        space: "MKT",
        content: "Focus on enterprise decision makers. Channels: LinkedIn, TechCrunch, Industry Events.",
        lastUpdated: "2023-10-15"
      },
      {
        id: "1003",
        title: "Employee Onboarding Guide",
        space: "HR",
        content: "Welcome to the team! 1. Setup email. 2. Join Slack. 3. Read the handbook.",
        lastUpdated: "2023-09-20"
      }
    ]);
    this.registerTools();
  }
  async simulateDelay() {
    await new Promise((e) => setTimeout(e, 500));
  }
  registerTools() {
    const e = {
      name: "confluence_search",
      description: "Search for Confluence pages by title or content.",
      schema: Ee({
        query: G().describe("Search query string")
      }),
      execute: async ({ query: s }) => {
        await this.simulateDelay();
        const a = s.toLowerCase(), i = this.pages.filter(
          (o) => o.title.toLowerCase().includes(a) || o.content.toLowerCase().includes(a)
        ).map(({ content: o, ...c }) => c);
        return JSON.stringify(i, null, 2);
      }
    }, t = {
      name: "confluence_read_page",
      description: "Read the full content of a Confluence page.",
      schema: Ee({
        id: G().describe("The page ID (e.g., 1001)")
      }),
      execute: async ({ id: s }) => {
        await this.simulateDelay();
        const a = this.pages.find((i) => i.id === s);
        return a ? JSON.stringify(a, null, 2) : `Page ${s} not found.`;
      }
    }, n = {
      name: "confluence_create_page",
      description: "Create a new Confluence page.",
      schema: Ee({
        title: G().describe("Page title"),
        space: G().describe("Space key (e.g. ENG, HR)"),
        content: G().describe("Page content")
      }),
      execute: async ({ title: s, space: a, content: i }) => {
        await this.simulateDelay();
        const o = (1e3 + this.pages.length + 1).toString();
        return this.pages.push({
          id: o,
          title: s,
          space: a,
          content: i,
          lastUpdated: (/* @__PURE__ */ new Date()).toISOString().split("T")[0]
        }), `Created page ${o}: "${s}" in space ${a}`;
      }
    };
    we.register(e), we.register(t), we.register(n);
  }
}
new nR();
class sR {
  constructor() {
    v(this, "boards", [
      {
        id: "board-1",
        name: "Product Roadmap",
        lists: [
          { id: "list-1", name: "Backlog" },
          { id: "list-2", name: "Doing" },
          { id: "list-3", name: "Done" }
        ],
        cards: [
          { id: "card-1", title: "Research competitors", listId: "list-1" },
          { id: "card-2", title: "Design new logo", listId: "list-2" }
        ]
      }
    ]);
    this.registerTools();
  }
  async simulateDelay() {
    await new Promise((e) => setTimeout(e, 500));
  }
  registerTools() {
    const e = {
      name: "trello_get_board",
      description: "Get details of a Trello board, including lists and cards.",
      schema: Ee({
        id: G().describe("The board ID (e.g., board-1)")
      }),
      execute: async ({ id: s }) => {
        await this.simulateDelay();
        const a = this.boards.find((i) => i.id === s);
        return a ? JSON.stringify(a, null, 2) : `Board ${s} not found.`;
      }
    }, t = {
      name: "trello_move_card",
      description: "Move a Trello card to a different list.",
      schema: Ee({
        cardId: G().describe("The ID of the card to move"),
        targetListId: G().describe("The ID of the destination list")
      }),
      execute: async ({ cardId: s, targetListId: a }) => {
        await this.simulateDelay();
        for (const i of this.boards) {
          const o = i.cards.find((c) => c.id === s);
          if (o)
            return i.lists.some((u) => u.id === a) ? (o.listId = a, `Successfully moved card ${s} to list ${a}`) : `List ${a} not found on this board.`;
        }
        return `Card ${s} not found.`;
      }
    }, n = {
      name: "trello_create_card",
      description: "Create a new Trello card.",
      schema: Ee({
        boardId: G().describe("Board ID"),
        listId: G().describe("List ID"),
        title: G().describe("Card title")
      }),
      execute: async ({ boardId: s, listId: a, title: i }) => {
        await this.simulateDelay();
        const o = this.boards.find((l) => l.id === s);
        if (!o) return `Board ${s} not found`;
        const c = o.lists.find((l) => l.id === a);
        if (!c) return `List ${a} not found`;
        const u = `card-${Date.now()}`;
        return o.cards.push({ id: u, title: i, listId: a }), `Created card ${u}: "${i}" in list ${c.name}`;
      }
    };
    we.register(e), we.register(t), we.register(n);
  }
}
new sR();
const hy = ke.dirname(yy(import.meta.url));
process.env.APP_ROOT = ke.join(hy, "..");
const Tu = process.env.VITE_DEV_SERVER_URL, WR = ke.join(process.env.APP_ROOT, "dist-electron"), fy = ke.join(process.env.APP_ROOT, "dist");
process.env.VITE_PUBLIC = Tu ? ke.join(process.env.APP_ROOT, "public") : fy;
let Pr;
const Wa = /* @__PURE__ */ new Map(), Ef = 3e4;
function py() {
  Pr = new Eu({
    icon: ke.join(process.env.VITE_PUBLIC, "electron-vite.svg"),
    webPreferences: {
      preload: ke.join(hy, "preload.mjs"),
      webviewTag: !0
    }
  }), Pr.webContents.on("did-finish-load", () => {
    Pr == null || Pr.webContents.send("main-process-message", (/* @__PURE__ */ new Date()).toLocaleString());
  }), Tu ? (Pr.loadURL(Tu), Pr.webContents.openDevTools()) : Pr.loadFile(ke.join(fy, "index.html"));
}
process.env.ENABLE_ELECTRON_REMOTE_DEBUGGING === "true" && Bt.commandLine.appendSwitch("remote-debugging-port", "9222");
Bt.on("window-all-closed", () => {
  process.platform !== "darwin" && (Bt.quit(), Pr = null);
});
Bt.on("activate", () => {
  Eu.getAllWindows().length === 0 && py();
});
Bt.whenReady().then(() => {
  const r = new H1(et, yt);
  we.setPolicyService(r), We.on("agent:approval-response", (e, t) => {
    var i;
    const n = t == null ? void 0 : t.requestId, s = !!(t != null && t.approved);
    if (typeof n != "string") return;
    const a = Wa.get(n);
    a && ((i = e.sender) == null ? void 0 : i.id) === a.requesterWebContentsId && (clearTimeout(a.timeout), Wa.delete(n), a.resolve(s));
  }), we.setApprovalHandler(async (e, t) => {
    const n = ft.getRunId(), s = ft.getRequesterWebContentsId();
    if (!s) return !1;
    const a = Bs.fromId(s);
    if (!a || a.isDestroyed()) return !1;
    const i = Pe(), o = Date.now();
    return a.send("agent:request-approval", { requestId: i, toolName: e, args: t, runId: n, timeoutMs: Ef }), await new Promise((c) => {
      const u = setTimeout(() => {
        Wa.delete(i);
        try {
          const l = Bs.fromId(s);
          l && !l.isDestroyed() && l.send("agent:approval-timeout", { requestId: i, toolName: e, runId: n });
        } catch {
        }
        c(!1);
      }, Ef);
      Wa.set(i, {
        requestId: i,
        runId: n,
        toolName: e,
        requesterWebContentsId: s,
        createdAt: o,
        timeout: u,
        resolve: c
      });
    });
  }), We.handle("browser:webview-register", async (e, { tabId: t, webContentsId: n }) => {
    Cs.registerWebview(t, n);
  }), We.handle("browser:active-tab", async (e, { tabId: t }) => {
    Cs.setActiveTab(t ?? null);
  }), We.handle("vault:set", async (e, t, n) => await Rs.setSecret(t, n)), We.handle("vault:get", async (e, t) => await Rs.getSecret(t)), We.handle("vault:delete", async (e, t) => await Rs.deleteSecret(t)), We.handle("audit:get-logs", async (e, t) => yt.getLogs(typeof t == "number" ? t : 100).map((s) => {
    const a = (() => {
      try {
        return JSON.parse(s.details);
      } catch {
        return s.details;
      }
    })();
    return { ...s, details: a };
  })), We.handle("agent:feedback", async (e, t) => {
    const n = t, s = n == null ? void 0 : n.skillId;
    if (typeof s != "string") return !1;
    const a = n == null ? void 0 : n.label, i = n == null ? void 0 : n.version, o = n == null ? void 0 : n.success;
    if (a === "worked" || a === "failed" || a === "partial") {
      const c = typeof i == "number" ? i : void 0;
      return typeof Ja.recordFeedback == "function" ? (Ja.recordFeedback(
        s,
        a,
        c
      ), !0) : (Ja.recordOutcome(s, a === "worked"), !0);
    }
    return typeof o == "boolean" ? (Ja.recordOutcome(s, o), !0) : !1;
  }), We.handle("telemetry:export", async () => {
    const e = ke.join(Bt.getPath("userData"), "trajectories_export.json");
    return { success: !0, count: await et.exportTrajectories(e), path: e };
  }), We.handle("benchmark:runSuite", async (e, t) => await yc.runSuite(t)), We.handle("benchmark:runSuiteWithFlag", async (e, t, n) => await yc.runSuite(t, n)), We.handle("benchmark:exportTrajectories", async (e, t) => ({ success: !0, path: await yc.exportTrajectories(t) })), We.handle("agent:chat", async (e, t) => {
    const n = Pe();
    try {
      e.sender.send("agent:step", {
        type: "observation",
        content: `Run started: ${n}`,
        metadata: { runId: n, ts: (/* @__PURE__ */ new Date()).toISOString() }
      });
    } catch {
    }
    let s, a;
    try {
      const c = Cs.getActiveWebContents();
      if (c && !c.isDestroyed() && (s = c.getURL(), s))
        try {
          const u = new URL(s);
          a = u.hostname, u.port && (a += `:${u.port}`);
        } catch {
        }
    } catch {
    }
    try {
      await et.emit({
        eventId: Pe(),
        runId: n,
        ts: (/* @__PURE__ */ new Date()).toISOString(),
        type: "agent_run_start",
        name: "agent:chat",
        data: { messageLength: String(t ?? "").length }
      });
    } catch {
    }
    await yt.log({
      actor: "user",
      action: "chat_message",
      details: { message: t, runId: n },
      status: "success"
    }), Ot.setStepHandler((c) => {
      e.sender.send("agent:step", c);
      try {
        const u = c == null ? void 0 : c.metadata, l = u == null ? void 0 : u.tool, d = u == null ? void 0 : u.args, h = String((c == null ? void 0 : c.content) ?? ""), f = h.length, p = rn.createHash("sha256").update(h).digest("hex"), y = f > 2e3 ? h.slice(0, 2e3) : h, g = (() => {
          try {
            return JSON.stringify(d ?? null);
          } catch {
            return "[unserializable_args]";
          }
        })(), S = rn.createHash("sha256").update(g).digest("hex"), _ = u ? {
          ...u,
          ...d !== void 0 ? { args: void 0, argsHash: S } : null
        } : void 0;
        yt.log({
          actor: "agent",
          action: "agent_step",
          details: {
            runId: n,
            type: c == null ? void 0 : c.type,
            toolName: l,
            contentPreview: y,
            contentLength: f,
            contentHash: p,
            argsHash: d !== void 0 ? S : void 0,
            metadata: _
          },
          status: "success"
        }).catch(() => {
        });
      } catch {
      }
    });
    let i = "Current browser state: No active tab";
    try {
      const c = Cs.getActiveWebContents(), u = c.getURL(), l = c.getTitle();
      i = `Current browser state: URL="${u}", Title="${l}"`;
    } catch {
    }
    let o = "";
    try {
      const c = Ot.isYoloMode();
      o = await ft.run(
        { runId: n, requesterWebContentsId: e.sender.id, browserContext: { url: s, domain: a }, yoloMode: c },
        async () => await Ot.chat(t, i)
      );
    } finally {
      try {
        await et.emit({
          eventId: Pe(),
          runId: n,
          ts: (/* @__PURE__ */ new Date()).toISOString(),
          type: "agent_run_end",
          name: "agent:chat",
          data: { responseLength: o.length }
        });
      } catch {
      }
    }
    return await yt.log({
      actor: "agent",
      action: "chat_response",
      details: { response: o, runId: n },
      status: "success"
    }), o;
  }), We.handle("agent:reset-conversation", async () => (Ot.resetConversation(), { success: !0 })), We.handle("agent:get-models", async () => zn), We.handle("agent:get-current-model", async () => Ot.getCurrentModelId()), We.handle("agent:set-model", async (e, t) => (Ot.setModel(t), { success: !0, modelId: t })), We.handle("agent:set-mode", async (e, t) => (Ot.setAgentMode(t), { success: !0 })), We.handle("agent:get-mode", async () => Ot.getAgentMode()), We.handle("agent:set-permission-mode", async (e, t) => (Ot.setPermissionMode(t), { success: !0 })), We.handle("agent:get-permission-mode", async () => Ot.getPermissionMode()), We.handle("browser:navigate-tab", async (e, t) => {
    const n = Eu.getAllWindows()[0];
    return n ? (n.webContents.send("browser:navigate-to", t), { success: !0, url: t }) : { success: !1, error: "No window found" };
  }), py();
});
export {
  WR as MAIN_DIST,
  fy as RENDERER_DIST,
  Tu as VITE_DEV_SERVER_URL
};
