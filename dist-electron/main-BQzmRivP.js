var DJ = Object.defineProperty;
var Gp = (t) => {
  throw TypeError(t);
};
var SJ = (t, A, e) => A in t ? DJ(t, A, { enumerable: !0, configurable: !0, writable: !0, value: e }) : t[A] = e;
var R = (t, A, e) => SJ(t, typeof A != "symbol" ? A + "" : A, e), Up = (t, A, e) => A.has(t) || Gp("Cannot " + e), Cr = (t, A) => Object(A) !== A ? Gp('Cannot use the "in" operator on this value') : t.has(A), d = (t, A, e) => (Up(t, A, "read from private field"), e ? e.call(t) : A.get(t)), k = (t, A, e) => A.has(t) ? Gp("Cannot add the same private member more than once") : A instanceof WeakSet ? A.add(t) : A.set(t, e), x = (t, A, e, r) => (Up(t, A, "write to private field"), r ? r.call(t, e) : A.set(t, e), e), O = (t, A, e) => (Up(t, A, "access private method"), e);
var BI = (t, A, e, r) => ({
  set _(i) {
    x(t, A, i, e);
  },
  get _() {
    return d(t, A, r);
  }
});
import { app as Tc, BrowserWindow as F_, ipcMain as EI } from "electron";
import { urlToHttpOptions as FJ, URL as kJ, fileURLToPath as vJ } from "node:url";
import VA, { join as oF, dirname as RJ } from "node:path";
import Tp from "keytar";
import DE, { randomFillSync as bJ, randomUUID as MJ } from "node:crypto";
import Rf from "fs";
import SE from "path";
import ZD from "os";
import un from "crypto";
import _J from "better-sqlite3";
import { mkdtemp as k_, unlink as NJ, rename as LJ } from "node:fs/promises";
import gr, { tmpdir as xJ } from "node:os";
import gF, { execSync as Sw, spawnSync as GJ, spawn as UJ } from "node:child_process";
import { EventEmitter as TJ } from "node:events";
import Ft, { accessSync as KJ, existsSync as zE } from "node:fs";
import JJ from "node:readline";
import * as HJ from "node:http";
import * as PJ from "node:https";
import wn from "http";
import mn from "https";
import Dn from "url";
import yr from "net";
import v_ from "tty";
import bf from "util";
import Sn from "tls";
import rI from "events";
import R_ from "assert";
import b_ from "buffer";
import Fn from "stream";
import M_ from "dns";
import "node:assert";
import { PassThrough as OJ } from "node:stream";
import "node:process";
import YJ from "zlib";
class qJ {
  constructor() {
    R(this, "serviceName", "EnterpriseAgenticBrowser");
  }
  async setSecret(A, e) {
    await Tp.setPassword(this.serviceName, A, e);
  }
  async getSecret(A) {
    return await Tp.getPassword(this.serviceName, A);
  }
  async deleteSecret(A) {
    return await Tp.deletePassword(this.serviceName, A);
  }
}
const MC = new qJ();
function $E(t, A) {
  return t.lc_error_code = A, t.message = `${t.message}

Troubleshooting URL: https://docs.langchain.com/oss/javascript/langchain/errors/${A}/
`, t;
}
function $A(t, A, e, r, i) {
  if (typeof A == "function" ? t !== A || !0 : !A.has(t))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return A.set(t, e), e;
}
function $(t, A, e, r) {
  if (e === "a" && !r)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof A == "function" ? t !== A || !r : !A.has(t))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return e === "m" ? r : e === "a" ? r.call(t) : r ? r.value : A.get(t);
}
let __ = function() {
  const { crypto: t } = globalThis;
  if (t != null && t.randomUUID)
    return __ = t.randomUUID.bind(t), t.randomUUID();
  const A = new Uint8Array(1), e = t ? () => t.getRandomValues(A)[0] : () => Math.random() * 255 & 255;
  return "10000000-1000-4000-8000-100000000000".replace(/[018]/g, (r) => (+r ^ e() & 15 >> +r / 4).toString(16));
};
function Fw(t) {
  return typeof t == "object" && t !== null && // Spec-compliant fetch implementations
  ("name" in t && t.name === "AbortError" || // Expo fetch
  "message" in t && String(t.message).includes("FetchRequestCanceledException"));
}
const kw = (t) => {
  if (t instanceof Error)
    return t;
  if (typeof t == "object" && t !== null) {
    try {
      if (Object.prototype.toString.call(t) === "[object Error]") {
        const A = new Error(t.message, t.cause ? { cause: t.cause } : {});
        return t.stack && (A.stack = t.stack), t.cause && !A.cause && (A.cause = t.cause), t.name && (A.name = t.name), A;
      }
    } catch {
    }
    try {
      return new Error(JSON.stringify(t));
    } catch {
    }
  }
  return new Error(t);
};
class jA extends Error {
}
class Wt extends jA {
  constructor(A, e, r, i) {
    super(`${Wt.makeMessage(A, e, r)}`), this.status = A, this.headers = i, this.requestID = i == null ? void 0 : i.get("x-request-id"), this.error = e;
    const n = e;
    this.code = n == null ? void 0 : n.code, this.param = n == null ? void 0 : n.param, this.type = n == null ? void 0 : n.type;
  }
  static makeMessage(A, e, r) {
    const i = e != null && e.message ? typeof e.message == "string" ? e.message : JSON.stringify(e.message) : e ? JSON.stringify(e) : r;
    return A && i ? `${A} ${i}` : A ? `${A} status code (no body)` : i || "(no status code or body)";
  }
  static generate(A, e, r, i) {
    if (!A || !i)
      return new Mf({ message: r, cause: kw(e) });
    const n = e == null ? void 0 : e.error;
    return A === 400 ? new N_(A, n, r, i) : A === 401 ? new L_(A, n, r, i) : A === 403 ? new x_(A, n, r, i) : A === 404 ? new G_(A, n, r, i) : A === 409 ? new U_(A, n, r, i) : A === 422 ? new T_(A, n, r, i) : A === 429 ? new K_(A, n, r, i) : A >= 500 ? new J_(A, n, r, i) : new Wt(A, n, r, i);
  }
}
class Ur extends Wt {
  constructor({ message: A } = {}) {
    super(void 0, void 0, A || "Request was aborted.", void 0);
  }
}
class Mf extends Wt {
  constructor({ message: A, cause: e }) {
    super(void 0, void 0, A || "Connection error.", void 0), e && (this.cause = e);
  }
}
class _f extends Mf {
  constructor({ message: A } = {}) {
    super({ message: A ?? "Request timed out." });
  }
}
class N_ extends Wt {
}
class L_ extends Wt {
}
class x_ extends Wt {
}
class G_ extends Wt {
}
class U_ extends Wt {
}
class T_ extends Wt {
}
class K_ extends Wt {
}
class J_ extends Wt {
}
class H_ extends jA {
  constructor() {
    super("Could not parse response content as the length limit was reached");
  }
}
class P_ extends jA {
  constructor() {
    super("Could not parse response content as the request was rejected by the content filter");
  }
}
class cC extends Error {
  constructor(A) {
    super(A);
  }
}
const jJ = /^[a-z][a-z0-9+.-]*:/i, WJ = (t) => jJ.test(t);
let Qr = (t) => (Qr = Array.isArray, Qr(t)), uF = Qr;
function O_(t) {
  return typeof t != "object" ? {} : t ?? {};
}
function VJ(t) {
  if (!t)
    return !0;
  for (const A in t)
    return !1;
  return !0;
}
function ZJ(t, A) {
  return Object.prototype.hasOwnProperty.call(t, A);
}
function Kp(t) {
  return t != null && typeof t == "object" && !Array.isArray(t);
}
const XJ = (t, A) => {
  if (typeof A != "number" || !Number.isInteger(A))
    throw new jA(`${t} must be an integer`);
  if (A < 0)
    throw new jA(`${t} must be a positive integer`);
  return A;
}, zJ = (t) => {
  try {
    return JSON.parse(t);
  } catch {
    return;
  }
}, FE = (t) => new Promise((A) => setTimeout(A, t)), Hg = "6.10.0", $J = () => (
  // @ts-ignore
  typeof window < "u" && // @ts-ignore
  typeof window.document < "u" && // @ts-ignore
  typeof navigator < "u"
);
function AH() {
  return typeof Deno < "u" && Deno.build != null ? "deno" : typeof EdgeRuntime < "u" ? "edge" : Object.prototype.toString.call(typeof globalThis.process < "u" ? globalThis.process : 0) === "[object process]" ? "node" : "unknown";
}
const eH = () => {
  var e;
  const t = AH();
  if (t === "deno")
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": Hg,
      "X-Stainless-OS": IF(Deno.build.os),
      "X-Stainless-Arch": cF(Deno.build.arch),
      "X-Stainless-Runtime": "deno",
      "X-Stainless-Runtime-Version": typeof Deno.version == "string" ? Deno.version : ((e = Deno.version) == null ? void 0 : e.deno) ?? "unknown"
    };
  if (typeof EdgeRuntime < "u")
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": Hg,
      "X-Stainless-OS": "Unknown",
      "X-Stainless-Arch": `other:${EdgeRuntime}`,
      "X-Stainless-Runtime": "edge",
      "X-Stainless-Runtime-Version": globalThis.process.version
    };
  if (t === "node")
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": Hg,
      "X-Stainless-OS": IF(globalThis.process.platform ?? "unknown"),
      "X-Stainless-Arch": cF(globalThis.process.arch ?? "unknown"),
      "X-Stainless-Runtime": "node",
      "X-Stainless-Runtime-Version": globalThis.process.version ?? "unknown"
    };
  const A = tH();
  return A ? {
    "X-Stainless-Lang": "js",
    "X-Stainless-Package-Version": Hg,
    "X-Stainless-OS": "Unknown",
    "X-Stainless-Arch": "unknown",
    "X-Stainless-Runtime": `browser:${A.browser}`,
    "X-Stainless-Runtime-Version": A.version
  } : {
    "X-Stainless-Lang": "js",
    "X-Stainless-Package-Version": Hg,
    "X-Stainless-OS": "Unknown",
    "X-Stainless-Arch": "unknown",
    "X-Stainless-Runtime": "unknown",
    "X-Stainless-Runtime-Version": "unknown"
  };
};
function tH() {
  if (typeof navigator > "u" || !navigator)
    return null;
  const t = [
    { key: "edge", pattern: /Edge(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "ie", pattern: /MSIE(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "ie", pattern: /Trident(?:.*rv\:(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "chrome", pattern: /Chrome(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "firefox", pattern: /Firefox(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "safari", pattern: /(?:Version\W+(\d+)\.(\d+)(?:\.(\d+))?)?(?:\W+Mobile\S*)?\W+Safari/ }
  ];
  for (const { key: A, pattern: e } of t) {
    const r = e.exec(navigator.userAgent);
    if (r) {
      const i = r[1] || 0, n = r[2] || 0, s = r[3] || 0;
      return { browser: A, version: `${i}.${n}.${s}` };
    }
  }
  return null;
}
const cF = (t) => t === "x32" ? "x32" : t === "x86_64" || t === "x64" ? "x64" : t === "arm" ? "arm" : t === "aarch64" || t === "arm64" ? "arm64" : t ? `other:${t}` : "unknown", IF = (t) => (t = t.toLowerCase(), t.includes("ios") ? "iOS" : t === "android" ? "Android" : t === "darwin" ? "MacOS" : t === "win32" ? "Windows" : t === "freebsd" ? "FreeBSD" : t === "openbsd" ? "OpenBSD" : t === "linux" ? "Linux" : t ? `Other:${t}` : "Unknown");
let CF;
const rH = () => CF ?? (CF = eH());
function iH() {
  if (typeof fetch < "u")
    return fetch;
  throw new Error("`fetch` is not defined as a global; Either pass `fetch` to the client, `new OpenAI({ fetch })` or polyfill the global, `globalThis.fetch = fetch`");
}
function Y_(...t) {
  const A = globalThis.ReadableStream;
  if (typeof A > "u")
    throw new Error("`ReadableStream` is not defined as a global; You will need to polyfill it, `globalThis.ReadableStream = ReadableStream`");
  return new A(...t);
}
function q_(t) {
  let A = Symbol.asyncIterator in t ? t[Symbol.asyncIterator]() : t[Symbol.iterator]();
  return Y_({
    start() {
    },
    async pull(e) {
      const { done: r, value: i } = await A.next();
      r ? e.close() : e.enqueue(i);
    },
    async cancel() {
      var e;
      await ((e = A.return) == null ? void 0 : e.call(A));
    }
  });
}
function j_(t) {
  if (t[Symbol.asyncIterator])
    return t;
  const A = t.getReader();
  return {
    async next() {
      try {
        const e = await A.read();
        return e != null && e.done && A.releaseLock(), e;
      } catch (e) {
        throw A.releaseLock(), e;
      }
    },
    async return() {
      const e = A.cancel();
      return A.releaseLock(), await e, { done: !0, value: void 0 };
    },
    [Symbol.asyncIterator]() {
      return this;
    }
  };
}
async function nH(t) {
  var r, i;
  if (t === null || typeof t != "object")
    return;
  if (t[Symbol.asyncIterator]) {
    await ((i = (r = t[Symbol.asyncIterator]()).return) == null ? void 0 : i.call(r));
    return;
  }
  const A = t.getReader(), e = A.cancel();
  A.releaseLock(), await e;
}
const sH = ({ headers: t, body: A }) => ({
  bodyHeaders: {
    "content-type": "application/json"
  },
  body: JSON.stringify(A)
}), W_ = "RFC3986", V_ = (t) => String(t), lF = {
  RFC1738: (t) => String(t).replace(/%20/g, "+"),
  RFC3986: V_
}, aH = "RFC1738";
let vw = (t, A) => (vw = Object.hasOwn ?? Function.prototype.call.bind(Object.prototype.hasOwnProperty), vw(t, A));
const Ui = /* @__PURE__ */ (() => {
  const t = [];
  for (let A = 0; A < 256; ++A)
    t.push("%" + ((A < 16 ? "0" : "") + A.toString(16)).toUpperCase());
  return t;
})(), Jp = 1024, oH = (t, A, e, r, i) => {
  if (t.length === 0)
    return t;
  let n = t;
  if (typeof t == "symbol" ? n = Symbol.prototype.toString.call(t) : typeof t != "string" && (n = String(t)), e === "iso-8859-1")
    return escape(n).replace(/%u[0-9a-f]{4}/gi, function(a) {
      return "%26%23" + parseInt(a.slice(2), 16) + "%3B";
    });
  let s = "";
  for (let a = 0; a < n.length; a += Jp) {
    const g = n.length >= Jp ? n.slice(a, a + Jp) : n, o = [];
    for (let u = 0; u < g.length; ++u) {
      let I = g.charCodeAt(u);
      if (I === 45 || // -
      I === 46 || // .
      I === 95 || // _
      I === 126 || // ~
      I >= 48 && I <= 57 || // 0-9
      I >= 65 && I <= 90 || // a-z
      I >= 97 && I <= 122 || // A-Z
      i === aH && (I === 40 || I === 41)) {
        o[o.length] = g.charAt(u);
        continue;
      }
      if (I < 128) {
        o[o.length] = Ui[I];
        continue;
      }
      if (I < 2048) {
        o[o.length] = Ui[192 | I >> 6] + Ui[128 | I & 63];
        continue;
      }
      if (I < 55296 || I >= 57344) {
        o[o.length] = Ui[224 | I >> 12] + Ui[128 | I >> 6 & 63] + Ui[128 | I & 63];
        continue;
      }
      u += 1, I = 65536 + ((I & 1023) << 10 | g.charCodeAt(u) & 1023), o[o.length] = Ui[240 | I >> 18] + Ui[128 | I >> 12 & 63] + Ui[128 | I >> 6 & 63] + Ui[128 | I & 63];
    }
    s += o.join("");
  }
  return s;
};
function gH(t) {
  return !t || typeof t != "object" ? !1 : !!(t.constructor && t.constructor.isBuffer && t.constructor.isBuffer(t));
}
function BF(t, A) {
  if (Qr(t)) {
    const e = [];
    for (let r = 0; r < t.length; r += 1)
      e.push(A(t[r]));
    return e;
  }
  return A(t);
}
const Z_ = {
  brackets(t) {
    return String(t) + "[]";
  },
  comma: "comma",
  indices(t, A) {
    return String(t) + "[" + A + "]";
  },
  repeat(t) {
    return String(t);
  }
}, X_ = function(t, A) {
  Array.prototype.push.apply(t, Qr(A) ? A : [A]);
};
let EF;
const Et = {
  addQueryPrefix: !1,
  allowDots: !1,
  allowEmptyArrays: !1,
  arrayFormat: "indices",
  charset: "utf-8",
  charsetSentinel: !1,
  delimiter: "&",
  encode: !0,
  encodeDotInKeys: !1,
  encoder: oH,
  encodeValuesOnly: !1,
  format: W_,
  formatter: V_,
  /** @deprecated */
  indices: !1,
  serializeDate(t) {
    return (EF ?? (EF = Function.prototype.call.bind(Date.prototype.toISOString)))(t);
  },
  skipNulls: !1,
  strictNullHandling: !1
};
function uH(t) {
  return typeof t == "string" || typeof t == "number" || typeof t == "boolean" || typeof t == "symbol" || typeof t == "bigint";
}
const Hp = {};
function z_(t, A, e, r, i, n, s, a, g, o, u, I, c, C, E, l, B, h) {
  let Q = t, f = h, p = 0, y = !1;
  for (; (f = f.get(Hp)) !== void 0 && !y; ) {
    const b = f.get(t);
    if (p += 1, typeof b < "u") {
      if (b === p)
        throw new RangeError("Cyclic object value");
      y = !0;
    }
    typeof f.get(Hp) > "u" && (p = 0);
  }
  if (typeof o == "function" ? Q = o(A, Q) : Q instanceof Date ? Q = c == null ? void 0 : c(Q) : e === "comma" && Qr(Q) && (Q = BF(Q, function(b) {
    return b instanceof Date ? c == null ? void 0 : c(b) : b;
  })), Q === null) {
    if (n)
      return g && !l ? (
        // @ts-expect-error
        g(A, Et.encoder, B, "key", C)
      ) : A;
    Q = "";
  }
  if (uH(Q) || gH(Q)) {
    if (g) {
      const b = l ? A : g(A, Et.encoder, B, "key", C);
      return [
        (E == null ? void 0 : E(b)) + "=" + // @ts-expect-error
        (E == null ? void 0 : E(g(Q, Et.encoder, B, "value", C)))
      ];
    }
    return [(E == null ? void 0 : E(A)) + "=" + (E == null ? void 0 : E(String(Q)))];
  }
  const m = [];
  if (typeof Q > "u")
    return m;
  let S;
  if (e === "comma" && Qr(Q))
    l && g && (Q = BF(Q, g)), S = [{ value: Q.length > 0 ? Q.join(",") || null : void 0 }];
  else if (Qr(o))
    S = o;
  else {
    const b = Object.keys(Q);
    S = u ? b.sort(u) : b;
  }
  const w = a ? String(A).replace(/\./g, "%2E") : String(A), F = r && Qr(Q) && Q.length === 1 ? w + "[]" : w;
  if (i && Qr(Q) && Q.length === 0)
    return F + "[]";
  for (let b = 0; b < S.length; ++b) {
    const G = S[b], T = (
      // @ts-ignore
      typeof G == "object" && typeof G.value < "u" ? G.value : Q[G]
    );
    if (s && T === null)
      continue;
    const K = I && a ? G.replace(/\./g, "%2E") : G, H = Qr(Q) ? typeof e == "function" ? e(F, K) : F : F + (I ? "." + K : "[" + K + "]");
    h.set(t, p);
    const j = /* @__PURE__ */ new WeakMap();
    j.set(Hp, h), X_(m, z_(
      T,
      H,
      e,
      r,
      i,
      n,
      s,
      a,
      // @ts-ignore
      e === "comma" && l && Qr(Q) ? null : g,
      o,
      u,
      I,
      c,
      C,
      E,
      l,
      B,
      j
    ));
  }
  return m;
}
function cH(t = Et) {
  if (typeof t.allowEmptyArrays < "u" && typeof t.allowEmptyArrays != "boolean")
    throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
  if (typeof t.encodeDotInKeys < "u" && typeof t.encodeDotInKeys != "boolean")
    throw new TypeError("`encodeDotInKeys` option can only be `true` or `false`, when provided");
  if (t.encoder !== null && typeof t.encoder < "u" && typeof t.encoder != "function")
    throw new TypeError("Encoder has to be a function.");
  const A = t.charset || Et.charset;
  if (typeof t.charset < "u" && t.charset !== "utf-8" && t.charset !== "iso-8859-1")
    throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
  let e = W_;
  if (typeof t.format < "u") {
    if (!vw(lF, t.format))
      throw new TypeError("Unknown format option provided.");
    e = t.format;
  }
  const r = lF[e];
  let i = Et.filter;
  (typeof t.filter == "function" || Qr(t.filter)) && (i = t.filter);
  let n;
  if (t.arrayFormat && t.arrayFormat in Z_ ? n = t.arrayFormat : "indices" in t ? n = t.indices ? "indices" : "repeat" : n = Et.arrayFormat, "commaRoundTrip" in t && typeof t.commaRoundTrip != "boolean")
    throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
  const s = typeof t.allowDots > "u" ? t.encodeDotInKeys ? !0 : Et.allowDots : !!t.allowDots;
  return {
    addQueryPrefix: typeof t.addQueryPrefix == "boolean" ? t.addQueryPrefix : Et.addQueryPrefix,
    // @ts-ignore
    allowDots: s,
    allowEmptyArrays: typeof t.allowEmptyArrays == "boolean" ? !!t.allowEmptyArrays : Et.allowEmptyArrays,
    arrayFormat: n,
    charset: A,
    charsetSentinel: typeof t.charsetSentinel == "boolean" ? t.charsetSentinel : Et.charsetSentinel,
    commaRoundTrip: !!t.commaRoundTrip,
    delimiter: typeof t.delimiter > "u" ? Et.delimiter : t.delimiter,
    encode: typeof t.encode == "boolean" ? t.encode : Et.encode,
    encodeDotInKeys: typeof t.encodeDotInKeys == "boolean" ? t.encodeDotInKeys : Et.encodeDotInKeys,
    encoder: typeof t.encoder == "function" ? t.encoder : Et.encoder,
    encodeValuesOnly: typeof t.encodeValuesOnly == "boolean" ? t.encodeValuesOnly : Et.encodeValuesOnly,
    filter: i,
    format: e,
    formatter: r,
    serializeDate: typeof t.serializeDate == "function" ? t.serializeDate : Et.serializeDate,
    skipNulls: typeof t.skipNulls == "boolean" ? t.skipNulls : Et.skipNulls,
    // @ts-ignore
    sort: typeof t.sort == "function" ? t.sort : null,
    strictNullHandling: typeof t.strictNullHandling == "boolean" ? t.strictNullHandling : Et.strictNullHandling
  };
}
function IH(t, A = {}) {
  let e = t;
  const r = cH(A);
  let i, n;
  typeof r.filter == "function" ? (n = r.filter, e = n("", e)) : Qr(r.filter) && (n = r.filter, i = n);
  const s = [];
  if (typeof e != "object" || e === null)
    return "";
  const a = Z_[r.arrayFormat], g = a === "comma" && r.commaRoundTrip;
  i || (i = Object.keys(e)), r.sort && i.sort(r.sort);
  const o = /* @__PURE__ */ new WeakMap();
  for (let c = 0; c < i.length; ++c) {
    const C = i[c];
    r.skipNulls && e[C] === null || X_(s, z_(
      e[C],
      C,
      // @ts-expect-error
      a,
      g,
      r.allowEmptyArrays,
      r.strictNullHandling,
      r.skipNulls,
      r.encodeDotInKeys,
      r.encode ? r.encoder : null,
      r.filter,
      r.sort,
      r.allowDots,
      r.serializeDate,
      r.format,
      r.formatter,
      r.encodeValuesOnly,
      r.charset,
      o
    ));
  }
  const u = s.join(r.delimiter);
  let I = r.addQueryPrefix === !0 ? "?" : "";
  return r.charsetSentinel && (r.charset === "iso-8859-1" ? I += "utf8=%26%2310003%3B&" : I += "utf8=%E2%9C%93&"), u.length > 0 ? I + u : "";
}
function CH(t) {
  let A = 0;
  for (const i of t)
    A += i.length;
  const e = new Uint8Array(A);
  let r = 0;
  for (const i of t)
    e.set(i, r), r += i.length;
  return e;
}
let hF;
function XD(t) {
  let A;
  return (hF ?? (A = new globalThis.TextEncoder(), hF = A.encode.bind(A)))(t);
}
let QF;
function dF(t) {
  let A;
  return (QF ?? (A = new globalThis.TextDecoder(), QF = A.decode.bind(A)))(t);
}
var Dr, Sr;
class Nf {
  constructor() {
    Dr.set(this, void 0), Sr.set(this, void 0), $A(this, Dr, new Uint8Array()), $A(this, Sr, null);
  }
  decode(A) {
    if (A == null)
      return [];
    const e = A instanceof ArrayBuffer ? new Uint8Array(A) : typeof A == "string" ? XD(A) : A;
    $A(this, Dr, CH([$(this, Dr, "f"), e]));
    const r = [];
    let i;
    for (; (i = lH($(this, Dr, "f"), $(this, Sr, "f"))) != null; ) {
      if (i.carriage && $(this, Sr, "f") == null) {
        $A(this, Sr, i.index);
        continue;
      }
      if ($(this, Sr, "f") != null && (i.index !== $(this, Sr, "f") + 1 || i.carriage)) {
        r.push(dF($(this, Dr, "f").subarray(0, $(this, Sr, "f") - 1))), $A(this, Dr, $(this, Dr, "f").subarray($(this, Sr, "f"))), $A(this, Sr, null);
        continue;
      }
      const n = $(this, Sr, "f") !== null ? i.preceding - 1 : i.preceding, s = dF($(this, Dr, "f").subarray(0, n));
      r.push(s), $A(this, Dr, $(this, Dr, "f").subarray(i.index)), $A(this, Sr, null);
    }
    return r;
  }
  flush() {
    return $(this, Dr, "f").length ? this.decode(`
`) : [];
  }
}
Dr = /* @__PURE__ */ new WeakMap(), Sr = /* @__PURE__ */ new WeakMap();
Nf.NEWLINE_CHARS = /* @__PURE__ */ new Set([`
`, "\r"]);
Nf.NEWLINE_REGEXP = /\r\n|[\n\r]/g;
function lH(t, A) {
  for (let i = A ?? 0; i < t.length; i++) {
    if (t[i] === 10)
      return { preceding: i, index: i + 1, carriage: !1 };
    if (t[i] === 13)
      return { preceding: i, index: i + 1, carriage: !0 };
  }
  return null;
}
function BH(t) {
  for (let r = 0; r < t.length - 1; r++) {
    if (t[r] === 10 && t[r + 1] === 10 || t[r] === 13 && t[r + 1] === 13)
      return r + 2;
    if (t[r] === 13 && t[r + 1] === 10 && r + 3 < t.length && t[r + 2] === 13 && t[r + 3] === 10)
      return r + 4;
  }
  return -1;
}
const gd = {
  off: 0,
  error: 200,
  warn: 300,
  info: 400,
  debug: 500
}, fF = (t, A, e) => {
  if (t) {
    if (ZJ(gd, t))
      return t;
    Jt(e).warn(`${A} was set to ${JSON.stringify(t)}, expected one of ${JSON.stringify(Object.keys(gd))}`);
  }
};
function IC() {
}
function Ah(t, A, e) {
  return !A || gd[t] > gd[e] ? IC : A[t].bind(A);
}
const EH = {
  error: IC,
  warn: IC,
  info: IC,
  debug: IC
};
let pF = /* @__PURE__ */ new WeakMap();
function Jt(t) {
  const A = t.logger, e = t.logLevel ?? "off";
  if (!A)
    return EH;
  const r = pF.get(A);
  if (r && r[0] === e)
    return r[1];
  const i = {
    error: Ah("error", A, e),
    warn: Ah("warn", A, e),
    info: Ah("info", A, e),
    debug: Ah("debug", A, e)
  };
  return pF.set(A, [e, i]), i;
}
const $a = (t) => (t.options && (t.options = { ...t.options }, delete t.options.headers), t.headers && (t.headers = Object.fromEntries((t.headers instanceof Headers ? [...t.headers] : Object.entries(t.headers)).map(([A, e]) => [
  A,
  A.toLowerCase() === "authorization" || A.toLowerCase() === "cookie" || A.toLowerCase() === "set-cookie" ? "***" : e
]))), "retryOfRequestLogID" in t && (t.retryOfRequestLogID && (t.retryOf = t.retryOfRequestLogID), delete t.retryOfRequestLogID), t);
var hI;
class cn {
  constructor(A, e, r) {
    this.iterator = A, hI.set(this, void 0), this.controller = e, $A(this, hI, r);
  }
  static fromSSEResponse(A, e, r) {
    let i = !1;
    const n = r ? Jt(r) : console;
    async function* s() {
      if (i)
        throw new jA("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
      i = !0;
      let a = !1;
      try {
        for await (const g of hH(A, e))
          if (!a) {
            if (g.data.startsWith("[DONE]")) {
              a = !0;
              continue;
            }
            if (g.event === null || !g.event.startsWith("thread.")) {
              let o;
              try {
                o = JSON.parse(g.data);
              } catch (u) {
                throw n.error("Could not parse message into JSON:", g.data), n.error("From chunk:", g.raw), u;
              }
              if (o && o.error)
                throw new Wt(void 0, o.error, void 0, A.headers);
              yield o;
            } else {
              let o;
              try {
                o = JSON.parse(g.data);
              } catch (u) {
                throw console.error("Could not parse message into JSON:", g.data), console.error("From chunk:", g.raw), u;
              }
              if (g.event == "error")
                throw new Wt(void 0, o.error, o.message, void 0);
              yield { event: g.event, data: o };
            }
          }
        a = !0;
      } catch (g) {
        if (Fw(g))
          return;
        throw g;
      } finally {
        a || e.abort();
      }
    }
    return new cn(s, e, r);
  }
  /**
   * Generates a Stream from a newline-separated ReadableStream
   * where each item is a JSON value.
   */
  static fromReadableStream(A, e, r) {
    let i = !1;
    async function* n() {
      const a = new Nf(), g = j_(A);
      for await (const o of g)
        for (const u of a.decode(o))
          yield u;
      for (const o of a.flush())
        yield o;
    }
    async function* s() {
      if (i)
        throw new jA("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
      i = !0;
      let a = !1;
      try {
        for await (const g of n())
          a || g && (yield JSON.parse(g));
        a = !0;
      } catch (g) {
        if (Fw(g))
          return;
        throw g;
      } finally {
        a || e.abort();
      }
    }
    return new cn(s, e, r);
  }
  [(hI = /* @__PURE__ */ new WeakMap(), Symbol.asyncIterator)]() {
    return this.iterator();
  }
  /**
   * Splits the stream into two streams which can be
   * independently read from at different speeds.
   */
  tee() {
    const A = [], e = [], r = this.iterator(), i = (n) => ({
      next: () => {
        if (n.length === 0) {
          const s = r.next();
          A.push(s), e.push(s);
        }
        return n.shift();
      }
    });
    return [
      new cn(() => i(A), this.controller, $(this, hI, "f")),
      new cn(() => i(e), this.controller, $(this, hI, "f"))
    ];
  }
  /**
   * Converts this stream to a newline-separated ReadableStream of
   * JSON stringified values in the stream
   * which can be turned back into a Stream with `Stream.fromReadableStream()`.
   */
  toReadableStream() {
    const A = this;
    let e;
    return Y_({
      async start() {
        e = A[Symbol.asyncIterator]();
      },
      async pull(r) {
        try {
          const { value: i, done: n } = await e.next();
          if (n)
            return r.close();
          const s = XD(JSON.stringify(i) + `
`);
          r.enqueue(s);
        } catch (i) {
          r.error(i);
        }
      },
      async cancel() {
        var r;
        await ((r = e.return) == null ? void 0 : r.call(e));
      }
    });
  }
}
async function* hH(t, A) {
  if (!t.body)
    throw A.abort(), typeof globalThis.navigator < "u" && globalThis.navigator.product === "ReactNative" ? new jA("The default react-native fetch implementation does not support streaming. Please use expo/fetch: https://docs.expo.dev/versions/latest/sdk/expo/#expofetch-api") : new jA("Attempted to iterate over a response with no body");
  const e = new dH(), r = new Nf(), i = j_(t.body);
  for await (const n of QH(i))
    for (const s of r.decode(n)) {
      const a = e.decode(s);
      a && (yield a);
    }
  for (const n of r.flush()) {
    const s = e.decode(n);
    s && (yield s);
  }
}
async function* QH(t) {
  let A = new Uint8Array();
  for await (const e of t) {
    if (e == null)
      continue;
    const r = e instanceof ArrayBuffer ? new Uint8Array(e) : typeof e == "string" ? XD(e) : e;
    let i = new Uint8Array(A.length + r.length);
    i.set(A), i.set(r, A.length), A = i;
    let n;
    for (; (n = BH(A)) !== -1; )
      yield A.slice(0, n), A = A.slice(n);
  }
  A.length > 0 && (yield A);
}
class dH {
  constructor() {
    this.event = null, this.data = [], this.chunks = [];
  }
  decode(A) {
    if (A.endsWith("\r") && (A = A.substring(0, A.length - 1)), !A) {
      if (!this.event && !this.data.length)
        return null;
      const n = {
        event: this.event,
        data: this.data.join(`
`),
        raw: this.chunks
      };
      return this.event = null, this.data = [], this.chunks = [], n;
    }
    if (this.chunks.push(A), A.startsWith(":"))
      return null;
    let [e, r, i] = fH(A, ":");
    return i.startsWith(" ") && (i = i.substring(1)), e === "event" ? this.event = i : e === "data" && this.data.push(i), null;
  }
}
function fH(t, A) {
  const e = t.indexOf(A);
  return e !== -1 ? [t.substring(0, e), A, t.substring(e + A.length)] : [t, "", ""];
}
async function $_(t, A) {
  const { response: e, requestLogID: r, retryOfRequestLogID: i, startTime: n } = A, s = await (async () => {
    var I;
    if (A.options.stream)
      return Jt(t).debug("response", e.status, e.url, e.headers, e.body), A.options.__streamClass ? A.options.__streamClass.fromSSEResponse(e, A.controller, t) : cn.fromSSEResponse(e, A.controller, t);
    if (e.status === 204)
      return null;
    if (A.options.__binaryResponse)
      return e;
    const a = e.headers.get("content-type"), g = (I = a == null ? void 0 : a.split(";")[0]) == null ? void 0 : I.trim();
    if ((g == null ? void 0 : g.includes("application/json")) || (g == null ? void 0 : g.endsWith("+json"))) {
      const c = await e.json();
      return AN(c, e);
    }
    return await e.text();
  })();
  return Jt(t).debug(`[${r}] response parsed`, $a({
    retryOfRequestLogID: i,
    url: e.url,
    status: e.status,
    body: s,
    durationMs: Date.now() - n
  })), s;
}
function AN(t, A) {
  return !t || typeof t != "object" || Array.isArray(t) ? t : Object.defineProperty(t, "_request_id", {
    value: A.headers.get("x-request-id"),
    enumerable: !1
  });
}
var CC;
class Lf extends Promise {
  constructor(A, e, r = $_) {
    super((i) => {
      i(null);
    }), this.responsePromise = e, this.parseResponse = r, CC.set(this, void 0), $A(this, CC, A);
  }
  _thenUnwrap(A) {
    return new Lf($(this, CC, "f"), this.responsePromise, async (e, r) => AN(A(await this.parseResponse(e, r), r), r.response));
  }
  /**
   * Gets the raw `Response` instance instead of parsing the response
   * data.
   *
   * If you want to parse the response body but still get the `Response`
   * instance, you can use {@link withResponse()}.
   *
   * ðŸ‘‹ Getting the wrong TypeScript type for `Response`?
   * Try setting `"moduleResolution": "NodeNext"` or add `"lib": ["DOM"]`
   * to your `tsconfig.json`.
   */
  asResponse() {
    return this.responsePromise.then((A) => A.response);
  }
  /**
   * Gets the parsed response data, the raw `Response` instance and the ID of the request,
   * returned via the X-Request-ID header which is useful for debugging requests and reporting
   * issues to OpenAI.
   *
   * If you just want to get the raw `Response` instance without parsing it,
   * you can use {@link asResponse()}.
   *
   * ðŸ‘‹ Getting the wrong TypeScript type for `Response`?
   * Try setting `"moduleResolution": "NodeNext"` or add `"lib": ["DOM"]`
   * to your `tsconfig.json`.
   */
  async withResponse() {
    const [A, e] = await Promise.all([this.parse(), this.asResponse()]);
    return { data: A, response: e, request_id: e.headers.get("x-request-id") };
  }
  parse() {
    return this.parsedPromise || (this.parsedPromise = this.responsePromise.then((A) => this.parseResponse($(this, CC, "f"), A))), this.parsedPromise;
  }
  then(A, e) {
    return this.parse().then(A, e);
  }
  catch(A) {
    return this.parse().catch(A);
  }
  finally(A) {
    return this.parse().finally(A);
  }
}
CC = /* @__PURE__ */ new WeakMap();
var eh;
class zD {
  constructor(A, e, r, i) {
    eh.set(this, void 0), $A(this, eh, A), this.options = i, this.response = e, this.body = r;
  }
  hasNextPage() {
    return this.getPaginatedItems().length ? this.nextPageRequestOptions() != null : !1;
  }
  async getNextPage() {
    const A = this.nextPageRequestOptions();
    if (!A)
      throw new jA("No next page expected; please check `.hasNextPage()` before calling `.getNextPage()`.");
    return await $(this, eh, "f").requestAPIList(this.constructor, A);
  }
  async *iterPages() {
    let A = this;
    for (yield A; A.hasNextPage(); )
      A = await A.getNextPage(), yield A;
  }
  async *[(eh = /* @__PURE__ */ new WeakMap(), Symbol.asyncIterator)]() {
    for await (const A of this.iterPages())
      for (const e of A.getPaginatedItems())
        yield e;
  }
}
class pH extends Lf {
  constructor(A, e, r) {
    super(A, e, async (i, n) => new r(i, n.response, await $_(i, n), n.options));
  }
  /**
   * Allow auto-paginating iteration on an unawaited list call, eg:
   *
   *    for await (const item of client.items.list()) {
   *      console.log(item)
   *    }
   */
  async *[Symbol.asyncIterator]() {
    const A = await this;
    for await (const e of A)
      yield e;
  }
}
let xf = class extends zD {
  constructor(A, e, r, i) {
    super(A, e, r, i), this.data = r.data || [], this.object = r.object;
  }
  getPaginatedItems() {
    return this.data ?? [];
  }
  nextPageRequestOptions() {
    return null;
  }
};
class ct extends zD {
  constructor(A, e, r, i) {
    super(A, e, r, i), this.data = r.data || [], this.has_more = r.has_more || !1;
  }
  getPaginatedItems() {
    return this.data ?? [];
  }
  hasNextPage() {
    return this.has_more === !1 ? !1 : super.hasNextPage();
  }
  nextPageRequestOptions() {
    var r;
    const A = this.getPaginatedItems(), e = (r = A[A.length - 1]) == null ? void 0 : r.id;
    return e ? {
      ...this.options,
      query: {
        ...O_(this.options.query),
        after: e
      }
    } : null;
  }
}
class ud extends zD {
  constructor(A, e, r, i) {
    super(A, e, r, i), this.data = r.data || [], this.has_more = r.has_more || !1, this.last_id = r.last_id || "";
  }
  getPaginatedItems() {
    return this.data ?? [];
  }
  hasNextPage() {
    return this.has_more === !1 ? !1 : super.hasNextPage();
  }
  nextPageRequestOptions() {
    const A = this.last_id;
    return A ? {
      ...this.options,
      query: {
        ...O_(this.options.query),
        after: A
      }
    } : null;
  }
}
const eN = () => {
  var t;
  if (typeof File > "u") {
    const { process: A } = globalThis, e = typeof ((t = A == null ? void 0 : A.versions) == null ? void 0 : t.node) == "string" && parseInt(A.versions.node.split(".")) < 20;
    throw new Error("`File` is not defined as a global, which is required for file uploads." + (e ? " Update to Node 20 LTS or newer, or set `globalThis.File` to `import('node:buffer').File`." : ""));
  }
};
function _C(t, A, e) {
  return eN(), new File(t, A ?? "unknown_file", e);
}
function FQ(t) {
  return (typeof t == "object" && t !== null && ("name" in t && t.name && String(t.name) || "url" in t && t.url && String(t.url) || "filename" in t && t.filename && String(t.filename) || "path" in t && t.path && String(t.path)) || "").split(/[\\/]/).pop() || void 0;
}
const $D = (t) => t != null && typeof t == "object" && typeof t[Symbol.asyncIterator] == "function", yF = async (t, A) => Rw(t.body) ? { ...t, body: await tN(t.body, A) } : t, Cg = async (t, A) => ({ ...t, body: await tN(t.body, A) }), wF = /* @__PURE__ */ new WeakMap();
function yH(t) {
  const A = typeof t == "function" ? t : t.fetch, e = wF.get(A);
  if (e)
    return e;
  const r = (async () => {
    try {
      const i = "Response" in A ? A.Response : (await A("data:,")).constructor, n = new FormData();
      return n.toString() !== await new i(n).text();
    } catch {
      return !0;
    }
  })();
  return wF.set(A, r), r;
}
const tN = async (t, A) => {
  if (!await yH(A))
    throw new TypeError("The provided fetch function does not support file uploads with the current global FormData class.");
  const e = new FormData();
  return await Promise.all(Object.entries(t || {}).map(([r, i]) => bw(e, r, i))), e;
}, rN = (t) => t instanceof Blob && "name" in t, wH = (t) => typeof t == "object" && t !== null && (t instanceof Response || $D(t) || rN(t)), Rw = (t) => {
  if (wH(t))
    return !0;
  if (Array.isArray(t))
    return t.some(Rw);
  if (t && typeof t == "object") {
    for (const A in t)
      if (Rw(t[A]))
        return !0;
  }
  return !1;
}, bw = async (t, A, e) => {
  if (e !== void 0) {
    if (e == null)
      throw new TypeError(`Received null for "${A}"; to pass null in FormData, you must use the string 'null'`);
    if (typeof e == "string" || typeof e == "number" || typeof e == "boolean")
      t.append(A, String(e));
    else if (e instanceof Response)
      t.append(A, _C([await e.blob()], FQ(e)));
    else if ($D(e))
      t.append(A, _C([await new Response(q_(e)).blob()], FQ(e)));
    else if (rN(e))
      t.append(A, e, FQ(e));
    else if (Array.isArray(e))
      await Promise.all(e.map((r) => bw(t, A + "[]", r)));
    else if (typeof e == "object")
      await Promise.all(Object.entries(e).map(([r, i]) => bw(t, `${A}[${r}]`, i)));
    else
      throw new TypeError(`Invalid value given to form, expected a string, number, boolean, object, Array, File or Blob but got ${e} instead`);
  }
}, iN = (t) => t != null && typeof t == "object" && typeof t.size == "number" && typeof t.type == "string" && typeof t.text == "function" && typeof t.slice == "function" && typeof t.arrayBuffer == "function", mH = (t) => t != null && typeof t == "object" && typeof t.name == "string" && typeof t.lastModified == "number" && iN(t), DH = (t) => t != null && typeof t == "object" && typeof t.url == "string" && typeof t.blob == "function";
async function SH(t, A, e) {
  if (eN(), t = await t, mH(t))
    return t instanceof File ? t : _C([await t.arrayBuffer()], t.name);
  if (DH(t)) {
    const i = await t.blob();
    return A || (A = new URL(t.url).pathname.split(/[\\/]/).pop()), _C(await Mw(i), A, e);
  }
  const r = await Mw(t);
  if (A || (A = FQ(t)), !(e != null && e.type)) {
    const i = r.find((n) => typeof n == "object" && "type" in n && n.type);
    typeof i == "string" && (e = { ...e, type: i });
  }
  return _C(r, A, e);
}
async function Mw(t) {
  var e;
  let A = [];
  if (typeof t == "string" || ArrayBuffer.isView(t) || // includes Uint8Array, Buffer, etc.
  t instanceof ArrayBuffer)
    A.push(t);
  else if (iN(t))
    A.push(t instanceof Blob ? t : await t.arrayBuffer());
  else if ($D(t))
    for await (const r of t)
      A.push(...await Mw(r));
  else {
    const r = (e = t == null ? void 0 : t.constructor) == null ? void 0 : e.name;
    throw new Error(`Unexpected data type: ${typeof t}${r ? `; constructor: ${r}` : ""}${FH(t)}`);
  }
  return A;
}
function FH(t) {
  return typeof t != "object" || t === null ? "" : `; props: [${Object.getOwnPropertyNames(t).map((e) => `"${e}"`).join(", ")}]`;
}
class qA {
  constructor(A) {
    this._client = A;
  }
}
function nN(t) {
  return t.replace(/[^A-Za-z0-9\-._~!$&'()*+,;=:@]+/g, encodeURIComponent);
}
const mF = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.create(null)), kH = (t = nN) => function(e, ...r) {
  if (e.length === 1)
    return e[0];
  let i = !1;
  const n = [], s = e.reduce((u, I, c) => {
    var l;
    /[?#]/.test(I) && (i = !0);
    const C = r[c];
    let E = (i ? encodeURIComponent : t)("" + C);
    return c !== r.length && (C == null || typeof C == "object" && // handle values from other realms
    C.toString === ((l = Object.getPrototypeOf(Object.getPrototypeOf(C.hasOwnProperty ?? mF) ?? mF)) == null ? void 0 : l.toString)) && (E = C + "", n.push({
      start: u.length + I.length,
      length: E.length,
      error: `Value of type ${Object.prototype.toString.call(C).slice(8, -1)} is not a valid path parameter`
    })), u + I + (c === r.length ? "" : E);
  }, ""), a = s.split(/[?#]/, 1)[0], g = new RegExp("(?<=^|\\/)(?:\\.|%2e){1,2}(?=\\/|$)", "gi");
  let o;
  for (; (o = g.exec(a)) !== null; )
    n.push({
      start: o.index,
      length: o[0].length,
      error: `Value "${o[0]}" can't be safely passed as a path parameter`
    });
  if (n.sort((u, I) => u.start - I.start), n.length > 0) {
    let u = 0;
    const I = n.reduce((c, C) => {
      const E = " ".repeat(C.start - u), l = "^".repeat(C.length);
      return u = C.start + C.length, c + E + l;
    }, "");
    throw new jA(`Path parameters result in path with invalid segments:
${n.map((c) => c.error).join(`
`)}
${s}
${I}`);
  }
  return s;
}, yA = /* @__PURE__ */ kH(nN);
let sN = class extends qA {
  /**
   * Get the messages in a stored chat completion. Only Chat Completions that have
   * been created with the `store` parameter set to `true` will be returned.
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const chatCompletionStoreMessage of client.chat.completions.messages.list(
   *   'completion_id',
   * )) {
   *   // ...
   * }
   * ```
   */
  list(A, e = {}, r) {
    return this._client.getAPIList(yA`/chat/completions/${A}/messages`, ct, { query: e, ...r });
  }
};
function cd(t) {
  return t !== void 0 && "function" in t && t.function !== void 0;
}
function vH(t, A) {
  const e = { ...t };
  return Object.defineProperties(e, {
    $brand: {
      value: "auto-parseable-response-format",
      enumerable: !1
    },
    $parseRaw: {
      value: A,
      enumerable: !1
    }
  }), e;
}
function A0(t) {
  return (t == null ? void 0 : t.$brand) === "auto-parseable-response-format";
}
function kE(t) {
  return (t == null ? void 0 : t.$brand) === "auto-parseable-tool";
}
function RH(t, A) {
  return !A || !aN(A) ? {
    ...t,
    choices: t.choices.map((e) => (oN(e.message.tool_calls), {
      ...e,
      message: {
        ...e.message,
        parsed: null,
        ...e.message.tool_calls ? {
          tool_calls: e.message.tool_calls
        } : void 0
      }
    }))
  } : e0(t, A);
}
function e0(t, A) {
  const e = t.choices.map((r) => {
    var i;
    if (r.finish_reason === "length")
      throw new H_();
    if (r.finish_reason === "content_filter")
      throw new P_();
    return oN(r.message.tool_calls), {
      ...r,
      message: {
        ...r.message,
        ...r.message.tool_calls ? {
          tool_calls: ((i = r.message.tool_calls) == null ? void 0 : i.map((n) => MH(A, n))) ?? void 0
        } : void 0,
        parsed: r.message.content && !r.message.refusal ? bH(A, r.message.content) : null
      }
    };
  });
  return { ...t, choices: e };
}
function bH(t, A) {
  var e, r;
  return ((e = t.response_format) == null ? void 0 : e.type) !== "json_schema" ? null : ((r = t.response_format) == null ? void 0 : r.type) === "json_schema" ? "$parseRaw" in t.response_format ? t.response_format.$parseRaw(A) : JSON.parse(A) : null;
}
function MH(t, A) {
  var r;
  const e = (r = t.tools) == null ? void 0 : r.find((i) => {
    var n;
    return cd(i) && ((n = i.function) == null ? void 0 : n.name) === A.function.name;
  });
  return {
    ...A,
    function: {
      ...A.function,
      parsed_arguments: kE(e) ? e.$parseRaw(A.function.arguments) : e != null && e.function.strict ? JSON.parse(A.function.arguments) : null
    }
  };
}
function _H(t, A) {
  var r;
  if (!t || !("tools" in t) || !t.tools)
    return !1;
  const e = (r = t.tools) == null ? void 0 : r.find((i) => {
    var n;
    return cd(i) && ((n = i.function) == null ? void 0 : n.name) === A.function.name;
  });
  return cd(e) && (kE(e) || (e == null ? void 0 : e.function.strict) || !1);
}
function aN(t) {
  var A;
  return A0(t.response_format) ? !0 : ((A = t.tools) == null ? void 0 : A.some((e) => kE(e) || e.type === "function" && e.function.strict === !0)) ?? !1;
}
function oN(t) {
  for (const A of t || [])
    if (A.type !== "function")
      throw new jA(`Currently only \`function\` tool calls are supported; Received \`${A.type}\``);
}
function NH(t) {
  for (const A of t ?? []) {
    if (A.type !== "function")
      throw new jA(`Currently only \`function\` tool types support auto-parsing; Received \`${A.type}\``);
    if (A.function.strict !== !0)
      throw new jA(`The \`${A.function.name}\` tool is not marked with \`strict: true\`. Only strict function tools can be auto-parsed`);
  }
}
const Id = (t) => (t == null ? void 0 : t.role) === "assistant", gN = (t) => (t == null ? void 0 : t.role) === "tool";
var _w, kQ, vQ, lC, BC, RQ, EC, Kn, hC, Cd, ld, Pg, uN;
class t0 {
  constructor() {
    _w.add(this), this.controller = new AbortController(), kQ.set(this, void 0), vQ.set(this, () => {
    }), lC.set(this, () => {
    }), BC.set(this, void 0), RQ.set(this, () => {
    }), EC.set(this, () => {
    }), Kn.set(this, {}), hC.set(this, !1), Cd.set(this, !1), ld.set(this, !1), Pg.set(this, !1), $A(this, kQ, new Promise((A, e) => {
      $A(this, vQ, A, "f"), $A(this, lC, e, "f");
    })), $A(this, BC, new Promise((A, e) => {
      $A(this, RQ, A, "f"), $A(this, EC, e, "f");
    })), $(this, kQ, "f").catch(() => {
    }), $(this, BC, "f").catch(() => {
    });
  }
  _run(A) {
    setTimeout(() => {
      A().then(() => {
        this._emitFinal(), this._emit("end");
      }, $(this, _w, "m", uN).bind(this));
    }, 0);
  }
  _connected() {
    this.ended || ($(this, vQ, "f").call(this), this._emit("connect"));
  }
  get ended() {
    return $(this, hC, "f");
  }
  get errored() {
    return $(this, Cd, "f");
  }
  get aborted() {
    return $(this, ld, "f");
  }
  abort() {
    this.controller.abort();
  }
  /**
   * Adds the listener function to the end of the listeners array for the event.
   * No checks are made to see if the listener has already been added. Multiple calls passing
   * the same combination of event and listener will result in the listener being added, and
   * called, multiple times.
   * @returns this ChatCompletionStream, so that calls can be chained
   */
  on(A, e) {
    return ($(this, Kn, "f")[A] || ($(this, Kn, "f")[A] = [])).push({ listener: e }), this;
  }
  /**
   * Removes the specified listener from the listener array for the event.
   * off() will remove, at most, one instance of a listener from the listener array. If any single
   * listener has been added multiple times to the listener array for the specified event, then
   * off() must be called multiple times to remove each instance.
   * @returns this ChatCompletionStream, so that calls can be chained
   */
  off(A, e) {
    const r = $(this, Kn, "f")[A];
    if (!r)
      return this;
    const i = r.findIndex((n) => n.listener === e);
    return i >= 0 && r.splice(i, 1), this;
  }
  /**
   * Adds a one-time listener function for the event. The next time the event is triggered,
   * this listener is removed and then invoked.
   * @returns this ChatCompletionStream, so that calls can be chained
   */
  once(A, e) {
    return ($(this, Kn, "f")[A] || ($(this, Kn, "f")[A] = [])).push({ listener: e, once: !0 }), this;
  }
  /**
   * This is similar to `.once()`, but returns a Promise that resolves the next time
   * the event is triggered, instead of calling a listener callback.
   * @returns a Promise that resolves the next time given event is triggered,
   * or rejects if an error is emitted.  (If you request the 'error' event,
   * returns a promise that resolves with the error).
   *
   * Example:
   *
   *   const message = await stream.emitted('message') // rejects if the stream errors
   */
  emitted(A) {
    return new Promise((e, r) => {
      $A(this, Pg, !0), A !== "error" && this.once("error", r), this.once(A, e);
    });
  }
  async done() {
    $A(this, Pg, !0), await $(this, BC, "f");
  }
  _emit(A, ...e) {
    if ($(this, hC, "f"))
      return;
    A === "end" && ($A(this, hC, !0), $(this, RQ, "f").call(this));
    const r = $(this, Kn, "f")[A];
    if (r && ($(this, Kn, "f")[A] = r.filter((i) => !i.once), r.forEach(({ listener: i }) => i(...e))), A === "abort") {
      const i = e[0];
      !$(this, Pg, "f") && !(r != null && r.length) && Promise.reject(i), $(this, lC, "f").call(this, i), $(this, EC, "f").call(this, i), this._emit("end");
      return;
    }
    if (A === "error") {
      const i = e[0];
      !$(this, Pg, "f") && !(r != null && r.length) && Promise.reject(i), $(this, lC, "f").call(this, i), $(this, EC, "f").call(this, i), this._emit("end");
    }
  }
  _emitFinal() {
  }
}
kQ = /* @__PURE__ */ new WeakMap(), vQ = /* @__PURE__ */ new WeakMap(), lC = /* @__PURE__ */ new WeakMap(), BC = /* @__PURE__ */ new WeakMap(), RQ = /* @__PURE__ */ new WeakMap(), EC = /* @__PURE__ */ new WeakMap(), Kn = /* @__PURE__ */ new WeakMap(), hC = /* @__PURE__ */ new WeakMap(), Cd = /* @__PURE__ */ new WeakMap(), ld = /* @__PURE__ */ new WeakMap(), Pg = /* @__PURE__ */ new WeakMap(), _w = /* @__PURE__ */ new WeakSet(), uN = function(A) {
  if ($A(this, Cd, !0), A instanceof Error && A.name === "AbortError" && (A = new Ur()), A instanceof Ur)
    return $A(this, ld, !0), this._emit("abort", A);
  if (A instanceof jA)
    return this._emit("error", A);
  if (A instanceof Error) {
    const e = new jA(A.message);
    return e.cause = A, this._emit("error", e);
  }
  return this._emit("error", new jA(String(A)));
};
function LH(t) {
  return typeof t.parse == "function";
}
var tr, Nw, Bd, Lw, xw, Gw, cN, IN;
const xH = 10;
class CN extends t0 {
  constructor() {
    super(...arguments), tr.add(this), this._chatCompletions = [], this.messages = [];
  }
  _addChatCompletion(A) {
    var r;
    this._chatCompletions.push(A), this._emit("chatCompletion", A);
    const e = (r = A.choices[0]) == null ? void 0 : r.message;
    return e && this._addMessage(e), A;
  }
  _addMessage(A, e = !0) {
    if ("content" in A || (A.content = null), this.messages.push(A), e) {
      if (this._emit("message", A), gN(A) && A.content)
        this._emit("functionToolCallResult", A.content);
      else if (Id(A) && A.tool_calls)
        for (const r of A.tool_calls)
          r.type === "function" && this._emit("functionToolCall", r.function);
    }
  }
  /**
   * @returns a promise that resolves with the final ChatCompletion, or rejects
   * if an error occurred or the stream ended prematurely without producing a ChatCompletion.
   */
  async finalChatCompletion() {
    await this.done();
    const A = this._chatCompletions[this._chatCompletions.length - 1];
    if (!A)
      throw new jA("stream ended without producing a ChatCompletion");
    return A;
  }
  /**
   * @returns a promise that resolves with the content of the final ChatCompletionMessage, or rejects
   * if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.
   */
  async finalContent() {
    return await this.done(), $(this, tr, "m", Nw).call(this);
  }
  /**
   * @returns a promise that resolves with the the final assistant ChatCompletionMessage response,
   * or rejects if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.
   */
  async finalMessage() {
    return await this.done(), $(this, tr, "m", Bd).call(this);
  }
  /**
   * @returns a promise that resolves with the content of the final FunctionCall, or rejects
   * if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.
   */
  async finalFunctionToolCall() {
    return await this.done(), $(this, tr, "m", Lw).call(this);
  }
  async finalFunctionToolCallResult() {
    return await this.done(), $(this, tr, "m", xw).call(this);
  }
  async totalUsage() {
    return await this.done(), $(this, tr, "m", Gw).call(this);
  }
  allChatCompletions() {
    return [...this._chatCompletions];
  }
  _emitFinal() {
    const A = this._chatCompletions[this._chatCompletions.length - 1];
    A && this._emit("finalChatCompletion", A);
    const e = $(this, tr, "m", Bd).call(this);
    e && this._emit("finalMessage", e);
    const r = $(this, tr, "m", Nw).call(this);
    r && this._emit("finalContent", r);
    const i = $(this, tr, "m", Lw).call(this);
    i && this._emit("finalFunctionToolCall", i);
    const n = $(this, tr, "m", xw).call(this);
    n != null && this._emit("finalFunctionToolCallResult", n), this._chatCompletions.some((s) => s.usage) && this._emit("totalUsage", $(this, tr, "m", Gw).call(this));
  }
  async _createChatCompletion(A, e, r) {
    const i = r == null ? void 0 : r.signal;
    i && (i.aborted && this.controller.abort(), i.addEventListener("abort", () => this.controller.abort())), $(this, tr, "m", cN).call(this, e);
    const n = await A.chat.completions.create({ ...e, stream: !1 }, { ...r, signal: this.controller.signal });
    return this._connected(), this._addChatCompletion(e0(n, e));
  }
  async _runChatCompletion(A, e, r) {
    for (const i of e.messages)
      this._addMessage(i, !1);
    return await this._createChatCompletion(A, e, r);
  }
  async _runTools(A, e, r) {
    var C, E, l;
    const i = "tool", { tool_choice: n = "auto", stream: s, ...a } = e, g = typeof n != "string" && n.type === "function" && ((C = n == null ? void 0 : n.function) == null ? void 0 : C.name), { maxChatCompletions: o = xH } = r || {}, u = e.tools.map((B) => {
      if (kE(B)) {
        if (!B.$callback)
          throw new jA("Tool given to `.runTools()` that does not have an associated function");
        return {
          type: "function",
          function: {
            function: B.$callback,
            name: B.function.name,
            description: B.function.description || "",
            parameters: B.function.parameters,
            parse: B.$parseRaw,
            strict: !0
          }
        };
      }
      return B;
    }), I = {};
    for (const B of u)
      B.type === "function" && (I[B.function.name || B.function.function.name] = B.function);
    const c = "tools" in e ? u.map((B) => B.type === "function" ? {
      type: "function",
      function: {
        name: B.function.name || B.function.function.name,
        parameters: B.function.parameters,
        description: B.function.description,
        strict: B.function.strict
      }
    } : B) : void 0;
    for (const B of e.messages)
      this._addMessage(B, !1);
    for (let B = 0; B < o; ++B) {
      const Q = (E = (await this._createChatCompletion(A, {
        ...a,
        tool_choice: n,
        tools: c,
        messages: [...this.messages]
      }, r)).choices[0]) == null ? void 0 : E.message;
      if (!Q)
        throw new jA("missing message in ChatCompletion response");
      if (!((l = Q.tool_calls) != null && l.length))
        return;
      for (const f of Q.tool_calls) {
        if (f.type !== "function")
          continue;
        const p = f.id, { name: y, arguments: m } = f.function, S = I[y];
        if (S) {
          if (g && g !== y) {
            const G = `Invalid tool_call: ${JSON.stringify(y)}. ${JSON.stringify(g)} requested. Please try again`;
            this._addMessage({ role: i, tool_call_id: p, content: G });
            continue;
          }
        } else {
          const G = `Invalid tool_call: ${JSON.stringify(y)}. Available options are: ${Object.keys(I).map((T) => JSON.stringify(T)).join(", ")}. Please try again`;
          this._addMessage({ role: i, tool_call_id: p, content: G });
          continue;
        }
        let w;
        try {
          w = LH(S) ? await S.parse(m) : m;
        } catch (G) {
          const T = G instanceof Error ? G.message : String(G);
          this._addMessage({ role: i, tool_call_id: p, content: T });
          continue;
        }
        const F = await S.function(w, this), b = $(this, tr, "m", IN).call(this, F);
        if (this._addMessage({ role: i, tool_call_id: p, content: b }), g)
          return;
      }
    }
  }
}
tr = /* @__PURE__ */ new WeakSet(), Nw = function() {
  return $(this, tr, "m", Bd).call(this).content ?? null;
}, Bd = function() {
  let A = this.messages.length;
  for (; A-- > 0; ) {
    const e = this.messages[A];
    if (Id(e))
      return {
        ...e,
        content: e.content ?? null,
        refusal: e.refusal ?? null
      };
  }
  throw new jA("stream ended without producing a ChatCompletionMessage with role=assistant");
}, Lw = function() {
  var A, e;
  for (let r = this.messages.length - 1; r >= 0; r--) {
    const i = this.messages[r];
    if (Id(i) && ((A = i == null ? void 0 : i.tool_calls) != null && A.length))
      return (e = i.tool_calls.filter((n) => n.type === "function").at(-1)) == null ? void 0 : e.function;
  }
}, xw = function() {
  for (let A = this.messages.length - 1; A >= 0; A--) {
    const e = this.messages[A];
    if (gN(e) && e.content != null && typeof e.content == "string" && this.messages.some((r) => {
      var i;
      return r.role === "assistant" && ((i = r.tool_calls) == null ? void 0 : i.some((n) => n.type === "function" && n.id === e.tool_call_id));
    }))
      return e.content;
  }
}, Gw = function() {
  const A = {
    completion_tokens: 0,
    prompt_tokens: 0,
    total_tokens: 0
  };
  for (const { usage: e } of this._chatCompletions)
    e && (A.completion_tokens += e.completion_tokens, A.prompt_tokens += e.prompt_tokens, A.total_tokens += e.total_tokens);
  return A;
}, cN = function(A) {
  if (A.n != null && A.n > 1)
    throw new jA("ChatCompletion convenience helpers only support n=1 at this time. To use n>1, please use chat.completions.create() directly.");
}, IN = function(A) {
  return typeof A == "string" ? A : A === void 0 ? "undefined" : JSON.stringify(A);
};
class r0 extends CN {
  static runTools(A, e, r) {
    const i = new r0(), n = {
      ...r,
      headers: { ...r == null ? void 0 : r.headers, "X-Stainless-Helper-Method": "runTools" }
    };
    return i._run(() => i._runTools(A, e, n)), i;
  }
  _addMessage(A, e = !0) {
    super._addMessage(A, e), Id(A) && A.content && this._emit("content", A.content);
  }
}
const lN = 1, BN = 2, EN = 4, hN = 8, QN = 16, dN = 32, fN = 64, pN = 128, yN = 256, wN = pN | yN, mN = QN | dN | wN | fN, DN = lN | BN | mN, SN = EN | hN, GH = DN | SN, mt = {
  STR: lN,
  NUM: BN,
  ARR: EN,
  OBJ: hN,
  NULL: QN,
  BOOL: dN,
  NAN: fN,
  INFINITY: pN,
  MINUS_INFINITY: yN,
  INF: wN,
  SPECIAL: mN,
  ATOM: DN,
  COLLECTION: SN,
  ALL: GH
};
class UH extends Error {
}
class TH extends Error {
}
function KH(t, A = mt.ALL) {
  if (typeof t != "string")
    throw new TypeError(`expecting str, got ${typeof t}`);
  if (!t.trim())
    throw new Error(`${t} is empty`);
  return JH(t.trim(), A);
}
const JH = (t, A) => {
  const e = t.length;
  let r = 0;
  const i = (c) => {
    throw new UH(`${c} at position ${r}`);
  }, n = (c) => {
    throw new TH(`${c} at position ${r}`);
  }, s = () => (I(), r >= e && i("Unexpected end of input"), t[r] === '"' ? a() : t[r] === "{" ? g() : t[r] === "[" ? o() : t.substring(r, r + 4) === "null" || mt.NULL & A && e - r < 4 && "null".startsWith(t.substring(r)) ? (r += 4, null) : t.substring(r, r + 4) === "true" || mt.BOOL & A && e - r < 4 && "true".startsWith(t.substring(r)) ? (r += 4, !0) : t.substring(r, r + 5) === "false" || mt.BOOL & A && e - r < 5 && "false".startsWith(t.substring(r)) ? (r += 5, !1) : t.substring(r, r + 8) === "Infinity" || mt.INFINITY & A && e - r < 8 && "Infinity".startsWith(t.substring(r)) ? (r += 8, 1 / 0) : t.substring(r, r + 9) === "-Infinity" || mt.MINUS_INFINITY & A && 1 < e - r && e - r < 9 && "-Infinity".startsWith(t.substring(r)) ? (r += 9, -1 / 0) : t.substring(r, r + 3) === "NaN" || mt.NAN & A && e - r < 3 && "NaN".startsWith(t.substring(r)) ? (r += 3, NaN) : u()), a = () => {
    const c = r;
    let C = !1;
    for (r++; r < e && (t[r] !== '"' || C && t[r - 1] === "\\"); )
      C = t[r] === "\\" ? !C : !1, r++;
    if (t.charAt(r) == '"')
      try {
        return JSON.parse(t.substring(c, ++r - Number(C)));
      } catch (E) {
        n(String(E));
      }
    else if (mt.STR & A)
      try {
        return JSON.parse(t.substring(c, r - Number(C)) + '"');
      } catch {
        return JSON.parse(t.substring(c, t.lastIndexOf("\\")) + '"');
      }
    i("Unterminated string literal");
  }, g = () => {
    r++, I();
    const c = {};
    try {
      for (; t[r] !== "}"; ) {
        if (I(), r >= e && mt.OBJ & A)
          return c;
        const C = a();
        I(), r++;
        try {
          const E = s();
          Object.defineProperty(c, C, { value: E, writable: !0, enumerable: !0, configurable: !0 });
        } catch (E) {
          if (mt.OBJ & A)
            return c;
          throw E;
        }
        I(), t[r] === "," && r++;
      }
    } catch {
      if (mt.OBJ & A)
        return c;
      i("Expected '}' at end of object");
    }
    return r++, c;
  }, o = () => {
    r++;
    const c = [];
    try {
      for (; t[r] !== "]"; )
        c.push(s()), I(), t[r] === "," && r++;
    } catch {
      if (mt.ARR & A)
        return c;
      i("Expected ']' at end of array");
    }
    return r++, c;
  }, u = () => {
    if (r === 0) {
      t === "-" && mt.NUM & A && i("Not sure what '-' is");
      try {
        return JSON.parse(t);
      } catch (C) {
        if (mt.NUM & A)
          try {
            return t[t.length - 1] === "." ? JSON.parse(t.substring(0, t.lastIndexOf("."))) : JSON.parse(t.substring(0, t.lastIndexOf("e")));
          } catch {
          }
        n(String(C));
      }
    }
    const c = r;
    for (t[r] === "-" && r++; t[r] && !",]}".includes(t[r]); )
      r++;
    r == e && !(mt.NUM & A) && i("Unterminated number literal");
    try {
      return JSON.parse(t.substring(c, r));
    } catch {
      t.substring(c, r) === "-" && mt.NUM & A && i("Not sure what '-' is");
      try {
        return JSON.parse(t.substring(c, t.lastIndexOf("e")));
      } catch (E) {
        n(String(E));
      }
    }
  }, I = () => {
    for (; r < e && ` 
\r	`.includes(t[r]); )
      r++;
  };
  return s();
}, DF = (t) => KH(t, mt.ALL ^ mt.NUM);
var Bt, Mn, Mg, Ss, Pp, th, Op, Yp, qp, rh, jp, SF;
class qC extends CN {
  constructor(A) {
    super(), Bt.add(this), Mn.set(this, void 0), Mg.set(this, void 0), Ss.set(this, void 0), $A(this, Mn, A), $A(this, Mg, []);
  }
  get currentChatCompletionSnapshot() {
    return $(this, Ss, "f");
  }
  /**
   * Intended for use on the frontend, consuming a stream produced with
   * `.toReadableStream()` on the backend.
   *
   * Note that messages sent to the model do not appear in `.on('message')`
   * in this context.
   */
  static fromReadableStream(A) {
    const e = new qC(null);
    return e._run(() => e._fromReadableStream(A)), e;
  }
  static createChatCompletion(A, e, r) {
    const i = new qC(e);
    return i._run(() => i._runChatCompletion(A, { ...e, stream: !0 }, { ...r, headers: { ...r == null ? void 0 : r.headers, "X-Stainless-Helper-Method": "stream" } })), i;
  }
  async _createChatCompletion(A, e, r) {
    var s;
    super._createChatCompletion;
    const i = r == null ? void 0 : r.signal;
    i && (i.aborted && this.controller.abort(), i.addEventListener("abort", () => this.controller.abort())), $(this, Bt, "m", Pp).call(this);
    const n = await A.chat.completions.create({ ...e, stream: !0 }, { ...r, signal: this.controller.signal });
    this._connected();
    for await (const a of n)
      $(this, Bt, "m", Op).call(this, a);
    if ((s = n.controller.signal) != null && s.aborted)
      throw new Ur();
    return this._addChatCompletion($(this, Bt, "m", rh).call(this));
  }
  async _fromReadableStream(A, e) {
    var s;
    const r = e == null ? void 0 : e.signal;
    r && (r.aborted && this.controller.abort(), r.addEventListener("abort", () => this.controller.abort())), $(this, Bt, "m", Pp).call(this), this._connected();
    const i = cn.fromReadableStream(A, this.controller);
    let n;
    for await (const a of i)
      n && n !== a.id && this._addChatCompletion($(this, Bt, "m", rh).call(this)), $(this, Bt, "m", Op).call(this, a), n = a.id;
    if ((s = i.controller.signal) != null && s.aborted)
      throw new Ur();
    return this._addChatCompletion($(this, Bt, "m", rh).call(this));
  }
  [(Mn = /* @__PURE__ */ new WeakMap(), Mg = /* @__PURE__ */ new WeakMap(), Ss = /* @__PURE__ */ new WeakMap(), Bt = /* @__PURE__ */ new WeakSet(), Pp = function() {
    this.ended || $A(this, Ss, void 0);
  }, th = function(e) {
    let r = $(this, Mg, "f")[e.index];
    return r || (r = {
      content_done: !1,
      refusal_done: !1,
      logprobs_content_done: !1,
      logprobs_refusal_done: !1,
      done_tool_calls: /* @__PURE__ */ new Set(),
      current_tool_call_index: null
    }, $(this, Mg, "f")[e.index] = r, r);
  }, Op = function(e) {
    var i, n, s, a, g, o, u, I, c, C, E, l, B, h, Q;
    if (this.ended)
      return;
    const r = $(this, Bt, "m", SF).call(this, e);
    this._emit("chunk", e, r);
    for (const f of e.choices) {
      const p = r.choices[f.index];
      f.delta.content != null && ((i = p.message) == null ? void 0 : i.role) === "assistant" && ((n = p.message) != null && n.content) && (this._emit("content", f.delta.content, p.message.content), this._emit("content.delta", {
        delta: f.delta.content,
        snapshot: p.message.content,
        parsed: p.message.parsed
      })), f.delta.refusal != null && ((s = p.message) == null ? void 0 : s.role) === "assistant" && ((a = p.message) != null && a.refusal) && this._emit("refusal.delta", {
        delta: f.delta.refusal,
        snapshot: p.message.refusal
      }), ((g = f.logprobs) == null ? void 0 : g.content) != null && ((o = p.message) == null ? void 0 : o.role) === "assistant" && this._emit("logprobs.content.delta", {
        content: (u = f.logprobs) == null ? void 0 : u.content,
        snapshot: ((I = p.logprobs) == null ? void 0 : I.content) ?? []
      }), ((c = f.logprobs) == null ? void 0 : c.refusal) != null && ((C = p.message) == null ? void 0 : C.role) === "assistant" && this._emit("logprobs.refusal.delta", {
        refusal: (E = f.logprobs) == null ? void 0 : E.refusal,
        snapshot: ((l = p.logprobs) == null ? void 0 : l.refusal) ?? []
      });
      const y = $(this, Bt, "m", th).call(this, p);
      p.finish_reason && ($(this, Bt, "m", qp).call(this, p), y.current_tool_call_index != null && $(this, Bt, "m", Yp).call(this, p, y.current_tool_call_index));
      for (const m of f.delta.tool_calls ?? [])
        y.current_tool_call_index !== m.index && ($(this, Bt, "m", qp).call(this, p), y.current_tool_call_index != null && $(this, Bt, "m", Yp).call(this, p, y.current_tool_call_index)), y.current_tool_call_index = m.index;
      for (const m of f.delta.tool_calls ?? []) {
        const S = (B = p.message.tool_calls) == null ? void 0 : B[m.index];
        S != null && S.type && ((S == null ? void 0 : S.type) === "function" ? this._emit("tool_calls.function.arguments.delta", {
          name: (h = S.function) == null ? void 0 : h.name,
          index: m.index,
          arguments: S.function.arguments,
          parsed_arguments: S.function.parsed_arguments,
          arguments_delta: ((Q = m.function) == null ? void 0 : Q.arguments) ?? ""
        }) : (S == null || S.type, void 0));
      }
    }
  }, Yp = function(e, r) {
    var s, a, g;
    if ($(this, Bt, "m", th).call(this, e).done_tool_calls.has(r))
      return;
    const n = (s = e.message.tool_calls) == null ? void 0 : s[r];
    if (!n)
      throw new Error("no tool call snapshot");
    if (!n.type)
      throw new Error("tool call snapshot missing `type`");
    if (n.type === "function") {
      const o = (g = (a = $(this, Mn, "f")) == null ? void 0 : a.tools) == null ? void 0 : g.find((u) => cd(u) && u.function.name === n.function.name);
      this._emit("tool_calls.function.arguments.done", {
        name: n.function.name,
        index: r,
        arguments: n.function.arguments,
        parsed_arguments: kE(o) ? o.$parseRaw(n.function.arguments) : o != null && o.function.strict ? JSON.parse(n.function.arguments) : null
      });
    } else
      n.type;
  }, qp = function(e) {
    var i, n;
    const r = $(this, Bt, "m", th).call(this, e);
    if (e.message.content && !r.content_done) {
      r.content_done = !0;
      const s = $(this, Bt, "m", jp).call(this);
      this._emit("content.done", {
        content: e.message.content,
        parsed: s ? s.$parseRaw(e.message.content) : null
      });
    }
    e.message.refusal && !r.refusal_done && (r.refusal_done = !0, this._emit("refusal.done", { refusal: e.message.refusal })), (i = e.logprobs) != null && i.content && !r.logprobs_content_done && (r.logprobs_content_done = !0, this._emit("logprobs.content.done", { content: e.logprobs.content })), (n = e.logprobs) != null && n.refusal && !r.logprobs_refusal_done && (r.logprobs_refusal_done = !0, this._emit("logprobs.refusal.done", { refusal: e.logprobs.refusal }));
  }, rh = function() {
    if (this.ended)
      throw new jA("stream has ended, this shouldn't happen");
    const e = $(this, Ss, "f");
    if (!e)
      throw new jA("request ended without sending any chunks");
    return $A(this, Ss, void 0), $A(this, Mg, []), HH(e, $(this, Mn, "f"));
  }, jp = function() {
    var r;
    const e = (r = $(this, Mn, "f")) == null ? void 0 : r.response_format;
    return A0(e) ? e : null;
  }, SF = function(e) {
    var r, i, n, s;
    let a = $(this, Ss, "f");
    const { choices: g, ...o } = e;
    a ? Object.assign(a, o) : a = $A(this, Ss, {
      ...o,
      choices: []
    });
    for (const { delta: u, finish_reason: I, index: c, logprobs: C = null, ...E } of e.choices) {
      let l = a.choices[c];
      if (l || (l = a.choices[c] = { finish_reason: I, index: c, message: {}, logprobs: C, ...E }), C)
        if (!l.logprobs)
          l.logprobs = Object.assign({}, C);
        else {
          const { content: m, refusal: S, ...w } = C;
          Object.assign(l.logprobs, w), m && ((r = l.logprobs).content ?? (r.content = []), l.logprobs.content.push(...m)), S && ((i = l.logprobs).refusal ?? (i.refusal = []), l.logprobs.refusal.push(...S));
        }
      if (I && (l.finish_reason = I, $(this, Mn, "f") && aN($(this, Mn, "f")))) {
        if (I === "length")
          throw new H_();
        if (I === "content_filter")
          throw new P_();
      }
      if (Object.assign(l, E), !u)
        continue;
      const { content: B, refusal: h, function_call: Q, role: f, tool_calls: p, ...y } = u;
      if (Object.assign(l.message, y), h && (l.message.refusal = (l.message.refusal || "") + h), f && (l.message.role = f), Q && (l.message.function_call ? (Q.name && (l.message.function_call.name = Q.name), Q.arguments && ((n = l.message.function_call).arguments ?? (n.arguments = ""), l.message.function_call.arguments += Q.arguments)) : l.message.function_call = Q), B && (l.message.content = (l.message.content || "") + B, !l.message.refusal && $(this, Bt, "m", jp).call(this) && (l.message.parsed = DF(l.message.content))), p) {
        l.message.tool_calls || (l.message.tool_calls = []);
        for (const { index: m, id: S, type: w, function: F, ...b } of p) {
          const G = (s = l.message.tool_calls)[m] ?? (s[m] = {});
          Object.assign(G, b), S && (G.id = S), w && (G.type = w), F && (G.function ?? (G.function = { name: F.name ?? "", arguments: "" })), F != null && F.name && (G.function.name = F.name), F != null && F.arguments && (G.function.arguments += F.arguments, _H($(this, Mn, "f"), G) && (G.function.parsed_arguments = DF(G.function.arguments)));
        }
      }
    }
    return a;
  }, Symbol.asyncIterator)]() {
    const A = [], e = [];
    let r = !1;
    return this.on("chunk", (i) => {
      const n = e.shift();
      n ? n.resolve(i) : A.push(i);
    }), this.on("end", () => {
      r = !0;
      for (const i of e)
        i.resolve(void 0);
      e.length = 0;
    }), this.on("abort", (i) => {
      r = !0;
      for (const n of e)
        n.reject(i);
      e.length = 0;
    }), this.on("error", (i) => {
      r = !0;
      for (const n of e)
        n.reject(i);
      e.length = 0;
    }), {
      next: async () => A.length ? { value: A.shift(), done: !1 } : r ? { value: void 0, done: !0 } : new Promise((n, s) => e.push({ resolve: n, reject: s })).then((n) => n ? { value: n, done: !1 } : { value: void 0, done: !0 }),
      return: async () => (this.abort(), { value: void 0, done: !0 })
    };
  }
  toReadableStream() {
    return new cn(this[Symbol.asyncIterator].bind(this), this.controller).toReadableStream();
  }
}
function HH(t, A) {
  const { id: e, choices: r, created: i, model: n, system_fingerprint: s, ...a } = t, g = {
    ...a,
    id: e,
    choices: r.map(({ message: o, finish_reason: u, index: I, logprobs: c, ...C }) => {
      if (!u)
        throw new jA(`missing finish_reason for choice ${I}`);
      const { content: E = null, function_call: l, tool_calls: B, ...h } = o, Q = o.role;
      if (!Q)
        throw new jA(`missing role for choice ${I}`);
      if (l) {
        const { arguments: f, name: p } = l;
        if (f == null)
          throw new jA(`missing function_call.arguments for choice ${I}`);
        if (!p)
          throw new jA(`missing function_call.name for choice ${I}`);
        return {
          ...C,
          message: {
            content: E,
            function_call: { arguments: f, name: p },
            role: Q,
            refusal: o.refusal ?? null
          },
          finish_reason: u,
          index: I,
          logprobs: c
        };
      }
      return B ? {
        ...C,
        index: I,
        finish_reason: u,
        logprobs: c,
        message: {
          ...h,
          role: Q,
          content: E,
          refusal: o.refusal ?? null,
          tool_calls: B.map((f, p) => {
            const { function: y, type: m, id: S, ...w } = f, { arguments: F, name: b, ...G } = y || {};
            if (S == null)
              throw new jA(`missing choices[${I}].tool_calls[${p}].id
${ih(t)}`);
            if (m == null)
              throw new jA(`missing choices[${I}].tool_calls[${p}].type
${ih(t)}`);
            if (b == null)
              throw new jA(`missing choices[${I}].tool_calls[${p}].function.name
${ih(t)}`);
            if (F == null)
              throw new jA(`missing choices[${I}].tool_calls[${p}].function.arguments
${ih(t)}`);
            return { ...w, id: S, type: m, function: { ...G, name: b, arguments: F } };
          })
        }
      } : {
        ...C,
        message: { ...h, content: E, role: Q, refusal: o.refusal ?? null },
        finish_reason: u,
        index: I,
        logprobs: c
      };
    }),
    created: i,
    model: n,
    object: "chat.completion",
    ...s ? { system_fingerprint: s } : {}
  };
  return RH(g, A);
}
function ih(t) {
  return JSON.stringify(t);
}
class Ed extends qC {
  static fromReadableStream(A) {
    const e = new Ed(null);
    return e._run(() => e._fromReadableStream(A)), e;
  }
  static runTools(A, e, r) {
    const i = new Ed(
      // @ts-expect-error TODO these types are incompatible
      e
    ), n = {
      ...r,
      headers: { ...r == null ? void 0 : r.headers, "X-Stainless-Helper-Method": "runTools" }
    };
    return i._run(() => i._runTools(A, e, n)), i;
  }
}
let i0 = class extends qA {
  constructor() {
    super(...arguments), this.messages = new sN(this._client);
  }
  create(A, e) {
    return this._client.post("/chat/completions", { body: A, ...e, stream: A.stream ?? !1 });
  }
  /**
   * Get a stored chat completion. Only Chat Completions that have been created with
   * the `store` parameter set to `true` will be returned.
   *
   * @example
   * ```ts
   * const chatCompletion =
   *   await client.chat.completions.retrieve('completion_id');
   * ```
   */
  retrieve(A, e) {
    return this._client.get(yA`/chat/completions/${A}`, e);
  }
  /**
   * Modify a stored chat completion. Only Chat Completions that have been created
   * with the `store` parameter set to `true` can be modified. Currently, the only
   * supported modification is to update the `metadata` field.
   *
   * @example
   * ```ts
   * const chatCompletion = await client.chat.completions.update(
   *   'completion_id',
   *   { metadata: { foo: 'string' } },
   * );
   * ```
   */
  update(A, e, r) {
    return this._client.post(yA`/chat/completions/${A}`, { body: e, ...r });
  }
  /**
   * List stored Chat Completions. Only Chat Completions that have been stored with
   * the `store` parameter set to `true` will be returned.
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const chatCompletion of client.chat.completions.list()) {
   *   // ...
   * }
   * ```
   */
  list(A = {}, e) {
    return this._client.getAPIList("/chat/completions", ct, { query: A, ...e });
  }
  /**
   * Delete a stored chat completion. Only Chat Completions that have been created
   * with the `store` parameter set to `true` can be deleted.
   *
   * @example
   * ```ts
   * const chatCompletionDeleted =
   *   await client.chat.completions.delete('completion_id');
   * ```
   */
  delete(A, e) {
    return this._client.delete(yA`/chat/completions/${A}`, e);
  }
  parse(A, e) {
    return NH(A.tools), this._client.chat.completions.create(A, {
      ...e,
      headers: {
        ...e == null ? void 0 : e.headers,
        "X-Stainless-Helper-Method": "chat.completions.parse"
      }
    })._thenUnwrap((r) => e0(r, A));
  }
  runTools(A, e) {
    return A.stream ? Ed.runTools(this._client, A, e) : r0.runTools(this._client, A, e);
  }
  /**
   * Creates a chat completion stream
   */
  stream(A, e) {
    return qC.createChatCompletion(this._client, A, e);
  }
};
i0.Messages = sN;
class n0 extends qA {
  constructor() {
    super(...arguments), this.completions = new i0(this._client);
  }
}
n0.Completions = i0;
const FN = /* @__PURE__ */ Symbol("brand.privateNullableHeaders");
function* PH(t) {
  if (!t)
    return;
  if (FN in t) {
    const { values: r, nulls: i } = t;
    yield* r.entries();
    for (const n of i)
      yield [n, null];
    return;
  }
  let A = !1, e;
  t instanceof Headers ? e = t.entries() : uF(t) ? e = t : (A = !0, e = Object.entries(t ?? {}));
  for (let r of e) {
    const i = r[0];
    if (typeof i != "string")
      throw new TypeError("expected header name to be a string");
    const n = uF(r[1]) ? r[1] : [r[1]];
    let s = !1;
    for (const a of n)
      a !== void 0 && (A && !s && (s = !0, yield [i, null]), yield [i, a]);
  }
}
const TA = (t) => {
  const A = new Headers(), e = /* @__PURE__ */ new Set();
  for (const r of t) {
    const i = /* @__PURE__ */ new Set();
    for (const [n, s] of PH(r)) {
      const a = n.toLowerCase();
      i.has(a) || (A.delete(n), i.add(a)), s === null ? (A.delete(n), e.add(a)) : (A.append(n, s), e.delete(a));
    }
  }
  return { [FN]: !0, values: A, nulls: e };
};
class kN extends qA {
  /**
   * Generates audio from the input text.
   *
   * @example
   * ```ts
   * const speech = await client.audio.speech.create({
   *   input: 'input',
   *   model: 'string',
   *   voice: 'ash',
   * });
   *
   * const content = await speech.blob();
   * console.log(content);
   * ```
   */
  create(A, e) {
    return this._client.post("/audio/speech", {
      body: A,
      ...e,
      headers: TA([{ Accept: "application/octet-stream" }, e == null ? void 0 : e.headers]),
      __binaryResponse: !0
    });
  }
}
class vN extends qA {
  create(A, e) {
    return this._client.post("/audio/transcriptions", Cg({
      body: A,
      ...e,
      stream: A.stream ?? !1,
      __metadata: { model: A.model }
    }, this._client));
  }
}
class RN extends qA {
  create(A, e) {
    return this._client.post("/audio/translations", Cg({ body: A, ...e, __metadata: { model: A.model } }, this._client));
  }
}
class vE extends qA {
  constructor() {
    super(...arguments), this.transcriptions = new vN(this._client), this.translations = new RN(this._client), this.speech = new kN(this._client);
  }
}
vE.Transcriptions = vN;
vE.Translations = RN;
vE.Speech = kN;
class bN extends qA {
  /**
   * Creates and executes a batch from an uploaded file of requests
   */
  create(A, e) {
    return this._client.post("/batches", { body: A, ...e });
  }
  /**
   * Retrieves a batch.
   */
  retrieve(A, e) {
    return this._client.get(yA`/batches/${A}`, e);
  }
  /**
   * List your organization's batches.
   */
  list(A = {}, e) {
    return this._client.getAPIList("/batches", ct, { query: A, ...e });
  }
  /**
   * Cancels an in-progress batch. The batch will be in status `cancelling` for up to
   * 10 minutes, before changing to `cancelled`, where it will have partial results
   * (if any) available in the output file.
   */
  cancel(A, e) {
    return this._client.post(yA`/batches/${A}/cancel`, e);
  }
}
class MN extends qA {
  /**
   * Create an assistant with a model and instructions.
   *
   * @example
   * ```ts
   * const assistant = await client.beta.assistants.create({
   *   model: 'gpt-4o',
   * });
   * ```
   */
  create(A, e) {
    return this._client.post("/assistants", {
      body: A,
      ...e,
      headers: TA([{ "OpenAI-Beta": "assistants=v2" }, e == null ? void 0 : e.headers])
    });
  }
  /**
   * Retrieves an assistant.
   *
   * @example
   * ```ts
   * const assistant = await client.beta.assistants.retrieve(
   *   'assistant_id',
   * );
   * ```
   */
  retrieve(A, e) {
    return this._client.get(yA`/assistants/${A}`, {
      ...e,
      headers: TA([{ "OpenAI-Beta": "assistants=v2" }, e == null ? void 0 : e.headers])
    });
  }
  /**
   * Modifies an assistant.
   *
   * @example
   * ```ts
   * const assistant = await client.beta.assistants.update(
   *   'assistant_id',
   * );
   * ```
   */
  update(A, e, r) {
    return this._client.post(yA`/assistants/${A}`, {
      body: e,
      ...r,
      headers: TA([{ "OpenAI-Beta": "assistants=v2" }, r == null ? void 0 : r.headers])
    });
  }
  /**
   * Returns a list of assistants.
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const assistant of client.beta.assistants.list()) {
   *   // ...
   * }
   * ```
   */
  list(A = {}, e) {
    return this._client.getAPIList("/assistants", ct, {
      query: A,
      ...e,
      headers: TA([{ "OpenAI-Beta": "assistants=v2" }, e == null ? void 0 : e.headers])
    });
  }
  /**
   * Delete an assistant.
   *
   * @example
   * ```ts
   * const assistantDeleted =
   *   await client.beta.assistants.delete('assistant_id');
   * ```
   */
  delete(A, e) {
    return this._client.delete(yA`/assistants/${A}`, {
      ...e,
      headers: TA([{ "OpenAI-Beta": "assistants=v2" }, e == null ? void 0 : e.headers])
    });
  }
}
let _N = class extends qA {
  /**
   * Create an ephemeral API token for use in client-side applications with the
   * Realtime API. Can be configured with the same session parameters as the
   * `session.update` client event.
   *
   * It responds with a session object, plus a `client_secret` key which contains a
   * usable ephemeral API token that can be used to authenticate browser clients for
   * the Realtime API.
   *
   * @example
   * ```ts
   * const session =
   *   await client.beta.realtime.sessions.create();
   * ```
   */
  create(A, e) {
    return this._client.post("/realtime/sessions", {
      body: A,
      ...e,
      headers: TA([{ "OpenAI-Beta": "assistants=v2" }, e == null ? void 0 : e.headers])
    });
  }
};
class NN extends qA {
  /**
   * Create an ephemeral API token for use in client-side applications with the
   * Realtime API specifically for realtime transcriptions. Can be configured with
   * the same session parameters as the `transcription_session.update` client event.
   *
   * It responds with a session object, plus a `client_secret` key which contains a
   * usable ephemeral API token that can be used to authenticate browser clients for
   * the Realtime API.
   *
   * @example
   * ```ts
   * const transcriptionSession =
   *   await client.beta.realtime.transcriptionSessions.create();
   * ```
   */
  create(A, e) {
    return this._client.post("/realtime/transcription_sessions", {
      body: A,
      ...e,
      headers: TA([{ "OpenAI-Beta": "assistants=v2" }, e == null ? void 0 : e.headers])
    });
  }
}
let Gf = class extends qA {
  constructor() {
    super(...arguments), this.sessions = new _N(this._client), this.transcriptionSessions = new NN(this._client);
  }
};
Gf.Sessions = _N;
Gf.TranscriptionSessions = NN;
class LN extends qA {
  /**
   * Create a ChatKit session
   *
   * @example
   * ```ts
   * const chatSession =
   *   await client.beta.chatkit.sessions.create({
   *     user: 'x',
   *     workflow: { id: 'id' },
   *   });
   * ```
   */
  create(A, e) {
    return this._client.post("/chatkit/sessions", {
      body: A,
      ...e,
      headers: TA([{ "OpenAI-Beta": "chatkit_beta=v1" }, e == null ? void 0 : e.headers])
    });
  }
  /**
   * Cancel a ChatKit session
   *
   * @example
   * ```ts
   * const chatSession =
   *   await client.beta.chatkit.sessions.cancel('cksess_123');
   * ```
   */
  cancel(A, e) {
    return this._client.post(yA`/chatkit/sessions/${A}/cancel`, {
      ...e,
      headers: TA([{ "OpenAI-Beta": "chatkit_beta=v1" }, e == null ? void 0 : e.headers])
    });
  }
}
let xN = class extends qA {
  /**
   * Retrieve a ChatKit thread
   *
   * @example
   * ```ts
   * const chatkitThread =
   *   await client.beta.chatkit.threads.retrieve('cthr_123');
   * ```
   */
  retrieve(A, e) {
    return this._client.get(yA`/chatkit/threads/${A}`, {
      ...e,
      headers: TA([{ "OpenAI-Beta": "chatkit_beta=v1" }, e == null ? void 0 : e.headers])
    });
  }
  /**
   * List ChatKit threads
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const chatkitThread of client.beta.chatkit.threads.list()) {
   *   // ...
   * }
   * ```
   */
  list(A = {}, e) {
    return this._client.getAPIList("/chatkit/threads", ud, {
      query: A,
      ...e,
      headers: TA([{ "OpenAI-Beta": "chatkit_beta=v1" }, e == null ? void 0 : e.headers])
    });
  }
  /**
   * Delete a ChatKit thread
   *
   * @example
   * ```ts
   * const thread = await client.beta.chatkit.threads.delete(
   *   'cthr_123',
   * );
   * ```
   */
  delete(A, e) {
    return this._client.delete(yA`/chatkit/threads/${A}`, {
      ...e,
      headers: TA([{ "OpenAI-Beta": "chatkit_beta=v1" }, e == null ? void 0 : e.headers])
    });
  }
  /**
   * List ChatKit thread items
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const thread of client.beta.chatkit.threads.listItems(
   *   'cthr_123',
   * )) {
   *   // ...
   * }
   * ```
   */
  listItems(A, e = {}, r) {
    return this._client.getAPIList(yA`/chatkit/threads/${A}/items`, ud, { query: e, ...r, headers: TA([{ "OpenAI-Beta": "chatkit_beta=v1" }, r == null ? void 0 : r.headers]) });
  }
};
class Uf extends qA {
  constructor() {
    super(...arguments), this.sessions = new LN(this._client), this.threads = new xN(this._client);
  }
}
Uf.Sessions = LN;
Uf.Threads = xN;
class GN extends qA {
  /**
   * Create a message.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  create(A, e, r) {
    return this._client.post(yA`/threads/${A}/messages`, {
      body: e,
      ...r,
      headers: TA([{ "OpenAI-Beta": "assistants=v2" }, r == null ? void 0 : r.headers])
    });
  }
  /**
   * Retrieve a message.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  retrieve(A, e, r) {
    const { thread_id: i } = e;
    return this._client.get(yA`/threads/${i}/messages/${A}`, {
      ...r,
      headers: TA([{ "OpenAI-Beta": "assistants=v2" }, r == null ? void 0 : r.headers])
    });
  }
  /**
   * Modifies a message.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  update(A, e, r) {
    const { thread_id: i, ...n } = e;
    return this._client.post(yA`/threads/${i}/messages/${A}`, {
      body: n,
      ...r,
      headers: TA([{ "OpenAI-Beta": "assistants=v2" }, r == null ? void 0 : r.headers])
    });
  }
  /**
   * Returns a list of messages for a given thread.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  list(A, e = {}, r) {
    return this._client.getAPIList(yA`/threads/${A}/messages`, ct, {
      query: e,
      ...r,
      headers: TA([{ "OpenAI-Beta": "assistants=v2" }, r == null ? void 0 : r.headers])
    });
  }
  /**
   * Deletes a message.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  delete(A, e, r) {
    const { thread_id: i } = e;
    return this._client.delete(yA`/threads/${i}/messages/${A}`, {
      ...r,
      headers: TA([{ "OpenAI-Beta": "assistants=v2" }, r == null ? void 0 : r.headers])
    });
  }
}
class UN extends qA {
  /**
   * Retrieves a run step.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  retrieve(A, e, r) {
    const { thread_id: i, run_id: n, ...s } = e;
    return this._client.get(yA`/threads/${i}/runs/${n}/steps/${A}`, {
      query: s,
      ...r,
      headers: TA([{ "OpenAI-Beta": "assistants=v2" }, r == null ? void 0 : r.headers])
    });
  }
  /**
   * Returns a list of run steps belonging to a run.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  list(A, e, r) {
    const { thread_id: i, ...n } = e;
    return this._client.getAPIList(yA`/threads/${i}/runs/${A}/steps`, ct, {
      query: n,
      ...r,
      headers: TA([{ "OpenAI-Beta": "assistants=v2" }, r == null ? void 0 : r.headers])
    });
  }
}
const OH = (t) => {
  if (typeof Buffer < "u") {
    const A = Buffer.from(t, "base64");
    return Array.from(new Float32Array(A.buffer, A.byteOffset, A.length / Float32Array.BYTES_PER_ELEMENT));
  } else {
    const A = atob(t), e = A.length, r = new Uint8Array(e);
    for (let i = 0; i < e; i++)
      r[i] = A.charCodeAt(i);
    return Array.from(new Float32Array(r.buffer));
  }
}, _g = (t) => {
  var A, e, r, i, n;
  if (typeof globalThis.process < "u")
    return ((e = (A = globalThis.process.env) == null ? void 0 : A[t]) == null ? void 0 : e.trim()) ?? void 0;
  if (typeof globalThis.Deno < "u")
    return (n = (i = (r = globalThis.Deno.env) == null ? void 0 : r.get) == null ? void 0 : i.call(r, t)) == null ? void 0 : n.trim();
};
var Ht, go, Uw, qi, bQ, hi, uo, Vg, ao, hd, vr, MQ, _Q, NC, QC, dC, FF, kF, vF, RF, bF, MF, _F;
class LC extends t0 {
  constructor() {
    super(...arguments), Ht.add(this), Uw.set(this, []), qi.set(this, {}), bQ.set(this, {}), hi.set(this, void 0), uo.set(this, void 0), Vg.set(this, void 0), ao.set(this, void 0), hd.set(this, void 0), vr.set(this, void 0), MQ.set(this, void 0), _Q.set(this, void 0), NC.set(this, void 0);
  }
  [(Uw = /* @__PURE__ */ new WeakMap(), qi = /* @__PURE__ */ new WeakMap(), bQ = /* @__PURE__ */ new WeakMap(), hi = /* @__PURE__ */ new WeakMap(), uo = /* @__PURE__ */ new WeakMap(), Vg = /* @__PURE__ */ new WeakMap(), ao = /* @__PURE__ */ new WeakMap(), hd = /* @__PURE__ */ new WeakMap(), vr = /* @__PURE__ */ new WeakMap(), MQ = /* @__PURE__ */ new WeakMap(), _Q = /* @__PURE__ */ new WeakMap(), NC = /* @__PURE__ */ new WeakMap(), Ht = /* @__PURE__ */ new WeakSet(), Symbol.asyncIterator)]() {
    const A = [], e = [];
    let r = !1;
    return this.on("event", (i) => {
      const n = e.shift();
      n ? n.resolve(i) : A.push(i);
    }), this.on("end", () => {
      r = !0;
      for (const i of e)
        i.resolve(void 0);
      e.length = 0;
    }), this.on("abort", (i) => {
      r = !0;
      for (const n of e)
        n.reject(i);
      e.length = 0;
    }), this.on("error", (i) => {
      r = !0;
      for (const n of e)
        n.reject(i);
      e.length = 0;
    }), {
      next: async () => A.length ? { value: A.shift(), done: !1 } : r ? { value: void 0, done: !0 } : new Promise((n, s) => e.push({ resolve: n, reject: s })).then((n) => n ? { value: n, done: !1 } : { value: void 0, done: !0 }),
      return: async () => (this.abort(), { value: void 0, done: !0 })
    };
  }
  static fromReadableStream(A) {
    const e = new go();
    return e._run(() => e._fromReadableStream(A)), e;
  }
  async _fromReadableStream(A, e) {
    var n;
    const r = e == null ? void 0 : e.signal;
    r && (r.aborted && this.controller.abort(), r.addEventListener("abort", () => this.controller.abort())), this._connected();
    const i = cn.fromReadableStream(A, this.controller);
    for await (const s of i)
      $(this, Ht, "m", QC).call(this, s);
    if ((n = i.controller.signal) != null && n.aborted)
      throw new Ur();
    return this._addRun($(this, Ht, "m", dC).call(this));
  }
  toReadableStream() {
    return new cn(this[Symbol.asyncIterator].bind(this), this.controller).toReadableStream();
  }
  static createToolAssistantStream(A, e, r, i) {
    const n = new go();
    return n._run(() => n._runToolAssistantStream(A, e, r, {
      ...i,
      headers: { ...i == null ? void 0 : i.headers, "X-Stainless-Helper-Method": "stream" }
    })), n;
  }
  async _createToolAssistantStream(A, e, r, i) {
    var g;
    const n = i == null ? void 0 : i.signal;
    n && (n.aborted && this.controller.abort(), n.addEventListener("abort", () => this.controller.abort()));
    const s = { ...r, stream: !0 }, a = await A.submitToolOutputs(e, s, {
      ...i,
      signal: this.controller.signal
    });
    this._connected();
    for await (const o of a)
      $(this, Ht, "m", QC).call(this, o);
    if ((g = a.controller.signal) != null && g.aborted)
      throw new Ur();
    return this._addRun($(this, Ht, "m", dC).call(this));
  }
  static createThreadAssistantStream(A, e, r) {
    const i = new go();
    return i._run(() => i._threadAssistantStream(A, e, {
      ...r,
      headers: { ...r == null ? void 0 : r.headers, "X-Stainless-Helper-Method": "stream" }
    })), i;
  }
  static createAssistantStream(A, e, r, i) {
    const n = new go();
    return n._run(() => n._runAssistantStream(A, e, r, {
      ...i,
      headers: { ...i == null ? void 0 : i.headers, "X-Stainless-Helper-Method": "stream" }
    })), n;
  }
  currentEvent() {
    return $(this, MQ, "f");
  }
  currentRun() {
    return $(this, _Q, "f");
  }
  currentMessageSnapshot() {
    return $(this, hi, "f");
  }
  currentRunStepSnapshot() {
    return $(this, NC, "f");
  }
  async finalRunSteps() {
    return await this.done(), Object.values($(this, qi, "f"));
  }
  async finalMessages() {
    return await this.done(), Object.values($(this, bQ, "f"));
  }
  async finalRun() {
    if (await this.done(), !$(this, uo, "f"))
      throw Error("Final run was not received.");
    return $(this, uo, "f");
  }
  async _createThreadAssistantStream(A, e, r) {
    var a;
    const i = r == null ? void 0 : r.signal;
    i && (i.aborted && this.controller.abort(), i.addEventListener("abort", () => this.controller.abort()));
    const n = { ...e, stream: !0 }, s = await A.createAndRun(n, { ...r, signal: this.controller.signal });
    this._connected();
    for await (const g of s)
      $(this, Ht, "m", QC).call(this, g);
    if ((a = s.controller.signal) != null && a.aborted)
      throw new Ur();
    return this._addRun($(this, Ht, "m", dC).call(this));
  }
  async _createAssistantStream(A, e, r, i) {
    var g;
    const n = i == null ? void 0 : i.signal;
    n && (n.aborted && this.controller.abort(), n.addEventListener("abort", () => this.controller.abort()));
    const s = { ...r, stream: !0 }, a = await A.create(e, s, { ...i, signal: this.controller.signal });
    this._connected();
    for await (const o of a)
      $(this, Ht, "m", QC).call(this, o);
    if ((g = a.controller.signal) != null && g.aborted)
      throw new Ur();
    return this._addRun($(this, Ht, "m", dC).call(this));
  }
  static accumulateDelta(A, e) {
    for (const [r, i] of Object.entries(e)) {
      if (!A.hasOwnProperty(r)) {
        A[r] = i;
        continue;
      }
      let n = A[r];
      if (n == null) {
        A[r] = i;
        continue;
      }
      if (r === "index" || r === "type") {
        A[r] = i;
        continue;
      }
      if (typeof n == "string" && typeof i == "string")
        n += i;
      else if (typeof n == "number" && typeof i == "number")
        n += i;
      else if (Kp(n) && Kp(i))
        n = this.accumulateDelta(n, i);
      else if (Array.isArray(n) && Array.isArray(i)) {
        if (n.every((s) => typeof s == "string" || typeof s == "number")) {
          n.push(...i);
          continue;
        }
        for (const s of i) {
          if (!Kp(s))
            throw new Error(`Expected array delta entry to be an object but got: ${s}`);
          const a = s.index;
          if (a == null)
            throw console.error(s), new Error("Expected array delta entry to have an `index` property");
          if (typeof a != "number")
            throw new Error(`Expected array delta entry \`index\` property to be a number but got ${a}`);
          const g = n[a];
          g == null ? n.push(s) : n[a] = this.accumulateDelta(g, s);
        }
        continue;
      } else
        throw Error(`Unhandled record type: ${r}, deltaValue: ${i}, accValue: ${n}`);
      A[r] = n;
    }
    return A;
  }
  _addRun(A) {
    return A;
  }
  async _threadAssistantStream(A, e, r) {
    return await this._createThreadAssistantStream(e, A, r);
  }
  async _runAssistantStream(A, e, r, i) {
    return await this._createAssistantStream(e, A, r, i);
  }
  async _runToolAssistantStream(A, e, r, i) {
    return await this._createToolAssistantStream(e, A, r, i);
  }
}
go = LC, QC = function(A) {
  if (!this.ended)
    switch ($A(this, MQ, A), $(this, Ht, "m", vF).call(this, A), A.event) {
      case "thread.created":
        break;
      case "thread.run.created":
      case "thread.run.queued":
      case "thread.run.in_progress":
      case "thread.run.requires_action":
      case "thread.run.completed":
      case "thread.run.incomplete":
      case "thread.run.failed":
      case "thread.run.cancelling":
      case "thread.run.cancelled":
      case "thread.run.expired":
        $(this, Ht, "m", _F).call(this, A);
        break;
      case "thread.run.step.created":
      case "thread.run.step.in_progress":
      case "thread.run.step.delta":
      case "thread.run.step.completed":
      case "thread.run.step.failed":
      case "thread.run.step.cancelled":
      case "thread.run.step.expired":
        $(this, Ht, "m", kF).call(this, A);
        break;
      case "thread.message.created":
      case "thread.message.in_progress":
      case "thread.message.delta":
      case "thread.message.completed":
      case "thread.message.incomplete":
        $(this, Ht, "m", FF).call(this, A);
        break;
      case "error":
        throw new Error("Encountered an error event in event processing - errors should be processed earlier");
    }
}, dC = function() {
  if (this.ended)
    throw new jA("stream has ended, this shouldn't happen");
  if (!$(this, uo, "f"))
    throw Error("Final run has not been received");
  return $(this, uo, "f");
}, FF = function(A) {
  const [e, r] = $(this, Ht, "m", bF).call(this, A, $(this, hi, "f"));
  $A(this, hi, e), $(this, bQ, "f")[e.id] = e;
  for (const i of r) {
    const n = e.content[i.index];
    (n == null ? void 0 : n.type) == "text" && this._emit("textCreated", n.text);
  }
  switch (A.event) {
    case "thread.message.created":
      this._emit("messageCreated", A.data);
      break;
    case "thread.message.in_progress":
      break;
    case "thread.message.delta":
      if (this._emit("messageDelta", A.data.delta, e), A.data.delta.content)
        for (const i of A.data.delta.content) {
          if (i.type == "text" && i.text) {
            let n = i.text, s = e.content[i.index];
            if (s && s.type == "text")
              this._emit("textDelta", n, s.text);
            else
              throw Error("The snapshot associated with this text delta is not text or missing");
          }
          if (i.index != $(this, Vg, "f")) {
            if ($(this, ao, "f"))
              switch ($(this, ao, "f").type) {
                case "text":
                  this._emit("textDone", $(this, ao, "f").text, $(this, hi, "f"));
                  break;
                case "image_file":
                  this._emit("imageFileDone", $(this, ao, "f").image_file, $(this, hi, "f"));
                  break;
              }
            $A(this, Vg, i.index);
          }
          $A(this, ao, e.content[i.index]);
        }
      break;
    case "thread.message.completed":
    case "thread.message.incomplete":
      if ($(this, Vg, "f") !== void 0) {
        const i = A.data.content[$(this, Vg, "f")];
        if (i)
          switch (i.type) {
            case "image_file":
              this._emit("imageFileDone", i.image_file, $(this, hi, "f"));
              break;
            case "text":
              this._emit("textDone", i.text, $(this, hi, "f"));
              break;
          }
      }
      $(this, hi, "f") && this._emit("messageDone", A.data), $A(this, hi, void 0);
  }
}, kF = function(A) {
  const e = $(this, Ht, "m", RF).call(this, A);
  switch ($A(this, NC, e), A.event) {
    case "thread.run.step.created":
      this._emit("runStepCreated", A.data);
      break;
    case "thread.run.step.delta":
      const r = A.data.delta;
      if (r.step_details && r.step_details.type == "tool_calls" && r.step_details.tool_calls && e.step_details.type == "tool_calls")
        for (const n of r.step_details.tool_calls)
          n.index == $(this, hd, "f") ? this._emit("toolCallDelta", n, e.step_details.tool_calls[n.index]) : ($(this, vr, "f") && this._emit("toolCallDone", $(this, vr, "f")), $A(this, hd, n.index), $A(this, vr, e.step_details.tool_calls[n.index]), $(this, vr, "f") && this._emit("toolCallCreated", $(this, vr, "f")));
      this._emit("runStepDelta", A.data.delta, e);
      break;
    case "thread.run.step.completed":
    case "thread.run.step.failed":
    case "thread.run.step.cancelled":
    case "thread.run.step.expired":
      $A(this, NC, void 0), A.data.step_details.type == "tool_calls" && $(this, vr, "f") && (this._emit("toolCallDone", $(this, vr, "f")), $A(this, vr, void 0)), this._emit("runStepDone", A.data, e);
      break;
  }
}, vF = function(A) {
  $(this, Uw, "f").push(A), this._emit("event", A);
}, RF = function(A) {
  switch (A.event) {
    case "thread.run.step.created":
      return $(this, qi, "f")[A.data.id] = A.data, A.data;
    case "thread.run.step.delta":
      let e = $(this, qi, "f")[A.data.id];
      if (!e)
        throw Error("Received a RunStepDelta before creation of a snapshot");
      let r = A.data;
      if (r.delta) {
        const i = go.accumulateDelta(e, r.delta);
        $(this, qi, "f")[A.data.id] = i;
      }
      return $(this, qi, "f")[A.data.id];
    case "thread.run.step.completed":
    case "thread.run.step.failed":
    case "thread.run.step.cancelled":
    case "thread.run.step.expired":
    case "thread.run.step.in_progress":
      $(this, qi, "f")[A.data.id] = A.data;
      break;
  }
  if ($(this, qi, "f")[A.data.id])
    return $(this, qi, "f")[A.data.id];
  throw new Error("No snapshot available");
}, bF = function(A, e) {
  let r = [];
  switch (A.event) {
    case "thread.message.created":
      return [A.data, r];
    case "thread.message.delta":
      if (!e)
        throw Error("Received a delta with no existing snapshot (there should be one from message creation)");
      let i = A.data;
      if (i.delta.content)
        for (const n of i.delta.content)
          if (n.index in e.content) {
            let s = e.content[n.index];
            e.content[n.index] = $(this, Ht, "m", MF).call(this, n, s);
          } else
            e.content[n.index] = n, r.push(n);
      return [e, r];
    case "thread.message.in_progress":
    case "thread.message.completed":
    case "thread.message.incomplete":
      if (e)
        return [e, r];
      throw Error("Received thread message event with no existing snapshot");
  }
  throw Error("Tried to accumulate a non-message event");
}, MF = function(A, e) {
  return go.accumulateDelta(e, A);
}, _F = function(A) {
  switch ($A(this, _Q, A.data), A.event) {
    case "thread.run.created":
      break;
    case "thread.run.queued":
      break;
    case "thread.run.in_progress":
      break;
    case "thread.run.requires_action":
    case "thread.run.cancelled":
    case "thread.run.failed":
    case "thread.run.completed":
    case "thread.run.expired":
    case "thread.run.incomplete":
      $A(this, uo, A.data), $(this, vr, "f") && (this._emit("toolCallDone", $(this, vr, "f")), $A(this, vr, void 0));
      break;
  }
};
let s0 = class extends qA {
  constructor() {
    super(...arguments), this.steps = new UN(this._client);
  }
  create(A, e, r) {
    const { include: i, ...n } = e;
    return this._client.post(yA`/threads/${A}/runs`, {
      query: { include: i },
      body: n,
      ...r,
      headers: TA([{ "OpenAI-Beta": "assistants=v2" }, r == null ? void 0 : r.headers]),
      stream: e.stream ?? !1
    });
  }
  /**
   * Retrieves a run.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  retrieve(A, e, r) {
    const { thread_id: i } = e;
    return this._client.get(yA`/threads/${i}/runs/${A}`, {
      ...r,
      headers: TA([{ "OpenAI-Beta": "assistants=v2" }, r == null ? void 0 : r.headers])
    });
  }
  /**
   * Modifies a run.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  update(A, e, r) {
    const { thread_id: i, ...n } = e;
    return this._client.post(yA`/threads/${i}/runs/${A}`, {
      body: n,
      ...r,
      headers: TA([{ "OpenAI-Beta": "assistants=v2" }, r == null ? void 0 : r.headers])
    });
  }
  /**
   * Returns a list of runs belonging to a thread.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  list(A, e = {}, r) {
    return this._client.getAPIList(yA`/threads/${A}/runs`, ct, {
      query: e,
      ...r,
      headers: TA([{ "OpenAI-Beta": "assistants=v2" }, r == null ? void 0 : r.headers])
    });
  }
  /**
   * Cancels a run that is `in_progress`.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  cancel(A, e, r) {
    const { thread_id: i } = e;
    return this._client.post(yA`/threads/${i}/runs/${A}/cancel`, {
      ...r,
      headers: TA([{ "OpenAI-Beta": "assistants=v2" }, r == null ? void 0 : r.headers])
    });
  }
  /**
   * A helper to create a run an poll for a terminal state. More information on Run
   * lifecycles can be found here:
   * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
   */
  async createAndPoll(A, e, r) {
    const i = await this.create(A, e, r);
    return await this.poll(i.id, { thread_id: A }, r);
  }
  /**
   * Create a Run stream
   *
   * @deprecated use `stream` instead
   */
  createAndStream(A, e, r) {
    return LC.createAssistantStream(A, this._client.beta.threads.runs, e, r);
  }
  /**
   * A helper to poll a run status until it reaches a terminal state. More
   * information on Run lifecycles can be found here:
   * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
   */
  async poll(A, e, r) {
    var n;
    const i = TA([
      r == null ? void 0 : r.headers,
      {
        "X-Stainless-Poll-Helper": "true",
        "X-Stainless-Custom-Poll-Interval": ((n = r == null ? void 0 : r.pollIntervalMs) == null ? void 0 : n.toString()) ?? void 0
      }
    ]);
    for (; ; ) {
      const { data: s, response: a } = await this.retrieve(A, e, {
        ...r,
        headers: { ...r == null ? void 0 : r.headers, ...i }
      }).withResponse();
      switch (s.status) {
        case "queued":
        case "in_progress":
        case "cancelling":
          let g = 5e3;
          if (r != null && r.pollIntervalMs)
            g = r.pollIntervalMs;
          else {
            const o = a.headers.get("openai-poll-after-ms");
            if (o) {
              const u = parseInt(o);
              isNaN(u) || (g = u);
            }
          }
          await FE(g);
          break;
        case "requires_action":
        case "incomplete":
        case "cancelled":
        case "completed":
        case "failed":
        case "expired":
          return s;
      }
    }
  }
  /**
   * Create a Run stream
   */
  stream(A, e, r) {
    return LC.createAssistantStream(A, this._client.beta.threads.runs, e, r);
  }
  submitToolOutputs(A, e, r) {
    const { thread_id: i, ...n } = e;
    return this._client.post(yA`/threads/${i}/runs/${A}/submit_tool_outputs`, {
      body: n,
      ...r,
      headers: TA([{ "OpenAI-Beta": "assistants=v2" }, r == null ? void 0 : r.headers]),
      stream: e.stream ?? !1
    });
  }
  /**
   * A helper to submit a tool output to a run and poll for a terminal run state.
   * More information on Run lifecycles can be found here:
   * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
   */
  async submitToolOutputsAndPoll(A, e, r) {
    const i = await this.submitToolOutputs(A, e, r);
    return await this.poll(i.id, e, r);
  }
  /**
   * Submit the tool outputs from a previous run and stream the run to a terminal
   * state. More information on Run lifecycles can be found here:
   * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
   */
  submitToolOutputsStream(A, e, r) {
    return LC.createToolAssistantStream(A, this._client.beta.threads.runs, e, r);
  }
};
s0.Steps = UN;
class Tf extends qA {
  constructor() {
    super(...arguments), this.runs = new s0(this._client), this.messages = new GN(this._client);
  }
  /**
   * Create a thread.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  create(A = {}, e) {
    return this._client.post("/threads", {
      body: A,
      ...e,
      headers: TA([{ "OpenAI-Beta": "assistants=v2" }, e == null ? void 0 : e.headers])
    });
  }
  /**
   * Retrieves a thread.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  retrieve(A, e) {
    return this._client.get(yA`/threads/${A}`, {
      ...e,
      headers: TA([{ "OpenAI-Beta": "assistants=v2" }, e == null ? void 0 : e.headers])
    });
  }
  /**
   * Modifies a thread.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  update(A, e, r) {
    return this._client.post(yA`/threads/${A}`, {
      body: e,
      ...r,
      headers: TA([{ "OpenAI-Beta": "assistants=v2" }, r == null ? void 0 : r.headers])
    });
  }
  /**
   * Delete a thread.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  delete(A, e) {
    return this._client.delete(yA`/threads/${A}`, {
      ...e,
      headers: TA([{ "OpenAI-Beta": "assistants=v2" }, e == null ? void 0 : e.headers])
    });
  }
  createAndRun(A, e) {
    return this._client.post("/threads/runs", {
      body: A,
      ...e,
      headers: TA([{ "OpenAI-Beta": "assistants=v2" }, e == null ? void 0 : e.headers]),
      stream: A.stream ?? !1
    });
  }
  /**
   * A helper to create a thread, start a run and then poll for a terminal state.
   * More information on Run lifecycles can be found here:
   * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
   */
  async createAndRunPoll(A, e) {
    const r = await this.createAndRun(A, e);
    return await this.runs.poll(r.id, { thread_id: r.thread_id }, e);
  }
  /**
   * Create a thread and stream the run back
   */
  createAndRunStream(A, e) {
    return LC.createThreadAssistantStream(A, this._client.beta.threads, e);
  }
}
Tf.Runs = s0;
Tf.Messages = GN;
class iI extends qA {
  constructor() {
    super(...arguments), this.realtime = new Gf(this._client), this.chatkit = new Uf(this._client), this.assistants = new MN(this._client), this.threads = new Tf(this._client);
  }
}
iI.Realtime = Gf;
iI.ChatKit = Uf;
iI.Assistants = MN;
iI.Threads = Tf;
class TN extends qA {
  create(A, e) {
    return this._client.post("/completions", { body: A, ...e, stream: A.stream ?? !1 });
  }
}
class KN extends qA {
  /**
   * Retrieve Container File Content
   */
  retrieve(A, e, r) {
    const { container_id: i } = e;
    return this._client.get(yA`/containers/${i}/files/${A}/content`, {
      ...r,
      headers: TA([{ Accept: "application/binary" }, r == null ? void 0 : r.headers]),
      __binaryResponse: !0
    });
  }
}
let a0 = class extends qA {
  constructor() {
    super(...arguments), this.content = new KN(this._client);
  }
  /**
   * Create a Container File
   *
   * You can send either a multipart/form-data request with the raw file content, or
   * a JSON request with a file ID.
   */
  create(A, e, r) {
    return this._client.post(yA`/containers/${A}/files`, Cg({ body: e, ...r }, this._client));
  }
  /**
   * Retrieve Container File
   */
  retrieve(A, e, r) {
    const { container_id: i } = e;
    return this._client.get(yA`/containers/${i}/files/${A}`, r);
  }
  /**
   * List Container files
   */
  list(A, e = {}, r) {
    return this._client.getAPIList(yA`/containers/${A}/files`, ct, {
      query: e,
      ...r
    });
  }
  /**
   * Delete Container File
   */
  delete(A, e, r) {
    const { container_id: i } = e;
    return this._client.delete(yA`/containers/${i}/files/${A}`, {
      ...r,
      headers: TA([{ Accept: "*/*" }, r == null ? void 0 : r.headers])
    });
  }
};
a0.Content = KN;
class o0 extends qA {
  constructor() {
    super(...arguments), this.files = new a0(this._client);
  }
  /**
   * Create Container
   */
  create(A, e) {
    return this._client.post("/containers", { body: A, ...e });
  }
  /**
   * Retrieve Container
   */
  retrieve(A, e) {
    return this._client.get(yA`/containers/${A}`, e);
  }
  /**
   * List Containers
   */
  list(A = {}, e) {
    return this._client.getAPIList("/containers", ct, { query: A, ...e });
  }
  /**
   * Delete Container
   */
  delete(A, e) {
    return this._client.delete(yA`/containers/${A}`, {
      ...e,
      headers: TA([{ Accept: "*/*" }, e == null ? void 0 : e.headers])
    });
  }
}
o0.Files = a0;
class JN extends qA {
  /**
   * Create items in a conversation with the given ID.
   */
  create(A, e, r) {
    const { include: i, ...n } = e;
    return this._client.post(yA`/conversations/${A}/items`, {
      query: { include: i },
      body: n,
      ...r
    });
  }
  /**
   * Get a single item from a conversation with the given IDs.
   */
  retrieve(A, e, r) {
    const { conversation_id: i, ...n } = e;
    return this._client.get(yA`/conversations/${i}/items/${A}`, { query: n, ...r });
  }
  /**
   * List all items for a conversation with the given ID.
   */
  list(A, e = {}, r) {
    return this._client.getAPIList(yA`/conversations/${A}/items`, ud, { query: e, ...r });
  }
  /**
   * Delete an item from a conversation with the given IDs.
   */
  delete(A, e, r) {
    const { conversation_id: i } = e;
    return this._client.delete(yA`/conversations/${i}/items/${A}`, r);
  }
}
class g0 extends qA {
  constructor() {
    super(...arguments), this.items = new JN(this._client);
  }
  /**
   * Create a conversation.
   */
  create(A = {}, e) {
    return this._client.post("/conversations", { body: A, ...e });
  }
  /**
   * Get a conversation
   */
  retrieve(A, e) {
    return this._client.get(yA`/conversations/${A}`, e);
  }
  /**
   * Update a conversation
   */
  update(A, e, r) {
    return this._client.post(yA`/conversations/${A}`, { body: e, ...r });
  }
  /**
   * Delete a conversation. Items in the conversation will not be deleted.
   */
  delete(A, e) {
    return this._client.delete(yA`/conversations/${A}`, e);
  }
}
g0.Items = JN;
let HN = class extends qA {
  /**
   * Creates an embedding vector representing the input text.
   *
   * @example
   * ```ts
   * const createEmbeddingResponse =
   *   await client.embeddings.create({
   *     input: 'The quick brown fox jumped over the lazy dog',
   *     model: 'text-embedding-3-small',
   *   });
   * ```
   */
  create(A, e) {
    const r = !!A.encoding_format;
    let i = r ? A.encoding_format : "base64";
    r && Jt(this._client).debug("embeddings/user defined encoding_format:", A.encoding_format);
    const n = this._client.post("/embeddings", {
      body: {
        ...A,
        encoding_format: i
      },
      ...e
    });
    return r ? n : (Jt(this._client).debug("embeddings/decoding base64 embeddings from base64"), n._thenUnwrap((s) => (s && s.data && s.data.forEach((a) => {
      const g = a.embedding;
      a.embedding = OH(g);
    }), s)));
  }
};
class PN extends qA {
  /**
   * Get an evaluation run output item by ID.
   */
  retrieve(A, e, r) {
    const { eval_id: i, run_id: n } = e;
    return this._client.get(yA`/evals/${i}/runs/${n}/output_items/${A}`, r);
  }
  /**
   * Get a list of output items for an evaluation run.
   */
  list(A, e, r) {
    const { eval_id: i, ...n } = e;
    return this._client.getAPIList(yA`/evals/${i}/runs/${A}/output_items`, ct, { query: n, ...r });
  }
}
class u0 extends qA {
  constructor() {
    super(...arguments), this.outputItems = new PN(this._client);
  }
  /**
   * Kicks off a new run for a given evaluation, specifying the data source, and what
   * model configuration to use to test. The datasource will be validated against the
   * schema specified in the config of the evaluation.
   */
  create(A, e, r) {
    return this._client.post(yA`/evals/${A}/runs`, { body: e, ...r });
  }
  /**
   * Get an evaluation run by ID.
   */
  retrieve(A, e, r) {
    const { eval_id: i } = e;
    return this._client.get(yA`/evals/${i}/runs/${A}`, r);
  }
  /**
   * Get a list of runs for an evaluation.
   */
  list(A, e = {}, r) {
    return this._client.getAPIList(yA`/evals/${A}/runs`, ct, {
      query: e,
      ...r
    });
  }
  /**
   * Delete an eval run.
   */
  delete(A, e, r) {
    const { eval_id: i } = e;
    return this._client.delete(yA`/evals/${i}/runs/${A}`, r);
  }
  /**
   * Cancel an ongoing evaluation run.
   */
  cancel(A, e, r) {
    const { eval_id: i } = e;
    return this._client.post(yA`/evals/${i}/runs/${A}`, r);
  }
}
u0.OutputItems = PN;
class c0 extends qA {
  constructor() {
    super(...arguments), this.runs = new u0(this._client);
  }
  /**
   * Create the structure of an evaluation that can be used to test a model's
   * performance. An evaluation is a set of testing criteria and the config for a
   * data source, which dictates the schema of the data used in the evaluation. After
   * creating an evaluation, you can run it on different models and model parameters.
   * We support several types of graders and datasources. For more information, see
   * the [Evals guide](https://platform.openai.com/docs/guides/evals).
   */
  create(A, e) {
    return this._client.post("/evals", { body: A, ...e });
  }
  /**
   * Get an evaluation by ID.
   */
  retrieve(A, e) {
    return this._client.get(yA`/evals/${A}`, e);
  }
  /**
   * Update certain properties of an evaluation.
   */
  update(A, e, r) {
    return this._client.post(yA`/evals/${A}`, { body: e, ...r });
  }
  /**
   * List evaluations for a project.
   */
  list(A = {}, e) {
    return this._client.getAPIList("/evals", ct, { query: A, ...e });
  }
  /**
   * Delete an evaluation.
   */
  delete(A, e) {
    return this._client.delete(yA`/evals/${A}`, e);
  }
}
c0.Runs = u0;
let ON = class extends qA {
  /**
   * Upload a file that can be used across various endpoints. Individual files can be
   * up to 512 MB, and the size of all files uploaded by one organization can be up
   * to 1 TB.
   *
   * - The Assistants API supports files up to 2 million tokens and of specific file
   *   types. See the
   *   [Assistants Tools guide](https://platform.openai.com/docs/assistants/tools)
   *   for details.
   * - The Fine-tuning API only supports `.jsonl` files. The input also has certain
   *   required formats for fine-tuning
   *   [chat](https://platform.openai.com/docs/api-reference/fine-tuning/chat-input)
   *   or
   *   [completions](https://platform.openai.com/docs/api-reference/fine-tuning/completions-input)
   *   models.
   * - The Batch API only supports `.jsonl` files up to 200 MB in size. The input
   *   also has a specific required
   *   [format](https://platform.openai.com/docs/api-reference/batch/request-input).
   *
   * Please [contact us](https://help.openai.com/) if you need to increase these
   * storage limits.
   */
  create(A, e) {
    return this._client.post("/files", Cg({ body: A, ...e }, this._client));
  }
  /**
   * Returns information about a specific file.
   */
  retrieve(A, e) {
    return this._client.get(yA`/files/${A}`, e);
  }
  /**
   * Returns a list of files.
   */
  list(A = {}, e) {
    return this._client.getAPIList("/files", ct, { query: A, ...e });
  }
  /**
   * Delete a file and remove it from all vector stores.
   */
  delete(A, e) {
    return this._client.delete(yA`/files/${A}`, e);
  }
  /**
   * Returns the contents of the specified file.
   */
  content(A, e) {
    return this._client.get(yA`/files/${A}/content`, {
      ...e,
      headers: TA([{ Accept: "application/binary" }, e == null ? void 0 : e.headers]),
      __binaryResponse: !0
    });
  }
  /**
   * Waits for the given file to be processed, default timeout is 30 mins.
   */
  async waitForProcessing(A, { pollInterval: e = 5e3, maxWait: r = 30 * 60 * 1e3 } = {}) {
    const i = /* @__PURE__ */ new Set(["processed", "error", "deleted"]), n = Date.now();
    let s = await this.retrieve(A);
    for (; !s.status || !i.has(s.status); )
      if (await FE(e), s = await this.retrieve(A), Date.now() - n > r)
        throw new _f({
          message: `Giving up on waiting for file ${A} to finish processing after ${r} milliseconds.`
        });
    return s;
  }
};
class YN extends qA {
}
let qN = class extends qA {
  /**
   * Run a grader.
   *
   * @example
   * ```ts
   * const response = await client.fineTuning.alpha.graders.run({
   *   grader: {
   *     input: 'input',
   *     name: 'name',
   *     operation: 'eq',
   *     reference: 'reference',
   *     type: 'string_check',
   *   },
   *   model_sample: 'model_sample',
   * });
   * ```
   */
  run(A, e) {
    return this._client.post("/fine_tuning/alpha/graders/run", { body: A, ...e });
  }
  /**
   * Validate a grader.
   *
   * @example
   * ```ts
   * const response =
   *   await client.fineTuning.alpha.graders.validate({
   *     grader: {
   *       input: 'input',
   *       name: 'name',
   *       operation: 'eq',
   *       reference: 'reference',
   *       type: 'string_check',
   *     },
   *   });
   * ```
   */
  validate(A, e) {
    return this._client.post("/fine_tuning/alpha/graders/validate", { body: A, ...e });
  }
};
class I0 extends qA {
  constructor() {
    super(...arguments), this.graders = new qN(this._client);
  }
}
I0.Graders = qN;
class jN extends qA {
  /**
   * **NOTE:** Calling this endpoint requires an [admin API key](../admin-api-keys).
   *
   * This enables organization owners to share fine-tuned models with other projects
   * in their organization.
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const permissionCreateResponse of client.fineTuning.checkpoints.permissions.create(
   *   'ft:gpt-4o-mini-2024-07-18:org:weather:B7R9VjQd',
   *   { project_ids: ['string'] },
   * )) {
   *   // ...
   * }
   * ```
   */
  create(A, e, r) {
    return this._client.getAPIList(yA`/fine_tuning/checkpoints/${A}/permissions`, xf, { body: e, method: "post", ...r });
  }
  /**
   * **NOTE:** This endpoint requires an [admin API key](../admin-api-keys).
   *
   * Organization owners can use this endpoint to view all permissions for a
   * fine-tuned model checkpoint.
   *
   * @example
   * ```ts
   * const permission =
   *   await client.fineTuning.checkpoints.permissions.retrieve(
   *     'ft-AF1WoRqd3aJAHsqc9NY7iL8F',
   *   );
   * ```
   */
  retrieve(A, e = {}, r) {
    return this._client.get(yA`/fine_tuning/checkpoints/${A}/permissions`, {
      query: e,
      ...r
    });
  }
  /**
   * **NOTE:** This endpoint requires an [admin API key](../admin-api-keys).
   *
   * Organization owners can use this endpoint to delete a permission for a
   * fine-tuned model checkpoint.
   *
   * @example
   * ```ts
   * const permission =
   *   await client.fineTuning.checkpoints.permissions.delete(
   *     'cp_zc4Q7MP6XxulcVzj4MZdwsAB',
   *     {
   *       fine_tuned_model_checkpoint:
   *         'ft:gpt-4o-mini-2024-07-18:org:weather:B7R9VjQd',
   *     },
   *   );
   * ```
   */
  delete(A, e, r) {
    const { fine_tuned_model_checkpoint: i } = e;
    return this._client.delete(yA`/fine_tuning/checkpoints/${i}/permissions/${A}`, r);
  }
}
let C0 = class extends qA {
  constructor() {
    super(...arguments), this.permissions = new jN(this._client);
  }
};
C0.Permissions = jN;
class WN extends qA {
  /**
   * List checkpoints for a fine-tuning job.
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const fineTuningJobCheckpoint of client.fineTuning.jobs.checkpoints.list(
   *   'ft-AF1WoRqd3aJAHsqc9NY7iL8F',
   * )) {
   *   // ...
   * }
   * ```
   */
  list(A, e = {}, r) {
    return this._client.getAPIList(yA`/fine_tuning/jobs/${A}/checkpoints`, ct, { query: e, ...r });
  }
}
class l0 extends qA {
  constructor() {
    super(...arguments), this.checkpoints = new WN(this._client);
  }
  /**
   * Creates a fine-tuning job which begins the process of creating a new model from
   * a given dataset.
   *
   * Response includes details of the enqueued job including job status and the name
   * of the fine-tuned models once complete.
   *
   * [Learn more about fine-tuning](https://platform.openai.com/docs/guides/model-optimization)
   *
   * @example
   * ```ts
   * const fineTuningJob = await client.fineTuning.jobs.create({
   *   model: 'gpt-4o-mini',
   *   training_file: 'file-abc123',
   * });
   * ```
   */
  create(A, e) {
    return this._client.post("/fine_tuning/jobs", { body: A, ...e });
  }
  /**
   * Get info about a fine-tuning job.
   *
   * [Learn more about fine-tuning](https://platform.openai.com/docs/guides/model-optimization)
   *
   * @example
   * ```ts
   * const fineTuningJob = await client.fineTuning.jobs.retrieve(
   *   'ft-AF1WoRqd3aJAHsqc9NY7iL8F',
   * );
   * ```
   */
  retrieve(A, e) {
    return this._client.get(yA`/fine_tuning/jobs/${A}`, e);
  }
  /**
   * List your organization's fine-tuning jobs
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const fineTuningJob of client.fineTuning.jobs.list()) {
   *   // ...
   * }
   * ```
   */
  list(A = {}, e) {
    return this._client.getAPIList("/fine_tuning/jobs", ct, { query: A, ...e });
  }
  /**
   * Immediately cancel a fine-tune job.
   *
   * @example
   * ```ts
   * const fineTuningJob = await client.fineTuning.jobs.cancel(
   *   'ft-AF1WoRqd3aJAHsqc9NY7iL8F',
   * );
   * ```
   */
  cancel(A, e) {
    return this._client.post(yA`/fine_tuning/jobs/${A}/cancel`, e);
  }
  /**
   * Get status updates for a fine-tuning job.
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const fineTuningJobEvent of client.fineTuning.jobs.listEvents(
   *   'ft-AF1WoRqd3aJAHsqc9NY7iL8F',
   * )) {
   *   // ...
   * }
   * ```
   */
  listEvents(A, e = {}, r) {
    return this._client.getAPIList(yA`/fine_tuning/jobs/${A}/events`, ct, { query: e, ...r });
  }
  /**
   * Pause a fine-tune job.
   *
   * @example
   * ```ts
   * const fineTuningJob = await client.fineTuning.jobs.pause(
   *   'ft-AF1WoRqd3aJAHsqc9NY7iL8F',
   * );
   * ```
   */
  pause(A, e) {
    return this._client.post(yA`/fine_tuning/jobs/${A}/pause`, e);
  }
  /**
   * Resume a fine-tune job.
   *
   * @example
   * ```ts
   * const fineTuningJob = await client.fineTuning.jobs.resume(
   *   'ft-AF1WoRqd3aJAHsqc9NY7iL8F',
   * );
   * ```
   */
  resume(A, e) {
    return this._client.post(yA`/fine_tuning/jobs/${A}/resume`, e);
  }
}
l0.Checkpoints = WN;
class nI extends qA {
  constructor() {
    super(...arguments), this.methods = new YN(this._client), this.jobs = new l0(this._client), this.checkpoints = new C0(this._client), this.alpha = new I0(this._client);
  }
}
nI.Methods = YN;
nI.Jobs = l0;
nI.Checkpoints = C0;
nI.Alpha = I0;
class VN extends qA {
}
class B0 extends qA {
  constructor() {
    super(...arguments), this.graderModels = new VN(this._client);
  }
}
B0.GraderModels = VN;
class ZN extends qA {
  /**
   * Creates a variation of a given image. This endpoint only supports `dall-e-2`.
   *
   * @example
   * ```ts
   * const imagesResponse = await client.images.createVariation({
   *   image: fs.createReadStream('otter.png'),
   * });
   * ```
   */
  createVariation(A, e) {
    return this._client.post("/images/variations", Cg({ body: A, ...e }, this._client));
  }
  edit(A, e) {
    return this._client.post("/images/edits", Cg({ body: A, ...e, stream: A.stream ?? !1 }, this._client));
  }
  generate(A, e) {
    return this._client.post("/images/generations", { body: A, ...e, stream: A.stream ?? !1 });
  }
}
class XN extends qA {
  /**
   * Retrieves a model instance, providing basic information about the model such as
   * the owner and permissioning.
   */
  retrieve(A, e) {
    return this._client.get(yA`/models/${A}`, e);
  }
  /**
   * Lists the currently available models, and provides basic information about each
   * one such as the owner and availability.
   */
  list(A) {
    return this._client.getAPIList("/models", xf, A);
  }
  /**
   * Delete a fine-tuned model. You must have the Owner role in your organization to
   * delete a model.
   */
  delete(A, e) {
    return this._client.delete(yA`/models/${A}`, e);
  }
}
class zN extends qA {
  /**
   * Classifies if text and/or image inputs are potentially harmful. Learn more in
   * the [moderation guide](https://platform.openai.com/docs/guides/moderation).
   */
  create(A, e) {
    return this._client.post("/moderations", { body: A, ...e });
  }
}
class $N extends qA {
  /**
   * Accept an incoming SIP call and configure the realtime session that will handle
   * it.
   *
   * @example
   * ```ts
   * await client.realtime.calls.accept('call_id', {
   *   type: 'realtime',
   * });
   * ```
   */
  accept(A, e, r) {
    return this._client.post(yA`/realtime/calls/${A}/accept`, {
      body: e,
      ...r,
      headers: TA([{ Accept: "*/*" }, r == null ? void 0 : r.headers])
    });
  }
  /**
   * End an active Realtime API call, whether it was initiated over SIP or WebRTC.
   *
   * @example
   * ```ts
   * await client.realtime.calls.hangup('call_id');
   * ```
   */
  hangup(A, e) {
    return this._client.post(yA`/realtime/calls/${A}/hangup`, {
      ...e,
      headers: TA([{ Accept: "*/*" }, e == null ? void 0 : e.headers])
    });
  }
  /**
   * Transfer an active SIP call to a new destination using the SIP REFER verb.
   *
   * @example
   * ```ts
   * await client.realtime.calls.refer('call_id', {
   *   target_uri: 'tel:+14155550123',
   * });
   * ```
   */
  refer(A, e, r) {
    return this._client.post(yA`/realtime/calls/${A}/refer`, {
      body: e,
      ...r,
      headers: TA([{ Accept: "*/*" }, r == null ? void 0 : r.headers])
    });
  }
  /**
   * Decline an incoming SIP call by returning a SIP status code to the caller.
   *
   * @example
   * ```ts
   * await client.realtime.calls.reject('call_id');
   * ```
   */
  reject(A, e = {}, r) {
    return this._client.post(yA`/realtime/calls/${A}/reject`, {
      body: e,
      ...r,
      headers: TA([{ Accept: "*/*" }, r == null ? void 0 : r.headers])
    });
  }
}
class AL extends qA {
  /**
   * Create a Realtime client secret with an associated session configuration.
   *
   * @example
   * ```ts
   * const clientSecret =
   *   await client.realtime.clientSecrets.create();
   * ```
   */
  create(A, e) {
    return this._client.post("/realtime/client_secrets", { body: A, ...e });
  }
}
class Kf extends qA {
  constructor() {
    super(...arguments), this.clientSecrets = new AL(this._client), this.calls = new $N(this._client);
  }
}
Kf.ClientSecrets = AL;
Kf.Calls = $N;
function YH(t, A) {
  return !A || !jH(A) ? {
    ...t,
    output_parsed: null,
    output: t.output.map((e) => e.type === "function_call" ? {
      ...e,
      parsed_arguments: null
    } : e.type === "message" ? {
      ...e,
      content: e.content.map((r) => ({
        ...r,
        parsed: null
      }))
    } : e)
  } : eL(t, A);
}
function eL(t, A) {
  const e = t.output.map((i) => {
    if (i.type === "function_call")
      return {
        ...i,
        parsed_arguments: ZH(A, i)
      };
    if (i.type === "message") {
      const n = i.content.map((s) => s.type === "output_text" ? {
        ...s,
        parsed: qH(A, s.text)
      } : s);
      return {
        ...i,
        content: n
      };
    }
    return i;
  }), r = Object.assign({}, t, { output: e });
  return Object.getOwnPropertyDescriptor(t, "output_text") || Tw(r), Object.defineProperty(r, "output_parsed", {
    enumerable: !0,
    get() {
      for (const i of r.output)
        if (i.type === "message") {
          for (const n of i.content)
            if (n.type === "output_text" && n.parsed !== null)
              return n.parsed;
        }
      return null;
    }
  }), r;
}
function qH(t, A) {
  var e, r, i, n;
  return ((r = (e = t.text) == null ? void 0 : e.format) == null ? void 0 : r.type) !== "json_schema" ? null : "$parseRaw" in ((i = t.text) == null ? void 0 : i.format) ? ((n = t.text) == null ? void 0 : n.format).$parseRaw(A) : JSON.parse(A);
}
function jH(t) {
  var A;
  return !!A0((A = t.text) == null ? void 0 : A.format);
}
function WH(t) {
  return (t == null ? void 0 : t.$brand) === "auto-parseable-tool";
}
function VH(t, A) {
  return t.find((e) => e.type === "function" && e.name === A);
}
function ZH(t, A) {
  const e = VH(t.tools ?? [], A.name);
  return {
    ...A,
    ...A,
    parsed_arguments: WH(e) ? e.$parseRaw(A.arguments) : e != null && e.strict ? JSON.parse(A.arguments) : null
  };
}
function Tw(t) {
  const A = [];
  for (const e of t.output)
    if (e.type === "message")
      for (const r of e.content)
        r.type === "output_text" && A.push(r.text);
  t.output_text = A.join("");
}
var Ng, nh, Fs, sh, NF, LF, xF, GF;
class E0 extends t0 {
  constructor(A) {
    super(), Ng.add(this), nh.set(this, void 0), Fs.set(this, void 0), sh.set(this, void 0), $A(this, nh, A);
  }
  static createResponse(A, e, r) {
    const i = new E0(e);
    return i._run(() => i._createOrRetrieveResponse(A, e, {
      ...r,
      headers: { ...r == null ? void 0 : r.headers, "X-Stainless-Helper-Method": "stream" }
    })), i;
  }
  async _createOrRetrieveResponse(A, e, r) {
    var a;
    const i = r == null ? void 0 : r.signal;
    i && (i.aborted && this.controller.abort(), i.addEventListener("abort", () => this.controller.abort())), $(this, Ng, "m", NF).call(this);
    let n, s = null;
    "response_id" in e ? (n = await A.responses.retrieve(e.response_id, { stream: !0 }, { ...r, signal: this.controller.signal, stream: !0 }), s = e.starting_after ?? null) : n = await A.responses.create({ ...e, stream: !0 }, { ...r, signal: this.controller.signal }), this._connected();
    for await (const g of n)
      $(this, Ng, "m", LF).call(this, g, s);
    if ((a = n.controller.signal) != null && a.aborted)
      throw new Ur();
    return $(this, Ng, "m", xF).call(this);
  }
  [(nh = /* @__PURE__ */ new WeakMap(), Fs = /* @__PURE__ */ new WeakMap(), sh = /* @__PURE__ */ new WeakMap(), Ng = /* @__PURE__ */ new WeakSet(), NF = function() {
    this.ended || $A(this, Fs, void 0);
  }, LF = function(e, r) {
    if (this.ended)
      return;
    const i = (s, a) => {
      (r == null || a.sequence_number > r) && this._emit(s, a);
    }, n = $(this, Ng, "m", GF).call(this, e);
    switch (i("event", e), e.type) {
      case "response.output_text.delta": {
        const s = n.output[e.output_index];
        if (!s)
          throw new jA(`missing output at index ${e.output_index}`);
        if (s.type === "message") {
          const a = s.content[e.content_index];
          if (!a)
            throw new jA(`missing content at index ${e.content_index}`);
          if (a.type !== "output_text")
            throw new jA(`expected content to be 'output_text', got ${a.type}`);
          i("response.output_text.delta", {
            ...e,
            snapshot: a.text
          });
        }
        break;
      }
      case "response.function_call_arguments.delta": {
        const s = n.output[e.output_index];
        if (!s)
          throw new jA(`missing output at index ${e.output_index}`);
        s.type === "function_call" && i("response.function_call_arguments.delta", {
          ...e,
          snapshot: s.arguments
        });
        break;
      }
      default:
        i(e.type, e);
        break;
    }
  }, xF = function() {
    if (this.ended)
      throw new jA("stream has ended, this shouldn't happen");
    const e = $(this, Fs, "f");
    if (!e)
      throw new jA("request ended without sending any events");
    $A(this, Fs, void 0);
    const r = XH(e, $(this, nh, "f"));
    return $A(this, sh, r), r;
  }, GF = function(e) {
    var i;
    let r = $(this, Fs, "f");
    if (!r) {
      if (e.type !== "response.created")
        throw new jA(`When snapshot hasn't been set yet, expected 'response.created' event, got ${e.type}`);
      return r = $A(this, Fs, e.response), r;
    }
    switch (e.type) {
      case "response.output_item.added": {
        r.output.push(e.item);
        break;
      }
      case "response.content_part.added": {
        const n = r.output[e.output_index];
        if (!n)
          throw new jA(`missing output at index ${e.output_index}`);
        const s = n.type, a = e.part;
        s === "message" && a.type !== "reasoning_text" ? n.content.push(a) : s === "reasoning" && a.type === "reasoning_text" && (n.content || (n.content = []), n.content.push(a));
        break;
      }
      case "response.output_text.delta": {
        const n = r.output[e.output_index];
        if (!n)
          throw new jA(`missing output at index ${e.output_index}`);
        if (n.type === "message") {
          const s = n.content[e.content_index];
          if (!s)
            throw new jA(`missing content at index ${e.content_index}`);
          if (s.type !== "output_text")
            throw new jA(`expected content to be 'output_text', got ${s.type}`);
          s.text += e.delta;
        }
        break;
      }
      case "response.function_call_arguments.delta": {
        const n = r.output[e.output_index];
        if (!n)
          throw new jA(`missing output at index ${e.output_index}`);
        n.type === "function_call" && (n.arguments += e.delta);
        break;
      }
      case "response.reasoning_text.delta": {
        const n = r.output[e.output_index];
        if (!n)
          throw new jA(`missing output at index ${e.output_index}`);
        if (n.type === "reasoning") {
          const s = (i = n.content) == null ? void 0 : i[e.content_index];
          if (!s)
            throw new jA(`missing content at index ${e.content_index}`);
          if (s.type !== "reasoning_text")
            throw new jA(`expected content to be 'reasoning_text', got ${s.type}`);
          s.text += e.delta;
        }
        break;
      }
      case "response.completed": {
        $A(this, Fs, e.response);
        break;
      }
    }
    return r;
  }, Symbol.asyncIterator)]() {
    const A = [], e = [];
    let r = !1;
    return this.on("event", (i) => {
      const n = e.shift();
      n ? n.resolve(i) : A.push(i);
    }), this.on("end", () => {
      r = !0;
      for (const i of e)
        i.resolve(void 0);
      e.length = 0;
    }), this.on("abort", (i) => {
      r = !0;
      for (const n of e)
        n.reject(i);
      e.length = 0;
    }), this.on("error", (i) => {
      r = !0;
      for (const n of e)
        n.reject(i);
      e.length = 0;
    }), {
      next: async () => A.length ? { value: A.shift(), done: !1 } : r ? { value: void 0, done: !0 } : new Promise((n, s) => e.push({ resolve: n, reject: s })).then((n) => n ? { value: n, done: !1 } : { value: void 0, done: !0 }),
      return: async () => (this.abort(), { value: void 0, done: !0 })
    };
  }
  /**
   * @returns a promise that resolves with the final Response, or rejects
   * if an error occurred or the stream ended prematurely without producing a REsponse.
   */
  async finalResponse() {
    await this.done();
    const A = $(this, sh, "f");
    if (!A)
      throw new jA("stream ended without producing a ChatCompletion");
    return A;
  }
}
function XH(t, A) {
  return YH(t, A);
}
class tL extends qA {
  /**
   * Returns a list of input items for a given response.
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const responseItem of client.responses.inputItems.list(
   *   'response_id',
   * )) {
   *   // ...
   * }
   * ```
   */
  list(A, e = {}, r) {
    return this._client.getAPIList(yA`/responses/${A}/input_items`, ct, { query: e, ...r });
  }
}
class rL extends qA {
  /**
   * Get input token counts
   *
   * @example
   * ```ts
   * const response = await client.responses.inputTokens.count();
   * ```
   */
  count(A = {}, e) {
    return this._client.post("/responses/input_tokens", { body: A, ...e });
  }
}
class Jf extends qA {
  constructor() {
    super(...arguments), this.inputItems = new tL(this._client), this.inputTokens = new rL(this._client);
  }
  create(A, e) {
    return this._client.post("/responses", { body: A, ...e, stream: A.stream ?? !1 })._thenUnwrap((r) => ("object" in r && r.object === "response" && Tw(r), r));
  }
  retrieve(A, e = {}, r) {
    return this._client.get(yA`/responses/${A}`, {
      query: e,
      ...r,
      stream: (e == null ? void 0 : e.stream) ?? !1
    })._thenUnwrap((i) => ("object" in i && i.object === "response" && Tw(i), i));
  }
  /**
   * Deletes a model response with the given ID.
   *
   * @example
   * ```ts
   * await client.responses.delete(
   *   'resp_677efb5139a88190b512bc3fef8e535d',
   * );
   * ```
   */
  delete(A, e) {
    return this._client.delete(yA`/responses/${A}`, {
      ...e,
      headers: TA([{ Accept: "*/*" }, e == null ? void 0 : e.headers])
    });
  }
  parse(A, e) {
    return this._client.responses.create(A, e)._thenUnwrap((r) => eL(r, A));
  }
  /**
   * Creates a model response stream
   */
  stream(A, e) {
    return E0.createResponse(this._client, A, e);
  }
  /**
   * Cancels a model response with the given ID. Only responses created with the
   * `background` parameter set to `true` can be cancelled.
   * [Learn more](https://platform.openai.com/docs/guides/background).
   *
   * @example
   * ```ts
   * const response = await client.responses.cancel(
   *   'resp_677efb5139a88190b512bc3fef8e535d',
   * );
   * ```
   */
  cancel(A, e) {
    return this._client.post(yA`/responses/${A}/cancel`, e);
  }
  /**
   * Compact conversation
   *
   * @example
   * ```ts
   * const compactedResponse = await client.responses.compact();
   * ```
   */
  compact(A = {}, e) {
    return this._client.post("/responses/compact", { body: A, ...e });
  }
}
Jf.InputItems = tL;
Jf.InputTokens = rL;
class iL extends qA {
  /**
   * Adds a
   * [Part](https://platform.openai.com/docs/api-reference/uploads/part-object) to an
   * [Upload](https://platform.openai.com/docs/api-reference/uploads/object) object.
   * A Part represents a chunk of bytes from the file you are trying to upload.
   *
   * Each Part can be at most 64 MB, and you can add Parts until you hit the Upload
   * maximum of 8 GB.
   *
   * It is possible to add multiple Parts in parallel. You can decide the intended
   * order of the Parts when you
   * [complete the Upload](https://platform.openai.com/docs/api-reference/uploads/complete).
   */
  create(A, e, r) {
    return this._client.post(yA`/uploads/${A}/parts`, Cg({ body: e, ...r }, this._client));
  }
}
class h0 extends qA {
  constructor() {
    super(...arguments), this.parts = new iL(this._client);
  }
  /**
   * Creates an intermediate
   * [Upload](https://platform.openai.com/docs/api-reference/uploads/object) object
   * that you can add
   * [Parts](https://platform.openai.com/docs/api-reference/uploads/part-object) to.
   * Currently, an Upload can accept at most 8 GB in total and expires after an hour
   * after you create it.
   *
   * Once you complete the Upload, we will create a
   * [File](https://platform.openai.com/docs/api-reference/files/object) object that
   * contains all the parts you uploaded. This File is usable in the rest of our
   * platform as a regular File object.
   *
   * For certain `purpose` values, the correct `mime_type` must be specified. Please
   * refer to documentation for the
   * [supported MIME types for your use case](https://platform.openai.com/docs/assistants/tools/file-search#supported-files).
   *
   * For guidance on the proper filename extensions for each purpose, please follow
   * the documentation on
   * [creating a File](https://platform.openai.com/docs/api-reference/files/create).
   */
  create(A, e) {
    return this._client.post("/uploads", { body: A, ...e });
  }
  /**
   * Cancels the Upload. No Parts may be added after an Upload is cancelled.
   */
  cancel(A, e) {
    return this._client.post(yA`/uploads/${A}/cancel`, e);
  }
  /**
   * Completes the
   * [Upload](https://platform.openai.com/docs/api-reference/uploads/object).
   *
   * Within the returned Upload object, there is a nested
   * [File](https://platform.openai.com/docs/api-reference/files/object) object that
   * is ready to use in the rest of the platform.
   *
   * You can specify the order of the Parts by passing in an ordered list of the Part
   * IDs.
   *
   * The number of bytes uploaded upon completion must match the number of bytes
   * initially specified when creating the Upload object. No Parts may be added after
   * an Upload is completed.
   */
  complete(A, e, r) {
    return this._client.post(yA`/uploads/${A}/complete`, { body: e, ...r });
  }
}
h0.Parts = iL;
const zH = async (t) => {
  const A = await Promise.allSettled(t), e = A.filter((i) => i.status === "rejected");
  if (e.length) {
    for (const i of e)
      console.error(i.reason);
    throw new Error(`${e.length} promise(s) failed - see the above errors`);
  }
  const r = [];
  for (const i of A)
    i.status === "fulfilled" && r.push(i.value);
  return r;
};
class nL extends qA {
  /**
   * Create a vector store file batch.
   */
  create(A, e, r) {
    return this._client.post(yA`/vector_stores/${A}/file_batches`, {
      body: e,
      ...r,
      headers: TA([{ "OpenAI-Beta": "assistants=v2" }, r == null ? void 0 : r.headers])
    });
  }
  /**
   * Retrieves a vector store file batch.
   */
  retrieve(A, e, r) {
    const { vector_store_id: i } = e;
    return this._client.get(yA`/vector_stores/${i}/file_batches/${A}`, {
      ...r,
      headers: TA([{ "OpenAI-Beta": "assistants=v2" }, r == null ? void 0 : r.headers])
    });
  }
  /**
   * Cancel a vector store file batch. This attempts to cancel the processing of
   * files in this batch as soon as possible.
   */
  cancel(A, e, r) {
    const { vector_store_id: i } = e;
    return this._client.post(yA`/vector_stores/${i}/file_batches/${A}/cancel`, {
      ...r,
      headers: TA([{ "OpenAI-Beta": "assistants=v2" }, r == null ? void 0 : r.headers])
    });
  }
  /**
   * Create a vector store batch and poll until all files have been processed.
   */
  async createAndPoll(A, e, r) {
    const i = await this.create(A, e);
    return await this.poll(A, i.id, r);
  }
  /**
   * Returns a list of vector store files in a batch.
   */
  listFiles(A, e, r) {
    const { vector_store_id: i, ...n } = e;
    return this._client.getAPIList(yA`/vector_stores/${i}/file_batches/${A}/files`, ct, { query: n, ...r, headers: TA([{ "OpenAI-Beta": "assistants=v2" }, r == null ? void 0 : r.headers]) });
  }
  /**
   * Wait for the given file batch to be processed.
   *
   * Note: this will return even if one of the files failed to process, you need to
   * check batch.file_counts.failed_count to handle this case.
   */
  async poll(A, e, r) {
    var n;
    const i = TA([
      r == null ? void 0 : r.headers,
      {
        "X-Stainless-Poll-Helper": "true",
        "X-Stainless-Custom-Poll-Interval": ((n = r == null ? void 0 : r.pollIntervalMs) == null ? void 0 : n.toString()) ?? void 0
      }
    ]);
    for (; ; ) {
      const { data: s, response: a } = await this.retrieve(e, { vector_store_id: A }, {
        ...r,
        headers: i
      }).withResponse();
      switch (s.status) {
        case "in_progress":
          let g = 5e3;
          if (r != null && r.pollIntervalMs)
            g = r.pollIntervalMs;
          else {
            const o = a.headers.get("openai-poll-after-ms");
            if (o) {
              const u = parseInt(o);
              isNaN(u) || (g = u);
            }
          }
          await FE(g);
          break;
        case "failed":
        case "cancelled":
        case "completed":
          return s;
      }
    }
  }
  /**
   * Uploads the given files concurrently and then creates a vector store file batch.
   *
   * The concurrency limit is configurable using the `maxConcurrency` parameter.
   */
  async uploadAndPoll(A, { files: e, fileIds: r = [] }, i) {
    if (e == null || e.length == 0)
      throw new Error("No `files` provided to process. If you've already uploaded files you should use `.createAndPoll()` instead");
    const n = (i == null ? void 0 : i.maxConcurrency) ?? 5, s = Math.min(n, e.length), a = this._client, g = e.values(), o = [...r];
    async function u(c) {
      for (let C of c) {
        const E = await a.files.create({ file: C, purpose: "assistants" }, i);
        o.push(E.id);
      }
    }
    const I = Array(s).fill(g).map(u);
    return await zH(I), await this.createAndPoll(A, {
      file_ids: o
    });
  }
}
class sL extends qA {
  /**
   * Create a vector store file by attaching a
   * [File](https://platform.openai.com/docs/api-reference/files) to a
   * [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object).
   */
  create(A, e, r) {
    return this._client.post(yA`/vector_stores/${A}/files`, {
      body: e,
      ...r,
      headers: TA([{ "OpenAI-Beta": "assistants=v2" }, r == null ? void 0 : r.headers])
    });
  }
  /**
   * Retrieves a vector store file.
   */
  retrieve(A, e, r) {
    const { vector_store_id: i } = e;
    return this._client.get(yA`/vector_stores/${i}/files/${A}`, {
      ...r,
      headers: TA([{ "OpenAI-Beta": "assistants=v2" }, r == null ? void 0 : r.headers])
    });
  }
  /**
   * Update attributes on a vector store file.
   */
  update(A, e, r) {
    const { vector_store_id: i, ...n } = e;
    return this._client.post(yA`/vector_stores/${i}/files/${A}`, {
      body: n,
      ...r,
      headers: TA([{ "OpenAI-Beta": "assistants=v2" }, r == null ? void 0 : r.headers])
    });
  }
  /**
   * Returns a list of vector store files.
   */
  list(A, e = {}, r) {
    return this._client.getAPIList(yA`/vector_stores/${A}/files`, ct, {
      query: e,
      ...r,
      headers: TA([{ "OpenAI-Beta": "assistants=v2" }, r == null ? void 0 : r.headers])
    });
  }
  /**
   * Delete a vector store file. This will remove the file from the vector store but
   * the file itself will not be deleted. To delete the file, use the
   * [delete file](https://platform.openai.com/docs/api-reference/files/delete)
   * endpoint.
   */
  delete(A, e, r) {
    const { vector_store_id: i } = e;
    return this._client.delete(yA`/vector_stores/${i}/files/${A}`, {
      ...r,
      headers: TA([{ "OpenAI-Beta": "assistants=v2" }, r == null ? void 0 : r.headers])
    });
  }
  /**
   * Attach a file to the given vector store and wait for it to be processed.
   */
  async createAndPoll(A, e, r) {
    const i = await this.create(A, e, r);
    return await this.poll(A, i.id, r);
  }
  /**
   * Wait for the vector store file to finish processing.
   *
   * Note: this will return even if the file failed to process, you need to check
   * file.last_error and file.status to handle these cases
   */
  async poll(A, e, r) {
    var n;
    const i = TA([
      r == null ? void 0 : r.headers,
      {
        "X-Stainless-Poll-Helper": "true",
        "X-Stainless-Custom-Poll-Interval": ((n = r == null ? void 0 : r.pollIntervalMs) == null ? void 0 : n.toString()) ?? void 0
      }
    ]);
    for (; ; ) {
      const s = await this.retrieve(e, {
        vector_store_id: A
      }, { ...r, headers: i }).withResponse(), a = s.data;
      switch (a.status) {
        case "in_progress":
          let g = 5e3;
          if (r != null && r.pollIntervalMs)
            g = r.pollIntervalMs;
          else {
            const o = s.response.headers.get("openai-poll-after-ms");
            if (o) {
              const u = parseInt(o);
              isNaN(u) || (g = u);
            }
          }
          await FE(g);
          break;
        case "failed":
        case "completed":
          return a;
      }
    }
  }
  /**
   * Upload a file to the `files` API and then attach it to the given vector store.
   *
   * Note the file will be asynchronously processed (you can use the alternative
   * polling helper method to wait for processing to complete).
   */
  async upload(A, e, r) {
    const i = await this._client.files.create({ file: e, purpose: "assistants" }, r);
    return this.create(A, { file_id: i.id }, r);
  }
  /**
   * Add a file to a vector store and poll until processing is complete.
   */
  async uploadAndPoll(A, e, r) {
    const i = await this.upload(A, e, r);
    return await this.poll(A, i.id, r);
  }
  /**
   * Retrieve the parsed contents of a vector store file.
   */
  content(A, e, r) {
    const { vector_store_id: i } = e;
    return this._client.getAPIList(yA`/vector_stores/${i}/files/${A}/content`, xf, { ...r, headers: TA([{ "OpenAI-Beta": "assistants=v2" }, r == null ? void 0 : r.headers]) });
  }
}
class Hf extends qA {
  constructor() {
    super(...arguments), this.files = new sL(this._client), this.fileBatches = new nL(this._client);
  }
  /**
   * Create a vector store.
   */
  create(A, e) {
    return this._client.post("/vector_stores", {
      body: A,
      ...e,
      headers: TA([{ "OpenAI-Beta": "assistants=v2" }, e == null ? void 0 : e.headers])
    });
  }
  /**
   * Retrieves a vector store.
   */
  retrieve(A, e) {
    return this._client.get(yA`/vector_stores/${A}`, {
      ...e,
      headers: TA([{ "OpenAI-Beta": "assistants=v2" }, e == null ? void 0 : e.headers])
    });
  }
  /**
   * Modifies a vector store.
   */
  update(A, e, r) {
    return this._client.post(yA`/vector_stores/${A}`, {
      body: e,
      ...r,
      headers: TA([{ "OpenAI-Beta": "assistants=v2" }, r == null ? void 0 : r.headers])
    });
  }
  /**
   * Returns a list of vector stores.
   */
  list(A = {}, e) {
    return this._client.getAPIList("/vector_stores", ct, {
      query: A,
      ...e,
      headers: TA([{ "OpenAI-Beta": "assistants=v2" }, e == null ? void 0 : e.headers])
    });
  }
  /**
   * Delete a vector store.
   */
  delete(A, e) {
    return this._client.delete(yA`/vector_stores/${A}`, {
      ...e,
      headers: TA([{ "OpenAI-Beta": "assistants=v2" }, e == null ? void 0 : e.headers])
    });
  }
  /**
   * Search a vector store for relevant chunks based on a query and file attributes
   * filter.
   */
  search(A, e, r) {
    return this._client.getAPIList(yA`/vector_stores/${A}/search`, xf, {
      body: e,
      method: "post",
      ...r,
      headers: TA([{ "OpenAI-Beta": "assistants=v2" }, r == null ? void 0 : r.headers])
    });
  }
}
Hf.Files = sL;
Hf.FileBatches = nL;
class aL extends qA {
  /**
   * Create a video
   */
  create(A, e) {
    return this._client.post("/videos", yF({ body: A, ...e }, this._client));
  }
  /**
   * Retrieve a video
   */
  retrieve(A, e) {
    return this._client.get(yA`/videos/${A}`, e);
  }
  /**
   * List videos
   */
  list(A = {}, e) {
    return this._client.getAPIList("/videos", ud, { query: A, ...e });
  }
  /**
   * Delete a video
   */
  delete(A, e) {
    return this._client.delete(yA`/videos/${A}`, e);
  }
  /**
   * Download video content
   */
  downloadContent(A, e = {}, r) {
    return this._client.get(yA`/videos/${A}/content`, {
      query: e,
      ...r,
      headers: TA([{ Accept: "application/binary" }, r == null ? void 0 : r.headers]),
      __binaryResponse: !0
    });
  }
  /**
   * Create a video remix
   */
  remix(A, e, r) {
    return this._client.post(yA`/videos/${A}/remix`, yF({ body: e, ...r }, this._client));
  }
}
var Og, oL, NQ;
class gL extends qA {
  constructor() {
    super(...arguments), Og.add(this);
  }
  /**
   * Validates that the given payload was sent by OpenAI and parses the payload.
   */
  async unwrap(A, e, r = this._client.webhookSecret, i = 300) {
    return await this.verifySignature(A, e, r, i), JSON.parse(A);
  }
  /**
   * Validates whether or not the webhook payload was sent by OpenAI.
   *
   * An error will be raised if the webhook payload was not sent by OpenAI.
   *
   * @param payload - The webhook payload
   * @param headers - The webhook headers
   * @param secret - The webhook secret (optional, will use client secret if not provided)
   * @param tolerance - Maximum age of the webhook in seconds (default: 300 = 5 minutes)
   */
  async verifySignature(A, e, r = this._client.webhookSecret, i = 300) {
    if (typeof crypto > "u" || typeof crypto.subtle.importKey != "function" || typeof crypto.subtle.verify != "function")
      throw new Error("Webhook signature verification is only supported when the `crypto` global is defined");
    $(this, Og, "m", oL).call(this, r);
    const n = TA([e]).values, s = $(this, Og, "m", NQ).call(this, n, "webhook-signature"), a = $(this, Og, "m", NQ).call(this, n, "webhook-timestamp"), g = $(this, Og, "m", NQ).call(this, n, "webhook-id"), o = parseInt(a, 10);
    if (isNaN(o))
      throw new cC("Invalid webhook timestamp format");
    const u = Math.floor(Date.now() / 1e3);
    if (u - o > i)
      throw new cC("Webhook timestamp is too old");
    if (o > u + i)
      throw new cC("Webhook timestamp is too new");
    const I = s.split(" ").map((l) => l.startsWith("v1,") ? l.substring(3) : l), c = r.startsWith("whsec_") ? Buffer.from(r.replace("whsec_", ""), "base64") : Buffer.from(r, "utf-8"), C = g ? `${g}.${a}.${A}` : `${a}.${A}`, E = await crypto.subtle.importKey("raw", c, { name: "HMAC", hash: "SHA-256" }, !1, ["verify"]);
    for (const l of I)
      try {
        const B = Buffer.from(l, "base64");
        if (await crypto.subtle.verify("HMAC", E, B, new TextEncoder().encode(C)))
          return;
      } catch {
        continue;
      }
    throw new cC("The given webhook signature does not match the expected signature");
  }
}
Og = /* @__PURE__ */ new WeakSet(), oL = function(A) {
  if (typeof A != "string" || A.length === 0)
    throw new Error("The webhook secret must either be set using the env var, OPENAI_WEBHOOK_SECRET, on the client class, OpenAI({ webhookSecret: '123' }), or passed to this function");
}, NQ = function(A, e) {
  if (!A)
    throw new Error("Headers are required");
  const r = A.get(e);
  if (r == null)
    throw new Error(`Missing required header: ${e}`);
  return r;
};
var Kw, Q0, LQ, uL;
class ge {
  /**
   * API Client for interfacing with the OpenAI API.
   *
   * @param {string | undefined} [opts.apiKey=process.env['OPENAI_API_KEY'] ?? undefined]
   * @param {string | null | undefined} [opts.organization=process.env['OPENAI_ORG_ID'] ?? null]
   * @param {string | null | undefined} [opts.project=process.env['OPENAI_PROJECT_ID'] ?? null]
   * @param {string | null | undefined} [opts.webhookSecret=process.env['OPENAI_WEBHOOK_SECRET'] ?? null]
   * @param {string} [opts.baseURL=process.env['OPENAI_BASE_URL'] ?? https://api.openai.com/v1] - Override the default base URL for the API.
   * @param {number} [opts.timeout=10 minutes] - The maximum amount of time (in milliseconds) the client will wait for a response before timing out.
   * @param {MergedRequestInit} [opts.fetchOptions] - Additional `RequestInit` options to be passed to `fetch` calls.
   * @param {Fetch} [opts.fetch] - Specify a custom `fetch` function implementation.
   * @param {number} [opts.maxRetries=2] - The maximum number of times the client will retry a request.
   * @param {HeadersLike} opts.defaultHeaders - Default headers to include with every request to the API.
   * @param {Record<string, string | undefined>} opts.defaultQuery - Default query parameters to include with every request to the API.
   * @param {boolean} [opts.dangerouslyAllowBrowser=false] - By default, client-side use of this library is not allowed, as it risks exposing your secret API credentials to attackers.
   */
  constructor({ baseURL: A = _g("OPENAI_BASE_URL"), apiKey: e = _g("OPENAI_API_KEY"), organization: r = _g("OPENAI_ORG_ID") ?? null, project: i = _g("OPENAI_PROJECT_ID") ?? null, webhookSecret: n = _g("OPENAI_WEBHOOK_SECRET") ?? null, ...s } = {}) {
    if (Kw.add(this), LQ.set(this, void 0), this.completions = new TN(this), this.chat = new n0(this), this.embeddings = new HN(this), this.files = new ON(this), this.images = new ZN(this), this.audio = new vE(this), this.moderations = new zN(this), this.models = new XN(this), this.fineTuning = new nI(this), this.graders = new B0(this), this.vectorStores = new Hf(this), this.webhooks = new gL(this), this.beta = new iI(this), this.batches = new bN(this), this.uploads = new h0(this), this.responses = new Jf(this), this.realtime = new Kf(this), this.conversations = new g0(this), this.evals = new c0(this), this.containers = new o0(this), this.videos = new aL(this), e === void 0)
      throw new jA("Missing credentials. Please pass an `apiKey`, or set the `OPENAI_API_KEY` environment variable.");
    const a = {
      apiKey: e,
      organization: r,
      project: i,
      webhookSecret: n,
      ...s,
      baseURL: A || "https://api.openai.com/v1"
    };
    if (!a.dangerouslyAllowBrowser && $J())
      throw new jA(`It looks like you're running in a browser-like environment.

This is disabled by default, as it risks exposing your secret API credentials to attackers.
If you understand the risks and have appropriate mitigations in place,
you can set the \`dangerouslyAllowBrowser\` option to \`true\`, e.g.,

new OpenAI({ apiKey, dangerouslyAllowBrowser: true });

https://help.openai.com/en/articles/5112595-best-practices-for-api-key-safety
`);
    this.baseURL = a.baseURL, this.timeout = a.timeout ?? Q0.DEFAULT_TIMEOUT, this.logger = a.logger ?? console;
    const g = "warn";
    this.logLevel = g, this.logLevel = fF(a.logLevel, "ClientOptions.logLevel", this) ?? fF(_g("OPENAI_LOG"), "process.env['OPENAI_LOG']", this) ?? g, this.fetchOptions = a.fetchOptions, this.maxRetries = a.maxRetries ?? 2, this.fetch = a.fetch ?? iH(), $A(this, LQ, sH), this._options = a, this.apiKey = typeof e == "string" ? e : "Missing Key", this.organization = r, this.project = i, this.webhookSecret = n;
  }
  /**
   * Create a new client instance re-using the same options given to the current client with optional overriding.
   */
  withOptions(A) {
    return new this.constructor({
      ...this._options,
      baseURL: this.baseURL,
      maxRetries: this.maxRetries,
      timeout: this.timeout,
      logger: this.logger,
      logLevel: this.logLevel,
      fetch: this.fetch,
      fetchOptions: this.fetchOptions,
      apiKey: this.apiKey,
      organization: this.organization,
      project: this.project,
      webhookSecret: this.webhookSecret,
      ...A
    });
  }
  defaultQuery() {
    return this._options.defaultQuery;
  }
  validateHeaders({ values: A, nulls: e }) {
  }
  async authHeaders(A) {
    return TA([{ Authorization: `Bearer ${this.apiKey}` }]);
  }
  stringifyQuery(A) {
    return IH(A, { arrayFormat: "brackets" });
  }
  getUserAgent() {
    return `${this.constructor.name}/JS ${Hg}`;
  }
  defaultIdempotencyKey() {
    return `stainless-node-retry-${__()}`;
  }
  makeStatusError(A, e, r, i) {
    return Wt.generate(A, e, r, i);
  }
  async _callApiKey() {
    const A = this._options.apiKey;
    if (typeof A != "function")
      return !1;
    let e;
    try {
      e = await A();
    } catch (r) {
      throw r instanceof jA ? r : new jA(
        `Failed to get token from 'apiKey' function: ${r.message}`,
        // @ts-ignore
        { cause: r }
      );
    }
    if (typeof e != "string" || !e)
      throw new jA(`Expected 'apiKey' function argument to return a string but it returned ${e}`);
    return this.apiKey = e, !0;
  }
  buildURL(A, e, r) {
    const i = !$(this, Kw, "m", uL).call(this) && r || this.baseURL, n = WJ(A) ? new URL(A) : new URL(i + (i.endsWith("/") && A.startsWith("/") ? A.slice(1) : A)), s = this.defaultQuery();
    return VJ(s) || (e = { ...s, ...e }), typeof e == "object" && e && !Array.isArray(e) && (n.search = this.stringifyQuery(e)), n.toString();
  }
  /**
   * Used as a callback for mutating the given `FinalRequestOptions` object.
   */
  async prepareOptions(A) {
    await this._callApiKey();
  }
  /**
   * Used as a callback for mutating the given `RequestInit` object.
   *
   * This is useful for cases where you want to add certain headers based off of
   * the request properties, e.g. `method` or `url`.
   */
  async prepareRequest(A, { url: e, options: r }) {
  }
  get(A, e) {
    return this.methodRequest("get", A, e);
  }
  post(A, e) {
    return this.methodRequest("post", A, e);
  }
  patch(A, e) {
    return this.methodRequest("patch", A, e);
  }
  put(A, e) {
    return this.methodRequest("put", A, e);
  }
  delete(A, e) {
    return this.methodRequest("delete", A, e);
  }
  methodRequest(A, e, r) {
    return this.request(Promise.resolve(r).then((i) => ({ method: A, path: e, ...i })));
  }
  request(A, e = null) {
    return new Lf(this, this.makeRequest(A, e, void 0));
  }
  async makeRequest(A, e, r) {
    var h, Q;
    const i = await A, n = i.maxRetries ?? this.maxRetries;
    e == null && (e = n), await this.prepareOptions(i);
    const { req: s, url: a, timeout: g } = await this.buildRequest(i, {
      retryCount: n - e
    });
    await this.prepareRequest(s, { url: a, options: i });
    const o = "log_" + (Math.random() * (1 << 24) | 0).toString(16).padStart(6, "0"), u = r === void 0 ? "" : `, retryOf: ${r}`, I = Date.now();
    if (Jt(this).debug(`[${o}] sending request`, $a({
      retryOfRequestLogID: r,
      method: i.method,
      url: a,
      options: i,
      headers: s.headers
    })), (h = i.signal) != null && h.aborted)
      throw new Ur();
    const c = new AbortController(), C = await this.fetchWithTimeout(a, s, g, c).catch(kw), E = Date.now();
    if (C instanceof globalThis.Error) {
      const f = `retrying, ${e} attempts remaining`;
      if ((Q = i.signal) != null && Q.aborted)
        throw new Ur();
      const p = Fw(C) || /timed? ?out/i.test(String(C) + ("cause" in C ? String(C.cause) : ""));
      if (e)
        return Jt(this).info(`[${o}] connection ${p ? "timed out" : "failed"} - ${f}`), Jt(this).debug(`[${o}] connection ${p ? "timed out" : "failed"} (${f})`, $a({
          retryOfRequestLogID: r,
          url: a,
          durationMs: E - I,
          message: C.message
        })), this.retryRequest(i, e, r ?? o);
      throw Jt(this).info(`[${o}] connection ${p ? "timed out" : "failed"} - error; no more retries left`), Jt(this).debug(`[${o}] connection ${p ? "timed out" : "failed"} (error; no more retries left)`, $a({
        retryOfRequestLogID: r,
        url: a,
        durationMs: E - I,
        message: C.message
      })), p ? new _f() : new Mf({ cause: C });
    }
    const l = [...C.headers.entries()].filter(([f]) => f === "x-request-id").map(([f, p]) => ", " + f + ": " + JSON.stringify(p)).join(""), B = `[${o}${u}${l}] ${s.method} ${a} ${C.ok ? "succeeded" : "failed"} with status ${C.status} in ${E - I}ms`;
    if (!C.ok) {
      const f = await this.shouldRetry(C);
      if (e && f) {
        const F = `retrying, ${e} attempts remaining`;
        return await nH(C.body), Jt(this).info(`${B} - ${F}`), Jt(this).debug(`[${o}] response error (${F})`, $a({
          retryOfRequestLogID: r,
          url: C.url,
          status: C.status,
          headers: C.headers,
          durationMs: E - I
        })), this.retryRequest(i, e, r ?? o, C.headers);
      }
      const p = f ? "error; no more retries left" : "error; not retryable";
      Jt(this).info(`${B} - ${p}`);
      const y = await C.text().catch((F) => kw(F).message), m = zJ(y), S = m ? void 0 : y;
      throw Jt(this).debug(`[${o}] response error (${p})`, $a({
        retryOfRequestLogID: r,
        url: C.url,
        status: C.status,
        headers: C.headers,
        message: S,
        durationMs: Date.now() - I
      })), this.makeStatusError(C.status, m, S, C.headers);
    }
    return Jt(this).info(B), Jt(this).debug(`[${o}] response start`, $a({
      retryOfRequestLogID: r,
      url: C.url,
      status: C.status,
      headers: C.headers,
      durationMs: E - I
    })), { response: C, options: i, controller: c, requestLogID: o, retryOfRequestLogID: r, startTime: I };
  }
  getAPIList(A, e, r) {
    return this.requestAPIList(e, { method: "get", path: A, ...r });
  }
  requestAPIList(A, e) {
    const r = this.makeRequest(e, null, void 0);
    return new pH(this, r, A);
  }
  async fetchWithTimeout(A, e, r, i) {
    const { signal: n, method: s, ...a } = e || {};
    n && n.addEventListener("abort", () => i.abort());
    const g = setTimeout(() => i.abort(), r), o = globalThis.ReadableStream && a.body instanceof globalThis.ReadableStream || typeof a.body == "object" && a.body !== null && Symbol.asyncIterator in a.body, u = {
      signal: i.signal,
      ...o ? { duplex: "half" } : {},
      method: "GET",
      ...a
    };
    s && (u.method = s.toUpperCase());
    try {
      return await this.fetch.call(void 0, A, u);
    } finally {
      clearTimeout(g);
    }
  }
  async shouldRetry(A) {
    const e = A.headers.get("x-should-retry");
    return e === "true" ? !0 : e === "false" ? !1 : A.status === 408 || A.status === 409 || A.status === 429 || A.status >= 500;
  }
  async retryRequest(A, e, r, i) {
    let n;
    const s = i == null ? void 0 : i.get("retry-after-ms");
    if (s) {
      const g = parseFloat(s);
      Number.isNaN(g) || (n = g);
    }
    const a = i == null ? void 0 : i.get("retry-after");
    if (a && !n) {
      const g = parseFloat(a);
      Number.isNaN(g) ? n = Date.parse(a) - Date.now() : n = g * 1e3;
    }
    if (!(n && 0 <= n && n < 60 * 1e3)) {
      const g = A.maxRetries ?? this.maxRetries;
      n = this.calculateDefaultRetryTimeoutMillis(e, g);
    }
    return await FE(n), this.makeRequest(A, e - 1, r);
  }
  calculateDefaultRetryTimeoutMillis(A, e) {
    const n = e - A, s = Math.min(0.5 * Math.pow(2, n), 8), a = 1 - Math.random() * 0.25;
    return s * a * 1e3;
  }
  async buildRequest(A, { retryCount: e = 0 } = {}) {
    const r = { ...A }, { method: i, path: n, query: s, defaultBaseURL: a } = r, g = this.buildURL(n, s, a);
    "timeout" in r && XJ("timeout", r.timeout), r.timeout = r.timeout ?? this.timeout;
    const { bodyHeaders: o, body: u } = this.buildBody({ options: r }), I = await this.buildHeaders({ options: A, method: i, bodyHeaders: o, retryCount: e });
    return { req: {
      method: i,
      headers: I,
      ...r.signal && { signal: r.signal },
      ...globalThis.ReadableStream && u instanceof globalThis.ReadableStream && { duplex: "half" },
      ...u && { body: u },
      ...this.fetchOptions ?? {},
      ...r.fetchOptions ?? {}
    }, url: g, timeout: r.timeout };
  }
  async buildHeaders({ options: A, method: e, bodyHeaders: r, retryCount: i }) {
    let n = {};
    this.idempotencyHeader && e !== "get" && (A.idempotencyKey || (A.idempotencyKey = this.defaultIdempotencyKey()), n[this.idempotencyHeader] = A.idempotencyKey);
    const s = TA([
      n,
      {
        Accept: "application/json",
        "User-Agent": this.getUserAgent(),
        "X-Stainless-Retry-Count": String(i),
        ...A.timeout ? { "X-Stainless-Timeout": String(Math.trunc(A.timeout / 1e3)) } : {},
        ...rH(),
        "OpenAI-Organization": this.organization,
        "OpenAI-Project": this.project
      },
      await this.authHeaders(A),
      this._options.defaultHeaders,
      r,
      A.headers
    ]);
    return this.validateHeaders(s), s.values;
  }
  buildBody({ options: { body: A, headers: e } }) {
    if (!A)
      return { bodyHeaders: void 0, body: void 0 };
    const r = TA([e]);
    return (
      // Pass raw type verbatim
      ArrayBuffer.isView(A) || A instanceof ArrayBuffer || A instanceof DataView || typeof A == "string" && // Preserve legacy string encoding behavior for now
      r.values.has("content-type") || // `Blob` is superset of `File`
      globalThis.Blob && A instanceof globalThis.Blob || // `FormData` -> `multipart/form-data`
      A instanceof FormData || // `URLSearchParams` -> `application/x-www-form-urlencoded`
      A instanceof URLSearchParams || // Send chunked stream (each chunk has own `length`)
      globalThis.ReadableStream && A instanceof globalThis.ReadableStream ? { bodyHeaders: void 0, body: A } : typeof A == "object" && (Symbol.asyncIterator in A || Symbol.iterator in A && "next" in A && typeof A.next == "function") ? { bodyHeaders: void 0, body: q_(A) } : $(this, LQ, "f").call(this, { body: A, headers: r })
    );
  }
}
Q0 = ge, LQ = /* @__PURE__ */ new WeakMap(), Kw = /* @__PURE__ */ new WeakSet(), uL = function() {
  return this.baseURL !== "https://api.openai.com/v1";
};
ge.OpenAI = Q0;
ge.DEFAULT_TIMEOUT = 6e5;
ge.OpenAIError = jA;
ge.APIError = Wt;
ge.APIConnectionError = Mf;
ge.APIConnectionTimeoutError = _f;
ge.APIUserAbortError = Ur;
ge.NotFoundError = G_;
ge.ConflictError = U_;
ge.RateLimitError = K_;
ge.BadRequestError = N_;
ge.AuthenticationError = L_;
ge.InternalServerError = J_;
ge.PermissionDeniedError = x_;
ge.UnprocessableEntityError = T_;
ge.InvalidWebhookSignatureError = cC;
ge.toFile = SH;
ge.Completions = TN;
ge.Chat = n0;
ge.Embeddings = HN;
ge.Files = ON;
ge.Images = ZN;
ge.Audio = vE;
ge.Moderations = zN;
ge.Models = XN;
ge.FineTuning = nI;
ge.Graders = B0;
ge.VectorStores = Hf;
ge.Webhooks = gL;
ge.Beta = iI;
ge.Batches = bN;
ge.Uploads = h0;
ge.Responses = Jf;
ge.Realtime = Kf;
ge.Conversations = g0;
ge.Evals = c0;
ge.Containers = o0;
ge.Videos = aL;
function cL(t) {
  if (!t || typeof t != "object") return t;
  let A;
  return t.constructor.name === _f.name && "message" in t && typeof t.message == "string" ? (A = new Error(t.message), A.name = "TimeoutError") : t.constructor.name === Ur.name && "message" in t && typeof t.message == "string" ? (A = new Error(t.message), A.name = "AbortError") : "status" in t && t.status === 400 && "message" in t && typeof t.message == "string" && t.message.includes("tool_calls") ? A = $E(t, "INVALID_TOOL_RESULTS") : "status" in t && t.status === 401 ? A = $E(t, "MODEL_AUTHENTICATION") : "status" in t && t.status === 429 ? A = $E(t, "MODEL_RATE_LIMIT") : "status" in t && t.status === 404 ? A = $E(t, "MODEL_NOT_FOUND") : A = t, A;
}
var $H = Object.defineProperty, fe = (t, A) => {
  for (var e in A) $H(t, e, {
    get: A[e],
    enumerable: !0
  });
};
function dn(t) {
  return typeof t == "object" && t !== null && "type" in t && typeof t.type == "string" && "source_type" in t && (t.source_type === "url" || t.source_type === "base64" || t.source_type === "text" || t.source_type === "id");
}
function d0(t) {
  return dn(t) && t.source_type === "url" && "url" in t && typeof t.url == "string";
}
function f0(t) {
  return dn(t) && t.source_type === "base64" && "data" in t && typeof t.data == "string";
}
function AP(t) {
  return dn(t) && t.source_type === "text" && "text" in t && typeof t.text == "string";
}
function IL(t) {
  return dn(t) && t.source_type === "id" && "id" in t && typeof t.id == "string";
}
function CL(t) {
  if (dn(t)) {
    if (t.source_type === "url") return {
      type: "image_url",
      image_url: { url: t.url }
    };
    if (t.source_type === "base64") {
      if (!t.mime_type) throw new Error("mime_type key is required for base64 data.");
      return {
        type: "image_url",
        image_url: { url: `data:${t.mime_type};base64,${t.data}` }
      };
    }
  }
  throw new Error("Unsupported source type. Only 'url' and 'base64' are supported.");
}
function Jw(t) {
  const A = t.split(";")[0].split("/");
  if (A.length !== 2) throw new Error(`Invalid mime type: "${t}" - does not match type/subtype format.`);
  const e = A[0].trim(), r = A[1].trim();
  if (e === "" || r === "") throw new Error(`Invalid mime type: "${t}" - type or subtype is empty.`);
  const i = {};
  for (const n of t.split(";").slice(1)) {
    const s = n.split("=");
    if (s.length !== 2) throw new Error(`Invalid parameter syntax in mime type: "${t}".`);
    const a = s[0].trim(), g = s[1].trim();
    if (a === "") throw new Error(`Invalid parameter syntax in mime type: "${t}".`);
    i[a] = g;
  }
  return {
    type: e,
    subtype: r,
    parameters: i
  };
}
function jC({ dataUrl: t, asTypedArray: A = !1 }) {
  const e = t.match(/^data:(\w+\/\w+);base64,([A-Za-z0-9+/]+=*)$/);
  let r;
  if (e) {
    r = e[1].toLowerCase();
    const i = A ? Uint8Array.from(atob(e[2]), (n) => n.charCodeAt(0)) : e[2];
    return {
      mime_type: r,
      data: i
    };
  }
}
function p0(t, A) {
  if (t.type === "text") {
    if (!A.fromStandardTextBlock) throw new Error(`Converter for ${A.providerName} does not implement \`fromStandardTextBlock\` method.`);
    return A.fromStandardTextBlock(t);
  }
  if (t.type === "image") {
    if (!A.fromStandardImageBlock) throw new Error(`Converter for ${A.providerName} does not implement \`fromStandardImageBlock\` method.`);
    return A.fromStandardImageBlock(t);
  }
  if (t.type === "audio") {
    if (!A.fromStandardAudioBlock) throw new Error(`Converter for ${A.providerName} does not implement \`fromStandardAudioBlock\` method.`);
    return A.fromStandardAudioBlock(t);
  }
  if (t.type === "file") {
    if (!A.fromStandardFileBlock) throw new Error(`Converter for ${A.providerName} does not implement \`fromStandardFileBlock\` method.`);
    return A.fromStandardFileBlock(t);
  }
  throw new Error(`Unable to convert content block type '${t.type}' to provider-specific format: not recognized.`);
}
function lL(t) {
  return typeof t == "object" && t !== null && "type" in t && "content" in t && (typeof t.content == "string" || Array.isArray(t.content));
}
var W = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function sI(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
function y0(t) {
  if (t.__esModule) return t;
  var A = t.default;
  if (typeof A == "function") {
    var e = function r() {
      return this instanceof r ? Reflect.construct(A, arguments, this.constructor) : A.apply(this, arguments);
    };
    e.prototype = A.prototype;
  } else e = {};
  return Object.defineProperty(e, "__esModule", { value: !0 }), Object.keys(t).forEach(function(r) {
    var i = Object.getOwnPropertyDescriptor(t, r);
    Object.defineProperty(e, r, i.get ? i : {
      enumerable: !0,
      get: function() {
        return t[r];
      }
    });
  }), e;
}
var eP = function(t, A) {
  if (typeof t != "string")
    throw new TypeError("Expected a string");
  return A = typeof A > "u" ? "_" : A, t.replace(/([a-z\d])([A-Z])/g, "$1" + A + "$2").replace(/([A-Z]+)([A-Z][a-z\d]+)/g, "$1" + A + "$2").toLowerCase();
};
const tP = /* @__PURE__ */ sI(eP);
var BL = { exports: {} };
const rP = /[\p{Lu}]/u, iP = /[\p{Ll}]/u, UF = /^[\p{Lu}](?![\p{Lu}])/gu, EL = /([\p{Alpha}\p{N}_]|$)/u, hL = /[_.\- ]+/, nP = new RegExp("^" + hL.source), TF = new RegExp(hL.source + EL.source, "gu"), KF = new RegExp("\\d+" + EL.source, "gu"), sP = (t, A, e) => {
  let r = !1, i = !1, n = !1;
  for (let s = 0; s < t.length; s++) {
    const a = t[s];
    r && rP.test(a) ? (t = t.slice(0, s) + "-" + t.slice(s), r = !1, n = i, i = !0, s++) : i && n && iP.test(a) ? (t = t.slice(0, s - 1) + "-" + t.slice(s - 1), n = i, i = !1, r = !0) : (r = A(a) === a && e(a) !== a, n = i, i = e(a) === a && A(a) !== a);
  }
  return t;
}, aP = (t, A) => (UF.lastIndex = 0, t.replace(UF, (e) => A(e))), oP = (t, A) => (TF.lastIndex = 0, KF.lastIndex = 0, t.replace(TF, (e, r) => A(r)).replace(KF, (e) => A(e))), QL = (t, A) => {
  if (!(typeof t == "string" || Array.isArray(t)))
    throw new TypeError("Expected the input to be `string | string[]`");
  if (A = {
    pascalCase: !1,
    preserveConsecutiveUppercase: !1,
    ...A
  }, Array.isArray(t) ? t = t.map((n) => n.trim()).filter((n) => n.length).join("-") : t = t.trim(), t.length === 0)
    return "";
  const e = A.locale === !1 ? (n) => n.toLowerCase() : (n) => n.toLocaleLowerCase(A.locale), r = A.locale === !1 ? (n) => n.toUpperCase() : (n) => n.toLocaleUpperCase(A.locale);
  return t.length === 1 ? A.pascalCase ? r(t) : e(t) : (t !== e(t) && (t = sP(t, e, r)), t = t.replace(nP, ""), A.preserveConsecutiveUppercase ? t = aP(t, e) : t = e(t), A.pascalCase && (t = r(t.charAt(0)) + t.slice(1)), oP(t, r));
};
BL.exports = QL;
BL.exports.default = QL;
function gP(t, A) {
  return (A == null ? void 0 : A[t]) || tP(t);
}
function uP(t, A, e) {
  const r = {};
  for (const i in t) Object.hasOwn(t, i) && (r[A(i, e)] = t[i]);
  return r;
}
var cP = {};
fe(cP, {
  Serializable: () => Kc,
  get_lc_unique_name: () => w0
});
function JF(t) {
  return Array.isArray(t) ? [...t] : { ...t };
}
function IP(t, A) {
  const e = JF(t);
  for (const [r, i] of Object.entries(A)) {
    const [n, ...s] = r.split(".").reverse();
    let a = e;
    for (const g of s.reverse()) {
      if (a[g] === void 0) break;
      a[g] = JF(a[g]), a = a[g];
    }
    a[n] !== void 0 && (a[n] = {
      lc: 1,
      type: "secret",
      id: [i]
    });
  }
  return e;
}
function w0(t) {
  const A = Object.getPrototypeOf(t);
  return typeof t.lc_name == "function" && (typeof A.lc_name != "function" || t.lc_name() !== A.lc_name()) ? t.lc_name() : t.name;
}
var Kc = class dL {
  constructor(A, ...e) {
    R(this, "lc_serializable", !1);
    R(this, "lc_kwargs");
    this.lc_serializable_keys !== void 0 ? this.lc_kwargs = Object.fromEntries(Object.entries(A || {}).filter(([r]) => {
      var i;
      return (i = this.lc_serializable_keys) == null ? void 0 : i.includes(r);
    })) : this.lc_kwargs = A ?? {};
  }
  /**
  * The name of the serializable. Override to provide an alias or
  * to preserve the serialized module name in minified environments.
  *
  * Implemented as a static method to support loading logic.
  */
  static lc_name() {
    return this.name;
  }
  /**
  * The final serialized identifier for the module.
  */
  get lc_id() {
    return [...this.lc_namespace, w0(this.constructor)];
  }
  /**
  * A map of secrets, which will be omitted from serialization.
  * Keys are paths to the secret in constructor args, e.g. "foo.bar.baz".
  * Values are the secret ids, which will be used when deserializing.
  */
  get lc_secrets() {
  }
  /**
  * A map of additional attributes to merge with constructor args.
  * Keys are the attribute names, e.g. "foo".
  * Values are the attribute values, which will be serialized.
  * These attributes need to be accepted by the constructor as arguments.
  */
  get lc_attributes() {
  }
  /**
  * A map of aliases for constructor args.
  * Keys are the attribute names, e.g. "foo".
  * Values are the alias that will replace the key in serialization.
  * This is used to eg. make argument names match Python.
  */
  get lc_aliases() {
  }
  /**
  * A manual list of keys that should be serialized.
  * If not overridden, all fields passed into the constructor will be serialized.
  */
  get lc_serializable_keys() {
  }
  toJSON() {
    if (!this.lc_serializable) return this.toJSONNotImplemented();
    if (this.lc_kwargs instanceof dL || typeof this.lc_kwargs != "object" || Array.isArray(this.lc_kwargs)) return this.toJSONNotImplemented();
    const A = {}, e = {}, r = Object.keys(this.lc_kwargs).reduce((i, n) => (i[n] = n in this ? this[n] : this.lc_kwargs[n], i), {});
    for (let i = Object.getPrototypeOf(this); i; i = Object.getPrototypeOf(i))
      Object.assign(A, Reflect.get(i, "lc_aliases", this)), Object.assign(e, Reflect.get(i, "lc_secrets", this)), Object.assign(r, Reflect.get(i, "lc_attributes", this));
    return Object.keys(e).forEach((i) => {
      let n = this, s = r;
      const [a, ...g] = i.split(".").reverse();
      for (const o of g.reverse()) {
        if (!(o in n) || n[o] === void 0) return;
        (!(o in s) || s[o] === void 0) && (typeof n[o] == "object" && n[o] != null ? s[o] = {} : Array.isArray(n[o]) && (s[o] = [])), n = n[o], s = s[o];
      }
      a in n && n[a] !== void 0 && (s[a] = s[a] || n[a]);
    }), {
      lc: 1,
      type: "constructor",
      id: this.lc_id,
      kwargs: uP(Object.keys(e).length ? IP(r, e) : r, gP, A)
    };
  }
  toJSONNotImplemented() {
    return {
      lc: 1,
      type: "not_implemented",
      id: this.lc_id
    };
  }
};
function WA(t, A) {
  return ne(t) && t.type === A;
}
function ne(t) {
  return typeof t == "object" && t !== null;
}
function En(t) {
  return Array.isArray(t);
}
function GA(t) {
  return typeof t == "string";
}
function Qi(t) {
  return typeof t == "number";
}
function m0(t) {
  return t instanceof Uint8Array;
}
function HF(t) {
  try {
    return JSON.parse(t);
  } catch {
    return;
  }
}
const WC = (t) => t();
function CP(t) {
  if (t.type === "char_location" && GA(t.document_title) && Qi(t.start_char_index) && Qi(t.end_char_index) && GA(t.cited_text)) {
    const { document_title: A, start_char_index: e, end_char_index: r, cited_text: i, ...n } = t;
    return {
      ...n,
      type: "citation",
      source: "char",
      title: A ?? void 0,
      startIndex: e,
      endIndex: r,
      citedText: i
    };
  }
  if (t.type === "page_location" && GA(t.document_title) && Qi(t.start_page_number) && Qi(t.end_page_number) && GA(t.cited_text)) {
    const { document_title: A, start_page_number: e, end_page_number: r, cited_text: i, ...n } = t;
    return {
      ...n,
      type: "citation",
      source: "page",
      title: A ?? void 0,
      startIndex: e,
      endIndex: r,
      citedText: i
    };
  }
  if (t.type === "content_block_location" && GA(t.document_title) && Qi(t.start_block_index) && Qi(t.end_block_index) && GA(t.cited_text)) {
    const { document_title: A, start_block_index: e, end_block_index: r, cited_text: i, ...n } = t;
    return {
      ...n,
      type: "citation",
      source: "block",
      title: A ?? void 0,
      startIndex: e,
      endIndex: r,
      citedText: i
    };
  }
  if (t.type === "web_search_result_location" && GA(t.url) && GA(t.title) && GA(t.encrypted_index) && GA(t.cited_text)) {
    const { url: A, title: e, encrypted_index: r, cited_text: i, ...n } = t;
    return {
      ...n,
      type: "citation",
      source: "url",
      url: A,
      title: e,
      startIndex: Number(r),
      endIndex: Number(r),
      citedText: i
    };
  }
  if (t.type === "search_result_location" && GA(t.source) && GA(t.title) && Qi(t.start_block_index) && Qi(t.end_block_index) && GA(t.cited_text)) {
    const { source: A, title: e, start_block_index: r, end_block_index: i, cited_text: n, ...s } = t;
    return {
      ...s,
      type: "citation",
      source: "search",
      url: A,
      title: e ?? void 0,
      startIndex: r,
      endIndex: i,
      citedText: n
    };
  }
}
function fL(t) {
  if (WA(t, "document") && ne(t.source) && "type" in t.source) {
    if (t.source.type === "base64" && GA(t.source.media_type) && GA(t.source.data)) return {
      type: "file",
      mimeType: t.source.media_type,
      data: t.source.data
    };
    if (t.source.type === "url" && GA(t.source.url)) return {
      type: "file",
      url: t.source.url
    };
    if (t.source.type === "file" && GA(t.source.file_id)) return {
      type: "file",
      fileId: t.source.file_id
    };
    if (t.source.type === "text" && GA(t.source.data)) return {
      type: "file",
      mimeType: String(t.source.media_type ?? "text/plain"),
      data: t.source.data
    };
  } else if (WA(t, "image") && ne(t.source) && "type" in t.source) {
    if (t.source.type === "base64" && GA(t.source.media_type) && GA(t.source.data)) return {
      type: "image",
      mimeType: t.source.media_type,
      data: t.source.data
    };
    if (t.source.type === "url" && GA(t.source.url)) return {
      type: "image",
      url: t.source.url
    };
    if (t.source.type === "file" && GA(t.source.file_id)) return {
      type: "image",
      fileId: t.source.file_id
    };
  }
}
function lP(t) {
  function* A() {
    for (const e of t) {
      const r = fL(e);
      r ? yield r : yield e;
    }
  }
  return Array.from(A());
}
function PF(t) {
  function* A() {
    var r;
    const e = typeof t.content == "string" ? [{
      type: "text",
      text: t.content
    }] : t.content;
    for (const i of e) {
      if (WA(i, "text") && GA(i.text)) {
        const { text: n, citations: s, ...a } = i;
        if (En(s) && s.length) {
          const g = s.reduce((o, u) => {
            const I = CP(u);
            return I ? [...o, I] : o;
          }, []);
          yield {
            ...a,
            type: "text",
            text: n,
            annotations: g
          };
          continue;
        } else {
          yield {
            ...a,
            type: "text",
            text: n
          };
          continue;
        }
      } else if (WA(i, "thinking") && GA(i.thinking)) {
        const { thinking: n, signature: s, ...a } = i;
        yield {
          ...a,
          type: "reasoning",
          reasoning: n,
          signature: s
        };
        continue;
      } else if (WA(i, "redacted_thinking")) {
        yield {
          type: "non_standard",
          value: i
        };
        continue;
      } else if (WA(i, "tool_use") && GA(i.name) && GA(i.id)) {
        yield {
          type: "tool_call",
          id: i.id,
          name: i.name,
          args: i.input
        };
        continue;
      } else if (WA(i, "input_json_delta")) {
        if (EP(t) && ((r = t.tool_call_chunks) != null && r.length)) {
          const n = t.tool_call_chunks[0];
          yield {
            type: "tool_call_chunk",
            id: n.id,
            name: n.name,
            args: n.args,
            index: n.index
          };
          continue;
        }
      } else if (WA(i, "server_tool_use") && GA(i.name) && GA(i.id)) {
        const { name: n, id: s } = i;
        if (n === "web_search") {
          const a = WC(() => {
            if (typeof i.input == "string") return i.input;
            if (ne(i.input) && GA(i.input.query)) return i.input.query;
            if (GA(i.partial_json)) {
              const g = HF(i.partial_json);
              if (g != null && g.query) return g.query;
            }
            return "";
          });
          yield {
            id: s,
            type: "server_tool_call",
            name: "web_search",
            args: { query: a }
          };
          continue;
        } else if (i.name === "code_execution") {
          const a = WC(() => {
            if (typeof i.input == "string") return i.input;
            if (ne(i.input) && GA(i.input.code)) return i.input.code;
            if (GA(i.partial_json)) {
              const g = HF(i.partial_json);
              if (g != null && g.code) return g.code;
            }
            return "";
          });
          yield {
            id: s,
            type: "server_tool_call",
            name: "code_execution",
            args: { code: a }
          };
          continue;
        }
      } else if (WA(i, "web_search_tool_result") && GA(i.tool_use_id) && En(i.content)) {
        const { content: n, tool_use_id: s } = i, a = n.reduce((g, o) => WA(o, "web_search_result") ? [...g, o.url] : g, []);
        yield {
          type: "server_tool_call_result",
          name: "web_search",
          toolCallId: s,
          status: "success",
          output: { urls: a }
        };
        continue;
      } else if (WA(i, "code_execution_tool_result") && GA(i.tool_use_id) && ne(i.content)) {
        yield {
          type: "server_tool_call_result",
          name: "code_execution",
          toolCallId: i.tool_use_id,
          status: "success",
          output: i.content
        };
        continue;
      } else if (WA(i, "mcp_tool_use")) {
        yield {
          id: i.id,
          type: "server_tool_call",
          name: "mcp_tool_use",
          args: i.input
        };
        continue;
      } else if (WA(i, "mcp_tool_result") && GA(i.tool_use_id) && ne(i.content)) {
        yield {
          type: "server_tool_call_result",
          name: "mcp_tool_use",
          toolCallId: i.tool_use_id,
          status: "success",
          output: i.content
        };
        continue;
      } else if (WA(i, "container_upload")) {
        yield {
          type: "server_tool_call",
          name: "container_upload",
          args: i.input
        };
        continue;
      } else if (WA(i, "search_result")) {
        yield {
          id: i.id,
          type: "non_standard",
          value: i
        };
        continue;
      } else if (WA(i, "tool_result")) {
        yield {
          id: i.id,
          type: "non_standard",
          value: i
        };
        continue;
      } else {
        const n = fL(i);
        if (n) {
          yield n;
          continue;
        }
      }
      yield {
        type: "non_standard",
        value: i
      };
    }
  }
  return Array.from(A());
}
const BP = {
  translateContent: PF,
  translateContentChunk: PF
};
function EP(t) {
  return typeof (t == null ? void 0 : t._getType) == "function" && typeof t.concat == "function" && t._getType() === "ai";
}
function hP(t) {
  return d0(t) ? {
    type: t.type,
    mimeType: t.mime_type,
    url: t.url,
    metadata: t.metadata
  } : f0(t) ? {
    type: t.type,
    mimeType: t.mime_type ?? "application/octet-stream",
    data: t.data,
    metadata: t.metadata
  } : IL(t) ? {
    type: t.type,
    mimeType: t.mime_type,
    fileId: t.id,
    metadata: t.metadata
  } : t;
}
function QP(t) {
  return t.map(hP);
}
function dP(t) {
  return !!(WA(t, "image_url") && ne(t.image_url) || WA(t, "input_audio") && ne(t.input_audio) || WA(t, "file") && ne(t.file));
}
function fP(t) {
  if (WA(t, "image_url") && ne(t.image_url) && GA(t.image_url.url)) {
    const A = jC({ dataUrl: t.image_url.url });
    return A ? {
      type: "image",
      mimeType: A.mime_type,
      data: A.data
    } : {
      type: "image",
      url: t.image_url.url
    };
  } else {
    if (WA(t, "input_audio") && ne(t.input_audio) && GA(t.input_audio.data) && GA(t.input_audio.format)) return {
      type: "audio",
      data: t.input_audio.data,
      mimeType: `audio/${t.input_audio.format}`
    };
    if (WA(t, "file") && ne(t.file) && GA(t.file.data)) {
      const A = jC({ dataUrl: t.file.data });
      if (A) return {
        type: "file",
        data: A.data,
        mimeType: A.mime_type
      };
      if (GA(t.file.file_id)) return {
        type: "file",
        fileId: t.file.file_id
      };
    }
  }
  return t;
}
function pP(t) {
  const A = [];
  typeof t.content == "string" ? A.push({
    type: "text",
    text: t.content
  }) : A.push(...D0(t.content));
  for (const e of t.tool_calls ?? []) A.push({
    type: "tool_call",
    id: e.id,
    name: e.name,
    args: e.args
  });
  return A;
}
function yP(t) {
  const A = [];
  typeof t.content == "string" ? A.push({
    type: "text",
    text: t.content
  }) : A.push(...D0(t.content));
  for (const e of t.tool_calls ?? []) A.push({
    type: "tool_call",
    id: e.id,
    name: e.name,
    args: e.args
  });
  return A;
}
function D0(t) {
  const A = [];
  for (const e of t) dP(e) ? A.push(fP(e)) : A.push(e);
  return A;
}
function wP(t) {
  if (t.type === "url_citation") {
    const { url: A, title: e, start_index: r, end_index: i } = t;
    return {
      type: "citation",
      url: A,
      title: e,
      startIndex: r,
      endIndex: i
    };
  }
  if (t.type === "file_citation") {
    const { file_id: A, filename: e, index: r } = t;
    return {
      type: "citation",
      title: e,
      startIndex: r,
      endIndex: r,
      fileId: A
    };
  }
  return t;
}
function pL(t) {
  function* A() {
    var r;
    ne((r = t.additional_kwargs) == null ? void 0 : r.reasoning) && En(t.additional_kwargs.reasoning.summary) && (yield {
      type: "reasoning",
      reasoning: t.additional_kwargs.reasoning.summary.reduce((n, s) => ne(s) && GA(s.text) ? `${n}${s.text}` : n, "")
    });
    const e = typeof t.content == "string" ? [{
      type: "text",
      text: t.content
    }] : t.content;
    for (const i of e) if (WA(i, "text")) {
      const { text: n, annotations: s, ...a } = i;
      Array.isArray(s) ? yield {
        ...a,
        type: "text",
        text: String(n),
        annotations: s.map(wP)
      } : yield {
        ...a,
        type: "text",
        text: String(n)
      };
    }
    for (const i of t.tool_calls ?? []) yield {
      type: "tool_call",
      id: i.id,
      name: i.name,
      args: i.args
    };
    if (ne(t.additional_kwargs) && En(t.additional_kwargs.tool_outputs)) for (const i of t.additional_kwargs.tool_outputs) {
      if (WA(i, "web_search_call")) {
        yield {
          id: i.id,
          type: "server_tool_call",
          name: "web_search",
          args: { query: i.query }
        };
        continue;
      } else if (WA(i, "file_search_call")) {
        yield {
          id: i.id,
          type: "server_tool_call",
          name: "file_search",
          args: { query: i.query }
        };
        continue;
      } else if (WA(i, "computer_call")) {
        yield {
          type: "non_standard",
          value: i
        };
        continue;
      } else if (WA(i, "code_interpreter_call")) {
        if (GA(i.code) && (yield {
          id: i.id,
          type: "server_tool_call",
          name: "code_interpreter",
          args: { code: i.code }
        }), En(i.outputs)) {
          const n = WC(() => {
            if (i.status !== "in_progress") {
              if (i.status === "completed") return 0;
              if (i.status === "incomplete") return 127;
              if (i.status !== "interpreting" && i.status === "failed")
                return 1;
            }
          });
          for (const s of i.outputs) if (WA(s, "logs")) {
            yield {
              type: "server_tool_call_result",
              toolCallId: i.id ?? "",
              status: "success",
              output: {
                type: "code_interpreter_output",
                returnCode: n ?? 0,
                stderr: [0, void 0].includes(n) ? void 0 : String(s.logs),
                stdout: [0, void 0].includes(n) ? String(s.logs) : void 0
              }
            };
            continue;
          }
        }
        continue;
      } else if (WA(i, "mcp_call")) {
        yield {
          id: i.id,
          type: "server_tool_call",
          name: "mcp_call",
          args: i.input
        };
        continue;
      } else if (WA(i, "mcp_list_tools")) {
        yield {
          id: i.id,
          type: "server_tool_call",
          name: "mcp_list_tools",
          args: i.input
        };
        continue;
      } else if (WA(i, "mcp_approval_request")) {
        yield {
          type: "non_standard",
          value: i
        };
        continue;
      } else if (WA(i, "image_generation_call")) {
        yield {
          type: "non_standard",
          value: i
        };
        continue;
      }
      ne(i) && (yield {
        type: "non_standard",
        value: i
      });
    }
  }
  return Array.from(A());
}
function mP(t) {
  function* A() {
    yield* pL(t);
    for (const e of t.tool_call_chunks ?? []) yield {
      type: "tool_call_chunk",
      id: e.id,
      name: e.name,
      args: e.args
    };
  }
  return Array.from(A());
}
const DP = {
  translateContent: (t) => typeof t.content == "string" ? pP(t) : pL(t),
  translateContentChunk: (t) => typeof t.content == "string" ? yP(t) : mP(t)
};
function SP(t, A = "pretty") {
  return A === "pretty" ? FP(t) : JSON.stringify(t);
}
function FP(t) {
  const A = [], e = ` ${t.type.charAt(0).toUpperCase() + t.type.slice(1)} Message `, r = Math.floor((80 - e.length) / 2), i = "=".repeat(r), n = e.length % 2 === 0 ? i : `${i}=`;
  if (A.push(`${i}${e}${n}`), t.type === "ai") {
    const s = t;
    if (s.tool_calls && s.tool_calls.length > 0) {
      A.push("Tool Calls:");
      for (const a of s.tool_calls) {
        A.push(`  ${a.name} (${a.id})`), A.push(` Call ID: ${a.id}`), A.push("  Args:");
        for (const [g, o] of Object.entries(a.args)) A.push(`    ${g}: ${o}`);
      }
    }
  }
  if (t.type === "tool") {
    const s = t;
    s.name && A.push(`Name: ${s.name}`);
  }
  return typeof t.content == "string" && t.content.trim() && (A.length > 1 && A.push(""), A.push(t.content)), A.join(`
`);
}
const Wp = Symbol.for("langchain.message");
function Cs(t, A) {
  return typeof t == "string" ? t === "" ? A : typeof A == "string" ? t + A : Array.isArray(A) && A.length === 0 ? t : Array.isArray(A) && A.some((e) => dn(e)) ? [{
    type: "text",
    source_type: "text",
    text: t
  }, ...A] : [{
    type: "text",
    text: t
  }, ...A] : Array.isArray(A) ? RE(t, A) ?? [...t, ...A] : A === "" ? t : Array.isArray(t) && t.some((e) => dn(e)) ? [...t, {
    type: "file",
    source_type: "text",
    text: A
  }] : [...t, {
    type: "text",
    text: A
  }];
}
function yL(t, A) {
  return t === "error" || A === "error" ? "error" : "success";
}
function kP(t, A) {
  function e(r, i) {
    if (typeof r != "object" || r === null || r === void 0) return r;
    if (i >= A)
      return Array.isArray(r) ? "[Array]" : "[Object]";
    if (Array.isArray(r)) return r.map((s) => e(s, i + 1));
    const n = {};
    for (const s of Object.keys(r)) n[s] = e(r[s], i + 1);
    return n;
  }
  return JSON.stringify(e(t, 0), null, 2);
}
var f_, fs = class extends Kc {
  constructor(A) {
    const e = typeof A == "string" || Array.isArray(A) ? { content: A } : A;
    e.additional_kwargs || (e.additional_kwargs = {}), e.response_metadata || (e.response_metadata = {});
    super(e);
    R(this, "lc_namespace", ["langchain_core", "messages"]);
    R(this, "lc_serializable", !0);
    R(this, f_, !0);
    R(this, "id");
    R(this, "name");
    R(this, "content");
    R(this, "additional_kwargs");
    R(this, "response_metadata");
    this.name = e.name, e.content === void 0 && e.contentBlocks !== void 0 ? (this.content = e.contentBlocks, this.response_metadata = {
      output_version: "v1",
      ...e.response_metadata
    }) : e.content !== void 0 ? (this.content = e.content ?? [], this.response_metadata = e.response_metadata) : (this.content = [], this.response_metadata = e.response_metadata), this.additional_kwargs = e.additional_kwargs, this.id = e.id;
  }
  get lc_aliases() {
    return {
      additional_kwargs: "additional_kwargs",
      response_metadata: "response_metadata"
    };
  }
  /**
  * @deprecated Use .getType() instead or import the proper typeguard.
  * For example:
  *
  * ```ts
  * import { isAIMessage } from "@langchain/core/messages";
  *
  * const message = new AIMessage("Hello!");
  * isAIMessage(message); // true
  * ```
  */
  _getType() {
    return this.type;
  }
  /**
  * @deprecated Use .type instead
  * The type of the message.
  */
  getType() {
    return this._getType();
  }
  /** Get text content of the message. */
  get text() {
    return typeof this.content == "string" ? this.content : Array.isArray(this.content) ? this.content.map((A) => typeof A == "string" ? A : A.type === "text" ? A.text : "").join("") : "";
  }
  get contentBlocks() {
    const A = typeof this.content == "string" ? [{
      type: "text",
      text: this.content
    }] : this.content;
    return [
      QP,
      D0,
      lP
    ].reduce((i, n) => n(i), A);
  }
  toDict() {
    return {
      type: this.getType(),
      data: this.toJSON().kwargs
    };
  }
  static lc_name() {
    return "BaseMessage";
  }
  get _printableFields() {
    return {
      id: this.id,
      content: this.content,
      name: this.name,
      additional_kwargs: this.additional_kwargs,
      response_metadata: this.response_metadata
    };
  }
  static isInstance(A) {
    return typeof A == "object" && A !== null && Wp in A && A[Wp] === !0 && lL(A);
  }
  _updateId(A) {
    this.id = A, this.lc_kwargs.id = A;
  }
  get [(f_ = Wp, Symbol.toStringTag)]() {
    return this.constructor.lc_name();
  }
  [Symbol.for("nodejs.util.inspect.custom")](A) {
    if (A === null) return this;
    const e = kP(this._printableFields, Math.max(4, A));
    return `${this.constructor.lc_name()} ${e}`;
  }
  toFormattedString(A = "pretty") {
    return SP(this, A);
  }
};
function vP(t) {
  return Array.isArray(t) && t.every((A) => typeof A.index == "number");
}
function zt(t = {}, A = {}) {
  const e = { ...t };
  for (const [r, i] of Object.entries(A)) if (e[r] == null) e[r] = i;
  else {
    if (i == null) continue;
    if (typeof e[r] != typeof i || Array.isArray(e[r]) !== Array.isArray(i)) throw new Error(`field[${r}] already exists in the message chunk, but with a different type.`);
    if (typeof e[r] == "string") {
      if (r === "type") continue;
      [
        "id",
        "name",
        "output_version",
        "model_provider"
      ].includes(r) ? i && (e[r] = i) : e[r] += i;
    } else if (typeof e[r] == "object" && !Array.isArray(e[r])) e[r] = zt(e[r], i);
    else if (Array.isArray(e[r])) e[r] = RE(e[r], i);
    else {
      if (e[r] === i) continue;
      console.warn(`field[${r}] already exists in this message chunk and value has unsupported type.`);
    }
  }
  return e;
}
function RE(t, A) {
  if (!(t === void 0 && A === void 0)) {
    if (t === void 0 || A === void 0) return t || A;
    {
      const e = [...t];
      for (const r of A) if (typeof r == "object" && r !== null && "index" in r && typeof r.index == "number") {
        const i = e.findIndex((n) => {
          const s = typeof n == "object", a = "index" in n && n.index === r.index, g = "id" in n && "id" in r && (n == null ? void 0 : n.id) === (r == null ? void 0 : r.id), o = !("id" in n) || !(n != null && n.id) || !("id" in r) || !(r != null && r.id);
          return s && a && (g || o);
        });
        i !== -1 && typeof e[i] == "object" && e[i] !== null ? e[i] = zt(e[i], r) : e.push(r);
      } else {
        if (typeof r == "object" && r !== null && "text" in r && r.text === "") continue;
        e.push(r);
      }
      return e;
    }
  }
}
function wL(t, A) {
  if (!t && !A) throw new Error("Cannot merge two undefined objects.");
  if (!t || !A) return t || A;
  if (typeof t != typeof A) throw new Error(`Cannot merge objects of different types.
Left ${typeof t}
Right ${typeof A}`);
  if (typeof t == "string" && typeof A == "string") return t + A;
  if (Array.isArray(t) && Array.isArray(A)) return RE(t, A);
  if (typeof t == "object" && typeof A == "object") return zt(t, A);
  if (t === A) return t;
  throw new Error(`Can not merge objects of different types.
Left ${t}
Right ${A}`);
}
var Ga = class mL extends fs {
  static isInstance(A) {
    if (!super.isInstance(A)) return !1;
    let e = Object.getPrototypeOf(A);
    for (; e !== null; ) {
      if (e === mL.prototype) return !0;
      e = Object.getPrototypeOf(e);
    }
    return !1;
  }
};
function DL(t) {
  return typeof t.role == "string";
}
function wa(t) {
  return typeof (t == null ? void 0 : t._getType) == "function";
}
function S0(t) {
  return Ga.isInstance(t);
}
function SL(t, A) {
  return zt(t ?? {}, A ?? {});
}
function FL(t, A) {
  const e = {};
  return ((t == null ? void 0 : t.audio) !== void 0 || (A == null ? void 0 : A.audio) !== void 0) && (e.audio = ((t == null ? void 0 : t.audio) ?? 0) + ((A == null ? void 0 : A.audio) ?? 0)), ((t == null ? void 0 : t.image) !== void 0 || (A == null ? void 0 : A.image) !== void 0) && (e.image = ((t == null ? void 0 : t.image) ?? 0) + ((A == null ? void 0 : A.image) ?? 0)), ((t == null ? void 0 : t.video) !== void 0 || (A == null ? void 0 : A.video) !== void 0) && (e.video = ((t == null ? void 0 : t.video) ?? 0) + ((A == null ? void 0 : A.video) ?? 0)), ((t == null ? void 0 : t.document) !== void 0 || (A == null ? void 0 : A.document) !== void 0) && (e.document = ((t == null ? void 0 : t.document) ?? 0) + ((A == null ? void 0 : A.document) ?? 0)), ((t == null ? void 0 : t.text) !== void 0 || (A == null ? void 0 : A.text) !== void 0) && (e.text = ((t == null ? void 0 : t.text) ?? 0) + ((A == null ? void 0 : A.text) ?? 0)), e;
}
function RP(t, A) {
  const e = { ...FL(t, A) };
  return ((t == null ? void 0 : t.cache_read) !== void 0 || (A == null ? void 0 : A.cache_read) !== void 0) && (e.cache_read = ((t == null ? void 0 : t.cache_read) ?? 0) + ((A == null ? void 0 : A.cache_read) ?? 0)), ((t == null ? void 0 : t.cache_creation) !== void 0 || (A == null ? void 0 : A.cache_creation) !== void 0) && (e.cache_creation = ((t == null ? void 0 : t.cache_creation) ?? 0) + ((A == null ? void 0 : A.cache_creation) ?? 0)), e;
}
function bP(t, A) {
  const e = { ...FL(t, A) };
  return ((t == null ? void 0 : t.reasoning) !== void 0 || (A == null ? void 0 : A.reasoning) !== void 0) && (e.reasoning = ((t == null ? void 0 : t.reasoning) ?? 0) + ((A == null ? void 0 : A.reasoning) ?? 0)), e;
}
function kL(t, A) {
  return {
    input_tokens: ((t == null ? void 0 : t.input_tokens) ?? 0) + ((A == null ? void 0 : A.input_tokens) ?? 0),
    output_tokens: ((t == null ? void 0 : t.output_tokens) ?? 0) + ((A == null ? void 0 : A.output_tokens) ?? 0),
    total_tokens: ((t == null ? void 0 : t.total_tokens) ?? 0) + ((A == null ? void 0 : A.total_tokens) ?? 0),
    input_token_details: RP(t == null ? void 0 : t.input_token_details, A == null ? void 0 : A.input_token_details),
    output_token_details: bP(t == null ? void 0 : t.output_token_details, A == null ? void 0 : A.output_token_details)
  };
}
var MP = {};
fe(MP, {
  ToolMessage: () => fn,
  ToolMessageChunk: () => bE,
  defaultToolCallParser: () => k0,
  isDirectToolOutput: () => F0,
  isToolMessage: () => vL,
  isToolMessageChunk: () => RL
});
function F0(t) {
  return t != null && typeof t == "object" && "lc_direct_tool_output" in t && t.lc_direct_tool_output === !0;
}
var fn = class extends fs {
  constructor(A, e, r) {
    const i = typeof A == "string" || Array.isArray(A) ? {
      content: A,
      name: r,
      tool_call_id: e
    } : A;
    super(i);
    R(this, "lc_direct_tool_output", !0);
    R(this, "type", "tool");
    /**
    * Status of the tool invocation.
    * @version 0.2.19
    */
    R(this, "status");
    R(this, "tool_call_id");
    R(this, "metadata");
    /**
    * Artifact of the Tool execution which is not meant to be sent to the model.
    *
    * Should only be specified if it is different from the message content, e.g. if only
    * a subset of the full tool output is being passed as message content but the full
    * output is needed in other parts of the code.
    */
    R(this, "artifact");
    this.tool_call_id = i.tool_call_id, this.artifact = i.artifact, this.status = i.status, this.metadata = i.metadata;
  }
  static lc_name() {
    return "ToolMessage";
  }
  get lc_aliases() {
    return { tool_call_id: "tool_call_id" };
  }
  static isInstance(A) {
    return super.isInstance(A) && A.type === "tool";
  }
  get _printableFields() {
    return {
      ...super._printableFields,
      tool_call_id: this.tool_call_id,
      artifact: this.artifact
    };
  }
}, bE = class extends Ga {
  constructor(A) {
    super(A);
    R(this, "type", "tool");
    R(this, "tool_call_id");
    /**
    * Status of the tool invocation.
    * @version 0.2.19
    */
    R(this, "status");
    /**
    * Artifact of the Tool execution which is not meant to be sent to the model.
    *
    * Should only be specified if it is different from the message content, e.g. if only
    * a subset of the full tool output is being passed as message content but the full
    * output is needed in other parts of the code.
    */
    R(this, "artifact");
    this.tool_call_id = A.tool_call_id, this.artifact = A.artifact, this.status = A.status;
  }
  static lc_name() {
    return "ToolMessageChunk";
  }
  concat(A) {
    const e = this.constructor;
    return new e({
      content: Cs(this.content, A.content),
      additional_kwargs: zt(this.additional_kwargs, A.additional_kwargs),
      response_metadata: zt(this.response_metadata, A.response_metadata),
      artifact: wL(this.artifact, A.artifact),
      tool_call_id: this.tool_call_id,
      id: this.id ?? A.id,
      status: yL(this.status, A.status)
    });
  }
  get _printableFields() {
    return {
      ...super._printableFields,
      tool_call_id: this.tool_call_id,
      artifact: this.artifact
    };
  }
};
function k0(t) {
  const A = [], e = [];
  for (const r of t) if (r.function) {
    const i = r.function.name;
    try {
      const n = JSON.parse(r.function.arguments);
      A.push({
        name: i || "",
        args: n || {},
        id: r.id
      });
    } catch {
      e.push({
        name: i,
        args: r.function.arguments,
        id: r.id,
        error: "Malformed args."
      });
    }
  } else
    continue;
  return [A, e];
}
function vL(t) {
  return typeof t == "object" && t !== null && "getType" in t && typeof t.getType == "function" && t.getType() === "tool";
}
function RL(t) {
  return t._getType() === "tool";
}
var wg = class bL extends fs {
  constructor(e, r) {
    (typeof e == "string" || Array.isArray(e)) && (e = {
      content: e,
      role: r
    });
    super(e);
    R(this, "type", "generic");
    R(this, "role");
    this.role = e.role;
  }
  static lc_name() {
    return "ChatMessage";
  }
  static _chatMessageClass() {
    return bL;
  }
  static isInstance(e) {
    return super.isInstance(e) && e.type === "generic";
  }
  get _printableFields() {
    return {
      ...super._printableFields,
      role: this.role
    };
  }
}, ME = class extends Ga {
  constructor(A, e) {
    (typeof A == "string" || Array.isArray(A)) && (A = {
      content: A,
      role: e
    });
    super(A);
    R(this, "type", "generic");
    R(this, "role");
    this.role = A.role;
  }
  static lc_name() {
    return "ChatMessageChunk";
  }
  concat(A) {
    const e = this.constructor;
    return new e({
      content: Cs(this.content, A.content),
      additional_kwargs: zt(this.additional_kwargs, A.additional_kwargs),
      response_metadata: zt(this.response_metadata, A.response_metadata),
      role: this.role,
      id: this.id ?? A.id
    });
  }
  static isInstance(A) {
    return super.isInstance(A) && A.type === "generic";
  }
  get _printableFields() {
    return {
      ...super._printableFields,
      role: this.role
    };
  }
};
function _P(t) {
  return t._getType() === "generic";
}
function NP(t) {
  return t._getType() === "generic";
}
var Pf = class extends fs {
  constructor(A) {
    super(A);
    R(this, "type", "function");
    R(this, "name");
    this.name = A.name;
  }
  static lc_name() {
    return "FunctionMessage";
  }
}, _E = class extends Ga {
  constructor() {
    super(...arguments);
    R(this, "type", "function");
  }
  static lc_name() {
    return "FunctionMessageChunk";
  }
  concat(A) {
    const e = this.constructor;
    return new e({
      content: Cs(this.content, A.content),
      additional_kwargs: zt(this.additional_kwargs, A.additional_kwargs),
      response_metadata: zt(this.response_metadata, A.response_metadata),
      name: this.name ?? "",
      id: this.id ?? A.id
    });
  }
};
function LP(t) {
  return t._getType() === "function";
}
function xP(t) {
  return t._getType() === "function";
}
var Tr = class extends fs {
  constructor(A) {
    super(A);
    R(this, "type", "human");
  }
  static lc_name() {
    return "HumanMessage";
  }
  static isInstance(A) {
    return super.isInstance(A) && A.type === "human";
  }
}, NE = class extends Ga {
  constructor(A) {
    super(A);
    R(this, "type", "human");
  }
  static lc_name() {
    return "HumanMessageChunk";
  }
  concat(A) {
    const e = this.constructor;
    return new e({
      content: Cs(this.content, A.content),
      additional_kwargs: zt(this.additional_kwargs, A.additional_kwargs),
      response_metadata: zt(this.response_metadata, A.response_metadata),
      id: this.id ?? A.id
    });
  }
  static isInstance(A) {
    return super.isInstance(A) && A.type === "human";
  }
};
function GP(t) {
  return t.getType() === "human";
}
function UP(t) {
  return t.getType() === "human";
}
var Qd = class extends fs {
  constructor(A) {
    super({
      ...A,
      content: []
    });
    R(this, "type", "remove");
    /**
    * The ID of the message to remove.
    */
    R(this, "id");
    this.id = A.id;
  }
  get _printableFields() {
    return {
      ...super._printableFields,
      id: this.id
    };
  }
  static isInstance(A) {
    return super.isInstance(A) && A.type === "remove";
  }
}, Zr = class xQ extends fs {
  constructor(e) {
    super(e);
    R(this, "type", "system");
  }
  static lc_name() {
    return "SystemMessage";
  }
  /**
  * Concatenates a string or another system message with the current system message.
  * @param chunk - The chunk to concatenate with the system message.
  * @returns A new system message with the concatenated content.
  */
  concat(e) {
    if (typeof e == "string") return new xQ({
      ...this,
      content: Cs(this.content, e)
    });
    if (xQ.isInstance(e)) return new xQ({
      ...this,
      additional_kwargs: {
        ...this.additional_kwargs,
        ...e.additional_kwargs
      },
      response_metadata: {
        ...this.response_metadata,
        ...e.response_metadata
      },
      content: Cs(this.content, e.content)
    });
    throw new Error("Unexpected chunk type for system message");
  }
  static isInstance(e) {
    return super.isInstance(e) && e.type === "system";
  }
}, Ma = class extends Ga {
  constructor(A) {
    super(A);
    R(this, "type", "system");
  }
  static lc_name() {
    return "SystemMessageChunk";
  }
  concat(A) {
    const e = this.constructor;
    return new e({
      content: Cs(this.content, A.content),
      additional_kwargs: zt(this.additional_kwargs, A.additional_kwargs),
      response_metadata: zt(this.response_metadata, A.response_metadata),
      id: this.id ?? A.id
    });
  }
  static isInstance(A) {
    return super.isInstance(A) && A.type === "system";
  }
};
function TP(t) {
  return t._getType() === "system";
}
function KP(t) {
  return t._getType() === "system";
}
function ML(t, A) {
  return t.lc_error_code = A, t.message = `${t.message}

Troubleshooting URL: https://docs.langchain.com/oss/javascript/langchain/errors/${A}/
`, t;
}
function xC(t) {
  return !!(t && typeof t == "object" && "type" in t && t.type === "tool_call");
}
function JP(t) {
  return !!(t && typeof t == "object" && "toolCall" in t && t.toolCall != null && typeof t.toolCall == "object" && "id" in t.toolCall && typeof t.toolCall.id == "string");
}
var dd = class extends Error {
  constructor(A, e) {
    super(A);
    R(this, "output");
    this.output = e;
  }
};
function Hw(t, A = Of) {
  t = t.trim();
  const e = t.indexOf("```");
  if (e === -1) return A(t);
  let r = t.substring(e + 3);
  r.startsWith(`json
`) ? r = r.substring(5) : r.startsWith("json") ? r = r.substring(4) : r.startsWith(`
`) && (r = r.substring(1));
  const i = r.indexOf("```");
  let n = r;
  return i !== -1 && (n = r.substring(0, i)), A(n.trim());
}
function HP(t) {
  try {
    return JSON.parse(t);
  } catch {
  }
  const A = t.trim();
  if (A.length === 0) throw new Error("Unexpected end of JSON input");
  let e = 0;
  function r() {
    for (; e < A.length && /\s/.test(A[e]); ) e += 1;
  }
  function i() {
    if (A[e] !== '"') throw new Error(`Expected '"' at position ${e}, got '${A[e]}'`);
    e += 1;
    let u = "", I = !1;
    for (; e < A.length; ) {
      const c = A[e];
      if (I) {
        if (c === "n") u += `
`;
        else if (c === "t") u += "	";
        else if (c === "r") u += "\r";
        else if (c === "\\") u += "\\";
        else if (c === '"') u += '"';
        else if (c === "b") u += "\b";
        else if (c === "f") u += "\f";
        else if (c === "/") u += "/";
        else if (c === "u") {
          const C = A.substring(e + 1, e + 5);
          if (/^[0-9A-Fa-f]{0,4}$/.test(C))
            C.length === 4 ? u += String.fromCharCode(Number.parseInt(C, 16)) : u += `u${C}`, e += C.length;
          else throw new Error(`Invalid unicode escape sequence '\\u${C}' at position ${e}`);
        } else throw new Error(`Invalid escape sequence '\\${c}' at position ${e}`);
        I = !1;
      } else if (c === "\\") I = !0;
      else {
        if (c === '"')
          return e += 1, u;
        u += c;
      }
      e += 1;
    }
    return I && (u += "\\"), u;
  }
  function n() {
    const u = e;
    let I = "";
    if (A[e] === "-" && (I += "-", e += 1), e < A.length && A[e] === "0" && (I += "0", e += 1, A[e] >= "0" && A[e] <= "9"))
      throw new Error(`Invalid number at position ${u}`);
    if (e < A.length && A[e] >= "1" && A[e] <= "9") for (; e < A.length && A[e] >= "0" && A[e] <= "9"; )
      I += A[e], e += 1;
    if (e < A.length && A[e] === ".")
      for (I += ".", e += 1; e < A.length && A[e] >= "0" && A[e] <= "9"; )
        I += A[e], e += 1;
    if (e < A.length && (A[e] === "e" || A[e] === "E"))
      for (I += A[e], e += 1, e < A.length && (A[e] === "+" || A[e] === "-") && (I += A[e], e += 1); e < A.length && A[e] >= "0" && A[e] <= "9"; )
        I += A[e], e += 1;
    if (I === "-") return -0;
    const c = Number.parseFloat(I);
    if (Number.isNaN(c))
      throw e = u, new Error(`Invalid number '${I}' at position ${u}`);
    return c;
  }
  function s() {
    if (r(), e >= A.length) throw new Error(`Unexpected end of input at position ${e}`);
    const u = A[e];
    if (u === "{") return g();
    if (u === "[") return a();
    if (u === '"') return i();
    if ("null".startsWith(A.substring(e, e + 4)))
      return e += Math.min(4, A.length - e), null;
    if ("true".startsWith(A.substring(e, e + 4)))
      return e += Math.min(4, A.length - e), !0;
    if ("false".startsWith(A.substring(e, e + 5)))
      return e += Math.min(5, A.length - e), !1;
    if (u === "-" || u >= "0" && u <= "9") return n();
    throw new Error(`Unexpected character '${u}' at position ${e}`);
  }
  function a() {
    if (A[e] !== "[") throw new Error(`Expected '[' at position ${e}, got '${A[e]}'`);
    const u = [];
    if (e += 1, r(), e >= A.length) return u;
    if (A[e] === "]")
      return e += 1, u;
    for (; e < A.length; ) {
      if (r(), e >= A.length || (u.push(s()), r(), e >= A.length)) return u;
      if (A[e] === "]")
        return e += 1, u;
      if (A[e] === ",") {
        e += 1;
        continue;
      }
      throw new Error(`Expected ',' or ']' at position ${e}, got '${A[e]}'`);
    }
    return u;
  }
  function g() {
    if (A[e] !== "{") throw new Error(`Expected '{' at position ${e}, got '${A[e]}'`);
    const u = {};
    if (e += 1, r(), e >= A.length) return u;
    if (A[e] === "}")
      return e += 1, u;
    for (; e < A.length; ) {
      if (r(), e >= A.length) return u;
      const I = i();
      if (r(), e >= A.length) return u;
      if (A[e] !== ":") throw new Error(`Expected ':' at position ${e}, got '${A[e]}'`);
      if (e += 1, r(), e >= A.length || (u[I] = s(), r(), e >= A.length)) return u;
      if (A[e] === "}")
        return e += 1, u;
      if (A[e] === ",") {
        e += 1;
        continue;
      }
      throw new Error(`Expected ',' or '}' at position ${e}, got '${A[e]}'`);
    }
    return u;
  }
  const o = s();
  if (r(), e < A.length) throw new Error(`Unexpected character '${A[e]}' at position ${e}`);
  return o;
}
function Of(t) {
  try {
    return typeof t > "u" ? null : HP(t);
  } catch {
    return null;
  }
}
function v0(t) {
  switch (t) {
    case "csv":
      return "text/csv";
    case "doc":
      return "application/vnd.openxmlformats-officedocument.wordprocessingml.document";
    case "docx":
      return "application/vnd.openxmlformats-officedocument.wordprocessingml.document";
    case "html":
      return "text/html";
    case "md":
      return "text/markdown";
    case "pdf":
      return "application/pdf";
    case "txt":
      return "text/plain";
    case "xls":
      return "application/vnd.ms-excel";
    case "xlsx":
      return "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet";
    case "gif":
      return "image/gif";
    case "jpeg":
      return "image/jpeg";
    case "jpg":
      return "image/jpeg";
    case "png":
      return "image/png";
    case "webp":
      return "image/webp";
    case "flv":
      return "video/flv";
    case "mkv":
      return "video/mkv";
    case "mov":
      return "video/mov";
    case "mp4":
      return "video/mp4";
    case "mpeg":
      return "video/mpeg";
    case "mpg":
      return "video/mpg";
    case "three_gp":
      return "video/three_gp";
    case "webm":
      return "video/webm";
    case "wmv":
      return "video/wmv";
    default:
      return "application/octet-stream";
  }
}
function PP(t) {
  if (ne(t.document) && ne(t.document.source)) {
    const A = ne(t.document) && GA(t.document.format) ? t.document.format : "", e = v0(A);
    if (ne(t.document.source)) {
      if (ne(t.document.source.s3Location) && GA(t.document.source.s3Location.uri)) return {
        type: "file",
        mimeType: e,
        fileId: t.document.source.s3Location.uri
      };
      if (m0(t.document.source.bytes)) return {
        type: "file",
        mimeType: e,
        data: t.document.source.bytes
      };
      if (GA(t.document.source.text)) return {
        type: "file",
        mimeType: e,
        data: Buffer.from(t.document.source.text).toString("base64")
      };
      if (En(t.document.source.content)) {
        const r = t.document.source.content.reduce((i, n) => ne(n) && GA(n.text) ? i + n.text : i, "");
        return {
          type: "file",
          mimeType: e,
          data: r
        };
      }
    }
  }
  return {
    type: "non_standard",
    value: t
  };
}
function OP(t) {
  if (WA(t, "image") && ne(t.image)) {
    const A = ne(t.image) && GA(t.image.format) ? t.image.format : "", e = v0(A);
    if (ne(t.image.source)) {
      if (ne(t.image.source.s3Location) && GA(t.image.source.s3Location.uri)) return {
        type: "image",
        mimeType: e,
        fileId: t.image.source.s3Location.uri
      };
      if (m0(t.image.source.bytes)) return {
        type: "image",
        mimeType: e,
        data: t.image.source.bytes
      };
    }
  }
  return {
    type: "non_standard",
    value: t
  };
}
function YP(t) {
  if (WA(t, "video") && ne(t.video)) {
    const A = ne(t.video) && GA(t.video.format) ? t.video.format : "", e = v0(A);
    if (ne(t.video.source)) {
      if (ne(t.video.source.s3Location) && GA(t.video.source.s3Location.uri)) return {
        type: "video",
        mimeType: e,
        fileId: t.video.source.s3Location.uri
      };
      if (m0(t.video.source.bytes)) return {
        type: "video",
        mimeType: e,
        data: t.video.source.bytes
      };
    }
  }
  return {
    type: "non_standard",
    value: t
  };
}
function OF(t) {
  function* A() {
    const e = typeof t.content == "string" ? [{
      type: "text",
      text: t.content
    }] : t.content;
    for (const r of e) {
      if (WA(r, "cache_point")) {
        yield {
          type: "non_standard",
          value: r
        };
        continue;
      } else if (WA(r, "citations_content") && ne(r.citationsContent)) {
        const i = En(r.citationsContent.content) ? r.citationsContent.content.reduce((s, a) => ne(a) && GA(a.text) ? s + a.text : s, "") : "", n = En(r.citationsContent.citations) ? r.citationsContent.citations.reduce((s, a) => {
          if (ne(a)) {
            const g = En(a.sourceContent) ? a.sourceContent.reduce((u, I) => ne(I) && GA(I.text) ? u + I.text : u, "") : "", o = WC(() => {
              if (ne(a.location)) {
                const u = a.location.documentChar || a.location.documentPage || a.location.documentChunk;
                if (ne(u)) return {
                  source: Qi(u.documentIndex) ? u.documentIndex.toString() : void 0,
                  startIndex: Qi(u.start) ? u.start : void 0,
                  endIndex: Qi(u.end) ? u.end : void 0
                };
              }
              return {};
            });
            s.push({
              type: "citation",
              citedText: g,
              ...o
            });
          }
          return s;
        }, []) : [];
        yield {
          type: "text",
          text: i,
          annotations: n
        };
        continue;
      } else if (WA(r, "document") && ne(r.document)) {
        yield PP(r);
        continue;
      } else if (WA(r, "guard_content")) {
        yield {
          type: "non_standard",
          value: r
        };
        continue;
      } else if (WA(r, "image") && ne(r.image)) {
        yield OP(r);
        continue;
      } else if (WA(r, "reasoning_content") && GA(r.reasoningText)) {
        yield {
          type: "reasoning",
          reasoning: r.reasoningText
        };
        continue;
      } else if (WA(r, "text") && GA(r.text)) {
        yield {
          type: "text",
          text: r.text
        };
        continue;
      } else if (WA(r, "tool_result")) {
        yield {
          type: "non_standard",
          value: r
        };
        continue;
      } else {
        if (WA(r, "tool_call")) continue;
        if (WA(r, "video") && ne(r.video)) {
          yield YP(r);
          continue;
        }
      }
      yield {
        type: "non_standard",
        value: r
      };
    }
  }
  return Array.from(A());
}
const qP = {
  translateContent: OF,
  translateContentChunk: OF
};
function YF(t) {
  function* A() {
    const e = typeof t.content == "string" ? [{
      type: "text",
      text: t.content
    }] : t.content;
    for (const r of e) {
      if (WA(r, "text") && GA(r.text)) {
        yield {
          type: "text",
          text: r.text
        };
        continue;
      } else if (WA(r, "inlineData") && ne(r.inlineData) && GA(r.inlineData.mimeType) && GA(r.inlineData.data)) {
        yield {
          type: "file",
          mimeType: r.inlineData.mimeType,
          data: r.inlineData.data
        };
        continue;
      } else if (WA(r, "functionCall") && ne(r.functionCall) && GA(r.functionCall.name) && ne(r.functionCall.args)) {
        yield {
          type: "tool_call",
          id: t.id,
          name: r.functionCall.name,
          args: r.functionCall.args
        };
        continue;
      } else if (WA(r, "functionResponse")) {
        yield {
          type: "non_standard",
          value: r
        };
        continue;
      } else if (WA(r, "fileData") && ne(r.fileData) && GA(r.fileData.mimeType) && GA(r.fileData.fileUri)) {
        yield {
          type: "file",
          mimeType: r.fileData.mimeType,
          fileId: r.fileData.fileUri
        };
        continue;
      } else if (WA(r, "executableCode")) {
        yield {
          type: "non_standard",
          value: r
        };
        continue;
      } else if (WA(r, "codeExecutionResult")) {
        yield {
          type: "non_standard",
          value: r
        };
        continue;
      }
      yield {
        type: "non_standard",
        value: r
      };
    }
  }
  return Array.from(A());
}
const jP = {
  translateContent: YF,
  translateContentChunk: YF
};
function qF(t) {
  function* A() {
    const e = typeof t.content == "string" ? [{
      type: "text",
      text: t.content
    }] : t.content;
    for (const r of e) {
      if (WA(r, "reasoning") && GA(r.reasoning)) {
        const i = WC(() => {
          var s;
          const n = e.indexOf(r);
          if (En((s = t.additional_kwargs) == null ? void 0 : s.signatures) && n >= 0) return t.additional_kwargs.signatures.at(n);
        });
        GA(i) ? yield {
          type: "reasoning",
          reasoning: r.reasoning,
          signature: i
        } : yield {
          type: "reasoning",
          reasoning: r.reasoning
        };
        continue;
      } else if (WA(r, "text") && GA(r.text)) {
        yield {
          type: "text",
          text: r.text
        };
        continue;
      } else if (WA(r, "image_url")) {
        if (GA(r.image_url)) if (r.image_url.startsWith("data:")) {
          const i = /^data:([^;]+);base64,(.+)$/, n = r.image_url.match(i);
          n ? yield {
            type: "image",
            data: n[2],
            mimeType: n[1]
          } : yield {
            type: "image",
            url: r.image_url
          };
        } else yield {
          type: "image",
          url: r.image_url
        };
        continue;
      } else if (WA(r, "media") && GA(r.mimeType) && GA(r.data)) {
        yield {
          type: "file",
          mimeType: r.mimeType,
          data: r.data
        };
        continue;
      }
      yield {
        type: "non_standard",
        value: r
      };
    }
  }
  return Array.from(A());
}
const WP = {
  translateContent: qF,
  translateContentChunk: qF
};
globalThis.lc_block_translators_registry ?? (globalThis.lc_block_translators_registry = /* @__PURE__ */ new Map([
  ["anthropic", BP],
  ["bedrock-converse", qP],
  ["google-genai", jP],
  ["google-vertexai", WP],
  ["openai", DP]
]));
function _L(t) {
  return globalThis.lc_block_translators_registry.get(t);
}
var jt = class extends fs {
  constructor(A) {
    var r;
    let e;
    if (typeof A == "string" || Array.isArray(A)) e = {
      content: A,
      tool_calls: [],
      invalid_tool_calls: [],
      additional_kwargs: {}
    };
    else {
      e = A;
      const i = (r = e.additional_kwargs) == null ? void 0 : r.tool_calls, n = e.tool_calls;
      i != null && i.length > 0 && (n === void 0 || n.length === 0) && console.warn([
        "New LangChain packages are available that more efficiently handle",
        `tool calling.

Please upgrade your packages to versions that set`,
        "message tool calls. e.g., `pnpm install @langchain/anthropic`,",
        "pnpm install @langchain/openai`, etc."
      ].join(" "));
      try {
        if (i != null && n === void 0) {
          const [s, a] = k0(i);
          e.tool_calls = s ?? [], e.invalid_tool_calls = a ?? [];
        } else
          e.tool_calls = e.tool_calls ?? [], e.invalid_tool_calls = e.invalid_tool_calls ?? [];
      } catch {
        e.tool_calls = [], e.invalid_tool_calls = [];
      }
      if (e.response_metadata !== void 0 && "output_version" in e.response_metadata && e.response_metadata.output_version === "v1" && (e.contentBlocks = e.content, e.content = void 0), e.contentBlocks !== void 0) {
        e.contentBlocks.push(...e.tool_calls.map((a) => ({
          type: "tool_call",
          id: a.id,
          name: a.name,
          args: a.args
        })));
        const s = e.contentBlocks.filter((a) => a.type === "tool_call").filter((a) => {
          var g;
          return !((g = e.tool_calls) != null && g.some((o) => o.id === a.id && o.name === a.name));
        });
        s.length > 0 && (e.tool_calls = s.map((a) => ({
          type: "tool_call",
          id: a.id,
          name: a.name,
          args: a.args
        })));
      }
    }
    super(e);
    R(this, "type", "ai");
    R(this, "tool_calls", []);
    R(this, "invalid_tool_calls", []);
    R(this, "usage_metadata");
    typeof e != "string" && (this.tool_calls = e.tool_calls ?? this.tool_calls, this.invalid_tool_calls = e.invalid_tool_calls ?? this.invalid_tool_calls), this.usage_metadata = e.usage_metadata;
  }
  get lc_aliases() {
    return {
      ...super.lc_aliases,
      tool_calls: "tool_calls",
      invalid_tool_calls: "invalid_tool_calls"
    };
  }
  static lc_name() {
    return "AIMessage";
  }
  get contentBlocks() {
    if (this.response_metadata && "output_version" in this.response_metadata && this.response_metadata.output_version === "v1") return this.content;
    if (this.response_metadata && "model_provider" in this.response_metadata && typeof this.response_metadata.model_provider == "string") {
      const e = _L(this.response_metadata.model_provider);
      if (e) return e.translateContent(this);
    }
    const A = super.contentBlocks;
    if (this.tool_calls) {
      const e = this.tool_calls.filter((r) => !A.some((i) => i.id === r.id && i.name === r.name));
      A.push(...e.map((r) => ({
        ...r,
        type: "tool_call",
        id: r.id,
        name: r.name,
        args: r.args
      })));
    }
    return A;
  }
  get _printableFields() {
    return {
      ...super._printableFields,
      tool_calls: this.tool_calls,
      invalid_tool_calls: this.invalid_tool_calls,
      usage_metadata: this.usage_metadata
    };
  }
  static isInstance(A) {
    return super.isInstance(A) && A.type === "ai";
  }
};
function Yf(t) {
  return t._getType() === "ai";
}
function Pw(t) {
  return t._getType() === "ai";
}
var kn = class extends Ga {
  constructor(A) {
    let e;
    typeof A == "string" || Array.isArray(A) ? e = {
      content: A,
      tool_calls: [],
      invalid_tool_calls: [],
      tool_call_chunks: []
    } : A.tool_call_chunks === void 0 || A.tool_call_chunks.length === 0 ? e = {
      ...A,
      tool_calls: A.tool_calls ?? [],
      invalid_tool_calls: [],
      tool_call_chunks: [],
      usage_metadata: A.usage_metadata !== void 0 ? A.usage_metadata : void 0
    } : e = {
      ...A,
      ...LL(A.tool_call_chunks ?? []),
      usage_metadata: A.usage_metadata !== void 0 ? A.usage_metadata : void 0
    };
    super(e);
    R(this, "type", "ai");
    R(this, "tool_calls", []);
    R(this, "invalid_tool_calls", []);
    R(this, "tool_call_chunks", []);
    R(this, "usage_metadata");
    this.tool_call_chunks = e.tool_call_chunks ?? this.tool_call_chunks, this.tool_calls = e.tool_calls ?? this.tool_calls, this.invalid_tool_calls = e.invalid_tool_calls ?? this.invalid_tool_calls, this.usage_metadata = e.usage_metadata;
  }
  get lc_aliases() {
    return {
      ...super.lc_aliases,
      tool_calls: "tool_calls",
      invalid_tool_calls: "invalid_tool_calls",
      tool_call_chunks: "tool_call_chunks"
    };
  }
  static lc_name() {
    return "AIMessageChunk";
  }
  get contentBlocks() {
    if (this.response_metadata && "output_version" in this.response_metadata && this.response_metadata.output_version === "v1") return this.content;
    if (this.response_metadata && "model_provider" in this.response_metadata && typeof this.response_metadata.model_provider == "string") {
      const e = _L(this.response_metadata.model_provider);
      if (e) return e.translateContent(this);
    }
    const A = super.contentBlocks;
    if (this.tool_calls && typeof this.content != "string") {
      const e = this.content.filter((r) => r.type === "tool_call").map((r) => r.id);
      for (const r of this.tool_calls) r.id && !e.includes(r.id) && A.push({
        ...r,
        type: "tool_call",
        id: r.id,
        name: r.name,
        args: r.args
      });
    }
    return A;
  }
  get _printableFields() {
    return {
      ...super._printableFields,
      tool_calls: this.tool_calls,
      tool_call_chunks: this.tool_call_chunks,
      invalid_tool_calls: this.invalid_tool_calls,
      usage_metadata: this.usage_metadata
    };
  }
  concat(A) {
    const e = {
      content: Cs(this.content, A.content),
      additional_kwargs: zt(this.additional_kwargs, A.additional_kwargs),
      response_metadata: SL(this.response_metadata, A.response_metadata),
      tool_call_chunks: [],
      id: this.id ?? A.id
    };
    if (this.tool_call_chunks !== void 0 || A.tool_call_chunks !== void 0) {
      const i = RE(this.tool_call_chunks, A.tool_call_chunks);
      i !== void 0 && i.length > 0 && (e.tool_call_chunks = i);
    }
    (this.usage_metadata !== void 0 || A.usage_metadata !== void 0) && (e.usage_metadata = kL(this.usage_metadata, A.usage_metadata));
    const r = this.constructor;
    return new r(e);
  }
  static isInstance(A) {
    return super.isInstance(A) && A.type === "ai";
  }
};
const NL = (t) => t();
function VP(t) {
  return xC(t) ? t : typeof t.id == "string" && t.type === "function" && typeof t.function == "object" && t.function !== null && "arguments" in t.function && typeof t.function.arguments == "string" && "name" in t.function && typeof t.function.name == "string" ? {
    id: t.id,
    args: JSON.parse(t.function.arguments),
    name: t.function.name,
    type: "tool_call"
  } : t;
}
function ZP(t) {
  return typeof t == "object" && t != null && t.lc === 1 && Array.isArray(t.id) && t.kwargs != null && typeof t.kwargs == "object";
}
function Vp(t) {
  let A, e;
  if (ZP(t)) {
    const r = t.id.at(-1);
    r === "HumanMessage" || r === "HumanMessageChunk" ? A = "user" : r === "AIMessage" || r === "AIMessageChunk" ? A = "assistant" : r === "SystemMessage" || r === "SystemMessageChunk" ? A = "system" : r === "FunctionMessage" || r === "FunctionMessageChunk" ? A = "function" : r === "ToolMessage" || r === "ToolMessageChunk" ? A = "tool" : A = "unknown", e = t.kwargs;
  } else {
    const { type: r, ...i } = t;
    A = r, e = i;
  }
  if (A === "human" || A === "user") return new Tr(e);
  if (A === "ai" || A === "assistant") {
    const { tool_calls: r, ...i } = e;
    if (!Array.isArray(r)) return new jt(e);
    const n = r.map(VP);
    return new jt({
      ...i,
      tool_calls: n
    });
  } else {
    if (A === "system") return new Zr(e);
    if (A === "developer") return new Zr({
      ...e,
      additional_kwargs: {
        ...e.additional_kwargs,
        __openai_role__: "developer"
      }
    });
    if (A === "tool" && "tool_call_id" in e) return new fn({
      ...e,
      content: e.content,
      tool_call_id: e.tool_call_id,
      name: e.name
    });
    if (A === "remove" && "id" in e && typeof e.id == "string") return new Qd({
      ...e,
      id: e.id
    });
    throw ML(/* @__PURE__ */ new Error(`Unable to coerce message from array: only human, AI, system, developer, or tool message coercion is currently supported.

Received: ${JSON.stringify(t, null, 2)}`), "MESSAGE_COERCION_FAILURE");
  }
}
function GC(t) {
  if (typeof t == "string") return new Tr(t);
  if (wa(t)) return t;
  if (Array.isArray(t)) {
    const [A, e] = t;
    return Vp({
      type: A,
      content: e
    });
  } else if (DL(t)) {
    const { role: A, ...e } = t;
    return Vp({
      ...e,
      type: A
    });
  } else return Vp(t);
}
function R0(t, A = "Human", e = "AI") {
  const r = [];
  for (const i of t) {
    let n;
    if (i._getType() === "human") n = A;
    else if (i._getType() === "ai") n = e;
    else if (i._getType() === "system") n = "System";
    else if (i._getType() === "tool") n = "Tool";
    else if (i._getType() === "generic") n = i.role;
    else throw new Error(`Got unsupported message type: ${i._getType()}`);
    const s = i.name ? `${i.name}, ` : "", a = typeof i.content == "string" ? i.content : JSON.stringify(i.content, null, 2);
    r.push(`${n}: ${s}${a}`);
  }
  return r.join(`
`);
}
function XP(t) {
  if (t.data !== void 0) return t;
  {
    const A = t;
    return {
      type: A.type,
      data: {
        content: A.text,
        role: A.role,
        name: void 0,
        tool_call_id: void 0
      }
    };
  }
}
function b0(t) {
  const A = XP(t);
  switch (A.type) {
    case "human":
      return new Tr(A.data);
    case "ai":
      return new jt(A.data);
    case "system":
      return new Zr(A.data);
    case "function":
      if (A.data.name === void 0) throw new Error("Name must be defined for function messages");
      return new Pf(A.data);
    case "tool":
      if (A.data.tool_call_id === void 0) throw new Error("Tool call ID must be defined for tool messages");
      return new fn(A.data);
    case "generic":
      if (A.data.role === void 0) throw new Error("Role must be defined for chat messages");
      return new wg(A.data);
    default:
      throw new Error(`Got unexpected type: ${A.type}`);
  }
}
function zP(t) {
  return t.map(b0);
}
function $P(t) {
  return t.map((A) => A.toDict());
}
function fd(t) {
  var e;
  const A = t._getType();
  if (A === "human") return new NE({ ...t });
  if (A === "ai") {
    let r = { ...t };
    return "tool_calls" in r && (r = {
      ...r,
      tool_call_chunks: (e = r.tool_calls) == null ? void 0 : e.map((i) => ({
        ...i,
        type: "tool_call_chunk",
        index: void 0,
        args: JSON.stringify(i.args)
      }))
    }), new kn({ ...r });
  } else {
    if (A === "system") return new Ma({ ...t });
    if (A === "function") return new _E({ ...t });
    if (wg.isInstance(t)) return new ME({ ...t });
    throw new Error("Unknown message type.");
  }
}
function LL(t) {
  var i, n;
  const A = t.reduce((s, a) => {
    const g = s.findIndex(([o]) => "id" in a && a.id && "index" in a && a.index !== void 0 ? a.id === o.id && a.index === o.index : "id" in a && a.id ? a.id === o.id : "index" in a && a.index !== void 0 ? a.index === o.index : !1);
    return g !== -1 ? s[g].push(a) : s.push([a]), s;
  }, []), e = [], r = [];
  for (const s of A) {
    let a = null;
    const g = ((i = s[0]) == null ? void 0 : i.name) ?? "", o = s.map((c) => c.args || "").join("").trim(), u = o.length ? o : "{}", I = (n = s[0]) == null ? void 0 : n.id;
    try {
      if (a = Of(u), !I || a === null || typeof a != "object" || Array.isArray(a)) throw new Error("Malformed tool call chunk args.");
      e.push({
        name: g,
        args: a,
        id: I,
        type: "tool_call"
      });
    } catch {
      r.push({
        name: g,
        args: u,
        id: I,
        error: "Malformed args.",
        type: "invalid_tool_call"
      });
    }
  }
  return {
    tool_call_chunks: t,
    tool_calls: e,
    invalid_tool_calls: r
  };
}
const xL = Symbol.for("ls:tracing_async_local_storage"), UC = Symbol.for("lc:context_variables"), AO = (t) => {
  globalThis[xL] = t;
}, VC = () => globalThis[xL];
var eO = {};
fe(eO, {
  getEnv: () => M0,
  getEnvironmentVariable: () => hn,
  getRuntimeEnvironment: () => JL,
  isBrowser: () => GL,
  isDeno: () => qf,
  isJsDom: () => TL,
  isNode: () => KL,
  isWebWorker: () => UL
});
const GL = () => typeof window < "u" && typeof window.document < "u", UL = () => typeof globalThis == "object" && globalThis.constructor && globalThis.constructor.name === "DedicatedWorkerGlobalScope", TL = () => typeof window < "u" && window.name === "nodejs" || typeof navigator < "u" && navigator.userAgent.includes("jsdom"), qf = () => typeof Deno < "u", KL = () => typeof process < "u" && typeof process.versions < "u" && typeof process.versions.node < "u" && !qf(), M0 = () => {
  let t;
  return GL() ? t = "browser" : KL() ? t = "node" : UL() ? t = "webworker" : TL() ? t = "jsdom" : qf() ? t = "deno" : t = "other", t;
};
let Zp;
function JL() {
  return Zp === void 0 && (Zp = {
    library: "langchain-js",
    runtime: M0()
  }), Zp;
}
function hn(t) {
  var A;
  try {
    return typeof process < "u" ? (A = process.env) == null ? void 0 : A[t] : qf() ? Deno == null ? void 0 : Deno.env.get(t) : void 0;
  } catch {
    return;
  }
}
const tO = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i;
function GQ(t) {
  return typeof t == "string" && tO.test(t);
}
const Gt = [];
for (let t = 0; t < 256; ++t)
  Gt.push((t + 256).toString(16).slice(1));
function rO(t, A = 0) {
  return (Gt[t[A + 0]] + Gt[t[A + 1]] + Gt[t[A + 2]] + Gt[t[A + 3]] + "-" + Gt[t[A + 4]] + Gt[t[A + 5]] + "-" + Gt[t[A + 6]] + Gt[t[A + 7]] + "-" + Gt[t[A + 8]] + Gt[t[A + 9]] + "-" + Gt[t[A + 10]] + Gt[t[A + 11]] + Gt[t[A + 12]] + Gt[t[A + 13]] + Gt[t[A + 14]] + Gt[t[A + 15]]).toLowerCase();
}
const UQ = new Uint8Array(256);
let ah = UQ.length;
function iO() {
  return ah > UQ.length - 16 && (DE.randomFillSync(UQ), ah = 0), UQ.slice(ah, ah += 16);
}
const jF = {
  randomUUID: DE.randomUUID
};
function Hn(t, A, e) {
  if (jF.randomUUID && !t)
    return jF.randomUUID();
  t = t || {};
  const r = t.random || (t.rng || iO)();
  return r[6] = r[6] & 15 | 64, r[8] = r[8] & 63 | 128, rO(r);
}
var nO = {};
fe(nO, {
  BaseCallbackHandler: () => LE,
  callbackHandlerPrefersStreaming: () => _0,
  isBaseCallbackHandler: () => HL
});
var sO = class {
};
function _0(t) {
  return "lc_prefer_streaming" in t && t.lc_prefer_streaming;
}
var LE = class extends sO {
  constructor(A) {
    super();
    R(this, "lc_serializable", !1);
    R(this, "lc_kwargs");
    R(this, "ignoreLLM", !1);
    R(this, "ignoreChain", !1);
    R(this, "ignoreAgent", !1);
    R(this, "ignoreRetriever", !1);
    R(this, "ignoreCustomEvent", !1);
    R(this, "raiseError", !1);
    R(this, "awaitHandlers", hn("LANGCHAIN_CALLBACKS_BACKGROUND") === "false");
    this.lc_kwargs = A || {}, A && (this.ignoreLLM = A.ignoreLLM ?? this.ignoreLLM, this.ignoreChain = A.ignoreChain ?? this.ignoreChain, this.ignoreAgent = A.ignoreAgent ?? this.ignoreAgent, this.ignoreRetriever = A.ignoreRetriever ?? this.ignoreRetriever, this.ignoreCustomEvent = A.ignoreCustomEvent ?? this.ignoreCustomEvent, this.raiseError = A.raiseError ?? this.raiseError, this.awaitHandlers = this.raiseError || (A._awaitHandler ?? this.awaitHandlers));
  }
  get lc_namespace() {
    return [
      "langchain_core",
      "callbacks",
      this.name
    ];
  }
  get lc_secrets() {
  }
  get lc_attributes() {
  }
  get lc_aliases() {
  }
  get lc_serializable_keys() {
  }
  /**
  * The name of the serializable. Override to provide an alias or
  * to preserve the serialized module name in minified environments.
  *
  * Implemented as a static method to support loading logic.
  */
  static lc_name() {
    return this.name;
  }
  /**
  * The final serialized identifier for the module.
  */
  get lc_id() {
    return [...this.lc_namespace, w0(this.constructor)];
  }
  copy() {
    return new this.constructor(this);
  }
  toJSON() {
    return Kc.prototype.toJSON.call(this);
  }
  toJSONNotImplemented() {
    return Kc.prototype.toJSONNotImplemented.call(this);
  }
  static fromMethods(A) {
    class e extends LE {
      constructor() {
        super();
        R(this, "name", Hn());
        Object.assign(this, A);
      }
    }
    return new e();
  }
};
const HL = (t) => {
  const A = t;
  return A !== void 0 && typeof A.copy == "function" && typeof A.name == "string" && typeof A.awaitHandlers == "boolean";
}, aO = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i;
function oO(t) {
  return typeof t == "string" && aO.test(t);
}
function gO(t) {
  if (!oO(t))
    throw TypeError("Invalid UUID");
  let A;
  const e = new Uint8Array(16);
  return e[0] = (A = parseInt(t.slice(0, 8), 16)) >>> 24, e[1] = A >>> 16 & 255, e[2] = A >>> 8 & 255, e[3] = A & 255, e[4] = (A = parseInt(t.slice(9, 13), 16)) >>> 8, e[5] = A & 255, e[6] = (A = parseInt(t.slice(14, 18), 16)) >>> 8, e[7] = A & 255, e[8] = (A = parseInt(t.slice(19, 23), 16)) >>> 8, e[9] = A & 255, e[10] = (A = parseInt(t.slice(24, 36), 16)) / 1099511627776 & 255, e[11] = A / 4294967296 & 255, e[12] = A >>> 24 & 255, e[13] = A >>> 16 & 255, e[14] = A >>> 8 & 255, e[15] = A & 255, e;
}
const Ut = [];
for (let t = 0; t < 256; ++t)
  Ut.push((t + 256).toString(16).slice(1));
function N0(t, A = 0) {
  return (Ut[t[A + 0]] + Ut[t[A + 1]] + Ut[t[A + 2]] + Ut[t[A + 3]] + "-" + Ut[t[A + 4]] + Ut[t[A + 5]] + "-" + Ut[t[A + 6]] + Ut[t[A + 7]] + "-" + Ut[t[A + 8]] + Ut[t[A + 9]] + "-" + Ut[t[A + 10]] + Ut[t[A + 11]] + Ut[t[A + 12]] + Ut[t[A + 13]] + Ut[t[A + 14]] + Ut[t[A + 15]]).toLowerCase();
}
const TQ = new Uint8Array(256);
let oh = TQ.length;
function PL() {
  return oh > TQ.length - 16 && (DE.randomFillSync(TQ), oh = 0), TQ.slice(oh, oh += 16);
}
function uO(t) {
  t = unescape(encodeURIComponent(t));
  const A = [];
  for (let e = 0; e < t.length; ++e)
    A.push(t.charCodeAt(e));
  return A;
}
const cO = "6ba7b810-9dad-11d1-80b4-00c04fd430c8", IO = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
function CO(t, A, e) {
  function r(i, n, s, a) {
    var g;
    if (typeof i == "string" && (i = uO(i)), typeof n == "string" && (n = gO(n)), ((g = n) === null || g === void 0 ? void 0 : g.length) !== 16)
      throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
    let o = new Uint8Array(16 + i.length);
    if (o.set(n), o.set(i, n.length), o = e(o), o[6] = o[6] & 15 | A, o[8] = o[8] & 63 | 128, s) {
      a = a || 0;
      for (let u = 0; u < 16; ++u)
        s[a + u] = o[u];
      return s;
    }
    return N0(o);
  }
  try {
    r.name = t;
  } catch {
  }
  return r.DNS = cO, r.URL = IO, r;
}
const WF = {
  randomUUID: DE.randomUUID
};
function QI(t, A, e) {
  if (WF.randomUUID && !t)
    return WF.randomUUID();
  t = t || {};
  const r = t.random || (t.rng || PL)();
  return r[6] = r[6] & 15 | 64, r[8] = r[8] & 63 | 128, N0(r);
}
function lO(t) {
  return Array.isArray(t) ? t = Buffer.from(t) : typeof t == "string" && (t = Buffer.from(t, "utf8")), DE.createHash("sha1").update(t).digest();
}
const fC = CO("v5", 80, lO);
let VF = null, ZF = null, $r = 0;
function BO(t, A, e) {
  t = t || {};
  let r = 0;
  const i = new Uint8Array(16), n = t.random || (t.rng || PL)(), s = t.msecs !== void 0 ? t.msecs : Date.now();
  let a = t.seq !== void 0 ? t.seq : null, g = ZF, o = VF;
  return s > $r && t.msecs === void 0 && ($r = s, a !== null && (g = null, o = null)), a !== null && (a > 2147483647 && (a = 2147483647), g = a >>> 19 & 4095, o = a & 524287), (g === null || o === null) && (g = n[6] & 127, g = g << 8 | n[7], o = n[8] & 63, o = o << 8 | n[9], o = o << 5 | n[10] >>> 3), s + 1e4 > $r && a === null ? ++o > 524287 && (o = 0, ++g > 4095 && (g = 0, $r++)) : $r = s, ZF = g, VF = o, i[r++] = $r / 1099511627776 & 255, i[r++] = $r / 4294967296 & 255, i[r++] = $r / 16777216 & 255, i[r++] = $r / 65536 & 255, i[r++] = $r / 256 & 255, i[r++] = $r & 255, i[r++] = g >>> 4 & 15 | 112, i[r++] = g & 255, i[r++] = o >>> 13 & 63 | 128, i[r++] = o >>> 5 & 255, i[r++] = o << 3 & 255 | n[10] & 7, i[r++] = n[11], i[r++] = n[12], i[r++] = n[13], i[r++] = n[14], i[r++] = n[15], A || N0(i);
}
const EO = "gen_ai.operation.name", hO = "gen_ai.system", XF = "gen_ai.request.model", QO = "gen_ai.response.model", zF = "gen_ai.usage.input_tokens", $F = "gen_ai.usage.output_tokens", Ak = "gen_ai.usage.total_tokens", dO = "gen_ai.request.max_tokens", fO = "gen_ai.request.temperature", pO = "gen_ai.request.top_p", yO = "gen_ai.request.frequency_penalty", wO = "gen_ai.request.presence_penalty", mO = "gen_ai.response.finish_reasons", DO = "gen_ai.prompt", SO = "gen_ai.completion", FO = "gen_ai.request.extra_query", kO = "gen_ai.request.extra_body", vO = "gen_ai.serialized.name", RO = "gen_ai.serialized.signature", bO = "gen_ai.serialized.doc", MO = "gen_ai.response.id", _O = "gen_ai.response.service_tier", NO = "gen_ai.response.system_fingerprint", LO = "gen_ai.usage.input_token_details", xO = "gen_ai.usage.output_token_details", GO = "langsmith.trace.session_id", UO = "langsmith.trace.session_name", TO = "langsmith.span.kind", KO = "langsmith.trace.name", JO = "langsmith.metadata", ek = "langsmith.span.tags", HO = "langsmith.request.streaming", PO = "langsmith.request.headers", OO = (...t) => fetch(...t), OL = Symbol.for("ls:fetch_implementation"), YO = () => {
  const t = globalThis[OL];
  return t ? typeof t == "function" && "Headers" in t && "Request" in t && "Response" in t : !1;
}, qO = (t) => async (...A) => {
  if (t || dr("DEBUG") === "true") {
    const [r, i] = A;
    console.log(`â†’ ${(i == null ? void 0 : i.method) || "GET"} ${r}`);
  }
  const e = await (globalThis[OL] ?? OO)(...A);
  return (t || dr("DEBUG") === "true") && console.log(`â† ${e.status} ${e.statusText} ${e.url}`), e;
}, YL = () => dr("PROJECT") ?? pn("LANGCHAIN_SESSION") ?? // TODO: Deprecate
"default", tk = {};
function Ow(t) {
  tk[t] || (console.warn(t), tk[t] = !0);
}
const jO = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
function te(t, A) {
  if (!jO.test(t)) {
    const e = A !== void 0 ? `Invalid UUID for ${A}: ${t}` : `Invalid UUID: ${t}`;
    throw new Error(e);
  }
  return t;
}
function WO(t) {
  const A = typeof t == "string" ? Date.parse(t) : t;
  return BO({ msecs: A, seq: 0 });
}
const qL = "0.3.84";
let Ti;
const VO = () => typeof window < "u" && typeof window.document < "u", ZO = () => typeof globalThis == "object" && globalThis.constructor && globalThis.constructor.name === "DedicatedWorkerGlobalScope", XO = () => typeof window < "u" && window.name === "nodejs" || typeof navigator < "u" && navigator.userAgent.includes("jsdom"), jL = () => typeof Deno < "u", zO = () => typeof process < "u" && typeof process.versions < "u" && typeof process.versions.node < "u" && !jL(), WL = () => Ti || (typeof Bun < "u" ? Ti = "bun" : VO() ? Ti = "browser" : zO() ? Ti = "node" : ZO() ? Ti = "webworker" : XO() ? Ti = "jsdom" : jL() ? Ti = "deno" : Ti = "other", Ti);
let Xp;
function VL() {
  if (Xp === void 0) {
    const t = WL(), A = A2();
    Xp = {
      library: "langsmith",
      runtime: t,
      sdk: "langsmith-js",
      sdk_version: qL,
      ...A
    };
  }
  return Xp;
}
function ZL() {
  const t = $O(), A = {}, e = [
    "LANGCHAIN_API_KEY",
    "LANGCHAIN_ENDPOINT",
    "LANGCHAIN_TRACING_V2",
    "LANGCHAIN_PROJECT",
    "LANGCHAIN_SESSION",
    "LANGSMITH_API_KEY",
    "LANGSMITH_ENDPOINT",
    "LANGSMITH_TRACING_V2",
    "LANGSMITH_PROJECT",
    "LANGSMITH_SESSION"
  ];
  for (const [r, i] of Object.entries(t))
    typeof i == "string" && !e.includes(r) && !r.toLowerCase().includes("key") && !r.toLowerCase().includes("secret") && !r.toLowerCase().includes("token") && (r === "LANGCHAIN_REVISION_ID" ? A.revision_id = i : A[r] = i);
  return A;
}
function $O() {
  const t = {};
  try {
    if (typeof process < "u" && process.env)
      for (const [A, e] of Object.entries(process.env))
        (A.startsWith("LANGCHAIN_") || A.startsWith("LANGSMITH_")) && e != null && ((A.toLowerCase().includes("key") || A.toLowerCase().includes("secret") || A.toLowerCase().includes("token")) && typeof e == "string" ? t[A] = e.slice(0, 2) + "*".repeat(e.length - 4) + e.slice(-2) : t[A] = e);
  } catch {
  }
  return t;
}
function pn(t) {
  var A;
  try {
    return typeof process < "u" ? (
      // eslint-disable-next-line no-process-env
      (A = process.env) == null ? void 0 : A[t]
    ) : void 0;
  } catch {
    return;
  }
}
function dr(t) {
  return pn(`LANGSMITH_${t}`) || pn(`LANGCHAIN_${t}`);
}
let zp;
function A2() {
  if (zp !== void 0)
    return zp;
  const t = [
    "VERCEL_GIT_COMMIT_SHA",
    "NEXT_PUBLIC_VERCEL_GIT_COMMIT_SHA",
    "COMMIT_REF",
    "RENDER_GIT_COMMIT",
    "CI_COMMIT_SHA",
    "CIRCLE_SHA1",
    "CF_PAGES_COMMIT_SHA",
    "REACT_APP_GIT_SHA",
    "SOURCE_VERSION",
    "GITHUB_SHA",
    "TRAVIS_COMMIT",
    "GIT_COMMIT",
    "BUILD_VCS_NUMBER",
    "bamboo_planRepository_revision",
    "Build.SourceVersion",
    "BITBUCKET_COMMIT",
    "DRONE_COMMIT_SHA",
    "SEMAPHORE_GIT_SHA",
    "BUILDKITE_COMMIT"
  ], A = {};
  for (const e of t) {
    const r = pn(e);
    r !== void 0 && (A[e] = r);
  }
  return zp = A, A;
}
function XL() {
  return pn("OTEL_ENABLED") === "true" || dr("OTEL_ENABLED") === "true";
}
class e2 {
  constructor() {
    Object.defineProperty(this, "hasWarned", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    });
  }
  startActiveSpan(A, ...e) {
    !this.hasWarned && XL() && (console.warn('You have enabled OTEL export via the `OTEL_ENABLED` or `LANGSMITH_OTEL_ENABLED` environment variable, but have not initialized the required OTEL instances. Please add:\n```\nimport { initializeOTEL } from "langsmith/experimental/otel/setup";\ninitializeOTEL();\n```\nat the beginning of your code.'), this.hasWarned = !0);
    let r;
    if (e.length === 1 && typeof e[0] == "function" ? r = e[0] : e.length === 2 && typeof e[1] == "function" ? r = e[1] : e.length === 3 && typeof e[2] == "function" && (r = e[2]), typeof r == "function")
      return r();
  }
}
class t2 {
  constructor() {
    Object.defineProperty(this, "mockTracer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new e2()
    });
  }
  getTracer(A, e) {
    return this.mockTracer;
  }
  getActiveSpan() {
  }
  setSpan(A, e) {
    return A;
  }
  getSpan(A) {
  }
  setSpanContext(A, e) {
    return A;
  }
  getTracerProvider() {
  }
  setGlobalTracerProvider(A) {
    return !1;
  }
}
class r2 {
  active() {
    return {};
  }
  with(A, e) {
    return e();
  }
}
const $p = Symbol.for("ls:otel_trace"), Ay = Symbol.for("ls:otel_context"), rk = Symbol.for("ls:otel_get_default_otlp_tracer_provider"), i2 = new t2(), n2 = new r2();
class s2 {
  getTraceInstance() {
    return globalThis[$p] ?? i2;
  }
  getContextInstance() {
    return globalThis[Ay] ?? n2;
  }
  initializeGlobalInstances(A) {
    globalThis[$p] === void 0 && (globalThis[$p] = A.trace), globalThis[Ay] === void 0 && (globalThis[Ay] = A.context);
  }
  setDefaultOTLPTracerComponents(A) {
    globalThis[rk] = A;
  }
  getDefaultOTLPTracerComponents() {
    return globalThis[rk] ?? void 0;
  }
}
const L0 = new s2();
function zL() {
  return L0.getTraceInstance();
}
function a2() {
  return L0.getContextInstance();
}
function o2() {
  return L0.getDefaultOTLPTracerComponents();
}
const g2 = {
  llm: "chat",
  tool: "execute_tool",
  retriever: "embeddings",
  embedding: "embeddings",
  prompt: "chat"
};
function u2(t) {
  return g2[t] || t;
}
class c2 {
  constructor() {
    Object.defineProperty(this, "spans", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: /* @__PURE__ */ new Map()
    });
  }
  exportBatch(A, e) {
    for (const r of A)
      try {
        if (!r.run)
          continue;
        if (r.operation === "post") {
          const i = this.createSpanForRun(r, r.run, e.get(r.id));
          i && !r.run.end_time && this.spans.set(r.id, i);
        } else
          this.updateSpanForRun(r, r.run);
      } catch (i) {
        console.error(`Error processing operation ${r.id}:`, i);
      }
  }
  createSpanForRun(A, e, r) {
    const i = r && zL().getSpan(r);
    if (i)
      try {
        return this.finishSpanSetup(i, e, A);
      } catch (n) {
        console.error(`Failed to create span for run ${A.id}:`, n);
        return;
      }
  }
  finishSpanSetup(A, e, r) {
    return this.setSpanAttributes(A, e, r), e.error ? (A.setStatus({ code: 2 }), A.recordException(new Error(e.error))) : A.setStatus({ code: 1 }), e.end_time && A.end(new Date(e.end_time)), A;
  }
  updateSpanForRun(A, e) {
    try {
      const r = this.spans.get(A.id);
      if (!r) {
        console.debug(`No span found for run ${A.id} during update`);
        return;
      }
      this.setSpanAttributes(r, e, A), e.error ? (r.setStatus({ code: 2 }), r.recordException(new Error(e.error))) : r.setStatus({ code: 1 });
      const i = e.end_time;
      i && (r.end(new Date(i)), this.spans.delete(A.id));
    } catch (r) {
      console.error(`Failed to update span for run ${A.id}:`, r);
    }
  }
  extractModelName(A) {
    var e;
    if ((e = A.extra) != null && e.metadata) {
      const r = A.extra.metadata;
      if (r.ls_model_name)
        return r.ls_model_name;
      if (r.invocation_params) {
        const i = r.invocation_params;
        if (i.model)
          return i.model;
        if (i.model_name)
          return i.model_name;
      }
    }
  }
  setSpanAttributes(A, e, r) {
    var a;
    if ("run_type" in e && e.run_type) {
      A.setAttribute(TO, e.run_type);
      const g = u2(e.run_type || "chain");
      A.setAttribute(EO, g);
    }
    "name" in e && e.name && A.setAttribute(KO, e.name), "session_id" in e && e.session_id && A.setAttribute(GO, e.session_id), "session_name" in e && e.session_name && A.setAttribute(UO, e.session_name), this.setGenAiSystem(A, e);
    const i = this.extractModelName(e);
    i && A.setAttribute(XF, i), "prompt_tokens" in e && typeof e.prompt_tokens == "number" && A.setAttribute(zF, e.prompt_tokens), "completion_tokens" in e && typeof e.completion_tokens == "number" && A.setAttribute($F, e.completion_tokens), "total_tokens" in e && typeof e.total_tokens == "number" && A.setAttribute(Ak, e.total_tokens), this.setInvocationParameters(A, e);
    const n = ((a = e.extra) == null ? void 0 : a.metadata) || {};
    for (const [g, o] of Object.entries(n))
      o != null && A.setAttribute(`${JO}.${g}`, String(o));
    const s = e.tags;
    if (s && Array.isArray(s) ? A.setAttribute(ek, s.join(", ")) : s && A.setAttribute(ek, String(s)), "serialized" in e && typeof e.serialized == "object") {
      const g = e.serialized;
      g.name && A.setAttribute(vO, String(g.name)), g.signature && A.setAttribute(RO, String(g.signature)), g.doc && A.setAttribute(bO, String(g.doc));
    }
    this.setIOAttributes(A, r);
  }
  setGenAiSystem(A, e) {
    let r = "langchain";
    const i = this.extractModelName(e);
    if (i) {
      const n = i.toLowerCase();
      n.includes("anthropic") || n.startsWith("claude") ? r = "anthropic" : n.includes("bedrock") ? r = "aws.bedrock" : n.includes("azure") && n.includes("openai") ? r = "az.ai.openai" : n.includes("azure") && n.includes("inference") ? r = "az.ai.inference" : n.includes("cohere") ? r = "cohere" : n.includes("deepseek") ? r = "deepseek" : n.includes("gemini") ? r = "gemini" : n.includes("groq") ? r = "groq" : n.includes("watson") || n.includes("ibm") ? r = "ibm.watsonx.ai" : n.includes("mistral") ? r = "mistral_ai" : n.includes("gpt") || n.includes("openai") ? r = "openai" : n.includes("perplexity") || n.includes("sonar") ? r = "perplexity" : n.includes("vertex") ? r = "vertex_ai" : (n.includes("xai") || n.includes("grok")) && (r = "xai");
    }
    A.setAttribute(hO, r);
  }
  setInvocationParameters(A, e) {
    var i, n;
    if (!((n = (i = e.extra) == null ? void 0 : i.metadata) != null && n.invocation_params))
      return;
    const r = e.extra.metadata.invocation_params;
    r.max_tokens !== void 0 && A.setAttribute(dO, r.max_tokens), r.temperature !== void 0 && A.setAttribute(fO, r.temperature), r.top_p !== void 0 && A.setAttribute(pO, r.top_p), r.frequency_penalty !== void 0 && A.setAttribute(yO, r.frequency_penalty), r.presence_penalty !== void 0 && A.setAttribute(wO, r.presence_penalty);
  }
  setIOAttributes(A, e) {
    if (e.run.inputs)
      try {
        const r = e.run.inputs;
        typeof r == "object" && r !== null && (r.model && Array.isArray(r.messages) && A.setAttribute(XF, r.model), r.stream !== void 0 && A.setAttribute(HO, r.stream), r.extra_headers && A.setAttribute(PO, JSON.stringify(r.extra_headers)), r.extra_query && A.setAttribute(FO, JSON.stringify(r.extra_query)), r.extra_body && A.setAttribute(kO, JSON.stringify(r.extra_body))), A.setAttribute(DO, JSON.stringify(r));
      } catch (r) {
        console.debug(`Failed to process inputs for run ${e.id}`, r);
      }
    if (e.run.outputs)
      try {
        const r = e.run.outputs, i = this.getUnifiedRunTokens(r);
        if (i && (A.setAttribute(zF, i[0]), A.setAttribute($F, i[1]), A.setAttribute(Ak, i[0] + i[1])), r && typeof r == "object") {
          if (r.model && A.setAttribute(QO, String(r.model)), r.id && A.setAttribute(MO, r.id), r.choices && Array.isArray(r.choices)) {
            const n = r.choices.map((s) => s.finish_reason).filter((s) => s).map(String);
            n.length > 0 && A.setAttribute(mO, n.join(", "));
          }
          if (r.service_tier && A.setAttribute(_O, r.service_tier), r.system_fingerprint && A.setAttribute(NO, r.system_fingerprint), r.usage_metadata && typeof r.usage_metadata == "object") {
            const n = r.usage_metadata;
            n.input_token_details && A.setAttribute(LO, JSON.stringify(n.input_token_details)), n.output_token_details && A.setAttribute(xO, JSON.stringify(n.output_token_details));
          }
        }
        A.setAttribute(SO, JSON.stringify(r));
      } catch (r) {
        console.debug(`Failed to process outputs for run ${e.id}`, r);
      }
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  getUnifiedRunTokens(A) {
    if (!A)
      return null;
    let e = this.extractUnifiedRunTokens(A.usage_metadata);
    if (e)
      return e;
    const r = Object.keys(A);
    for (const s of r) {
      const a = A[s];
      if (!(!a || typeof a != "object") && (e = this.extractUnifiedRunTokens(a.usage_metadata), e || a.lc === 1 && a.kwargs && typeof a.kwargs == "object" && (e = this.extractUnifiedRunTokens(a.kwargs.usage_metadata), e)))
        return e;
    }
    const i = A.generations || [];
    if (!Array.isArray(i))
      return null;
    const n = Array.isArray(i[0]) ? i.flat() : i;
    for (const s of n)
      if (typeof s == "object" && s.message && typeof s.message == "object" && s.message.kwargs && typeof s.message.kwargs == "object" && (e = this.extractUnifiedRunTokens(s.message.kwargs.usage_metadata), e))
        return e;
    return null;
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  extractUnifiedRunTokens(A) {
    return !A || typeof A != "object" || typeof A.input_tokens != "number" || typeof A.output_tokens != "number" ? null : [A.input_tokens, A.output_tokens];
  }
}
const I2 = Object.prototype.toString, C2 = (t) => I2.call(t) === "[object Error]", l2 = /* @__PURE__ */ new Set([
  "network error",
  // Chrome
  "Failed to fetch",
  // Chrome
  "NetworkError when attempting to fetch resource.",
  // Firefox
  "The Internet connection appears to be offline.",
  // Safari 16
  "Network request failed",
  // `cross-fetch`
  "fetch failed",
  // Undici (Node.js)
  "terminated",
  // Undici (Node.js)
  " A network error occurred.",
  // Bun (WebKit)
  "Network connection lost"
  // Cloudflare Workers (fetch)
]);
function B2(t) {
  if (!(t && C2(t) && t.name === "TypeError" && typeof t.message == "string"))
    return !1;
  const { message: e, stack: r } = t;
  return e === "Load failed" ? r === void 0 || // Sentry adds its own stack trace to the fetch error, so also check for that
  "__sentry_captured__" in t : e.startsWith("error sending request for url") ? !0 : l2.has(e);
}
function E2(t) {
  if (typeof t == "number") {
    if (t < 0)
      throw new TypeError("Expected `retries` to be a non-negative number.");
    if (Number.isNaN(t))
      throw new TypeError("Expected `retries` to be a valid number or Infinity, got NaN.");
  } else if (t !== void 0)
    throw new TypeError("Expected `retries` to be a number or Infinity.");
}
function gh(t, A, { min: e = 0, allowInfinity: r = !1 } = {}) {
  if (A !== void 0) {
    if (typeof A != "number" || Number.isNaN(A))
      throw new TypeError(`Expected \`${t}\` to be a number${r ? " or Infinity" : ""}.`);
    if (!r && !Number.isFinite(A))
      throw new TypeError(`Expected \`${t}\` to be a finite number.`);
    if (A < e)
      throw new TypeError(`Expected \`${t}\` to be â‰¥ ${e}.`);
  }
}
let h2 = class extends Error {
  constructor(A) {
    super(), A instanceof Error ? (this.originalError = A, { message: A } = A) : (this.originalError = new Error(A), this.originalError.stack = this.stack), this.name = "AbortError", this.message = A;
  }
};
function Q2(t, A) {
  const e = Math.max(1, t + 1), r = A.randomize ? Math.random() + 1 : 1;
  let i = Math.round(r * A.minTimeout * A.factor ** (e - 1));
  return i = Math.min(i, A.maxTimeout), i;
}
function ik(t, A) {
  return Number.isFinite(A) ? A - (performance.now() - t) : A;
}
async function d2({ error: t, attemptNumber: A, retriesConsumed: e, startTime: r, options: i }) {
  var C, E, l;
  const n = t instanceof Error ? t : new TypeError(`Non-error was thrown: "${t}". You should only throw errors.`);
  if (n instanceof h2)
    throw n.originalError;
  const s = Number.isFinite(i.retries) ? Math.max(0, i.retries - e) : i.retries, a = i.maxRetryTime ?? Number.POSITIVE_INFINITY, g = Object.freeze({
    error: n,
    attemptNumber: A,
    retriesLeft: s,
    retriesConsumed: e
  });
  if (await i.onFailedAttempt(g), ik(r, a) <= 0)
    throw n;
  const o = await i.shouldConsumeRetry(g), u = ik(r, a);
  if (u <= 0 || s <= 0)
    throw n;
  if (n instanceof TypeError && !B2(n)) {
    if (o)
      throw n;
    return (C = i.signal) == null || C.throwIfAborted(), !1;
  }
  if (!await i.shouldRetry(g))
    throw n;
  if (!o)
    return (E = i.signal) == null || E.throwIfAborted(), !1;
  const I = Q2(e, i), c = Math.min(I, u);
  return c > 0 && await new Promise((B, h) => {
    var p, y;
    const Q = () => {
      var m;
      clearTimeout(f), (m = i.signal) == null || m.removeEventListener("abort", Q), h(i.signal.reason);
    }, f = setTimeout(() => {
      var m;
      (m = i.signal) == null || m.removeEventListener("abort", Q), B();
    }, c);
    i.unref && ((p = f.unref) == null || p.call(f)), (y = i.signal) == null || y.addEventListener("abort", Q, { once: !0 });
  }), (l = i.signal) == null || l.throwIfAborted(), !0;
}
async function f2(t, A = {}) {
  var n, s, a;
  if (A = { ...A }, E2(A.retries), Object.hasOwn(A, "forever"))
    throw new Error("The `forever` option is no longer supported. For many use-cases, you can set `retries: Infinity` instead.");
  A.retries ?? (A.retries = 10), A.factor ?? (A.factor = 2), A.minTimeout ?? (A.minTimeout = 1e3), A.maxTimeout ?? (A.maxTimeout = Number.POSITIVE_INFINITY), A.maxRetryTime ?? (A.maxRetryTime = Number.POSITIVE_INFINITY), A.randomize ?? (A.randomize = !1), A.onFailedAttempt ?? (A.onFailedAttempt = () => {
  }), A.shouldRetry ?? (A.shouldRetry = () => !0), A.shouldConsumeRetry ?? (A.shouldConsumeRetry = () => !0), gh("factor", A.factor, {
    min: 0,
    allowInfinity: !1
  }), gh("minTimeout", A.minTimeout, {
    min: 0,
    allowInfinity: !1
  }), gh("maxTimeout", A.maxTimeout, {
    min: 0,
    allowInfinity: !0
  }), gh("maxRetryTime", A.maxRetryTime, {
    min: 0,
    allowInfinity: !0
  }), A.factor > 0 || (A.factor = 1), (n = A.signal) == null || n.throwIfAborted();
  let e = 0, r = 0;
  const i = performance.now();
  for (; !Number.isFinite(A.retries) || r <= A.retries; ) {
    e++;
    try {
      (s = A.signal) == null || s.throwIfAborted();
      const g = await t(e);
      return (a = A.signal) == null || a.throwIfAborted(), g;
    } catch (g) {
      await d2({
        error: g,
        attemptNumber: e,
        retriesConsumed: r,
        startTime: i,
        options: A
      }) && r++;
    }
  }
  throw new Error("Retry attempts exhausted without throwing an error.");
}
var $L = {}, Ax = { exports: {} };
(function(t) {
  var A = Object.prototype.hasOwnProperty, e = "~";
  function r() {
  }
  Object.create && (r.prototype = /* @__PURE__ */ Object.create(null), new r().__proto__ || (e = !1));
  function i(g, o, u) {
    this.fn = g, this.context = o, this.once = u || !1;
  }
  function n(g, o, u, I, c) {
    if (typeof u != "function")
      throw new TypeError("The listener must be a function");
    var C = new i(u, I || g, c), E = e ? e + o : o;
    return g._events[E] ? g._events[E].fn ? g._events[E] = [g._events[E], C] : g._events[E].push(C) : (g._events[E] = C, g._eventsCount++), g;
  }
  function s(g, o) {
    --g._eventsCount === 0 ? g._events = new r() : delete g._events[o];
  }
  function a() {
    this._events = new r(), this._eventsCount = 0;
  }
  a.prototype.eventNames = function() {
    var o = [], u, I;
    if (this._eventsCount === 0) return o;
    for (I in u = this._events)
      A.call(u, I) && o.push(e ? I.slice(1) : I);
    return Object.getOwnPropertySymbols ? o.concat(Object.getOwnPropertySymbols(u)) : o;
  }, a.prototype.listeners = function(o) {
    var u = e ? e + o : o, I = this._events[u];
    if (!I) return [];
    if (I.fn) return [I.fn];
    for (var c = 0, C = I.length, E = new Array(C); c < C; c++)
      E[c] = I[c].fn;
    return E;
  }, a.prototype.listenerCount = function(o) {
    var u = e ? e + o : o, I = this._events[u];
    return I ? I.fn ? 1 : I.length : 0;
  }, a.prototype.emit = function(o, u, I, c, C, E) {
    var l = e ? e + o : o;
    if (!this._events[l]) return !1;
    var B = this._events[l], h = arguments.length, Q, f;
    if (B.fn) {
      switch (B.once && this.removeListener(o, B.fn, void 0, !0), h) {
        case 1:
          return B.fn.call(B.context), !0;
        case 2:
          return B.fn.call(B.context, u), !0;
        case 3:
          return B.fn.call(B.context, u, I), !0;
        case 4:
          return B.fn.call(B.context, u, I, c), !0;
        case 5:
          return B.fn.call(B.context, u, I, c, C), !0;
        case 6:
          return B.fn.call(B.context, u, I, c, C, E), !0;
      }
      for (f = 1, Q = new Array(h - 1); f < h; f++)
        Q[f - 1] = arguments[f];
      B.fn.apply(B.context, Q);
    } else {
      var p = B.length, y;
      for (f = 0; f < p; f++)
        switch (B[f].once && this.removeListener(o, B[f].fn, void 0, !0), h) {
          case 1:
            B[f].fn.call(B[f].context);
            break;
          case 2:
            B[f].fn.call(B[f].context, u);
            break;
          case 3:
            B[f].fn.call(B[f].context, u, I);
            break;
          case 4:
            B[f].fn.call(B[f].context, u, I, c);
            break;
          default:
            if (!Q) for (y = 1, Q = new Array(h - 1); y < h; y++)
              Q[y - 1] = arguments[y];
            B[f].fn.apply(B[f].context, Q);
        }
    }
    return !0;
  }, a.prototype.on = function(o, u, I) {
    return n(this, o, u, I, !1);
  }, a.prototype.once = function(o, u, I) {
    return n(this, o, u, I, !0);
  }, a.prototype.removeListener = function(o, u, I, c) {
    var C = e ? e + o : o;
    if (!this._events[C]) return this;
    if (!u)
      return s(this, C), this;
    var E = this._events[C];
    if (E.fn)
      E.fn === u && (!c || E.once) && (!I || E.context === I) && s(this, C);
    else {
      for (var l = 0, B = [], h = E.length; l < h; l++)
        (E[l].fn !== u || c && !E[l].once || I && E[l].context !== I) && B.push(E[l]);
      B.length ? this._events[C] = B.length === 1 ? B[0] : B : s(this, C);
    }
    return this;
  }, a.prototype.removeAllListeners = function(o) {
    var u;
    return o ? (u = e ? e + o : o, this._events[u] && s(this, u)) : (this._events = new r(), this._eventsCount = 0), this;
  }, a.prototype.off = a.prototype.removeListener, a.prototype.addListener = a.prototype.on, a.prefixed = e, a.EventEmitter = a, t.exports = a;
})(Ax);
var p2 = Ax.exports, jf = { exports: {} }, y2 = (t, A) => (A = A || (() => {
}), t.then(
  (e) => new Promise((r) => {
    r(A());
  }).then(() => e),
  (e) => new Promise((r) => {
    r(A());
  }).then(() => {
    throw e;
  })
));
const w2 = y2;
let ex = class extends Error {
  constructor(A) {
    super(A), this.name = "TimeoutError";
  }
};
const tx = (t, A, e) => new Promise((r, i) => {
  if (typeof A != "number" || A < 0)
    throw new TypeError("Expected `milliseconds` to be a positive number");
  if (A === 1 / 0) {
    r(t);
    return;
  }
  const n = setTimeout(() => {
    if (typeof e == "function") {
      try {
        r(e());
      } catch (g) {
        i(g);
      }
      return;
    }
    const s = typeof e == "string" ? e : `Promise timed out after ${A} milliseconds`, a = e instanceof Error ? e : new ex(s);
    typeof t.cancel == "function" && t.cancel(), i(a);
  }, A);
  w2(
    // eslint-disable-next-line promise/prefer-await-to-then
    t.then(r, i),
    () => {
      clearTimeout(n);
    }
  );
});
jf.exports = tx;
jf.exports.default = tx;
jf.exports.TimeoutError = ex;
var m2 = jf.exports, x0 = {}, G0 = {};
Object.defineProperty(G0, "__esModule", { value: !0 });
function D2(t, A, e) {
  let r = 0, i = t.length;
  for (; i > 0; ) {
    const n = i / 2 | 0;
    let s = r + n;
    e(t[s], A) <= 0 ? (r = ++s, i -= n + 1) : i = n;
  }
  return r;
}
G0.default = D2;
Object.defineProperty(x0, "__esModule", { value: !0 });
const S2 = G0;
class F2 {
  constructor() {
    this._queue = [];
  }
  enqueue(A, e) {
    e = Object.assign({ priority: 0 }, e);
    const r = {
      priority: e.priority,
      run: A
    };
    if (this.size && this._queue[this.size - 1].priority >= e.priority) {
      this._queue.push(r);
      return;
    }
    const i = S2.default(this._queue, r, (n, s) => s.priority - n.priority);
    this._queue.splice(i, 0, r);
  }
  dequeue() {
    const A = this._queue.shift();
    return A == null ? void 0 : A.run;
  }
  filter(A) {
    return this._queue.filter((e) => e.priority === A.priority).map((e) => e.run);
  }
  get size() {
    return this._queue.length;
  }
}
x0.default = F2;
Object.defineProperty($L, "__esModule", { value: !0 });
const k2 = p2, rx = m2, v2 = x0, uh = () => {
}, R2 = new rx.TimeoutError();
class b2 extends k2 {
  constructor(A) {
    var e, r, i, n;
    if (super(), this._intervalCount = 0, this._intervalEnd = 0, this._pendingCount = 0, this._resolveEmpty = uh, this._resolveIdle = uh, A = Object.assign({ carryoverConcurrencyCount: !1, intervalCap: 1 / 0, interval: 0, concurrency: 1 / 0, autoStart: !0, queueClass: v2.default }, A), !(typeof A.intervalCap == "number" && A.intervalCap >= 1))
      throw new TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${(r = (e = A.intervalCap) === null || e === void 0 ? void 0 : e.toString()) !== null && r !== void 0 ? r : ""}\` (${typeof A.intervalCap})`);
    if (A.interval === void 0 || !(Number.isFinite(A.interval) && A.interval >= 0))
      throw new TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${(n = (i = A.interval) === null || i === void 0 ? void 0 : i.toString()) !== null && n !== void 0 ? n : ""}\` (${typeof A.interval})`);
    this._carryoverConcurrencyCount = A.carryoverConcurrencyCount, this._isIntervalIgnored = A.intervalCap === 1 / 0 || A.interval === 0, this._intervalCap = A.intervalCap, this._interval = A.interval, this._queue = new A.queueClass(), this._queueClass = A.queueClass, this.concurrency = A.concurrency, this._timeout = A.timeout, this._throwOnTimeout = A.throwOnTimeout === !0, this._isPaused = A.autoStart === !1;
  }
  get _doesIntervalAllowAnother() {
    return this._isIntervalIgnored || this._intervalCount < this._intervalCap;
  }
  get _doesConcurrentAllowAnother() {
    return this._pendingCount < this._concurrency;
  }
  _next() {
    this._pendingCount--, this._tryToStartAnother(), this.emit("next");
  }
  _resolvePromises() {
    this._resolveEmpty(), this._resolveEmpty = uh, this._pendingCount === 0 && (this._resolveIdle(), this._resolveIdle = uh, this.emit("idle"));
  }
  _onResumeInterval() {
    this._onInterval(), this._initializeIntervalIfNeeded(), this._timeoutId = void 0;
  }
  _isIntervalPaused() {
    const A = Date.now();
    if (this._intervalId === void 0) {
      const e = this._intervalEnd - A;
      if (e < 0)
        this._intervalCount = this._carryoverConcurrencyCount ? this._pendingCount : 0;
      else
        return this._timeoutId === void 0 && (this._timeoutId = setTimeout(() => {
          this._onResumeInterval();
        }, e)), !0;
    }
    return !1;
  }
  _tryToStartAnother() {
    if (this._queue.size === 0)
      return this._intervalId && clearInterval(this._intervalId), this._intervalId = void 0, this._resolvePromises(), !1;
    if (!this._isPaused) {
      const A = !this._isIntervalPaused();
      if (this._doesIntervalAllowAnother && this._doesConcurrentAllowAnother) {
        const e = this._queue.dequeue();
        return e ? (this.emit("active"), e(), A && this._initializeIntervalIfNeeded(), !0) : !1;
      }
    }
    return !1;
  }
  _initializeIntervalIfNeeded() {
    this._isIntervalIgnored || this._intervalId !== void 0 || (this._intervalId = setInterval(() => {
      this._onInterval();
    }, this._interval), this._intervalEnd = Date.now() + this._interval);
  }
  _onInterval() {
    this._intervalCount === 0 && this._pendingCount === 0 && this._intervalId && (clearInterval(this._intervalId), this._intervalId = void 0), this._intervalCount = this._carryoverConcurrencyCount ? this._pendingCount : 0, this._processQueue();
  }
  /**
  Executes all queued functions until it reaches the limit.
  */
  _processQueue() {
    for (; this._tryToStartAnother(); )
      ;
  }
  get concurrency() {
    return this._concurrency;
  }
  set concurrency(A) {
    if (!(typeof A == "number" && A >= 1))
      throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${A}\` (${typeof A})`);
    this._concurrency = A, this._processQueue();
  }
  /**
  Adds a sync or async task to the queue. Always returns a promise.
  */
  async add(A, e = {}) {
    return new Promise((r, i) => {
      const n = async () => {
        this._pendingCount++, this._intervalCount++;
        try {
          const s = this._timeout === void 0 && e.timeout === void 0 ? A() : rx.default(Promise.resolve(A()), e.timeout === void 0 ? this._timeout : e.timeout, () => {
            (e.throwOnTimeout === void 0 ? this._throwOnTimeout : e.throwOnTimeout) && i(R2);
          });
          r(await s);
        } catch (s) {
          i(s);
        }
        this._next();
      };
      this._queue.enqueue(n, e), this._tryToStartAnother(), this.emit("add");
    });
  }
  /**
      Same as `.add()`, but accepts an array of sync or async functions.
  
      @returns A promise that resolves when all functions are resolved.
      */
  async addAll(A, e) {
    return Promise.all(A.map(async (r) => this.add(r, e)));
  }
  /**
  Start (or resume) executing enqueued tasks within concurrency limit. No need to call this if queue is not paused (via `options.autoStart = false` or by `.pause()` method.)
  */
  start() {
    return this._isPaused ? (this._isPaused = !1, this._processQueue(), this) : this;
  }
  /**
  Put queue execution on hold.
  */
  pause() {
    this._isPaused = !0;
  }
  /**
  Clear the queue.
  */
  clear() {
    this._queue = new this._queueClass();
  }
  /**
      Can be called multiple times. Useful if you for example add additional items at a later time.
  
      @returns A promise that settles when the queue becomes empty.
      */
  async onEmpty() {
    if (this._queue.size !== 0)
      return new Promise((A) => {
        const e = this._resolveEmpty;
        this._resolveEmpty = () => {
          e(), A();
        };
      });
  }
  /**
      The difference with `.onEmpty` is that `.onIdle` guarantees that all work from the queue has finished. `.onEmpty` merely signals that the queue is empty, but it could mean that some promises haven't completed yet.
  
      @returns A promise that settles when the queue becomes empty, and all promises have completed; `queue.size === 0 && queue.pending === 0`.
      */
  async onIdle() {
    if (!(this._pendingCount === 0 && this._queue.size === 0))
      return new Promise((A) => {
        const e = this._resolveIdle;
        this._resolveIdle = () => {
          e(), A();
        };
      });
  }
  /**
  Size of the queue.
  */
  get size() {
    return this._queue.size;
  }
  /**
      Size of the queue, filtered by the given options.
  
      For example, this can be used to find the number of items remaining in the queue with a specific priority level.
      */
  sizeBy(A) {
    return this._queue.filter(A).length;
  }
  /**
  Number of pending promises.
  */
  get pending() {
    return this._pendingCount;
  }
  /**
  Whether the queue is currently paused.
  */
  get isPaused() {
    return this._isPaused;
  }
  get timeout() {
    return this._timeout;
  }
  /**
  Set the timeout for future operations.
  */
  set timeout(A) {
    this._timeout = A;
  }
}
var os = $L.default = b2;
const M2 = [
  408,
  // Request Timeout
  425,
  // Too Early
  429,
  // Too Many Requests
  500,
  // Internal Server Error
  502,
  // Bad Gateway
  503,
  // Service Unavailable
  504
  // Gateway Timeout
];
let nk = class {
  constructor(A) {
    Object.defineProperty(this, "maxConcurrency", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "maxRetries", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "maxQueueSizeBytes", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "queue", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "onFailedResponseHook", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "queueSizeBytes", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), this.maxConcurrency = A.maxConcurrency ?? 1 / 0, this.maxRetries = A.maxRetries ?? 6, this.maxQueueSizeBytes = A.maxQueueSizeBytes, "default" in os ? this.queue = new os.default({
      concurrency: this.maxConcurrency
    }) : this.queue = new os({ concurrency: this.maxConcurrency }), this.onFailedResponseHook = A == null ? void 0 : A.onFailedResponseHook;
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  call(A, ...e) {
    return this.callWithOptions({}, A, ...e);
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  callWithOptions(A, e, ...r) {
    const i = A.sizeBytes ?? 0;
    if (this.maxQueueSizeBytes !== void 0 && i > 0 && this.queueSizeBytes + i > this.maxQueueSizeBytes)
      return Promise.reject(new Error(`Queue size limit (${this.maxQueueSizeBytes} bytes) exceeded. Current queue size: ${this.queueSizeBytes} bytes, attempted addition: ${i} bytes.`));
    i > 0 && (this.queueSizeBytes += i);
    const n = this.onFailedResponseHook;
    let s = this.queue.add(() => f2(() => e(...r).catch((a) => {
      throw a instanceof Error ? a : new Error(a);
    }), {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      async onFailedAttempt({ error: a }) {
        if (a.message.startsWith("Cancel") || a.message.startsWith("TimeoutError") || a.name === "TimeoutError" || a.message.startsWith("AbortError") || (a == null ? void 0 : a.code) === "ECONNABORTED")
          throw a;
        const g = a == null ? void 0 : a.response;
        if (n && await n(g))
          return;
        const o = (g == null ? void 0 : g.status) ?? (a == null ? void 0 : a.status);
        if (o && !M2.includes(+o))
          throw a;
      },
      retries: this.maxRetries,
      randomize: !0
    }), { throwOnTimeout: !0 });
    return i > 0 && (s = s.finally(() => {
      this.queueSizeBytes -= i;
    })), A.signal ? Promise.race([
      s,
      new Promise((a, g) => {
        var o;
        (o = A.signal) == null || o.addEventListener("abort", () => {
          g(new Error("AbortError"));
        });
      })
    ]) : s;
  }
};
function sk(t) {
  return typeof (t == null ? void 0 : t._getType) == "function";
}
function ak(t) {
  const A = {
    type: t._getType(),
    data: { content: t.content }
  };
  return t != null && t.additional_kwargs && Object.keys(t.additional_kwargs).length > 0 && (A.data.additional_kwargs = { ...t.additional_kwargs }), A;
}
var Yw = { exports: {} };
const _2 = "2.0.0", ix = 256, N2 = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
9007199254740991, L2 = 16, x2 = ix - 6, G2 = [
  "major",
  "premajor",
  "minor",
  "preminor",
  "patch",
  "prepatch",
  "prerelease"
];
var Wf = {
  MAX_LENGTH: ix,
  MAX_SAFE_COMPONENT_LENGTH: L2,
  MAX_SAFE_BUILD_LENGTH: x2,
  MAX_SAFE_INTEGER: N2,
  RELEASE_TYPES: G2,
  SEMVER_SPEC_VERSION: _2,
  FLAG_INCLUDE_PRERELEASE: 1,
  FLAG_LOOSE: 2
};
const U2 = typeof process == "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...t) => console.error("SEMVER", ...t) : () => {
};
var Vf = U2;
(function(t, A) {
  const {
    MAX_SAFE_COMPONENT_LENGTH: e,
    MAX_SAFE_BUILD_LENGTH: r,
    MAX_LENGTH: i
  } = Wf, n = Vf;
  A = t.exports = {};
  const s = A.re = [], a = A.safeRe = [], g = A.src = [], o = A.safeSrc = [], u = A.t = {};
  let I = 0;
  const c = "[a-zA-Z0-9-]", C = [
    ["\\s", 1],
    ["\\d", i],
    [c, r]
  ], E = (B) => {
    for (const [h, Q] of C)
      B = B.split(`${h}*`).join(`${h}{0,${Q}}`).split(`${h}+`).join(`${h}{1,${Q}}`);
    return B;
  }, l = (B, h, Q) => {
    const f = E(h), p = I++;
    n(B, p, h), u[B] = p, g[p] = h, o[p] = f, s[p] = new RegExp(h, Q ? "g" : void 0), a[p] = new RegExp(f, Q ? "g" : void 0);
  };
  l("NUMERICIDENTIFIER", "0|[1-9]\\d*"), l("NUMERICIDENTIFIERLOOSE", "\\d+"), l("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${c}*`), l("MAINVERSION", `(${g[u.NUMERICIDENTIFIER]})\\.(${g[u.NUMERICIDENTIFIER]})\\.(${g[u.NUMERICIDENTIFIER]})`), l("MAINVERSIONLOOSE", `(${g[u.NUMERICIDENTIFIERLOOSE]})\\.(${g[u.NUMERICIDENTIFIERLOOSE]})\\.(${g[u.NUMERICIDENTIFIERLOOSE]})`), l("PRERELEASEIDENTIFIER", `(?:${g[u.NONNUMERICIDENTIFIER]}|${g[u.NUMERICIDENTIFIER]})`), l("PRERELEASEIDENTIFIERLOOSE", `(?:${g[u.NONNUMERICIDENTIFIER]}|${g[u.NUMERICIDENTIFIERLOOSE]})`), l("PRERELEASE", `(?:-(${g[u.PRERELEASEIDENTIFIER]}(?:\\.${g[u.PRERELEASEIDENTIFIER]})*))`), l("PRERELEASELOOSE", `(?:-?(${g[u.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${g[u.PRERELEASEIDENTIFIERLOOSE]})*))`), l("BUILDIDENTIFIER", `${c}+`), l("BUILD", `(?:\\+(${g[u.BUILDIDENTIFIER]}(?:\\.${g[u.BUILDIDENTIFIER]})*))`), l("FULLPLAIN", `v?${g[u.MAINVERSION]}${g[u.PRERELEASE]}?${g[u.BUILD]}?`), l("FULL", `^${g[u.FULLPLAIN]}$`), l("LOOSEPLAIN", `[v=\\s]*${g[u.MAINVERSIONLOOSE]}${g[u.PRERELEASELOOSE]}?${g[u.BUILD]}?`), l("LOOSE", `^${g[u.LOOSEPLAIN]}$`), l("GTLT", "((?:<|>)?=?)"), l("XRANGEIDENTIFIERLOOSE", `${g[u.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`), l("XRANGEIDENTIFIER", `${g[u.NUMERICIDENTIFIER]}|x|X|\\*`), l("XRANGEPLAIN", `[v=\\s]*(${g[u.XRANGEIDENTIFIER]})(?:\\.(${g[u.XRANGEIDENTIFIER]})(?:\\.(${g[u.XRANGEIDENTIFIER]})(?:${g[u.PRERELEASE]})?${g[u.BUILD]}?)?)?`), l("XRANGEPLAINLOOSE", `[v=\\s]*(${g[u.XRANGEIDENTIFIERLOOSE]})(?:\\.(${g[u.XRANGEIDENTIFIERLOOSE]})(?:\\.(${g[u.XRANGEIDENTIFIERLOOSE]})(?:${g[u.PRERELEASELOOSE]})?${g[u.BUILD]}?)?)?`), l("XRANGE", `^${g[u.GTLT]}\\s*${g[u.XRANGEPLAIN]}$`), l("XRANGELOOSE", `^${g[u.GTLT]}\\s*${g[u.XRANGEPLAINLOOSE]}$`), l("COERCEPLAIN", `(^|[^\\d])(\\d{1,${e}})(?:\\.(\\d{1,${e}}))?(?:\\.(\\d{1,${e}}))?`), l("COERCE", `${g[u.COERCEPLAIN]}(?:$|[^\\d])`), l("COERCEFULL", g[u.COERCEPLAIN] + `(?:${g[u.PRERELEASE]})?(?:${g[u.BUILD]})?(?:$|[^\\d])`), l("COERCERTL", g[u.COERCE], !0), l("COERCERTLFULL", g[u.COERCEFULL], !0), l("LONETILDE", "(?:~>?)"), l("TILDETRIM", `(\\s*)${g[u.LONETILDE]}\\s+`, !0), A.tildeTrimReplace = "$1~", l("TILDE", `^${g[u.LONETILDE]}${g[u.XRANGEPLAIN]}$`), l("TILDELOOSE", `^${g[u.LONETILDE]}${g[u.XRANGEPLAINLOOSE]}$`), l("LONECARET", "(?:\\^)"), l("CARETTRIM", `(\\s*)${g[u.LONECARET]}\\s+`, !0), A.caretTrimReplace = "$1^", l("CARET", `^${g[u.LONECARET]}${g[u.XRANGEPLAIN]}$`), l("CARETLOOSE", `^${g[u.LONECARET]}${g[u.XRANGEPLAINLOOSE]}$`), l("COMPARATORLOOSE", `^${g[u.GTLT]}\\s*(${g[u.LOOSEPLAIN]})$|^$`), l("COMPARATOR", `^${g[u.GTLT]}\\s*(${g[u.FULLPLAIN]})$|^$`), l("COMPARATORTRIM", `(\\s*)${g[u.GTLT]}\\s*(${g[u.LOOSEPLAIN]}|${g[u.XRANGEPLAIN]})`, !0), A.comparatorTrimReplace = "$1$2$3", l("HYPHENRANGE", `^\\s*(${g[u.XRANGEPLAIN]})\\s+-\\s+(${g[u.XRANGEPLAIN]})\\s*$`), l("HYPHENRANGELOOSE", `^\\s*(${g[u.XRANGEPLAINLOOSE]})\\s+-\\s+(${g[u.XRANGEPLAINLOOSE]})\\s*$`), l("STAR", "(<|>)?=?\\s*\\*"), l("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$"), l("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
})(Yw, Yw.exports);
var xE = Yw.exports;
const T2 = Object.freeze({ loose: !0 }), K2 = Object.freeze({}), J2 = (t) => t ? typeof t != "object" ? T2 : t : K2;
var U0 = J2;
const ok = /^[0-9]+$/, nx = (t, A) => {
  if (typeof t == "number" && typeof A == "number")
    return t === A ? 0 : t < A ? -1 : 1;
  const e = ok.test(t), r = ok.test(A);
  return e && r && (t = +t, A = +A), t === A ? 0 : e && !r ? -1 : r && !e ? 1 : t < A ? -1 : 1;
}, H2 = (t, A) => nx(A, t);
var sx = {
  compareIdentifiers: nx,
  rcompareIdentifiers: H2
};
const ch = Vf, { MAX_LENGTH: gk, MAX_SAFE_INTEGER: Ih } = Wf, { safeRe: Ch, t: lh } = xE, P2 = U0, { compareIdentifiers: ey } = sx;
let O2 = class Pi {
  constructor(A, e) {
    if (e = P2(e), A instanceof Pi) {
      if (A.loose === !!e.loose && A.includePrerelease === !!e.includePrerelease)
        return A;
      A = A.version;
    } else if (typeof A != "string")
      throw new TypeError(`Invalid version. Must be a string. Got type "${typeof A}".`);
    if (A.length > gk)
      throw new TypeError(
        `version is longer than ${gk} characters`
      );
    ch("SemVer", A, e), this.options = e, this.loose = !!e.loose, this.includePrerelease = !!e.includePrerelease;
    const r = A.trim().match(e.loose ? Ch[lh.LOOSE] : Ch[lh.FULL]);
    if (!r)
      throw new TypeError(`Invalid Version: ${A}`);
    if (this.raw = A, this.major = +r[1], this.minor = +r[2], this.patch = +r[3], this.major > Ih || this.major < 0)
      throw new TypeError("Invalid major version");
    if (this.minor > Ih || this.minor < 0)
      throw new TypeError("Invalid minor version");
    if (this.patch > Ih || this.patch < 0)
      throw new TypeError("Invalid patch version");
    r[4] ? this.prerelease = r[4].split(".").map((i) => {
      if (/^[0-9]+$/.test(i)) {
        const n = +i;
        if (n >= 0 && n < Ih)
          return n;
      }
      return i;
    }) : this.prerelease = [], this.build = r[5] ? r[5].split(".") : [], this.format();
  }
  format() {
    return this.version = `${this.major}.${this.minor}.${this.patch}`, this.prerelease.length && (this.version += `-${this.prerelease.join(".")}`), this.version;
  }
  toString() {
    return this.version;
  }
  compare(A) {
    if (ch("SemVer.compare", this.version, this.options, A), !(A instanceof Pi)) {
      if (typeof A == "string" && A === this.version)
        return 0;
      A = new Pi(A, this.options);
    }
    return A.version === this.version ? 0 : this.compareMain(A) || this.comparePre(A);
  }
  compareMain(A) {
    return A instanceof Pi || (A = new Pi(A, this.options)), this.major < A.major ? -1 : this.major > A.major ? 1 : this.minor < A.minor ? -1 : this.minor > A.minor ? 1 : this.patch < A.patch ? -1 : this.patch > A.patch ? 1 : 0;
  }
  comparePre(A) {
    if (A instanceof Pi || (A = new Pi(A, this.options)), this.prerelease.length && !A.prerelease.length)
      return -1;
    if (!this.prerelease.length && A.prerelease.length)
      return 1;
    if (!this.prerelease.length && !A.prerelease.length)
      return 0;
    let e = 0;
    do {
      const r = this.prerelease[e], i = A.prerelease[e];
      if (ch("prerelease compare", e, r, i), r === void 0 && i === void 0)
        return 0;
      if (i === void 0)
        return 1;
      if (r === void 0)
        return -1;
      if (r === i)
        continue;
      return ey(r, i);
    } while (++e);
  }
  compareBuild(A) {
    A instanceof Pi || (A = new Pi(A, this.options));
    let e = 0;
    do {
      const r = this.build[e], i = A.build[e];
      if (ch("build compare", e, r, i), r === void 0 && i === void 0)
        return 0;
      if (i === void 0)
        return 1;
      if (r === void 0)
        return -1;
      if (r === i)
        continue;
      return ey(r, i);
    } while (++e);
  }
  // preminor will bump the version up to the next minor release, and immediately
  // down to pre-release. premajor and prepatch work the same way.
  inc(A, e, r) {
    if (A.startsWith("pre")) {
      if (!e && r === !1)
        throw new Error("invalid increment argument: identifier is empty");
      if (e) {
        const i = `-${e}`.match(this.options.loose ? Ch[lh.PRERELEASELOOSE] : Ch[lh.PRERELEASE]);
        if (!i || i[1] !== e)
          throw new Error(`invalid identifier: ${e}`);
      }
    }
    switch (A) {
      case "premajor":
        this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", e, r);
        break;
      case "preminor":
        this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", e, r);
        break;
      case "prepatch":
        this.prerelease.length = 0, this.inc("patch", e, r), this.inc("pre", e, r);
        break;
      case "prerelease":
        this.prerelease.length === 0 && this.inc("patch", e, r), this.inc("pre", e, r);
        break;
      case "release":
        if (this.prerelease.length === 0)
          throw new Error(`version ${this.raw} is not a prerelease`);
        this.prerelease.length = 0;
        break;
      case "major":
        (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) && this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
        break;
      case "minor":
        (this.patch !== 0 || this.prerelease.length === 0) && this.minor++, this.patch = 0, this.prerelease = [];
        break;
      case "patch":
        this.prerelease.length === 0 && this.patch++, this.prerelease = [];
        break;
      case "pre": {
        const i = Number(r) ? 1 : 0;
        if (this.prerelease.length === 0)
          this.prerelease = [i];
        else {
          let n = this.prerelease.length;
          for (; --n >= 0; )
            typeof this.prerelease[n] == "number" && (this.prerelease[n]++, n = -2);
          if (n === -1) {
            if (e === this.prerelease.join(".") && r === !1)
              throw new Error("invalid increment argument: identifier already exists");
            this.prerelease.push(i);
          }
        }
        if (e) {
          let n = [e, i];
          r === !1 && (n = [e]), ey(this.prerelease[0], e) === 0 ? isNaN(this.prerelease[1]) && (this.prerelease = n) : this.prerelease = n;
        }
        break;
      }
      default:
        throw new Error(`invalid increment argument: ${A}`);
    }
    return this.raw = this.format(), this.build.length && (this.raw += `+${this.build.join(".")}`), this;
  }
};
var ur = O2;
const uk = ur, Y2 = (t, A, e = !1) => {
  if (t instanceof uk)
    return t;
  try {
    return new uk(t, A);
  } catch (r) {
    if (!e)
      return null;
    throw r;
  }
};
var aI = Y2;
const q2 = aI, j2 = (t, A) => {
  const e = q2(t, A);
  return e ? e.version : null;
};
var W2 = j2;
const V2 = aI, Z2 = (t, A) => {
  const e = V2(t.trim().replace(/^[=v]+/, ""), A);
  return e ? e.version : null;
};
var X2 = Z2;
const ck = ur, z2 = (t, A, e, r, i) => {
  typeof e == "string" && (i = r, r = e, e = void 0);
  try {
    return new ck(
      t instanceof ck ? t.version : t,
      e
    ).inc(A, r, i).version;
  } catch {
    return null;
  }
};
var $2 = z2;
const Ik = aI, AY = (t, A) => {
  const e = Ik(t, null, !0), r = Ik(A, null, !0), i = e.compare(r);
  if (i === 0)
    return null;
  const n = i > 0, s = n ? e : r, a = n ? r : e, g = !!s.prerelease.length;
  if (!!a.prerelease.length && !g) {
    if (!a.patch && !a.minor)
      return "major";
    if (a.compareMain(s) === 0)
      return a.minor && !a.patch ? "minor" : "patch";
  }
  const u = g ? "pre" : "";
  return e.major !== r.major ? u + "major" : e.minor !== r.minor ? u + "minor" : e.patch !== r.patch ? u + "patch" : "prerelease";
};
var eY = AY;
const tY = ur, rY = (t, A) => new tY(t, A).major;
var iY = rY;
const nY = ur, sY = (t, A) => new nY(t, A).minor;
var aY = sY;
const oY = ur, gY = (t, A) => new oY(t, A).patch;
var uY = gY;
const cY = aI, IY = (t, A) => {
  const e = cY(t, A);
  return e && e.prerelease.length ? e.prerelease : null;
};
var CY = IY;
const Ck = ur, lY = (t, A, e) => new Ck(t, e).compare(new Ck(A, e));
var Ni = lY;
const BY = Ni, EY = (t, A, e) => BY(A, t, e);
var hY = EY;
const QY = Ni, dY = (t, A) => QY(t, A, !0);
var fY = dY;
const lk = ur, pY = (t, A, e) => {
  const r = new lk(t, e), i = new lk(A, e);
  return r.compare(i) || r.compareBuild(i);
};
var T0 = pY;
const yY = T0, wY = (t, A) => t.sort((e, r) => yY(e, r, A));
var mY = wY;
const DY = T0, SY = (t, A) => t.sort((e, r) => DY(r, e, A));
var FY = SY;
const kY = Ni, vY = (t, A, e) => kY(t, A, e) > 0;
var Zf = vY;
const RY = Ni, bY = (t, A, e) => RY(t, A, e) < 0;
var K0 = bY;
const MY = Ni, _Y = (t, A, e) => MY(t, A, e) === 0;
var ax = _Y;
const NY = Ni, LY = (t, A, e) => NY(t, A, e) !== 0;
var ox = LY;
const xY = Ni, GY = (t, A, e) => xY(t, A, e) >= 0;
var J0 = GY;
const UY = Ni, TY = (t, A, e) => UY(t, A, e) <= 0;
var H0 = TY;
const KY = ax, JY = ox, HY = Zf, PY = J0, OY = K0, YY = H0, qY = (t, A, e, r) => {
  switch (A) {
    case "===":
      return typeof t == "object" && (t = t.version), typeof e == "object" && (e = e.version), t === e;
    case "!==":
      return typeof t == "object" && (t = t.version), typeof e == "object" && (e = e.version), t !== e;
    case "":
    case "=":
    case "==":
      return KY(t, e, r);
    case "!=":
      return JY(t, e, r);
    case ">":
      return HY(t, e, r);
    case ">=":
      return PY(t, e, r);
    case "<":
      return OY(t, e, r);
    case "<=":
      return YY(t, e, r);
    default:
      throw new TypeError(`Invalid operator: ${A}`);
  }
};
var gx = qY;
const jY = ur, WY = aI, { safeRe: Bh, t: Eh } = xE, VY = (t, A) => {
  if (t instanceof jY)
    return t;
  if (typeof t == "number" && (t = String(t)), typeof t != "string")
    return null;
  A = A || {};
  let e = null;
  if (!A.rtl)
    e = t.match(A.includePrerelease ? Bh[Eh.COERCEFULL] : Bh[Eh.COERCE]);
  else {
    const g = A.includePrerelease ? Bh[Eh.COERCERTLFULL] : Bh[Eh.COERCERTL];
    let o;
    for (; (o = g.exec(t)) && (!e || e.index + e[0].length !== t.length); )
      (!e || o.index + o[0].length !== e.index + e[0].length) && (e = o), g.lastIndex = o.index + o[1].length + o[2].length;
    g.lastIndex = -1;
  }
  if (e === null)
    return null;
  const r = e[2], i = e[3] || "0", n = e[4] || "0", s = A.includePrerelease && e[5] ? `-${e[5]}` : "", a = A.includePrerelease && e[6] ? `+${e[6]}` : "";
  return WY(`${r}.${i}.${n}${s}${a}`, A);
};
var ZY = VY;
let XY = class {
  constructor() {
    this.max = 1e3, this.map = /* @__PURE__ */ new Map();
  }
  get(A) {
    const e = this.map.get(A);
    if (e !== void 0)
      return this.map.delete(A), this.map.set(A, e), e;
  }
  delete(A) {
    return this.map.delete(A);
  }
  set(A, e) {
    if (!this.delete(A) && e !== void 0) {
      if (this.map.size >= this.max) {
        const i = this.map.keys().next().value;
        this.delete(i);
      }
      this.map.set(A, e);
    }
    return this;
  }
};
var zY = XY, ty, Bk;
function Li() {
  if (Bk) return ty;
  Bk = 1;
  const t = /\s+/g;
  class A {
    constructor(j, eA) {
      if (eA = i(eA), j instanceof A)
        return j.loose === !!eA.loose && j.includePrerelease === !!eA.includePrerelease ? j : new A(j.raw, eA);
      if (j instanceof n)
        return this.raw = j.value, this.set = [[j]], this.formatted = void 0, this;
      if (this.options = eA, this.loose = !!eA.loose, this.includePrerelease = !!eA.includePrerelease, this.raw = j.trim().replace(t, " "), this.set = this.raw.split("||").map((sA) => this.parseRange(sA.trim())).filter((sA) => sA.length), !this.set.length)
        throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
      if (this.set.length > 1) {
        const sA = this.set[0];
        if (this.set = this.set.filter((uA) => !l(uA[0])), this.set.length === 0)
          this.set = [sA];
        else if (this.set.length > 1) {
          for (const uA of this.set)
            if (uA.length === 1 && B(uA[0])) {
              this.set = [uA];
              break;
            }
        }
      }
      this.formatted = void 0;
    }
    get range() {
      if (this.formatted === void 0) {
        this.formatted = "";
        for (let j = 0; j < this.set.length; j++) {
          j > 0 && (this.formatted += "||");
          const eA = this.set[j];
          for (let sA = 0; sA < eA.length; sA++)
            sA > 0 && (this.formatted += " "), this.formatted += eA[sA].toString().trim();
        }
      }
      return this.formatted;
    }
    format() {
      return this.range;
    }
    toString() {
      return this.range;
    }
    parseRange(j) {
      const sA = ((this.options.includePrerelease && C) | (this.options.loose && E)) + ":" + j, uA = r.get(sA);
      if (uA)
        return uA;
      const rA = this.options.loose, hA = rA ? g[o.HYPHENRANGELOOSE] : g[o.HYPHENRANGE];
      j = j.replace(hA, T(this.options.includePrerelease)), s("hyphen replace", j), j = j.replace(g[o.COMPARATORTRIM], u), s("comparator trim", j), j = j.replace(g[o.TILDETRIM], I), s("tilde trim", j), j = j.replace(g[o.CARETTRIM], c), s("caret trim", j);
      let UA = j.split(" ").map((zA) => Q(zA, this.options)).join(" ").split(/\s+/).map((zA) => G(zA, this.options));
      rA && (UA = UA.filter((zA) => (s("loose invalid filter", zA, this.options), !!zA.match(g[o.COMPARATORLOOSE])))), s("range list", UA);
      const iA = /* @__PURE__ */ new Map(), wA = UA.map((zA) => new n(zA, this.options));
      for (const zA of wA) {
        if (l(zA))
          return [zA];
        iA.set(zA.value, zA);
      }
      iA.size > 1 && iA.has("") && iA.delete("");
      const Re = [...iA.values()];
      return r.set(sA, Re), Re;
    }
    intersects(j, eA) {
      if (!(j instanceof A))
        throw new TypeError("a Range is required");
      return this.set.some((sA) => h(sA, eA) && j.set.some((uA) => h(uA, eA) && sA.every((rA) => uA.every((hA) => rA.intersects(hA, eA)))));
    }
    // if ANY of the sets match ALL of its comparators, then pass
    test(j) {
      if (!j)
        return !1;
      if (typeof j == "string")
        try {
          j = new a(j, this.options);
        } catch {
          return !1;
        }
      for (let eA = 0; eA < this.set.length; eA++)
        if (K(this.set[eA], j, this.options))
          return !0;
      return !1;
    }
  }
  ty = A;
  const e = zY, r = new e(), i = U0, n = Xf(), s = Vf, a = ur, {
    safeRe: g,
    t: o,
    comparatorTrimReplace: u,
    tildeTrimReplace: I,
    caretTrimReplace: c
  } = xE, { FLAG_INCLUDE_PRERELEASE: C, FLAG_LOOSE: E } = Wf, l = (H) => H.value === "<0.0.0-0", B = (H) => H.value === "", h = (H, j) => {
    let eA = !0;
    const sA = H.slice();
    let uA = sA.pop();
    for (; eA && sA.length; )
      eA = sA.every((rA) => uA.intersects(rA, j)), uA = sA.pop();
    return eA;
  }, Q = (H, j) => (H = H.replace(g[o.BUILD], ""), s("comp", H, j), H = m(H, j), s("caret", H), H = p(H, j), s("tildes", H), H = w(H, j), s("xrange", H), H = b(H, j), s("stars", H), H), f = (H) => !H || H.toLowerCase() === "x" || H === "*", p = (H, j) => H.trim().split(/\s+/).map((eA) => y(eA, j)).join(" "), y = (H, j) => {
    const eA = j.loose ? g[o.TILDELOOSE] : g[o.TILDE];
    return H.replace(eA, (sA, uA, rA, hA, UA) => {
      s("tilde", H, sA, uA, rA, hA, UA);
      let iA;
      return f(uA) ? iA = "" : f(rA) ? iA = `>=${uA}.0.0 <${+uA + 1}.0.0-0` : f(hA) ? iA = `>=${uA}.${rA}.0 <${uA}.${+rA + 1}.0-0` : UA ? (s("replaceTilde pr", UA), iA = `>=${uA}.${rA}.${hA}-${UA} <${uA}.${+rA + 1}.0-0`) : iA = `>=${uA}.${rA}.${hA} <${uA}.${+rA + 1}.0-0`, s("tilde return", iA), iA;
    });
  }, m = (H, j) => H.trim().split(/\s+/).map((eA) => S(eA, j)).join(" "), S = (H, j) => {
    s("caret", H, j);
    const eA = j.loose ? g[o.CARETLOOSE] : g[o.CARET], sA = j.includePrerelease ? "-0" : "";
    return H.replace(eA, (uA, rA, hA, UA, iA) => {
      s("caret", H, uA, rA, hA, UA, iA);
      let wA;
      return f(rA) ? wA = "" : f(hA) ? wA = `>=${rA}.0.0${sA} <${+rA + 1}.0.0-0` : f(UA) ? rA === "0" ? wA = `>=${rA}.${hA}.0${sA} <${rA}.${+hA + 1}.0-0` : wA = `>=${rA}.${hA}.0${sA} <${+rA + 1}.0.0-0` : iA ? (s("replaceCaret pr", iA), rA === "0" ? hA === "0" ? wA = `>=${rA}.${hA}.${UA}-${iA} <${rA}.${hA}.${+UA + 1}-0` : wA = `>=${rA}.${hA}.${UA}-${iA} <${rA}.${+hA + 1}.0-0` : wA = `>=${rA}.${hA}.${UA}-${iA} <${+rA + 1}.0.0-0`) : (s("no pr"), rA === "0" ? hA === "0" ? wA = `>=${rA}.${hA}.${UA}${sA} <${rA}.${hA}.${+UA + 1}-0` : wA = `>=${rA}.${hA}.${UA}${sA} <${rA}.${+hA + 1}.0-0` : wA = `>=${rA}.${hA}.${UA} <${+rA + 1}.0.0-0`), s("caret return", wA), wA;
    });
  }, w = (H, j) => (s("replaceXRanges", H, j), H.split(/\s+/).map((eA) => F(eA, j)).join(" ")), F = (H, j) => {
    H = H.trim();
    const eA = j.loose ? g[o.XRANGELOOSE] : g[o.XRANGE];
    return H.replace(eA, (sA, uA, rA, hA, UA, iA) => {
      s("xRange", H, sA, uA, rA, hA, UA, iA);
      const wA = f(rA), Re = wA || f(hA), zA = Re || f(UA), U = zA;
      return uA === "=" && U && (uA = ""), iA = j.includePrerelease ? "-0" : "", wA ? uA === ">" || uA === "<" ? sA = "<0.0.0-0" : sA = "*" : uA && U ? (Re && (hA = 0), UA = 0, uA === ">" ? (uA = ">=", Re ? (rA = +rA + 1, hA = 0, UA = 0) : (hA = +hA + 1, UA = 0)) : uA === "<=" && (uA = "<", Re ? rA = +rA + 1 : hA = +hA + 1), uA === "<" && (iA = "-0"), sA = `${uA + rA}.${hA}.${UA}${iA}`) : Re ? sA = `>=${rA}.0.0${iA} <${+rA + 1}.0.0-0` : zA && (sA = `>=${rA}.${hA}.0${iA} <${rA}.${+hA + 1}.0-0`), s("xRange return", sA), sA;
    });
  }, b = (H, j) => (s("replaceStars", H, j), H.trim().replace(g[o.STAR], "")), G = (H, j) => (s("replaceGTE0", H, j), H.trim().replace(g[j.includePrerelease ? o.GTE0PRE : o.GTE0], "")), T = (H) => (j, eA, sA, uA, rA, hA, UA, iA, wA, Re, zA, U) => (f(sA) ? eA = "" : f(uA) ? eA = `>=${sA}.0.0${H ? "-0" : ""}` : f(rA) ? eA = `>=${sA}.${uA}.0${H ? "-0" : ""}` : hA ? eA = `>=${eA}` : eA = `>=${eA}${H ? "-0" : ""}`, f(wA) ? iA = "" : f(Re) ? iA = `<${+wA + 1}.0.0-0` : f(zA) ? iA = `<${wA}.${+Re + 1}.0-0` : U ? iA = `<=${wA}.${Re}.${zA}-${U}` : H ? iA = `<${wA}.${Re}.${+zA + 1}-0` : iA = `<=${iA}`, `${eA} ${iA}`.trim()), K = (H, j, eA) => {
    for (let sA = 0; sA < H.length; sA++)
      if (!H[sA].test(j))
        return !1;
    if (j.prerelease.length && !eA.includePrerelease) {
      for (let sA = 0; sA < H.length; sA++)
        if (s(H[sA].semver), H[sA].semver !== n.ANY && H[sA].semver.prerelease.length > 0) {
          const uA = H[sA].semver;
          if (uA.major === j.major && uA.minor === j.minor && uA.patch === j.patch)
            return !0;
        }
      return !1;
    }
    return !0;
  };
  return ty;
}
var ry, Ek;
function Xf() {
  if (Ek) return ry;
  Ek = 1;
  const t = Symbol("SemVer ANY");
  class A {
    static get ANY() {
      return t;
    }
    constructor(u, I) {
      if (I = e(I), u instanceof A) {
        if (u.loose === !!I.loose)
          return u;
        u = u.value;
      }
      u = u.trim().split(/\s+/).join(" "), s("comparator", u, I), this.options = I, this.loose = !!I.loose, this.parse(u), this.semver === t ? this.value = "" : this.value = this.operator + this.semver.version, s("comp", this);
    }
    parse(u) {
      const I = this.options.loose ? r[i.COMPARATORLOOSE] : r[i.COMPARATOR], c = u.match(I);
      if (!c)
        throw new TypeError(`Invalid comparator: ${u}`);
      this.operator = c[1] !== void 0 ? c[1] : "", this.operator === "=" && (this.operator = ""), c[2] ? this.semver = new a(c[2], this.options.loose) : this.semver = t;
    }
    toString() {
      return this.value;
    }
    test(u) {
      if (s("Comparator.test", u, this.options.loose), this.semver === t || u === t)
        return !0;
      if (typeof u == "string")
        try {
          u = new a(u, this.options);
        } catch {
          return !1;
        }
      return n(u, this.operator, this.semver, this.options);
    }
    intersects(u, I) {
      if (!(u instanceof A))
        throw new TypeError("a Comparator is required");
      return this.operator === "" ? this.value === "" ? !0 : new g(u.value, I).test(this.value) : u.operator === "" ? u.value === "" ? !0 : new g(this.value, I).test(u.semver) : (I = e(I), I.includePrerelease && (this.value === "<0.0.0-0" || u.value === "<0.0.0-0") || !I.includePrerelease && (this.value.startsWith("<0.0.0") || u.value.startsWith("<0.0.0")) ? !1 : !!(this.operator.startsWith(">") && u.operator.startsWith(">") || this.operator.startsWith("<") && u.operator.startsWith("<") || this.semver.version === u.semver.version && this.operator.includes("=") && u.operator.includes("=") || n(this.semver, "<", u.semver, I) && this.operator.startsWith(">") && u.operator.startsWith("<") || n(this.semver, ">", u.semver, I) && this.operator.startsWith("<") && u.operator.startsWith(">")));
    }
  }
  ry = A;
  const e = U0, { safeRe: r, t: i } = xE, n = gx, s = Vf, a = ur, g = Li();
  return ry;
}
const $Y = Li(), A8 = (t, A, e) => {
  try {
    A = new $Y(A, e);
  } catch {
    return !1;
  }
  return A.test(t);
};
var zf = A8;
const e8 = Li(), t8 = (t, A) => new e8(t, A).set.map((e) => e.map((r) => r.value).join(" ").trim().split(" "));
var r8 = t8;
const i8 = ur, n8 = Li(), s8 = (t, A, e) => {
  let r = null, i = null, n = null;
  try {
    n = new n8(A, e);
  } catch {
    return null;
  }
  return t.forEach((s) => {
    n.test(s) && (!r || i.compare(s) === -1) && (r = s, i = new i8(r, e));
  }), r;
};
var a8 = s8;
const o8 = ur, g8 = Li(), u8 = (t, A, e) => {
  let r = null, i = null, n = null;
  try {
    n = new g8(A, e);
  } catch {
    return null;
  }
  return t.forEach((s) => {
    n.test(s) && (!r || i.compare(s) === 1) && (r = s, i = new o8(r, e));
  }), r;
};
var c8 = u8;
const iy = ur, I8 = Li(), hk = Zf, C8 = (t, A) => {
  t = new I8(t, A);
  let e = new iy("0.0.0");
  if (t.test(e) || (e = new iy("0.0.0-0"), t.test(e)))
    return e;
  e = null;
  for (let r = 0; r < t.set.length; ++r) {
    const i = t.set[r];
    let n = null;
    i.forEach((s) => {
      const a = new iy(s.semver.version);
      switch (s.operator) {
        case ">":
          a.prerelease.length === 0 ? a.patch++ : a.prerelease.push(0), a.raw = a.format();
        case "":
        case ">=":
          (!n || hk(a, n)) && (n = a);
          break;
        case "<":
        case "<=":
          break;
        default:
          throw new Error(`Unexpected operation: ${s.operator}`);
      }
    }), n && (!e || hk(e, n)) && (e = n);
  }
  return e && t.test(e) ? e : null;
};
var l8 = C8;
const B8 = Li(), E8 = (t, A) => {
  try {
    return new B8(t, A).range || "*";
  } catch {
    return null;
  }
};
var h8 = E8;
const Q8 = ur, ux = Xf(), { ANY: d8 } = ux, f8 = Li(), p8 = zf, Qk = Zf, dk = K0, y8 = H0, w8 = J0, m8 = (t, A, e, r) => {
  t = new Q8(t, r), A = new f8(A, r);
  let i, n, s, a, g;
  switch (e) {
    case ">":
      i = Qk, n = y8, s = dk, a = ">", g = ">=";
      break;
    case "<":
      i = dk, n = w8, s = Qk, a = "<", g = "<=";
      break;
    default:
      throw new TypeError('Must provide a hilo val of "<" or ">"');
  }
  if (p8(t, A, r))
    return !1;
  for (let o = 0; o < A.set.length; ++o) {
    const u = A.set[o];
    let I = null, c = null;
    if (u.forEach((C) => {
      C.semver === d8 && (C = new ux(">=0.0.0")), I = I || C, c = c || C, i(C.semver, I.semver, r) ? I = C : s(C.semver, c.semver, r) && (c = C);
    }), I.operator === a || I.operator === g || (!c.operator || c.operator === a) && n(t, c.semver))
      return !1;
    if (c.operator === g && s(t, c.semver))
      return !1;
  }
  return !0;
};
var P0 = m8;
const D8 = P0, S8 = (t, A, e) => D8(t, A, ">", e);
var F8 = S8;
const k8 = P0, v8 = (t, A, e) => k8(t, A, "<", e);
var R8 = v8;
const fk = Li(), b8 = (t, A, e) => (t = new fk(t, e), A = new fk(A, e), t.intersects(A, e));
var M8 = b8;
const _8 = zf, N8 = Ni;
var L8 = (t, A, e) => {
  const r = [];
  let i = null, n = null;
  const s = t.sort((u, I) => N8(u, I, e));
  for (const u of s)
    _8(u, A, e) ? (n = u, i || (i = u)) : (n && r.push([i, n]), n = null, i = null);
  i && r.push([i, null]);
  const a = [];
  for (const [u, I] of r)
    u === I ? a.push(u) : !I && u === s[0] ? a.push("*") : I ? u === s[0] ? a.push(`<=${I}`) : a.push(`${u} - ${I}`) : a.push(`>=${u}`);
  const g = a.join(" || "), o = typeof A.raw == "string" ? A.raw : String(A);
  return g.length < o.length ? g : A;
};
const pk = Li(), O0 = Xf(), { ANY: ny } = O0, dI = zf, Y0 = Ni, x8 = (t, A, e = {}) => {
  if (t === A)
    return !0;
  t = new pk(t, e), A = new pk(A, e);
  let r = !1;
  A: for (const i of t.set) {
    for (const n of A.set) {
      const s = U8(i, n, e);
      if (r = r || s !== null, s)
        continue A;
    }
    if (r)
      return !1;
  }
  return !0;
}, G8 = [new O0(">=0.0.0-0")], yk = [new O0(">=0.0.0")], U8 = (t, A, e) => {
  if (t === A)
    return !0;
  if (t.length === 1 && t[0].semver === ny) {
    if (A.length === 1 && A[0].semver === ny)
      return !0;
    e.includePrerelease ? t = G8 : t = yk;
  }
  if (A.length === 1 && A[0].semver === ny) {
    if (e.includePrerelease)
      return !0;
    A = yk;
  }
  const r = /* @__PURE__ */ new Set();
  let i, n;
  for (const C of t)
    C.operator === ">" || C.operator === ">=" ? i = wk(i, C, e) : C.operator === "<" || C.operator === "<=" ? n = mk(n, C, e) : r.add(C.semver);
  if (r.size > 1)
    return null;
  let s;
  if (i && n) {
    if (s = Y0(i.semver, n.semver, e), s > 0)
      return null;
    if (s === 0 && (i.operator !== ">=" || n.operator !== "<="))
      return null;
  }
  for (const C of r) {
    if (i && !dI(C, String(i), e) || n && !dI(C, String(n), e))
      return null;
    for (const E of A)
      if (!dI(C, String(E), e))
        return !1;
    return !0;
  }
  let a, g, o, u, I = n && !e.includePrerelease && n.semver.prerelease.length ? n.semver : !1, c = i && !e.includePrerelease && i.semver.prerelease.length ? i.semver : !1;
  I && I.prerelease.length === 1 && n.operator === "<" && I.prerelease[0] === 0 && (I = !1);
  for (const C of A) {
    if (u = u || C.operator === ">" || C.operator === ">=", o = o || C.operator === "<" || C.operator === "<=", i) {
      if (c && C.semver.prerelease && C.semver.prerelease.length && C.semver.major === c.major && C.semver.minor === c.minor && C.semver.patch === c.patch && (c = !1), C.operator === ">" || C.operator === ">=") {
        if (a = wk(i, C, e), a === C && a !== i)
          return !1;
      } else if (i.operator === ">=" && !dI(i.semver, String(C), e))
        return !1;
    }
    if (n) {
      if (I && C.semver.prerelease && C.semver.prerelease.length && C.semver.major === I.major && C.semver.minor === I.minor && C.semver.patch === I.patch && (I = !1), C.operator === "<" || C.operator === "<=") {
        if (g = mk(n, C, e), g === C && g !== n)
          return !1;
      } else if (n.operator === "<=" && !dI(n.semver, String(C), e))
        return !1;
    }
    if (!C.operator && (n || i) && s !== 0)
      return !1;
  }
  return !(i && o && !n && s !== 0 || n && u && !i && s !== 0 || c || I);
}, wk = (t, A, e) => {
  if (!t)
    return A;
  const r = Y0(t.semver, A.semver, e);
  return r > 0 ? t : r < 0 || A.operator === ">" && t.operator === ">=" ? A : t;
}, mk = (t, A, e) => {
  if (!t)
    return A;
  const r = Y0(t.semver, A.semver, e);
  return r < 0 ? t : r > 0 || A.operator === "<" && t.operator === "<=" ? A : t;
};
var T8 = x8;
const sy = xE, Dk = Wf, K8 = ur, Sk = sx, J8 = aI, H8 = W2, P8 = X2, O8 = $2, Y8 = eY, q8 = iY, j8 = aY, W8 = uY, V8 = CY, Z8 = Ni, X8 = hY, z8 = fY, $8 = T0, A4 = mY, e4 = FY, t4 = Zf, r4 = K0, i4 = ax, n4 = ox, s4 = J0, a4 = H0, o4 = gx, g4 = ZY, u4 = Xf(), c4 = Li(), I4 = zf, C4 = r8, l4 = a8, B4 = c8, E4 = l8, h4 = h8, Q4 = P0, d4 = F8, f4 = R8, p4 = M8, y4 = L8, w4 = T8;
var m4 = {
  parse: J8,
  valid: H8,
  clean: P8,
  inc: O8,
  diff: Y8,
  major: q8,
  minor: j8,
  patch: W8,
  prerelease: V8,
  compare: Z8,
  rcompare: X8,
  compareLoose: z8,
  compareBuild: $8,
  sort: A4,
  rsort: e4,
  gt: t4,
  lt: r4,
  eq: i4,
  neq: n4,
  gte: s4,
  lte: a4,
  cmp: o4,
  coerce: g4,
  Comparator: u4,
  Range: c4,
  satisfies: I4,
  toComparators: C4,
  maxSatisfying: l4,
  minSatisfying: B4,
  minVersion: E4,
  validRange: h4,
  outside: Q4,
  gtr: d4,
  ltr: f4,
  intersects: p4,
  simplifyRange: y4,
  subset: w4,
  SemVer: K8,
  re: sy.re,
  src: sy.src,
  tokens: sy.t,
  SEMVER_SPEC_VERSION: Dk.SEMVER_SPEC_VERSION,
  RELEASE_TYPES: Dk.RELEASE_TYPES,
  compareIdentifiers: Sk.compareIdentifiers,
  rcompareIdentifiers: Sk.rcompareIdentifiers
};
const hh = /* @__PURE__ */ sI(m4);
function ks(t) {
  if (!t || t.split("/").length > 2 || t.startsWith("/") || t.endsWith("/") || t.split(":").length > 2)
    throw new Error(`Invalid identifier format: ${t}`);
  const [A, e] = t.split(":"), r = e || "latest";
  if (A.includes("/")) {
    const [i, n] = A.split("/", 2);
    if (!i || !n)
      throw new Error(`Invalid identifier format: ${t}`);
    return [i, n, r];
  } else {
    if (!A)
      throw new Error(`Invalid identifier format: ${t}`);
    return ["-", A, r];
  }
}
class D4 extends Error {
  constructor(A) {
    super(A), Object.defineProperty(this, "status", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.name = "LangSmithConflictError", this.status = 409;
  }
}
async function OA(t, A, e) {
  let r;
  if (t.ok) {
    e && (r = await t.text());
    return;
  }
  if (t.status === 403)
    try {
      const s = await t.json();
      (s == null ? void 0 : s.error) === "org_scoped_key_requires_workspace" && (r = "This API key is org-scoped and requires workspace specification. Please provide 'workspaceId' parameter, or set LANGSMITH_WORKSPACE_ID environment variable.");
    } catch {
      const a = new Error(`${t.status} ${t.statusText}`);
      throw a.status = t == null ? void 0 : t.status, a;
    }
  if (r === void 0)
    try {
      r = await t.text();
    } catch {
      r = "";
    }
  const i = `Failed to ${A}. Received status [${t.status}]: ${t.statusText}. Message: ${r}`;
  if (t.status === 409)
    throw new D4(i);
  const n = new Error(i);
  throw n.status = t.status, n;
}
const cx = "ERR_CONFLICTING_ENDPOINTS";
class S4 extends Error {
  constructor() {
    super("You cannot provide both LANGSMITH_ENDPOINT / LANGCHAIN_ENDPOINT and LANGSMITH_RUNS_ENDPOINTS."), Object.defineProperty(this, "code", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: cx
    }), this.name = "ConflictingEndpointsError";
  }
}
function F4(t) {
  return typeof t == "object" && t !== null && t.code === cx;
}
var Fk = "[...]", k4 = { result: "[Circular]" }, pd = [], Zg = [];
const v4 = new TextEncoder();
function R4() {
  return {
    depthLimit: Number.MAX_SAFE_INTEGER,
    edgesLimit: Number.MAX_SAFE_INTEGER
  };
}
function Qh(t) {
  return v4.encode(t);
}
function Ix(t) {
  if (t && typeof t == "object" && t !== null) {
    if (t instanceof Map)
      return Object.fromEntries(t);
    if (t instanceof Set)
      return Array.from(t);
    if (t instanceof Date)
      return t.toISOString();
    if (t instanceof RegExp)
      return t.toString();
    if (t instanceof Error)
      return {
        name: t.name,
        message: t.message
      };
  } else if (typeof t == "bigint")
    return t.toString();
  return t;
}
function b4(t) {
  return function(A, e) {
    return Ix(e);
  };
}
function Fr(t, A, e, r, i) {
  var n;
  try {
    const s = JSON.stringify(t, b4(e), r);
    return Qh(s);
  } catch (s) {
    if (!((n = s.message) != null && n.includes("Converting circular structure to JSON")))
      return console.warn(`[WARNING]: LangSmith received unserializable value.${A ? `
Context: ${A}` : ""}`), Qh("[Unserializable]");
    dr("SUPPRESS_CIRCULAR_JSON_WARNINGS") !== "true" && console.warn(`[WARNING]: LangSmith received circular JSON. This will decrease tracer performance. ${A ? `
Context: ${A}` : ""}`), typeof i > "u" && (i = R4()), qw(t, "", 0, [], void 0, 0, i);
    let a;
    try {
      Zg.length === 0 ? a = JSON.stringify(t, e, r) : a = JSON.stringify(t, M4(e), r);
    } catch {
      return Qh("[unable to serialize, circular reference is too complex to analyze]");
    } finally {
      for (; pd.length !== 0; ) {
        const g = pd.pop();
        g.length === 4 ? Object.defineProperty(g[0], g[1], g[3]) : g[0][g[1]] = g[2];
      }
    }
    return Qh(a);
  }
}
function ay(t, A, e, r) {
  var i = Object.getOwnPropertyDescriptor(r, e);
  i.get !== void 0 ? i.configurable ? (Object.defineProperty(r, e, { value: t }), pd.push([r, e, A, i])) : Zg.push([A, e, t]) : (r[e] = t, pd.push([r, e, A]));
}
function qw(t, A, e, r, i, n, s) {
  n += 1;
  var a;
  if (typeof t == "object" && t !== null) {
    for (a = 0; a < r.length; a++)
      if (r[a] === t) {
        ay(k4, t, A, i);
        return;
      }
    if (typeof s.depthLimit < "u" && n > s.depthLimit) {
      ay(Fk, t, A, i);
      return;
    }
    if (typeof s.edgesLimit < "u" && e + 1 > s.edgesLimit) {
      ay(Fk, t, A, i);
      return;
    }
    if (r.push(t), Array.isArray(t))
      for (a = 0; a < t.length; a++)
        qw(t[a], a, a, r, t, n, s);
    else {
      t = Ix(t);
      var g = Object.keys(t);
      for (a = 0; a < g.length; a++) {
        var o = g[a];
        qw(t[o], o, a, r, t, n, s);
      }
    }
    r.pop();
  }
}
function M4(t) {
  return t = typeof t < "u" ? t : function(A, e) {
    return e;
  }, function(A, e) {
    if (Zg.length > 0)
      for (var r = 0; r < Zg.length; r++) {
        var i = Zg[r];
        if (i[1] === A && i[0] === e) {
          e = i[2], Zg.splice(r, 1);
          break;
        }
      }
    return t.call(this, A, e);
  };
}
function kk(t, A) {
  const e = VL(), r = A ?? ZL(), i = t.extra ?? {}, n = i.metadata;
  return t.extra = {
    ...i,
    runtime: {
      ...e,
      ...i == null ? void 0 : i.runtime
    },
    metadata: {
      ...r,
      ...r.revision_id || "revision_id" in t && t.revision_id ? {
        revision_id: ("revision_id" in t ? t.revision_id : void 0) ?? r.revision_id
      } : {},
      ...n
    }
  }, t;
}
const _4 = (t) => {
  const A = (t == null ? void 0 : t.toString()) ?? dr("TRACING_SAMPLING_RATE");
  if (A === void 0)
    return;
  const e = parseFloat(A);
  if (e < 0 || e > 1)
    throw new Error(`LANGSMITH_TRACING_SAMPLING_RATE must be between 0 and 1 if set. Got: ${e}`);
  return e;
}, N4 = (t) => {
  const e = t.replace("http://", "").replace("https://", "").split("/")[0].split(":")[0];
  return e === "localhost" || e === "127.0.0.1" || e === "::1";
};
async function L4(t) {
  const A = [];
  for await (const e of t)
    A.push(e);
  return A;
}
function dh(t) {
  if (t !== void 0)
    return t.trim().replace(/^"(.*)"$/, "$1").replace(/^'(.*)'$/, "$1");
}
const x4 = async (t) => {
  if ((t == null ? void 0 : t.status) === 429) {
    const A = parseInt(t.headers.get("retry-after") ?? "10", 10) * 1e3;
    if (A > 0)
      return await new Promise((e) => setTimeout(e, A)), !0;
  }
  return !1;
};
function vk(t) {
  return typeof t == "number" ? Number(t.toFixed(4)) : t;
}
const G4 = 24 * 1024 * 1024, Cx = 1024 * 1024 * 1024, U4 = 1e4, T4 = 100, Rk = "https://api.smith.langchain.com";
class K4 {
  constructor(A) {
    Object.defineProperty(this, "items", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "sizeBytes", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "maxSizeBytes", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.maxSizeBytes = A ?? Cx;
  }
  peek() {
    return this.items[0];
  }
  push(A) {
    let e;
    const r = new Promise((n) => {
      e = n;
    }), i = Fr(A.item, `Serializing run with id: ${A.item.id}`).length;
    return this.sizeBytes + i > this.maxSizeBytes && this.items.length > 0 ? (console.warn(`AutoBatchQueue size limit (${this.maxSizeBytes} bytes) exceeded. Dropping run with id: ${A.item.id}. Current queue size: ${this.sizeBytes} bytes, attempted addition: ${i} bytes.`), e(), r) : (this.items.push({
      action: A.action,
      payload: A.item,
      otelContext: A.otelContext,
      apiKey: A.apiKey,
      apiUrl: A.apiUrl,
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      itemPromiseResolve: e,
      itemPromise: r,
      size: i
    }), this.sizeBytes += i, r);
  }
  pop({ upToSizeBytes: A, upToSize: e }) {
    var n;
    if (A < 1)
      throw new Error("Number of bytes to pop off may not be less than 1.");
    const r = [];
    let i = 0;
    for (; i + (((n = this.peek()) == null ? void 0 : n.size) ?? 0) < A && this.items.length > 0 && r.length < e; ) {
      const s = this.items.shift();
      s && (r.push(s), i += s.size, this.sizeBytes -= s.size);
    }
    if (r.length === 0 && this.items.length > 0) {
      const s = this.items.shift();
      r.push(s), i += s.size, this.sizeBytes -= s.size;
    }
    return [
      r.map((s) => ({
        action: s.action,
        item: s.payload,
        otelContext: s.otelContext,
        apiKey: s.apiKey,
        apiUrl: s.apiUrl,
        size: s.size
      })),
      () => r.forEach((s) => s.itemPromiseResolve())
    ];
  }
}
let lx = class jw {
  get _fetch() {
    return this.fetchImplementation || qO(this.debug);
  }
  constructor(A = {}) {
    var i;
    Object.defineProperty(this, "apiKey", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "apiUrl", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "webUrl", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "workspaceId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "caller", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "batchIngestCaller", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "timeout_ms", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_tenantId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: null
    }), Object.defineProperty(this, "hideInputs", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "hideOutputs", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "tracingSampleRate", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "filteredPostUuids", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: /* @__PURE__ */ new Set()
    }), Object.defineProperty(this, "autoBatchTracing", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "autoBatchQueue", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "autoBatchTimeout", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "autoBatchAggregationDelayMs", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 250
    }), Object.defineProperty(this, "batchSizeBytesLimit", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "batchSizeLimit", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "fetchOptions", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "settings", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "blockOnRootRunFinalization", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: pn("LANGSMITH_TRACING_BACKGROUND") === "false"
    }), Object.defineProperty(this, "traceBatchConcurrency", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 5
    }), Object.defineProperty(this, "_serverInfo", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_getServerInfoPromise", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "manualFlushMode", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "langSmithToOTELTranslator", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "fetchImplementation", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "cachedLSEnvVarsForMetadata", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "multipartStreamingDisabled", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "debug", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: pn("LANGSMITH_DEBUG") === "true"
    });
    const e = jw.getDefaultClientConfig();
    if (this.tracingSampleRate = _4(A.tracingSamplingRate), this.apiUrl = dh(A.apiUrl ?? e.apiUrl) ?? "", this.apiUrl.endsWith("/") && (this.apiUrl = this.apiUrl.slice(0, -1)), this.apiKey = dh(A.apiKey ?? e.apiKey), this.webUrl = dh(A.webUrl ?? e.webUrl), (i = this.webUrl) != null && i.endsWith("/") && (this.webUrl = this.webUrl.slice(0, -1)), this.workspaceId = dh(A.workspaceId ?? dr("WORKSPACE_ID")), this.timeout_ms = A.timeout_ms ?? 9e4, this.caller = new nk({
      ...A.callerOptions ?? {},
      maxRetries: 4,
      debug: A.debug ?? this.debug
    }), this.traceBatchConcurrency = A.traceBatchConcurrency ?? this.traceBatchConcurrency, this.traceBatchConcurrency < 1)
      throw new Error("Trace batch concurrency must be positive.");
    this.debug = A.debug ?? this.debug, this.fetchImplementation = A.fetchImplementation;
    const r = A.maxIngestMemoryBytes ?? Cx;
    this.batchIngestCaller = new nk({
      maxRetries: 4,
      maxConcurrency: this.traceBatchConcurrency,
      maxQueueSizeBytes: r,
      ...A.callerOptions ?? {},
      onFailedResponseHook: x4,
      debug: A.debug ?? this.debug
    }), this.hideInputs = A.hideInputs ?? A.anonymizer ?? e.hideInputs, this.hideOutputs = A.hideOutputs ?? A.anonymizer ?? e.hideOutputs, this.autoBatchTracing = A.autoBatchTracing ?? this.autoBatchTracing, this.autoBatchQueue = new K4(r), this.blockOnRootRunFinalization = A.blockOnRootRunFinalization ?? this.blockOnRootRunFinalization, this.batchSizeBytesLimit = A.batchSizeBytesLimit, this.batchSizeLimit = A.batchSizeLimit, this.fetchOptions = A.fetchOptions || {}, this.manualFlushMode = A.manualFlushMode ?? this.manualFlushMode, XL() && (this.langSmithToOTELTranslator = new c2()), this.cachedLSEnvVarsForMetadata = ZL();
  }
  static getDefaultClientConfig() {
    const A = dr("API_KEY"), e = dr("ENDPOINT") ?? Rk, r = dr("HIDE_INPUTS") === "true", i = dr("HIDE_OUTPUTS") === "true";
    return {
      apiUrl: e,
      apiKey: A,
      webUrl: void 0,
      hideInputs: r,
      hideOutputs: i
    };
  }
  getHostUrl() {
    return this.webUrl ? this.webUrl : N4(this.apiUrl) ? (this.webUrl = "http://localhost:3000", this.webUrl) : this.apiUrl.endsWith("/api/v1") ? (this.webUrl = this.apiUrl.replace("/api/v1", ""), this.webUrl) : this.apiUrl.includes("/api") && !this.apiUrl.split(".", 1)[0].endsWith("api") ? (this.webUrl = this.apiUrl.replace("/api", ""), this.webUrl) : this.apiUrl.split(".", 1)[0].includes("dev") ? (this.webUrl = "https://dev.smith.langchain.com", this.webUrl) : this.apiUrl.split(".", 1)[0].includes("eu") ? (this.webUrl = "https://eu.smith.langchain.com", this.webUrl) : this.apiUrl.split(".", 1)[0].includes("beta") ? (this.webUrl = "https://beta.smith.langchain.com", this.webUrl) : (this.webUrl = "https://smith.langchain.com", this.webUrl);
  }
  get headers() {
    const A = {
      "User-Agent": `langsmith-js/${qL}`
    };
    return this.apiKey && (A["x-api-key"] = `${this.apiKey}`), this.workspaceId && (A["x-tenant-id"] = this.workspaceId), A;
  }
  _getPlatformEndpointPath(A) {
    return this.apiUrl.slice(-3) !== "/v1" && this.apiUrl.slice(-4) !== "/v1/" ? `/v1/platform/${A}` : `/platform/${A}`;
  }
  async processInputs(A) {
    return this.hideInputs === !1 ? A : this.hideInputs === !0 ? {} : typeof this.hideInputs == "function" ? this.hideInputs(A) : A;
  }
  async processOutputs(A) {
    return this.hideOutputs === !1 ? A : this.hideOutputs === !0 ? {} : typeof this.hideOutputs == "function" ? this.hideOutputs(A) : A;
  }
  async prepareRunCreateOrUpdateInputs(A) {
    const e = { ...A };
    return e.inputs !== void 0 && (e.inputs = await this.processInputs(e.inputs)), e.outputs !== void 0 && (e.outputs = await this.processOutputs(e.outputs)), e;
  }
  async _getResponse(A, e) {
    const r = (e == null ? void 0 : e.toString()) ?? "", i = `${this.apiUrl}${A}?${r}`;
    return await this.caller.call(async () => {
      const s = await this._fetch(i, {
        method: "GET",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      return await OA(s, `fetch ${A}`), s;
    });
  }
  async _get(A, e) {
    return (await this._getResponse(A, e)).json();
  }
  async *_getPaginated(A, e = new URLSearchParams(), r) {
    let i = Number(e.get("offset")) || 0;
    const n = Number(e.get("limit")) || 100;
    for (; ; ) {
      e.set("offset", String(i)), e.set("limit", String(n));
      const s = `${this.apiUrl}${A}?${e}`, a = await this.caller.call(async () => {
        const o = await this._fetch(s, {
          method: "GET",
          headers: this.headers,
          signal: AbortSignal.timeout(this.timeout_ms),
          ...this.fetchOptions
        });
        return await OA(o, `fetch ${A}`), o;
      }), g = r ? r(await a.json()) : await a.json();
      if (g.length === 0 || (yield g, g.length < n))
        break;
      i += g.length;
    }
  }
  async *_getCursorPaginatedList(A, e = null, r = "POST", i = "runs") {
    const n = e ? { ...e } : {};
    for (; ; ) {
      const s = JSON.stringify(n), g = await (await this.caller.call(async () => {
        const u = await this._fetch(`${this.apiUrl}${A}`, {
          method: r,
          headers: { ...this.headers, "Content-Type": "application/json" },
          signal: AbortSignal.timeout(this.timeout_ms),
          ...this.fetchOptions,
          body: s
        });
        return await OA(u, `fetch ${A}`), u;
      })).json();
      if (!g || !g[i])
        break;
      yield g[i];
      const o = g.cursors;
      if (!o || !o.next)
        break;
      n.cursor = o.next;
    }
  }
  // Allows mocking for tests
  _shouldSample() {
    return this.tracingSampleRate === void 0 ? !0 : Math.random() < this.tracingSampleRate;
  }
  _filterForSampling(A, e = !1) {
    if (this.tracingSampleRate === void 0)
      return A;
    if (e) {
      const r = [];
      for (const i of A)
        this.filteredPostUuids.has(i.trace_id) ? i.id === i.trace_id && this.filteredPostUuids.delete(i.trace_id) : r.push(i);
      return r;
    } else {
      const r = [];
      for (const i of A) {
        const n = i.trace_id ?? i.id;
        this.filteredPostUuids.has(n) || (i.id === n ? this._shouldSample() ? r.push(i) : this.filteredPostUuids.add(n) : r.push(i));
      }
      return r;
    }
  }
  async _getBatchSizeLimitBytes() {
    var e;
    const A = await this._ensureServerInfo();
    return this.batchSizeBytesLimit ?? ((e = A.batch_ingest_config) == null ? void 0 : e.size_limit_bytes) ?? G4;
  }
  /**
   * Get the maximum number of operations to batch in a single request.
   */
  async _getBatchSizeLimit() {
    var e;
    const A = await this._ensureServerInfo();
    return this.batchSizeLimit ?? ((e = A.batch_ingest_config) == null ? void 0 : e.size_limit) ?? T4;
  }
  async _getDatasetExamplesMultiPartSupport() {
    var e;
    return ((e = (await this._ensureServerInfo()).instance_flags) == null ? void 0 : e.dataset_examples_multipart_enabled) ?? !1;
  }
  drainAutoBatchQueue({ batchSizeLimitBytes: A, batchSizeLimit: e }) {
    const r = [];
    for (; this.autoBatchQueue.items.length > 0; ) {
      const [i, n] = this.autoBatchQueue.pop({
        upToSizeBytes: A,
        upToSize: e
      });
      if (!i.length) {
        n();
        break;
      }
      const s = i.reduce((o, u) => {
        const I = u.apiUrl ?? this.apiUrl, c = u.apiKey ?? this.apiKey, E = u.apiKey === this.apiKey && u.apiUrl === this.apiUrl ? "default" : `${I}|${c}`;
        return o[E] || (o[E] = []), o[E].push(u), o;
      }, {}), a = [];
      for (const [o, u] of Object.entries(s)) {
        const I = this._processBatch(u, {
          apiUrl: o === "default" ? void 0 : o.split("|")[0],
          apiKey: o === "default" ? void 0 : o.split("|")[1]
        });
        a.push(I);
      }
      const g = Promise.all(a).finally(n);
      r.push(g);
    }
    return Promise.all(r);
  }
  async _processBatch(A, e) {
    var i, n;
    if (!A.length)
      return;
    const r = A.reduce((s, a) => s + (a.size ?? 0), 0);
    try {
      if (this.langSmithToOTELTranslator !== void 0)
        this._sendBatchToOTELTranslator(A);
      else {
        const s = {
          runCreates: A.filter((g) => g.action === "create").map((g) => g.item),
          runUpdates: A.filter((g) => g.action === "update").map((g) => g.item)
        }, a = await this._ensureServerInfo();
        if ((i = a == null ? void 0 : a.batch_ingest_config) != null && i.use_multipart_endpoint) {
          const g = (n = a == null ? void 0 : a.instance_flags) == null ? void 0 : n.gzip_body_enabled;
          await this.multipartIngestRuns(s, {
            ...e,
            useGzip: g,
            sizeBytes: r
          });
        } else
          await this.batchIngestRuns(s, {
            ...e,
            sizeBytes: r
          });
      }
    } catch (s) {
      console.error("Error exporting batch:", s);
    }
  }
  _sendBatchToOTELTranslator(A) {
    if (this.langSmithToOTELTranslator !== void 0) {
      const e = /* @__PURE__ */ new Map(), r = [];
      for (const i of A)
        i.item.id && i.otelContext && (e.set(i.item.id, i.otelContext), i.action === "create" ? r.push({
          operation: "post",
          id: i.item.id,
          trace_id: i.item.trace_id ?? i.item.id,
          run: i.item
        }) : r.push({
          operation: "patch",
          id: i.item.id,
          trace_id: i.item.trace_id ?? i.item.id,
          run: i.item
        }));
      this.langSmithToOTELTranslator.exportBatch(r, e);
    }
  }
  async processRunOperation(A) {
    clearTimeout(this.autoBatchTimeout), this.autoBatchTimeout = void 0, A.item = kk(A.item, this.cachedLSEnvVarsForMetadata);
    const e = this.autoBatchQueue.push(A);
    if (this.manualFlushMode)
      return e;
    const r = await this._getBatchSizeLimitBytes(), i = await this._getBatchSizeLimit();
    return (this.autoBatchQueue.sizeBytes > r || this.autoBatchQueue.items.length > i) && this.drainAutoBatchQueue({
      batchSizeLimitBytes: r,
      batchSizeLimit: i
    }), this.autoBatchQueue.items.length > 0 && (this.autoBatchTimeout = setTimeout(() => {
      this.autoBatchTimeout = void 0, this.drainAutoBatchQueue({
        batchSizeLimitBytes: r,
        batchSizeLimit: i
      });
    }, this.autoBatchAggregationDelayMs)), e;
  }
  async _getServerInfo() {
    const e = await (await this.caller.call(async () => {
      const r = await this._fetch(`${this.apiUrl}/info`, {
        method: "GET",
        headers: { Accept: "application/json" },
        signal: AbortSignal.timeout(U4),
        ...this.fetchOptions
      });
      return await OA(r, "get server info"), r;
    })).json();
    return this.debug && console.log(`
=== LangSmith Server Configuration ===
` + JSON.stringify(e, null, 2) + `
`), e;
  }
  async _ensureServerInfo() {
    return this._getServerInfoPromise === void 0 && (this._getServerInfoPromise = (async () => {
      if (this._serverInfo === void 0)
        try {
          this._serverInfo = await this._getServerInfo();
        } catch (A) {
          console.warn(`[LANGSMITH]: Failed to fetch info on supported operations. Falling back to batch operations and default limits. Info: ${A.status ?? "Unspecified status code"} ${A.message}`);
        }
      return this._serverInfo ?? {};
    })()), this._getServerInfoPromise.then((A) => (this._serverInfo === void 0 && (this._getServerInfoPromise = void 0), A));
  }
  async _getSettings() {
    return this.settings || (this.settings = this._get("/settings")), await this.settings;
  }
  /**
   * Flushes current queued traces.
   */
  async flush() {
    const A = await this._getBatchSizeLimitBytes(), e = await this._getBatchSizeLimit();
    await this.drainAutoBatchQueue({
      batchSizeLimitBytes: A,
      batchSizeLimit: e
    });
  }
  _cloneCurrentOTELContext() {
    const A = zL(), e = a2();
    if (this.langSmithToOTELTranslator !== void 0) {
      const r = A.getActiveSpan();
      if (r)
        return A.setSpan(e.active(), r);
    }
  }
  async createRun(A, e) {
    if (!this._filterForSampling([A]).length)
      return;
    const r = {
      ...this.headers,
      "Content-Type": "application/json"
    }, i = A.project_name;
    delete A.project_name;
    const n = await this.prepareRunCreateOrUpdateInputs({
      session_name: i,
      ...A,
      start_time: A.start_time ?? Date.now()
    });
    if (this.autoBatchTracing && n.trace_id !== void 0 && n.dotted_order !== void 0) {
      const g = this._cloneCurrentOTELContext();
      this.processRunOperation({
        action: "create",
        item: n,
        otelContext: g,
        apiKey: e == null ? void 0 : e.apiKey,
        apiUrl: e == null ? void 0 : e.apiUrl
      }).catch(console.error);
      return;
    }
    const s = kk(n, this.cachedLSEnvVarsForMetadata);
    (e == null ? void 0 : e.apiKey) !== void 0 && (r["x-api-key"] = e.apiKey), (e == null ? void 0 : e.workspaceId) !== void 0 && (r["x-tenant-id"] = e.workspaceId);
    const a = Fr(s, `Creating run with id: ${s.id}`);
    await this.caller.call(async () => {
      const g = await this._fetch(`${(e == null ? void 0 : e.apiUrl) ?? this.apiUrl}/runs`, {
        method: "POST",
        headers: r,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: a
      });
      return await OA(g, "create run", !0), g;
    });
  }
  /**
   * Batch ingest/upsert multiple runs in the Langsmith system.
   * @param runs
   */
  async batchIngestRuns({ runCreates: A, runUpdates: e }, r) {
    if (A === void 0 && e === void 0)
      return;
    let i = await Promise.all((A == null ? void 0 : A.map((g) => this.prepareRunCreateOrUpdateInputs(g))) ?? []), n = await Promise.all((e == null ? void 0 : e.map((g) => this.prepareRunCreateOrUpdateInputs(g))) ?? []);
    if (i.length > 0 && n.length > 0) {
      const g = i.reduce((u, I) => (I.id && (u[I.id] = I), u), {}), o = [];
      for (const u of n)
        u.id !== void 0 && g[u.id] ? g[u.id] = {
          ...g[u.id],
          ...u
        } : o.push(u);
      i = Object.values(g), n = o;
    }
    const s = {
      post: i,
      patch: n
    };
    if (!s.post.length && !s.patch.length)
      return;
    const a = {
      post: [],
      patch: []
    };
    for (const g of ["post", "patch"]) {
      const o = g, u = s[o].reverse();
      let I = u.pop();
      for (; I !== void 0; )
        a[o].push(I), I = u.pop();
    }
    if (a.post.length > 0 || a.patch.length > 0) {
      const g = a.post.map((o) => o.id).concat(a.patch.map((o) => o.id)).join(",");
      await this._postBatchIngestRuns(Fr(a, `Ingesting runs with ids: ${g}`), r);
    }
  }
  async _postBatchIngestRuns(A, e) {
    const r = {
      ...this.headers,
      "Content-Type": "application/json",
      Accept: "application/json"
    };
    (e == null ? void 0 : e.apiKey) !== void 0 && (r["x-api-key"] = e.apiKey), await this.batchIngestCaller.callWithOptions({ sizeBytes: e == null ? void 0 : e.sizeBytes }, async () => {
      const i = await this._fetch(`${(e == null ? void 0 : e.apiUrl) ?? this.apiUrl}/runs/batch`, {
        method: "POST",
        headers: r,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: A
      });
      return await OA(i, "batch create run", !0), i;
    });
  }
  /**
   * Batch ingest/upsert multiple runs in the Langsmith system.
   * @param runs
   */
  async multipartIngestRuns({ runCreates: A, runUpdates: e }, r) {
    if (A === void 0 && e === void 0)
      return;
    const i = {};
    let n = [];
    for (const I of A ?? []) {
      const c = await this.prepareRunCreateOrUpdateInputs(I);
      c.id !== void 0 && c.attachments !== void 0 && (i[c.id] = c.attachments), delete c.attachments, n.push(c);
    }
    let s = [];
    for (const I of e ?? [])
      s.push(await this.prepareRunCreateOrUpdateInputs(I));
    if (n.find((I) => I.trace_id === void 0 || I.dotted_order === void 0) !== void 0)
      throw new Error('Multipart ingest requires "trace_id" and "dotted_order" to be set when creating a run');
    if (s.find((I) => I.trace_id === void 0 || I.dotted_order === void 0) !== void 0)
      throw new Error('Multipart ingest requires "trace_id" and "dotted_order" to be set when updating a run');
    if (n.length > 0 && s.length > 0) {
      const I = n.reduce((C, E) => (E.id && (C[E.id] = E), C), {}), c = [];
      for (const C of s)
        C.id !== void 0 && I[C.id] ? I[C.id] = {
          ...I[C.id],
          ...C
        } : c.push(C);
      n = Object.values(I), s = c;
    }
    if (n.length === 0 && s.length === 0)
      return;
    const o = [], u = [];
    for (const [I, c] of [
      ["post", n],
      ["patch", s]
    ])
      for (const C of c) {
        const { inputs: E, outputs: l, events: B, extra: h, error: Q, serialized: f, attachments: p, ...y } = C, m = { inputs: E, outputs: l, events: B, extra: h, error: Q, serialized: f }, S = Fr(y, `Serializing for multipart ingestion of run with id: ${y.id}`);
        u.push({
          name: `${I}.${y.id}`,
          payload: new Blob([S], {
            type: `application/json; length=${S.length}`
            // encoding=gzip
          })
        });
        for (const [w, F] of Object.entries(m)) {
          if (F === void 0)
            continue;
          const b = Fr(F, `Serializing ${w} for multipart ingestion of run with id: ${y.id}`);
          u.push({
            name: `${I}.${y.id}.${w}`,
            payload: new Blob([b], {
              type: `application/json; length=${b.length}`
            })
          });
        }
        if (y.id !== void 0) {
          const w = i[y.id];
          if (w) {
            delete i[y.id];
            for (const [F, b] of Object.entries(w)) {
              let G, T;
              if (Array.isArray(b) ? [G, T] = b : (G = b.mimeType, T = b.data), F.includes(".")) {
                console.warn(`Skipping attachment '${F}' for run ${y.id}: Invalid attachment name. Attachment names must not contain periods ('.'). Please rename the attachment and try again.`);
                continue;
              }
              u.push({
                name: `attachment.${y.id}.${F}`,
                payload: new Blob([T], {
                  type: `${G}; length=${T.byteLength}`
                })
              });
            }
          }
        }
        o.push(`trace=${y.trace_id},id=${y.id}`);
      }
    await this._sendMultipartRequest(u, o.join("; "), r);
  }
  async _createNodeFetchBody(A, e) {
    const r = [];
    for (const s of A)
      r.push(new Blob([`--${e}\r
`])), r.push(new Blob([
        `Content-Disposition: form-data; name="${s.name}"\r
`,
        `Content-Type: ${s.payload.type}\r
\r
`
      ])), r.push(s.payload), r.push(new Blob([`\r
`]));
    return r.push(new Blob([`--${e}--\r
`])), await new Blob(r).arrayBuffer();
  }
  async _createMultipartStream(A, e) {
    const r = new TextEncoder();
    return new ReadableStream({
      async start(n) {
        const s = async (a) => {
          typeof a == "string" ? n.enqueue(r.encode(a)) : n.enqueue(a);
        };
        for (const a of A) {
          await s(`--${e}\r
`), await s(`Content-Disposition: form-data; name="${a.name}"\r
`), await s(`Content-Type: ${a.payload.type}\r
\r
`);
          const o = a.payload.stream().getReader();
          try {
            let u;
            for (; !(u = await o.read()).done; )
              n.enqueue(u.value);
          } finally {
            o.releaseLock();
          }
          await s(`\r
`);
        }
        await s(`--${e}--\r
`), n.close();
      }
    });
  }
  async _sendMultipartRequest(A, e, r) {
    const i = "----LangSmithFormBoundary" + Math.random().toString(36).slice(2), n = YO(), s = () => this._createNodeFetchBody(A, i), a = () => this._createMultipartStream(A, i), g = async (o) => this.batchIngestCaller.callWithOptions({ sizeBytes: r == null ? void 0 : r.sizeBytes }, async () => {
      const u = await o(), I = {
        ...this.headers,
        "Content-Type": `multipart/form-data; boundary=${i}`
      };
      (r == null ? void 0 : r.apiKey) !== void 0 && (I["x-api-key"] = r.apiKey);
      let c = u;
      r != null && r.useGzip && typeof u == "object" && "pipeThrough" in u && (c = u.pipeThrough(new CompressionStream("gzip")), I["Content-Encoding"] = "gzip");
      const C = await this._fetch(`${(r == null ? void 0 : r.apiUrl) ?? this.apiUrl}/runs/multipart`, {
        method: "POST",
        headers: I,
        body: c,
        duplex: "half",
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      return await OA(C, "Failed to send multipart request", !0), C;
    });
    try {
      let o, u = !1;
      !n && !this.multipartStreamingDisabled && WL() !== "bun" ? (u = !0, o = await g(a)) : o = await g(s), (!this.multipartStreamingDisabled || u) && o.status === 422 && ((r == null ? void 0 : r.apiUrl) ?? this.apiUrl) !== Rk && (console.warn(`Streaming multipart upload to ${(r == null ? void 0 : r.apiUrl) ?? this.apiUrl}/runs/multipart failed. This usually means the host does not support chunked uploads. Retrying with a buffered upload for operation "${e}".`), this.multipartStreamingDisabled = !0, o = await g(s));
    } catch (o) {
      console.warn(`${o.message.trim()}

Context: ${e}`);
    }
  }
  async updateRun(A, e, r) {
    te(A), e.inputs && (e.inputs = await this.processInputs(e.inputs)), e.outputs && (e.outputs = await this.processOutputs(e.outputs));
    const i = { ...e, id: A };
    if (!this._filterForSampling([i], !0).length)
      return;
    if (this.autoBatchTracing && i.trace_id !== void 0 && i.dotted_order !== void 0) {
      const a = this._cloneCurrentOTELContext();
      if (e.end_time !== void 0 && i.parent_run_id === void 0 && this.blockOnRootRunFinalization && !this.manualFlushMode) {
        await this.processRunOperation({
          action: "update",
          item: i,
          otelContext: a,
          apiKey: r == null ? void 0 : r.apiKey,
          apiUrl: r == null ? void 0 : r.apiUrl
        }).catch(console.error);
        return;
      } else
        this.processRunOperation({
          action: "update",
          item: i,
          otelContext: a,
          apiKey: r == null ? void 0 : r.apiKey,
          apiUrl: r == null ? void 0 : r.apiUrl
        }).catch(console.error);
      return;
    }
    const n = {
      ...this.headers,
      "Content-Type": "application/json"
    };
    (r == null ? void 0 : r.apiKey) !== void 0 && (n["x-api-key"] = r.apiKey), (r == null ? void 0 : r.workspaceId) !== void 0 && (n["x-tenant-id"] = r.workspaceId);
    const s = Fr(e, `Serializing payload to update run with id: ${A}`);
    await this.caller.call(async () => {
      const a = await this._fetch(`${(r == null ? void 0 : r.apiUrl) ?? this.apiUrl}/runs/${A}`, {
        method: "PATCH",
        headers: n,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: s
      });
      return await OA(a, "update run", !0), a;
    });
  }
  async readRun(A, { loadChildRuns: e } = { loadChildRuns: !1 }) {
    te(A);
    let r = await this._get(`/runs/${A}`);
    return e && (r = await this._loadChildRuns(r)), r;
  }
  async getRunUrl({ runId: A, run: e, projectOpts: r }) {
    if (e !== void 0) {
      let i;
      e.session_id ? i = e.session_id : r != null && r.projectName ? i = (await this.readProject({ projectName: r == null ? void 0 : r.projectName })).id : r != null && r.projectId ? i = r == null ? void 0 : r.projectId : i = (await this.readProject({
        projectName: dr("PROJECT") || "default"
      })).id;
      const n = await this._getTenantId();
      return `${this.getHostUrl()}/o/${n}/projects/p/${i}/r/${e.id}?poll=true`;
    } else if (A !== void 0) {
      const i = await this.readRun(A);
      if (!i.app_path)
        throw new Error(`Run ${A} has no app_path`);
      return `${this.getHostUrl()}${i.app_path}`;
    } else
      throw new Error("Must provide either runId or run");
  }
  async _loadChildRuns(A) {
    var n;
    const e = await L4(this.listRuns({
      isRoot: !1,
      projectId: A.session_id,
      traceId: A.trace_id
    })), r = {}, i = {};
    e.sort((s, a) => ((s == null ? void 0 : s.dotted_order) ?? "").localeCompare((a == null ? void 0 : a.dotted_order) ?? ""));
    for (const s of e) {
      if (s.parent_run_id === null || s.parent_run_id === void 0)
        throw new Error(`Child run ${s.id} has no parent`);
      (n = s.dotted_order) != null && n.startsWith(A.dotted_order ?? "") && s.id !== A.id && (s.parent_run_id in r || (r[s.parent_run_id] = []), r[s.parent_run_id].push(s), i[s.id] = s);
    }
    A.child_runs = r[A.id] || [];
    for (const s in r)
      s !== A.id && (i[s].child_runs = r[s]);
    return A;
  }
  /**
   * List runs from the LangSmith server.
   * @param projectId - The ID of the project to filter by.
   * @param projectName - The name of the project to filter by.
   * @param parentRunId - The ID of the parent run to filter by.
   * @param traceId - The ID of the trace to filter by.
   * @param referenceExampleId - The ID of the reference example to filter by.
   * @param startTime - The start time to filter by.
   * @param isRoot - Indicates whether to only return root runs.
   * @param runType - The run type to filter by.
   * @param error - Indicates whether to filter by error runs.
   * @param id - The ID of the run to filter by.
   * @param query - The query string to filter by.
   * @param filter - The filter string to apply to the run spans.
   * @param traceFilter - The filter string to apply on the root run of the trace.
   * @param treeFilter - The filter string to apply on other runs in the trace.
   * @param limit - The maximum number of runs to retrieve.
   * @returns {AsyncIterable<Run>} - The runs.
   *
   * @example
   * // List all runs in a project
   * const projectRuns = client.listRuns({ projectName: "<your_project>" });
   *
   * @example
   * // List LLM and Chat runs in the last 24 hours
   * const todaysLLMRuns = client.listRuns({
   *   projectName: "<your_project>",
   *   start_time: new Date(Date.now() - 24 * 60 * 60 * 1000),
   *   run_type: "llm",
   * });
   *
   * @example
   * // List traces in a project
   * const rootRuns = client.listRuns({
   *   projectName: "<your_project>",
   *   execution_order: 1,
   * });
   *
   * @example
   * // List runs without errors
   * const correctRuns = client.listRuns({
   *   projectName: "<your_project>",
   *   error: false,
   * });
   *
   * @example
   * // List runs by run ID
   * const runIds = [
   *   "a36092d2-4ad5-4fb4-9c0d-0dba9a2ed836",
   *   "9398e6be-964f-4aa4-8ae9-ad78cd4b7074",
   * ];
   * const selectedRuns = client.listRuns({ run_ids: runIds });
   *
   * @example
   * // List all "chain" type runs that took more than 10 seconds and had `total_tokens` greater than 5000
   * const chainRuns = client.listRuns({
   *   projectName: "<your_project>",
   *   filter: 'and(eq(run_type, "chain"), gt(latency, 10), gt(total_tokens, 5000))',
   * });
   *
   * @example
   * // List all runs called "extractor" whose root of the trace was assigned feedback "user_score" score of 1
   * const goodExtractorRuns = client.listRuns({
   *   projectName: "<your_project>",
   *   filter: 'eq(name, "extractor")',
   *   traceFilter: 'and(eq(feedback_key, "user_score"), eq(feedback_score, 1))',
   * });
   *
   * @example
   * // List all runs that started after a specific timestamp and either have "error" not equal to null or a "Correctness" feedback score equal to 0
   * const complexRuns = client.listRuns({
   *   projectName: "<your_project>",
   *   filter: 'and(gt(start_time, "2023-07-15T12:34:56Z"), or(neq(error, null), and(eq(feedback_key, "Correctness"), eq(feedback_score, 0.0))))',
   * });
   *
   * @example
   * // List all runs where `tags` include "experimental" or "beta" and `latency` is greater than 2 seconds
   * const taggedRuns = client.listRuns({
   *   projectName: "<your_project>",
   *   filter: 'and(or(has(tags, "experimental"), has(tags, "beta")), gt(latency, 2))',
   * });
   */
  async *listRuns(A) {
    const { projectId: e, projectName: r, parentRunId: i, traceId: n, referenceExampleId: s, startTime: a, executionOrder: g, isRoot: o, runType: u, error: I, id: c, query: C, filter: E, traceFilter: l, treeFilter: B, limit: h, select: Q, order: f } = A;
    let p = [];
    if (e && (p = Array.isArray(e) ? e : [e]), r) {
      const w = Array.isArray(r) ? r : [r], F = await Promise.all(w.map((b) => this.readProject({ projectName: b }).then((G) => G.id)));
      p.push(...F);
    }
    const y = [
      "app_path",
      "completion_cost",
      "completion_tokens",
      "dotted_order",
      "end_time",
      "error",
      "events",
      "extra",
      "feedback_stats",
      "first_token_time",
      "id",
      "inputs",
      "name",
      "outputs",
      "parent_run_id",
      "parent_run_ids",
      "prompt_cost",
      "prompt_tokens",
      "reference_example_id",
      "run_type",
      "session_id",
      "start_time",
      "status",
      "tags",
      "total_cost",
      "total_tokens",
      "trace_id"
    ], m = {
      session: p.length ? p : null,
      run_type: u,
      reference_example: s,
      query: C,
      filter: E,
      trace_filter: l,
      tree_filter: B,
      execution_order: g,
      parent_run: i,
      start_time: a ? a.toISOString() : null,
      error: I,
      id: c,
      limit: h,
      trace: n,
      select: Q || y,
      is_root: o,
      order: f
    };
    m.select.includes("child_run_ids") && Ow("Deprecated: 'child_run_ids' in the listRuns select parameter is deprecated and will be removed in a future version.");
    let S = 0;
    for await (const w of this._getCursorPaginatedList("/runs/query", m))
      if (h) {
        if (S >= h)
          break;
        if (w.length + S > h) {
          yield* w.slice(0, h - S);
          break;
        }
        S += w.length, yield* w;
      } else
        yield* w;
  }
  async *listGroupRuns(A) {
    const { projectId: e, projectName: r, groupBy: i, filter: n, startTime: s, endTime: a, limit: g, offset: o } = A, I = {
      session_id: e || (await this.readProject({ projectName: r })).id,
      group_by: i,
      filter: n,
      start_time: s ? s.toISOString() : null,
      end_time: a ? a.toISOString() : null,
      limit: Number(g) || 100
    };
    let c = Number(o) || 0;
    const C = "/runs/group", E = `${this.apiUrl}${C}`;
    for (; ; ) {
      const l = {
        ...I,
        offset: c
      }, B = Object.fromEntries(Object.entries(l).filter(([m, S]) => S !== void 0)), h = JSON.stringify(B), f = await (await this.caller.call(async () => {
        const m = await this._fetch(E, {
          method: "POST",
          headers: { ...this.headers, "Content-Type": "application/json" },
          signal: AbortSignal.timeout(this.timeout_ms),
          ...this.fetchOptions,
          body: h
        });
        return await OA(m, `Failed to fetch ${C}`), m;
      })).json(), { groups: p, total: y } = f;
      if (p.length === 0)
        break;
      for (const m of p)
        yield m;
      if (c += p.length, c >= y)
        break;
    }
  }
  async getRunStats({ id: A, trace: e, parentRun: r, runType: i, projectNames: n, projectIds: s, referenceExampleIds: a, startTime: g, endTime: o, error: u, query: I, filter: c, traceFilter: C, treeFilter: E, isRoot: l, dataSourceType: B }) {
    let h = s || [];
    n && (h = [
      ...s || [],
      ...await Promise.all(n.map((S) => this.readProject({ projectName: S }).then((w) => w.id)))
    ]);
    const f = Object.fromEntries(Object.entries({
      id: A,
      trace: e,
      parent_run: r,
      run_type: i,
      session: h,
      reference_example: a,
      start_time: g,
      end_time: o,
      error: u,
      query: I,
      filter: c,
      trace_filter: C,
      tree_filter: E,
      is_root: l,
      data_source_type: B
    }).filter(([S, w]) => w !== void 0)), p = JSON.stringify(f);
    return await (await this.caller.call(async () => {
      const S = await this._fetch(`${this.apiUrl}/runs/stats`, {
        method: "POST",
        headers: { ...this.headers, "Content-Type": "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: p
      });
      return await OA(S, "get run stats"), S;
    })).json();
  }
  async shareRun(A, { shareId: e } = {}) {
    const r = {
      run_id: A,
      share_token: e || QI()
    };
    te(A);
    const i = JSON.stringify(r), s = await (await this.caller.call(async () => {
      const a = await this._fetch(`${this.apiUrl}/runs/${A}/share`, {
        method: "PUT",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: i
      });
      return await OA(a, "share run"), a;
    })).json();
    if (s === null || !("share_token" in s))
      throw new Error("Invalid response from server");
    return `${this.getHostUrl()}/public/${s.share_token}/r`;
  }
  async unshareRun(A) {
    te(A), await this.caller.call(async () => {
      const e = await this._fetch(`${this.apiUrl}/runs/${A}/share`, {
        method: "DELETE",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      return await OA(e, "unshare run", !0), e;
    });
  }
  async readRunSharedLink(A) {
    te(A);
    const r = await (await this.caller.call(async () => {
      const i = await this._fetch(`${this.apiUrl}/runs/${A}/share`, {
        method: "GET",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      return await OA(i, "read run shared link"), i;
    })).json();
    if (!(r === null || !("share_token" in r)))
      return `${this.getHostUrl()}/public/${r.share_token}/r`;
  }
  async listSharedRuns(A, { runIds: e } = {}) {
    const r = new URLSearchParams({
      share_token: A
    });
    if (e !== void 0)
      for (const s of e)
        r.append("id", s);
    return te(A), await (await this.caller.call(async () => {
      const s = await this._fetch(`${this.apiUrl}/public/${A}/runs${r}`, {
        method: "GET",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      return await OA(s, "list shared runs"), s;
    })).json();
  }
  async readDatasetSharedSchema(A, e) {
    if (!A && !e)
      throw new Error("Either datasetId or datasetName must be given");
    A || (A = (await this.readDataset({ datasetName: e })).id), te(A);
    const i = await (await this.caller.call(async () => {
      const n = await this._fetch(`${this.apiUrl}/datasets/${A}/share`, {
        method: "GET",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      return await OA(n, "read dataset shared schema"), n;
    })).json();
    return i.url = `${this.getHostUrl()}/public/${i.share_token}/d`, i;
  }
  async shareDataset(A, e) {
    if (!A && !e)
      throw new Error("Either datasetId or datasetName must be given");
    A || (A = (await this.readDataset({ datasetName: e })).id);
    const r = {
      dataset_id: A
    };
    te(A);
    const i = JSON.stringify(r), s = await (await this.caller.call(async () => {
      const a = await this._fetch(`${this.apiUrl}/datasets/${A}/share`, {
        method: "PUT",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: i
      });
      return await OA(a, "share dataset"), a;
    })).json();
    return s.url = `${this.getHostUrl()}/public/${s.share_token}/d`, s;
  }
  async unshareDataset(A) {
    te(A), await this.caller.call(async () => {
      const e = await this._fetch(`${this.apiUrl}/datasets/${A}/share`, {
        method: "DELETE",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      return await OA(e, "unshare dataset", !0), e;
    });
  }
  async readSharedDataset(A) {
    return te(A), await (await this.caller.call(async () => {
      const i = await this._fetch(`${this.apiUrl}/public/${A}/datasets`, {
        method: "GET",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      return await OA(i, "read shared dataset"), i;
    })).json();
  }
  /**
   * Get shared examples.
   *
   * @param {string} shareToken The share token to get examples for. A share token is the UUID (or LangSmith URL, including UUID) generated when explicitly marking an example as public.
   * @param {Object} [options] Additional options for listing the examples.
   * @param {string[] | undefined} [options.exampleIds] A list of example IDs to filter by.
   * @returns {Promise<Example[]>} The shared examples.
   */
  async listSharedExamples(A, e) {
    const r = {};
    e != null && e.exampleIds && (r.id = e.exampleIds);
    const i = new URLSearchParams();
    Object.entries(r).forEach(([a, g]) => {
      Array.isArray(g) ? g.forEach((o) => i.append(a, o)) : i.append(a, g);
    });
    const n = await this.caller.call(async () => {
      const a = await this._fetch(`${this.apiUrl}/public/${A}/examples?${i.toString()}`, {
        method: "GET",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      return await OA(a, "list shared examples"), a;
    }), s = await n.json();
    if (!n.ok)
      throw "detail" in s ? new Error(`Failed to list shared examples.
Status: ${n.status}
Message: ${Array.isArray(s.detail) ? s.detail.join(`
`) : "Unspecified error"}`) : new Error(`Failed to list shared examples: ${n.status} ${n.statusText}`);
    return s.map((a) => ({
      ...a,
      _hostUrl: this.getHostUrl()
    }));
  }
  async createProject({ projectName: A, description: e = null, metadata: r = null, upsert: i = !1, projectExtra: n = null, referenceDatasetId: s = null }) {
    const a = i ? "?upsert=true" : "", g = `${this.apiUrl}/sessions${a}`, o = n || {};
    r && (o.metadata = r);
    const u = {
      name: A,
      extra: o,
      description: e
    };
    s !== null && (u.reference_dataset_id = s);
    const I = JSON.stringify(u);
    return await (await this.caller.call(async () => {
      const E = await this._fetch(g, {
        method: "POST",
        headers: { ...this.headers, "Content-Type": "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: I
      });
      return await OA(E, "create project"), E;
    })).json();
  }
  async updateProject(A, { name: e = null, description: r = null, metadata: i = null, projectExtra: n = null, endTime: s = null }) {
    const a = `${this.apiUrl}/sessions/${A}`;
    let g = n;
    i && (g = { ...g || {}, metadata: i });
    const o = JSON.stringify({
      name: e,
      extra: g,
      description: r,
      end_time: s ? new Date(s).toISOString() : null
    });
    return await (await this.caller.call(async () => {
      const c = await this._fetch(a, {
        method: "PATCH",
        headers: { ...this.headers, "Content-Type": "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: o
      });
      return await OA(c, "update project"), c;
    })).json();
  }
  async hasProject({ projectId: A, projectName: e }) {
    let r = "/sessions";
    const i = new URLSearchParams();
    if (A !== void 0 && e !== void 0)
      throw new Error("Must provide either projectName or projectId, not both");
    if (A !== void 0)
      te(A), r += `/${A}`;
    else if (e !== void 0)
      i.append("name", e);
    else
      throw new Error("Must provide projectName or projectId");
    const n = await this.caller.call(async () => {
      const s = await this._fetch(`${this.apiUrl}${r}?${i}`, {
        method: "GET",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      return await OA(s, "has project"), s;
    });
    try {
      const s = await n.json();
      return n.ok ? Array.isArray(s) ? s.length > 0 : !0 : !1;
    } catch {
      return !1;
    }
  }
  async readProject({ projectId: A, projectName: e, includeStats: r }) {
    let i = "/sessions";
    const n = new URLSearchParams();
    if (A !== void 0 && e !== void 0)
      throw new Error("Must provide either projectName or projectId, not both");
    if (A !== void 0)
      te(A), i += `/${A}`;
    else if (e !== void 0)
      n.append("name", e);
    else
      throw new Error("Must provide projectName or projectId");
    r !== void 0 && n.append("include_stats", r.toString());
    const s = await this._get(i, n);
    let a;
    if (Array.isArray(s)) {
      if (s.length === 0)
        throw new Error(`Project[id=${A}, name=${e}] not found`);
      a = s[0];
    } else
      a = s;
    return a;
  }
  async getProjectUrl({ projectId: A, projectName: e }) {
    if (A === void 0 && e === void 0)
      throw new Error("Must provide either projectName or projectId");
    const r = await this.readProject({ projectId: A, projectName: e }), i = await this._getTenantId();
    return `${this.getHostUrl()}/o/${i}/projects/p/${r.id}`;
  }
  async getDatasetUrl({ datasetId: A, datasetName: e }) {
    if (A === void 0 && e === void 0)
      throw new Error("Must provide either datasetName or datasetId");
    const r = await this.readDataset({ datasetId: A, datasetName: e }), i = await this._getTenantId();
    return `${this.getHostUrl()}/o/${i}/datasets/${r.id}`;
  }
  async _getTenantId() {
    if (this._tenantId !== null)
      return this._tenantId;
    const A = new URLSearchParams({ limit: "1" });
    for await (const e of this._getPaginated("/sessions", A))
      return this._tenantId = e[0].tenant_id, e[0].tenant_id;
    throw new Error("No projects found to resolve tenant.");
  }
  async *listProjects({ projectIds: A, name: e, nameContains: r, referenceDatasetId: i, referenceDatasetName: n, includeStats: s, datasetVersion: a, referenceFree: g, metadata: o } = {}) {
    const u = new URLSearchParams();
    if (A !== void 0)
      for (const I of A)
        u.append("id", I);
    if (e !== void 0 && u.append("name", e), r !== void 0 && u.append("name_contains", r), i !== void 0)
      u.append("reference_dataset", i);
    else if (n !== void 0) {
      const I = await this.readDataset({
        datasetName: n
      });
      u.append("reference_dataset", I.id);
    }
    s !== void 0 && u.append("include_stats", s.toString()), a !== void 0 && u.append("dataset_version", a), g !== void 0 && u.append("reference_free", g.toString()), o !== void 0 && u.append("metadata", JSON.stringify(o));
    for await (const I of this._getPaginated("/sessions", u))
      yield* I;
  }
  async deleteProject({ projectId: A, projectName: e }) {
    let r;
    if (A === void 0 && e === void 0)
      throw new Error("Must provide projectName or projectId");
    if (A !== void 0 && e !== void 0)
      throw new Error("Must provide either projectName or projectId, not both");
    A === void 0 ? r = (await this.readProject({ projectName: e })).id : r = A, te(r), await this.caller.call(async () => {
      const i = await this._fetch(`${this.apiUrl}/sessions/${r}`, {
        method: "DELETE",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      return await OA(i, `delete session ${r} (${e})`, !0), i;
    });
  }
  async uploadCsv({ csvFile: A, fileName: e, inputKeys: r, outputKeys: i, description: n, dataType: s, name: a }) {
    const g = `${this.apiUrl}/datasets/upload`, o = new FormData();
    return o.append("file", A, e), r.forEach((c) => {
      o.append("input_keys", c);
    }), i.forEach((c) => {
      o.append("output_keys", c);
    }), n && o.append("description", n), s && o.append("data_type", s), a && o.append("name", a), await (await this.caller.call(async () => {
      const c = await this._fetch(g, {
        method: "POST",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: o
      });
      return await OA(c, "upload CSV"), c;
    })).json();
  }
  async createDataset(A, { description: e, dataType: r, inputsSchema: i, outputsSchema: n, metadata: s } = {}) {
    const a = {
      name: A,
      description: e,
      extra: s ? { metadata: s } : void 0
    };
    r && (a.data_type = r), i && (a.inputs_schema_definition = i), n && (a.outputs_schema_definition = n);
    const g = JSON.stringify(a);
    return await (await this.caller.call(async () => {
      const I = await this._fetch(`${this.apiUrl}/datasets`, {
        method: "POST",
        headers: { ...this.headers, "Content-Type": "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: g
      });
      return await OA(I, "create dataset"), I;
    })).json();
  }
  async readDataset({ datasetId: A, datasetName: e }) {
    let r = "/datasets";
    const i = new URLSearchParams({ limit: "1" });
    if (A && e)
      throw new Error("Must provide either datasetName or datasetId, not both");
    if (A)
      te(A), r += `/${A}`;
    else if (e)
      i.append("name", e);
    else
      throw new Error("Must provide datasetName or datasetId");
    const n = await this._get(r, i);
    let s;
    if (Array.isArray(n)) {
      if (n.length === 0)
        throw new Error(`Dataset[id=${A}, name=${e}] not found`);
      s = n[0];
    } else
      s = n;
    return s;
  }
  async hasDataset({ datasetId: A, datasetName: e }) {
    try {
      return await this.readDataset({ datasetId: A, datasetName: e }), !0;
    } catch (r) {
      if (
        // eslint-disable-next-line no-instanceof/no-instanceof
        r instanceof Error && r.message.toLocaleLowerCase().includes("not found")
      )
        return !1;
      throw r;
    }
  }
  async diffDatasetVersions({ datasetId: A, datasetName: e, fromVersion: r, toVersion: i }) {
    let n = A;
    if (n === void 0 && e === void 0)
      throw new Error("Must provide either datasetName or datasetId");
    if (n !== void 0 && e !== void 0)
      throw new Error("Must provide either datasetName or datasetId, not both");
    n === void 0 && (n = (await this.readDataset({ datasetName: e })).id);
    const s = new URLSearchParams({
      from_version: typeof r == "string" ? r : r.toISOString(),
      to_version: typeof i == "string" ? i : i.toISOString()
    });
    return await this._get(`/datasets/${n}/versions/diff`, s);
  }
  async readDatasetOpenaiFinetuning({ datasetId: A, datasetName: e }) {
    const r = "/datasets";
    if (A === void 0) if (e !== void 0)
      A = (await this.readDataset({ datasetName: e })).id;
    else
      throw new Error("Must provide either datasetName or datasetId");
    return (await (await this._getResponse(`${r}/${A}/openai_ft`)).text()).trim().split(`
`).map((a) => JSON.parse(a));
  }
  async *listDatasets({ limit: A = 100, offset: e = 0, datasetIds: r, datasetName: i, datasetNameContains: n, metadata: s } = {}) {
    const a = "/datasets", g = new URLSearchParams({
      limit: A.toString(),
      offset: e.toString()
    });
    if (r !== void 0)
      for (const o of r)
        g.append("id", o);
    i !== void 0 && g.append("name", i), n !== void 0 && g.append("name_contains", n), s !== void 0 && g.append("metadata", JSON.stringify(s));
    for await (const o of this._getPaginated(a, g))
      yield* o;
  }
  /**
   * Update a dataset
   * @param props The dataset details to update
   * @returns The updated dataset
   */
  async updateDataset(A) {
    const { datasetId: e, datasetName: r, ...i } = A;
    if (!e && !r)
      throw new Error("Must provide either datasetName or datasetId");
    const n = e ?? (await this.readDataset({ datasetName: r })).id;
    te(n);
    const s = JSON.stringify(i);
    return await (await this.caller.call(async () => {
      const g = await this._fetch(`${this.apiUrl}/datasets/${n}`, {
        method: "PATCH",
        headers: { ...this.headers, "Content-Type": "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: s
      });
      return await OA(g, "update dataset"), g;
    })).json();
  }
  /**
   * Updates a tag on a dataset.
   *
   * If the tag is already assigned to a different version of this dataset,
   * the tag will be moved to the new version. The as_of parameter is used to
   * determine which version of the dataset to apply the new tags to.
   *
   * It must be an exact version of the dataset to succeed. You can
   * use the "readDatasetVersion" method to find the exact version
   * to apply the tags to.
   * @param params.datasetId The ID of the dataset to update. Must be provided if "datasetName" is not provided.
   * @param params.datasetName The name of the dataset to update. Must be provided if "datasetId" is not provided.
   * @param params.asOf The timestamp of the dataset to apply the new tags to.
   * @param params.tag The new tag to apply to the dataset.
   */
  async updateDatasetTag(A) {
    const { datasetId: e, datasetName: r, asOf: i, tag: n } = A;
    if (!e && !r)
      throw new Error("Must provide either datasetName or datasetId");
    const s = e ?? (await this.readDataset({ datasetName: r })).id;
    te(s);
    const a = JSON.stringify({
      as_of: typeof i == "string" ? i : i.toISOString(),
      tag: n
    });
    await this.caller.call(async () => {
      const g = await this._fetch(`${this.apiUrl}/datasets/${s}/tags`, {
        method: "PUT",
        headers: { ...this.headers, "Content-Type": "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: a
      });
      return await OA(g, "update dataset tags", !0), g;
    });
  }
  async deleteDataset({ datasetId: A, datasetName: e }) {
    let r = "/datasets", i = A;
    if (A !== void 0 && e !== void 0)
      throw new Error("Must provide either datasetName or datasetId, not both");
    if (e !== void 0 && (i = (await this.readDataset({ datasetName: e })).id), i !== void 0)
      te(i), r += `/${i}`;
    else
      throw new Error("Must provide datasetName or datasetId");
    await this.caller.call(async () => {
      const n = await this._fetch(this.apiUrl + r, {
        method: "DELETE",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      return await OA(n, `delete ${r}`, !0), n;
    });
  }
  async indexDataset({ datasetId: A, datasetName: e, tag: r }) {
    let i = A;
    if (!i && !e)
      throw new Error("Must provide either datasetName or datasetId");
    if (i && e)
      throw new Error("Must provide either datasetName or datasetId, not both");
    i || (i = (await this.readDataset({ datasetName: e })).id), te(i);
    const s = JSON.stringify({
      tag: r
    });
    await (await this.caller.call(async () => {
      const g = await this._fetch(`${this.apiUrl}/datasets/${i}/index`, {
        method: "POST",
        headers: { ...this.headers, "Content-Type": "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: s
      });
      return await OA(g, "index dataset"), g;
    })).json();
  }
  /**
   * Lets you run a similarity search query on a dataset.
   *
   * Requires the dataset to be indexed. Please see the `indexDataset` method to set up indexing.
   *
   * @param inputs      The input on which to run the similarity search. Must have the
   *                    same schema as the dataset.
   *
   * @param datasetId   The dataset to search for similar examples.
   *
   * @param limit       The maximum number of examples to return. Will return the top `limit` most
   *                    similar examples in order of most similar to least similar. If no similar
   *                    examples are found, random examples will be returned.
   *
   * @param filter      A filter string to apply to the search. Only examples will be returned that
   *                    match the filter string. Some examples of filters
   *
   *                    - eq(metadata.mykey, "value")
   *                    - and(neq(metadata.my.nested.key, "value"), neq(metadata.mykey, "value"))
   *                    - or(eq(metadata.mykey, "value"), eq(metadata.mykey, "othervalue"))
   *
   * @returns           A list of similar examples.
   *
   *
   * @example
   * dataset_id = "123e4567-e89b-12d3-a456-426614174000"
   * inputs = {"text": "How many people live in Berlin?"}
   * limit = 5
   * examples = await client.similarExamples(inputs, dataset_id, limit)
   */
  async similarExamples(A, e, r, { filter: i } = {}) {
    const n = {
      limit: r,
      inputs: A
    };
    i !== void 0 && (n.filter = i), te(e);
    const s = JSON.stringify(n);
    return (await (await this.caller.call(async () => {
      const o = await this._fetch(`${this.apiUrl}/datasets/${e}/search`, {
        headers: { ...this.headers, "Content-Type": "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        method: "POST",
        body: s
      });
      return await OA(o, "fetch similar examples"), o;
    })).json()).examples;
  }
  async createExample(A, e, r) {
    var u;
    if (bk(A) && (e !== void 0 || r !== void 0))
      throw new Error("Cannot provide outputs or options when using ExampleCreate object");
    let i = e ? r == null ? void 0 : r.datasetId : A.dataset_id;
    const n = e ? r == null ? void 0 : r.datasetName : A.dataset_name;
    if (i === void 0 && n === void 0)
      throw new Error("Must provide either datasetName or datasetId");
    if (i !== void 0 && n !== void 0)
      throw new Error("Must provide either datasetName or datasetId, not both");
    i === void 0 && (i = (await this.readDataset({ datasetName: n })).id);
    const s = (e ? r == null ? void 0 : r.createdAt : A.created_at) || /* @__PURE__ */ new Date();
    let a;
    bk(A) ? a = A : a = {
      inputs: A,
      outputs: e,
      created_at: s == null ? void 0 : s.toISOString(),
      id: r == null ? void 0 : r.exampleId,
      metadata: r == null ? void 0 : r.metadata,
      split: r == null ? void 0 : r.split,
      source_run_id: r == null ? void 0 : r.sourceRunId,
      use_source_run_io: r == null ? void 0 : r.useSourceRunIO,
      use_source_run_attachments: r == null ? void 0 : r.useSourceRunAttachments,
      attachments: r == null ? void 0 : r.attachments
    };
    const g = await this._uploadExamplesMultipart(i, [a]);
    return await this.readExample(((u = g.example_ids) == null ? void 0 : u[0]) ?? QI());
  }
  async createExamples(A) {
    if (Array.isArray(A)) {
      if (A.length === 0)
        return [];
      const Q = A;
      let f = Q[0].dataset_id;
      const p = Q[0].dataset_name;
      if (f === void 0 && p === void 0)
        throw new Error("Must provide either datasetName or datasetId");
      if (f !== void 0 && p !== void 0)
        throw new Error("Must provide either datasetName or datasetId, not both");
      f === void 0 && (f = (await this.readDataset({ datasetName: p })).id);
      const y = await this._uploadExamplesMultipart(f, Q);
      return await Promise.all(y.example_ids.map((S) => this.readExample(S)));
    }
    const { inputs: e, outputs: r, metadata: i, splits: n, sourceRunIds: s, useSourceRunIOs: a, useSourceRunAttachments: g, attachments: o, exampleIds: u, datasetId: I, datasetName: c } = A;
    if (e === void 0)
      throw new Error("Must provide inputs when using legacy parameters");
    let C = I;
    const E = c;
    if (C === void 0 && E === void 0)
      throw new Error("Must provide either datasetName or datasetId");
    if (C !== void 0 && E !== void 0)
      throw new Error("Must provide either datasetName or datasetId, not both");
    C === void 0 && (C = (await this.readDataset({ datasetName: E })).id);
    const l = e.map((Q, f) => ({
      dataset_id: C,
      inputs: Q,
      outputs: r == null ? void 0 : r[f],
      metadata: i == null ? void 0 : i[f],
      split: n == null ? void 0 : n[f],
      id: u == null ? void 0 : u[f],
      attachments: o == null ? void 0 : o[f],
      source_run_id: s == null ? void 0 : s[f],
      use_source_run_io: a == null ? void 0 : a[f],
      use_source_run_attachments: g == null ? void 0 : g[f]
    })), B = await this._uploadExamplesMultipart(C, l);
    return await Promise.all(B.example_ids.map((Q) => this.readExample(Q)));
  }
  async createLLMExample(A, e, r) {
    return this.createExample({ input: A }, { output: e }, r);
  }
  async createChatExample(A, e, r) {
    const i = A.map((s) => sk(s) ? ak(s) : s), n = sk(e) ? ak(e) : e;
    return this.createExample({ input: i }, { output: n }, r);
  }
  async readExample(A) {
    te(A);
    const e = `/examples/${A}`, r = await this._get(e), { attachment_urls: i, ...n } = r, s = n;
    return i && (s.attachments = Object.entries(i).reduce((a, [g, o]) => (a[g.slice(11)] = {
      presigned_url: o.presigned_url,
      mime_type: o.mime_type
    }, a), {})), s;
  }
  async *listExamples({ datasetId: A, datasetName: e, exampleIds: r, asOf: i, splits: n, inlineS3Urls: s, metadata: a, limit: g, offset: o, filter: u, includeAttachments: I } = {}) {
    let c;
    if (A !== void 0 && e !== void 0)
      throw new Error("Must provide either datasetName or datasetId, not both");
    if (A !== void 0)
      c = A;
    else if (e !== void 0)
      c = (await this.readDataset({ datasetName: e })).id;
    else
      throw new Error("Must provide a datasetName or datasetId");
    const C = new URLSearchParams({ dataset: c }), E = i ? typeof i == "string" ? i : i == null ? void 0 : i.toISOString() : void 0;
    E && C.append("as_of", E);
    const l = s ?? !0;
    if (C.append("inline_s3_urls", l.toString()), r !== void 0)
      for (const h of r)
        C.append("id", h);
    if (n !== void 0)
      for (const h of n)
        C.append("splits", h);
    if (a !== void 0) {
      const h = JSON.stringify(a);
      C.append("metadata", h);
    }
    g !== void 0 && C.append("limit", g.toString()), o !== void 0 && C.append("offset", o.toString()), u !== void 0 && C.append("filter", u), I === !0 && ["attachment_urls", "outputs", "metadata"].forEach((h) => C.append("select", h));
    let B = 0;
    for await (const h of this._getPaginated("/examples", C)) {
      for (const Q of h) {
        const { attachment_urls: f, ...p } = Q, y = p;
        f && (y.attachments = Object.entries(f).reduce((m, [S, w]) => (m[S.slice(11)] = {
          presigned_url: w.presigned_url,
          mime_type: w.mime_type || void 0
        }, m), {})), yield y, B++;
      }
      if (g !== void 0 && B >= g)
        break;
    }
  }
  async deleteExample(A) {
    te(A);
    const e = `/examples/${A}`;
    await this.caller.call(async () => {
      const r = await this._fetch(this.apiUrl + e, {
        method: "DELETE",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      return await OA(r, `delete ${e}`, !0), r;
    });
  }
  /**
   * Delete multiple examples by ID.
   * @param exampleIds - The IDs of the examples to delete
   * @param options - Optional settings for deletion
   * @param options.hardDelete - If true, permanently delete examples. If false (default), soft delete them.
   */
  async deleteExamples(A, e) {
    if (A.forEach((r) => te(r)), e != null && e.hardDelete) {
      const r = this._getPlatformEndpointPath("datasets/examples/delete");
      await this.caller.call(async () => {
        const i = await this._fetch(`${this.apiUrl}${r}`, {
          method: "POST",
          headers: { ...this.headers, "Content-Type": "application/json" },
          body: JSON.stringify({
            example_ids: A,
            hard_delete: !0
          }),
          signal: AbortSignal.timeout(this.timeout_ms),
          ...this.fetchOptions
        });
        return await OA(i, "hard delete examples", !0), i;
      });
    } else {
      const r = new URLSearchParams();
      A.forEach((i) => r.append("example_ids", i)), await this.caller.call(async () => {
        const i = await this._fetch(`${this.apiUrl}/examples?${r.toString()}`, {
          method: "DELETE",
          headers: this.headers,
          signal: AbortSignal.timeout(this.timeout_ms),
          ...this.fetchOptions
        });
        return await OA(i, "delete examples", !0), i;
      });
    }
  }
  async updateExample(A, e) {
    let r;
    e ? r = A : r = A.id, te(r);
    let i;
    e ? i = { id: r, ...e } : i = A;
    let n;
    return i.dataset_id !== void 0 ? n = i.dataset_id : n = (await this.readExample(r)).dataset_id, this._updateExamplesMultipart(n, [i]);
  }
  async updateExamples(A) {
    let e;
    return A[0].dataset_id === void 0 ? e = (await this.readExample(A[0].id)).dataset_id : e = A[0].dataset_id, this._updateExamplesMultipart(e, A);
  }
  /**
   * Get dataset version by closest date or exact tag.
   *
   * Use this to resolve the nearest version to a given timestamp or for a given tag.
   *
   * @param options The options for getting the dataset version
   * @param options.datasetId The ID of the dataset
   * @param options.datasetName The name of the dataset
   * @param options.asOf The timestamp of the dataset to retrieve
   * @param options.tag The tag of the dataset to retrieve
   * @returns The dataset version
   */
  async readDatasetVersion({ datasetId: A, datasetName: e, asOf: r, tag: i }) {
    let n;
    if (A ? n = A : n = (await this.readDataset({ datasetName: e })).id, te(n), r && i || !r && !i)
      throw new Error("Exactly one of asOf and tag must be specified.");
    const s = new URLSearchParams();
    return r !== void 0 && s.append("as_of", typeof r == "string" ? r : r.toISOString()), i !== void 0 && s.append("tag", i), await (await this.caller.call(async () => {
      const g = await this._fetch(`${this.apiUrl}/datasets/${n}/version?${s.toString()}`, {
        method: "GET",
        headers: { ...this.headers },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      return await OA(g, "read dataset version"), g;
    })).json();
  }
  async listDatasetSplits({ datasetId: A, datasetName: e, asOf: r }) {
    let i;
    if (A === void 0 && e === void 0)
      throw new Error("Must provide dataset name or ID");
    if (A !== void 0 && e !== void 0)
      throw new Error("Must provide either datasetName or datasetId, not both");
    A === void 0 ? i = (await this.readDataset({ datasetName: e })).id : i = A, te(i);
    const n = new URLSearchParams(), s = r ? typeof r == "string" ? r : r == null ? void 0 : r.toISOString() : void 0;
    return s && n.append("as_of", s), await this._get(`/datasets/${i}/splits`, n);
  }
  async updateDatasetSplits({ datasetId: A, datasetName: e, splitName: r, exampleIds: i, remove: n = !1 }) {
    let s;
    if (A === void 0 && e === void 0)
      throw new Error("Must provide dataset name or ID");
    if (A !== void 0 && e !== void 0)
      throw new Error("Must provide either datasetName or datasetId, not both");
    A === void 0 ? s = (await this.readDataset({ datasetName: e })).id : s = A, te(s);
    const a = {
      split_name: r,
      examples: i.map((o) => (te(o), o)),
      remove: n
    }, g = JSON.stringify(a);
    await this.caller.call(async () => {
      const o = await this._fetch(`${this.apiUrl}/datasets/${s}/splits`, {
        method: "PUT",
        headers: { ...this.headers, "Content-Type": "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: g
      });
      return await OA(o, "update dataset splits", !0), o;
    });
  }
  /**
   * @deprecated This method is deprecated and will be removed in future LangSmith versions, use `evaluate` from `langsmith/evaluation` instead.
   */
  async evaluateRun(A, e, { sourceInfo: r, loadChildRuns: i, referenceExample: n } = { loadChildRuns: !1 }) {
    Ow("This method is deprecated and will be removed in future LangSmith versions, use `evaluate` from `langsmith/evaluation` instead.");
    let s;
    if (typeof A == "string")
      s = await this.readRun(A, { loadChildRuns: i });
    else if (typeof A == "object" && "id" in A)
      s = A;
    else
      throw new Error(`Invalid run type: ${typeof A}`);
    s.reference_example_id !== null && s.reference_example_id !== void 0 && (n = await this.readExample(s.reference_example_id));
    const a = await e.evaluateRun(s, n), [g, o] = await this._logEvaluationFeedback(a, s, r);
    return o[0];
  }
  async createFeedback(A, e, { score: r, value: i, correction: n, comment: s, sourceInfo: a, feedbackSourceType: g = "api", sourceRunId: o, feedbackId: u, feedbackConfig: I, projectId: c, comparativeExperimentId: C }) {
    var Q;
    if (!A && !c)
      throw new Error("One of runId or projectId must be provided");
    if (A && c)
      throw new Error("Only one of runId or projectId can be provided");
    const E = {
      type: g ?? "api",
      metadata: a ?? {}
    };
    o !== void 0 && (E == null ? void 0 : E.metadata) !== void 0 && !E.metadata.__run && (E.metadata.__run = { run_id: o }), (E == null ? void 0 : E.metadata) !== void 0 && ((Q = E.metadata.__run) == null ? void 0 : Q.run_id) !== void 0 && te(E.metadata.__run.run_id);
    const l = {
      id: u ?? QI(),
      run_id: A,
      key: e,
      score: vk(r),
      value: i,
      correction: n,
      comment: s,
      feedback_source: E,
      comparative_experiment_id: C,
      feedbackConfig: I,
      session_id: c
    }, B = JSON.stringify(l), h = `${this.apiUrl}/feedback`;
    return await this.caller.call(async () => {
      const f = await this._fetch(h, {
        method: "POST",
        headers: { ...this.headers, "Content-Type": "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: B
      });
      return await OA(f, "create feedback", !0), f;
    }), l;
  }
  async updateFeedback(A, { score: e, value: r, correction: i, comment: n }) {
    const s = {};
    e != null && (s.score = vk(e)), r != null && (s.value = r), i != null && (s.correction = i), n != null && (s.comment = n), te(A);
    const a = JSON.stringify(s);
    await this.caller.call(async () => {
      const g = await this._fetch(`${this.apiUrl}/feedback/${A}`, {
        method: "PATCH",
        headers: { ...this.headers, "Content-Type": "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: a
      });
      return await OA(g, "update feedback", !0), g;
    });
  }
  async readFeedback(A) {
    te(A);
    const e = `/feedback/${A}`;
    return await this._get(e);
  }
  async deleteFeedback(A) {
    te(A);
    const e = `/feedback/${A}`;
    await this.caller.call(async () => {
      const r = await this._fetch(this.apiUrl + e, {
        method: "DELETE",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      return await OA(r, `delete ${e}`, !0), r;
    });
  }
  async *listFeedback({ runIds: A, feedbackKeys: e, feedbackSourceTypes: r } = {}) {
    const i = new URLSearchParams();
    if (A)
      for (const n of A)
        te(n), i.append("run", n);
    if (e)
      for (const n of e)
        i.append("key", n);
    if (r)
      for (const n of r)
        i.append("source", n);
    for await (const n of this._getPaginated("/feedback", i))
      yield* n;
  }
  /**
   * Creates a presigned feedback token and URL.
   *
   * The token can be used to authorize feedback metrics without
   * needing an API key. This is useful for giving browser-based
   * applications the ability to submit feedback without needing
   * to expose an API key.
   *
   * @param runId The ID of the run.
   * @param feedbackKey The feedback key.
   * @param options Additional options for the token.
   * @param options.expiration The expiration time for the token.
   *
   * @returns A promise that resolves to a FeedbackIngestToken.
   */
  async createPresignedFeedbackToken(A, e, { expiration: r, feedbackConfig: i } = {}) {
    const n = {
      run_id: A,
      feedback_key: e,
      feedback_config: i
    };
    r ? typeof r == "string" ? n.expires_at = r : (r != null && r.hours || r != null && r.minutes || r != null && r.days) && (n.expires_in = r) : n.expires_in = {
      hours: 3
    };
    const s = JSON.stringify(n);
    return await (await this.caller.call(async () => {
      const g = await this._fetch(`${this.apiUrl}/feedback/tokens`, {
        method: "POST",
        headers: { ...this.headers, "Content-Type": "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: s
      });
      return await OA(g, "create presigned feedback token"), g;
    })).json();
  }
  async createComparativeExperiment({ name: A, experimentIds: e, referenceDatasetId: r, createdAt: i, description: n, metadata: s, id: a }) {
    var I;
    if (e.length === 0)
      throw new Error("At least one experiment is required");
    if (r || (r = (await this.readProject({
      projectId: e[0]
    })).reference_dataset_id), !r == null)
      throw new Error("A reference dataset is required");
    const g = {
      id: a,
      name: A,
      experiment_ids: e,
      reference_dataset_id: r,
      description: n,
      created_at: (I = i ?? /* @__PURE__ */ new Date()) == null ? void 0 : I.toISOString(),
      extra: {}
    };
    s && (g.extra.metadata = s);
    const o = JSON.stringify(g);
    return (await this.caller.call(async () => {
      const c = await this._fetch(`${this.apiUrl}/datasets/comparative`, {
        method: "POST",
        headers: { ...this.headers, "Content-Type": "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: o
      });
      return await OA(c, "create comparative experiment"), c;
    })).json();
  }
  /**
   * Retrieves a list of presigned feedback tokens for a given run ID.
   * @param runId The ID of the run.
   * @returns An async iterable of FeedbackIngestToken objects.
   */
  async *listPresignedFeedbackTokens(A) {
    te(A);
    const e = new URLSearchParams({ run_id: A });
    for await (const r of this._getPaginated("/feedback/tokens", e))
      yield* r;
  }
  _selectEvalResults(A) {
    let e;
    return "results" in A ? e = A.results : Array.isArray(A) ? e = A : e = [A], e;
  }
  async _logEvaluationFeedback(A, e, r) {
    const i = this._selectEvalResults(A), n = [];
    for (const s of i) {
      let a = r || {};
      s.evaluatorInfo && (a = { ...s.evaluatorInfo, ...a });
      let g = null;
      s.targetRunId ? g = s.targetRunId : e && (g = e.id), n.push(await this.createFeedback(g, s.key, {
        score: s.score,
        value: s.value,
        comment: s.comment,
        correction: s.correction,
        sourceInfo: a,
        sourceRunId: s.sourceRunId,
        feedbackConfig: s.feedbackConfig,
        feedbackSourceType: "model"
      }));
    }
    return [i, n];
  }
  async logEvaluationFeedback(A, e, r) {
    const [i] = await this._logEvaluationFeedback(A, e, r);
    return i;
  }
  /**
   * API for managing annotation queues
   */
  /**
   * List the annotation queues on the LangSmith API.
   * @param options - The options for listing annotation queues
   * @param options.queueIds - The IDs of the queues to filter by
   * @param options.name - The name of the queue to filter by
   * @param options.nameContains - The substring that the queue name should contain
   * @param options.limit - The maximum number of queues to return
   * @returns An iterator of AnnotationQueue objects
   */
  async *listAnnotationQueues(A = {}) {
    const { queueIds: e, name: r, nameContains: i, limit: n } = A, s = new URLSearchParams();
    e && e.forEach((g, o) => {
      te(g, `queueIds[${o}]`), s.append("ids", g);
    }), r && s.append("name", r), i && s.append("name_contains", i), s.append("limit", (n !== void 0 ? Math.min(n, 100) : 100).toString());
    let a = 0;
    for await (const g of this._getPaginated("/annotation-queues", s))
      if (yield* g, a++, n !== void 0 && a >= n)
        break;
  }
  /**
   * Create an annotation queue on the LangSmith API.
   * @param options - The options for creating an annotation queue
   * @param options.name - The name of the annotation queue
   * @param options.description - The description of the annotation queue
   * @param options.queueId - The ID of the annotation queue
   * @returns The created AnnotationQueue object
   */
  async createAnnotationQueue(A) {
    const { name: e, description: r, queueId: i, rubricInstructions: n } = A, s = {
      name: e,
      description: r,
      id: i || QI(),
      rubric_instructions: n
    }, a = JSON.stringify(Object.fromEntries(Object.entries(s).filter(([o, u]) => u !== void 0)));
    return (await this.caller.call(async () => {
      const o = await this._fetch(`${this.apiUrl}/annotation-queues`, {
        method: "POST",
        headers: { ...this.headers, "Content-Type": "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: a
      });
      return await OA(o, "create annotation queue"), o;
    })).json();
  }
  /**
   * Read an annotation queue with the specified queue ID.
   * @param queueId - The ID of the annotation queue to read
   * @returns The AnnotationQueueWithDetails object
   */
  async readAnnotationQueue(A) {
    return (await this.caller.call(async () => {
      const r = await this._fetch(`${this.apiUrl}/annotation-queues/${te(A, "queueId")}`, {
        method: "GET",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      return await OA(r, "read annotation queue"), r;
    })).json();
  }
  /**
   * Update an annotation queue with the specified queue ID.
   * @param queueId - The ID of the annotation queue to update
   * @param options - The options for updating the annotation queue
   * @param options.name - The new name for the annotation queue
   * @param options.description - The new description for the annotation queue
   */
  async updateAnnotationQueue(A, e) {
    const { name: r, description: i, rubricInstructions: n } = e, s = JSON.stringify({
      name: r,
      description: i,
      rubric_instructions: n
    });
    await this.caller.call(async () => {
      const a = await this._fetch(`${this.apiUrl}/annotation-queues/${te(A, "queueId")}`, {
        method: "PATCH",
        headers: { ...this.headers, "Content-Type": "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: s
      });
      return await OA(a, "update annotation queue", !0), a;
    });
  }
  /**
   * Delete an annotation queue with the specified queue ID.
   * @param queueId - The ID of the annotation queue to delete
   */
  async deleteAnnotationQueue(A) {
    await this.caller.call(async () => {
      const e = await this._fetch(`${this.apiUrl}/annotation-queues/${te(A, "queueId")}`, {
        method: "DELETE",
        headers: { ...this.headers, Accept: "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      return await OA(e, "delete annotation queue", !0), e;
    });
  }
  /**
   * Add runs to an annotation queue with the specified queue ID.
   * @param queueId - The ID of the annotation queue
   * @param runIds - The IDs of the runs to be added to the annotation queue
   */
  async addRunsToAnnotationQueue(A, e) {
    const r = JSON.stringify(e.map((i, n) => te(i, `runIds[${n}]`).toString()));
    await this.caller.call(async () => {
      const i = await this._fetch(`${this.apiUrl}/annotation-queues/${te(A, "queueId")}/runs`, {
        method: "POST",
        headers: { ...this.headers, "Content-Type": "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: r
      });
      return await OA(i, "add runs to annotation queue", !0), i;
    });
  }
  /**
   * Get a run from an annotation queue at the specified index.
   * @param queueId - The ID of the annotation queue
   * @param index - The index of the run to retrieve
   * @returns A Promise that resolves to a RunWithAnnotationQueueInfo object
   * @throws {Error} If the run is not found at the given index or for other API-related errors
   */
  async getRunFromAnnotationQueue(A, e) {
    const r = `/annotation-queues/${te(A, "queueId")}/run`;
    return (await this.caller.call(async () => {
      const n = await this._fetch(`${this.apiUrl}${r}/${e}`, {
        method: "GET",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      return await OA(n, "get run from annotation queue"), n;
    })).json();
  }
  /**
   * Delete a run from an an annotation queue.
   * @param queueId - The ID of the annotation queue to delete the run from
   * @param queueRunId - The ID of the run to delete from the annotation queue
   */
  async deleteRunFromAnnotationQueue(A, e) {
    await this.caller.call(async () => {
      const r = await this._fetch(`${this.apiUrl}/annotation-queues/${te(A, "queueId")}/runs/${te(e, "queueRunId")}`, {
        method: "DELETE",
        headers: { ...this.headers, Accept: "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      return await OA(r, "delete run from annotation queue", !0), r;
    });
  }
  /**
   * Get the size of an annotation queue.
   * @param queueId - The ID of the annotation queue
   */
  async getSizeFromAnnotationQueue(A) {
    return (await this.caller.call(async () => {
      const r = await this._fetch(`${this.apiUrl}/annotation-queues/${te(A, "queueId")}/size`, {
        method: "GET",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      return await OA(r, "get size from annotation queue"), r;
    })).json();
  }
  async _currentTenantIsOwner(A) {
    const e = await this._getSettings();
    return A == "-" || e.tenant_handle === A;
  }
  async _ownerConflictError(A, e) {
    const r = await this._getSettings();
    return new Error(`Cannot ${A} for another tenant.

      Current tenant: ${r.tenant_handle}

      Requested tenant: ${e}`);
  }
  async _getLatestCommitHash(A) {
    const r = await (await this.caller.call(async () => {
      const i = await this._fetch(`${this.apiUrl}/commits/${A}/?limit=1&offset=0`, {
        method: "GET",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      return await OA(i, "get latest commit hash"), i;
    })).json();
    if (r.commits.length !== 0)
      return r.commits[0].commit_hash;
  }
  async _likeOrUnlikePrompt(A, e) {
    const [r, i, n] = ks(A), s = JSON.stringify({ like: e });
    return (await this.caller.call(async () => {
      const g = await this._fetch(`${this.apiUrl}/likes/${r}/${i}`, {
        method: "POST",
        headers: { ...this.headers, "Content-Type": "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: s
      });
      return await OA(g, `${e ? "like" : "unlike"} prompt`), g;
    })).json();
  }
  async _getPromptUrl(A) {
    const [e, r, i] = ks(A);
    if (await this._currentTenantIsOwner(e)) {
      const n = await this._getSettings();
      return i !== "latest" ? `${this.getHostUrl()}/prompts/${r}/${i.substring(0, 8)}?organizationId=${n.id}` : `${this.getHostUrl()}/prompts/${r}?organizationId=${n.id}`;
    } else
      return i !== "latest" ? `${this.getHostUrl()}/hub/${e}/${r}/${i.substring(0, 8)}` : `${this.getHostUrl()}/hub/${e}/${r}`;
  }
  async promptExists(A) {
    return !!await this.getPrompt(A);
  }
  async likePrompt(A) {
    return this._likeOrUnlikePrompt(A, !0);
  }
  async unlikePrompt(A) {
    return this._likeOrUnlikePrompt(A, !1);
  }
  async *listCommits(A) {
    for await (const e of this._getPaginated(`/commits/${A}/`, new URLSearchParams(), (r) => r.commits))
      yield* e;
  }
  async *listPrompts(A) {
    const e = new URLSearchParams();
    e.append("sort_field", (A == null ? void 0 : A.sortField) ?? "updated_at"), e.append("sort_direction", "desc"), e.append("is_archived", (!!(A != null && A.isArchived)).toString()), (A == null ? void 0 : A.isPublic) !== void 0 && e.append("is_public", A.isPublic.toString()), A != null && A.query && e.append("query", A.query);
    for await (const r of this._getPaginated("/repos", e, (i) => i.repos))
      yield* r;
  }
  async getPrompt(A) {
    const [e, r, i] = ks(A), n = await this.caller.call(async () => {
      const a = await this._fetch(`${this.apiUrl}/repos/${e}/${r}`, {
        method: "GET",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      return (a == null ? void 0 : a.status) === 404 ? null : (await OA(a, "get prompt"), a);
    }), s = await (n == null ? void 0 : n.json());
    return s != null && s.repo ? s.repo : null;
  }
  async createPrompt(A, e) {
    const r = await this._getSettings();
    if (e != null && e.isPublic && !r.tenant_handle)
      throw new Error(`Cannot create a public prompt without first

        creating a LangChain Hub handle.
        You can add a handle by creating a public prompt at:

        https://smith.langchain.com/prompts`);
    const [i, n, s] = ks(A);
    if (!await this._currentTenantIsOwner(i))
      throw await this._ownerConflictError("create a prompt", i);
    const a = {
      repo_handle: n,
      ...(e == null ? void 0 : e.description) && { description: e.description },
      ...(e == null ? void 0 : e.readme) && { readme: e.readme },
      ...(e == null ? void 0 : e.tags) && { tags: e.tags },
      is_public: !!(e != null && e.isPublic)
    }, g = JSON.stringify(a), o = await this.caller.call(async () => {
      const I = await this._fetch(`${this.apiUrl}/repos/`, {
        method: "POST",
        headers: { ...this.headers, "Content-Type": "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: g
      });
      return await OA(I, "create prompt"), I;
    }), { repo: u } = await o.json();
    return u;
  }
  async createCommit(A, e, r) {
    if (!await this.promptExists(A))
      throw new Error("Prompt does not exist, you must create it first.");
    const [i, n, s] = ks(A), a = (r == null ? void 0 : r.parentCommitHash) === "latest" || !(r != null && r.parentCommitHash) ? await this._getLatestCommitHash(`${i}/${n}`) : r == null ? void 0 : r.parentCommitHash, g = {
      manifest: JSON.parse(JSON.stringify(e)),
      parent_commit: a
    }, o = JSON.stringify(g), I = await (await this.caller.call(async () => {
      const c = await this._fetch(`${this.apiUrl}/commits/${i}/${n}`, {
        method: "POST",
        headers: { ...this.headers, "Content-Type": "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: o
      });
      return await OA(c, "create commit"), c;
    })).json();
    return this._getPromptUrl(`${i}/${n}${I.commit_hash ? `:${I.commit_hash}` : ""}`);
  }
  /**
   * Update examples with attachments using multipart form data.
   * @param updates List of ExampleUpdateWithAttachments objects to upsert
   * @returns Promise with the update response
   */
  async updateExamplesMultipart(A, e = []) {
    return this._updateExamplesMultipart(A, e);
  }
  async _updateExamplesMultipart(A, e = []) {
    var s;
    if (!await this._getDatasetExamplesMultiPartSupport())
      throw new Error("Your LangSmith deployment does not allow using the multipart examples endpoint, please upgrade your deployment to the latest version.");
    const r = new FormData();
    for (const a of e) {
      const g = a.id, o = {
        ...a.metadata && { metadata: a.metadata },
        ...a.split && { split: a.split }
      }, u = Fr(o, `Serializing body for example with id: ${g}`), I = new Blob([u], {
        type: "application/json"
      });
      if (r.append(g, I), a.inputs) {
        const c = Fr(a.inputs, `Serializing inputs for example with id: ${g}`), C = new Blob([c], {
          type: "application/json"
        });
        r.append(`${g}.inputs`, C);
      }
      if (a.outputs) {
        const c = Fr(a.outputs, `Serializing outputs whle updating example with id: ${g}`), C = new Blob([c], {
          type: "application/json"
        });
        r.append(`${g}.outputs`, C);
      }
      if (a.attachments)
        for (const [c, C] of Object.entries(a.attachments)) {
          let E, l;
          Array.isArray(C) ? [E, l] = C : (E = C.mimeType, l = C.data);
          const B = new Blob([l], {
            type: `${E}; length=${l.byteLength}`
          });
          r.append(`${g}.attachment.${c}`, B);
        }
      if (a.attachments_operations) {
        const c = Fr(a.attachments_operations, `Serializing attachments while updating example with id: ${g}`), C = new Blob([c], {
          type: "application/json"
        });
        r.append(`${g}.attachments_operations`, C);
      }
    }
    const i = A ?? ((s = e[0]) == null ? void 0 : s.dataset_id);
    return (await this.caller.call(async () => {
      const a = await this._fetch(`${this.apiUrl}${this._getPlatformEndpointPath(`datasets/${i}/examples`)}`, {
        method: "PATCH",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: r
      });
      return await OA(a, "update examples"), a;
    })).json();
  }
  /**
   * Upload examples with attachments using multipart form data.
   * @param uploads List of ExampleUploadWithAttachments objects to upload
   * @returns Promise with the upload response
   * @deprecated This method is deprecated and will be removed in future LangSmith versions, please use `createExamples` instead
   */
  async uploadExamplesMultipart(A, e = []) {
    return this._uploadExamplesMultipart(A, e);
  }
  async _uploadExamplesMultipart(A, e = []) {
    if (!await this._getDatasetExamplesMultiPartSupport())
      throw new Error("Your LangSmith deployment does not allow using the multipart examples endpoint, please upgrade your deployment to the latest version.");
    const r = new FormData();
    for (const n of e) {
      const s = (n.id ?? QI()).toString(), a = {
        created_at: n.created_at,
        ...n.metadata && { metadata: n.metadata },
        ...n.split && { split: n.split },
        ...n.source_run_id && { source_run_id: n.source_run_id },
        ...n.use_source_run_io && {
          use_source_run_io: n.use_source_run_io
        },
        ...n.use_source_run_attachments && {
          use_source_run_attachments: n.use_source_run_attachments
        }
      }, g = Fr(a, `Serializing body for uploaded example with id: ${s}`), o = new Blob([g], {
        type: "application/json"
      });
      if (r.append(s, o), n.inputs) {
        const u = Fr(n.inputs, `Serializing inputs for uploaded example with id: ${s}`), I = new Blob([u], {
          type: "application/json"
        });
        r.append(`${s}.inputs`, I);
      }
      if (n.outputs) {
        const u = Fr(n.outputs, `Serializing outputs for uploaded example with id: ${s}`), I = new Blob([u], {
          type: "application/json"
        });
        r.append(`${s}.outputs`, I);
      }
      if (n.attachments)
        for (const [u, I] of Object.entries(n.attachments)) {
          let c, C;
          Array.isArray(I) ? [c, C] = I : (c = I.mimeType, C = I.data);
          const E = new Blob([C], {
            type: `${c}; length=${C.byteLength}`
          });
          r.append(`${s}.attachment.${u}`, E);
        }
    }
    return (await this.caller.call(async () => {
      const n = await this._fetch(`${this.apiUrl}${this._getPlatformEndpointPath(`datasets/${A}/examples`)}`, {
        method: "POST",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: r
      });
      return await OA(n, "upload examples"), n;
    })).json();
  }
  async updatePrompt(A, e) {
    if (!await this.promptExists(A))
      throw new Error("Prompt does not exist, you must create it first.");
    const [r, i] = ks(A);
    if (!await this._currentTenantIsOwner(r))
      throw await this._ownerConflictError("update a prompt", r);
    const n = {};
    if ((e == null ? void 0 : e.description) !== void 0 && (n.description = e.description), (e == null ? void 0 : e.readme) !== void 0 && (n.readme = e.readme), (e == null ? void 0 : e.tags) !== void 0 && (n.tags = e.tags), (e == null ? void 0 : e.isPublic) !== void 0 && (n.is_public = e.isPublic), (e == null ? void 0 : e.isArchived) !== void 0 && (n.is_archived = e.isArchived), Object.keys(n).length === 0)
      throw new Error("No valid update options provided");
    const s = JSON.stringify(n);
    return (await this.caller.call(async () => {
      const g = await this._fetch(`${this.apiUrl}/repos/${r}/${i}`, {
        method: "PATCH",
        headers: {
          ...this.headers,
          "Content-Type": "application/json"
        },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: s
      });
      return await OA(g, "update prompt"), g;
    })).json();
  }
  async deletePrompt(A) {
    if (!await this.promptExists(A))
      throw new Error("Prompt does not exist, you must create it first.");
    const [e, r, i] = ks(A);
    if (!await this._currentTenantIsOwner(e))
      throw await this._ownerConflictError("delete a prompt", e);
    return (await this.caller.call(async () => {
      const s = await this._fetch(`${this.apiUrl}/repos/${e}/${r}`, {
        method: "DELETE",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      return await OA(s, "delete prompt"), s;
    })).json();
  }
  async pullPromptCommit(A, e) {
    const [r, i, n] = ks(A), a = await (await this.caller.call(async () => {
      const g = await this._fetch(`${this.apiUrl}/commits/${r}/${i}/${n}${e != null && e.includeModel ? "?include_model=true" : ""}`, {
        method: "GET",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      return await OA(g, "pull prompt commit"), g;
    })).json();
    return {
      owner: r,
      repo: i,
      commit_hash: a.commit_hash,
      manifest: a.manifest,
      examples: a.examples
    };
  }
  /**
   * This method should not be used directly, use `import { pull } from "langchain/hub"` instead.
   * Using this method directly returns the JSON string of the prompt rather than a LangChain object.
   * @private
   */
  async _pullPrompt(A, e) {
    const r = await this.pullPromptCommit(A, {
      includeModel: e == null ? void 0 : e.includeModel
    });
    return JSON.stringify(r.manifest);
  }
  async pushPrompt(A, e) {
    return await this.promptExists(A) ? e && Object.keys(e).some((i) => i !== "object") && await this.updatePrompt(A, {
      description: e == null ? void 0 : e.description,
      readme: e == null ? void 0 : e.readme,
      tags: e == null ? void 0 : e.tags,
      isPublic: e == null ? void 0 : e.isPublic
    }) : await this.createPrompt(A, {
      description: e == null ? void 0 : e.description,
      readme: e == null ? void 0 : e.readme,
      tags: e == null ? void 0 : e.tags,
      isPublic: e == null ? void 0 : e.isPublic
    }), e != null && e.object ? await this.createCommit(A, e == null ? void 0 : e.object, {
      parentCommitHash: e == null ? void 0 : e.parentCommitHash
    }) : await this._getPromptUrl(A);
  }
  /**
     * Clone a public dataset to your own langsmith tenant.
     * This operation is idempotent. If you already have a dataset with the given name,
     * this function will do nothing.
  
     * @param {string} tokenOrUrl The token of the public dataset to clone.
     * @param {Object} [options] Additional options for cloning the dataset.
     * @param {string} [options.sourceApiUrl] The URL of the langsmith server where the data is hosted. Defaults to the API URL of your current client.
     * @param {string} [options.datasetName] The name of the dataset to create in your tenant. Defaults to the name of the public dataset.
     * @returns {Promise<void>}
     */
  async clonePublicDataset(A, e = {}) {
    const { sourceApiUrl: r = this.apiUrl, datasetName: i } = e, [n, s] = this.parseTokenOrUrl(A, r), a = new jw({
      apiUrl: n,
      // Placeholder API key not needed anymore in most cases, but
      // some private deployments may have API key-based rate limiting
      // that would cause this to fail if we provide no value.
      apiKey: "placeholder"
    }), g = await a.readSharedDataset(s), o = i || g.name;
    try {
      if (await this.hasDataset({ datasetId: o })) {
        console.log(`Dataset ${o} already exists in your tenant. Skipping.`);
        return;
      }
    } catch {
    }
    const u = await a.listSharedExamples(s), I = await this.createDataset(o, {
      description: g.description,
      dataType: g.data_type || "kv",
      inputsSchema: g.inputs_schema_definition ?? void 0,
      outputsSchema: g.outputs_schema_definition ?? void 0
    });
    try {
      await this.createExamples({
        inputs: u.map((c) => c.inputs),
        outputs: u.flatMap((c) => c.outputs ? [c.outputs] : []),
        datasetId: I.id
      });
    } catch (c) {
      throw console.error(`An error occurred while creating dataset ${o}. You should delete it manually.`), c;
    }
  }
  parseTokenOrUrl(A, e, r = 2, i = "dataset") {
    try {
      return te(A), [e, A];
    } catch {
    }
    try {
      const s = new URL(A).pathname.split("/").filter((a) => a !== "");
      if (s.length >= r) {
        const a = s[s.length - r];
        return [e, a];
      } else
        throw new Error(`Invalid public ${i} URL: ${A}`);
    } catch {
      throw new Error(`Invalid public ${i} URL or token: ${A}`);
    }
  }
  /**
   * Awaits all pending trace batches. Useful for environments where
   * you need to be sure that all tracing requests finish before execution ends,
   * such as serverless environments.
   *
   * @example
   * ```
   * import { Client } from "langsmith";
   *
   * const client = new Client();
   *
   * try {
   *   // Tracing happens here
   *   ...
   * } finally {
   *   await client.awaitPendingTraceBatches();
   * }
   * ```
   *
   * @returns A promise that resolves once all currently pending traces have sent.
   */
  async awaitPendingTraceBatches() {
    var A, e;
    if (this.manualFlushMode)
      return console.warn("[WARNING]: When tracing in manual flush mode, you must call `await client.flush()` manually to submit trace batches."), Promise.resolve();
    await Promise.all([
      ...this.autoBatchQueue.items.map(({ itemPromise: r }) => r),
      this.batchIngestCaller.queue.onIdle()
    ]), this.langSmithToOTELTranslator !== void 0 && await ((e = (A = o2()) == null ? void 0 : A.DEFAULT_LANGSMITH_SPAN_PROCESSOR) == null ? void 0 : e.forceFlush());
  }
};
function bk(t) {
  return "dataset_id" in t || "dataset_name" in t;
}
const J4 = (t) => !!["TRACING_V2", "TRACING"].find((e) => dr(e) === "true"), Fa = Symbol.for("lc:context_variables"), oy = Symbol.for("langsmith:replica_trace_roots");
function Mk(t, A) {
  if (Fa in t)
    return t[Fa][A];
}
function H4(t, A, e) {
  const r = Fa in t ? (
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    t[Fa]
  ) : {};
  r[A] = e, t[Fa] = r;
}
const pC = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
function _k(t) {
  const e = Object.keys(t).sort().map((r) => `${r}:${t[r] ?? ""}`).join("|");
  return fC(e, pC);
}
function P4(t) {
  return t.replace(/[-:.]/g, "");
}
function Bx(t, A = 1) {
  const e = A.toFixed(0).slice(0, 3).padStart(3, "0");
  return `${new Date(t).toISOString().slice(0, -1)}${e}Z`;
}
function Ex(t, A, e = 1) {
  const r = Bx(t, e);
  return {
    dottedOrder: P4(r) + A,
    microsecondPrecisionDatestring: r
  };
}
class yd {
  constructor(A, e, r, i) {
    Object.defineProperty(this, "metadata", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "tags", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "project_name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "replicas", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.metadata = A, this.tags = e, this.project_name = r, this.replicas = i;
  }
  static fromHeader(A) {
    const e = A.split(",");
    let r = {}, i = [], n, s;
    for (const a of e) {
      const [g, o] = a.split("="), u = decodeURIComponent(o);
      g === "langsmith-metadata" ? r = JSON.parse(u) : g === "langsmith-tags" ? i = u.split(",") : g === "langsmith-project" ? n = u : g === "langsmith-replicas" && (s = JSON.parse(u));
    }
    return new yd(r, i, n, s);
  }
  toHeader() {
    const A = [];
    return this.metadata && Object.keys(this.metadata).length > 0 && A.push(`langsmith-metadata=${encodeURIComponent(JSON.stringify(this.metadata))}`), this.tags && this.tags.length > 0 && A.push(`langsmith-tags=${encodeURIComponent(this.tags.join(","))}`), this.project_name && A.push(`langsmith-project=${encodeURIComponent(this.project_name)}`), A.join(",");
  }
}
class hr {
  constructor(A) {
    var a;
    if (Object.defineProperty(this, "id", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "run_type", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "project_name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "parent_run", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "parent_run_id", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "child_runs", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "start_time", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "end_time", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "extra", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "tags", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "error", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "serialized", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "inputs", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "outputs", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "reference_example_id", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "client", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "events", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "trace_id", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "dotted_order", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "tracingEnabled", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "execution_order", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "child_execution_order", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "attachments", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "replicas", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "distributedParentId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_serialized_start_time", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), O4(A)) {
      Object.assign(this, { ...A });
      return;
    }
    const e = hr.getDefaultConfig(), { metadata: r, ...i } = A, n = i.client ?? hr.getSharedClient(), s = {
      ...r,
      ...(a = i == null ? void 0 : i.extra) == null ? void 0 : a.metadata
    };
    if (i.extra = { ...i.extra, metadata: s }, "id" in i && i.id == null && delete i.id, Object.assign(this, { ...e, ...i, client: n }), this.execution_order ?? (this.execution_order = 1), this.child_execution_order ?? (this.child_execution_order = 1), this.dotted_order || (this._serialized_start_time = Bx(this.start_time, this.execution_order)), this.id || (this.id = WO(this._serialized_start_time ?? this.start_time)), this.trace_id || (this.parent_run ? this.trace_id = this.parent_run.trace_id ?? this.id : this.trace_id = this.id), this.replicas = W4(this.replicas), !this.dotted_order) {
      const { dottedOrder: g } = Ex(this.start_time, this.id, this.execution_order);
      this.parent_run ? this.dotted_order = this.parent_run.dotted_order + "." + g : this.dotted_order = g;
    }
  }
  set metadata(A) {
    var e;
    this.extra = {
      ...this.extra,
      metadata: {
        ...(e = this.extra) == null ? void 0 : e.metadata,
        ...A
      }
    };
  }
  get metadata() {
    var A;
    return (A = this.extra) == null ? void 0 : A.metadata;
  }
  static getDefaultConfig() {
    const A = Date.now();
    return {
      run_type: "chain",
      project_name: YL(),
      child_runs: [],
      api_url: pn("LANGCHAIN_ENDPOINT") ?? "http://localhost:1984",
      api_key: pn("LANGCHAIN_API_KEY"),
      caller_options: {},
      start_time: A,
      serialized: {},
      inputs: {},
      extra: {}
    };
  }
  static getSharedClient() {
    return hr.sharedClient || (hr.sharedClient = new lx()), hr.sharedClient;
  }
  createChild(A) {
    var u, I, c, C, E, l, B;
    const e = this.child_execution_order + 1, r = (u = this.replicas) == null ? void 0 : u.map((h) => {
      const { reroot: Q, ...f } = h;
      return f;
    }), i = A.replicas ?? r, n = new hr({
      ...A,
      parent_run: this,
      project_name: this.project_name,
      replicas: i,
      client: this.client,
      tracingEnabled: this.tracingEnabled,
      execution_order: e,
      child_execution_order: e
    });
    Fa in this && (n[Fa] = this[Fa]);
    const s = Symbol.for("lc:child_config"), a = ((I = A.extra) == null ? void 0 : I[s]) ?? this.extra[s];
    if (q4(a)) {
      const h = { ...a }, Q = Y4(h.callbacks) ? (C = (c = h.callbacks).copy) == null ? void 0 : C.call(c) : void 0;
      Q && (Object.assign(Q, { _parentRunId: n.id }), (B = (l = (E = Q.handlers) == null ? void 0 : E.find(hx)) == null ? void 0 : l.updateFromRunTree) == null || B.call(l, n), h.callbacks = Q), n.extra[s] = h;
    }
    const g = /* @__PURE__ */ new Set();
    let o = this;
    for (; o != null && !g.has(o.id); )
      g.add(o.id), o.child_execution_order = Math.max(o.child_execution_order, e), o = o.parent_run;
    return this.child_runs.push(n), n;
  }
  async end(A, e, r = Date.now(), i) {
    this.outputs = this.outputs ?? A, this.error = this.error ?? e, this.end_time = this.end_time ?? r, i && Object.keys(i).length > 0 && (this.extra = this.extra ? { ...this.extra, metadata: { ...this.extra.metadata, ...i } } : { metadata: i });
  }
  _convertToCreate(A, e, r = !0) {
    var a, g;
    const i = A.extra ?? {};
    if (((a = i == null ? void 0 : i.runtime) == null ? void 0 : a.library) === void 0 && (i.runtime || (i.runtime = {}), e))
      for (const [o, u] of Object.entries(e))
        i.runtime[o] || (i.runtime[o] = u);
    let n, s;
    return r ? (s = ((g = A.parent_run) == null ? void 0 : g.id) ?? A.parent_run_id, n = []) : (n = A.child_runs.map((o) => this._convertToCreate(o, e, r)), s = void 0), {
      id: A.id,
      name: A.name,
      start_time: A._serialized_start_time ?? A.start_time,
      end_time: A.end_time,
      run_type: A.run_type,
      reference_example_id: A.reference_example_id,
      extra: i,
      serialized: A.serialized,
      error: A.error,
      inputs: A.inputs,
      outputs: A.outputs,
      session_name: A.project_name,
      child_runs: n,
      parent_run_id: s,
      trace_id: A.trace_id,
      dotted_order: A.dotted_order,
      tags: A.tags,
      attachments: A.attachments,
      events: A.events
    };
  }
  _sliceParentId(A, e) {
    if (e.dotted_order) {
      const r = e.dotted_order.split(".");
      let i = null;
      for (let n = 0; n < r.length; n++)
        if (r[n].slice(-36) === A) {
          i = n;
          break;
        }
      if (i !== null) {
        const n = r.slice(i + 1);
        e.dotted_order = n.join("."), n.length > 0 ? e.trace_id = n[0].slice(-36) : e.trace_id = e.id;
      }
    }
    e.parent_run_id === A && (e.parent_run_id = void 0);
  }
  _setReplicaTraceRoot(A, e) {
    const r = Mk(this, oy) ?? {};
    r[A] = e, H4(this, oy, r);
    for (const i of this.child_runs)
      i._setReplicaTraceRoot(A, e);
  }
  _remapForProject(A) {
    const { projectName: e, runtimeEnv: r, excludeChildRuns: i = !0, reroot: n = !1, distributedParentId: s, apiUrl: a, apiKey: g, workspaceId: o } = A, u = this._convertToCreate(this, r, i);
    if (e === this.project_name)
      return {
        ...u,
        session_name: e
      };
    if (n) {
      if (s)
        this._sliceParentId(s, u);
      else if (u.parent_run_id = void 0, u.dotted_order) {
        const Q = u.dotted_order.split(".");
        Q.length > 0 && (u.dotted_order = Q[Q.length - 1], u.trace_id = u.id);
      }
      const h = _k({
        projectName: e,
        apiUrl: a,
        apiKey: g,
        workspaceId: o
      });
      this._setReplicaTraceRoot(h, u.id);
    }
    let I;
    if (!n) {
      const h = Mk(this, oy) ?? {}, Q = _k({
        projectName: e,
        apiUrl: a,
        apiKey: g,
        workspaceId: o
      });
      if (I = h[Q], I && (u.trace_id = I, u.dotted_order)) {
        const f = u.dotted_order.split(".");
        let p = null;
        for (let y = 0; y < f.length; y++)
          if (f[y].slice(-36) === I) {
            p = y;
            break;
          }
        if (p !== null) {
          const y = f.slice(p);
          u.dotted_order = y.join(".");
        }
      }
    }
    const c = u.id, C = fC(`${c}:${e}`, pC);
    let E;
    u.trace_id ? E = fC(`${u.trace_id}:${e}`, pC) : E = C;
    let l;
    u.parent_run_id && (l = fC(`${u.parent_run_id}:${e}`, pC));
    let B;
    return u.dotted_order && (B = u.dotted_order.split(".").map((f) => {
      const p = f.slice(-36), y = fC(`${p}:${e}`, pC);
      return f.slice(0, -36) + y;
    }).join(".")), {
      ...u,
      id: C,
      trace_id: E,
      parent_run_id: l,
      dotted_order: B,
      session_name: e
    };
  }
  async postRun(A = !0) {
    try {
      const e = VL();
      if (this.replicas && this.replicas.length > 0)
        for (const { projectName: r, apiKey: i, apiUrl: n, workspaceId: s, reroot: a } of this.replicas) {
          const g = this._remapForProject({
            projectName: r ?? this.project_name,
            runtimeEnv: e,
            excludeChildRuns: !0,
            reroot: a,
            distributedParentId: this.distributedParentId,
            apiUrl: n,
            apiKey: i,
            workspaceId: s
          });
          await this.client.createRun(g, {
            apiKey: i,
            apiUrl: n,
            workspaceId: s
          });
        }
      else {
        const r = this._convertToCreate(this, e, A);
        await this.client.createRun(r);
      }
      if (!A) {
        Ow("Posting with excludeChildRuns=false is deprecated and will be removed in a future version.");
        for (const r of this.child_runs)
          await r.postRun(!1);
      }
    } catch (e) {
      console.error(`Error in postRun for run ${this.id}:`, e);
    }
  }
  async patchRun(A) {
    var e;
    if (this.replicas && this.replicas.length > 0)
      for (const { projectName: r, apiKey: i, apiUrl: n, workspaceId: s, updates: a, reroot: g } of this.replicas) {
        const o = this._remapForProject({
          projectName: r ?? this.project_name,
          runtimeEnv: void 0,
          excludeChildRuns: !0,
          reroot: g,
          distributedParentId: this.distributedParentId,
          apiUrl: n,
          apiKey: i,
          workspaceId: s
        }), u = {
          id: o.id,
          name: o.name,
          run_type: o.run_type,
          start_time: o.start_time,
          outputs: o.outputs,
          error: o.error,
          parent_run_id: o.parent_run_id,
          session_name: o.session_name,
          reference_example_id: o.reference_example_id,
          end_time: o.end_time,
          dotted_order: o.dotted_order,
          trace_id: o.trace_id,
          events: o.events,
          tags: o.tags,
          extra: o.extra,
          attachments: this.attachments,
          ...a
        };
        A != null && A.excludeInputs || (u.inputs = o.inputs), await this.client.updateRun(o.id, u, {
          apiKey: i,
          apiUrl: n,
          workspaceId: s
        });
      }
    else
      try {
        const r = {
          name: this.name,
          run_type: this.run_type,
          start_time: this._serialized_start_time ?? this.start_time,
          end_time: this.end_time,
          error: this.error,
          outputs: this.outputs,
          parent_run_id: ((e = this.parent_run) == null ? void 0 : e.id) ?? this.parent_run_id,
          reference_example_id: this.reference_example_id,
          extra: this.extra,
          events: this.events,
          dotted_order: this.dotted_order,
          trace_id: this.trace_id,
          tags: this.tags,
          attachments: this.attachments,
          session_name: this.project_name
        };
        A != null && A.excludeInputs || (r.inputs = this.inputs), await this.client.updateRun(this.id, r);
      } catch (r) {
        console.error(`Error in patchRun for run ${this.id}`, r);
      }
  }
  toJSON() {
    return this._convertToCreate(this, void 0, !1);
  }
  /**
   * Add an event to the run tree.
   * @param event - A single event or string to add
   */
  addEvent(A) {
    this.events || (this.events = []), typeof A == "string" ? this.events.push({
      name: "event",
      time: (/* @__PURE__ */ new Date()).toISOString(),
      message: A
    }) : this.events.push({
      ...A,
      time: A.time ?? (/* @__PURE__ */ new Date()).toISOString()
    });
  }
  static fromRunnableConfig(A, e) {
    var o, u, I, c;
    const r = A == null ? void 0 : A.callbacks;
    let i, n, s, a = J4();
    if (r) {
      const C = ((o = r == null ? void 0 : r.getParentRunId) == null ? void 0 : o.call(r)) ?? "", E = (u = r == null ? void 0 : r.handlers) == null ? void 0 : u.find((l) => (l == null ? void 0 : l.name) == "langchain_tracer");
      i = (I = E == null ? void 0 : E.getRun) == null ? void 0 : I.call(E, C), n = E == null ? void 0 : E.projectName, s = E == null ? void 0 : E.client, a = a || !!E;
    }
    return i ? new hr({
      name: i.name,
      id: i.id,
      trace_id: i.trace_id,
      dotted_order: i.dotted_order,
      client: s,
      tracingEnabled: a,
      project_name: n,
      tags: [
        ...new Set(((i == null ? void 0 : i.tags) ?? []).concat((A == null ? void 0 : A.tags) ?? []))
      ],
      extra: {
        metadata: {
          ...(c = i == null ? void 0 : i.extra) == null ? void 0 : c.metadata,
          ...A == null ? void 0 : A.metadata
        }
      }
    }).createChild(e) : new hr({
      ...e,
      client: s,
      tracingEnabled: a,
      project_name: n
    });
  }
  static fromDottedOrder(A) {
    return this.fromHeaders({ "langsmith-trace": A });
  }
  static fromHeaders(A, e) {
    var u;
    const r = "get" in A && typeof A.get == "function" ? {
      "langsmith-trace": A.get("langsmith-trace"),
      baggage: A.get("baggage")
    } : A, i = r["langsmith-trace"];
    if (!i || typeof i != "string")
      return;
    const n = i.trim(), s = n.split(".").map((I) => {
      const [c, C] = I.split("Z");
      return { strTime: c, time: Date.parse(c + "Z"), uuid: C };
    }), a = s[0].uuid, g = {
      ...e,
      name: (e == null ? void 0 : e.name) ?? "parent",
      run_type: (e == null ? void 0 : e.run_type) ?? "chain",
      start_time: (e == null ? void 0 : e.start_time) ?? Date.now(),
      id: (u = s.at(-1)) == null ? void 0 : u.uuid,
      trace_id: a,
      dotted_order: n
    };
    if (r.baggage && typeof r.baggage == "string") {
      const I = yd.fromHeader(r.baggage);
      g.metadata = I.metadata, g.tags = I.tags, g.project_name = I.project_name, g.replicas = I.replicas;
    }
    const o = new hr(g);
    return o.distributedParentId = o.id, o;
  }
  toHeaders(A) {
    var r;
    const e = {
      "langsmith-trace": this.dotted_order,
      baggage: new yd((r = this.extra) == null ? void 0 : r.metadata, this.tags, this.project_name, this.replicas).toHeader()
    };
    if (A)
      for (const [i, n] of Object.entries(e))
        A.set(i, n);
    return e;
  }
}
Object.defineProperty(hr, "sharedClient", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: null
});
function O4(t) {
  return t != null && typeof t.createChild == "function" && typeof t.postRun == "function";
}
function hx(t) {
  return typeof t == "object" && t != null && typeof t.name == "string" && t.name === "langchain_tracer";
}
function Nk(t) {
  return Array.isArray(t) && t.some((A) => hx(A));
}
function Y4(t) {
  return typeof t == "object" && t != null && Array.isArray(t.handlers);
}
function q4(t) {
  var A;
  return t != null && typeof t.callbacks == "object" && // Callback manager with a langchain tracer
  (Nk((A = t.callbacks) == null ? void 0 : A.handlers) || // Or it's an array with a LangChainTracerLike object within it
  Nk(t.callbacks));
}
function j4() {
  const t = pn("LANGSMITH_RUNS_ENDPOINTS");
  if (!t)
    return [];
  try {
    const A = JSON.parse(t);
    if (Array.isArray(A)) {
      const e = [];
      for (const r of A) {
        if (typeof r != "object" || r === null) {
          console.warn(`Invalid item type in LANGSMITH_RUNS_ENDPOINTS: expected object, got ${typeof r}`);
          continue;
        }
        if (typeof r.api_url != "string") {
          console.warn(`Invalid api_url type in LANGSMITH_RUNS_ENDPOINTS: expected string, got ${typeof r.api_url}`);
          continue;
        }
        if (typeof r.api_key != "string") {
          console.warn(`Invalid api_key type in LANGSMITH_RUNS_ENDPOINTS: expected string, got ${typeof r.api_key}`);
          continue;
        }
        e.push({
          apiUrl: r.api_url.replace(/\/$/, ""),
          apiKey: r.api_key
        });
      }
      return e;
    } else if (typeof A == "object" && A !== null) {
      V4(A);
      const e = [];
      for (const [r, i] of Object.entries(A)) {
        const n = r.replace(/\/$/, "");
        if (typeof i == "string")
          e.push({
            apiUrl: n,
            apiKey: i
          });
        else {
          console.warn(`Invalid value type in LANGSMITH_RUNS_ENDPOINTS for URL ${r}: expected string, got ${typeof i}`);
          continue;
        }
      }
      return e;
    } else
      return console.warn(`Invalid LANGSMITH_RUNS_ENDPOINTS â€“ must be valid JSON array of objects with api_url and api_key properties, or object mapping url->apiKey, got ${typeof A}`), [];
  } catch (A) {
    if (F4(A))
      throw A;
    return console.warn("Invalid LANGSMITH_RUNS_ENDPOINTS â€“ must be valid JSON array of objects with api_url and api_key properties, or object mapping url->apiKey"), [];
  }
}
function W4(t) {
  return t ? t.map((A) => Array.isArray(A) ? {
    projectName: A[0],
    updates: A[1]
  } : A) : j4();
}
function V4(t) {
  if (Object.keys(t).length > 0 && dr("ENDPOINT"))
    throw new S4();
}
var Z4 = {};
fe(Z4, {
  BaseTracer: () => oI,
  isBaseTracer: () => Yg
});
const X4 = (t) => {
  if (t)
    return t.events = t.events ?? [], t.child_runs = t.child_runs ?? [], t;
};
function Ww(t, A) {
  if (t)
    return new hr({
      ...t,
      start_time: t._serialized_start_time ?? t.start_time,
      parent_run: Ww(A),
      child_runs: t.child_runs.map((e) => Ww(e)).filter((e) => e !== void 0),
      extra: {
        ...t.extra,
        runtime: JL()
      },
      tracingEnabled: !1
    });
}
function gy(t, A) {
  return t && !Array.isArray(t) && typeof t == "object" ? t : { [A]: t };
}
function Yg(t) {
  return typeof t._addRunToRunMap == "function";
}
var oI = class extends LE {
  constructor(A) {
    super(...arguments);
    /** @deprecated Use `runTreeMap` instead. */
    R(this, "runMap", /* @__PURE__ */ new Map());
    R(this, "runTreeMap", /* @__PURE__ */ new Map());
    R(this, "usesRunTreeMap", !1);
  }
  copy() {
    return this;
  }
  getRunById(A) {
    if (A !== void 0)
      return this.usesRunTreeMap ? X4(this.runTreeMap.get(A)) : this.runMap.get(A);
  }
  stringifyError(A) {
    return A instanceof Error ? A.message + (A != null && A.stack ? `

${A.stack}` : "") : typeof A == "string" ? A : `${A}`;
  }
  _addChildRun(A, e) {
    A.child_runs.push(e);
  }
  _addRunToRunMap(A) {
    const { dottedOrder: e, microsecondPrecisionDatestring: r } = Ex(new Date(A.start_time).getTime(), A.id, A.execution_order), i = { ...A }, n = this.getRunById(i.parent_run_id);
    if (i.parent_run_id !== void 0 ? n && (this._addChildRun(n, i), n.child_execution_order = Math.max(n.child_execution_order, i.child_execution_order), i.trace_id = n.trace_id, n.dotted_order !== void 0 && (i.dotted_order = [n.dotted_order, e].join("."), i._serialized_start_time = r)) : (i.trace_id = i.id, i.dotted_order = e, i._serialized_start_time = r), this.usesRunTreeMap) {
      const s = Ww(i, n);
      s !== void 0 && this.runTreeMap.set(i.id, s);
    } else this.runMap.set(i.id, i);
    return i;
  }
  async _endTrace(A) {
    var r;
    const e = A.parent_run_id !== void 0 && this.getRunById(A.parent_run_id);
    e ? e.child_execution_order = Math.max(e.child_execution_order, A.child_execution_order) : await this.persistRun(A), await ((r = this.onRunUpdate) == null ? void 0 : r.call(this, A)), this.usesRunTreeMap ? this.runTreeMap.delete(A.id) : this.runMap.delete(A.id);
  }
  _getExecutionOrder(A) {
    const e = A !== void 0 && this.getRunById(A);
    return e ? e.child_execution_order + 1 : 1;
  }
  /**
  * Create and add a run to the run map for LLM start events.
  * This must sometimes be done synchronously to avoid race conditions
  * when callbacks are backgrounded, so we expose it as a separate method here.
  */
  _createRunForLLMStart(A, e, r, i, n, s, a, g) {
    const o = this._getExecutionOrder(i), u = Date.now(), I = a ? {
      ...n,
      metadata: a
    } : n, c = {
      id: r,
      name: g ?? A.id[A.id.length - 1],
      parent_run_id: i,
      start_time: u,
      serialized: A,
      events: [{
        name: "start",
        time: new Date(u).toISOString()
      }],
      inputs: { prompts: e },
      execution_order: o,
      child_runs: [],
      child_execution_order: o,
      run_type: "llm",
      extra: I ?? {},
      tags: s || []
    };
    return this._addRunToRunMap(c);
  }
  async handleLLMStart(A, e, r, i, n, s, a, g) {
    var u, I;
    const o = this.getRunById(r) ?? this._createRunForLLMStart(A, e, r, i, n, s, a, g);
    return await ((u = this.onRunCreate) == null ? void 0 : u.call(this, o)), await ((I = this.onLLMStart) == null ? void 0 : I.call(this, o)), o;
  }
  /**
  * Create and add a run to the run map for chat model start events.
  * This must sometimes be done synchronously to avoid race conditions
  * when callbacks are backgrounded, so we expose it as a separate method here.
  */
  _createRunForChatModelStart(A, e, r, i, n, s, a, g) {
    const o = this._getExecutionOrder(i), u = Date.now(), I = a ? {
      ...n,
      metadata: a
    } : n, c = {
      id: r,
      name: g ?? A.id[A.id.length - 1],
      parent_run_id: i,
      start_time: u,
      serialized: A,
      events: [{
        name: "start",
        time: new Date(u).toISOString()
      }],
      inputs: { messages: e },
      execution_order: o,
      child_runs: [],
      child_execution_order: o,
      run_type: "llm",
      extra: I ?? {},
      tags: s || []
    };
    return this._addRunToRunMap(c);
  }
  async handleChatModelStart(A, e, r, i, n, s, a, g) {
    var u, I;
    const o = this.getRunById(r) ?? this._createRunForChatModelStart(A, e, r, i, n, s, a, g);
    return await ((u = this.onRunCreate) == null ? void 0 : u.call(this, o)), await ((I = this.onLLMStart) == null ? void 0 : I.call(this, o)), o;
  }
  async handleLLMEnd(A, e, r, i, n) {
    var a;
    const s = this.getRunById(e);
    if (!s || (s == null ? void 0 : s.run_type) !== "llm") throw new Error("No LLM run to end.");
    return s.end_time = Date.now(), s.outputs = A, s.events.push({
      name: "end",
      time: new Date(s.end_time).toISOString()
    }), s.extra = {
      ...s.extra,
      ...n
    }, await ((a = this.onLLMEnd) == null ? void 0 : a.call(this, s)), await this._endTrace(s), s;
  }
  async handleLLMError(A, e, r, i, n) {
    var a;
    const s = this.getRunById(e);
    if (!s || (s == null ? void 0 : s.run_type) !== "llm") throw new Error("No LLM run to end.");
    return s.end_time = Date.now(), s.error = this.stringifyError(A), s.events.push({
      name: "error",
      time: new Date(s.end_time).toISOString()
    }), s.extra = {
      ...s.extra,
      ...n
    }, await ((a = this.onLLMError) == null ? void 0 : a.call(this, s)), await this._endTrace(s), s;
  }
  /**
  * Create and add a run to the run map for chain start events.
  * This must sometimes be done synchronously to avoid race conditions
  * when callbacks are backgrounded, so we expose it as a separate method here.
  */
  _createRunForChainStart(A, e, r, i, n, s, a, g) {
    const o = this._getExecutionOrder(i), u = Date.now(), I = {
      id: r,
      name: g ?? A.id[A.id.length - 1],
      parent_run_id: i,
      start_time: u,
      serialized: A,
      events: [{
        name: "start",
        time: new Date(u).toISOString()
      }],
      inputs: e,
      execution_order: o,
      child_execution_order: o,
      run_type: a ?? "chain",
      child_runs: [],
      extra: s ? { metadata: s } : {},
      tags: n || []
    };
    return this._addRunToRunMap(I);
  }
  async handleChainStart(A, e, r, i, n, s, a, g) {
    var u, I;
    const o = this.getRunById(r) ?? this._createRunForChainStart(A, e, r, i, n, s, a, g);
    return await ((u = this.onRunCreate) == null ? void 0 : u.call(this, o)), await ((I = this.onChainStart) == null ? void 0 : I.call(this, o)), o;
  }
  async handleChainEnd(A, e, r, i, n) {
    var a;
    const s = this.getRunById(e);
    if (!s) throw new Error("No chain run to end.");
    return s.end_time = Date.now(), s.outputs = gy(A, "output"), s.events.push({
      name: "end",
      time: new Date(s.end_time).toISOString()
    }), (n == null ? void 0 : n.inputs) !== void 0 && (s.inputs = gy(n.inputs, "input")), await ((a = this.onChainEnd) == null ? void 0 : a.call(this, s)), await this._endTrace(s), s;
  }
  async handleChainError(A, e, r, i, n) {
    var a;
    const s = this.getRunById(e);
    if (!s) throw new Error("No chain run to end.");
    return s.end_time = Date.now(), s.error = this.stringifyError(A), s.events.push({
      name: "error",
      time: new Date(s.end_time).toISOString()
    }), (n == null ? void 0 : n.inputs) !== void 0 && (s.inputs = gy(n.inputs, "input")), await ((a = this.onChainError) == null ? void 0 : a.call(this, s)), await this._endTrace(s), s;
  }
  /**
  * Create and add a run to the run map for tool start events.
  * This must sometimes be done synchronously to avoid race conditions
  * when callbacks are backgrounded, so we expose it as a separate method here.
  */
  _createRunForToolStart(A, e, r, i, n, s, a) {
    const g = this._getExecutionOrder(i), o = Date.now(), u = {
      id: r,
      name: a ?? A.id[A.id.length - 1],
      parent_run_id: i,
      start_time: o,
      serialized: A,
      events: [{
        name: "start",
        time: new Date(o).toISOString()
      }],
      inputs: { input: e },
      execution_order: g,
      child_execution_order: g,
      run_type: "tool",
      child_runs: [],
      extra: s ? { metadata: s } : {},
      tags: n || []
    };
    return this._addRunToRunMap(u);
  }
  async handleToolStart(A, e, r, i, n, s, a) {
    var o, u;
    const g = this.getRunById(r) ?? this._createRunForToolStart(A, e, r, i, n, s, a);
    return await ((o = this.onRunCreate) == null ? void 0 : o.call(this, g)), await ((u = this.onToolStart) == null ? void 0 : u.call(this, g)), g;
  }
  async handleToolEnd(A, e) {
    var i;
    const r = this.getRunById(e);
    if (!r || (r == null ? void 0 : r.run_type) !== "tool") throw new Error("No tool run to end");
    return r.end_time = Date.now(), r.outputs = { output: A }, r.events.push({
      name: "end",
      time: new Date(r.end_time).toISOString()
    }), await ((i = this.onToolEnd) == null ? void 0 : i.call(this, r)), await this._endTrace(r), r;
  }
  async handleToolError(A, e) {
    var i;
    const r = this.getRunById(e);
    if (!r || (r == null ? void 0 : r.run_type) !== "tool") throw new Error("No tool run to end");
    return r.end_time = Date.now(), r.error = this.stringifyError(A), r.events.push({
      name: "error",
      time: new Date(r.end_time).toISOString()
    }), await ((i = this.onToolError) == null ? void 0 : i.call(this, r)), await this._endTrace(r), r;
  }
  async handleAgentAction(A, e) {
    var n;
    const r = this.getRunById(e);
    if (!r || (r == null ? void 0 : r.run_type) !== "chain") return;
    const i = r;
    i.actions = i.actions || [], i.actions.push(A), i.events.push({
      name: "agent_action",
      time: (/* @__PURE__ */ new Date()).toISOString(),
      kwargs: { action: A }
    }), await ((n = this.onAgentAction) == null ? void 0 : n.call(this, r));
  }
  async handleAgentEnd(A, e) {
    var i;
    const r = this.getRunById(e);
    !r || (r == null ? void 0 : r.run_type) !== "chain" || (r.events.push({
      name: "agent_end",
      time: (/* @__PURE__ */ new Date()).toISOString(),
      kwargs: { action: A }
    }), await ((i = this.onAgentEnd) == null ? void 0 : i.call(this, r)));
  }
  /**
  * Create and add a run to the run map for retriever start events.
  * This must sometimes be done synchronously to avoid race conditions
  * when callbacks are backgrounded, so we expose it as a separate method here.
  */
  _createRunForRetrieverStart(A, e, r, i, n, s, a) {
    const g = this._getExecutionOrder(i), o = Date.now(), u = {
      id: r,
      name: a ?? A.id[A.id.length - 1],
      parent_run_id: i,
      start_time: o,
      serialized: A,
      events: [{
        name: "start",
        time: new Date(o).toISOString()
      }],
      inputs: { query: e },
      execution_order: g,
      child_execution_order: g,
      run_type: "retriever",
      child_runs: [],
      extra: s ? { metadata: s } : {},
      tags: n || []
    };
    return this._addRunToRunMap(u);
  }
  async handleRetrieverStart(A, e, r, i, n, s, a) {
    var o, u;
    const g = this.getRunById(r) ?? this._createRunForRetrieverStart(A, e, r, i, n, s, a);
    return await ((o = this.onRunCreate) == null ? void 0 : o.call(this, g)), await ((u = this.onRetrieverStart) == null ? void 0 : u.call(this, g)), g;
  }
  async handleRetrieverEnd(A, e) {
    var i;
    const r = this.getRunById(e);
    if (!r || (r == null ? void 0 : r.run_type) !== "retriever") throw new Error("No retriever run to end");
    return r.end_time = Date.now(), r.outputs = { documents: A }, r.events.push({
      name: "end",
      time: new Date(r.end_time).toISOString()
    }), await ((i = this.onRetrieverEnd) == null ? void 0 : i.call(this, r)), await this._endTrace(r), r;
  }
  async handleRetrieverError(A, e) {
    var i;
    const r = this.getRunById(e);
    if (!r || (r == null ? void 0 : r.run_type) !== "retriever") throw new Error("No retriever run to end");
    return r.end_time = Date.now(), r.error = this.stringifyError(A), r.events.push({
      name: "error",
      time: new Date(r.end_time).toISOString()
    }), await ((i = this.onRetrieverError) == null ? void 0 : i.call(this, r)), await this._endTrace(r), r;
  }
  async handleText(A, e) {
    var i;
    const r = this.getRunById(e);
    !r || (r == null ? void 0 : r.run_type) !== "chain" || (r.events.push({
      name: "text",
      time: (/* @__PURE__ */ new Date()).toISOString(),
      kwargs: { text: A }
    }), await ((i = this.onText) == null ? void 0 : i.call(this, r)));
  }
  async handleLLMNewToken(A, e, r, i, n, s) {
    var g;
    const a = this.getRunById(r);
    if (!a || (a == null ? void 0 : a.run_type) !== "llm") throw new Error('Invalid "runId" provided to "handleLLMNewToken" callback.');
    return a.events.push({
      name: "new_token",
      time: (/* @__PURE__ */ new Date()).toISOString(),
      kwargs: {
        token: A,
        idx: e,
        chunk: s == null ? void 0 : s.chunk
      }
    }), await ((g = this.onLLMNewToken) == null ? void 0 : g.call(this, a, A, { chunk: s == null ? void 0 : s.chunk })), a;
  }
}, q0 = { exports: {} };
q0.exports;
(function(t) {
  const e = (n = 0) => (s) => `\x1B[${38 + n};5;${s}m`, r = (n = 0) => (s, a, g) => `\x1B[${38 + n};2;${s};${a};${g}m`;
  function i() {
    const n = /* @__PURE__ */ new Map(), s = {
      modifier: {
        reset: [0, 0],
        // 21 isn't widely supported and 22 does the same thing
        bold: [1, 22],
        dim: [2, 22],
        italic: [3, 23],
        underline: [4, 24],
        overline: [53, 55],
        inverse: [7, 27],
        hidden: [8, 28],
        strikethrough: [9, 29]
      },
      color: {
        black: [30, 39],
        red: [31, 39],
        green: [32, 39],
        yellow: [33, 39],
        blue: [34, 39],
        magenta: [35, 39],
        cyan: [36, 39],
        white: [37, 39],
        // Bright color
        blackBright: [90, 39],
        redBright: [91, 39],
        greenBright: [92, 39],
        yellowBright: [93, 39],
        blueBright: [94, 39],
        magentaBright: [95, 39],
        cyanBright: [96, 39],
        whiteBright: [97, 39]
      },
      bgColor: {
        bgBlack: [40, 49],
        bgRed: [41, 49],
        bgGreen: [42, 49],
        bgYellow: [43, 49],
        bgBlue: [44, 49],
        bgMagenta: [45, 49],
        bgCyan: [46, 49],
        bgWhite: [47, 49],
        // Bright color
        bgBlackBright: [100, 49],
        bgRedBright: [101, 49],
        bgGreenBright: [102, 49],
        bgYellowBright: [103, 49],
        bgBlueBright: [104, 49],
        bgMagentaBright: [105, 49],
        bgCyanBright: [106, 49],
        bgWhiteBright: [107, 49]
      }
    };
    s.color.gray = s.color.blackBright, s.bgColor.bgGray = s.bgColor.bgBlackBright, s.color.grey = s.color.blackBright, s.bgColor.bgGrey = s.bgColor.bgBlackBright;
    for (const [a, g] of Object.entries(s)) {
      for (const [o, u] of Object.entries(g))
        s[o] = {
          open: `\x1B[${u[0]}m`,
          close: `\x1B[${u[1]}m`
        }, g[o] = s[o], n.set(u[0], u[1]);
      Object.defineProperty(s, a, {
        value: g,
        enumerable: !1
      });
    }
    return Object.defineProperty(s, "codes", {
      value: n,
      enumerable: !1
    }), s.color.close = "\x1B[39m", s.bgColor.close = "\x1B[49m", s.color.ansi256 = e(), s.color.ansi16m = r(), s.bgColor.ansi256 = e(10), s.bgColor.ansi16m = r(10), Object.defineProperties(s, {
      rgbToAnsi256: {
        value: (a, g, o) => a === g && g === o ? a < 8 ? 16 : a > 248 ? 231 : Math.round((a - 8) / 247 * 24) + 232 : 16 + 36 * Math.round(a / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(o / 255 * 5),
        enumerable: !1
      },
      hexToRgb: {
        value: (a) => {
          const g = /(?<colorString>[a-f\d]{6}|[a-f\d]{3})/i.exec(a.toString(16));
          if (!g)
            return [0, 0, 0];
          let { colorString: o } = g.groups;
          o.length === 3 && (o = o.split("").map((I) => I + I).join(""));
          const u = Number.parseInt(o, 16);
          return [
            u >> 16 & 255,
            u >> 8 & 255,
            u & 255
          ];
        },
        enumerable: !1
      },
      hexToAnsi256: {
        value: (a) => s.rgbToAnsi256(...s.hexToRgb(a)),
        enumerable: !1
      }
    }), s;
  }
  Object.defineProperty(t, "exports", {
    enumerable: !0,
    get: i
  });
})(q0);
var z4 = q0.exports;
const Qx = /* @__PURE__ */ sI(z4);
var $4 = {};
fe($4, { ConsoleCallbackHandler: () => Vw });
function $t(t, A) {
  return `${t.open}${A}${t.close}`;
}
function jr(t, A) {
  try {
    return JSON.stringify(t, null, 2);
  } catch {
    return A;
  }
}
function Lk(t) {
  return typeof t == "string" ? t.trim() : t == null ? t : jr(t, t.toString());
}
function vs(t) {
  if (!t.end_time) return "";
  const A = t.end_time - t.start_time;
  return A < 1e3 ? `${A}ms` : `${(A / 1e3).toFixed(2)}s`;
}
const { color: lr } = Qx;
var Vw = class extends oI {
  constructor() {
    super(...arguments);
    R(this, "name", "console_callback_handler");
  }
  /**
  * Method used to persist the run. In this case, it simply returns a
  * resolved promise as there's no persistence logic.
  * @param _run The run to persist.
  * @returns A resolved promise.
  */
  persistRun(A) {
    return Promise.resolve();
  }
  /**
  * Method used to get all the parent runs of a given run.
  * @param run The run whose parents are to be retrieved.
  * @returns An array of parent runs.
  */
  getParents(A) {
    const e = [];
    let r = A;
    for (; r.parent_run_id; ) {
      const i = this.runMap.get(r.parent_run_id);
      if (i)
        e.push(i), r = i;
      else break;
    }
    return e;
  }
  /**
  * Method used to get a string representation of the run's lineage, which
  * is used in logging.
  * @param run The run whose lineage is to be retrieved.
  * @returns A string representation of the run's lineage.
  */
  getBreadcrumbs(A) {
    const r = [...this.getParents(A).reverse(), A].map((i, n, s) => {
      const a = `${i.execution_order}:${i.run_type}:${i.name}`;
      return n === s.length - 1 ? $t(Qx.bold, a) : a;
    }).join(" > ");
    return $t(lr.grey, r);
  }
  /**
  * Method used to log the start of a chain run.
  * @param run The chain run that has started.
  * @returns void
  */
  onChainStart(A) {
    const e = this.getBreadcrumbs(A);
    console.log(`${$t(lr.green, "[chain/start]")} [${e}] Entering Chain run with input: ${jr(A.inputs, "[inputs]")}`);
  }
  /**
  * Method used to log the end of a chain run.
  * @param run The chain run that has ended.
  * @returns void
  */
  onChainEnd(A) {
    const e = this.getBreadcrumbs(A);
    console.log(`${$t(lr.cyan, "[chain/end]")} [${e}] [${vs(A)}] Exiting Chain run with output: ${jr(A.outputs, "[outputs]")}`);
  }
  /**
  * Method used to log any errors of a chain run.
  * @param run The chain run that has errored.
  * @returns void
  */
  onChainError(A) {
    const e = this.getBreadcrumbs(A);
    console.log(`${$t(lr.red, "[chain/error]")} [${e}] [${vs(A)}] Chain run errored with error: ${jr(A.error, "[error]")}`);
  }
  /**
  * Method used to log the start of an LLM run.
  * @param run The LLM run that has started.
  * @returns void
  */
  onLLMStart(A) {
    const e = this.getBreadcrumbs(A), r = "prompts" in A.inputs ? { prompts: A.inputs.prompts.map((i) => i.trim()) } : A.inputs;
    console.log(`${$t(lr.green, "[llm/start]")} [${e}] Entering LLM run with input: ${jr(r, "[inputs]")}`);
  }
  /**
  * Method used to log the end of an LLM run.
  * @param run The LLM run that has ended.
  * @returns void
  */
  onLLMEnd(A) {
    const e = this.getBreadcrumbs(A);
    console.log(`${$t(lr.cyan, "[llm/end]")} [${e}] [${vs(A)}] Exiting LLM run with output: ${jr(A.outputs, "[response]")}`);
  }
  /**
  * Method used to log any errors of an LLM run.
  * @param run The LLM run that has errored.
  * @returns void
  */
  onLLMError(A) {
    const e = this.getBreadcrumbs(A);
    console.log(`${$t(lr.red, "[llm/error]")} [${e}] [${vs(A)}] LLM run errored with error: ${jr(A.error, "[error]")}`);
  }
  /**
  * Method used to log the start of a tool run.
  * @param run The tool run that has started.
  * @returns void
  */
  onToolStart(A) {
    const e = this.getBreadcrumbs(A);
    console.log(`${$t(lr.green, "[tool/start]")} [${e}] Entering Tool run with input: "${Lk(A.inputs.input)}"`);
  }
  /**
  * Method used to log the end of a tool run.
  * @param run The tool run that has ended.
  * @returns void
  */
  onToolEnd(A) {
    var r;
    const e = this.getBreadcrumbs(A);
    console.log(`${$t(lr.cyan, "[tool/end]")} [${e}] [${vs(A)}] Exiting Tool run with output: "${Lk((r = A.outputs) == null ? void 0 : r.output)}"`);
  }
  /**
  * Method used to log any errors of a tool run.
  * @param run The tool run that has errored.
  * @returns void
  */
  onToolError(A) {
    const e = this.getBreadcrumbs(A);
    console.log(`${$t(lr.red, "[tool/error]")} [${e}] [${vs(A)}] Tool run errored with error: ${jr(A.error, "[error]")}`);
  }
  /**
  * Method used to log the start of a retriever run.
  * @param run The retriever run that has started.
  * @returns void
  */
  onRetrieverStart(A) {
    const e = this.getBreadcrumbs(A);
    console.log(`${$t(lr.green, "[retriever/start]")} [${e}] Entering Retriever run with input: ${jr(A.inputs, "[inputs]")}`);
  }
  /**
  * Method used to log the end of a retriever run.
  * @param run The retriever run that has ended.
  * @returns void
  */
  onRetrieverEnd(A) {
    const e = this.getBreadcrumbs(A);
    console.log(`${$t(lr.cyan, "[retriever/end]")} [${e}] [${vs(A)}] Exiting Retriever run with output: ${jr(A.outputs, "[outputs]")}`);
  }
  /**
  * Method used to log any errors of a retriever run.
  * @param run The retriever run that has errored.
  * @returns void
  */
  onRetrieverError(A) {
    const e = this.getBreadcrumbs(A);
    console.log(`${$t(lr.red, "[retriever/error]")} [${e}] [${vs(A)}] Retriever run errored with error: ${jr(A.error, "[error]")}`);
  }
  /**
  * Method used to log the action selected by the agent.
  * @param run The run in which the agent action occurred.
  * @returns void
  */
  onAgentAction(A) {
    const e = A, r = this.getBreadcrumbs(A);
    console.log(`${$t(lr.blue, "[agent/action]")} [${r}] Agent selected action: ${jr(e.actions[e.actions.length - 1], "[action]")}`);
  }
};
let uy;
const dx = () => {
  if (uy === void 0) {
    const t = hn("LANGCHAIN_CALLBACKS_BACKGROUND") === "false" ? { blockOnRootRunFinalization: !0 } : {};
    uy = new lx(t);
  }
  return uy;
};
let A3 = class {
  getStore() {
  }
  run(A, e) {
    return e();
  }
};
const cy = Symbol.for("ls:tracing_async_local_storage"), e3 = new A3();
let t3 = class {
  getInstance() {
    return globalThis[cy] ?? e3;
  }
  initializeGlobalInstance(A) {
    globalThis[cy] === void 0 && (globalThis[cy] = A);
  }
};
const r3 = new t3();
function i3(t = !1) {
  const A = r3.getInstance().getStore();
  if (!t && A === void 0)
    throw new Error(`Could not get the current run tree.

Please make sure you are calling this method within a traceable function and that tracing is enabled.`);
  return A;
}
function j0(t) {
  return typeof t == "function" && "langsmith:traceable" in t;
}
var n3 = {};
fe(n3, { LangChainTracer: () => KQ });
var KQ = class fx extends oI {
  constructor(e = {}) {
    super(e);
    R(this, "name", "langchain_tracer");
    R(this, "projectName");
    R(this, "exampleId");
    R(this, "client");
    R(this, "replicas");
    R(this, "usesRunTreeMap", !0);
    const { exampleId: r, projectName: i, client: n, replicas: s } = e;
    this.projectName = i ?? YL(), this.replicas = s, this.exampleId = r, this.client = n ?? dx();
    const a = fx.getTraceableRunTree();
    a && this.updateFromRunTree(a);
  }
  async persistRun(e) {
  }
  async onRunCreate(e) {
    const r = this.getRunTreeWithTracingConfig(e.id);
    await (r == null ? void 0 : r.postRun());
  }
  async onRunUpdate(e) {
    const r = this.getRunTreeWithTracingConfig(e.id);
    await (r == null ? void 0 : r.patchRun());
  }
  getRun(e) {
    return this.runTreeMap.get(e);
  }
  updateFromRunTree(e) {
    this.runTreeMap.set(e.id, e);
    let r = e;
    const i = /* @__PURE__ */ new Set();
    for (; r.parent_run && !(i.has(r.id) || (i.add(r.id), !r.parent_run)); )
      r = r.parent_run;
    i.clear();
    const n = [r];
    for (; n.length > 0; ) {
      const s = n.shift();
      !s || i.has(s.id) || (i.add(s.id), this.runTreeMap.set(s.id, s), s.child_runs && n.push(...s.child_runs));
    }
    this.client = e.client ?? this.client, this.replicas = e.replicas ?? this.replicas, this.projectName = e.project_name ?? this.projectName, this.exampleId = e.reference_example_id ?? this.exampleId;
  }
  getRunTreeWithTracingConfig(e) {
    const r = this.runTreeMap.get(e);
    if (r)
      return new hr({
        ...r,
        client: this.client,
        project_name: this.projectName,
        replicas: this.replicas,
        reference_example_id: this.exampleId,
        tracingEnabled: !0
      });
  }
  static getTraceableRunTree() {
    try {
      return i3(!0);
    } catch {
      return;
    }
  }
};
let og;
function s3() {
  const t = "default" in os ? os.default : os;
  return new t({
    autoStart: !0,
    concurrency: 1
  });
}
function a3() {
  return typeof og > "u" && (og = s3()), og;
}
async function ut(t, A) {
  if (A === !0) {
    const e = VC();
    e !== void 0 ? await e.run(void 0, async () => t()) : await t();
  } else
    og = a3(), og.add(async () => {
      const e = VC();
      e !== void 0 ? await e.run(void 0, async () => t()) : await t();
    });
}
async function o3() {
  const t = dx();
  await Promise.allSettled([typeof og < "u" ? og.onIdle() : Promise.resolve(), t.awaitPendingTraceBatches()]);
}
var g3 = {};
fe(g3, {
  awaitAllCallbacks: () => o3,
  consumeCallback: () => ut
});
const u3 = (t) => !![
  "LANGSMITH_TRACING_V2",
  "LANGCHAIN_TRACING_V2",
  "LANGSMITH_TRACING",
  "LANGCHAIN_TRACING"
].find((e) => hn(e) === "true");
function px(t) {
  var r;
  const A = VC();
  if (A === void 0) return;
  const e = A.getStore();
  return (r = e == null ? void 0 : e[UC]) == null ? void 0 : r[t];
}
const c3 = Symbol("lc:configure_hooks"), I3 = () => px(c3) || [];
var C3 = {};
fe(C3, {
  BaseCallbackManager: () => yx,
  BaseRunManager: () => GE,
  CallbackManager: () => fr,
  CallbackManagerForChainRun: () => mx,
  CallbackManagerForLLMRun: () => Zw,
  CallbackManagerForRetrieverRun: () => wx,
  CallbackManagerForToolRun: () => Dx,
  ensureHandler: () => ZC,
  parseCallbackConfigArg: () => $f
});
function $f(t) {
  return t ? Array.isArray(t) || "name" in t ? { callbacks: t } : t : {};
}
var yx = class {
  setHandler(t) {
    return this.setHandlers([t]);
  }
}, GE = class {
  constructor(t, A, e, r, i, n, s, a) {
    this.runId = t, this.handlers = A, this.inheritableHandlers = e, this.tags = r, this.inheritableTags = i, this.metadata = n, this.inheritableMetadata = s, this._parentRunId = a;
  }
  get parentRunId() {
    return this._parentRunId;
  }
  async handleText(t) {
    await Promise.all(this.handlers.map((A) => ut(async () => {
      var e;
      try {
        await ((e = A.handleText) == null ? void 0 : e.call(A, t, this.runId, this._parentRunId, this.tags));
      } catch (r) {
        if ((A.raiseError ? console.error : console.warn)(`Error in handler ${A.constructor.name}, handleText: ${r}`), A.raiseError) throw r;
      }
    }, A.awaitHandlers)));
  }
  async handleCustomEvent(t, A, e, r, i) {
    await Promise.all(this.handlers.map((n) => ut(async () => {
      var s;
      try {
        await ((s = n.handleCustomEvent) == null ? void 0 : s.call(n, t, A, this.runId, this.tags, this.metadata));
      } catch (a) {
        if ((n.raiseError ? console.error : console.warn)(`Error in handler ${n.constructor.name}, handleCustomEvent: ${a}`), n.raiseError) throw a;
      }
    }, n.awaitHandlers)));
  }
}, wx = class extends GE {
  getChild(t) {
    const A = new fr(this.runId);
    return A.setHandlers(this.inheritableHandlers), A.addTags(this.inheritableTags), A.addMetadata(this.inheritableMetadata), t && A.addTags([t], !1), A;
  }
  async handleRetrieverEnd(t) {
    await Promise.all(this.handlers.map((A) => ut(async () => {
      var e;
      if (!A.ignoreRetriever) try {
        await ((e = A.handleRetrieverEnd) == null ? void 0 : e.call(A, t, this.runId, this._parentRunId, this.tags));
      } catch (r) {
        if ((A.raiseError ? console.error : console.warn)(`Error in handler ${A.constructor.name}, handleRetriever`), A.raiseError) throw r;
      }
    }, A.awaitHandlers)));
  }
  async handleRetrieverError(t) {
    await Promise.all(this.handlers.map((A) => ut(async () => {
      var e;
      if (!A.ignoreRetriever) try {
        await ((e = A.handleRetrieverError) == null ? void 0 : e.call(A, t, this.runId, this._parentRunId, this.tags));
      } catch (r) {
        if ((A.raiseError ? console.error : console.warn)(`Error in handler ${A.constructor.name}, handleRetrieverError: ${r}`), A.raiseError) throw t;
      }
    }, A.awaitHandlers)));
  }
}, Zw = class extends GE {
  async handleLLMNewToken(t, A, e, r, i, n) {
    await Promise.all(this.handlers.map((s) => ut(async () => {
      var a;
      if (!s.ignoreLLM) try {
        await ((a = s.handleLLMNewToken) == null ? void 0 : a.call(s, t, A ?? {
          prompt: 0,
          completion: 0
        }, this.runId, this._parentRunId, this.tags, n));
      } catch (g) {
        if ((s.raiseError ? console.error : console.warn)(`Error in handler ${s.constructor.name}, handleLLMNewToken: ${g}`), s.raiseError) throw g;
      }
    }, s.awaitHandlers)));
  }
  async handleLLMError(t, A, e, r, i) {
    await Promise.all(this.handlers.map((n) => ut(async () => {
      var s;
      if (!n.ignoreLLM) try {
        await ((s = n.handleLLMError) == null ? void 0 : s.call(n, t, this.runId, this._parentRunId, this.tags, i));
      } catch (a) {
        if ((n.raiseError ? console.error : console.warn)(`Error in handler ${n.constructor.name}, handleLLMError: ${a}`), n.raiseError) throw a;
      }
    }, n.awaitHandlers)));
  }
  async handleLLMEnd(t, A, e, r, i) {
    await Promise.all(this.handlers.map((n) => ut(async () => {
      var s;
      if (!n.ignoreLLM) try {
        await ((s = n.handleLLMEnd) == null ? void 0 : s.call(n, t, this.runId, this._parentRunId, this.tags, i));
      } catch (a) {
        if ((n.raiseError ? console.error : console.warn)(`Error in handler ${n.constructor.name}, handleLLMEnd: ${a}`), n.raiseError) throw a;
      }
    }, n.awaitHandlers)));
  }
}, mx = class extends GE {
  getChild(t) {
    const A = new fr(this.runId);
    return A.setHandlers(this.inheritableHandlers), A.addTags(this.inheritableTags), A.addMetadata(this.inheritableMetadata), t && A.addTags([t], !1), A;
  }
  async handleChainError(t, A, e, r, i) {
    await Promise.all(this.handlers.map((n) => ut(async () => {
      var s;
      if (!n.ignoreChain) try {
        await ((s = n.handleChainError) == null ? void 0 : s.call(n, t, this.runId, this._parentRunId, this.tags, i));
      } catch (a) {
        if ((n.raiseError ? console.error : console.warn)(`Error in handler ${n.constructor.name}, handleChainError: ${a}`), n.raiseError) throw a;
      }
    }, n.awaitHandlers)));
  }
  async handleChainEnd(t, A, e, r, i) {
    await Promise.all(this.handlers.map((n) => ut(async () => {
      var s;
      if (!n.ignoreChain) try {
        await ((s = n.handleChainEnd) == null ? void 0 : s.call(n, t, this.runId, this._parentRunId, this.tags, i));
      } catch (a) {
        if ((n.raiseError ? console.error : console.warn)(`Error in handler ${n.constructor.name}, handleChainEnd: ${a}`), n.raiseError) throw a;
      }
    }, n.awaitHandlers)));
  }
  async handleAgentAction(t) {
    await Promise.all(this.handlers.map((A) => ut(async () => {
      var e;
      if (!A.ignoreAgent) try {
        await ((e = A.handleAgentAction) == null ? void 0 : e.call(A, t, this.runId, this._parentRunId, this.tags));
      } catch (r) {
        if ((A.raiseError ? console.error : console.warn)(`Error in handler ${A.constructor.name}, handleAgentAction: ${r}`), A.raiseError) throw r;
      }
    }, A.awaitHandlers)));
  }
  async handleAgentEnd(t) {
    await Promise.all(this.handlers.map((A) => ut(async () => {
      var e;
      if (!A.ignoreAgent) try {
        await ((e = A.handleAgentEnd) == null ? void 0 : e.call(A, t, this.runId, this._parentRunId, this.tags));
      } catch (r) {
        if ((A.raiseError ? console.error : console.warn)(`Error in handler ${A.constructor.name}, handleAgentEnd: ${r}`), A.raiseError) throw r;
      }
    }, A.awaitHandlers)));
  }
}, Dx = class extends GE {
  getChild(t) {
    const A = new fr(this.runId);
    return A.setHandlers(this.inheritableHandlers), A.addTags(this.inheritableTags), A.addMetadata(this.inheritableMetadata), t && A.addTags([t], !1), A;
  }
  async handleToolError(t) {
    await Promise.all(this.handlers.map((A) => ut(async () => {
      var e;
      if (!A.ignoreAgent) try {
        await ((e = A.handleToolError) == null ? void 0 : e.call(A, t, this.runId, this._parentRunId, this.tags));
      } catch (r) {
        if ((A.raiseError ? console.error : console.warn)(`Error in handler ${A.constructor.name}, handleToolError: ${r}`), A.raiseError) throw r;
      }
    }, A.awaitHandlers)));
  }
  async handleToolEnd(t) {
    await Promise.all(this.handlers.map((A) => ut(async () => {
      var e;
      if (!A.ignoreAgent) try {
        await ((e = A.handleToolEnd) == null ? void 0 : e.call(A, t, this.runId, this._parentRunId, this.tags));
      } catch (r) {
        if ((A.raiseError ? console.error : console.warn)(`Error in handler ${A.constructor.name}, handleToolEnd: ${r}`), A.raiseError) throw r;
      }
    }, A.awaitHandlers)));
  }
}, fr = class yC extends yx {
  constructor(e, r) {
    super();
    R(this, "handlers", []);
    R(this, "inheritableHandlers", []);
    R(this, "tags", []);
    R(this, "inheritableTags", []);
    R(this, "metadata", {});
    R(this, "inheritableMetadata", {});
    R(this, "name", "callback_manager");
    R(this, "_parentRunId");
    this.handlers = (r == null ? void 0 : r.handlers) ?? this.handlers, this.inheritableHandlers = (r == null ? void 0 : r.inheritableHandlers) ?? this.inheritableHandlers, this.tags = (r == null ? void 0 : r.tags) ?? this.tags, this.inheritableTags = (r == null ? void 0 : r.inheritableTags) ?? this.inheritableTags, this.metadata = (r == null ? void 0 : r.metadata) ?? this.metadata, this.inheritableMetadata = (r == null ? void 0 : r.inheritableMetadata) ?? this.inheritableMetadata, this._parentRunId = e;
  }
  /**
  * Gets the parent run ID, if any.
  *
  * @returns The parent run ID.
  */
  getParentRunId() {
    return this._parentRunId;
  }
  async handleLLMStart(e, r, i = void 0, n = void 0, s = void 0, a = void 0, g = void 0, o = void 0) {
    return Promise.all(r.map(async (u, I) => {
      const c = I === 0 && i ? i : Hn();
      return await Promise.all(this.handlers.map((C) => {
        if (!C.ignoreLLM)
          return Yg(C) && C._createRunForLLMStart(e, [u], c, this._parentRunId, s, this.tags, this.metadata, o), ut(async () => {
            var E;
            try {
              await ((E = C.handleLLMStart) == null ? void 0 : E.call(C, e, [u], c, this._parentRunId, s, this.tags, this.metadata, o));
            } catch (l) {
              if ((C.raiseError ? console.error : console.warn)(`Error in handler ${C.constructor.name}, handleLLMStart: ${l}`), C.raiseError) throw l;
            }
          }, C.awaitHandlers);
      })), new Zw(c, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);
    }));
  }
  async handleChatModelStart(e, r, i = void 0, n = void 0, s = void 0, a = void 0, g = void 0, o = void 0) {
    return Promise.all(r.map(async (u, I) => {
      const c = I === 0 && i ? i : Hn();
      return await Promise.all(this.handlers.map((C) => {
        if (!C.ignoreLLM)
          return Yg(C) && C._createRunForChatModelStart(e, [u], c, this._parentRunId, s, this.tags, this.metadata, o), ut(async () => {
            var E, l;
            try {
              if (C.handleChatModelStart) await ((E = C.handleChatModelStart) == null ? void 0 : E.call(C, e, [u], c, this._parentRunId, s, this.tags, this.metadata, o));
              else if (C.handleLLMStart) {
                const B = R0(u);
                await ((l = C.handleLLMStart) == null ? void 0 : l.call(C, e, [B], c, this._parentRunId, s, this.tags, this.metadata, o));
              }
            } catch (B) {
              if ((C.raiseError ? console.error : console.warn)(`Error in handler ${C.constructor.name}, handleLLMStart: ${B}`), C.raiseError) throw B;
            }
          }, C.awaitHandlers);
      })), new Zw(c, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);
    }));
  }
  async handleChainStart(e, r, i = Hn(), n = void 0, s = void 0, a = void 0, g = void 0) {
    return await Promise.all(this.handlers.map((o) => {
      if (!o.ignoreChain)
        return Yg(o) && o._createRunForChainStart(e, r, i, this._parentRunId, this.tags, this.metadata, n, g), ut(async () => {
          var u;
          try {
            await ((u = o.handleChainStart) == null ? void 0 : u.call(o, e, r, i, this._parentRunId, this.tags, this.metadata, n, g));
          } catch (I) {
            if ((o.raiseError ? console.error : console.warn)(`Error in handler ${o.constructor.name}, handleChainStart: ${I}`), o.raiseError) throw I;
          }
        }, o.awaitHandlers);
    })), new mx(i, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);
  }
  async handleToolStart(e, r, i = Hn(), n = void 0, s = void 0, a = void 0, g = void 0) {
    return await Promise.all(this.handlers.map((o) => {
      if (!o.ignoreAgent)
        return Yg(o) && o._createRunForToolStart(e, r, i, this._parentRunId, this.tags, this.metadata, g), ut(async () => {
          var u;
          try {
            await ((u = o.handleToolStart) == null ? void 0 : u.call(o, e, r, i, this._parentRunId, this.tags, this.metadata, g));
          } catch (I) {
            if ((o.raiseError ? console.error : console.warn)(`Error in handler ${o.constructor.name}, handleToolStart: ${I}`), o.raiseError) throw I;
          }
        }, o.awaitHandlers);
    })), new Dx(i, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);
  }
  async handleRetrieverStart(e, r, i = Hn(), n = void 0, s = void 0, a = void 0, g = void 0) {
    return await Promise.all(this.handlers.map((o) => {
      if (!o.ignoreRetriever)
        return Yg(o) && o._createRunForRetrieverStart(e, r, i, this._parentRunId, this.tags, this.metadata, g), ut(async () => {
          var u;
          try {
            await ((u = o.handleRetrieverStart) == null ? void 0 : u.call(o, e, r, i, this._parentRunId, this.tags, this.metadata, g));
          } catch (I) {
            if ((o.raiseError ? console.error : console.warn)(`Error in handler ${o.constructor.name}, handleRetrieverStart: ${I}`), o.raiseError) throw I;
          }
        }, o.awaitHandlers);
    })), new wx(i, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);
  }
  async handleCustomEvent(e, r, i, n, s) {
    await Promise.all(this.handlers.map((a) => ut(async () => {
      var g;
      if (!a.ignoreCustomEvent) try {
        await ((g = a.handleCustomEvent) == null ? void 0 : g.call(a, e, r, i, this.tags, this.metadata));
      } catch (o) {
        if ((a.raiseError ? console.error : console.warn)(`Error in handler ${a.constructor.name}, handleCustomEvent: ${o}`), a.raiseError) throw o;
      }
    }, a.awaitHandlers)));
  }
  addHandler(e, r = !0) {
    this.handlers.push(e), r && this.inheritableHandlers.push(e);
  }
  removeHandler(e) {
    this.handlers = this.handlers.filter((r) => r !== e), this.inheritableHandlers = this.inheritableHandlers.filter((r) => r !== e);
  }
  setHandlers(e, r = !0) {
    this.handlers = [], this.inheritableHandlers = [];
    for (const i of e) this.addHandler(i, r);
  }
  addTags(e, r = !0) {
    this.removeTags(e), this.tags.push(...e), r && this.inheritableTags.push(...e);
  }
  removeTags(e) {
    this.tags = this.tags.filter((r) => !e.includes(r)), this.inheritableTags = this.inheritableTags.filter((r) => !e.includes(r));
  }
  addMetadata(e, r = !0) {
    this.metadata = {
      ...this.metadata,
      ...e
    }, r && (this.inheritableMetadata = {
      ...this.inheritableMetadata,
      ...e
    });
  }
  removeMetadata(e) {
    for (const r of Object.keys(e))
      delete this.metadata[r], delete this.inheritableMetadata[r];
  }
  copy(e = [], r = !0) {
    const i = new yC(this._parentRunId);
    for (const n of this.handlers) {
      const s = this.inheritableHandlers.includes(n);
      i.addHandler(n, s);
    }
    for (const n of this.tags) {
      const s = this.inheritableTags.includes(n);
      i.addTags([n], s);
    }
    for (const n of Object.keys(this.metadata)) {
      const s = Object.keys(this.inheritableMetadata).includes(n);
      i.addMetadata({ [n]: this.metadata[n] }, s);
    }
    for (const n of e)
      i.handlers.filter((s) => s.name === "console_callback_handler").some((s) => s.name === n.name) || i.addHandler(n, r);
    return i;
  }
  static fromHandlers(e) {
    class r extends LE {
      constructor() {
        super();
        R(this, "name", Hn());
        Object.assign(this, e);
      }
    }
    const i = new this();
    return i.addHandler(new r()), i;
  }
  static configure(e, r, i, n, s, a, g) {
    return this._configureSync(e, r, i, n, s, a, g);
  }
  static _configureSync(e, r, i, n, s, a, g) {
    var C;
    let o;
    (e || r) && (Array.isArray(e) || !e ? (o = new yC(), o.setHandlers((e == null ? void 0 : e.map(ZC)) ?? [], !0)) : o = e, o = o.copy(Array.isArray(r) ? r.map(ZC) : r == null ? void 0 : r.handlers, !1));
    const u = hn("LANGCHAIN_VERBOSE") === "true" || (g == null ? void 0 : g.verbose), I = ((C = KQ.getTraceableRunTree()) == null ? void 0 : C.tracingEnabled) || u3(), c = I || (hn("LANGCHAIN_TRACING") ?? !1);
    if (u || c) {
      if (o || (o = new yC()), u && !o.handlers.some((E) => E.name === Vw.prototype.name)) {
        const E = new Vw();
        o.addHandler(E, !0);
      }
      if (c && !o.handlers.some((E) => E.name === "langchain_tracer") && I) {
        const E = new KQ();
        o.addHandler(E, !0);
      }
      if (I) {
        const E = KQ.getTraceableRunTree();
        if (E && o._parentRunId === void 0) {
          o._parentRunId = E.id;
          const l = o.handlers.find((B) => B.name === "langchain_tracer");
          l == null || l.updateFromRunTree(E);
        }
      }
    }
    for (const { contextVar: E, inheritable: l = !0, handlerClass: B, envVar: h } of I3()) {
      const Q = h && hn(h) === "true" && B;
      let f;
      const p = E !== void 0 ? px(E) : void 0;
      p && HL(p) ? f = p : Q && (f = new B({})), f !== void 0 && (o || (o = new yC()), o.handlers.some((y) => y.name === f.name) || o.addHandler(f, l));
    }
    return (i || n) && o && (o.addTags(i ?? []), o.addTags(n ?? [], !1)), (s || a) && o && (o.addMetadata(s ?? {}), o.addMetadata(a ?? {}, !1)), o;
  }
};
function ZC(t) {
  return "name" in t ? t : LE.fromMethods(t);
}
var Sx = class {
  getStore() {
  }
  run(t, A) {
    return A();
  }
  enterWith(t) {
  }
};
const l3 = new Sx(), xk = Symbol.for("lc:child_config");
var B3 = class {
  getInstance() {
    return VC() ?? l3;
  }
  getRunnableConfig() {
    var A, e;
    return (e = (A = this.getInstance().getStore()) == null ? void 0 : A.extra) == null ? void 0 : e[xk];
  }
  runWithConfig(t, A, e) {
    var o;
    const r = fr._configureSync(t == null ? void 0 : t.callbacks, void 0, t == null ? void 0 : t.tags, void 0, t == null ? void 0 : t.metadata), i = this.getInstance(), n = i.getStore(), s = r == null ? void 0 : r.getParentRunId(), a = (o = r == null ? void 0 : r.handlers) == null ? void 0 : o.find((u) => (u == null ? void 0 : u.name) === "langchain_tracer");
    let g;
    return a && s ? g = a.getRunTreeWithTracingConfig(s) : e || (g = new hr({
      name: "<runnable_lambda>",
      tracingEnabled: !1
    })), g && (g.extra = {
      ...g.extra,
      [xk]: t
    }), n !== void 0 && n[UC] !== void 0 && (g === void 0 && (g = {}), g[UC] = n[UC]), i.run(g, A);
  }
  initializeGlobalInstance(t) {
    VC() === void 0 && AO(t);
  }
};
const Ri = new B3();
var E3 = {};
fe(E3, {
  AsyncLocalStorageProviderSingleton: () => Ri,
  MockAsyncLocalStorage: () => Sx,
  _CONTEXT_VARIABLES_KEY: () => UC
});
const Iy = 25;
async function Jr(t) {
  return fr._configureSync(t == null ? void 0 : t.callbacks, void 0, t == null ? void 0 : t.tags, void 0, t == null ? void 0 : t.metadata);
}
function wd(...t) {
  const A = {};
  for (const e of t.filter((r) => !!r)) for (const r of Object.keys(e)) if (r === "metadata") A[r] = {
    ...A[r],
    ...e[r]
  };
  else if (r === "tags") {
    const i = A[r] ?? [];
    A[r] = [...new Set(i.concat(e[r] ?? []))];
  } else if (r === "configurable") A[r] = {
    ...A[r],
    ...e[r]
  };
  else if (r === "timeout")
    A.timeout === void 0 ? A.timeout = e.timeout : e.timeout !== void 0 && (A.timeout = Math.min(A.timeout, e.timeout));
  else if (r === "signal")
    A.signal === void 0 ? A.signal = e.signal : e.signal !== void 0 && ("any" in AbortSignal ? A.signal = AbortSignal.any([A.signal, e.signal]) : A.signal = e.signal);
  else if (r === "callbacks") {
    const i = A.callbacks, n = e.callbacks;
    if (Array.isArray(n)) if (!i) A.callbacks = n;
    else if (Array.isArray(i)) A.callbacks = i.concat(n);
    else {
      const s = i.copy();
      for (const a of n) s.addHandler(ZC(a), !0);
      A.callbacks = s;
    }
    else if (n) if (!i) A.callbacks = n;
    else if (Array.isArray(i)) {
      const s = n.copy();
      for (const a of i) s.addHandler(ZC(a), !0);
      A.callbacks = s;
    } else A.callbacks = new fr(n._parentRunId, {
      handlers: i.handlers.concat(n.handlers),
      inheritableHandlers: i.inheritableHandlers.concat(n.inheritableHandlers),
      tags: Array.from(new Set(i.tags.concat(n.tags))),
      inheritableTags: Array.from(new Set(i.inheritableTags.concat(n.inheritableTags))),
      metadata: {
        ...i.metadata,
        ...n.metadata
      }
    });
  } else {
    const i = r;
    A[i] = e[i] ?? A[i];
  }
  return A;
}
const h3 = /* @__PURE__ */ new Set([
  "string",
  "number",
  "boolean"
]);
function Se(t) {
  var r;
  const A = Ri.getRunnableConfig();
  let e = {
    tags: [],
    metadata: {},
    recursionLimit: 25,
    runId: void 0
  };
  if (A) {
    const { runId: i, runName: n, ...s } = A;
    e = Object.entries(s).reduce((a, [g, o]) => (o !== void 0 && (a[g] = o), a), e);
  }
  if (t && (e = Object.entries(t).reduce((i, [n, s]) => (s !== void 0 && (i[n] = s), i), e)), e != null && e.configurable)
    for (const i of Object.keys(e.configurable)) h3.has(typeof e.configurable[i]) && !((r = e.metadata) != null && r[i]) && (e.metadata || (e.metadata = {}), e.metadata[i] = e.configurable[i]);
  if (e.timeout !== void 0) {
    if (e.timeout <= 0) throw new Error("Timeout must be a positive number");
    const i = AbortSignal.timeout(e.timeout);
    e.signal !== void 0 ? "any" in AbortSignal && (e.signal = AbortSignal.any([e.signal, i])) : e.signal = i, delete e.timeout;
  }
  return e;
}
function Ye(t = {}, { callbacks: A, maxConcurrency: e, recursionLimit: r, runName: i, configurable: n, runId: s } = {}) {
  const a = Se(t);
  return A !== void 0 && (delete a.runName, a.callbacks = A), r !== void 0 && (a.recursionLimit = r), e !== void 0 && (a.maxConcurrency = e), i !== void 0 && (a.runName = i), n !== void 0 && (a.configurable = {
    ...a.configurable,
    ...n
  }), s !== void 0 && delete a.runId, a;
}
function ls(t) {
  if (t)
    return {
      configurable: t.configurable,
      recursionLimit: t.recursionLimit,
      callbacks: t.callbacks,
      tags: t.tags,
      metadata: t.metadata,
      maxConcurrency: t.maxConcurrency,
      timeout: t.timeout,
      signal: t.signal,
      store: t.store
    };
}
async function Bs(t, A) {
  if (A === void 0) return t;
  let e;
  return Promise.race([t.catch((r) => {
    if (!(A != null && A.aborted))
      throw r;
  }), new Promise((r, i) => {
    e = () => {
      i(XC(A));
    }, A.addEventListener("abort", e), A.aborted && i(XC(A));
  })]).finally(() => A.removeEventListener("abort", e));
}
function XC(t) {
  return (t == null ? void 0 : t.reason) instanceof Error ? t.reason : typeof (t == null ? void 0 : t.reason) == "string" ? new Error(t.reason) : /* @__PURE__ */ new Error("Aborted");
}
var Q3 = {};
fe(Q3, {
  AsyncGeneratorWithSetup: () => mg,
  IterableReadableStream: () => bi,
  atee: () => W0,
  concat: () => _a,
  pipeGeneratorWithSetup: () => Fx
});
var bi = class Xw extends ReadableStream {
  constructor() {
    super(...arguments);
    R(this, "reader");
  }
  ensureReader() {
    this.reader || (this.reader = this.getReader());
  }
  async next() {
    this.ensureReader();
    try {
      const e = await this.reader.read();
      return e.done ? (this.reader.releaseLock(), {
        done: !0,
        value: void 0
      }) : {
        done: !1,
        value: e.value
      };
    } catch (e) {
      throw this.reader.releaseLock(), e;
    }
  }
  async return() {
    if (this.ensureReader(), this.locked) {
      const e = this.reader.cancel();
      this.reader.releaseLock(), await e;
    }
    return {
      done: !0,
      value: void 0
    };
  }
  async throw(e) {
    if (this.ensureReader(), this.locked) {
      const r = this.reader.cancel();
      this.reader.releaseLock(), await r;
    }
    throw e;
  }
  [Symbol.asyncIterator]() {
    return this;
  }
  async [Symbol.asyncDispose]() {
    await this.return();
  }
  static fromReadableStream(e) {
    const r = e.getReader();
    return new Xw({
      start(i) {
        return n();
        function n() {
          return r.read().then(({ done: s, value: a }) => {
            if (s) {
              i.close();
              return;
            }
            return i.enqueue(a), n();
          });
        }
      },
      cancel() {
        r.releaseLock();
      }
    });
  }
  static fromAsyncGenerator(e) {
    return new Xw({
      async pull(r) {
        const { value: i, done: n } = await e.next();
        n && r.close(), r.enqueue(i);
      },
      async cancel(r) {
        await e.return(r);
      }
    });
  }
};
function W0(t, A = 2) {
  const e = Array.from({ length: A }, () => []);
  return e.map(async function* (i) {
    for (; ; ) if (i.length === 0) {
      const n = await t.next();
      for (const s of e) s.push(n);
    } else {
      if (i[0].done) return;
      yield i.shift().value;
    }
  });
}
function _a(t, A) {
  if (Array.isArray(t) && Array.isArray(A)) return t.concat(A);
  if (typeof t == "string" && typeof A == "string") return t + A;
  if (typeof t == "number" && typeof A == "number") return t + A;
  if ("concat" in t && typeof t.concat == "function") return t.concat(A);
  if (typeof t == "object" && typeof A == "object") {
    const e = { ...t };
    for (const [r, i] of Object.entries(A)) r in e && !Array.isArray(e[r]) ? e[r] = _a(e[r], i) : e[r] = i;
    return e;
  } else throw new Error(`Cannot concat ${typeof t} and ${typeof A}`);
}
var mg = class {
  constructor(t) {
    R(this, "generator");
    R(this, "setup");
    R(this, "config");
    R(this, "signal");
    R(this, "firstResult");
    R(this, "firstResultUsed", !1);
    var A;
    this.generator = t.generator, this.config = t.config, this.signal = t.signal ?? ((A = this.config) == null ? void 0 : A.signal), this.setup = new Promise((e, r) => {
      Ri.runWithConfig(ls(t.config), async () => {
        this.firstResult = t.generator.next(), t.startSetup ? this.firstResult.then(t.startSetup).then(e, r) : this.firstResult.then((i) => e(void 0), r);
      }, !0);
    });
  }
  async next(...t) {
    var A;
    return (A = this.signal) == null || A.throwIfAborted(), this.firstResultUsed ? Ri.runWithConfig(ls(this.config), this.signal ? async () => Bs(this.generator.next(...t), this.signal) : async () => this.generator.next(...t), !0) : (this.firstResultUsed = !0, this.firstResult);
  }
  async return(t) {
    return this.generator.return(t);
  }
  async throw(t) {
    return this.generator.throw(t);
  }
  [Symbol.asyncIterator]() {
    return this;
  }
  async [Symbol.asyncDispose]() {
    await this.return();
  }
};
async function Fx(t, A, e, r, ...i) {
  const n = new mg({
    generator: A,
    startSetup: e,
    signal: r
  }), s = await n.setup;
  return {
    output: t(n, s, ...i),
    setup: s
  };
}
/*!
* https://github.com/Starcounter-Jack/JSON-Patch
* (c) 2017-2022 Joachim Wester
* MIT licensed
*/
const d3 = Object.prototype.hasOwnProperty;
function zw(t, A) {
  return d3.call(t, A);
}
function $w(t) {
  if (Array.isArray(t)) {
    const e = new Array(t.length);
    for (let r = 0; r < e.length; r++) e[r] = "" + r;
    return e;
  }
  if (Object.keys) return Object.keys(t);
  let A = [];
  for (let e in t) zw(t, e) && A.push(e);
  return A;
}
function Fi(t) {
  switch (typeof t) {
    case "object":
      return JSON.parse(JSON.stringify(t));
    case "undefined":
      return null;
    default:
      return t;
  }
}
function Am(t) {
  let A = 0;
  const e = t.length;
  let r;
  for (; A < e; ) {
    if (r = t.charCodeAt(A), r >= 48 && r <= 57) {
      A++;
      continue;
    }
    return !1;
  }
  return !0;
}
function Lg(t) {
  return t.indexOf("/") === -1 && t.indexOf("~") === -1 ? t : t.replace(/~/g, "~0").replace(/\//g, "~1");
}
function f3(t) {
  return t.replace(/~1/g, "/").replace(/~0/g, "~");
}
function em(t) {
  if (t === void 0) return !0;
  if (t) {
    if (Array.isArray(t)) {
      for (let e = 0, r = t.length; e < r; e++) if (em(t[e])) return !0;
    } else if (typeof t == "object") {
      const e = $w(t), r = e.length;
      for (var A = 0; A < r; A++) if (em(t[e[A]])) return !0;
    }
  }
  return !1;
}
function Gk(t, A) {
  const e = [t];
  for (const r in A) {
    const i = typeof A[r] == "object" ? JSON.stringify(A[r], null, 2) : A[r];
    typeof i < "u" && e.push(`${r}: ${i}`);
  }
  return e.join(`
`);
}
var p3 = class extends Error {
  constructor(t, A, e, r, i) {
    super(Gk(t, {
      name: A,
      index: e,
      operation: r,
      tree: i
    })), this.name = A, this.index = e, this.operation = r, this.tree = i, Object.setPrototypeOf(this, new.target.prototype), this.message = Gk(t, {
      name: A,
      index: e,
      operation: r,
      tree: i
    });
  }
}, kx = {};
fe(kx, {
  JsonPatchError: () => $e,
  _areEquals: () => zC,
  applyOperation: () => gg,
  applyPatch: () => Jc,
  applyReducer: () => m3,
  deepClone: () => y3,
  getValueByPointer: () => md,
  validate: () => vx,
  validator: () => Dd
});
const $e = p3, y3 = Fi, Xg = {
  add: function(t, A, e) {
    return t[A] = this.value, { newDocument: e };
  },
  remove: function(t, A, e) {
    var r = t[A];
    return delete t[A], {
      newDocument: e,
      removed: r
    };
  },
  replace: function(t, A, e) {
    var r = t[A];
    return t[A] = this.value, {
      newDocument: e,
      removed: r
    };
  },
  move: function(t, A, e) {
    let r = md(e, this.path);
    r && (r = Fi(r));
    const i = gg(e, {
      op: "remove",
      path: this.from
    }).removed;
    return gg(e, {
      op: "add",
      path: this.path,
      value: i
    }), {
      newDocument: e,
      removed: r
    };
  },
  copy: function(t, A, e) {
    const r = md(e, this.from);
    return gg(e, {
      op: "add",
      path: this.path,
      value: Fi(r)
    }), { newDocument: e };
  },
  test: function(t, A, e) {
    return {
      newDocument: e,
      test: zC(t[A], this.value)
    };
  },
  _get: function(t, A, e) {
    return this.value = t[A], { newDocument: e };
  }
};
var w3 = {
  add: function(t, A, e) {
    return Am(A) ? t.splice(A, 0, this.value) : t[A] = this.value, {
      newDocument: e,
      index: A
    };
  },
  remove: function(t, A, e) {
    var r = t.splice(A, 1);
    return {
      newDocument: e,
      removed: r[0]
    };
  },
  replace: function(t, A, e) {
    var r = t[A];
    return t[A] = this.value, {
      newDocument: e,
      removed: r
    };
  },
  move: Xg.move,
  copy: Xg.copy,
  test: Xg.test,
  _get: Xg._get
};
function md(t, A) {
  if (A == "") return t;
  var e = {
    op: "_get",
    path: A
  };
  return gg(t, e), e.value;
}
function gg(t, A, e = !1, r = !0, i = !0, n = 0) {
  if (e && (typeof e == "function" ? e(A, 0, t, A.path) : Dd(A, 0)), A.path === "") {
    let s = { newDocument: t };
    if (A.op === "add")
      return s.newDocument = A.value, s;
    if (A.op === "replace")
      return s.newDocument = A.value, s.removed = t, s;
    if (A.op === "move" || A.op === "copy")
      return s.newDocument = md(t, A.from), A.op === "move" && (s.removed = t), s;
    if (A.op === "test") {
      if (s.test = zC(t, A.value), s.test === !1) throw new $e("Test operation failed", "TEST_OPERATION_FAILED", n, A, t);
      return s.newDocument = t, s;
    } else {
      if (A.op === "remove")
        return s.removed = t, s.newDocument = null, s;
      if (A.op === "_get")
        return A.value = t, s;
      if (e) throw new $e("Operation `op` property is not one of operations defined in RFC-6902", "OPERATION_OP_INVALID", n, A, t);
      return s;
    }
  } else {
    r || (t = Fi(t));
    const a = (A.path || "").split("/");
    let g = t, o = 1, u = a.length, I, c, C;
    for (typeof e == "function" ? C = e : C = Dd; ; ) {
      if (c = a[o], c && c.indexOf("~") != -1 && (c = f3(c)), i && (c == "__proto__" || c == "prototype" && o > 0 && a[o - 1] == "constructor")) throw new TypeError("JSON-Patch: modifying `__proto__` or `constructor/prototype` prop is banned for security reasons, if this was on purpose, please set `banPrototypeModifications` flag false and pass it to this function. More info in fast-json-patch README");
      if (e && I === void 0 && (g[c] === void 0 ? I = a.slice(0, o).join("/") : o == u - 1 && (I = A.path), I !== void 0 && C(A, 0, t, I)), o++, Array.isArray(g)) {
        if (c === "-") c = g.length;
        else {
          if (e && !Am(c)) throw new $e("Expected an unsigned base-10 integer value, making the new referenced value the array element with the zero-based index", "OPERATION_PATH_ILLEGAL_ARRAY_INDEX", n, A, t);
          Am(c) && (c = ~~c);
        }
        if (o >= u) {
          if (e && A.op === "add" && c > g.length) throw new $e("The specified index MUST NOT be greater than the number of elements in the array", "OPERATION_VALUE_OUT_OF_BOUNDS", n, A, t);
          const E = w3[A.op].call(A, g, c, t);
          if (E.test === !1) throw new $e("Test operation failed", "TEST_OPERATION_FAILED", n, A, t);
          return E;
        }
      } else if (o >= u) {
        const E = Xg[A.op].call(A, g, c, t);
        if (E.test === !1) throw new $e("Test operation failed", "TEST_OPERATION_FAILED", n, A, t);
        return E;
      }
      if (g = g[c], e && o < u && (!g || typeof g != "object")) throw new $e("Cannot perform operation at the desired path", "OPERATION_PATH_UNRESOLVABLE", n, A, t);
    }
  }
}
function Jc(t, A, e, r = !0, i = !0) {
  if (e && !Array.isArray(A))
    throw new $e("Patch sequence must be an array", "SEQUENCE_NOT_AN_ARRAY");
  r || (t = Fi(t));
  const n = new Array(A.length);
  for (let s = 0, a = A.length; s < a; s++)
    n[s] = gg(t, A[s], e, !0, i, s), t = n[s].newDocument;
  return n.newDocument = t, n;
}
function m3(t, A, e) {
  const r = gg(t, A);
  if (r.test === !1) throw new $e("Test operation failed", "TEST_OPERATION_FAILED", e, A, t);
  return r.newDocument;
}
function Dd(t, A, e, r) {
  if (typeof t != "object" || t === null || Array.isArray(t)) throw new $e("Operation is not an object", "OPERATION_NOT_AN_OBJECT", A, t, e);
  if (Xg[t.op]) {
    if (typeof t.path != "string") throw new $e("Operation `path` property is not a string", "OPERATION_PATH_INVALID", A, t, e);
    if (t.path.indexOf("/") !== 0 && t.path.length > 0) throw new $e('Operation `path` property must start with "/"', "OPERATION_PATH_INVALID", A, t, e);
    if ((t.op === "move" || t.op === "copy") && typeof t.from != "string") throw new $e("Operation `from` property is not present (applicable in `move` and `copy` operations)", "OPERATION_FROM_REQUIRED", A, t, e);
    if ((t.op === "add" || t.op === "replace" || t.op === "test") && t.value === void 0) throw new $e("Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)", "OPERATION_VALUE_REQUIRED", A, t, e);
    if ((t.op === "add" || t.op === "replace" || t.op === "test") && em(t.value)) throw new $e("Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)", "OPERATION_VALUE_CANNOT_CONTAIN_UNDEFINED", A, t, e);
    if (e) {
      if (t.op == "add") {
        var i = t.path.split("/").length, n = r.split("/").length;
        if (i !== n + 1 && i !== n) throw new $e("Cannot perform an `add` operation at the desired path", "OPERATION_PATH_CANNOT_ADD", A, t, e);
      } else if (t.op === "replace" || t.op === "remove" || t.op === "_get") {
        if (t.path !== r) throw new $e("Cannot perform the operation at a path that does not exist", "OPERATION_PATH_UNRESOLVABLE", A, t, e);
      } else if (t.op === "move" || t.op === "copy") {
        var s = {
          op: "_get",
          path: t.from,
          value: void 0
        }, a = vx([s], e);
        if (a && a.name === "OPERATION_PATH_UNRESOLVABLE") throw new $e("Cannot perform the operation from a path that does not exist", "OPERATION_FROM_UNRESOLVABLE", A, t, e);
      }
    }
  } else throw new $e("Operation `op` property is not one of operations defined in RFC-6902", "OPERATION_OP_INVALID", A, t, e);
}
function vx(t, A, e) {
  try {
    if (!Array.isArray(t)) throw new $e("Patch sequence must be an array", "SEQUENCE_NOT_AN_ARRAY");
    if (A) Jc(Fi(A), Fi(t), e || !0);
    else {
      e = e || Dd;
      for (var r = 0; r < t.length; r++) e(t[r], r, A, void 0);
    }
  } catch (i) {
    if (i instanceof $e) return i;
    throw i;
  }
}
function zC(t, A) {
  if (t === A) return !0;
  if (t && A && typeof t == "object" && typeof A == "object") {
    var e = Array.isArray(t), r = Array.isArray(A), i, n, s;
    if (e && r) {
      if (n = t.length, n != A.length) return !1;
      for (i = n; i-- !== 0; ) if (!zC(t[i], A[i])) return !1;
      return !0;
    }
    if (e != r) return !1;
    var a = Object.keys(t);
    if (n = a.length, n !== Object.keys(A).length) return !1;
    for (i = n; i-- !== 0; ) if (!A.hasOwnProperty(a[i])) return !1;
    for (i = n; i-- !== 0; )
      if (s = a[i], !zC(t[s], A[s])) return !1;
    return !0;
  }
  return t !== t && A !== A;
}
function Rx(t, A, e, r, i) {
  if (A !== t) {
    typeof A.toJSON == "function" && (A = A.toJSON());
    for (var n = $w(A), s = $w(t), a = !1, g = s.length - 1; g >= 0; g--) {
      var o = s[g], u = t[o];
      if (zw(A, o) && !(A[o] === void 0 && u !== void 0 && Array.isArray(A) === !1)) {
        var I = A[o];
        typeof u == "object" && u != null && typeof I == "object" && I != null && Array.isArray(u) === Array.isArray(I) ? Rx(u, I, e, r + "/" + Lg(o), i) : u !== I && (i && e.push({
          op: "test",
          path: r + "/" + Lg(o),
          value: Fi(u)
        }), e.push({
          op: "replace",
          path: r + "/" + Lg(o),
          value: Fi(I)
        }));
      } else Array.isArray(t) === Array.isArray(A) ? (i && e.push({
        op: "test",
        path: r + "/" + Lg(o),
        value: Fi(u)
      }), e.push({
        op: "remove",
        path: r + "/" + Lg(o)
      }), a = !0) : (i && e.push({
        op: "test",
        path: r,
        value: t
      }), e.push({
        op: "replace",
        path: r,
        value: A
      }));
    }
    if (!(!a && n.length == s.length))
      for (var g = 0; g < n.length; g++) {
        var o = n[g];
        !zw(t, o) && A[o] !== void 0 && e.push({
          op: "add",
          path: r + "/" + Lg(o),
          value: Fi(A[o])
        });
      }
  }
}
function V0(t, A, e = !1) {
  var r = [];
  return Rx(t, A, r, "", e), r;
}
({
  ...kx
});
var D3 = {};
fe(D3, {
  LogStreamCallbackHandler: () => rm,
  RunLog: () => Z0,
  RunLogPatch: () => Pn,
  isLogStreamHandler: () => bx
});
var Pn = class {
  constructor(t) {
    R(this, "ops");
    this.ops = t.ops ?? [];
  }
  concat(t) {
    const A = this.ops.concat(t.ops), e = Jc({}, A);
    return new Z0({
      ops: A,
      state: e[e.length - 1].newDocument
    });
  }
}, Z0 = class tm extends Pn {
  constructor(e) {
    super(e);
    R(this, "state");
    this.state = e.state;
  }
  concat(e) {
    const r = this.ops.concat(e.ops), i = Jc(this.state, e.ops);
    return new tm({
      ops: r,
      state: i[i.length - 1].newDocument
    });
  }
  static fromRunLogPatch(e) {
    const r = Jc({}, e.ops);
    return new tm({
      ops: e.ops,
      state: r[r.length - 1].newDocument
    });
  }
};
const bx = (t) => t.name === "log_stream_tracer";
async function Uk(t, A) {
  if (A === "original") throw new Error("Do not assign inputs with original schema drop the key for now. When inputs are added to streamLog they should be added with standardized schema for streaming events.");
  const { inputs: e } = t;
  if ([
    "retriever",
    "llm",
    "prompt"
  ].includes(t.run_type)) return e;
  if (!(Object.keys(e).length === 1 && (e == null ? void 0 : e.input) === ""))
    return e.input;
}
async function Tk(t, A) {
  const { outputs: e } = t;
  return A === "original" || [
    "retriever",
    "llm",
    "prompt"
  ].includes(t.run_type) ? e : e !== void 0 && Object.keys(e).length === 1 && (e == null ? void 0 : e.output) !== void 0 ? e.output : e;
}
function S3(t) {
  return t !== void 0 && t.message !== void 0;
}
var rm = class extends oI {
  constructor(A) {
    super({
      _awaitHandler: !0,
      ...A
    });
    R(this, "autoClose", !0);
    R(this, "includeNames");
    R(this, "includeTypes");
    R(this, "includeTags");
    R(this, "excludeNames");
    R(this, "excludeTypes");
    R(this, "excludeTags");
    R(this, "_schemaFormat", "original");
    R(this, "rootId");
    R(this, "keyMapByRunId", {});
    R(this, "counterMapByRunName", {});
    R(this, "transformStream");
    R(this, "writer");
    R(this, "receiveStream");
    R(this, "name", "log_stream_tracer");
    R(this, "lc_prefer_streaming", !0);
    this.autoClose = (A == null ? void 0 : A.autoClose) ?? !0, this.includeNames = A == null ? void 0 : A.includeNames, this.includeTypes = A == null ? void 0 : A.includeTypes, this.includeTags = A == null ? void 0 : A.includeTags, this.excludeNames = A == null ? void 0 : A.excludeNames, this.excludeTypes = A == null ? void 0 : A.excludeTypes, this.excludeTags = A == null ? void 0 : A.excludeTags, this._schemaFormat = (A == null ? void 0 : A._schemaFormat) ?? this._schemaFormat, this.transformStream = new TransformStream(), this.writer = this.transformStream.writable.getWriter(), this.receiveStream = bi.fromReadableStream(this.transformStream.readable);
  }
  [Symbol.asyncIterator]() {
    return this.receiveStream;
  }
  async persistRun(A) {
  }
  _includeRun(A) {
    if (A.id === this.rootId) return !1;
    const e = A.tags ?? [];
    let r = this.includeNames === void 0 && this.includeTags === void 0 && this.includeTypes === void 0;
    return this.includeNames !== void 0 && (r = r || this.includeNames.includes(A.name)), this.includeTypes !== void 0 && (r = r || this.includeTypes.includes(A.run_type)), this.includeTags !== void 0 && (r = r || e.find((i) => {
      var n;
      return (n = this.includeTags) == null ? void 0 : n.includes(i);
    }) !== void 0), this.excludeNames !== void 0 && (r = r && !this.excludeNames.includes(A.name)), this.excludeTypes !== void 0 && (r = r && !this.excludeTypes.includes(A.run_type)), this.excludeTags !== void 0 && (r = r && e.every((i) => {
      var n;
      return !((n = this.excludeTags) != null && n.includes(i));
    })), r;
  }
  async *tapOutputIterable(A, e) {
    for await (const r of e) {
      if (A !== this.rootId) {
        const i = this.keyMapByRunId[A];
        i && await this.writer.write(new Pn({ ops: [{
          op: "add",
          path: `/logs/${i}/streamed_output/-`,
          value: r
        }] }));
      }
      yield r;
    }
  }
  async onRunCreate(A) {
    var i;
    if (this.rootId === void 0 && (this.rootId = A.id, await this.writer.write(new Pn({ ops: [{
      op: "replace",
      path: "",
      value: {
        id: A.id,
        name: A.name,
        type: A.run_type,
        streamed_output: [],
        final_output: void 0,
        logs: {}
      }
    }] }))), !this._includeRun(A)) return;
    this.counterMapByRunName[A.name] === void 0 && (this.counterMapByRunName[A.name] = 0), this.counterMapByRunName[A.name] += 1;
    const e = this.counterMapByRunName[A.name];
    this.keyMapByRunId[A.id] = e === 1 ? A.name : `${A.name}:${e}`;
    const r = {
      id: A.id,
      name: A.name,
      type: A.run_type,
      tags: A.tags ?? [],
      metadata: ((i = A.extra) == null ? void 0 : i.metadata) ?? {},
      start_time: new Date(A.start_time).toISOString(),
      streamed_output: [],
      streamed_output_str: [],
      final_output: void 0,
      end_time: void 0
    };
    this._schemaFormat === "streaming_events" && (r.inputs = await Uk(A, this._schemaFormat)), await this.writer.write(new Pn({ ops: [{
      op: "add",
      path: `/logs/${this.keyMapByRunId[A.id]}`,
      value: r
    }] }));
  }
  async onRunUpdate(A) {
    try {
      const e = this.keyMapByRunId[A.id];
      if (e === void 0) return;
      const r = [];
      this._schemaFormat === "streaming_events" && r.push({
        op: "replace",
        path: `/logs/${e}/inputs`,
        value: await Uk(A, this._schemaFormat)
      }), r.push({
        op: "add",
        path: `/logs/${e}/final_output`,
        value: await Tk(A, this._schemaFormat)
      }), A.end_time !== void 0 && r.push({
        op: "add",
        path: `/logs/${e}/end_time`,
        value: new Date(A.end_time).toISOString()
      });
      const i = new Pn({ ops: r });
      await this.writer.write(i);
    } finally {
      if (A.id === this.rootId) {
        const e = new Pn({ ops: [{
          op: "replace",
          path: "/final_output",
          value: await Tk(A, this._schemaFormat)
        }] });
        await this.writer.write(e), this.autoClose && await this.writer.close();
      }
    }
  }
  async onLLMNewToken(A, e, r) {
    const i = this.keyMapByRunId[A.id];
    if (i === void 0) return;
    const n = A.inputs.messages !== void 0;
    let s;
    n ? S3(r == null ? void 0 : r.chunk) ? s = r == null ? void 0 : r.chunk : s = new kn({
      id: `run-${A.id}`,
      content: e
    }) : s = e;
    const a = new Pn({ ops: [{
      op: "add",
      path: `/logs/${i}/streamed_output_str/-`,
      value: e
    }, {
      op: "add",
      path: `/logs/${i}/streamed_output/-`,
      value: s
    }] });
    await this.writer.write(a);
  }
}, F3 = {};
fe(F3, {
  ChatGenerationChunk: () => Pc,
  GenerationChunk: () => Hc,
  RUN_KEY: () => $C
});
const $C = "__run";
var Hc = class Mx {
  constructor(A) {
    R(this, "text");
    R(this, "generationInfo");
    this.text = A.text, this.generationInfo = A.generationInfo;
  }
  concat(A) {
    return new Mx({
      text: this.text + A.text,
      generationInfo: {
        ...this.generationInfo,
        ...A.generationInfo
      }
    });
  }
}, Pc = class _x extends Hc {
  constructor(e) {
    super(e);
    R(this, "message");
    this.message = e.message;
  }
  concat(e) {
    return new _x({
      text: this.text + e.text,
      generationInfo: {
        ...this.generationInfo,
        ...e.generationInfo
      },
      message: this.message.concat(e.message)
    });
  }
};
function fh({ name: t, serialized: A }) {
  return t !== void 0 ? t : (A == null ? void 0 : A.name) !== void 0 ? A.name : (A == null ? void 0 : A.id) !== void 0 && Array.isArray(A == null ? void 0 : A.id) ? A.id[A.id.length - 1] : "Unnamed";
}
const k3 = (t) => t.name === "event_stream_tracer";
var v3 = class extends oI {
  constructor(A) {
    super({
      _awaitHandler: !0,
      ...A
    });
    R(this, "autoClose", !0);
    R(this, "includeNames");
    R(this, "includeTypes");
    R(this, "includeTags");
    R(this, "excludeNames");
    R(this, "excludeTypes");
    R(this, "excludeTags");
    R(this, "runInfoMap", /* @__PURE__ */ new Map());
    R(this, "tappedPromises", /* @__PURE__ */ new Map());
    R(this, "transformStream");
    R(this, "writer");
    R(this, "receiveStream");
    R(this, "name", "event_stream_tracer");
    R(this, "lc_prefer_streaming", !0);
    this.autoClose = (A == null ? void 0 : A.autoClose) ?? !0, this.includeNames = A == null ? void 0 : A.includeNames, this.includeTypes = A == null ? void 0 : A.includeTypes, this.includeTags = A == null ? void 0 : A.includeTags, this.excludeNames = A == null ? void 0 : A.excludeNames, this.excludeTypes = A == null ? void 0 : A.excludeTypes, this.excludeTags = A == null ? void 0 : A.excludeTags, this.transformStream = new TransformStream(), this.writer = this.transformStream.writable.getWriter(), this.receiveStream = bi.fromReadableStream(this.transformStream.readable);
  }
  [Symbol.asyncIterator]() {
    return this.receiveStream;
  }
  async persistRun(A) {
  }
  _includeRun(A) {
    const e = A.tags ?? [];
    let r = this.includeNames === void 0 && this.includeTags === void 0 && this.includeTypes === void 0;
    return this.includeNames !== void 0 && (r = r || this.includeNames.includes(A.name)), this.includeTypes !== void 0 && (r = r || this.includeTypes.includes(A.runType)), this.includeTags !== void 0 && (r = r || e.find((i) => {
      var n;
      return (n = this.includeTags) == null ? void 0 : n.includes(i);
    }) !== void 0), this.excludeNames !== void 0 && (r = r && !this.excludeNames.includes(A.name)), this.excludeTypes !== void 0 && (r = r && !this.excludeTypes.includes(A.runType)), this.excludeTags !== void 0 && (r = r && e.every((i) => {
      var n;
      return !((n = this.excludeTags) != null && n.includes(i));
    })), r;
  }
  async *tapOutputIterable(A, e) {
    const r = await e.next();
    if (r.done) return;
    const i = this.runInfoMap.get(A);
    if (i === void 0) {
      yield r.value;
      return;
    }
    function n(a, g) {
      return a === "llm" && typeof g == "string" ? new Hc({ text: g }) : g;
    }
    let s = this.tappedPromises.get(A);
    if (s === void 0) {
      let a;
      s = new Promise((g) => {
        a = g;
      }), this.tappedPromises.set(A, s);
      try {
        const g = {
          event: `on_${i.runType}_stream`,
          run_id: A,
          name: i.name,
          tags: i.tags,
          metadata: i.metadata,
          data: {}
        };
        await this.send({
          ...g,
          data: { chunk: n(i.runType, r.value) }
        }, i), yield r.value;
        for await (const o of e)
          i.runType !== "tool" && i.runType !== "retriever" && await this.send({
            ...g,
            data: { chunk: n(i.runType, o) }
          }, i), yield o;
      } finally {
        a == null || a();
      }
    } else {
      yield r.value;
      for await (const a of e) yield a;
    }
  }
  async send(A, e) {
    this._includeRun(e) && await this.writer.write(A);
  }
  async sendEndEvent(A, e) {
    const r = this.tappedPromises.get(A.run_id);
    r !== void 0 ? r.then(() => {
      this.send(A, e);
    }) : await this.send(A, e);
  }
  async onLLMStart(A) {
    var s, a;
    const e = fh(A), r = A.inputs.messages !== void 0 ? "chat_model" : "llm", i = {
      tags: A.tags ?? [],
      metadata: ((s = A.extra) == null ? void 0 : s.metadata) ?? {},
      name: e,
      runType: r,
      inputs: A.inputs
    };
    this.runInfoMap.set(A.id, i);
    const n = `on_${r}_start`;
    await this.send({
      event: n,
      data: { input: A.inputs },
      name: e,
      tags: A.tags ?? [],
      run_id: A.id,
      metadata: ((a = A.extra) == null ? void 0 : a.metadata) ?? {}
    }, i);
  }
  async onLLMNewToken(A, e, r) {
    const i = this.runInfoMap.get(A.id);
    let n, s;
    if (i === void 0) throw new Error(`onLLMNewToken: Run ID ${A.id} not found in run map.`);
    if (this.runInfoMap.size !== 1) {
      if (i.runType === "chat_model")
        s = "on_chat_model_stream", (r == null ? void 0 : r.chunk) === void 0 ? n = new kn({
          content: e,
          id: `run-${A.id}`
        }) : n = r.chunk.message;
      else if (i.runType === "llm")
        s = "on_llm_stream", (r == null ? void 0 : r.chunk) === void 0 ? n = new Hc({ text: e }) : n = r.chunk;
      else throw new Error(`Unexpected run type ${i.runType}`);
      await this.send({
        event: s,
        data: { chunk: n },
        run_id: A.id,
        name: i.name,
        tags: i.tags,
        metadata: i.metadata
      }, i);
    }
  }
  async onLLMEnd(A) {
    var s, a, g;
    const e = this.runInfoMap.get(A.id);
    this.runInfoMap.delete(A.id);
    let r;
    if (e === void 0) throw new Error(`onLLMEnd: Run ID ${A.id} not found in run map.`);
    const i = (s = A.outputs) == null ? void 0 : s.generations;
    let n;
    if (e.runType === "chat_model") {
      for (const o of i ?? []) {
        if (n !== void 0) break;
        n = (a = o[0]) == null ? void 0 : a.message;
      }
      r = "on_chat_model_end";
    } else if (e.runType === "llm")
      n = {
        generations: i == null ? void 0 : i.map((o) => o.map((u) => ({
          text: u.text,
          generationInfo: u.generationInfo
        }))),
        llmOutput: ((g = A.outputs) == null ? void 0 : g.llmOutput) ?? {}
      }, r = "on_llm_end";
    else throw new Error(`onLLMEnd: Unexpected run type: ${e.runType}`);
    await this.sendEndEvent({
      event: r,
      data: {
        output: n,
        input: e.inputs
      },
      run_id: A.id,
      name: e.name,
      tags: e.tags,
      metadata: e.metadata
    }, e);
  }
  async onChainStart(A) {
    var s, a;
    const e = fh(A), r = A.run_type ?? "chain", i = {
      tags: A.tags ?? [],
      metadata: ((s = A.extra) == null ? void 0 : s.metadata) ?? {},
      name: e,
      runType: A.run_type
    };
    let n = {};
    A.inputs.input === "" && Object.keys(A.inputs).length === 1 ? (n = {}, i.inputs = {}) : A.inputs.input !== void 0 ? (n.input = A.inputs.input, i.inputs = A.inputs.input) : (n.input = A.inputs, i.inputs = A.inputs), this.runInfoMap.set(A.id, i), await this.send({
      event: `on_${r}_start`,
      data: n,
      name: e,
      tags: A.tags ?? [],
      run_id: A.id,
      metadata: ((a = A.extra) == null ? void 0 : a.metadata) ?? {}
    }, i);
  }
  async onChainEnd(A) {
    var a;
    const e = this.runInfoMap.get(A.id);
    if (this.runInfoMap.delete(A.id), e === void 0) throw new Error(`onChainEnd: Run ID ${A.id} not found in run map.`);
    const r = `on_${A.run_type}_end`, i = A.inputs ?? e.inputs ?? {}, s = {
      output: ((a = A.outputs) == null ? void 0 : a.output) ?? A.outputs,
      input: i
    };
    i.input && Object.keys(i).length === 1 && (s.input = i.input, e.inputs = i.input), await this.sendEndEvent({
      event: r,
      data: s,
      run_id: A.id,
      name: e.name,
      tags: e.tags,
      metadata: e.metadata ?? {}
    }, e);
  }
  async onToolStart(A) {
    var i, n;
    const e = fh(A), r = {
      tags: A.tags ?? [],
      metadata: ((i = A.extra) == null ? void 0 : i.metadata) ?? {},
      name: e,
      runType: "tool",
      inputs: A.inputs ?? {}
    };
    this.runInfoMap.set(A.id, r), await this.send({
      event: "on_tool_start",
      data: { input: A.inputs ?? {} },
      name: e,
      run_id: A.id,
      tags: A.tags ?? [],
      metadata: ((n = A.extra) == null ? void 0 : n.metadata) ?? {}
    }, r);
  }
  async onToolEnd(A) {
    var i;
    const e = this.runInfoMap.get(A.id);
    if (this.runInfoMap.delete(A.id), e === void 0) throw new Error(`onToolEnd: Run ID ${A.id} not found in run map.`);
    if (e.inputs === void 0) throw new Error(`onToolEnd: Run ID ${A.id} is a tool call, and is expected to have traced inputs.`);
    const r = ((i = A.outputs) == null ? void 0 : i.output) === void 0 ? A.outputs : A.outputs.output;
    await this.sendEndEvent({
      event: "on_tool_end",
      data: {
        output: r,
        input: e.inputs
      },
      run_id: A.id,
      name: e.name,
      tags: e.tags,
      metadata: e.metadata
    }, e);
  }
  async onRetrieverStart(A) {
    var n, s;
    const e = fh(A), i = {
      tags: A.tags ?? [],
      metadata: ((n = A.extra) == null ? void 0 : n.metadata) ?? {},
      name: e,
      runType: "retriever",
      inputs: { query: A.inputs.query }
    };
    this.runInfoMap.set(A.id, i), await this.send({
      event: "on_retriever_start",
      data: { input: { query: A.inputs.query } },
      name: e,
      tags: A.tags ?? [],
      run_id: A.id,
      metadata: ((s = A.extra) == null ? void 0 : s.metadata) ?? {}
    }, i);
  }
  async onRetrieverEnd(A) {
    var r;
    const e = this.runInfoMap.get(A.id);
    if (this.runInfoMap.delete(A.id), e === void 0) throw new Error(`onRetrieverEnd: Run ID ${A.id} not found in run map.`);
    await this.sendEndEvent({
      event: "on_retriever_end",
      data: {
        output: ((r = A.outputs) == null ? void 0 : r.documents) ?? A.outputs,
        input: e.inputs
      },
      run_id: A.id,
      name: e.name,
      tags: e.tags,
      metadata: e.metadata
    }, e);
  }
  async handleCustomEvent(A, e, r) {
    const i = this.runInfoMap.get(r);
    if (i === void 0) throw new Error(`handleCustomEvent: Run ID ${r} not found in run map.`);
    await this.send({
      event: "on_custom_event",
      run_id: r,
      name: A,
      tags: i.tags,
      metadata: i.metadata,
      data: e
    }, i);
  }
  async finish() {
    const A = [...this.tappedPromises.values()];
    Promise.all(A).finally(() => {
      this.writer.close();
    });
  }
};
const R3 = Object.prototype.toString, b3 = (t) => R3.call(t) === "[object Error]", M3 = /* @__PURE__ */ new Set([
  "network error",
  "Failed to fetch",
  "NetworkError when attempting to fetch resource.",
  "The Internet connection appears to be offline.",
  "Network request failed",
  "fetch failed",
  "terminated",
  " A network error occurred.",
  "Network connection lost"
]);
function _3(t) {
  if (!(t && b3(t) && t.name === "TypeError" && typeof t.message == "string")) return !1;
  const { message: e, stack: r } = t;
  return e === "Load failed" ? r === void 0 || "__sentry_captured__" in t : e.startsWith("error sending request for url") ? !0 : M3.has(e);
}
function N3(t) {
  if (typeof t == "number") {
    if (t < 0) throw new TypeError("Expected `retries` to be a non-negative number.");
    if (Number.isNaN(t)) throw new TypeError("Expected `retries` to be a valid number or Infinity, got NaN.");
  } else if (t !== void 0) throw new TypeError("Expected `retries` to be a number or Infinity.");
}
function ph(t, A, { min: e = 0, allowInfinity: r = !1 } = {}) {
  if (A !== void 0) {
    if (typeof A != "number" || Number.isNaN(A)) throw new TypeError(`Expected \`${t}\` to be a number${r ? " or Infinity" : ""}.`);
    if (!r && !Number.isFinite(A)) throw new TypeError(`Expected \`${t}\` to be a finite number.`);
    if (A < e) throw new TypeError(`Expected \`${t}\` to be â‰¥ ${e}.`);
  }
}
var L3 = class extends Error {
  constructor(t) {
    super(), t instanceof Error ? (this.originalError = t, { message: t } = t) : (this.originalError = new Error(t), this.originalError.stack = this.stack), this.name = "AbortError", this.message = t;
  }
};
function x3(t, A) {
  const e = Math.max(1, t + 1), r = A.randomize ? Math.random() + 1 : 1;
  let i = Math.round(r * A.minTimeout * A.factor ** (e - 1));
  return i = Math.min(i, A.maxTimeout), i;
}
function Kk(t, A) {
  return Number.isFinite(A) ? A - (performance.now() - t) : A;
}
async function G3({ error: t, attemptNumber: A, retriesConsumed: e, startTime: r, options: i }) {
  var C, E, l;
  const n = t instanceof Error ? t : /* @__PURE__ */ new TypeError(`Non-error was thrown: "${t}". You should only throw errors.`);
  if (n instanceof L3) throw n.originalError;
  const s = Number.isFinite(i.retries) ? Math.max(0, i.retries - e) : i.retries, a = i.maxRetryTime ?? Number.POSITIVE_INFINITY, g = Object.freeze({
    error: n,
    attemptNumber: A,
    retriesLeft: s,
    retriesConsumed: e
  });
  if (await i.onFailedAttempt(g), Kk(r, a) <= 0) throw n;
  const o = await i.shouldConsumeRetry(g), u = Kk(r, a);
  if (u <= 0 || s <= 0) throw n;
  if (n instanceof TypeError && !_3(n)) {
    if (o) throw n;
    return (C = i.signal) == null || C.throwIfAborted(), !1;
  }
  if (!await i.shouldRetry(g)) throw n;
  if (!o)
    return (E = i.signal) == null || E.throwIfAborted(), !1;
  const I = x3(e, i), c = Math.min(I, u);
  return c > 0 && await new Promise((B, h) => {
    var p, y;
    const Q = () => {
      var m;
      clearTimeout(f), (m = i.signal) == null || m.removeEventListener("abort", Q), h(i.signal.reason);
    }, f = setTimeout(() => {
      var m;
      (m = i.signal) == null || m.removeEventListener("abort", Q), B();
    }, c);
    i.unref && ((p = f.unref) == null || p.call(f)), (y = i.signal) == null || y.addEventListener("abort", Q, { once: !0 });
  }), (l = i.signal) == null || l.throwIfAborted(), !0;
}
async function im(t, A = {}) {
  var n, s, a;
  if (A = { ...A }, N3(A.retries), Object.hasOwn(A, "forever")) throw new Error("The `forever` option is no longer supported. For many use-cases, you can set `retries: Infinity` instead.");
  A.retries ?? (A.retries = 10), A.factor ?? (A.factor = 2), A.minTimeout ?? (A.minTimeout = 1e3), A.maxTimeout ?? (A.maxTimeout = Number.POSITIVE_INFINITY), A.maxRetryTime ?? (A.maxRetryTime = Number.POSITIVE_INFINITY), A.randomize ?? (A.randomize = !1), A.onFailedAttempt ?? (A.onFailedAttempt = () => {
  }), A.shouldRetry ?? (A.shouldRetry = () => !0), A.shouldConsumeRetry ?? (A.shouldConsumeRetry = () => !0), ph("factor", A.factor, {
    min: 0,
    allowInfinity: !1
  }), ph("minTimeout", A.minTimeout, {
    min: 0,
    allowInfinity: !1
  }), ph("maxTimeout", A.maxTimeout, {
    min: 0,
    allowInfinity: !0
  }), ph("maxRetryTime", A.maxRetryTime, {
    min: 0,
    allowInfinity: !0
  }), A.factor > 0 || (A.factor = 1), (n = A.signal) == null || n.throwIfAborted();
  let e = 0, r = 0;
  const i = performance.now();
  for (; !Number.isFinite(A.retries) || r <= A.retries; ) {
    e++;
    try {
      (s = A.signal) == null || s.throwIfAborted();
      const g = await t(e);
      return (a = A.signal) == null || a.throwIfAborted(), g;
    } catch (g) {
      await G3({
        error: g,
        attemptNumber: e,
        retriesConsumed: r,
        startTime: i,
        options: A
      }) && r++;
    }
  }
  throw new Error("Retry attempts exhausted without throwing an error.");
}
var U3 = {};
fe(U3, { AsyncCaller: () => UE });
const T3 = [
  400,
  401,
  402,
  403,
  404,
  405,
  406,
  407,
  409
], K3 = (t) => {
  var e, r;
  if (t.message.startsWith("Cancel") || t.message.startsWith("AbortError") || t.name === "AbortError" || (t == null ? void 0 : t.code) === "ECONNABORTED") throw t;
  const A = ((e = t == null ? void 0 : t.response) == null ? void 0 : e.status) ?? (t == null ? void 0 : t.status);
  if (A && T3.includes(+A)) throw t;
  if (((r = t == null ? void 0 : t.error) == null ? void 0 : r.code) === "insufficient_quota") {
    const i = new Error(t == null ? void 0 : t.message);
    throw i.name = "InsufficientQuotaError", i;
  }
};
var UE = class {
  constructor(t) {
    R(this, "maxConcurrency");
    R(this, "maxRetries");
    R(this, "onFailedAttempt");
    R(this, "queue");
    this.maxConcurrency = t.maxConcurrency ?? 1 / 0, this.maxRetries = t.maxRetries ?? 6, this.onFailedAttempt = t.onFailedAttempt ?? K3;
    const A = "default" in os ? os.default : os;
    this.queue = new A({ concurrency: this.maxConcurrency });
  }
  async call(t, ...A) {
    return this.queue.add(() => im(() => t(...A).catch((e) => {
      throw e instanceof Error ? e : new Error(e);
    }), {
      onFailedAttempt: ({ error: e }) => {
        var r;
        return (r = this.onFailedAttempt) == null ? void 0 : r.call(this, e);
      },
      retries: this.maxRetries,
      randomize: !0
    }), { throwOnTimeout: !0 });
  }
  callWithOptions(t, A, ...e) {
    if (t.signal) {
      let r;
      return Promise.race([this.call(A, ...e), new Promise((i, n) => {
        var s;
        r = () => {
          n(XC(t.signal));
        }, (s = t.signal) == null || s.addEventListener("abort", r);
      })]).finally(() => {
        t.signal && r && t.signal.removeEventListener("abort", r);
      });
    }
    return this.call(A, ...e);
  }
  fetch(...t) {
    return this.call(() => fetch(...t).then((A) => A.ok ? A : Promise.reject(A)));
  }
}, Nx = class extends oI {
  constructor({ config: A, onStart: e, onEnd: r, onError: i }) {
    super({ _awaitHandler: !0 });
    R(this, "name", "RootListenersTracer");
    /** The Run's ID. Type UUID */
    R(this, "rootId");
    R(this, "config");
    R(this, "argOnStart");
    R(this, "argOnEnd");
    R(this, "argOnError");
    this.config = A, this.argOnStart = e, this.argOnEnd = r, this.argOnError = i;
  }
  /**
  * This is a legacy method only called once for an entire run tree
  * therefore not useful here
  * @param {Run} _ Not used
  */
  persistRun(A) {
    return Promise.resolve();
  }
  async onRunCreate(A) {
    this.rootId || (this.rootId = A.id, this.argOnStart && await this.argOnStart(A, this.config));
  }
  async onRunUpdate(A) {
    A.id === this.rootId && (A.error ? this.argOnError && await this.argOnError(A, this.config) : this.argOnEnd && await this.argOnEnd(A, this.config));
  }
};
function X0(t) {
  return t ? t.lc_runnable : !1;
}
var J3 = class {
  constructor(t) {
    R(this, "includeNames");
    R(this, "includeTypes");
    R(this, "includeTags");
    R(this, "excludeNames");
    R(this, "excludeTypes");
    R(this, "excludeTags");
    this.includeNames = t.includeNames, this.includeTypes = t.includeTypes, this.includeTags = t.includeTags, this.excludeNames = t.excludeNames, this.excludeTypes = t.excludeTypes, this.excludeTags = t.excludeTags;
  }
  includeEvent(t, A) {
    let e = this.includeNames === void 0 && this.includeTypes === void 0 && this.includeTags === void 0;
    const r = t.tags ?? [];
    return this.includeNames !== void 0 && (e = e || this.includeNames.includes(t.name)), this.includeTypes !== void 0 && (e = e || this.includeTypes.includes(A)), this.includeTags !== void 0 && (e = e || r.some((i) => {
      var n;
      return (n = this.includeTags) == null ? void 0 : n.includes(i);
    })), this.excludeNames !== void 0 && (e = e && !this.excludeNames.includes(t.name)), this.excludeTypes !== void 0 && (e = e && !this.excludeTypes.includes(A)), this.excludeTags !== void 0 && (e = e && r.every((i) => {
      var n;
      return !((n = this.excludeTags) != null && n.includes(i));
    })), e;
  }
};
const H3 = (t) => btoa(t).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
function dA(t, A, e) {
  function r(a, g) {
    if (a._zod || Object.defineProperty(a, "_zod", {
      value: {
        def: g,
        constr: s,
        traits: /* @__PURE__ */ new Set()
      },
      enumerable: !1
    }), a._zod.traits.has(t))
      return;
    a._zod.traits.add(t), A(a, g);
    const o = s.prototype, u = Object.keys(o);
    for (let I = 0; I < u.length; I++) {
      const c = u[I];
      c in a || (a[c] = o[c].bind(a));
    }
  }
  const i = (e == null ? void 0 : e.Parent) ?? Object;
  class n extends i {
  }
  Object.defineProperty(n, "name", { value: t });
  function s(a) {
    var g;
    const o = e != null && e.Parent ? new n() : this;
    r(o, a), (g = o._zod).deferred ?? (g.deferred = []);
    for (const u of o._zod.deferred)
      u();
    return o;
  }
  return Object.defineProperty(s, "init", { value: r }), Object.defineProperty(s, Symbol.hasInstance, {
    value: (a) => {
      var g, o;
      return e != null && e.Parent && a instanceof e.Parent ? !0 : (o = (g = a == null ? void 0 : a._zod) == null ? void 0 : g.traits) == null ? void 0 : o.has(t);
    }
  }), Object.defineProperty(s, "name", { value: t }), s;
}
class su extends Error {
  constructor() {
    super("Encountered Promise during synchronous parse. Use .parseAsync() instead.");
  }
}
class Lx extends Error {
  constructor(A) {
    super(`Encountered unidirectional transform during encode: ${A}`), this.name = "ZodEncodeError";
  }
}
const xx = {};
function lg(t) {
  return xx;
}
function Gx(t) {
  const A = Object.values(t).filter((r) => typeof r == "number");
  return Object.entries(t).filter(([r, i]) => A.indexOf(+r) === -1).map(([r, i]) => i);
}
function nm(t, A) {
  return typeof A == "bigint" ? A.toString() : A;
}
function z0(t) {
  return {
    get value() {
      {
        const A = t();
        return Object.defineProperty(this, "value", { value: A }), A;
      }
    }
  };
}
function $0(t) {
  return t == null;
}
function AS(t) {
  const A = t.startsWith("^") ? 1 : 0, e = t.endsWith("$") ? t.length - 1 : t.length;
  return t.slice(A, e);
}
const Jk = Symbol("evaluating");
function Pe(t, A, e) {
  let r;
  Object.defineProperty(t, A, {
    get() {
      if (r !== Jk)
        return r === void 0 && (r = Jk, r = e()), r;
    },
    set(i) {
      Object.defineProperty(t, A, {
        value: i
        // configurable: true,
      });
    },
    configurable: !0
  });
}
function Dg(t, A, e) {
  Object.defineProperty(t, A, {
    value: e,
    writable: !0,
    enumerable: !0,
    configurable: !0
  });
}
function Sg(...t) {
  const A = {};
  for (const e of t) {
    const r = Object.getOwnPropertyDescriptors(e);
    Object.assign(A, r);
  }
  return Object.defineProperties({}, A);
}
function Hk(t) {
  return JSON.stringify(t);
}
function P3(t) {
  return t.toLowerCase().trim().replace(/[^\w\s-]/g, "").replace(/[\s_-]+/g, "-").replace(/^-+|-+$/g, "");
}
const Ux = "captureStackTrace" in Error ? Error.captureStackTrace : (...t) => {
};
function Sd(t) {
  return typeof t == "object" && t !== null && !Array.isArray(t);
}
const O3 = z0(() => {
  var t;
  if (typeof navigator < "u" && ((t = navigator == null ? void 0 : navigator.userAgent) != null && t.includes("Cloudflare")))
    return !1;
  try {
    const A = Function;
    return new A(""), !0;
  } catch {
    return !1;
  }
});
function Al(t) {
  if (Sd(t) === !1)
    return !1;
  const A = t.constructor;
  if (A === void 0 || typeof A != "function")
    return !0;
  const e = A.prototype;
  return !(Sd(e) === !1 || Object.prototype.hasOwnProperty.call(e, "isPrototypeOf") === !1);
}
function Tx(t) {
  return Al(t) ? { ...t } : Array.isArray(t) ? [...t] : t;
}
const Y3 = /* @__PURE__ */ new Set(["string", "number", "symbol"]);
function Ap(t) {
  return t.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function qt(t, A, e) {
  const r = new t._zod.constr(A ?? t._zod.def);
  return (!A || e != null && e.parent) && (r._zod.parent = t), r;
}
function ee(t) {
  const A = t;
  if (!A)
    return {};
  if (typeof A == "string")
    return { error: () => A };
  if ((A == null ? void 0 : A.message) !== void 0) {
    if ((A == null ? void 0 : A.error) !== void 0)
      throw new Error("Cannot specify both `message` and `error` params");
    A.error = A.message;
  }
  return delete A.message, typeof A.error == "string" ? { ...A, error: () => A.error } : A;
}
function q3(t) {
  return Object.keys(t).filter((A) => t[A]._zod.optin === "optional" && t[A]._zod.optout === "optional");
}
function j3(t, A) {
  const e = t._zod.def, r = Sg(t._zod.def, {
    get shape() {
      const i = {};
      for (const n in A) {
        if (!(n in e.shape))
          throw new Error(`Unrecognized key: "${n}"`);
        A[n] && (i[n] = e.shape[n]);
      }
      return Dg(this, "shape", i), i;
    },
    checks: []
  });
  return qt(t, r);
}
function W3(t, A) {
  const e = t._zod.def, r = Sg(t._zod.def, {
    get shape() {
      const i = { ...t._zod.def.shape };
      for (const n in A) {
        if (!(n in e.shape))
          throw new Error(`Unrecognized key: "${n}"`);
        A[n] && delete i[n];
      }
      return Dg(this, "shape", i), i;
    },
    checks: []
  });
  return qt(t, r);
}
function Kx(t, A) {
  if (!Al(A))
    throw new Error("Invalid input to extend: expected a plain object");
  const e = t._zod.def.checks;
  if (e && e.length > 0)
    throw new Error("Object schemas containing refinements cannot be extended. Use `.safeExtend()` instead.");
  const i = Sg(t._zod.def, {
    get shape() {
      const n = { ...t._zod.def.shape, ...A };
      return Dg(this, "shape", n), n;
    },
    checks: []
  });
  return qt(t, i);
}
function V3(t, A) {
  if (!Al(A))
    throw new Error("Invalid input to safeExtend: expected a plain object");
  const e = {
    ...t._zod.def,
    get shape() {
      const r = { ...t._zod.def.shape, ...A };
      return Dg(this, "shape", r), r;
    },
    checks: t._zod.def.checks
  };
  return qt(t, e);
}
function Z3(t, A) {
  const e = Sg(t._zod.def, {
    get shape() {
      const r = { ...t._zod.def.shape, ...A._zod.def.shape };
      return Dg(this, "shape", r), r;
    },
    get catchall() {
      return A._zod.def.catchall;
    },
    checks: []
    // delete existing checks
  });
  return qt(t, e);
}
function Jx(t, A, e) {
  const r = Sg(A._zod.def, {
    get shape() {
      const i = A._zod.def.shape, n = { ...i };
      if (e)
        for (const s in e) {
          if (!(s in i))
            throw new Error(`Unrecognized key: "${s}"`);
          e[s] && (n[s] = t ? new t({
            type: "optional",
            innerType: i[s]
          }) : i[s]);
        }
      else
        for (const s in i)
          n[s] = t ? new t({
            type: "optional",
            innerType: i[s]
          }) : i[s];
      return Dg(this, "shape", n), n;
    },
    checks: []
  });
  return qt(A, r);
}
function X3(t, A, e) {
  const r = Sg(A._zod.def, {
    get shape() {
      const i = A._zod.def.shape, n = { ...i };
      if (e)
        for (const s in e) {
          if (!(s in n))
            throw new Error(`Unrecognized key: "${s}"`);
          e[s] && (n[s] = new t({
            type: "nonoptional",
            innerType: i[s]
          }));
        }
      else
        for (const s in i)
          n[s] = new t({
            type: "nonoptional",
            innerType: i[s]
          });
      return Dg(this, "shape", n), n;
    },
    checks: []
  });
  return qt(A, r);
}
function zg(t, A = 0) {
  var e;
  if (t.aborted === !0)
    return !0;
  for (let r = A; r < t.issues.length; r++)
    if (((e = t.issues[r]) == null ? void 0 : e.continue) !== !0)
      return !0;
  return !1;
}
function Hx(t, A) {
  return A.map((e) => {
    var r;
    return (r = e).path ?? (r.path = []), e.path.unshift(t), e;
  });
}
function yh(t) {
  return typeof t == "string" ? t : t == null ? void 0 : t.message;
}
function Bg(t, A, e) {
  var i, n, s, a, g, o;
  const r = { ...t, path: t.path ?? [] };
  if (!t.message) {
    const u = yh((s = (n = (i = t.inst) == null ? void 0 : i._zod.def) == null ? void 0 : n.error) == null ? void 0 : s.call(n, t)) ?? yh((a = A == null ? void 0 : A.error) == null ? void 0 : a.call(A, t)) ?? yh((g = e.customError) == null ? void 0 : g.call(e, t)) ?? yh((o = e.localeError) == null ? void 0 : o.call(e, t)) ?? "Invalid input";
    r.message = u;
  }
  return delete r.inst, delete r.continue, A != null && A.reportInput || delete r.input, r;
}
function eS(t) {
  return Array.isArray(t) ? "array" : typeof t == "string" ? "string" : "unknown";
}
function el(...t) {
  const [A, e, r] = t;
  return typeof A == "string" ? {
    message: A,
    code: "custom",
    input: e,
    inst: r
  } : { ...A };
}
const Px = (t, A) => {
  t.name = "$ZodError", Object.defineProperty(t, "_zod", {
    value: t._zod,
    enumerable: !1
  }), Object.defineProperty(t, "issues", {
    value: A,
    enumerable: !1
  }), t.message = JSON.stringify(A, nm, 2), Object.defineProperty(t, "toString", {
    value: () => t.message,
    enumerable: !1
  });
}, Ox = dA("$ZodError", Px), ep = dA("$ZodError", Px, { Parent: Error });
function z3(t, A = (e) => e.message) {
  const e = {}, r = [];
  for (const i of t.issues)
    i.path.length > 0 ? (e[i.path[0]] = e[i.path[0]] || [], e[i.path[0]].push(A(i))) : r.push(A(i));
  return { formErrors: r, fieldErrors: e };
}
function $3(t, A = (e) => e.message) {
  const e = { _errors: [] }, r = (i) => {
    for (const n of i.issues)
      if (n.code === "invalid_union" && n.errors.length)
        n.errors.map((s) => r({ issues: s }));
      else if (n.code === "invalid_key")
        r({ issues: n.issues });
      else if (n.code === "invalid_element")
        r({ issues: n.issues });
      else if (n.path.length === 0)
        e._errors.push(A(n));
      else {
        let s = e, a = 0;
        for (; a < n.path.length; ) {
          const g = n.path[a];
          a === n.path.length - 1 ? (s[g] = s[g] || { _errors: [] }, s[g]._errors.push(A(n))) : s[g] = s[g] || { _errors: [] }, s = s[g], a++;
        }
      }
  };
  return r(t), e;
}
function Aq(t) {
  const A = [], e = t.map((r) => typeof r == "object" ? r.key : r);
  for (const r of e)
    typeof r == "number" ? A.push(`[${r}]`) : typeof r == "symbol" ? A.push(`[${JSON.stringify(String(r))}]`) : /[^\w$]/.test(r) ? A.push(`[${JSON.stringify(r)}]`) : (A.length && A.push("."), A.push(r));
  return A.join("");
}
function eq(t) {
  var r;
  const A = [], e = [...t.issues].sort((i, n) => (i.path ?? []).length - (n.path ?? []).length);
  for (const i of e)
    A.push(`âœ– ${i.message}`), (r = i.path) != null && r.length && A.push(`  â†’ at ${Aq(i.path)}`);
  return A.join(`
`);
}
const tp = (t) => (A, e, r, i) => {
  const n = r ? Object.assign(r, { async: !1 }) : { async: !1 }, s = A._zod.run({ value: e, issues: [] }, n);
  if (s instanceof Promise)
    throw new su();
  if (s.issues.length) {
    const a = new ((i == null ? void 0 : i.Err) ?? t)(s.issues.map((g) => Bg(g, n, lg())));
    throw Ux(a, i == null ? void 0 : i.callee), a;
  }
  return s.value;
}, rp = /* @__PURE__ */ tp(ep), ip = (t) => async (A, e, r, i) => {
  const n = r ? Object.assign(r, { async: !0 }) : { async: !0 };
  let s = A._zod.run({ value: e, issues: [] }, n);
  if (s instanceof Promise && (s = await s), s.issues.length) {
    const a = new ((i == null ? void 0 : i.Err) ?? t)(s.issues.map((g) => Bg(g, n, lg())));
    throw Ux(a, i == null ? void 0 : i.callee), a;
  }
  return s.value;
}, Yx = /* @__PURE__ */ ip(ep), np = (t) => (A, e, r) => {
  const i = r ? { ...r, async: !1 } : { async: !1 }, n = A._zod.run({ value: e, issues: [] }, i);
  if (n instanceof Promise)
    throw new su();
  return n.issues.length ? {
    success: !1,
    error: new (t ?? Ox)(n.issues.map((s) => Bg(s, i, lg())))
  } : { success: !0, data: n.value };
}, tq = /* @__PURE__ */ np(ep), sp = (t) => async (A, e, r) => {
  const i = r ? Object.assign(r, { async: !0 }) : { async: !0 };
  let n = A._zod.run({ value: e, issues: [] }, i);
  return n instanceof Promise && (n = await n), n.issues.length ? {
    success: !1,
    error: new t(n.issues.map((s) => Bg(s, i, lg())))
  } : { success: !0, data: n.value };
}, rq = /* @__PURE__ */ sp(ep), iq = (t) => (A, e, r) => {
  const i = r ? Object.assign(r, { direction: "backward" }) : { direction: "backward" };
  return tp(t)(A, e, i);
}, nq = (t) => (A, e, r) => tp(t)(A, e, r), sq = (t) => async (A, e, r) => {
  const i = r ? Object.assign(r, { direction: "backward" }) : { direction: "backward" };
  return ip(t)(A, e, i);
}, aq = (t) => async (A, e, r) => ip(t)(A, e, r), oq = (t) => (A, e, r) => {
  const i = r ? Object.assign(r, { direction: "backward" }) : { direction: "backward" };
  return np(t)(A, e, i);
}, gq = (t) => (A, e, r) => np(t)(A, e, r), uq = (t) => async (A, e, r) => {
  const i = r ? Object.assign(r, { direction: "backward" }) : { direction: "backward" };
  return sp(t)(A, e, i);
}, cq = (t) => async (A, e, r) => sp(t)(A, e, r), Iq = /^[cC][^\s-]{8,}$/, Cq = /^[0-9a-z]+$/, lq = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/, Bq = /^[0-9a-vA-V]{20}$/, Eq = /^[A-Za-z0-9]{27}$/, hq = /^[a-zA-Z0-9_-]{21}$/, Qq = /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/, dq = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/, Pk = (t) => t ? new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${t}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`) : /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/, fq = /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/, pq = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
function yq() {
  return new RegExp(pq, "u");
}
const wq = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/, mq = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$/, Dq = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/, Sq = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/, Fq = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/, qx = /^[A-Za-z0-9_-]*$/, kq = /^\+(?:[0-9]){6,14}[0-9]$/, jx = "(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))", vq = /* @__PURE__ */ new RegExp(`^${jx}$`);
function Wx(t) {
  const A = "(?:[01]\\d|2[0-3]):[0-5]\\d";
  return typeof t.precision == "number" ? t.precision === -1 ? `${A}` : t.precision === 0 ? `${A}:[0-5]\\d` : `${A}:[0-5]\\d\\.\\d{${t.precision}}` : `${A}(?::[0-5]\\d(?:\\.\\d+)?)?`;
}
function Rq(t) {
  return new RegExp(`^${Wx(t)}$`);
}
function bq(t) {
  const A = Wx({ precision: t.precision }), e = ["Z"];
  t.local && e.push(""), t.offset && e.push("([+-](?:[01]\\d|2[0-3]):[0-5]\\d)");
  const r = `${A}(?:${e.join("|")})`;
  return new RegExp(`^${jx}T(?:${r})$`);
}
const Mq = (t) => {
  const A = t ? `[\\s\\S]{${(t == null ? void 0 : t.minimum) ?? 0},${(t == null ? void 0 : t.maximum) ?? ""}}` : "[\\s\\S]*";
  return new RegExp(`^${A}$`);
}, _q = /^[^A-Z]*$/, Nq = /^[^a-z]*$/, vn = /* @__PURE__ */ dA("$ZodCheck", (t, A) => {
  var e;
  t._zod ?? (t._zod = {}), t._zod.def = A, (e = t._zod).onattach ?? (e.onattach = []);
}), Lq = /* @__PURE__ */ dA("$ZodCheckMaxLength", (t, A) => {
  var e;
  vn.init(t, A), (e = t._zod.def).when ?? (e.when = (r) => {
    const i = r.value;
    return !$0(i) && i.length !== void 0;
  }), t._zod.onattach.push((r) => {
    const i = r._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    A.maximum < i && (r._zod.bag.maximum = A.maximum);
  }), t._zod.check = (r) => {
    const i = r.value;
    if (i.length <= A.maximum)
      return;
    const s = eS(i);
    r.issues.push({
      origin: s,
      code: "too_big",
      maximum: A.maximum,
      inclusive: !0,
      input: i,
      inst: t,
      continue: !A.abort
    });
  };
}), xq = /* @__PURE__ */ dA("$ZodCheckMinLength", (t, A) => {
  var e;
  vn.init(t, A), (e = t._zod.def).when ?? (e.when = (r) => {
    const i = r.value;
    return !$0(i) && i.length !== void 0;
  }), t._zod.onattach.push((r) => {
    const i = r._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    A.minimum > i && (r._zod.bag.minimum = A.minimum);
  }), t._zod.check = (r) => {
    const i = r.value;
    if (i.length >= A.minimum)
      return;
    const s = eS(i);
    r.issues.push({
      origin: s,
      code: "too_small",
      minimum: A.minimum,
      inclusive: !0,
      input: i,
      inst: t,
      continue: !A.abort
    });
  };
}), Gq = /* @__PURE__ */ dA("$ZodCheckLengthEquals", (t, A) => {
  var e;
  vn.init(t, A), (e = t._zod.def).when ?? (e.when = (r) => {
    const i = r.value;
    return !$0(i) && i.length !== void 0;
  }), t._zod.onattach.push((r) => {
    const i = r._zod.bag;
    i.minimum = A.length, i.maximum = A.length, i.length = A.length;
  }), t._zod.check = (r) => {
    const i = r.value, n = i.length;
    if (n === A.length)
      return;
    const s = eS(i), a = n > A.length;
    r.issues.push({
      origin: s,
      ...a ? { code: "too_big", maximum: A.length } : { code: "too_small", minimum: A.length },
      inclusive: !0,
      exact: !0,
      input: r.value,
      inst: t,
      continue: !A.abort
    });
  };
}), ap = /* @__PURE__ */ dA("$ZodCheckStringFormat", (t, A) => {
  var e, r;
  vn.init(t, A), t._zod.onattach.push((i) => {
    const n = i._zod.bag;
    n.format = A.format, A.pattern && (n.patterns ?? (n.patterns = /* @__PURE__ */ new Set()), n.patterns.add(A.pattern));
  }), A.pattern ? (e = t._zod).check ?? (e.check = (i) => {
    A.pattern.lastIndex = 0, !A.pattern.test(i.value) && i.issues.push({
      origin: "string",
      code: "invalid_format",
      format: A.format,
      input: i.value,
      ...A.pattern ? { pattern: A.pattern.toString() } : {},
      inst: t,
      continue: !A.abort
    });
  }) : (r = t._zod).check ?? (r.check = () => {
  });
}), Uq = /* @__PURE__ */ dA("$ZodCheckRegex", (t, A) => {
  ap.init(t, A), t._zod.check = (e) => {
    A.pattern.lastIndex = 0, !A.pattern.test(e.value) && e.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "regex",
      input: e.value,
      pattern: A.pattern.toString(),
      inst: t,
      continue: !A.abort
    });
  };
}), Tq = /* @__PURE__ */ dA("$ZodCheckLowerCase", (t, A) => {
  A.pattern ?? (A.pattern = _q), ap.init(t, A);
}), Kq = /* @__PURE__ */ dA("$ZodCheckUpperCase", (t, A) => {
  A.pattern ?? (A.pattern = Nq), ap.init(t, A);
}), Jq = /* @__PURE__ */ dA("$ZodCheckIncludes", (t, A) => {
  vn.init(t, A);
  const e = Ap(A.includes), r = new RegExp(typeof A.position == "number" ? `^.{${A.position}}${e}` : e);
  A.pattern = r, t._zod.onattach.push((i) => {
    const n = i._zod.bag;
    n.patterns ?? (n.patterns = /* @__PURE__ */ new Set()), n.patterns.add(r);
  }), t._zod.check = (i) => {
    i.value.includes(A.includes, A.position) || i.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "includes",
      includes: A.includes,
      input: i.value,
      inst: t,
      continue: !A.abort
    });
  };
}), Hq = /* @__PURE__ */ dA("$ZodCheckStartsWith", (t, A) => {
  vn.init(t, A);
  const e = new RegExp(`^${Ap(A.prefix)}.*`);
  A.pattern ?? (A.pattern = e), t._zod.onattach.push((r) => {
    const i = r._zod.bag;
    i.patterns ?? (i.patterns = /* @__PURE__ */ new Set()), i.patterns.add(e);
  }), t._zod.check = (r) => {
    r.value.startsWith(A.prefix) || r.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "starts_with",
      prefix: A.prefix,
      input: r.value,
      inst: t,
      continue: !A.abort
    });
  };
}), Pq = /* @__PURE__ */ dA("$ZodCheckEndsWith", (t, A) => {
  vn.init(t, A);
  const e = new RegExp(`.*${Ap(A.suffix)}$`);
  A.pattern ?? (A.pattern = e), t._zod.onattach.push((r) => {
    const i = r._zod.bag;
    i.patterns ?? (i.patterns = /* @__PURE__ */ new Set()), i.patterns.add(e);
  }), t._zod.check = (r) => {
    r.value.endsWith(A.suffix) || r.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "ends_with",
      suffix: A.suffix,
      input: r.value,
      inst: t,
      continue: !A.abort
    });
  };
}), Oq = /* @__PURE__ */ dA("$ZodCheckOverwrite", (t, A) => {
  vn.init(t, A), t._zod.check = (e) => {
    e.value = A.tx(e.value);
  };
});
class Yq {
  constructor(A = []) {
    this.content = [], this.indent = 0, this && (this.args = A);
  }
  indented(A) {
    this.indent += 1, A(this), this.indent -= 1;
  }
  write(A) {
    if (typeof A == "function") {
      A(this, { execution: "sync" }), A(this, { execution: "async" });
      return;
    }
    const r = A.split(`
`).filter((s) => s), i = Math.min(...r.map((s) => s.length - s.trimStart().length)), n = r.map((s) => s.slice(i)).map((s) => " ".repeat(this.indent * 2) + s);
    for (const s of n)
      this.content.push(s);
  }
  compile() {
    const A = Function, e = this == null ? void 0 : this.args, i = [...((this == null ? void 0 : this.content) ?? [""]).map((n) => `  ${n}`)];
    return new A(...e, i.join(`
`));
  }
}
const qq = {
  major: 4,
  minor: 1,
  patch: 13
}, pt = /* @__PURE__ */ dA("$ZodType", (t, A) => {
  var i;
  var e;
  t ?? (t = {}), t._zod.def = A, t._zod.bag = t._zod.bag || {}, t._zod.version = qq;
  const r = [...t._zod.def.checks ?? []];
  t._zod.traits.has("$ZodCheck") && r.unshift(t);
  for (const n of r)
    for (const s of n._zod.onattach)
      s(t);
  if (r.length === 0)
    (e = t._zod).deferred ?? (e.deferred = []), (i = t._zod.deferred) == null || i.push(() => {
      t._zod.run = t._zod.parse;
    });
  else {
    const n = (a, g, o) => {
      let u = zg(a), I;
      for (const c of g) {
        if (c._zod.def.when) {
          if (!c._zod.def.when(a))
            continue;
        } else if (u)
          continue;
        const C = a.issues.length, E = c._zod.check(a);
        if (E instanceof Promise && (o == null ? void 0 : o.async) === !1)
          throw new su();
        if (I || E instanceof Promise)
          I = (I ?? Promise.resolve()).then(async () => {
            await E, a.issues.length !== C && (u || (u = zg(a, C)));
          });
        else {
          if (a.issues.length === C)
            continue;
          u || (u = zg(a, C));
        }
      }
      return I ? I.then(() => a) : a;
    }, s = (a, g, o) => {
      if (zg(a))
        return a.aborted = !0, a;
      const u = n(g, r, o);
      if (u instanceof Promise) {
        if (o.async === !1)
          throw new su();
        return u.then((I) => t._zod.parse(I, o));
      }
      return t._zod.parse(u, o);
    };
    t._zod.run = (a, g) => {
      if (g.skipChecks)
        return t._zod.parse(a, g);
      if (g.direction === "backward") {
        const u = t._zod.parse({ value: a.value, issues: [] }, { ...g, skipChecks: !0 });
        return u instanceof Promise ? u.then((I) => s(I, a, g)) : s(u, a, g);
      }
      const o = t._zod.parse(a, g);
      if (o instanceof Promise) {
        if (g.async === !1)
          throw new su();
        return o.then((u) => n(u, r, g));
      }
      return n(o, r, g);
    };
  }
  t["~standard"] = {
    validate: (n) => {
      var s;
      try {
        const a = tq(t, n);
        return a.success ? { value: a.data } : { issues: (s = a.error) == null ? void 0 : s.issues };
      } catch {
        return rq(t, n).then((g) => {
          var o;
          return g.success ? { value: g.data } : { issues: (o = g.error) == null ? void 0 : o.issues };
        });
      }
    },
    vendor: "zod",
    version: 1
  };
}), tS = /* @__PURE__ */ dA("$ZodString", (t, A) => {
  var e;
  pt.init(t, A), t._zod.pattern = [...((e = t == null ? void 0 : t._zod.bag) == null ? void 0 : e.patterns) ?? []].pop() ?? Mq(t._zod.bag), t._zod.parse = (r, i) => {
    if (A.coerce)
      try {
        r.value = String(r.value);
      } catch {
      }
    return typeof r.value == "string" || r.issues.push({
      expected: "string",
      code: "invalid_type",
      input: r.value,
      inst: t
    }), r;
  };
}), Ve = /* @__PURE__ */ dA("$ZodStringFormat", (t, A) => {
  ap.init(t, A), tS.init(t, A);
}), jq = /* @__PURE__ */ dA("$ZodGUID", (t, A) => {
  A.pattern ?? (A.pattern = dq), Ve.init(t, A);
}), Wq = /* @__PURE__ */ dA("$ZodUUID", (t, A) => {
  if (A.version) {
    const r = {
      v1: 1,
      v2: 2,
      v3: 3,
      v4: 4,
      v5: 5,
      v6: 6,
      v7: 7,
      v8: 8
    }[A.version];
    if (r === void 0)
      throw new Error(`Invalid UUID version: "${A.version}"`);
    A.pattern ?? (A.pattern = Pk(r));
  } else
    A.pattern ?? (A.pattern = Pk());
  Ve.init(t, A);
}), Vq = /* @__PURE__ */ dA("$ZodEmail", (t, A) => {
  A.pattern ?? (A.pattern = fq), Ve.init(t, A);
}), Zq = /* @__PURE__ */ dA("$ZodURL", (t, A) => {
  Ve.init(t, A), t._zod.check = (e) => {
    try {
      const r = e.value.trim(), i = new URL(r);
      A.hostname && (A.hostname.lastIndex = 0, A.hostname.test(i.hostname) || e.issues.push({
        code: "invalid_format",
        format: "url",
        note: "Invalid hostname",
        pattern: A.hostname.source,
        input: e.value,
        inst: t,
        continue: !A.abort
      })), A.protocol && (A.protocol.lastIndex = 0, A.protocol.test(i.protocol.endsWith(":") ? i.protocol.slice(0, -1) : i.protocol) || e.issues.push({
        code: "invalid_format",
        format: "url",
        note: "Invalid protocol",
        pattern: A.protocol.source,
        input: e.value,
        inst: t,
        continue: !A.abort
      })), A.normalize ? e.value = i.href : e.value = r;
      return;
    } catch {
      e.issues.push({
        code: "invalid_format",
        format: "url",
        input: e.value,
        inst: t,
        continue: !A.abort
      });
    }
  };
}), Xq = /* @__PURE__ */ dA("$ZodEmoji", (t, A) => {
  A.pattern ?? (A.pattern = yq()), Ve.init(t, A);
}), zq = /* @__PURE__ */ dA("$ZodNanoID", (t, A) => {
  A.pattern ?? (A.pattern = hq), Ve.init(t, A);
}), $q = /* @__PURE__ */ dA("$ZodCUID", (t, A) => {
  A.pattern ?? (A.pattern = Iq), Ve.init(t, A);
}), Aj = /* @__PURE__ */ dA("$ZodCUID2", (t, A) => {
  A.pattern ?? (A.pattern = Cq), Ve.init(t, A);
}), ej = /* @__PURE__ */ dA("$ZodULID", (t, A) => {
  A.pattern ?? (A.pattern = lq), Ve.init(t, A);
}), tj = /* @__PURE__ */ dA("$ZodXID", (t, A) => {
  A.pattern ?? (A.pattern = Bq), Ve.init(t, A);
}), rj = /* @__PURE__ */ dA("$ZodKSUID", (t, A) => {
  A.pattern ?? (A.pattern = Eq), Ve.init(t, A);
}), ij = /* @__PURE__ */ dA("$ZodISODateTime", (t, A) => {
  A.pattern ?? (A.pattern = bq(A)), Ve.init(t, A);
}), nj = /* @__PURE__ */ dA("$ZodISODate", (t, A) => {
  A.pattern ?? (A.pattern = vq), Ve.init(t, A);
}), sj = /* @__PURE__ */ dA("$ZodISOTime", (t, A) => {
  A.pattern ?? (A.pattern = Rq(A)), Ve.init(t, A);
}), aj = /* @__PURE__ */ dA("$ZodISODuration", (t, A) => {
  A.pattern ?? (A.pattern = Qq), Ve.init(t, A);
}), oj = /* @__PURE__ */ dA("$ZodIPv4", (t, A) => {
  A.pattern ?? (A.pattern = wq), Ve.init(t, A), t._zod.bag.format = "ipv4";
}), gj = /* @__PURE__ */ dA("$ZodIPv6", (t, A) => {
  A.pattern ?? (A.pattern = mq), Ve.init(t, A), t._zod.bag.format = "ipv6", t._zod.check = (e) => {
    try {
      new URL(`http://[${e.value}]`);
    } catch {
      e.issues.push({
        code: "invalid_format",
        format: "ipv6",
        input: e.value,
        inst: t,
        continue: !A.abort
      });
    }
  };
}), uj = /* @__PURE__ */ dA("$ZodCIDRv4", (t, A) => {
  A.pattern ?? (A.pattern = Dq), Ve.init(t, A);
}), cj = /* @__PURE__ */ dA("$ZodCIDRv6", (t, A) => {
  A.pattern ?? (A.pattern = Sq), Ve.init(t, A), t._zod.check = (e) => {
    const r = e.value.split("/");
    try {
      if (r.length !== 2)
        throw new Error();
      const [i, n] = r;
      if (!n)
        throw new Error();
      const s = Number(n);
      if (`${s}` !== n)
        throw new Error();
      if (s < 0 || s > 128)
        throw new Error();
      new URL(`http://[${i}]`);
    } catch {
      e.issues.push({
        code: "invalid_format",
        format: "cidrv6",
        input: e.value,
        inst: t,
        continue: !A.abort
      });
    }
  };
});
function Vx(t) {
  if (t === "")
    return !0;
  if (t.length % 4 !== 0)
    return !1;
  try {
    return atob(t), !0;
  } catch {
    return !1;
  }
}
const Ij = /* @__PURE__ */ dA("$ZodBase64", (t, A) => {
  A.pattern ?? (A.pattern = Fq), Ve.init(t, A), t._zod.bag.contentEncoding = "base64", t._zod.check = (e) => {
    Vx(e.value) || e.issues.push({
      code: "invalid_format",
      format: "base64",
      input: e.value,
      inst: t,
      continue: !A.abort
    });
  };
});
function Cj(t) {
  if (!qx.test(t))
    return !1;
  const A = t.replace(/[-_]/g, (r) => r === "-" ? "+" : "/"), e = A.padEnd(Math.ceil(A.length / 4) * 4, "=");
  return Vx(e);
}
const lj = /* @__PURE__ */ dA("$ZodBase64URL", (t, A) => {
  A.pattern ?? (A.pattern = qx), Ve.init(t, A), t._zod.bag.contentEncoding = "base64url", t._zod.check = (e) => {
    Cj(e.value) || e.issues.push({
      code: "invalid_format",
      format: "base64url",
      input: e.value,
      inst: t,
      continue: !A.abort
    });
  };
}), Bj = /* @__PURE__ */ dA("$ZodE164", (t, A) => {
  A.pattern ?? (A.pattern = kq), Ve.init(t, A);
});
function Ej(t, A = null) {
  try {
    const e = t.split(".");
    if (e.length !== 3)
      return !1;
    const [r] = e;
    if (!r)
      return !1;
    const i = JSON.parse(atob(r));
    return !("typ" in i && (i == null ? void 0 : i.typ) !== "JWT" || !i.alg || A && (!("alg" in i) || i.alg !== A));
  } catch {
    return !1;
  }
}
const hj = /* @__PURE__ */ dA("$ZodJWT", (t, A) => {
  Ve.init(t, A), t._zod.check = (e) => {
    Ej(e.value, A.alg) || e.issues.push({
      code: "invalid_format",
      format: "jwt",
      input: e.value,
      inst: t,
      continue: !A.abort
    });
  };
}), Zx = /* @__PURE__ */ dA("$ZodUnknown", (t, A) => {
  pt.init(t, A), t._zod.parse = (e) => e;
}), Xx = /* @__PURE__ */ dA("$ZodNever", (t, A) => {
  pt.init(t, A), t._zod.parse = (e, r) => (e.issues.push({
    expected: "never",
    code: "invalid_type",
    input: e.value,
    inst: t
  }), e);
});
function Ok(t, A, e) {
  t.issues.length && A.issues.push(...Hx(e, t.issues)), A.value[e] = t.value;
}
const Qj = /* @__PURE__ */ dA("$ZodArray", (t, A) => {
  pt.init(t, A), t._zod.parse = (e, r) => {
    const i = e.value;
    if (!Array.isArray(i))
      return e.issues.push({
        expected: "array",
        code: "invalid_type",
        input: i,
        inst: t
      }), e;
    e.value = Array(i.length);
    const n = [];
    for (let s = 0; s < i.length; s++) {
      const a = i[s], g = A.element._zod.run({
        value: a,
        issues: []
      }, r);
      g instanceof Promise ? n.push(g.then((o) => Ok(o, e, s))) : Ok(g, e, s);
    }
    return n.length ? Promise.all(n).then(() => e) : e;
  };
});
function Fd(t, A, e, r) {
  t.issues.length && A.issues.push(...Hx(e, t.issues)), t.value === void 0 ? e in r && (A.value[e] = void 0) : A.value[e] = t.value;
}
function zx(t) {
  var r, i, n, s;
  const A = Object.keys(t.shape);
  for (const a of A)
    if (!((s = (n = (i = (r = t.shape) == null ? void 0 : r[a]) == null ? void 0 : i._zod) == null ? void 0 : n.traits) != null && s.has("$ZodType")))
      throw new Error(`Invalid element at key "${a}": expected a Zod schema`);
  const e = q3(t.shape);
  return {
    ...t,
    keys: A,
    keySet: new Set(A),
    numKeys: A.length,
    optionalKeys: new Set(e)
  };
}
function $x(t, A, e, r, i, n) {
  const s = [], a = i.keySet, g = i.catchall._zod, o = g.def.type;
  for (const u in A) {
    if (a.has(u))
      continue;
    if (o === "never") {
      s.push(u);
      continue;
    }
    const I = g.run({ value: A[u], issues: [] }, r);
    I instanceof Promise ? t.push(I.then((c) => Fd(c, e, u, A))) : Fd(I, e, u, A);
  }
  return s.length && e.issues.push({
    code: "unrecognized_keys",
    keys: s,
    input: A,
    inst: n
  }), t.length ? Promise.all(t).then(() => e) : e;
}
const dj = /* @__PURE__ */ dA("$ZodObject", (t, A) => {
  pt.init(t, A);
  const e = Object.getOwnPropertyDescriptor(A, "shape");
  if (!(e != null && e.get)) {
    const a = A.shape;
    Object.defineProperty(A, "shape", {
      get: () => {
        const g = { ...a };
        return Object.defineProperty(A, "shape", {
          value: g
        }), g;
      }
    });
  }
  const r = z0(() => zx(A));
  Pe(t._zod, "propValues", () => {
    const a = A.shape, g = {};
    for (const o in a) {
      const u = a[o]._zod;
      if (u.values) {
        g[o] ?? (g[o] = /* @__PURE__ */ new Set());
        for (const I of u.values)
          g[o].add(I);
      }
    }
    return g;
  });
  const i = Sd, n = A.catchall;
  let s;
  t._zod.parse = (a, g) => {
    s ?? (s = r.value);
    const o = a.value;
    if (!i(o))
      return a.issues.push({
        expected: "object",
        code: "invalid_type",
        input: o,
        inst: t
      }), a;
    a.value = {};
    const u = [], I = s.shape;
    for (const c of s.keys) {
      const E = I[c]._zod.run({ value: o[c], issues: [] }, g);
      E instanceof Promise ? u.push(E.then((l) => Fd(l, a, c, o))) : Fd(E, a, c, o);
    }
    return n ? $x(u, o, a, g, r.value, t) : u.length ? Promise.all(u).then(() => a) : a;
  };
}), fj = /* @__PURE__ */ dA("$ZodObjectJIT", (t, A) => {
  dj.init(t, A);
  const e = t._zod.parse, r = z0(() => zx(A)), i = (c) => {
    const C = new Yq(["shape", "payload", "ctx"]), E = r.value, l = (f) => {
      const p = Hk(f);
      return `shape[${p}]._zod.run({ value: input[${p}], issues: [] }, ctx)`;
    };
    C.write("const input = payload.value;");
    const B = /* @__PURE__ */ Object.create(null);
    let h = 0;
    for (const f of E.keys)
      B[f] = `key_${h++}`;
    C.write("const newResult = {};");
    for (const f of E.keys) {
      const p = B[f], y = Hk(f);
      C.write(`const ${p} = ${l(f)};`), C.write(`
        if (${p}.issues.length) {
          payload.issues = payload.issues.concat(${p}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${y}, ...iss.path] : [${y}]
          })));
        }
        
        
        if (${p}.value === undefined) {
          if (${y} in input) {
            newResult[${y}] = undefined;
          }
        } else {
          newResult[${y}] = ${p}.value;
        }
        
      `);
    }
    C.write("payload.value = newResult;"), C.write("return payload;");
    const Q = C.compile();
    return (f, p) => Q(c, f, p);
  };
  let n;
  const s = Sd, a = !xx.jitless, o = a && O3.value, u = A.catchall;
  let I;
  t._zod.parse = (c, C) => {
    I ?? (I = r.value);
    const E = c.value;
    return s(E) ? a && o && (C == null ? void 0 : C.async) === !1 && C.jitless !== !0 ? (n || (n = i(A.shape)), c = n(c, C), u ? $x([], E, c, C, I, t) : c) : e(c, C) : (c.issues.push({
      expected: "object",
      code: "invalid_type",
      input: E,
      inst: t
    }), c);
  };
});
function Yk(t, A, e, r) {
  for (const n of t)
    if (n.issues.length === 0)
      return A.value = n.value, A;
  const i = t.filter((n) => !zg(n));
  return i.length === 1 ? (A.value = i[0].value, i[0]) : (A.issues.push({
    code: "invalid_union",
    input: A.value,
    inst: e,
    errors: t.map((n) => n.issues.map((s) => Bg(s, r, lg())))
  }), A);
}
const pj = /* @__PURE__ */ dA("$ZodUnion", (t, A) => {
  pt.init(t, A), Pe(t._zod, "optin", () => A.options.some((i) => i._zod.optin === "optional") ? "optional" : void 0), Pe(t._zod, "optout", () => A.options.some((i) => i._zod.optout === "optional") ? "optional" : void 0), Pe(t._zod, "values", () => {
    if (A.options.every((i) => i._zod.values))
      return new Set(A.options.flatMap((i) => Array.from(i._zod.values)));
  }), Pe(t._zod, "pattern", () => {
    if (A.options.every((i) => i._zod.pattern)) {
      const i = A.options.map((n) => n._zod.pattern);
      return new RegExp(`^(${i.map((n) => AS(n.source)).join("|")})$`);
    }
  });
  const e = A.options.length === 1, r = A.options[0]._zod.run;
  t._zod.parse = (i, n) => {
    if (e)
      return r(i, n);
    let s = !1;
    const a = [];
    for (const g of A.options) {
      const o = g._zod.run({
        value: i.value,
        issues: []
      }, n);
      if (o instanceof Promise)
        a.push(o), s = !0;
      else {
        if (o.issues.length === 0)
          return o;
        a.push(o);
      }
    }
    return s ? Promise.all(a).then((g) => Yk(g, i, t, n)) : Yk(a, i, t, n);
  };
}), yj = /* @__PURE__ */ dA("$ZodIntersection", (t, A) => {
  pt.init(t, A), t._zod.parse = (e, r) => {
    const i = e.value, n = A.left._zod.run({ value: i, issues: [] }, r), s = A.right._zod.run({ value: i, issues: [] }, r);
    return n instanceof Promise || s instanceof Promise ? Promise.all([n, s]).then(([g, o]) => qk(e, g, o)) : qk(e, n, s);
  };
});
function sm(t, A) {
  if (t === A)
    return { valid: !0, data: t };
  if (t instanceof Date && A instanceof Date && +t == +A)
    return { valid: !0, data: t };
  if (Al(t) && Al(A)) {
    const e = Object.keys(A), r = Object.keys(t).filter((n) => e.indexOf(n) !== -1), i = { ...t, ...A };
    for (const n of r) {
      const s = sm(t[n], A[n]);
      if (!s.valid)
        return {
          valid: !1,
          mergeErrorPath: [n, ...s.mergeErrorPath]
        };
      i[n] = s.data;
    }
    return { valid: !0, data: i };
  }
  if (Array.isArray(t) && Array.isArray(A)) {
    if (t.length !== A.length)
      return { valid: !1, mergeErrorPath: [] };
    const e = [];
    for (let r = 0; r < t.length; r++) {
      const i = t[r], n = A[r], s = sm(i, n);
      if (!s.valid)
        return {
          valid: !1,
          mergeErrorPath: [r, ...s.mergeErrorPath]
        };
      e.push(s.data);
    }
    return { valid: !0, data: e };
  }
  return { valid: !1, mergeErrorPath: [] };
}
function qk(t, A, e) {
  if (A.issues.length && t.issues.push(...A.issues), e.issues.length && t.issues.push(...e.issues), zg(t))
    return t;
  const r = sm(A.value, e.value);
  if (!r.valid)
    throw new Error(`Unmergable intersection. Error path: ${JSON.stringify(r.mergeErrorPath)}`);
  return t.value = r.data, t;
}
const wj = /* @__PURE__ */ dA("$ZodEnum", (t, A) => {
  pt.init(t, A);
  const e = Gx(A.entries), r = new Set(e);
  t._zod.values = r, t._zod.pattern = new RegExp(`^(${e.filter((i) => Y3.has(typeof i)).map((i) => typeof i == "string" ? Ap(i) : i.toString()).join("|")})$`), t._zod.parse = (i, n) => {
    const s = i.value;
    return r.has(s) || i.issues.push({
      code: "invalid_value",
      values: e,
      input: s,
      inst: t
    }), i;
  };
}), mj = /* @__PURE__ */ dA("$ZodTransform", (t, A) => {
  pt.init(t, A), t._zod.parse = (e, r) => {
    if (r.direction === "backward")
      throw new Lx(t.constructor.name);
    const i = A.transform(e.value, e);
    if (r.async)
      return (i instanceof Promise ? i : Promise.resolve(i)).then((s) => (e.value = s, e));
    if (i instanceof Promise)
      throw new su();
    return e.value = i, e;
  };
});
function jk(t, A) {
  return t.issues.length && A === void 0 ? { issues: [], value: void 0 } : t;
}
const rS = /* @__PURE__ */ dA("$ZodOptional", (t, A) => {
  pt.init(t, A), t._zod.optin = "optional", t._zod.optout = "optional", Pe(t._zod, "values", () => A.innerType._zod.values ? /* @__PURE__ */ new Set([...A.innerType._zod.values, void 0]) : void 0), Pe(t._zod, "pattern", () => {
    const e = A.innerType._zod.pattern;
    return e ? new RegExp(`^(${AS(e.source)})?$`) : void 0;
  }), t._zod.parse = (e, r) => {
    if (A.innerType._zod.optin === "optional") {
      const i = A.innerType._zod.run(e, r);
      return i instanceof Promise ? i.then((n) => jk(n, e.value)) : jk(i, e.value);
    }
    return e.value === void 0 ? e : A.innerType._zod.run(e, r);
  };
}), Dj = /* @__PURE__ */ dA("$ZodNullable", (t, A) => {
  pt.init(t, A), Pe(t._zod, "optin", () => A.innerType._zod.optin), Pe(t._zod, "optout", () => A.innerType._zod.optout), Pe(t._zod, "pattern", () => {
    const e = A.innerType._zod.pattern;
    return e ? new RegExp(`^(${AS(e.source)}|null)$`) : void 0;
  }), Pe(t._zod, "values", () => A.innerType._zod.values ? /* @__PURE__ */ new Set([...A.innerType._zod.values, null]) : void 0), t._zod.parse = (e, r) => e.value === null ? e : A.innerType._zod.run(e, r);
}), Sj = /* @__PURE__ */ dA("$ZodDefault", (t, A) => {
  pt.init(t, A), t._zod.optin = "optional", Pe(t._zod, "values", () => A.innerType._zod.values), t._zod.parse = (e, r) => {
    if (r.direction === "backward")
      return A.innerType._zod.run(e, r);
    if (e.value === void 0)
      return e.value = A.defaultValue, e;
    const i = A.innerType._zod.run(e, r);
    return i instanceof Promise ? i.then((n) => Wk(n, A)) : Wk(i, A);
  };
});
function Wk(t, A) {
  return t.value === void 0 && (t.value = A.defaultValue), t;
}
const Fj = /* @__PURE__ */ dA("$ZodPrefault", (t, A) => {
  pt.init(t, A), t._zod.optin = "optional", Pe(t._zod, "values", () => A.innerType._zod.values), t._zod.parse = (e, r) => (r.direction === "backward" || e.value === void 0 && (e.value = A.defaultValue), A.innerType._zod.run(e, r));
}), kj = /* @__PURE__ */ dA("$ZodNonOptional", (t, A) => {
  pt.init(t, A), Pe(t._zod, "values", () => {
    const e = A.innerType._zod.values;
    return e ? new Set([...e].filter((r) => r !== void 0)) : void 0;
  }), t._zod.parse = (e, r) => {
    const i = A.innerType._zod.run(e, r);
    return i instanceof Promise ? i.then((n) => Vk(n, t)) : Vk(i, t);
  };
});
function Vk(t, A) {
  return !t.issues.length && t.value === void 0 && t.issues.push({
    code: "invalid_type",
    expected: "nonoptional",
    input: t.value,
    inst: A
  }), t;
}
const vj = /* @__PURE__ */ dA("$ZodCatch", (t, A) => {
  pt.init(t, A), Pe(t._zod, "optin", () => A.innerType._zod.optin), Pe(t._zod, "optout", () => A.innerType._zod.optout), Pe(t._zod, "values", () => A.innerType._zod.values), t._zod.parse = (e, r) => {
    if (r.direction === "backward")
      return A.innerType._zod.run(e, r);
    const i = A.innerType._zod.run(e, r);
    return i instanceof Promise ? i.then((n) => (e.value = n.value, n.issues.length && (e.value = A.catchValue({
      ...e,
      error: {
        issues: n.issues.map((s) => Bg(s, r, lg()))
      },
      input: e.value
    }), e.issues = []), e)) : (e.value = i.value, i.issues.length && (e.value = A.catchValue({
      ...e,
      error: {
        issues: i.issues.map((n) => Bg(n, r, lg()))
      },
      input: e.value
    }), e.issues = []), e);
  };
}), Rj = /* @__PURE__ */ dA("$ZodPipe", (t, A) => {
  pt.init(t, A), Pe(t._zod, "values", () => A.in._zod.values), Pe(t._zod, "optin", () => A.in._zod.optin), Pe(t._zod, "optout", () => A.out._zod.optout), Pe(t._zod, "propValues", () => A.in._zod.propValues), t._zod.parse = (e, r) => {
    if (r.direction === "backward") {
      const n = A.out._zod.run(e, r);
      return n instanceof Promise ? n.then((s) => wh(s, A.in, r)) : wh(n, A.in, r);
    }
    const i = A.in._zod.run(e, r);
    return i instanceof Promise ? i.then((n) => wh(n, A.out, r)) : wh(i, A.out, r);
  };
});
function wh(t, A, e) {
  return t.issues.length ? (t.aborted = !0, t) : A._zod.run({ value: t.value, issues: t.issues }, e);
}
const bj = /* @__PURE__ */ dA("$ZodReadonly", (t, A) => {
  pt.init(t, A), Pe(t._zod, "propValues", () => A.innerType._zod.propValues), Pe(t._zod, "values", () => A.innerType._zod.values), Pe(t._zod, "optin", () => {
    var e, r;
    return (r = (e = A.innerType) == null ? void 0 : e._zod) == null ? void 0 : r.optin;
  }), Pe(t._zod, "optout", () => {
    var e, r;
    return (r = (e = A.innerType) == null ? void 0 : e._zod) == null ? void 0 : r.optout;
  }), t._zod.parse = (e, r) => {
    if (r.direction === "backward")
      return A.innerType._zod.run(e, r);
    const i = A.innerType._zod.run(e, r);
    return i instanceof Promise ? i.then(Zk) : Zk(i);
  };
});
function Zk(t) {
  return t.value = Object.freeze(t.value), t;
}
const Mj = /* @__PURE__ */ dA("$ZodCustom", (t, A) => {
  vn.init(t, A), pt.init(t, A), t._zod.parse = (e, r) => e, t._zod.check = (e) => {
    const r = e.value, i = A.fn(r);
    if (i instanceof Promise)
      return i.then((n) => Xk(n, e, r, t));
    Xk(i, e, r, t);
  };
});
function Xk(t, A, e, r) {
  if (!t) {
    const i = {
      code: "custom",
      input: e,
      inst: r,
      // incorporates params.error into issue reporting
      path: [...r._zod.def.path ?? []],
      // incorporates params.error into issue reporting
      continue: !r._zod.def.abort
      // params: inst._zod.def.params,
    };
    r._zod.def.params && (i.params = r._zod.def.params), A.issues.push(el(i));
  }
}
var zk;
class AG {
  constructor() {
    this._map = /* @__PURE__ */ new WeakMap(), this._idmap = /* @__PURE__ */ new Map();
  }
  add(A, ...e) {
    const r = e[0];
    if (this._map.set(A, r), r && typeof r == "object" && "id" in r) {
      if (this._idmap.has(r.id))
        throw new Error(`ID ${r.id} already exists in the registry`);
      this._idmap.set(r.id, A);
    }
    return this;
  }
  clear() {
    return this._map = /* @__PURE__ */ new WeakMap(), this._idmap = /* @__PURE__ */ new Map(), this;
  }
  remove(A) {
    const e = this._map.get(A);
    return e && typeof e == "object" && "id" in e && this._idmap.delete(e.id), this._map.delete(A), this;
  }
  get(A) {
    const e = A._zod.parent;
    if (e) {
      const r = { ...this.get(e) ?? {} };
      delete r.id;
      const i = { ...r, ...this._map.get(A) };
      return Object.keys(i).length ? i : void 0;
    }
    return this._map.get(A);
  }
  has(A) {
    return this._map.has(A);
  }
}
function _j() {
  return new AG();
}
(zk = globalThis).__zod_globalRegistry ?? (zk.__zod_globalRegistry = _j());
const Rt = globalThis.__zod_globalRegistry;
function Nj(t, A) {
  return new t({
    type: "string",
    ...ee(A)
  });
}
function Lj(t, A) {
  return new t({
    type: "string",
    format: "email",
    check: "string_format",
    abort: !1,
    ...ee(A)
  });
}
function $k(t, A) {
  return new t({
    type: "string",
    format: "guid",
    check: "string_format",
    abort: !1,
    ...ee(A)
  });
}
function xj(t, A) {
  return new t({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    ...ee(A)
  });
}
function Gj(t, A) {
  return new t({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    version: "v4",
    ...ee(A)
  });
}
function Uj(t, A) {
  return new t({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    version: "v6",
    ...ee(A)
  });
}
function Tj(t, A) {
  return new t({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    version: "v7",
    ...ee(A)
  });
}
function Kj(t, A) {
  return new t({
    type: "string",
    format: "url",
    check: "string_format",
    abort: !1,
    ...ee(A)
  });
}
function Jj(t, A) {
  return new t({
    type: "string",
    format: "emoji",
    check: "string_format",
    abort: !1,
    ...ee(A)
  });
}
function Hj(t, A) {
  return new t({
    type: "string",
    format: "nanoid",
    check: "string_format",
    abort: !1,
    ...ee(A)
  });
}
function Pj(t, A) {
  return new t({
    type: "string",
    format: "cuid",
    check: "string_format",
    abort: !1,
    ...ee(A)
  });
}
function Oj(t, A) {
  return new t({
    type: "string",
    format: "cuid2",
    check: "string_format",
    abort: !1,
    ...ee(A)
  });
}
function Yj(t, A) {
  return new t({
    type: "string",
    format: "ulid",
    check: "string_format",
    abort: !1,
    ...ee(A)
  });
}
function qj(t, A) {
  return new t({
    type: "string",
    format: "xid",
    check: "string_format",
    abort: !1,
    ...ee(A)
  });
}
function jj(t, A) {
  return new t({
    type: "string",
    format: "ksuid",
    check: "string_format",
    abort: !1,
    ...ee(A)
  });
}
function Wj(t, A) {
  return new t({
    type: "string",
    format: "ipv4",
    check: "string_format",
    abort: !1,
    ...ee(A)
  });
}
function Vj(t, A) {
  return new t({
    type: "string",
    format: "ipv6",
    check: "string_format",
    abort: !1,
    ...ee(A)
  });
}
function Zj(t, A) {
  return new t({
    type: "string",
    format: "cidrv4",
    check: "string_format",
    abort: !1,
    ...ee(A)
  });
}
function Xj(t, A) {
  return new t({
    type: "string",
    format: "cidrv6",
    check: "string_format",
    abort: !1,
    ...ee(A)
  });
}
function zj(t, A) {
  return new t({
    type: "string",
    format: "base64",
    check: "string_format",
    abort: !1,
    ...ee(A)
  });
}
function $j(t, A) {
  return new t({
    type: "string",
    format: "base64url",
    check: "string_format",
    abort: !1,
    ...ee(A)
  });
}
function A5(t, A) {
  return new t({
    type: "string",
    format: "e164",
    check: "string_format",
    abort: !1,
    ...ee(A)
  });
}
function e5(t, A) {
  return new t({
    type: "string",
    format: "jwt",
    check: "string_format",
    abort: !1,
    ...ee(A)
  });
}
function t5(t, A) {
  return new t({
    type: "string",
    format: "datetime",
    check: "string_format",
    offset: !1,
    local: !1,
    precision: null,
    ...ee(A)
  });
}
function r5(t, A) {
  return new t({
    type: "string",
    format: "date",
    check: "string_format",
    ...ee(A)
  });
}
function i5(t, A) {
  return new t({
    type: "string",
    format: "time",
    check: "string_format",
    precision: null,
    ...ee(A)
  });
}
function n5(t, A) {
  return new t({
    type: "string",
    format: "duration",
    check: "string_format",
    ...ee(A)
  });
}
function eG(t) {
  return new t({
    type: "unknown"
  });
}
function tG(t, A) {
  return new t({
    type: "never",
    ...ee(A)
  });
}
function rG(t, A) {
  return new Lq({
    check: "max_length",
    ...ee(A),
    maximum: t
  });
}
function kd(t, A) {
  return new xq({
    check: "min_length",
    ...ee(A),
    minimum: t
  });
}
function iG(t, A) {
  return new Gq({
    check: "length_equals",
    ...ee(A),
    length: t
  });
}
function s5(t, A) {
  return new Uq({
    check: "string_format",
    format: "regex",
    ...ee(A),
    pattern: t
  });
}
function a5(t) {
  return new Tq({
    check: "string_format",
    format: "lowercase",
    ...ee(t)
  });
}
function o5(t) {
  return new Kq({
    check: "string_format",
    format: "uppercase",
    ...ee(t)
  });
}
function g5(t, A) {
  return new Jq({
    check: "string_format",
    format: "includes",
    ...ee(A),
    includes: t
  });
}
function u5(t, A) {
  return new Hq({
    check: "string_format",
    format: "starts_with",
    ...ee(A),
    prefix: t
  });
}
function c5(t, A) {
  return new Pq({
    check: "string_format",
    format: "ends_with",
    ...ee(A),
    suffix: t
  });
}
function gI(t) {
  return new Oq({
    check: "overwrite",
    tx: t
  });
}
function I5(t) {
  return gI((A) => A.normalize(t));
}
function C5() {
  return gI((t) => t.trim());
}
function l5() {
  return gI((t) => t.toLowerCase());
}
function B5() {
  return gI((t) => t.toUpperCase());
}
function E5() {
  return gI((t) => P3(t));
}
function h5(t, A, e) {
  return new t({
    type: "array",
    element: A,
    // get element() {
    //   return element;
    // },
    ...ee(e)
  });
}
function Q5(t, A, e) {
  return new t({
    type: "custom",
    check: "custom",
    fn: A,
    ...ee(e)
  });
}
function d5(t) {
  const A = f5((e) => (e.addIssue = (r) => {
    if (typeof r == "string")
      e.issues.push(el(r, e.value, A._zod.def));
    else {
      const i = r;
      i.fatal && (i.continue = !1), i.code ?? (i.code = "custom"), i.input ?? (i.input = e.value), i.inst ?? (i.inst = A), i.continue ?? (i.continue = !A._zod.def.abort), e.issues.push(el(i));
    }
  }, t(e.value, e)));
  return A;
}
function f5(t, A) {
  const e = new vn({
    check: "custom",
    ...ee(A)
  });
  return e._zod.check = t, e;
}
class Av {
  constructor(A) {
    this.counter = 0, this.metadataRegistry = (A == null ? void 0 : A.metadata) ?? Rt, this.target = (A == null ? void 0 : A.target) ?? "draft-2020-12", this.unrepresentable = (A == null ? void 0 : A.unrepresentable) ?? "throw", this.override = (A == null ? void 0 : A.override) ?? (() => {
    }), this.io = (A == null ? void 0 : A.io) ?? "output", this.seen = /* @__PURE__ */ new Map();
  }
  process(A, e = { path: [], schemaPath: [] }) {
    var I, c, C;
    var r;
    const i = A._zod.def, n = {
      guid: "uuid",
      url: "uri",
      datetime: "date-time",
      json_string: "json-string",
      regex: ""
      // do not set
    }, s = this.seen.get(A);
    if (s)
      return s.count++, e.schemaPath.includes(A) && (s.cycle = e.path), s.schema;
    const a = { schema: {}, count: 1, cycle: void 0, path: e.path };
    this.seen.set(A, a);
    const g = (c = (I = A._zod).toJSONSchema) == null ? void 0 : c.call(I);
    if (g)
      a.schema = g;
    else {
      const E = {
        ...e,
        schemaPath: [...e.schemaPath, A],
        path: e.path
      }, l = A._zod.parent;
      if (l)
        a.ref = l, this.process(l, E), this.seen.get(l).isParent = !0;
      else {
        const B = a.schema;
        switch (i.type) {
          case "string": {
            const h = B;
            h.type = "string";
            const { minimum: Q, maximum: f, format: p, patterns: y, contentEncoding: m } = A._zod.bag;
            if (typeof Q == "number" && (h.minLength = Q), typeof f == "number" && (h.maxLength = f), p && (h.format = n[p] ?? p, h.format === "" && delete h.format), m && (h.contentEncoding = m), y && y.size > 0) {
              const S = [...y];
              S.length === 1 ? h.pattern = S[0].source : S.length > 1 && (a.schema.allOf = [
                ...S.map((w) => ({
                  ...this.target === "draft-7" || this.target === "draft-4" || this.target === "openapi-3.0" ? { type: "string" } : {},
                  pattern: w.source
                }))
              ]);
            }
            break;
          }
          case "number": {
            const h = B, { minimum: Q, maximum: f, format: p, multipleOf: y, exclusiveMaximum: m, exclusiveMinimum: S } = A._zod.bag;
            typeof p == "string" && p.includes("int") ? h.type = "integer" : h.type = "number", typeof S == "number" && (this.target === "draft-4" || this.target === "openapi-3.0" ? (h.minimum = S, h.exclusiveMinimum = !0) : h.exclusiveMinimum = S), typeof Q == "number" && (h.minimum = Q, typeof S == "number" && this.target !== "draft-4" && (S >= Q ? delete h.minimum : delete h.exclusiveMinimum)), typeof m == "number" && (this.target === "draft-4" || this.target === "openapi-3.0" ? (h.maximum = m, h.exclusiveMaximum = !0) : h.exclusiveMaximum = m), typeof f == "number" && (h.maximum = f, typeof m == "number" && this.target !== "draft-4" && (m <= f ? delete h.maximum : delete h.exclusiveMaximum)), typeof y == "number" && (h.multipleOf = y);
            break;
          }
          case "boolean": {
            const h = B;
            h.type = "boolean";
            break;
          }
          case "bigint": {
            if (this.unrepresentable === "throw")
              throw new Error("BigInt cannot be represented in JSON Schema");
            break;
          }
          case "symbol": {
            if (this.unrepresentable === "throw")
              throw new Error("Symbols cannot be represented in JSON Schema");
            break;
          }
          case "null": {
            this.target === "openapi-3.0" ? (B.type = "string", B.nullable = !0, B.enum = [null]) : B.type = "null";
            break;
          }
          case "any":
            break;
          case "unknown":
            break;
          case "undefined": {
            if (this.unrepresentable === "throw")
              throw new Error("Undefined cannot be represented in JSON Schema");
            break;
          }
          case "void": {
            if (this.unrepresentable === "throw")
              throw new Error("Void cannot be represented in JSON Schema");
            break;
          }
          case "never": {
            B.not = {};
            break;
          }
          case "date": {
            if (this.unrepresentable === "throw")
              throw new Error("Date cannot be represented in JSON Schema");
            break;
          }
          case "array": {
            const h = B, { minimum: Q, maximum: f } = A._zod.bag;
            typeof Q == "number" && (h.minItems = Q), typeof f == "number" && (h.maxItems = f), h.type = "array", h.items = this.process(i.element, { ...E, path: [...E.path, "items"] });
            break;
          }
          case "object": {
            const h = B;
            h.type = "object", h.properties = {};
            const Q = i.shape;
            for (const y in Q)
              h.properties[y] = this.process(Q[y], {
                ...E,
                path: [...E.path, "properties", y]
              });
            const f = new Set(Object.keys(Q)), p = new Set([...f].filter((y) => {
              const m = i.shape[y]._zod;
              return this.io === "input" ? m.optin === void 0 : m.optout === void 0;
            }));
            p.size > 0 && (h.required = Array.from(p)), ((C = i.catchall) == null ? void 0 : C._zod.def.type) === "never" ? h.additionalProperties = !1 : i.catchall ? i.catchall && (h.additionalProperties = this.process(i.catchall, {
              ...E,
              path: [...E.path, "additionalProperties"]
            })) : this.io === "output" && (h.additionalProperties = !1);
            break;
          }
          case "union": {
            const h = B, Q = i.discriminator !== void 0, f = i.options.map((p, y) => this.process(p, {
              ...E,
              path: [...E.path, Q ? "oneOf" : "anyOf", y]
            }));
            Q ? h.oneOf = f : h.anyOf = f;
            break;
          }
          case "intersection": {
            const h = B, Q = this.process(i.left, {
              ...E,
              path: [...E.path, "allOf", 0]
            }), f = this.process(i.right, {
              ...E,
              path: [...E.path, "allOf", 1]
            }), p = (m) => "allOf" in m && Object.keys(m).length === 1, y = [
              ...p(Q) ? Q.allOf : [Q],
              ...p(f) ? f.allOf : [f]
            ];
            h.allOf = y;
            break;
          }
          case "tuple": {
            const h = B;
            h.type = "array";
            const Q = this.target === "draft-2020-12" ? "prefixItems" : "items", f = this.target === "draft-2020-12" || this.target === "openapi-3.0" ? "items" : "additionalItems", p = i.items.map((w, F) => this.process(w, {
              ...E,
              path: [...E.path, Q, F]
            })), y = i.rest ? this.process(i.rest, {
              ...E,
              path: [...E.path, f, ...this.target === "openapi-3.0" ? [i.items.length] : []]
            }) : null;
            this.target === "draft-2020-12" ? (h.prefixItems = p, y && (h.items = y)) : this.target === "openapi-3.0" ? (h.items = {
              anyOf: p
            }, y && h.items.anyOf.push(y), h.minItems = p.length, y || (h.maxItems = p.length)) : (h.items = p, y && (h.additionalItems = y));
            const { minimum: m, maximum: S } = A._zod.bag;
            typeof m == "number" && (h.minItems = m), typeof S == "number" && (h.maxItems = S);
            break;
          }
          case "record": {
            const h = B;
            h.type = "object", (this.target === "draft-7" || this.target === "draft-2020-12") && (h.propertyNames = this.process(i.keyType, {
              ...E,
              path: [...E.path, "propertyNames"]
            })), h.additionalProperties = this.process(i.valueType, {
              ...E,
              path: [...E.path, "additionalProperties"]
            });
            break;
          }
          case "map": {
            if (this.unrepresentable === "throw")
              throw new Error("Map cannot be represented in JSON Schema");
            break;
          }
          case "set": {
            if (this.unrepresentable === "throw")
              throw new Error("Set cannot be represented in JSON Schema");
            break;
          }
          case "enum": {
            const h = B, Q = Gx(i.entries);
            Q.every((f) => typeof f == "number") && (h.type = "number"), Q.every((f) => typeof f == "string") && (h.type = "string"), h.enum = Q;
            break;
          }
          case "literal": {
            const h = B, Q = [];
            for (const f of i.values)
              if (f === void 0) {
                if (this.unrepresentable === "throw")
                  throw new Error("Literal `undefined` cannot be represented in JSON Schema");
              } else if (typeof f == "bigint") {
                if (this.unrepresentable === "throw")
                  throw new Error("BigInt literals cannot be represented in JSON Schema");
                Q.push(Number(f));
              } else
                Q.push(f);
            if (Q.length !== 0) if (Q.length === 1) {
              const f = Q[0];
              h.type = f === null ? "null" : typeof f, this.target === "draft-4" || this.target === "openapi-3.0" ? h.enum = [f] : h.const = f;
            } else
              Q.every((f) => typeof f == "number") && (h.type = "number"), Q.every((f) => typeof f == "string") && (h.type = "string"), Q.every((f) => typeof f == "boolean") && (h.type = "string"), Q.every((f) => f === null) && (h.type = "null"), h.enum = Q;
            break;
          }
          case "file": {
            const h = B, Q = {
              type: "string",
              format: "binary",
              contentEncoding: "binary"
            }, { minimum: f, maximum: p, mime: y } = A._zod.bag;
            f !== void 0 && (Q.minLength = f), p !== void 0 && (Q.maxLength = p), y ? y.length === 1 ? (Q.contentMediaType = y[0], Object.assign(h, Q)) : h.anyOf = y.map((m) => ({ ...Q, contentMediaType: m })) : Object.assign(h, Q);
            break;
          }
          case "transform": {
            if (this.unrepresentable === "throw")
              throw new Error("Transforms cannot be represented in JSON Schema");
            break;
          }
          case "nullable": {
            const h = this.process(i.innerType, E);
            this.target === "openapi-3.0" ? (a.ref = i.innerType, B.nullable = !0) : B.anyOf = [h, { type: "null" }];
            break;
          }
          case "nonoptional": {
            this.process(i.innerType, E), a.ref = i.innerType;
            break;
          }
          case "success": {
            const h = B;
            h.type = "boolean";
            break;
          }
          case "default": {
            this.process(i.innerType, E), a.ref = i.innerType, B.default = JSON.parse(JSON.stringify(i.defaultValue));
            break;
          }
          case "prefault": {
            this.process(i.innerType, E), a.ref = i.innerType, this.io === "input" && (B._prefault = JSON.parse(JSON.stringify(i.defaultValue)));
            break;
          }
          case "catch": {
            this.process(i.innerType, E), a.ref = i.innerType;
            let h;
            try {
              h = i.catchValue(void 0);
            } catch {
              throw new Error("Dynamic catch values are not supported in JSON Schema");
            }
            B.default = h;
            break;
          }
          case "nan": {
            if (this.unrepresentable === "throw")
              throw new Error("NaN cannot be represented in JSON Schema");
            break;
          }
          case "template_literal": {
            const h = B, Q = A._zod.pattern;
            if (!Q)
              throw new Error("Pattern not found in template literal");
            h.type = "string", h.pattern = Q.source;
            break;
          }
          case "pipe": {
            const h = this.io === "input" ? i.in._zod.def.type === "transform" ? i.out : i.in : i.out;
            this.process(h, E), a.ref = h;
            break;
          }
          case "readonly": {
            this.process(i.innerType, E), a.ref = i.innerType, B.readOnly = !0;
            break;
          }
          case "promise": {
            this.process(i.innerType, E), a.ref = i.innerType;
            break;
          }
          case "optional": {
            this.process(i.innerType, E), a.ref = i.innerType;
            break;
          }
          case "lazy": {
            const h = A._zod.innerType;
            this.process(h, E), a.ref = h;
            break;
          }
          case "custom": {
            if (this.unrepresentable === "throw")
              throw new Error("Custom types cannot be represented in JSON Schema");
            break;
          }
          case "function": {
            if (this.unrepresentable === "throw")
              throw new Error("Function types cannot be represented in JSON Schema");
            break;
          }
        }
      }
    }
    const o = this.metadataRegistry.get(A);
    return o && Object.assign(a.schema, o), this.io === "input" && er(A) && (delete a.schema.examples, delete a.schema.default), this.io === "input" && a.schema._prefault && ((r = a.schema).default ?? (r.default = a.schema._prefault)), delete a.schema._prefault, this.seen.get(A).schema;
  }
  emit(A, e) {
    var u, I, c, C, E, l;
    const r = {
      cycles: (e == null ? void 0 : e.cycles) ?? "ref",
      reused: (e == null ? void 0 : e.reused) ?? "inline",
      // unrepresentable: _params?.unrepresentable ?? "throw",
      // uri: _params?.uri ?? ((id) => `${id}`),
      external: (e == null ? void 0 : e.external) ?? void 0
    }, i = this.seen.get(A);
    if (!i)
      throw new Error("Unprocessed schema. This is a bug in Zod.");
    const n = (B) => {
      var y;
      const h = this.target === "draft-2020-12" ? "$defs" : "definitions";
      if (r.external) {
        const m = (y = r.external.registry.get(B[0])) == null ? void 0 : y.id, S = r.external.uri ?? ((F) => F);
        if (m)
          return { ref: S(m) };
        const w = B[1].defId ?? B[1].schema.id ?? `schema${this.counter++}`;
        return B[1].defId = w, { defId: w, ref: `${S("__shared")}#/${h}/${w}` };
      }
      if (B[1] === i)
        return { ref: "#" };
      const f = `#/${h}/`, p = B[1].schema.id ?? `__schema${this.counter++}`;
      return { defId: p, ref: f + p };
    }, s = (B) => {
      if (B[1].schema.$ref)
        return;
      const h = B[1], { ref: Q, defId: f } = n(B);
      h.def = { ...h.schema }, f && (h.defId = f);
      const p = h.schema;
      for (const y in p)
        delete p[y];
      p.$ref = Q;
    };
    if (r.cycles === "throw")
      for (const B of this.seen.entries()) {
        const h = B[1];
        if (h.cycle)
          throw new Error(`Cycle detected: #/${(u = h.cycle) == null ? void 0 : u.join("/")}/<root>

Set the \`cycles\` parameter to \`"ref"\` to resolve cyclical schemas with defs.`);
      }
    for (const B of this.seen.entries()) {
      const h = B[1];
      if (A === B[0]) {
        s(B);
        continue;
      }
      if (r.external) {
        const f = (I = r.external.registry.get(B[0])) == null ? void 0 : I.id;
        if (A !== B[0] && f) {
          s(B);
          continue;
        }
      }
      if ((c = this.metadataRegistry.get(B[0])) == null ? void 0 : c.id) {
        s(B);
        continue;
      }
      if (h.cycle) {
        s(B);
        continue;
      }
      if (h.count > 1 && r.reused === "ref") {
        s(B);
        continue;
      }
    }
    const a = (B, h) => {
      const Q = this.seen.get(B), f = Q.def ?? Q.schema, p = { ...f };
      if (Q.ref === null)
        return;
      const y = Q.ref;
      if (Q.ref = null, y) {
        a(y, h);
        const m = this.seen.get(y).schema;
        m.$ref && (h.target === "draft-7" || h.target === "draft-4" || h.target === "openapi-3.0") ? (f.allOf = f.allOf ?? [], f.allOf.push(m)) : (Object.assign(f, m), Object.assign(f, p));
      }
      Q.isParent || this.override({
        zodSchema: B,
        jsonSchema: f,
        path: Q.path ?? []
      });
    };
    for (const B of [...this.seen.entries()].reverse())
      a(B[0], { target: this.target });
    const g = {};
    if (this.target === "draft-2020-12" ? g.$schema = "https://json-schema.org/draft/2020-12/schema" : this.target === "draft-7" ? g.$schema = "http://json-schema.org/draft-07/schema#" : this.target === "draft-4" ? g.$schema = "http://json-schema.org/draft-04/schema#" : this.target === "openapi-3.0" || console.warn(`Invalid target: ${this.target}`), (C = r.external) != null && C.uri) {
      const B = (E = r.external.registry.get(A)) == null ? void 0 : E.id;
      if (!B)
        throw new Error("Schema is missing an `id` property");
      g.$id = r.external.uri(B);
    }
    Object.assign(g, i.def);
    const o = ((l = r.external) == null ? void 0 : l.defs) ?? {};
    for (const B of this.seen.entries()) {
      const h = B[1];
      h.def && h.defId && (o[h.defId] = h.def);
    }
    r.external || Object.keys(o).length > 0 && (this.target === "draft-2020-12" ? g.$defs = o : g.definitions = o);
    try {
      return JSON.parse(JSON.stringify(g));
    } catch {
      throw new Error("Error converting schema to JSON.");
    }
  }
}
function vd(t, A) {
  if (t instanceof AG) {
    const r = new Av(A), i = {};
    for (const a of t._idmap.entries()) {
      const [g, o] = a;
      r.process(o);
    }
    const n = {}, s = {
      registry: t,
      uri: A == null ? void 0 : A.uri,
      defs: i
    };
    for (const a of t._idmap.entries()) {
      const [g, o] = a;
      n[g] = r.emit(o, {
        ...A,
        external: s
      });
    }
    if (Object.keys(i).length > 0) {
      const a = r.target === "draft-2020-12" ? "$defs" : "definitions";
      n.__shared = {
        [a]: i
      };
    }
    return { schemas: n };
  }
  const e = new Av(A);
  return e.process(t), e.emit(t, A);
}
function er(t, A) {
  const e = A ?? { seen: /* @__PURE__ */ new Set() };
  if (e.seen.has(t))
    return !1;
  e.seen.add(t);
  const r = t._zod.def;
  if (r.type === "transform")
    return !0;
  if (r.type === "array")
    return er(r.element, e);
  if (r.type === "set")
    return er(r.valueType, e);
  if (r.type === "lazy")
    return er(r.getter(), e);
  if (r.type === "promise" || r.type === "optional" || r.type === "nonoptional" || r.type === "nullable" || r.type === "readonly" || r.type === "default" || r.type === "prefault")
    return er(r.innerType, e);
  if (r.type === "intersection")
    return er(r.left, e) || er(r.right, e);
  if (r.type === "record" || r.type === "map")
    return er(r.keyType, e) || er(r.valueType, e);
  if (r.type === "pipe")
    return er(r.in, e) || er(r.out, e);
  if (r.type === "object") {
    for (const i in r.shape)
      if (er(r.shape[i], e))
        return !0;
    return !1;
  }
  if (r.type === "union") {
    for (const i of r.options)
      if (er(i, e))
        return !0;
    return !1;
  }
  if (r.type === "tuple") {
    for (const i of r.items)
      if (er(i, e))
        return !0;
    return !!(r.rest && er(r.rest, e));
  }
  return !1;
}
function Ze(t) {
  if (typeof t != "object" || t === null) return !1;
  const A = t;
  if (!("_zod" in A)) return !1;
  const e = A._zod;
  return typeof e == "object" && e !== null && "def" in e;
}
function Ct(t) {
  if (typeof t != "object" || t === null) return !1;
  const A = t;
  if (!("_def" in A) || "_zod" in A) return !1;
  const e = A._def;
  return typeof e == "object" && e != null && "typeName" in e;
}
function p5(t) {
  return Ze(t) && console.warn("[WARNING] Attempting to use Zod 4 schema in a context where Zod 3 schema is expected. This may cause unexpected behavior."), Ct(t);
}
function In(t) {
  return !t || typeof t != "object" || Array.isArray(t) ? !1 : !!(Ze(t) || Ct(t));
}
function nG(t) {
  return typeof t == "object" && t !== null && "_def" in t && typeof t._def == "object" && t._def !== null && "typeName" in t._def && t._def.typeName === "ZodLiteral";
}
function sG(t) {
  return Ze(t) ? typeof t == "object" && t !== null && "_zod" in t && typeof t._zod == "object" && t._zod !== null && "def" in t._zod && typeof t._zod.def == "object" && t._zod.def !== null && "type" in t._zod.def && t._zod.def.type === "literal" : !1;
}
function y5(t) {
  return !!(nG(t) || sG(t));
}
async function aG(t, A) {
  if (Ze(t)) try {
    return {
      success: !0,
      data: await Yx(t, A)
    };
  } catch (e) {
    return {
      success: !1,
      error: e
    };
  }
  if (Ct(t)) return await t.safeParseAsync(A);
  throw new Error("Schema must be an instance of z3.ZodType or z4.$ZodType");
}
async function op(t, A) {
  if (Ze(t)) return await Yx(t, A);
  if (Ct(t)) return await t.parseAsync(A);
  throw new Error("Schema must be an instance of z3.ZodType or z4.$ZodType");
}
function w5(t, A) {
  if (Ze(t)) try {
    return {
      success: !0,
      data: rp(t, A)
    };
  } catch (e) {
    return {
      success: !1,
      error: e
    };
  }
  if (Ct(t)) return t.safeParse(A);
  throw new Error("Schema must be an instance of z3.ZodType or z4.$ZodType");
}
function m5(t, A) {
  if (Ze(t)) return rp(t, A);
  if (Ct(t)) return t.parse(A);
  throw new Error("Schema must be an instance of z3.ZodType or z4.$ZodType");
}
function gp(t) {
  var A;
  if (Ze(t)) return (A = Rt.get(t)) == null ? void 0 : A.description;
  if (Ct(t) || "description" in t && typeof t.description == "string") return t.description;
}
function D5(t) {
  if (!In(t)) return !1;
  if (Ct(t)) {
    const A = t._def;
    if (A.typeName === "ZodObject") {
      const e = t;
      return !e.shape || Object.keys(e.shape).length === 0;
    }
    if (A.typeName === "ZodRecord") return !0;
  }
  if (Ze(t)) {
    const A = t._zod.def;
    if (A.type === "object") {
      const e = t;
      return !e.shape || Object.keys(e.shape).length === 0;
    }
    if (A.type === "record") return !0;
  }
  return typeof t == "object" && t !== null && !("shape" in t);
}
function iS(t) {
  return In(t) ? Ct(t) ? t._def.typeName === "ZodString" : Ze(t) ? t._zod.def.type === "string" : !1 : !1;
}
function nS(t) {
  return typeof t == "object" && t !== null && "_def" in t && typeof t._def == "object" && t._def !== null && "typeName" in t._def && t._def.typeName === "ZodObject";
}
function Qn(t) {
  return Ze(t) ? typeof t == "object" && t !== null && "_zod" in t && typeof t._zod == "object" && t._zod !== null && "def" in t._zod && typeof t._zod.def == "object" && t._zod.def !== null && "type" in t._zod.def && t._zod.def.type === "object" : !1;
}
function up(t) {
  return Ze(t) ? typeof t == "object" && t !== null && "_zod" in t && typeof t._zod == "object" && t._zod !== null && "def" in t._zod && typeof t._zod.def == "object" && t._zod.def !== null && "type" in t._zod.def && t._zod.def.type === "array" : !1;
}
function oG(t) {
  return Ze(t) ? typeof t == "object" && t !== null && "_zod" in t && typeof t._zod == "object" && t._zod !== null && "def" in t._zod && typeof t._zod.def == "object" && t._zod.def !== null && "type" in t._zod.def && t._zod.def.type === "optional" : !1;
}
function gG(t) {
  return Ze(t) ? typeof t == "object" && t !== null && "_zod" in t && typeof t._zod == "object" && t._zod !== null && "def" in t._zod && typeof t._zod.def == "object" && t._zod.def !== null && "type" in t._zod.def && t._zod.def.type === "nullable" : !1;
}
function S5(t) {
  return !!(nS(t) || Qn(t));
}
function am(t) {
  if (Ct(t)) return t.shape;
  if (Ze(t)) return t._zod.def.shape;
  throw new Error("Schema must be an instance of z3.ZodObject or z4.$ZodObject");
}
function F5(t, A) {
  if (Ct(t)) return t.extend(A);
  if (Ze(t)) return Kx(t, A);
  throw new Error("Schema must be an instance of z3.ZodObject or z4.$ZodObject");
}
function k5(t) {
  if (Ct(t)) return t.partial();
  if (Ze(t)) return Jx(rS, t, void 0);
  throw new Error("Schema must be an instance of z3.ZodObject or z4.$ZodObject");
}
function Rd(t, A = !1) {
  if (Ct(t)) return t.strict();
  if (Qn(t)) {
    const e = t._zod.def.shape;
    if (A) for (const [n, s] of Object.entries(t._zod.def.shape)) {
      if (Qn(s)) {
        const g = Rd(s, A);
        e[n] = g;
      } else if (up(s)) {
        let g = s._zod.def.element;
        Qn(g) && (g = Rd(g, A)), e[n] = qt(s, {
          ...s._zod.def,
          element: g
        });
      } else e[n] = s;
      const a = Rt.get(s);
      a && Rt.add(e[n], a);
    }
    const r = qt(t, {
      ...t._zod.def,
      shape: e,
      catchall: tG(Xx)
    }), i = Rt.get(t);
    return i && Rt.add(r, i), r;
  }
  throw new Error("Schema must be an instance of z3.ZodObject or z4.$ZodObject");
}
function om(t, A = !1) {
  if (nS(t)) return t.passthrough();
  if (Qn(t)) {
    const e = t._zod.def.shape;
    if (A) for (const [n, s] of Object.entries(t._zod.def.shape)) {
      if (Qn(s)) {
        const g = om(s, A);
        e[n] = g;
      } else if (up(s)) {
        let g = s._zod.def.element;
        Qn(g) && (g = om(g, A)), e[n] = qt(s, {
          ...s._zod.def,
          element: g
        });
      } else e[n] = s;
      const a = Rt.get(s);
      a && Rt.add(e[n], a);
    }
    const r = qt(t, {
      ...t._zod.def,
      shape: e,
      catchall: eG(Zx)
    }), i = Rt.get(t);
    return i && Rt.add(r, i), r;
  }
  throw new Error("Schema must be an instance of z3.ZodObject or z4.$ZodObject");
}
function v5(t) {
  if (Ct(t)) try {
    const A = t.parse(void 0);
    return () => A;
  } catch {
    return;
  }
  if (Ze(t)) try {
    const A = rp(t, void 0);
    return () => A;
  } catch {
    return;
  }
}
function R5(t) {
  return Ct(t) && "typeName" in t._def && t._def.typeName === "ZodEffects";
}
function b5(t) {
  return Ze(t) && t._zod.def.type === "pipe";
}
function Ao(t, A, e) {
  const r = e.get(t);
  if (r !== void 0) return r;
  if (Ct(t))
    return R5(t) ? Ao(t._def.schema, A, e) : t;
  if (Ze(t)) {
    let i = t;
    if (b5(t) && (i = Ao(t._zod.def.in, A, e)), A) {
      if (Qn(i)) {
        const s = i._zod.def.shape;
        for (const [a, g] of Object.entries(i._zod.def.shape)) s[a] = Ao(g, A, e);
        i = qt(i, {
          ...i._zod.def,
          shape: s
        });
      } else if (up(i)) {
        const s = Ao(i._zod.def.element, A, e);
        i = qt(i, {
          ...i._zod.def,
          element: s
        });
      } else if (oG(i)) {
        const s = Ao(i._zod.def.innerType, A, e);
        i = qt(i, {
          ...i._zod.def,
          innerType: s
        });
      } else if (gG(i)) {
        const s = Ao(i._zod.def.innerType, A, e);
        i = qt(i, {
          ...i._zod.def,
          innerType: s
        });
      }
    }
    const n = Rt.get(t);
    return n && Rt.add(i, n), e.set(t, i), i;
  }
  throw new Error("Schema must be an instance of z3.ZodType or z4.$ZodType");
}
function uG(t, A = !1) {
  return Ao(t, A, /* @__PURE__ */ new WeakMap());
}
function M5(t, A) {
  if (Ct(t)) {
    const e = am(t), r = {};
    for (const [i, n] of Object.entries(e)) A(i, n) ? r[i] = n.optional() : r[i] = n;
    return t.extend(r);
  }
  if (Ze(t)) {
    const e = am(t), r = { ...t._zod.def.shape };
    for (const [s, a] of Object.entries(e)) A(s, a) && (r[s] = new rS({
      type: "optional",
      innerType: a
    }));
    const i = qt(t, {
      ...t._zod.def,
      shape: r
    }), n = Rt.get(t);
    return n && Rt.add(i, n), i;
  }
  throw new Error("Schema must be an instance of z3.ZodObject or z4.$ZodObject");
}
function cG(t) {
  return t instanceof Error && (t.constructor.name === "ZodError" || t.constructor.name === "$ZodError");
}
function Cy(t) {
  return t.replace(/[^a-zA-Z-_0-9]/g, "_");
}
const _5 = [
  "*",
  "_",
  "`"
];
function N5(t) {
  let A = "";
  for (const [e, r] of Object.entries(t)) A += `	classDef ${e} ${r};
`;
  return A;
}
function L5(t, A, e) {
  const { firstNode: r, lastNode: i, nodeColors: n, withStyles: s = !0, curveStyle: a = "linear", wrapLabelNWords: g = 9 } = e ?? {};
  let o = s ? `%%{init: {'flowchart': {'curve': '${a}'}}}%%
graph TD;
` : `graph TD;
`;
  if (s) {
    const C = "default", E = { [C]: "{0}({1})" };
    r !== void 0 && (E[r] = "{0}([{1}]):::first"), i !== void 0 && (E[i] = "{0}([{1}]):::last");
    for (const [l, B] of Object.entries(t)) {
      const h = B.name.split(":").pop() ?? "";
      let f = _5.some((y) => h.startsWith(y) && h.endsWith(y)) ? `<p>${h}</p>` : h;
      Object.keys(B.metadata ?? {}).length && (f += `<hr/><small><em>${Object.entries(B.metadata ?? {}).map(([y, m]) => `${y} = ${m}`).join(`
`)}</em></small>`);
      const p = (E[l] ?? E[C]).replace("{0}", Cy(l)).replace("{1}", f);
      o += `	${p}
`;
    }
  }
  const u = {};
  for (const C of A) {
    const E = C.source.split(":"), l = C.target.split(":"), B = E.filter((h, Q) => h === l[Q]).join(":");
    u[B] || (u[B] = []), u[B].push(C);
  }
  const I = /* @__PURE__ */ new Set();
  function c(C, E) {
    const l = C.length === 1 && C[0].source === C[0].target;
    if (E && !l) {
      const B = E.split(":").pop();
      if (I.has(B)) throw new Error(`Found duplicate subgraph '${B}' -- this likely means that you're reusing a subgraph node with the same name. Please adjust your graph to have subgraph nodes with unique names.`);
      I.add(B), o += `	subgraph ${B}
`;
    }
    for (const B of C) {
      const { source: h, target: Q, data: f, conditional: p } = B;
      let y = "";
      if (f !== void 0) {
        let m = f;
        const S = m.split(" ");
        S.length > g && (m = Array.from({ length: Math.ceil(S.length / g) }, (w, F) => S.slice(F * g, (F + 1) * g).join(" ")).join("&nbsp;<br>&nbsp;")), y = p ? ` -. &nbsp;${m}&nbsp; .-> ` : ` -- &nbsp;${m}&nbsp; --> `;
      } else y = p ? " -.-> " : " --> ";
      o += `	${Cy(h)}${y}${Cy(Q)};
`;
    }
    for (const B in u) B.startsWith(`${E}:`) && B !== E && c(u[B], B);
    E && !l && (o += `	end
`);
  }
  c(u[""] ?? [], "");
  for (const C in u) !C.includes(":") && C !== "" && c(u[C], C);
  return s && (o += N5(n ?? {})), o;
}
async function x5(t, A) {
  let e = (A == null ? void 0 : A.backgroundColor) ?? "white";
  const r = (A == null ? void 0 : A.imageType) ?? "png", i = H3(t);
  e !== void 0 && (/^#(?:[0-9a-fA-F]{3}){1,2}$/.test(e) || (e = `!${e}`));
  const n = `https://mermaid.ink/img/${i}?bgColor=${e}&type=${r}`, s = await fetch(n);
  if (!s.ok) throw new Error([
    "Failed to render the graph using the Mermaid.INK API.",
    `Status code: ${s.status}`,
    `Status text: ${s.statusText}`
  ].join(`
`));
  return await s.blob();
}
const G5 = Symbol("Let zodToJsonSchema decide on which parser to use"), U5 = {
  name: void 0,
  $refStrategy: "root",
  basePath: ["#"],
  effectStrategy: "input",
  pipeStrategy: "all",
  dateStrategy: "format:date-time",
  mapStrategy: "entries",
  removeAdditionalStrategy: "passthrough",
  allowedAdditionalProperties: !0,
  rejectedAdditionalProperties: !1,
  definitionPath: "definitions",
  target: "jsonSchema7",
  strictUnions: !1,
  definitions: {},
  errorMessages: !1,
  markdownDescription: !1,
  patternStrategy: "escape",
  applyRegexFlags: !1,
  emailStrategy: "format:email",
  base64Strategy: "contentEncoding:base64",
  nameStrategy: "ref",
  openAiAnyTypeName: "OpenAiAnyType"
}, T5 = (t) => ({
  ...U5,
  ...t
}), K5 = (t) => {
  const A = T5(t), e = A.name !== void 0 ? [
    ...A.basePath,
    A.definitionPath,
    A.name
  ] : A.basePath;
  return {
    ...A,
    flags: { hasReferencedOpenAiAnyType: !1 },
    currentPath: e,
    propertyPath: void 0,
    seen: new Map(Object.entries(A.definitions).map(([r, i]) => [i._def, {
      def: i._def,
      path: [
        ...A.basePath,
        A.definitionPath,
        r
      ],
      jsonSchema: void 0
    }]))
  };
}, IG = (t, A) => {
  let e = 0;
  for (; e < t.length && e < A.length && t[e] === A[e]; e++) ;
  return [(t.length - e).toString(), ...A.slice(e)].join("/");
};
function Hr(t) {
  if (t.target !== "openAi") return {};
  const A = [
    ...t.basePath,
    t.definitionPath,
    t.openAiAnyTypeName
  ];
  return t.flags.hasReferencedOpenAiAnyType = !0, { $ref: t.$refStrategy === "relative" ? IG(A, t.currentPath) : A.join("/") };
}
function CG(t, A, e, r) {
  r != null && r.errorMessages && e && (t.errorMessage = {
    ...t.errorMessage,
    [A]: e
  });
}
function _e(t, A, e, r, i) {
  t[A] = e, CG(t, A, r, i);
}
var Fe;
(function(t) {
  t.assertEqual = (i) => {
  };
  function A(i) {
  }
  t.assertIs = A;
  function e(i) {
    throw new Error();
  }
  t.assertNever = e, t.arrayToEnum = (i) => {
    const n = {};
    for (const s of i)
      n[s] = s;
    return n;
  }, t.getValidEnumValues = (i) => {
    const n = t.objectKeys(i).filter((a) => typeof i[i[a]] != "number"), s = {};
    for (const a of n)
      s[a] = i[a];
    return t.objectValues(s);
  }, t.objectValues = (i) => t.objectKeys(i).map(function(n) {
    return i[n];
  }), t.objectKeys = typeof Object.keys == "function" ? (i) => Object.keys(i) : (i) => {
    const n = [];
    for (const s in i)
      Object.prototype.hasOwnProperty.call(i, s) && n.push(s);
    return n;
  }, t.find = (i, n) => {
    for (const s of i)
      if (n(s))
        return s;
  }, t.isInteger = typeof Number.isInteger == "function" ? (i) => Number.isInteger(i) : (i) => typeof i == "number" && Number.isFinite(i) && Math.floor(i) === i;
  function r(i, n = " | ") {
    return i.map((s) => typeof s == "string" ? `'${s}'` : s).join(n);
  }
  t.joinValues = r, t.jsonStringifyReplacer = (i, n) => typeof n == "bigint" ? n.toString() : n;
})(Fe || (Fe = {}));
var ev;
(function(t) {
  t.mergeShapes = (A, e) => ({
    ...A,
    ...e
    // second overwrites first
  });
})(ev || (ev = {}));
const JA = Fe.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]), xs = (t) => {
  switch (typeof t) {
    case "undefined":
      return JA.undefined;
    case "string":
      return JA.string;
    case "number":
      return Number.isNaN(t) ? JA.nan : JA.number;
    case "boolean":
      return JA.boolean;
    case "function":
      return JA.function;
    case "bigint":
      return JA.bigint;
    case "symbol":
      return JA.symbol;
    case "object":
      return Array.isArray(t) ? JA.array : t === null ? JA.null : t.then && typeof t.then == "function" && t.catch && typeof t.catch == "function" ? JA.promise : typeof Map < "u" && t instanceof Map ? JA.map : typeof Set < "u" && t instanceof Set ? JA.set : typeof Date < "u" && t instanceof Date ? JA.date : JA.object;
    default:
      return JA.unknown;
  }
}, FA = Fe.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
class Es extends Error {
  get errors() {
    return this.issues;
  }
  constructor(A) {
    super(), this.issues = [], this.addIssue = (r) => {
      this.issues = [...this.issues, r];
    }, this.addIssues = (r = []) => {
      this.issues = [...this.issues, ...r];
    };
    const e = new.target.prototype;
    Object.setPrototypeOf ? Object.setPrototypeOf(this, e) : this.__proto__ = e, this.name = "ZodError", this.issues = A;
  }
  format(A) {
    const e = A || function(n) {
      return n.message;
    }, r = { _errors: [] }, i = (n) => {
      for (const s of n.issues)
        if (s.code === "invalid_union")
          s.unionErrors.map(i);
        else if (s.code === "invalid_return_type")
          i(s.returnTypeError);
        else if (s.code === "invalid_arguments")
          i(s.argumentsError);
        else if (s.path.length === 0)
          r._errors.push(e(s));
        else {
          let a = r, g = 0;
          for (; g < s.path.length; ) {
            const o = s.path[g];
            g === s.path.length - 1 ? (a[o] = a[o] || { _errors: [] }, a[o]._errors.push(e(s))) : a[o] = a[o] || { _errors: [] }, a = a[o], g++;
          }
        }
    };
    return i(this), r;
  }
  static assert(A) {
    if (!(A instanceof Es))
      throw new Error(`Not a ZodError: ${A}`);
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, Fe.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(A = (e) => e.message) {
    const e = /* @__PURE__ */ Object.create(null), r = [];
    for (const i of this.issues)
      if (i.path.length > 0) {
        const n = i.path[0];
        e[n] = e[n] || [], e[n].push(A(i));
      } else
        r.push(A(i));
    return { formErrors: r, fieldErrors: e };
  }
  get formErrors() {
    return this.flatten();
  }
}
Es.create = (t) => new Es(t);
const gm = (t, A) => {
  let e;
  switch (t.code) {
    case FA.invalid_type:
      t.received === JA.undefined ? e = "Required" : e = `Expected ${t.expected}, received ${t.received}`;
      break;
    case FA.invalid_literal:
      e = `Invalid literal value, expected ${JSON.stringify(t.expected, Fe.jsonStringifyReplacer)}`;
      break;
    case FA.unrecognized_keys:
      e = `Unrecognized key(s) in object: ${Fe.joinValues(t.keys, ", ")}`;
      break;
    case FA.invalid_union:
      e = "Invalid input";
      break;
    case FA.invalid_union_discriminator:
      e = `Invalid discriminator value. Expected ${Fe.joinValues(t.options)}`;
      break;
    case FA.invalid_enum_value:
      e = `Invalid enum value. Expected ${Fe.joinValues(t.options)}, received '${t.received}'`;
      break;
    case FA.invalid_arguments:
      e = "Invalid function arguments";
      break;
    case FA.invalid_return_type:
      e = "Invalid function return type";
      break;
    case FA.invalid_date:
      e = "Invalid date";
      break;
    case FA.invalid_string:
      typeof t.validation == "object" ? "includes" in t.validation ? (e = `Invalid input: must include "${t.validation.includes}"`, typeof t.validation.position == "number" && (e = `${e} at one or more positions greater than or equal to ${t.validation.position}`)) : "startsWith" in t.validation ? e = `Invalid input: must start with "${t.validation.startsWith}"` : "endsWith" in t.validation ? e = `Invalid input: must end with "${t.validation.endsWith}"` : Fe.assertNever(t.validation) : t.validation !== "regex" ? e = `Invalid ${t.validation}` : e = "Invalid";
      break;
    case FA.too_small:
      t.type === "array" ? e = `Array must contain ${t.exact ? "exactly" : t.inclusive ? "at least" : "more than"} ${t.minimum} element(s)` : t.type === "string" ? e = `String must contain ${t.exact ? "exactly" : t.inclusive ? "at least" : "over"} ${t.minimum} character(s)` : t.type === "number" ? e = `Number must be ${t.exact ? "exactly equal to " : t.inclusive ? "greater than or equal to " : "greater than "}${t.minimum}` : t.type === "bigint" ? e = `Number must be ${t.exact ? "exactly equal to " : t.inclusive ? "greater than or equal to " : "greater than "}${t.minimum}` : t.type === "date" ? e = `Date must be ${t.exact ? "exactly equal to " : t.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(t.minimum))}` : e = "Invalid input";
      break;
    case FA.too_big:
      t.type === "array" ? e = `Array must contain ${t.exact ? "exactly" : t.inclusive ? "at most" : "less than"} ${t.maximum} element(s)` : t.type === "string" ? e = `String must contain ${t.exact ? "exactly" : t.inclusive ? "at most" : "under"} ${t.maximum} character(s)` : t.type === "number" ? e = `Number must be ${t.exact ? "exactly" : t.inclusive ? "less than or equal to" : "less than"} ${t.maximum}` : t.type === "bigint" ? e = `BigInt must be ${t.exact ? "exactly" : t.inclusive ? "less than or equal to" : "less than"} ${t.maximum}` : t.type === "date" ? e = `Date must be ${t.exact ? "exactly" : t.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(t.maximum))}` : e = "Invalid input";
      break;
    case FA.custom:
      e = "Invalid input";
      break;
    case FA.invalid_intersection_types:
      e = "Intersection results could not be merged";
      break;
    case FA.not_multiple_of:
      e = `Number must be a multiple of ${t.multipleOf}`;
      break;
    case FA.not_finite:
      e = "Number must be finite";
      break;
    default:
      e = A.defaultError, Fe.assertNever(t);
  }
  return { message: e };
};
let J5 = gm;
function H5() {
  return J5;
}
const P5 = (t) => {
  const { data: A, path: e, errorMaps: r, issueData: i } = t, n = [...e, ...i.path || []], s = {
    ...i,
    path: n
  };
  if (i.message !== void 0)
    return {
      ...i,
      path: n,
      message: i.message
    };
  let a = "";
  const g = r.filter((o) => !!o).slice().reverse();
  for (const o of g)
    a = o(s, { data: A, defaultError: a }).message;
  return {
    ...i,
    path: n,
    message: a
  };
};
function NA(t, A) {
  const e = H5(), r = P5({
    issueData: A,
    data: t.data,
    path: t.path,
    errorMaps: [
      t.common.contextualErrorMap,
      // contextual error map is first priority
      t.schemaErrorMap,
      // then schema-bound map if available
      e,
      // then global override map
      e === gm ? void 0 : gm
      // then global default map
    ].filter((i) => !!i)
  });
  t.common.issues.push(r);
}
class Pr {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    this.value === "valid" && (this.value = "dirty");
  }
  abort() {
    this.value !== "aborted" && (this.value = "aborted");
  }
  static mergeArray(A, e) {
    const r = [];
    for (const i of e) {
      if (i.status === "aborted")
        return se;
      i.status === "dirty" && A.dirty(), r.push(i.value);
    }
    return { status: A.value, value: r };
  }
  static async mergeObjectAsync(A, e) {
    const r = [];
    for (const i of e) {
      const n = await i.key, s = await i.value;
      r.push({
        key: n,
        value: s
      });
    }
    return Pr.mergeObjectSync(A, r);
  }
  static mergeObjectSync(A, e) {
    const r = {};
    for (const i of e) {
      const { key: n, value: s } = i;
      if (n.status === "aborted" || s.status === "aborted")
        return se;
      n.status === "dirty" && A.dirty(), s.status === "dirty" && A.dirty(), n.value !== "__proto__" && (typeof s.value < "u" || i.alwaysSet) && (r[n.value] = s.value);
    }
    return { status: A.value, value: r };
  }
}
const se = Object.freeze({
  status: "aborted"
}), wC = (t) => ({ status: "dirty", value: t }), Xr = (t) => ({ status: "valid", value: t }), tv = (t) => t.status === "aborted", rv = (t) => t.status === "dirty", Oc = (t) => t.status === "valid", bd = (t) => typeof Promise < "u" && t instanceof Promise;
var PA;
(function(t) {
  t.errToObj = (A) => typeof A == "string" ? { message: A } : A || {}, t.toString = (A) => typeof A == "string" ? A : A == null ? void 0 : A.message;
})(PA || (PA = {}));
class Na {
  constructor(A, e, r, i) {
    this._cachedPath = [], this.parent = A, this.data = e, this._path = r, this._key = i;
  }
  get path() {
    return this._cachedPath.length || (Array.isArray(this._key) ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)), this._cachedPath;
  }
}
const iv = (t, A) => {
  if (Oc(A))
    return { success: !0, data: A.value };
  if (!t.common.issues.length)
    throw new Error("Validation failed but no issues detected.");
  return {
    success: !1,
    get error() {
      if (this._error)
        return this._error;
      const e = new Es(t.common.issues);
      return this._error = e, this._error;
    }
  };
};
function Ce(t) {
  if (!t)
    return {};
  const { errorMap: A, invalid_type_error: e, required_error: r, description: i } = t;
  if (A && (e || r))
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  return A ? { errorMap: A, description: i } : { errorMap: (s, a) => {
    const { message: g } = t;
    return s.code === "invalid_enum_value" ? { message: g ?? a.defaultError } : typeof a.data > "u" ? { message: g ?? r ?? a.defaultError } : s.code !== "invalid_type" ? { message: a.defaultError } : { message: g ?? e ?? a.defaultError };
  }, description: i };
}
let ye = class {
  get description() {
    return this._def.description;
  }
  _getType(A) {
    return xs(A.data);
  }
  _getOrReturnCtx(A, e) {
    return e || {
      common: A.parent.common,
      data: A.data,
      parsedType: xs(A.data),
      schemaErrorMap: this._def.errorMap,
      path: A.path,
      parent: A.parent
    };
  }
  _processInputParams(A) {
    return {
      status: new Pr(),
      ctx: {
        common: A.parent.common,
        data: A.data,
        parsedType: xs(A.data),
        schemaErrorMap: this._def.errorMap,
        path: A.path,
        parent: A.parent
      }
    };
  }
  _parseSync(A) {
    const e = this._parse(A);
    if (bd(e))
      throw new Error("Synchronous parse encountered promise.");
    return e;
  }
  _parseAsync(A) {
    const e = this._parse(A);
    return Promise.resolve(e);
  }
  parse(A, e) {
    const r = this.safeParse(A, e);
    if (r.success)
      return r.data;
    throw r.error;
  }
  safeParse(A, e) {
    const r = {
      common: {
        issues: [],
        async: (e == null ? void 0 : e.async) ?? !1,
        contextualErrorMap: e == null ? void 0 : e.errorMap
      },
      path: (e == null ? void 0 : e.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: A,
      parsedType: xs(A)
    }, i = this._parseSync({ data: A, path: r.path, parent: r });
    return iv(r, i);
  }
  "~validate"(A) {
    var r, i;
    const e = {
      common: {
        issues: [],
        async: !!this["~standard"].async
      },
      path: [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: A,
      parsedType: xs(A)
    };
    if (!this["~standard"].async)
      try {
        const n = this._parseSync({ data: A, path: [], parent: e });
        return Oc(n) ? {
          value: n.value
        } : {
          issues: e.common.issues
        };
      } catch (n) {
        (i = (r = n == null ? void 0 : n.message) == null ? void 0 : r.toLowerCase()) != null && i.includes("encountered") && (this["~standard"].async = !0), e.common = {
          issues: [],
          async: !0
        };
      }
    return this._parseAsync({ data: A, path: [], parent: e }).then((n) => Oc(n) ? {
      value: n.value
    } : {
      issues: e.common.issues
    });
  }
  async parseAsync(A, e) {
    const r = await this.safeParseAsync(A, e);
    if (r.success)
      return r.data;
    throw r.error;
  }
  async safeParseAsync(A, e) {
    const r = {
      common: {
        issues: [],
        contextualErrorMap: e == null ? void 0 : e.errorMap,
        async: !0
      },
      path: (e == null ? void 0 : e.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: A,
      parsedType: xs(A)
    }, i = this._parse({ data: A, path: r.path, parent: r }), n = await (bd(i) ? i : Promise.resolve(i));
    return iv(r, n);
  }
  refine(A, e) {
    const r = (i) => typeof e == "string" || typeof e > "u" ? { message: e } : typeof e == "function" ? e(i) : e;
    return this._refinement((i, n) => {
      const s = A(i), a = () => n.addIssue({
        code: FA.custom,
        ...r(i)
      });
      return typeof Promise < "u" && s instanceof Promise ? s.then((g) => g ? !0 : (a(), !1)) : s ? !0 : (a(), !1);
    });
  }
  refinement(A, e) {
    return this._refinement((r, i) => A(r) ? !0 : (i.addIssue(typeof e == "function" ? e(r, i) : e), !1));
  }
  _refinement(A) {
    return new qc({
      schema: this,
      typeName: IA.ZodEffects,
      effect: { type: "refinement", refinement: A }
    });
  }
  superRefine(A) {
    return this._refinement(A);
  }
  constructor(A) {
    this.spa = this.safeParseAsync, this._def = A, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.readonly = this.readonly.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this), this["~standard"] = {
      version: 1,
      vendor: "zod",
      validate: (e) => this["~validate"](e)
    };
  }
  optional() {
    return ka.create(this, this._def);
  }
  nullable() {
    return jc.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return Yc.create(this);
  }
  promise() {
    return Ld.create(this, this._def);
  }
  or(A) {
    return _d.create([this, A], this._def);
  }
  and(A) {
    return Nd.create(this, A, this._def);
  }
  transform(A) {
    return new qc({
      ...Ce(this._def),
      schema: this,
      typeName: IA.ZodEffects,
      effect: { type: "transform", transform: A }
    });
  }
  default(A) {
    const e = typeof A == "function" ? A : () => A;
    return new lm({
      ...Ce(this._def),
      innerType: this,
      defaultValue: e,
      typeName: IA.ZodDefault
    });
  }
  brand() {
    return new IW({
      typeName: IA.ZodBranded,
      type: this,
      ...Ce(this._def)
    });
  }
  catch(A) {
    const e = typeof A == "function" ? A : () => A;
    return new Bm({
      ...Ce(this._def),
      innerType: this,
      catchValue: e,
      typeName: IA.ZodCatch
    });
  }
  describe(A) {
    const e = this.constructor;
    return new e({
      ...this._def,
      description: A
    });
  }
  pipe(A) {
    return aS.create(this, A);
  }
  readonly() {
    return Em.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
};
const O5 = /^c[^\s-]{8,}$/i, Y5 = /^[0-9a-z]+$/, q5 = /^[0-9A-HJKMNP-TV-Z]{26}$/i, j5 = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i, W5 = /^[a-z0-9_-]{21}$/i, V5 = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/, Z5 = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/, X5 = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i, z5 = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
let ly;
const $5 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/, AW = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/, eW = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/, tW = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/, rW = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/, iW = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/, lG = "((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))", nW = new RegExp(`^${lG}$`);
function BG(t) {
  let A = "[0-5]\\d";
  t.precision ? A = `${A}\\.\\d{${t.precision}}` : t.precision == null && (A = `${A}(\\.\\d+)?`);
  const e = t.precision ? "+" : "?";
  return `([01]\\d|2[0-3]):[0-5]\\d(:${A})${e}`;
}
function sW(t) {
  return new RegExp(`^${BG(t)}$`);
}
function aW(t) {
  let A = `${lG}T${BG(t)}`;
  const e = [];
  return e.push(t.local ? "Z?" : "Z"), t.offset && e.push("([+-]\\d{2}:?\\d{2})"), A = `${A}(${e.join("|")})`, new RegExp(`^${A}$`);
}
function oW(t, A) {
  return !!((A === "v4" || !A) && $5.test(t) || (A === "v6" || !A) && eW.test(t));
}
function gW(t, A) {
  if (!V5.test(t))
    return !1;
  try {
    const [e] = t.split(".");
    if (!e)
      return !1;
    const r = e.replace(/-/g, "+").replace(/_/g, "/").padEnd(e.length + (4 - e.length % 4) % 4, "="), i = JSON.parse(atob(r));
    return !(typeof i != "object" || i === null || "typ" in i && (i == null ? void 0 : i.typ) !== "JWT" || !i.alg || A && i.alg !== A);
  } catch {
    return !1;
  }
}
function uW(t, A) {
  return !!((A === "v4" || !A) && AW.test(t) || (A === "v6" || !A) && tW.test(t));
}
let um = class mC extends ye {
  _parse(A) {
    if (this._def.coerce && (A.data = String(A.data)), this._getType(A) !== JA.string) {
      const n = this._getOrReturnCtx(A);
      return NA(n, {
        code: FA.invalid_type,
        expected: JA.string,
        received: n.parsedType
      }), se;
    }
    const r = new Pr();
    let i;
    for (const n of this._def.checks)
      if (n.kind === "min")
        A.data.length < n.value && (i = this._getOrReturnCtx(A, i), NA(i, {
          code: FA.too_small,
          minimum: n.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: n.message
        }), r.dirty());
      else if (n.kind === "max")
        A.data.length > n.value && (i = this._getOrReturnCtx(A, i), NA(i, {
          code: FA.too_big,
          maximum: n.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: n.message
        }), r.dirty());
      else if (n.kind === "length") {
        const s = A.data.length > n.value, a = A.data.length < n.value;
        (s || a) && (i = this._getOrReturnCtx(A, i), s ? NA(i, {
          code: FA.too_big,
          maximum: n.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: n.message
        }) : a && NA(i, {
          code: FA.too_small,
          minimum: n.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: n.message
        }), r.dirty());
      } else if (n.kind === "email")
        X5.test(A.data) || (i = this._getOrReturnCtx(A, i), NA(i, {
          validation: "email",
          code: FA.invalid_string,
          message: n.message
        }), r.dirty());
      else if (n.kind === "emoji")
        ly || (ly = new RegExp(z5, "u")), ly.test(A.data) || (i = this._getOrReturnCtx(A, i), NA(i, {
          validation: "emoji",
          code: FA.invalid_string,
          message: n.message
        }), r.dirty());
      else if (n.kind === "uuid")
        j5.test(A.data) || (i = this._getOrReturnCtx(A, i), NA(i, {
          validation: "uuid",
          code: FA.invalid_string,
          message: n.message
        }), r.dirty());
      else if (n.kind === "nanoid")
        W5.test(A.data) || (i = this._getOrReturnCtx(A, i), NA(i, {
          validation: "nanoid",
          code: FA.invalid_string,
          message: n.message
        }), r.dirty());
      else if (n.kind === "cuid")
        O5.test(A.data) || (i = this._getOrReturnCtx(A, i), NA(i, {
          validation: "cuid",
          code: FA.invalid_string,
          message: n.message
        }), r.dirty());
      else if (n.kind === "cuid2")
        Y5.test(A.data) || (i = this._getOrReturnCtx(A, i), NA(i, {
          validation: "cuid2",
          code: FA.invalid_string,
          message: n.message
        }), r.dirty());
      else if (n.kind === "ulid")
        q5.test(A.data) || (i = this._getOrReturnCtx(A, i), NA(i, {
          validation: "ulid",
          code: FA.invalid_string,
          message: n.message
        }), r.dirty());
      else if (n.kind === "url")
        try {
          new URL(A.data);
        } catch {
          i = this._getOrReturnCtx(A, i), NA(i, {
            validation: "url",
            code: FA.invalid_string,
            message: n.message
          }), r.dirty();
        }
      else n.kind === "regex" ? (n.regex.lastIndex = 0, n.regex.test(A.data) || (i = this._getOrReturnCtx(A, i), NA(i, {
        validation: "regex",
        code: FA.invalid_string,
        message: n.message
      }), r.dirty())) : n.kind === "trim" ? A.data = A.data.trim() : n.kind === "includes" ? A.data.includes(n.value, n.position) || (i = this._getOrReturnCtx(A, i), NA(i, {
        code: FA.invalid_string,
        validation: { includes: n.value, position: n.position },
        message: n.message
      }), r.dirty()) : n.kind === "toLowerCase" ? A.data = A.data.toLowerCase() : n.kind === "toUpperCase" ? A.data = A.data.toUpperCase() : n.kind === "startsWith" ? A.data.startsWith(n.value) || (i = this._getOrReturnCtx(A, i), NA(i, {
        code: FA.invalid_string,
        validation: { startsWith: n.value },
        message: n.message
      }), r.dirty()) : n.kind === "endsWith" ? A.data.endsWith(n.value) || (i = this._getOrReturnCtx(A, i), NA(i, {
        code: FA.invalid_string,
        validation: { endsWith: n.value },
        message: n.message
      }), r.dirty()) : n.kind === "datetime" ? aW(n).test(A.data) || (i = this._getOrReturnCtx(A, i), NA(i, {
        code: FA.invalid_string,
        validation: "datetime",
        message: n.message
      }), r.dirty()) : n.kind === "date" ? nW.test(A.data) || (i = this._getOrReturnCtx(A, i), NA(i, {
        code: FA.invalid_string,
        validation: "date",
        message: n.message
      }), r.dirty()) : n.kind === "time" ? sW(n).test(A.data) || (i = this._getOrReturnCtx(A, i), NA(i, {
        code: FA.invalid_string,
        validation: "time",
        message: n.message
      }), r.dirty()) : n.kind === "duration" ? Z5.test(A.data) || (i = this._getOrReturnCtx(A, i), NA(i, {
        validation: "duration",
        code: FA.invalid_string,
        message: n.message
      }), r.dirty()) : n.kind === "ip" ? oW(A.data, n.version) || (i = this._getOrReturnCtx(A, i), NA(i, {
        validation: "ip",
        code: FA.invalid_string,
        message: n.message
      }), r.dirty()) : n.kind === "jwt" ? gW(A.data, n.alg) || (i = this._getOrReturnCtx(A, i), NA(i, {
        validation: "jwt",
        code: FA.invalid_string,
        message: n.message
      }), r.dirty()) : n.kind === "cidr" ? uW(A.data, n.version) || (i = this._getOrReturnCtx(A, i), NA(i, {
        validation: "cidr",
        code: FA.invalid_string,
        message: n.message
      }), r.dirty()) : n.kind === "base64" ? rW.test(A.data) || (i = this._getOrReturnCtx(A, i), NA(i, {
        validation: "base64",
        code: FA.invalid_string,
        message: n.message
      }), r.dirty()) : n.kind === "base64url" ? iW.test(A.data) || (i = this._getOrReturnCtx(A, i), NA(i, {
        validation: "base64url",
        code: FA.invalid_string,
        message: n.message
      }), r.dirty()) : Fe.assertNever(n);
    return { status: r.value, value: A.data };
  }
  _regex(A, e, r) {
    return this.refinement((i) => A.test(i), {
      validation: e,
      code: FA.invalid_string,
      ...PA.errToObj(r)
    });
  }
  _addCheck(A) {
    return new mC({
      ...this._def,
      checks: [...this._def.checks, A]
    });
  }
  email(A) {
    return this._addCheck({ kind: "email", ...PA.errToObj(A) });
  }
  url(A) {
    return this._addCheck({ kind: "url", ...PA.errToObj(A) });
  }
  emoji(A) {
    return this._addCheck({ kind: "emoji", ...PA.errToObj(A) });
  }
  uuid(A) {
    return this._addCheck({ kind: "uuid", ...PA.errToObj(A) });
  }
  nanoid(A) {
    return this._addCheck({ kind: "nanoid", ...PA.errToObj(A) });
  }
  cuid(A) {
    return this._addCheck({ kind: "cuid", ...PA.errToObj(A) });
  }
  cuid2(A) {
    return this._addCheck({ kind: "cuid2", ...PA.errToObj(A) });
  }
  ulid(A) {
    return this._addCheck({ kind: "ulid", ...PA.errToObj(A) });
  }
  base64(A) {
    return this._addCheck({ kind: "base64", ...PA.errToObj(A) });
  }
  base64url(A) {
    return this._addCheck({
      kind: "base64url",
      ...PA.errToObj(A)
    });
  }
  jwt(A) {
    return this._addCheck({ kind: "jwt", ...PA.errToObj(A) });
  }
  ip(A) {
    return this._addCheck({ kind: "ip", ...PA.errToObj(A) });
  }
  cidr(A) {
    return this._addCheck({ kind: "cidr", ...PA.errToObj(A) });
  }
  datetime(A) {
    return typeof A == "string" ? this._addCheck({
      kind: "datetime",
      precision: null,
      offset: !1,
      local: !1,
      message: A
    }) : this._addCheck({
      kind: "datetime",
      precision: typeof (A == null ? void 0 : A.precision) > "u" ? null : A == null ? void 0 : A.precision,
      offset: (A == null ? void 0 : A.offset) ?? !1,
      local: (A == null ? void 0 : A.local) ?? !1,
      ...PA.errToObj(A == null ? void 0 : A.message)
    });
  }
  date(A) {
    return this._addCheck({ kind: "date", message: A });
  }
  time(A) {
    return typeof A == "string" ? this._addCheck({
      kind: "time",
      precision: null,
      message: A
    }) : this._addCheck({
      kind: "time",
      precision: typeof (A == null ? void 0 : A.precision) > "u" ? null : A == null ? void 0 : A.precision,
      ...PA.errToObj(A == null ? void 0 : A.message)
    });
  }
  duration(A) {
    return this._addCheck({ kind: "duration", ...PA.errToObj(A) });
  }
  regex(A, e) {
    return this._addCheck({
      kind: "regex",
      regex: A,
      ...PA.errToObj(e)
    });
  }
  includes(A, e) {
    return this._addCheck({
      kind: "includes",
      value: A,
      position: e == null ? void 0 : e.position,
      ...PA.errToObj(e == null ? void 0 : e.message)
    });
  }
  startsWith(A, e) {
    return this._addCheck({
      kind: "startsWith",
      value: A,
      ...PA.errToObj(e)
    });
  }
  endsWith(A, e) {
    return this._addCheck({
      kind: "endsWith",
      value: A,
      ...PA.errToObj(e)
    });
  }
  min(A, e) {
    return this._addCheck({
      kind: "min",
      value: A,
      ...PA.errToObj(e)
    });
  }
  max(A, e) {
    return this._addCheck({
      kind: "max",
      value: A,
      ...PA.errToObj(e)
    });
  }
  length(A, e) {
    return this._addCheck({
      kind: "length",
      value: A,
      ...PA.errToObj(e)
    });
  }
  /**
   * Equivalent to `.min(1)`
   */
  nonempty(A) {
    return this.min(1, PA.errToObj(A));
  }
  trim() {
    return new mC({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new mC({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new mC({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((A) => A.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((A) => A.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((A) => A.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((A) => A.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((A) => A.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((A) => A.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((A) => A.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((A) => A.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((A) => A.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((A) => A.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((A) => A.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((A) => A.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((A) => A.kind === "ip");
  }
  get isCIDR() {
    return !!this._def.checks.find((A) => A.kind === "cidr");
  }
  get isBase64() {
    return !!this._def.checks.find((A) => A.kind === "base64");
  }
  get isBase64url() {
    return !!this._def.checks.find((A) => A.kind === "base64url");
  }
  get minLength() {
    let A = null;
    for (const e of this._def.checks)
      e.kind === "min" && (A === null || e.value > A) && (A = e.value);
    return A;
  }
  get maxLength() {
    let A = null;
    for (const e of this._def.checks)
      e.kind === "max" && (A === null || e.value < A) && (A = e.value);
    return A;
  }
};
um.create = (t) => new um({
  checks: [],
  typeName: IA.ZodString,
  coerce: (t == null ? void 0 : t.coerce) ?? !1,
  ...Ce(t)
});
function cW(t, A) {
  const e = (t.toString().split(".")[1] || "").length, r = (A.toString().split(".")[1] || "").length, i = e > r ? e : r, n = Number.parseInt(t.toFixed(i).replace(".", "")), s = Number.parseInt(A.toFixed(i).replace(".", ""));
  return n % s / 10 ** i;
}
class tl extends ye {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
  }
  _parse(A) {
    if (this._def.coerce && (A.data = Number(A.data)), this._getType(A) !== JA.number) {
      const n = this._getOrReturnCtx(A);
      return NA(n, {
        code: FA.invalid_type,
        expected: JA.number,
        received: n.parsedType
      }), se;
    }
    let r;
    const i = new Pr();
    for (const n of this._def.checks)
      n.kind === "int" ? Fe.isInteger(A.data) || (r = this._getOrReturnCtx(A, r), NA(r, {
        code: FA.invalid_type,
        expected: "integer",
        received: "float",
        message: n.message
      }), i.dirty()) : n.kind === "min" ? (n.inclusive ? A.data < n.value : A.data <= n.value) && (r = this._getOrReturnCtx(A, r), NA(r, {
        code: FA.too_small,
        minimum: n.value,
        type: "number",
        inclusive: n.inclusive,
        exact: !1,
        message: n.message
      }), i.dirty()) : n.kind === "max" ? (n.inclusive ? A.data > n.value : A.data >= n.value) && (r = this._getOrReturnCtx(A, r), NA(r, {
        code: FA.too_big,
        maximum: n.value,
        type: "number",
        inclusive: n.inclusive,
        exact: !1,
        message: n.message
      }), i.dirty()) : n.kind === "multipleOf" ? cW(A.data, n.value) !== 0 && (r = this._getOrReturnCtx(A, r), NA(r, {
        code: FA.not_multiple_of,
        multipleOf: n.value,
        message: n.message
      }), i.dirty()) : n.kind === "finite" ? Number.isFinite(A.data) || (r = this._getOrReturnCtx(A, r), NA(r, {
        code: FA.not_finite,
        message: n.message
      }), i.dirty()) : Fe.assertNever(n);
    return { status: i.value, value: A.data };
  }
  gte(A, e) {
    return this.setLimit("min", A, !0, PA.toString(e));
  }
  gt(A, e) {
    return this.setLimit("min", A, !1, PA.toString(e));
  }
  lte(A, e) {
    return this.setLimit("max", A, !0, PA.toString(e));
  }
  lt(A, e) {
    return this.setLimit("max", A, !1, PA.toString(e));
  }
  setLimit(A, e, r, i) {
    return new tl({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: A,
          value: e,
          inclusive: r,
          message: PA.toString(i)
        }
      ]
    });
  }
  _addCheck(A) {
    return new tl({
      ...this._def,
      checks: [...this._def.checks, A]
    });
  }
  int(A) {
    return this._addCheck({
      kind: "int",
      message: PA.toString(A)
    });
  }
  positive(A) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !1,
      message: PA.toString(A)
    });
  }
  negative(A) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !1,
      message: PA.toString(A)
    });
  }
  nonpositive(A) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !0,
      message: PA.toString(A)
    });
  }
  nonnegative(A) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !0,
      message: PA.toString(A)
    });
  }
  multipleOf(A, e) {
    return this._addCheck({
      kind: "multipleOf",
      value: A,
      message: PA.toString(e)
    });
  }
  finite(A) {
    return this._addCheck({
      kind: "finite",
      message: PA.toString(A)
    });
  }
  safe(A) {
    return this._addCheck({
      kind: "min",
      inclusive: !0,
      value: Number.MIN_SAFE_INTEGER,
      message: PA.toString(A)
    })._addCheck({
      kind: "max",
      inclusive: !0,
      value: Number.MAX_SAFE_INTEGER,
      message: PA.toString(A)
    });
  }
  get minValue() {
    let A = null;
    for (const e of this._def.checks)
      e.kind === "min" && (A === null || e.value > A) && (A = e.value);
    return A;
  }
  get maxValue() {
    let A = null;
    for (const e of this._def.checks)
      e.kind === "max" && (A === null || e.value < A) && (A = e.value);
    return A;
  }
  get isInt() {
    return !!this._def.checks.find((A) => A.kind === "int" || A.kind === "multipleOf" && Fe.isInteger(A.value));
  }
  get isFinite() {
    let A = null, e = null;
    for (const r of this._def.checks) {
      if (r.kind === "finite" || r.kind === "int" || r.kind === "multipleOf")
        return !0;
      r.kind === "min" ? (e === null || r.value > e) && (e = r.value) : r.kind === "max" && (A === null || r.value < A) && (A = r.value);
    }
    return Number.isFinite(e) && Number.isFinite(A);
  }
}
tl.create = (t) => new tl({
  checks: [],
  typeName: IA.ZodNumber,
  coerce: (t == null ? void 0 : t.coerce) || !1,
  ...Ce(t)
});
class rl extends ye {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte;
  }
  _parse(A) {
    if (this._def.coerce)
      try {
        A.data = BigInt(A.data);
      } catch {
        return this._getInvalidInput(A);
      }
    if (this._getType(A) !== JA.bigint)
      return this._getInvalidInput(A);
    let r;
    const i = new Pr();
    for (const n of this._def.checks)
      n.kind === "min" ? (n.inclusive ? A.data < n.value : A.data <= n.value) && (r = this._getOrReturnCtx(A, r), NA(r, {
        code: FA.too_small,
        type: "bigint",
        minimum: n.value,
        inclusive: n.inclusive,
        message: n.message
      }), i.dirty()) : n.kind === "max" ? (n.inclusive ? A.data > n.value : A.data >= n.value) && (r = this._getOrReturnCtx(A, r), NA(r, {
        code: FA.too_big,
        type: "bigint",
        maximum: n.value,
        inclusive: n.inclusive,
        message: n.message
      }), i.dirty()) : n.kind === "multipleOf" ? A.data % n.value !== BigInt(0) && (r = this._getOrReturnCtx(A, r), NA(r, {
        code: FA.not_multiple_of,
        multipleOf: n.value,
        message: n.message
      }), i.dirty()) : Fe.assertNever(n);
    return { status: i.value, value: A.data };
  }
  _getInvalidInput(A) {
    const e = this._getOrReturnCtx(A);
    return NA(e, {
      code: FA.invalid_type,
      expected: JA.bigint,
      received: e.parsedType
    }), se;
  }
  gte(A, e) {
    return this.setLimit("min", A, !0, PA.toString(e));
  }
  gt(A, e) {
    return this.setLimit("min", A, !1, PA.toString(e));
  }
  lte(A, e) {
    return this.setLimit("max", A, !0, PA.toString(e));
  }
  lt(A, e) {
    return this.setLimit("max", A, !1, PA.toString(e));
  }
  setLimit(A, e, r, i) {
    return new rl({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: A,
          value: e,
          inclusive: r,
          message: PA.toString(i)
        }
      ]
    });
  }
  _addCheck(A) {
    return new rl({
      ...this._def,
      checks: [...this._def.checks, A]
    });
  }
  positive(A) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !1,
      message: PA.toString(A)
    });
  }
  negative(A) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !1,
      message: PA.toString(A)
    });
  }
  nonpositive(A) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !0,
      message: PA.toString(A)
    });
  }
  nonnegative(A) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !0,
      message: PA.toString(A)
    });
  }
  multipleOf(A, e) {
    return this._addCheck({
      kind: "multipleOf",
      value: A,
      message: PA.toString(e)
    });
  }
  get minValue() {
    let A = null;
    for (const e of this._def.checks)
      e.kind === "min" && (A === null || e.value > A) && (A = e.value);
    return A;
  }
  get maxValue() {
    let A = null;
    for (const e of this._def.checks)
      e.kind === "max" && (A === null || e.value < A) && (A = e.value);
    return A;
  }
}
rl.create = (t) => new rl({
  checks: [],
  typeName: IA.ZodBigInt,
  coerce: (t == null ? void 0 : t.coerce) ?? !1,
  ...Ce(t)
});
class nv extends ye {
  _parse(A) {
    if (this._def.coerce && (A.data = !!A.data), this._getType(A) !== JA.boolean) {
      const r = this._getOrReturnCtx(A);
      return NA(r, {
        code: FA.invalid_type,
        expected: JA.boolean,
        received: r.parsedType
      }), se;
    }
    return Xr(A.data);
  }
}
nv.create = (t) => new nv({
  typeName: IA.ZodBoolean,
  coerce: (t == null ? void 0 : t.coerce) || !1,
  ...Ce(t)
});
class Md extends ye {
  _parse(A) {
    if (this._def.coerce && (A.data = new Date(A.data)), this._getType(A) !== JA.date) {
      const n = this._getOrReturnCtx(A);
      return NA(n, {
        code: FA.invalid_type,
        expected: JA.date,
        received: n.parsedType
      }), se;
    }
    if (Number.isNaN(A.data.getTime())) {
      const n = this._getOrReturnCtx(A);
      return NA(n, {
        code: FA.invalid_date
      }), se;
    }
    const r = new Pr();
    let i;
    for (const n of this._def.checks)
      n.kind === "min" ? A.data.getTime() < n.value && (i = this._getOrReturnCtx(A, i), NA(i, {
        code: FA.too_small,
        message: n.message,
        inclusive: !0,
        exact: !1,
        minimum: n.value,
        type: "date"
      }), r.dirty()) : n.kind === "max" ? A.data.getTime() > n.value && (i = this._getOrReturnCtx(A, i), NA(i, {
        code: FA.too_big,
        message: n.message,
        inclusive: !0,
        exact: !1,
        maximum: n.value,
        type: "date"
      }), r.dirty()) : Fe.assertNever(n);
    return {
      status: r.value,
      value: new Date(A.data.getTime())
    };
  }
  _addCheck(A) {
    return new Md({
      ...this._def,
      checks: [...this._def.checks, A]
    });
  }
  min(A, e) {
    return this._addCheck({
      kind: "min",
      value: A.getTime(),
      message: PA.toString(e)
    });
  }
  max(A, e) {
    return this._addCheck({
      kind: "max",
      value: A.getTime(),
      message: PA.toString(e)
    });
  }
  get minDate() {
    let A = null;
    for (const e of this._def.checks)
      e.kind === "min" && (A === null || e.value > A) && (A = e.value);
    return A != null ? new Date(A) : null;
  }
  get maxDate() {
    let A = null;
    for (const e of this._def.checks)
      e.kind === "max" && (A === null || e.value < A) && (A = e.value);
    return A != null ? new Date(A) : null;
  }
}
Md.create = (t) => new Md({
  checks: [],
  coerce: (t == null ? void 0 : t.coerce) || !1,
  typeName: IA.ZodDate,
  ...Ce(t)
});
class sv extends ye {
  _parse(A) {
    if (this._getType(A) !== JA.symbol) {
      const r = this._getOrReturnCtx(A);
      return NA(r, {
        code: FA.invalid_type,
        expected: JA.symbol,
        received: r.parsedType
      }), se;
    }
    return Xr(A.data);
  }
}
sv.create = (t) => new sv({
  typeName: IA.ZodSymbol,
  ...Ce(t)
});
class av extends ye {
  _parse(A) {
    if (this._getType(A) !== JA.undefined) {
      const r = this._getOrReturnCtx(A);
      return NA(r, {
        code: FA.invalid_type,
        expected: JA.undefined,
        received: r.parsedType
      }), se;
    }
    return Xr(A.data);
  }
}
av.create = (t) => new av({
  typeName: IA.ZodUndefined,
  ...Ce(t)
});
class ov extends ye {
  _parse(A) {
    if (this._getType(A) !== JA.null) {
      const r = this._getOrReturnCtx(A);
      return NA(r, {
        code: FA.invalid_type,
        expected: JA.null,
        received: r.parsedType
      }), se;
    }
    return Xr(A.data);
  }
}
ov.create = (t) => new ov({
  typeName: IA.ZodNull,
  ...Ce(t)
});
class cm extends ye {
  constructor() {
    super(...arguments), this._any = !0;
  }
  _parse(A) {
    return Xr(A.data);
  }
}
cm.create = (t) => new cm({
  typeName: IA.ZodAny,
  ...Ce(t)
});
let gv = class extends ye {
  constructor() {
    super(...arguments), this._unknown = !0;
  }
  _parse(A) {
    return Xr(A.data);
  }
};
gv.create = (t) => new gv({
  typeName: IA.ZodUnknown,
  ...Ce(t)
});
let La = class extends ye {
  _parse(A) {
    const e = this._getOrReturnCtx(A);
    return NA(e, {
      code: FA.invalid_type,
      expected: JA.never,
      received: e.parsedType
    }), se;
  }
};
La.create = (t) => new La({
  typeName: IA.ZodNever,
  ...Ce(t)
});
class uv extends ye {
  _parse(A) {
    if (this._getType(A) !== JA.undefined) {
      const r = this._getOrReturnCtx(A);
      return NA(r, {
        code: FA.invalid_type,
        expected: JA.void,
        received: r.parsedType
      }), se;
    }
    return Xr(A.data);
  }
}
uv.create = (t) => new uv({
  typeName: IA.ZodVoid,
  ...Ce(t)
});
let Yc = class JQ extends ye {
  _parse(A) {
    const { ctx: e, status: r } = this._processInputParams(A), i = this._def;
    if (e.parsedType !== JA.array)
      return NA(e, {
        code: FA.invalid_type,
        expected: JA.array,
        received: e.parsedType
      }), se;
    if (i.exactLength !== null) {
      const s = e.data.length > i.exactLength.value, a = e.data.length < i.exactLength.value;
      (s || a) && (NA(e, {
        code: s ? FA.too_big : FA.too_small,
        minimum: a ? i.exactLength.value : void 0,
        maximum: s ? i.exactLength.value : void 0,
        type: "array",
        inclusive: !0,
        exact: !0,
        message: i.exactLength.message
      }), r.dirty());
    }
    if (i.minLength !== null && e.data.length < i.minLength.value && (NA(e, {
      code: FA.too_small,
      minimum: i.minLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: i.minLength.message
    }), r.dirty()), i.maxLength !== null && e.data.length > i.maxLength.value && (NA(e, {
      code: FA.too_big,
      maximum: i.maxLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: i.maxLength.message
    }), r.dirty()), e.common.async)
      return Promise.all([...e.data].map((s, a) => i.type._parseAsync(new Na(e, s, e.path, a)))).then((s) => Pr.mergeArray(r, s));
    const n = [...e.data].map((s, a) => i.type._parseSync(new Na(e, s, e.path, a)));
    return Pr.mergeArray(r, n);
  }
  get element() {
    return this._def.type;
  }
  min(A, e) {
    return new JQ({
      ...this._def,
      minLength: { value: A, message: PA.toString(e) }
    });
  }
  max(A, e) {
    return new JQ({
      ...this._def,
      maxLength: { value: A, message: PA.toString(e) }
    });
  }
  length(A, e) {
    return new JQ({
      ...this._def,
      exactLength: { value: A, message: PA.toString(e) }
    });
  }
  nonempty(A) {
    return this.min(1, A);
  }
};
Yc.create = (t, A) => new Yc({
  type: t,
  minLength: null,
  maxLength: null,
  exactLength: null,
  typeName: IA.ZodArray,
  ...Ce(A)
});
function qg(t) {
  if (t instanceof hs) {
    const A = {};
    for (const e in t.shape) {
      const r = t.shape[e];
      A[e] = ka.create(qg(r));
    }
    return new hs({
      ...t._def,
      shape: () => A
    });
  } else return t instanceof Yc ? new Yc({
    ...t._def,
    type: qg(t.element)
  }) : t instanceof ka ? ka.create(qg(t.unwrap())) : t instanceof jc ? jc.create(qg(t.unwrap())) : t instanceof Eg ? Eg.create(t.items.map((A) => qg(A))) : t;
}
let hs = class Bi extends ye {
  constructor() {
    super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const A = this._def.shape(), e = Fe.objectKeys(A);
    return this._cached = { shape: A, keys: e }, this._cached;
  }
  _parse(A) {
    if (this._getType(A) !== JA.object) {
      const o = this._getOrReturnCtx(A);
      return NA(o, {
        code: FA.invalid_type,
        expected: JA.object,
        received: o.parsedType
      }), se;
    }
    const { status: r, ctx: i } = this._processInputParams(A), { shape: n, keys: s } = this._getCached(), a = [];
    if (!(this._def.catchall instanceof La && this._def.unknownKeys === "strip"))
      for (const o in i.data)
        s.includes(o) || a.push(o);
    const g = [];
    for (const o of s) {
      const u = n[o], I = i.data[o];
      g.push({
        key: { status: "valid", value: o },
        value: u._parse(new Na(i, I, i.path, o)),
        alwaysSet: o in i.data
      });
    }
    if (this._def.catchall instanceof La) {
      const o = this._def.unknownKeys;
      if (o === "passthrough")
        for (const u of a)
          g.push({
            key: { status: "valid", value: u },
            value: { status: "valid", value: i.data[u] }
          });
      else if (o === "strict")
        a.length > 0 && (NA(i, {
          code: FA.unrecognized_keys,
          keys: a
        }), r.dirty());
      else if (o !== "strip") throw new Error("Internal ZodObject error: invalid unknownKeys value.");
    } else {
      const o = this._def.catchall;
      for (const u of a) {
        const I = i.data[u];
        g.push({
          key: { status: "valid", value: u },
          value: o._parse(
            new Na(i, I, i.path, u)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: u in i.data
        });
      }
    }
    return i.common.async ? Promise.resolve().then(async () => {
      const o = [];
      for (const u of g) {
        const I = await u.key, c = await u.value;
        o.push({
          key: I,
          value: c,
          alwaysSet: u.alwaysSet
        });
      }
      return o;
    }).then((o) => Pr.mergeObjectSync(r, o)) : Pr.mergeObjectSync(r, g);
  }
  get shape() {
    return this._def.shape();
  }
  strict(A) {
    return PA.errToObj, new Bi({
      ...this._def,
      unknownKeys: "strict",
      ...A !== void 0 ? {
        errorMap: (e, r) => {
          var n, s;
          const i = ((s = (n = this._def).errorMap) == null ? void 0 : s.call(n, e, r).message) ?? r.defaultError;
          return e.code === "unrecognized_keys" ? {
            message: PA.errToObj(A).message ?? i
          } : {
            message: i
          };
        }
      } : {}
    });
  }
  strip() {
    return new Bi({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new Bi({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(A) {
    return new Bi({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...A
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(A) {
    return new Bi({
      unknownKeys: A._def.unknownKeys,
      catchall: A._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...A._def.shape()
      }),
      typeName: IA.ZodObject
    });
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(A, e) {
    return this.augment({ [A]: e });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(A) {
    return new Bi({
      ...this._def,
      catchall: A
    });
  }
  pick(A) {
    const e = {};
    for (const r of Fe.objectKeys(A))
      A[r] && this.shape[r] && (e[r] = this.shape[r]);
    return new Bi({
      ...this._def,
      shape: () => e
    });
  }
  omit(A) {
    const e = {};
    for (const r of Fe.objectKeys(this.shape))
      A[r] || (e[r] = this.shape[r]);
    return new Bi({
      ...this._def,
      shape: () => e
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return qg(this);
  }
  partial(A) {
    const e = {};
    for (const r of Fe.objectKeys(this.shape)) {
      const i = this.shape[r];
      A && !A[r] ? e[r] = i : e[r] = i.optional();
    }
    return new Bi({
      ...this._def,
      shape: () => e
    });
  }
  required(A) {
    const e = {};
    for (const r of Fe.objectKeys(this.shape))
      if (A && !A[r])
        e[r] = this.shape[r];
      else {
        let n = this.shape[r];
        for (; n instanceof ka; )
          n = n._def.innerType;
        e[r] = n;
      }
    return new Bi({
      ...this._def,
      shape: () => e
    });
  }
  keyof() {
    return EG(Fe.objectKeys(this.shape));
  }
};
hs.create = (t, A) => new hs({
  shape: () => t,
  unknownKeys: "strip",
  catchall: La.create(),
  typeName: IA.ZodObject,
  ...Ce(A)
});
hs.strictCreate = (t, A) => new hs({
  shape: () => t,
  unknownKeys: "strict",
  catchall: La.create(),
  typeName: IA.ZodObject,
  ...Ce(A)
});
hs.lazycreate = (t, A) => new hs({
  shape: t,
  unknownKeys: "strip",
  catchall: La.create(),
  typeName: IA.ZodObject,
  ...Ce(A)
});
let _d = class extends ye {
  _parse(A) {
    const { ctx: e } = this._processInputParams(A), r = this._def.options;
    function i(n) {
      for (const a of n)
        if (a.result.status === "valid")
          return a.result;
      for (const a of n)
        if (a.result.status === "dirty")
          return e.common.issues.push(...a.ctx.common.issues), a.result;
      const s = n.map((a) => new Es(a.ctx.common.issues));
      return NA(e, {
        code: FA.invalid_union,
        unionErrors: s
      }), se;
    }
    if (e.common.async)
      return Promise.all(r.map(async (n) => {
        const s = {
          ...e,
          common: {
            ...e.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await n._parseAsync({
            data: e.data,
            path: e.path,
            parent: s
          }),
          ctx: s
        };
      })).then(i);
    {
      let n;
      const s = [];
      for (const g of r) {
        const o = {
          ...e,
          common: {
            ...e.common,
            issues: []
          },
          parent: null
        }, u = g._parseSync({
          data: e.data,
          path: e.path,
          parent: o
        });
        if (u.status === "valid")
          return u;
        u.status === "dirty" && !n && (n = { result: u, ctx: o }), o.common.issues.length && s.push(o.common.issues);
      }
      if (n)
        return e.common.issues.push(...n.ctx.common.issues), n.result;
      const a = s.map((g) => new Es(g));
      return NA(e, {
        code: FA.invalid_union,
        unionErrors: a
      }), se;
    }
  }
  get options() {
    return this._def.options;
  }
};
_d.create = (t, A) => new _d({
  options: t,
  typeName: IA.ZodUnion,
  ...Ce(A)
});
function Im(t, A) {
  const e = xs(t), r = xs(A);
  if (t === A)
    return { valid: !0, data: t };
  if (e === JA.object && r === JA.object) {
    const i = Fe.objectKeys(A), n = Fe.objectKeys(t).filter((a) => i.indexOf(a) !== -1), s = { ...t, ...A };
    for (const a of n) {
      const g = Im(t[a], A[a]);
      if (!g.valid)
        return { valid: !1 };
      s[a] = g.data;
    }
    return { valid: !0, data: s };
  } else if (e === JA.array && r === JA.array) {
    if (t.length !== A.length)
      return { valid: !1 };
    const i = [];
    for (let n = 0; n < t.length; n++) {
      const s = t[n], a = A[n], g = Im(s, a);
      if (!g.valid)
        return { valid: !1 };
      i.push(g.data);
    }
    return { valid: !0, data: i };
  } else return e === JA.date && r === JA.date && +t == +A ? { valid: !0, data: t } : { valid: !1 };
}
let Nd = class extends ye {
  _parse(A) {
    const { status: e, ctx: r } = this._processInputParams(A), i = (n, s) => {
      if (tv(n) || tv(s))
        return se;
      const a = Im(n.value, s.value);
      return a.valid ? ((rv(n) || rv(s)) && e.dirty(), { status: e.value, value: a.data }) : (NA(r, {
        code: FA.invalid_intersection_types
      }), se);
    };
    return r.common.async ? Promise.all([
      this._def.left._parseAsync({
        data: r.data,
        path: r.path,
        parent: r
      }),
      this._def.right._parseAsync({
        data: r.data,
        path: r.path,
        parent: r
      })
    ]).then(([n, s]) => i(n, s)) : i(this._def.left._parseSync({
      data: r.data,
      path: r.path,
      parent: r
    }), this._def.right._parseSync({
      data: r.data,
      path: r.path,
      parent: r
    }));
  }
};
Nd.create = (t, A, e) => new Nd({
  left: t,
  right: A,
  typeName: IA.ZodIntersection,
  ...Ce(e)
});
class Eg extends ye {
  _parse(A) {
    const { status: e, ctx: r } = this._processInputParams(A);
    if (r.parsedType !== JA.array)
      return NA(r, {
        code: FA.invalid_type,
        expected: JA.array,
        received: r.parsedType
      }), se;
    if (r.data.length < this._def.items.length)
      return NA(r, {
        code: FA.too_small,
        minimum: this._def.items.length,
        inclusive: !0,
        exact: !1,
        type: "array"
      }), se;
    !this._def.rest && r.data.length > this._def.items.length && (NA(r, {
      code: FA.too_big,
      maximum: this._def.items.length,
      inclusive: !0,
      exact: !1,
      type: "array"
    }), e.dirty());
    const n = [...r.data].map((s, a) => {
      const g = this._def.items[a] || this._def.rest;
      return g ? g._parse(new Na(r, s, r.path, a)) : null;
    }).filter((s) => !!s);
    return r.common.async ? Promise.all(n).then((s) => Pr.mergeArray(e, s)) : Pr.mergeArray(e, n);
  }
  get items() {
    return this._def.items;
  }
  rest(A) {
    return new Eg({
      ...this._def,
      rest: A
    });
  }
}
Eg.create = (t, A) => {
  if (!Array.isArray(t))
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  return new Eg({
    items: t,
    typeName: IA.ZodTuple,
    rest: null,
    ...Ce(A)
  });
};
class cv extends ye {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(A) {
    const { status: e, ctx: r } = this._processInputParams(A);
    if (r.parsedType !== JA.map)
      return NA(r, {
        code: FA.invalid_type,
        expected: JA.map,
        received: r.parsedType
      }), se;
    const i = this._def.keyType, n = this._def.valueType, s = [...r.data.entries()].map(([a, g], o) => ({
      key: i._parse(new Na(r, a, r.path, [o, "key"])),
      value: n._parse(new Na(r, g, r.path, [o, "value"]))
    }));
    if (r.common.async) {
      const a = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const g of s) {
          const o = await g.key, u = await g.value;
          if (o.status === "aborted" || u.status === "aborted")
            return se;
          (o.status === "dirty" || u.status === "dirty") && e.dirty(), a.set(o.value, u.value);
        }
        return { status: e.value, value: a };
      });
    } else {
      const a = /* @__PURE__ */ new Map();
      for (const g of s) {
        const o = g.key, u = g.value;
        if (o.status === "aborted" || u.status === "aborted")
          return se;
        (o.status === "dirty" || u.status === "dirty") && e.dirty(), a.set(o.value, u.value);
      }
      return { status: e.value, value: a };
    }
  }
}
cv.create = (t, A, e) => new cv({
  valueType: A,
  keyType: t,
  typeName: IA.ZodMap,
  ...Ce(e)
});
class il extends ye {
  _parse(A) {
    const { status: e, ctx: r } = this._processInputParams(A);
    if (r.parsedType !== JA.set)
      return NA(r, {
        code: FA.invalid_type,
        expected: JA.set,
        received: r.parsedType
      }), se;
    const i = this._def;
    i.minSize !== null && r.data.size < i.minSize.value && (NA(r, {
      code: FA.too_small,
      minimum: i.minSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: i.minSize.message
    }), e.dirty()), i.maxSize !== null && r.data.size > i.maxSize.value && (NA(r, {
      code: FA.too_big,
      maximum: i.maxSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: i.maxSize.message
    }), e.dirty());
    const n = this._def.valueType;
    function s(g) {
      const o = /* @__PURE__ */ new Set();
      for (const u of g) {
        if (u.status === "aborted")
          return se;
        u.status === "dirty" && e.dirty(), o.add(u.value);
      }
      return { status: e.value, value: o };
    }
    const a = [...r.data.values()].map((g, o) => n._parse(new Na(r, g, r.path, o)));
    return r.common.async ? Promise.all(a).then((g) => s(g)) : s(a);
  }
  min(A, e) {
    return new il({
      ...this._def,
      minSize: { value: A, message: PA.toString(e) }
    });
  }
  max(A, e) {
    return new il({
      ...this._def,
      maxSize: { value: A, message: PA.toString(e) }
    });
  }
  size(A, e) {
    return this.min(A, e).max(A, e);
  }
  nonempty(A) {
    return this.min(1, A);
  }
}
il.create = (t, A) => new il({
  valueType: t,
  minSize: null,
  maxSize: null,
  typeName: IA.ZodSet,
  ...Ce(A)
});
class Iv extends ye {
  get schema() {
    return this._def.getter();
  }
  _parse(A) {
    const { ctx: e } = this._processInputParams(A);
    return this._def.getter()._parse({ data: e.data, path: e.path, parent: e });
  }
}
Iv.create = (t, A) => new Iv({
  getter: t,
  typeName: IA.ZodLazy,
  ...Ce(A)
});
class Cv extends ye {
  _parse(A) {
    if (A.data !== this._def.value) {
      const e = this._getOrReturnCtx(A);
      return NA(e, {
        received: e.data,
        code: FA.invalid_literal,
        expected: this._def.value
      }), se;
    }
    return { status: "valid", value: A.data };
  }
  get value() {
    return this._def.value;
  }
}
Cv.create = (t, A) => new Cv({
  value: t,
  typeName: IA.ZodLiteral,
  ...Ce(A)
});
function EG(t, A) {
  return new sS({
    values: t,
    typeName: IA.ZodEnum,
    ...Ce(A)
  });
}
let sS = class Cm extends ye {
  _parse(A) {
    if (typeof A.data != "string") {
      const e = this._getOrReturnCtx(A), r = this._def.values;
      return NA(e, {
        expected: Fe.joinValues(r),
        received: e.parsedType,
        code: FA.invalid_type
      }), se;
    }
    if (this._cache || (this._cache = new Set(this._def.values)), !this._cache.has(A.data)) {
      const e = this._getOrReturnCtx(A), r = this._def.values;
      return NA(e, {
        received: e.data,
        code: FA.invalid_enum_value,
        options: r
      }), se;
    }
    return Xr(A.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const A = {};
    for (const e of this._def.values)
      A[e] = e;
    return A;
  }
  get Values() {
    const A = {};
    for (const e of this._def.values)
      A[e] = e;
    return A;
  }
  get Enum() {
    const A = {};
    for (const e of this._def.values)
      A[e] = e;
    return A;
  }
  extract(A, e = this._def) {
    return Cm.create(A, {
      ...this._def,
      ...e
    });
  }
  exclude(A, e = this._def) {
    return Cm.create(this.options.filter((r) => !A.includes(r)), {
      ...this._def,
      ...e
    });
  }
};
sS.create = EG;
class lv extends ye {
  _parse(A) {
    const e = Fe.getValidEnumValues(this._def.values), r = this._getOrReturnCtx(A);
    if (r.parsedType !== JA.string && r.parsedType !== JA.number) {
      const i = Fe.objectValues(e);
      return NA(r, {
        expected: Fe.joinValues(i),
        received: r.parsedType,
        code: FA.invalid_type
      }), se;
    }
    if (this._cache || (this._cache = new Set(Fe.getValidEnumValues(this._def.values))), !this._cache.has(A.data)) {
      const i = Fe.objectValues(e);
      return NA(r, {
        received: r.data,
        code: FA.invalid_enum_value,
        options: i
      }), se;
    }
    return Xr(A.data);
  }
  get enum() {
    return this._def.values;
  }
}
lv.create = (t, A) => new lv({
  values: t,
  typeName: IA.ZodNativeEnum,
  ...Ce(A)
});
class Ld extends ye {
  unwrap() {
    return this._def.type;
  }
  _parse(A) {
    const { ctx: e } = this._processInputParams(A);
    if (e.parsedType !== JA.promise && e.common.async === !1)
      return NA(e, {
        code: FA.invalid_type,
        expected: JA.promise,
        received: e.parsedType
      }), se;
    const r = e.parsedType === JA.promise ? e.data : Promise.resolve(e.data);
    return Xr(r.then((i) => this._def.type.parseAsync(i, {
      path: e.path,
      errorMap: e.common.contextualErrorMap
    })));
  }
}
Ld.create = (t, A) => new Ld({
  type: t,
  typeName: IA.ZodPromise,
  ...Ce(A)
});
class qc extends ye {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === IA.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(A) {
    const { status: e, ctx: r } = this._processInputParams(A), i = this._def.effect || null, n = {
      addIssue: (s) => {
        NA(r, s), s.fatal ? e.abort() : e.dirty();
      },
      get path() {
        return r.path;
      }
    };
    if (n.addIssue = n.addIssue.bind(n), i.type === "preprocess") {
      const s = i.transform(r.data, n);
      if (r.common.async)
        return Promise.resolve(s).then(async (a) => {
          if (e.value === "aborted")
            return se;
          const g = await this._def.schema._parseAsync({
            data: a,
            path: r.path,
            parent: r
          });
          return g.status === "aborted" ? se : g.status === "dirty" || e.value === "dirty" ? wC(g.value) : g;
        });
      {
        if (e.value === "aborted")
          return se;
        const a = this._def.schema._parseSync({
          data: s,
          path: r.path,
          parent: r
        });
        return a.status === "aborted" ? se : a.status === "dirty" || e.value === "dirty" ? wC(a.value) : a;
      }
    }
    if (i.type === "refinement") {
      const s = (a) => {
        const g = i.refinement(a, n);
        if (r.common.async)
          return Promise.resolve(g);
        if (g instanceof Promise)
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        return a;
      };
      if (r.common.async === !1) {
        const a = this._def.schema._parseSync({
          data: r.data,
          path: r.path,
          parent: r
        });
        return a.status === "aborted" ? se : (a.status === "dirty" && e.dirty(), s(a.value), { status: e.value, value: a.value });
      } else
        return this._def.schema._parseAsync({ data: r.data, path: r.path, parent: r }).then((a) => a.status === "aborted" ? se : (a.status === "dirty" && e.dirty(), s(a.value).then(() => ({ status: e.value, value: a.value }))));
    }
    if (i.type === "transform")
      if (r.common.async === !1) {
        const s = this._def.schema._parseSync({
          data: r.data,
          path: r.path,
          parent: r
        });
        if (!Oc(s))
          return se;
        const a = i.transform(s.value, n);
        if (a instanceof Promise)
          throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
        return { status: e.value, value: a };
      } else
        return this._def.schema._parseAsync({ data: r.data, path: r.path, parent: r }).then((s) => Oc(s) ? Promise.resolve(i.transform(s.value, n)).then((a) => ({
          status: e.value,
          value: a
        })) : se);
    Fe.assertNever(i);
  }
}
qc.create = (t, A, e) => new qc({
  schema: t,
  typeName: IA.ZodEffects,
  effect: A,
  ...Ce(e)
});
qc.createWithPreprocess = (t, A, e) => new qc({
  schema: A,
  effect: { type: "preprocess", transform: t },
  typeName: IA.ZodEffects,
  ...Ce(e)
});
let ka = class extends ye {
  _parse(A) {
    return this._getType(A) === JA.undefined ? Xr(void 0) : this._def.innerType._parse(A);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ka.create = (t, A) => new ka({
  innerType: t,
  typeName: IA.ZodOptional,
  ...Ce(A)
});
let jc = class extends ye {
  _parse(A) {
    return this._getType(A) === JA.null ? Xr(null) : this._def.innerType._parse(A);
  }
  unwrap() {
    return this._def.innerType;
  }
};
jc.create = (t, A) => new jc({
  innerType: t,
  typeName: IA.ZodNullable,
  ...Ce(A)
});
let lm = class extends ye {
  _parse(A) {
    const { ctx: e } = this._processInputParams(A);
    let r = e.data;
    return e.parsedType === JA.undefined && (r = this._def.defaultValue()), this._def.innerType._parse({
      data: r,
      path: e.path,
      parent: e
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
};
lm.create = (t, A) => new lm({
  innerType: t,
  typeName: IA.ZodDefault,
  defaultValue: typeof A.default == "function" ? A.default : () => A.default,
  ...Ce(A)
});
let Bm = class extends ye {
  _parse(A) {
    const { ctx: e } = this._processInputParams(A), r = {
      ...e,
      common: {
        ...e.common,
        issues: []
      }
    }, i = this._def.innerType._parse({
      data: r.data,
      path: r.path,
      parent: {
        ...r
      }
    });
    return bd(i) ? i.then((n) => ({
      status: "valid",
      value: n.status === "valid" ? n.value : this._def.catchValue({
        get error() {
          return new Es(r.common.issues);
        },
        input: r.data
      })
    })) : {
      status: "valid",
      value: i.status === "valid" ? i.value : this._def.catchValue({
        get error() {
          return new Es(r.common.issues);
        },
        input: r.data
      })
    };
  }
  removeCatch() {
    return this._def.innerType;
  }
};
Bm.create = (t, A) => new Bm({
  innerType: t,
  typeName: IA.ZodCatch,
  catchValue: typeof A.catch == "function" ? A.catch : () => A.catch,
  ...Ce(A)
});
class Bv extends ye {
  _parse(A) {
    if (this._getType(A) !== JA.nan) {
      const r = this._getOrReturnCtx(A);
      return NA(r, {
        code: FA.invalid_type,
        expected: JA.nan,
        received: r.parsedType
      }), se;
    }
    return { status: "valid", value: A.data };
  }
}
Bv.create = (t) => new Bv({
  typeName: IA.ZodNaN,
  ...Ce(t)
});
class IW extends ye {
  _parse(A) {
    const { ctx: e } = this._processInputParams(A), r = e.data;
    return this._def.type._parse({
      data: r,
      path: e.path,
      parent: e
    });
  }
  unwrap() {
    return this._def.type;
  }
}
class aS extends ye {
  _parse(A) {
    const { status: e, ctx: r } = this._processInputParams(A);
    if (r.common.async)
      return (async () => {
        const n = await this._def.in._parseAsync({
          data: r.data,
          path: r.path,
          parent: r
        });
        return n.status === "aborted" ? se : n.status === "dirty" ? (e.dirty(), wC(n.value)) : this._def.out._parseAsync({
          data: n.value,
          path: r.path,
          parent: r
        });
      })();
    {
      const i = this._def.in._parseSync({
        data: r.data,
        path: r.path,
        parent: r
      });
      return i.status === "aborted" ? se : i.status === "dirty" ? (e.dirty(), {
        status: "dirty",
        value: i.value
      }) : this._def.out._parseSync({
        data: i.value,
        path: r.path,
        parent: r
      });
    }
  }
  static create(A, e) {
    return new aS({
      in: A,
      out: e,
      typeName: IA.ZodPipeline
    });
  }
}
let Em = class extends ye {
  _parse(A) {
    const e = this._def.innerType._parse(A), r = (i) => (Oc(i) && (i.value = Object.freeze(i.value)), i);
    return bd(e) ? e.then((i) => r(i)) : r(e);
  }
  unwrap() {
    return this._def.innerType;
  }
};
Em.create = (t, A) => new Em({
  innerType: t,
  typeName: IA.ZodReadonly,
  ...Ce(A)
});
var IA;
(function(t) {
  t.ZodString = "ZodString", t.ZodNumber = "ZodNumber", t.ZodNaN = "ZodNaN", t.ZodBigInt = "ZodBigInt", t.ZodBoolean = "ZodBoolean", t.ZodDate = "ZodDate", t.ZodSymbol = "ZodSymbol", t.ZodUndefined = "ZodUndefined", t.ZodNull = "ZodNull", t.ZodAny = "ZodAny", t.ZodUnknown = "ZodUnknown", t.ZodNever = "ZodNever", t.ZodVoid = "ZodVoid", t.ZodArray = "ZodArray", t.ZodObject = "ZodObject", t.ZodUnion = "ZodUnion", t.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", t.ZodIntersection = "ZodIntersection", t.ZodTuple = "ZodTuple", t.ZodRecord = "ZodRecord", t.ZodMap = "ZodMap", t.ZodSet = "ZodSet", t.ZodFunction = "ZodFunction", t.ZodLazy = "ZodLazy", t.ZodLiteral = "ZodLiteral", t.ZodEnum = "ZodEnum", t.ZodEffects = "ZodEffects", t.ZodNativeEnum = "ZodNativeEnum", t.ZodOptional = "ZodOptional", t.ZodNullable = "ZodNullable", t.ZodDefault = "ZodDefault", t.ZodCatch = "ZodCatch", t.ZodPromise = "ZodPromise", t.ZodBranded = "ZodBranded", t.ZodPipeline = "ZodPipeline", t.ZodReadonly = "ZodReadonly";
})(IA || (IA = {}));
const cp = um.create, Ev = cm.create;
La.create;
Yc.create;
const Ip = hs.create;
_d.create;
Nd.create;
Eg.create;
sS.create;
Ld.create;
ka.create;
jc.create;
function CW(t, A) {
  var r, i, n;
  const e = { type: "array" };
  return (r = t.type) != null && r._def && ((n = (i = t.type) == null ? void 0 : i._def) == null ? void 0 : n.typeName) !== IA.ZodAny && (e.items = Me(t.type._def, {
    ...A,
    currentPath: [...A.currentPath, "items"]
  })), t.minLength && _e(e, "minItems", t.minLength.value, t.minLength.message, A), t.maxLength && _e(e, "maxItems", t.maxLength.value, t.maxLength.message, A), t.exactLength && (_e(e, "minItems", t.exactLength.value, t.exactLength.message, A), _e(e, "maxItems", t.exactLength.value, t.exactLength.message, A)), e;
}
function lW(t, A) {
  const e = {
    type: "integer",
    format: "int64"
  };
  if (!t.checks) return e;
  for (const r of t.checks) switch (r.kind) {
    case "min":
      A.target === "jsonSchema7" ? r.inclusive ? _e(e, "minimum", r.value, r.message, A) : _e(e, "exclusiveMinimum", r.value, r.message, A) : (r.inclusive || (e.exclusiveMinimum = !0), _e(e, "minimum", r.value, r.message, A));
      break;
    case "max":
      A.target === "jsonSchema7" ? r.inclusive ? _e(e, "maximum", r.value, r.message, A) : _e(e, "exclusiveMaximum", r.value, r.message, A) : (r.inclusive || (e.exclusiveMaximum = !0), _e(e, "maximum", r.value, r.message, A));
      break;
    case "multipleOf":
      _e(e, "multipleOf", r.value, r.message, A);
      break;
  }
  return e;
}
function BW() {
  return { type: "boolean" };
}
function hG(t, A) {
  return Me(t.type._def, A);
}
const EW = (t, A) => Me(t.innerType._def, A);
function QG(t, A, e) {
  const r = e ?? A.dateStrategy;
  if (Array.isArray(r)) return { anyOf: r.map((i) => QG(t, A, i)) };
  switch (r) {
    case "string":
    case "format:date-time":
      return {
        type: "string",
        format: "date-time"
      };
    case "format:date":
      return {
        type: "string",
        format: "date"
      };
    case "integer":
      return hW(t, A);
  }
}
const hW = (t, A) => {
  const e = {
    type: "integer",
    format: "unix-time"
  };
  if (A.target === "openApi3") return e;
  for (const r of t.checks) switch (r.kind) {
    case "min":
      _e(e, "minimum", r.value, r.message, A);
      break;
    case "max":
      _e(e, "maximum", r.value, r.message, A);
      break;
  }
  return e;
};
function QW(t, A) {
  return {
    ...Me(t.innerType._def, A),
    default: t.defaultValue()
  };
}
function dW(t, A) {
  return A.effectStrategy === "input" ? Me(t.schema._def, A) : Hr(A);
}
function fW(t) {
  return {
    type: "string",
    enum: Array.from(t.values)
  };
}
const pW = (t) => "type" in t && t.type === "string" ? !1 : "allOf" in t;
function yW(t, A) {
  const e = [Me(t.left._def, {
    ...A,
    currentPath: [
      ...A.currentPath,
      "allOf",
      "0"
    ]
  }), Me(t.right._def, {
    ...A,
    currentPath: [
      ...A.currentPath,
      "allOf",
      "1"
    ]
  })].filter((n) => !!n);
  let r = A.target === "jsonSchema2019-09" ? { unevaluatedProperties: !1 } : void 0;
  const i = [];
  return e.forEach((n) => {
    if (pW(n))
      i.push(...n.allOf), n.unevaluatedProperties === void 0 && (r = void 0);
    else {
      let s = n;
      if ("additionalProperties" in n && n.additionalProperties === !1) {
        const { additionalProperties: a, ...g } = n;
        s = g;
      } else r = void 0;
      i.push(s);
    }
  }), i.length ? {
    allOf: i,
    ...r
  } : void 0;
}
function wW(t, A) {
  const e = typeof t.value;
  return e !== "bigint" && e !== "number" && e !== "boolean" && e !== "string" ? { type: Array.isArray(t.value) ? "array" : "object" } : A.target === "openApi3" ? {
    type: e === "bigint" ? "integer" : e,
    enum: [t.value]
  } : {
    type: e === "bigint" ? "integer" : e,
    const: t.value
  };
}
let By;
const Ai = {
  cuid: /^[cC][^\s-]{8,}$/,
  cuid2: /^[0-9a-z]+$/,
  ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,
  email: /^(?!\.)(?!.*\.\.)([a-zA-Z0-9_'+\-\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\-]*\.)+[a-zA-Z]{2,}$/,
  emoji: () => (By === void 0 && (By = RegExp("^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$", "u")), By),
  uuid: /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/,
  ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
  ipv4Cidr: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/,
  ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,
  ipv6Cidr: /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,
  base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
  base64url: /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,
  nanoid: /^[a-zA-Z0-9_-]{21}$/,
  jwt: /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/
};
function dG(t, A) {
  const e = { type: "string" };
  if (t.checks) for (const r of t.checks) switch (r.kind) {
    case "min":
      _e(e, "minLength", typeof e.minLength == "number" ? Math.max(e.minLength, r.value) : r.value, r.message, A);
      break;
    case "max":
      _e(e, "maxLength", typeof e.maxLength == "number" ? Math.min(e.maxLength, r.value) : r.value, r.message, A);
      break;
    case "email":
      switch (A.emailStrategy) {
        case "format:email":
          ei(e, "email", r.message, A);
          break;
        case "format:idn-email":
          ei(e, "idn-email", r.message, A);
          break;
        case "pattern:zod":
          Ar(e, Ai.email, r.message, A);
          break;
      }
      break;
    case "url":
      ei(e, "uri", r.message, A);
      break;
    case "uuid":
      ei(e, "uuid", r.message, A);
      break;
    case "regex":
      Ar(e, r.regex, r.message, A);
      break;
    case "cuid":
      Ar(e, Ai.cuid, r.message, A);
      break;
    case "cuid2":
      Ar(e, Ai.cuid2, r.message, A);
      break;
    case "startsWith":
      Ar(e, RegExp(`^${Ey(r.value, A)}`), r.message, A);
      break;
    case "endsWith":
      Ar(e, RegExp(`${Ey(r.value, A)}$`), r.message, A);
      break;
    case "datetime":
      ei(e, "date-time", r.message, A);
      break;
    case "date":
      ei(e, "date", r.message, A);
      break;
    case "time":
      ei(e, "time", r.message, A);
      break;
    case "duration":
      ei(e, "duration", r.message, A);
      break;
    case "length":
      _e(e, "minLength", typeof e.minLength == "number" ? Math.max(e.minLength, r.value) : r.value, r.message, A), _e(e, "maxLength", typeof e.maxLength == "number" ? Math.min(e.maxLength, r.value) : r.value, r.message, A);
      break;
    case "includes":
      Ar(e, RegExp(Ey(r.value, A)), r.message, A);
      break;
    case "ip":
      r.version !== "v6" && ei(e, "ipv4", r.message, A), r.version !== "v4" && ei(e, "ipv6", r.message, A);
      break;
    case "base64url":
      Ar(e, Ai.base64url, r.message, A);
      break;
    case "jwt":
      Ar(e, Ai.jwt, r.message, A);
      break;
    case "cidr":
      r.version !== "v6" && Ar(e, Ai.ipv4Cidr, r.message, A), r.version !== "v4" && Ar(e, Ai.ipv6Cidr, r.message, A);
      break;
    case "emoji":
      Ar(e, Ai.emoji(), r.message, A);
      break;
    case "ulid":
      Ar(e, Ai.ulid, r.message, A);
      break;
    case "base64":
      switch (A.base64Strategy) {
        case "format:binary":
          ei(e, "binary", r.message, A);
          break;
        case "contentEncoding:base64":
          _e(e, "contentEncoding", "base64", r.message, A);
          break;
        case "pattern:zod":
          Ar(e, Ai.base64, r.message, A);
          break;
      }
      break;
    case "nanoid":
      Ar(e, Ai.nanoid, r.message, A);
      break;
  }
  return e;
}
function Ey(t, A) {
  return A.patternStrategy === "escape" ? DW(t) : t;
}
const mW = /* @__PURE__ */ new Set("ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789");
function DW(t) {
  let A = "";
  for (let e = 0; e < t.length; e++)
    mW.has(t[e]) || (A += "\\"), A += t[e];
  return A;
}
function ei(t, A, e, r) {
  var i;
  t.format || (i = t.anyOf) != null && i.some((n) => n.format) ? (t.anyOf || (t.anyOf = []), t.format && (t.anyOf.push({
    format: t.format,
    ...t.errorMessage && r.errorMessages && { errorMessage: { format: t.errorMessage.format } }
  }), delete t.format, t.errorMessage && (delete t.errorMessage.format, Object.keys(t.errorMessage).length === 0 && delete t.errorMessage)), t.anyOf.push({
    format: A,
    ...e && r.errorMessages && { errorMessage: { format: e } }
  })) : _e(t, "format", A, e, r);
}
function Ar(t, A, e, r) {
  var i;
  t.pattern || (i = t.allOf) != null && i.some((n) => n.pattern) ? (t.allOf || (t.allOf = []), t.pattern && (t.allOf.push({
    pattern: t.pattern,
    ...t.errorMessage && r.errorMessages && { errorMessage: { pattern: t.errorMessage.pattern } }
  }), delete t.pattern, t.errorMessage && (delete t.errorMessage.pattern, Object.keys(t.errorMessage).length === 0 && delete t.errorMessage)), t.allOf.push({
    pattern: hv(A, r),
    ...e && r.errorMessages && { errorMessage: { pattern: e } }
  })) : _e(t, "pattern", hv(A, r), e, r);
}
function hv(t, A) {
  var g;
  if (!A.applyRegexFlags || !t.flags) return t.source;
  const e = {
    i: t.flags.includes("i"),
    m: t.flags.includes("m"),
    s: t.flags.includes("s")
  }, r = e.i ? t.source.toLowerCase() : t.source;
  let i = "", n = !1, s = !1, a = !1;
  for (let o = 0; o < r.length; o++) {
    if (n) {
      i += r[o], n = !1;
      continue;
    }
    if (e.i) {
      if (s) {
        if (r[o].match(/[a-z]/)) {
          a ? (i += r[o], i += `${r[o - 2]}-${r[o]}`.toUpperCase(), a = !1) : r[o + 1] === "-" && ((g = r[o + 2]) != null && g.match(/[a-z]/)) ? (i += r[o], a = !0) : i += `${r[o]}${r[o].toUpperCase()}`;
          continue;
        }
      } else if (r[o].match(/[a-z]/)) {
        i += `[${r[o]}${r[o].toUpperCase()}]`;
        continue;
      }
    }
    if (e.m) {
      if (r[o] === "^") {
        i += `(^|(?<=[\r
]))`;
        continue;
      } else if (r[o] === "$") {
        i += `($|(?=[\r
]))`;
        continue;
      }
    }
    if (e.s && r[o] === ".") {
      i += s ? `${r[o]}\r
` : `[${r[o]}\r
]`;
      continue;
    }
    i += r[o], r[o] === "\\" ? n = !0 : s && r[o] === "]" ? s = !1 : !s && r[o] === "[" && (s = !0);
  }
  try {
    new RegExp(i);
  } catch {
    return console.warn(`Could not convert regex pattern at ${A.currentPath.join("/")} to a flag-independent form! Falling back to the flag-ignorant source`), t.source;
  }
  return i;
}
function fG(t, A) {
  var r, i, n, s, a, g;
  if (A.target === "openAi" && console.warn("Warning: OpenAI may not support records in schemas! Try an array of key-value pairs instead."), A.target === "openApi3" && ((r = t.keyType) == null ? void 0 : r._def.typeName) === IA.ZodEnum) return {
    type: "object",
    required: t.keyType._def.values,
    properties: t.keyType._def.values.reduce((o, u) => ({
      ...o,
      [u]: Me(t.valueType._def, {
        ...A,
        currentPath: [
          ...A.currentPath,
          "properties",
          u
        ]
      }) ?? Hr(A)
    }), {}),
    additionalProperties: A.rejectedAdditionalProperties
  };
  const e = {
    type: "object",
    additionalProperties: Me(t.valueType._def, {
      ...A,
      currentPath: [...A.currentPath, "additionalProperties"]
    }) ?? A.allowedAdditionalProperties
  };
  if (A.target === "openApi3") return e;
  if (((i = t.keyType) == null ? void 0 : i._def.typeName) === IA.ZodString && ((n = t.keyType._def.checks) != null && n.length)) {
    const { type: o, ...u } = dG(t.keyType._def, A);
    return {
      ...e,
      propertyNames: u
    };
  } else {
    if (((s = t.keyType) == null ? void 0 : s._def.typeName) === IA.ZodEnum) return {
      ...e,
      propertyNames: { enum: t.keyType._def.values }
    };
    if (((a = t.keyType) == null ? void 0 : a._def.typeName) === IA.ZodBranded && t.keyType._def.type._def.typeName === IA.ZodString && ((g = t.keyType._def.type._def.checks) != null && g.length)) {
      const { type: o, ...u } = hG(t.keyType._def, A);
      return {
        ...e,
        propertyNames: u
      };
    }
  }
  return e;
}
function SW(t, A) {
  if (A.mapStrategy === "record") return fG(t, A);
  const e = Me(t.keyType._def, {
    ...A,
    currentPath: [
      ...A.currentPath,
      "items",
      "items",
      "0"
    ]
  }) || Hr(A), r = Me(t.valueType._def, {
    ...A,
    currentPath: [
      ...A.currentPath,
      "items",
      "items",
      "1"
    ]
  }) || Hr(A);
  return {
    type: "array",
    maxItems: 125,
    items: {
      type: "array",
      items: [e, r],
      minItems: 2,
      maxItems: 2
    }
  };
}
function FW(t) {
  const A = t.values, r = Object.keys(t.values).filter((n) => typeof A[A[n]] != "number").map((n) => A[n]), i = Array.from(new Set(r.map((n) => typeof n)));
  return {
    type: i.length === 1 ? i[0] === "string" ? "string" : "number" : ["string", "number"],
    enum: r
  };
}
function kW(t) {
  return t.target === "openAi" ? void 0 : { not: Hr({
    ...t,
    currentPath: [...t.currentPath, "not"]
  }) };
}
function vW(t) {
  return t.target === "openApi3" ? {
    enum: ["null"],
    nullable: !0
  } : { type: "null" };
}
const xd = {
  ZodString: "string",
  ZodNumber: "number",
  ZodBigInt: "integer",
  ZodBoolean: "boolean",
  ZodNull: "null"
};
function RW(t, A) {
  if (A.target === "openApi3") return Qv(t, A);
  const e = t.options instanceof Map ? Array.from(t.options.values()) : t.options;
  if (e.every((r) => r._def.typeName in xd && (!r._def.checks || !r._def.checks.length))) {
    const r = e.reduce((i, n) => {
      const s = xd[n._def.typeName];
      return s && !i.includes(s) ? [...i, s] : i;
    }, []);
    return { type: r.length > 1 ? r : r[0] };
  } else if (e.every((r) => r._def.typeName === "ZodLiteral" && !r.description)) {
    const r = e.reduce((i, n) => {
      const s = typeof n._def.value;
      switch (s) {
        case "string":
        case "number":
        case "boolean":
          return [...i, s];
        case "bigint":
          return [...i, "integer"];
        case "object":
          return n._def.value === null ? [...i, "null"] : i;
        case "symbol":
        case "undefined":
        case "function":
        default:
          return i;
      }
    }, []);
    if (r.length === e.length) {
      const i = r.filter((n, s, a) => a.indexOf(n) === s);
      return {
        type: i.length > 1 ? i : i[0],
        enum: e.reduce((n, s) => n.includes(s._def.value) ? n : [...n, s._def.value], [])
      };
    }
  } else if (e.every((r) => r._def.typeName === "ZodEnum")) return {
    type: "string",
    enum: e.reduce((r, i) => [...r, ...i._def.values.filter((n) => !r.includes(n))], [])
  };
  return Qv(t, A);
}
const Qv = (t, A) => {
  const e = (t.options instanceof Map ? Array.from(t.options.values()) : t.options).map((r, i) => Me(r._def, {
    ...A,
    currentPath: [
      ...A.currentPath,
      "anyOf",
      `${i}`
    ]
  })).filter((r) => !!r && (!A.strictUnions || typeof r == "object" && Object.keys(r).length > 0));
  return e.length ? { anyOf: e } : void 0;
};
function bW(t, A) {
  if ([
    "ZodString",
    "ZodNumber",
    "ZodBigInt",
    "ZodBoolean",
    "ZodNull"
  ].includes(t.innerType._def.typeName) && (!t.innerType._def.checks || !t.innerType._def.checks.length))
    return A.target === "openApi3" ? {
      type: xd[t.innerType._def.typeName],
      nullable: !0
    } : { type: [xd[t.innerType._def.typeName], "null"] };
  if (A.target === "openApi3") {
    const r = Me(t.innerType._def, {
      ...A,
      currentPath: [...A.currentPath]
    });
    return r && "$ref" in r ? {
      allOf: [r],
      nullable: !0
    } : r && {
      ...r,
      nullable: !0
    };
  }
  const e = Me(t.innerType._def, {
    ...A,
    currentPath: [
      ...A.currentPath,
      "anyOf",
      "0"
    ]
  });
  return e && { anyOf: [e, { type: "null" }] };
}
function MW(t, A) {
  const e = { type: "number" };
  if (!t.checks) return e;
  for (const r of t.checks) switch (r.kind) {
    case "int":
      e.type = "integer", CG(e, "type", r.message, A);
      break;
    case "min":
      A.target === "jsonSchema7" ? r.inclusive ? _e(e, "minimum", r.value, r.message, A) : _e(e, "exclusiveMinimum", r.value, r.message, A) : (r.inclusive || (e.exclusiveMinimum = !0), _e(e, "minimum", r.value, r.message, A));
      break;
    case "max":
      A.target === "jsonSchema7" ? r.inclusive ? _e(e, "maximum", r.value, r.message, A) : _e(e, "exclusiveMaximum", r.value, r.message, A) : (r.inclusive || (e.exclusiveMaximum = !0), _e(e, "maximum", r.value, r.message, A));
      break;
    case "multipleOf":
      _e(e, "multipleOf", r.value, r.message, A);
      break;
  }
  return e;
}
function _W(t, A) {
  const e = A.target === "openAi", r = {
    type: "object",
    properties: {}
  }, i = [], n = t.shape();
  for (const a in n) {
    let g = n[a];
    if (g === void 0 || g._def === void 0) continue;
    let o = LW(g);
    o && e && (g._def.typeName === "ZodOptional" && (g = g._def.innerType), g.isNullable() || (g = g.nullable()), o = !1);
    const u = Me(g._def, {
      ...A,
      currentPath: [
        ...A.currentPath,
        "properties",
        a
      ],
      propertyPath: [
        ...A.currentPath,
        "properties",
        a
      ]
    });
    u !== void 0 && (r.properties[a] = u, o || i.push(a));
  }
  i.length && (r.required = i);
  const s = NW(t, A);
  return s !== void 0 && (r.additionalProperties = s), r;
}
function NW(t, A) {
  if (t.catchall._def.typeName !== "ZodNever") return Me(t.catchall._def, {
    ...A,
    currentPath: [...A.currentPath, "additionalProperties"]
  });
  switch (t.unknownKeys) {
    case "passthrough":
      return A.allowedAdditionalProperties;
    case "strict":
      return A.rejectedAdditionalProperties;
    case "strip":
      return A.removeAdditionalStrategy === "strict" ? A.allowedAdditionalProperties : A.rejectedAdditionalProperties;
  }
}
function LW(t) {
  try {
    return t.isOptional();
  } catch {
    return !0;
  }
}
const xW = (t, A) => {
  var r;
  if (A.currentPath.toString() === ((r = A.propertyPath) == null ? void 0 : r.toString())) return Me(t.innerType._def, A);
  const e = Me(t.innerType._def, {
    ...A,
    currentPath: [
      ...A.currentPath,
      "anyOf",
      "1"
    ]
  });
  return e ? { anyOf: [{ not: Hr(A) }, e] } : Hr(A);
}, GW = (t, A) => {
  if (A.pipeStrategy === "input") return Me(t.in._def, A);
  if (A.pipeStrategy === "output") return Me(t.out._def, A);
  const e = Me(t.in._def, {
    ...A,
    currentPath: [
      ...A.currentPath,
      "allOf",
      "0"
    ]
  }), r = Me(t.out._def, {
    ...A,
    currentPath: [
      ...A.currentPath,
      "allOf",
      e ? "1" : "0"
    ]
  });
  return { allOf: [e, r].filter((i) => i !== void 0) };
};
function UW(t, A) {
  return Me(t.type._def, A);
}
function TW(t, A) {
  const r = {
    type: "array",
    uniqueItems: !0,
    items: Me(t.valueType._def, {
      ...A,
      currentPath: [...A.currentPath, "items"]
    })
  };
  return t.minSize && _e(r, "minItems", t.minSize.value, t.minSize.message, A), t.maxSize && _e(r, "maxItems", t.maxSize.value, t.maxSize.message, A), r;
}
function KW(t, A) {
  return t.rest ? {
    type: "array",
    minItems: t.items.length,
    items: t.items.map((e, r) => Me(e._def, {
      ...A,
      currentPath: [
        ...A.currentPath,
        "items",
        `${r}`
      ]
    })).reduce((e, r) => r === void 0 ? e : [...e, r], []),
    additionalItems: Me(t.rest._def, {
      ...A,
      currentPath: [...A.currentPath, "additionalItems"]
    })
  } : {
    type: "array",
    minItems: t.items.length,
    maxItems: t.items.length,
    items: t.items.map((e, r) => Me(e._def, {
      ...A,
      currentPath: [
        ...A.currentPath,
        "items",
        `${r}`
      ]
    })).reduce((e, r) => r === void 0 ? e : [...e, r], [])
  };
}
function JW(t) {
  return { not: Hr(t) };
}
function HW(t) {
  return Hr(t);
}
const PW = (t, A) => Me(t.innerType._def, A), OW = (t, A, e) => {
  switch (A) {
    case IA.ZodString:
      return dG(t, e);
    case IA.ZodNumber:
      return MW(t, e);
    case IA.ZodObject:
      return _W(t, e);
    case IA.ZodBigInt:
      return lW(t, e);
    case IA.ZodBoolean:
      return BW();
    case IA.ZodDate:
      return QG(t, e);
    case IA.ZodUndefined:
      return JW(e);
    case IA.ZodNull:
      return vW(e);
    case IA.ZodArray:
      return CW(t, e);
    case IA.ZodUnion:
    case IA.ZodDiscriminatedUnion:
      return RW(t, e);
    case IA.ZodIntersection:
      return yW(t, e);
    case IA.ZodTuple:
      return KW(t, e);
    case IA.ZodRecord:
      return fG(t, e);
    case IA.ZodLiteral:
      return wW(t, e);
    case IA.ZodEnum:
      return fW(t);
    case IA.ZodNativeEnum:
      return FW(t);
    case IA.ZodNullable:
      return bW(t, e);
    case IA.ZodOptional:
      return xW(t, e);
    case IA.ZodMap:
      return SW(t, e);
    case IA.ZodSet:
      return TW(t, e);
    case IA.ZodLazy:
      return () => t.getter()._def;
    case IA.ZodPromise:
      return UW(t, e);
    case IA.ZodNaN:
    case IA.ZodNever:
      return kW(e);
    case IA.ZodEffects:
      return dW(t, e);
    case IA.ZodAny:
      return Hr(e);
    case IA.ZodUnknown:
      return HW(e);
    case IA.ZodDefault:
      return QW(t, e);
    case IA.ZodBranded:
      return hG(t, e);
    case IA.ZodReadonly:
      return PW(t, e);
    case IA.ZodCatch:
      return EW(t, e);
    case IA.ZodPipeline:
      return GW(t, e);
    case IA.ZodFunction:
    case IA.ZodVoid:
    case IA.ZodSymbol:
      return;
    default:
      return /* @__PURE__ */ ((r) => {
      })();
  }
};
function Me(t, A, e = !1) {
  var a;
  const r = A.seen.get(t);
  if (A.override) {
    const g = (a = A.override) == null ? void 0 : a.call(A, t, A, r, e);
    if (g !== G5) return g;
  }
  if (r && !e) {
    const g = YW(r, A);
    if (g !== void 0) return g;
  }
  const i = {
    def: t,
    path: A.currentPath,
    jsonSchema: void 0
  };
  A.seen.set(t, i);
  const n = OW(t, t.typeName, A), s = typeof n == "function" ? Me(n(), A) : n;
  if (s && qW(t, A, s), A.postProcess) {
    const g = A.postProcess(s, t, A);
    return i.jsonSchema = s, g;
  }
  return i.jsonSchema = s, s;
}
const YW = (t, A) => {
  switch (A.$refStrategy) {
    case "root":
      return { $ref: t.path.join("/") };
    case "relative":
      return { $ref: IG(A.currentPath, t.path) };
    case "none":
    case "seen":
      return t.path.length < A.currentPath.length && t.path.every((e, r) => A.currentPath[r] === e) ? (console.warn(`Recursive reference detected at ${A.currentPath.join("/")}! Defaulting to any`), Hr(A)) : A.$refStrategy === "seen" ? Hr(A) : void 0;
  }
}, qW = (t, A, e) => (t.description && (e.description = t.description, A.markdownDescription && (e.markdownDescription = t.description)), e), jW = (t, A) => {
  const e = K5(A);
  let r;
  const i = Me(t._def, e, !1) ?? Hr(e);
  e.flags.hasReferencedOpenAiAnyType && (r || (r = {}), r[e.openAiAnyTypeName] || (r[e.openAiAnyTypeName] = {
    type: [
      "string",
      "number",
      "integer",
      "boolean",
      "array",
      "null"
    ],
    items: { $ref: e.$refStrategy === "relative" ? "1" : [
      ...e.basePath,
      e.definitionPath,
      e.openAiAnyTypeName
    ].join("/") }
  }));
  const n = r ? {
    ...i,
    [e.definitionPath]: r
  } : i;
  return e.target === "jsonSchema7" ? n.$schema = "http://json-schema.org/draft-07/schema#" : (e.target === "jsonSchema2019-09" || e.target === "openAi") && (n.$schema = "https://json-schema.org/draft/2019-09/schema#"), e.target === "openAi" && ("anyOf" in n || "oneOf" in n || "allOf" in n || "type" in n && Array.isArray(n.type)) && console.warn("Warning: OpenAI may not support schemas with unions as roots! Try wrapping it in an object property."), n;
};
function ug(t, A) {
  const e = typeof t;
  if (e !== typeof A)
    return !1;
  if (Array.isArray(t)) {
    if (!Array.isArray(A))
      return !1;
    const r = t.length;
    if (r !== A.length)
      return !1;
    for (let i = 0; i < r; i++)
      if (!ug(t[i], A[i]))
        return !1;
    return !0;
  }
  if (e === "object") {
    if (!t || !A)
      return t === A;
    const r = Object.keys(t), i = Object.keys(A);
    if (r.length !== i.length)
      return !1;
    for (const s of r)
      if (!ug(t[s], A[s]))
        return !1;
    return !0;
  }
  return t === A;
}
function Ei(t) {
  return encodeURI(WW(t));
}
function WW(t) {
  return t.replace(/~/g, "~0").replace(/\//g, "~1");
}
const VW = {
  prefixItems: !0,
  items: !0,
  allOf: !0,
  anyOf: !0,
  oneOf: !0
}, ZW = {
  $defs: !0,
  definitions: !0,
  properties: !0,
  patternProperties: !0,
  dependentSchemas: !0
}, XW = {
  id: !0,
  $id: !0,
  $ref: !0,
  $schema: !0,
  $anchor: !0,
  $vocabulary: !0,
  $comment: !0,
  default: !0,
  enum: !0,
  const: !0,
  required: !0,
  type: !0,
  maximum: !0,
  minimum: !0,
  exclusiveMaximum: !0,
  exclusiveMinimum: !0,
  multipleOf: !0,
  maxLength: !0,
  minLength: !0,
  pattern: !0,
  format: !0,
  maxItems: !0,
  minItems: !0,
  uniqueItems: !0,
  maxProperties: !0,
  minProperties: !0
};
let zW = typeof self < "u" && self.location && self.location.origin !== "null" ? new URL(self.location.origin + self.location.pathname + location.search) : new URL("https://github.com/cfworker");
function ma(t, A = /* @__PURE__ */ Object.create(null), e = zW, r = "") {
  if (t && typeof t == "object" && !Array.isArray(t)) {
    const n = t.$id || t.id;
    if (n) {
      const s = new URL(n, e.href);
      s.hash.length > 1 ? A[s.href] = t : (s.hash = "", r === "" ? e = s : ma(t, A, e));
    }
  } else if (t !== !0 && t !== !1)
    return A;
  const i = e.href + (r ? "#" + r : "");
  if (A[i] !== void 0)
    throw new Error(`Duplicate schema URI "${i}".`);
  if (A[i] = t, t === !0 || t === !1)
    return A;
  if (t.__absolute_uri__ === void 0 && Object.defineProperty(t, "__absolute_uri__", {
    enumerable: !1,
    value: i
  }), t.$ref && t.__absolute_ref__ === void 0) {
    const n = new URL(t.$ref, e.href);
    n.hash = n.hash, Object.defineProperty(t, "__absolute_ref__", {
      enumerable: !1,
      value: n.href
    });
  }
  if (t.$recursiveRef && t.__absolute_recursive_ref__ === void 0) {
    const n = new URL(t.$recursiveRef, e.href);
    n.hash = n.hash, Object.defineProperty(t, "__absolute_recursive_ref__", {
      enumerable: !1,
      value: n.href
    });
  }
  if (t.$anchor) {
    const n = new URL("#" + t.$anchor, e.href);
    A[n.href] = t;
  }
  for (let n in t) {
    if (XW[n])
      continue;
    const s = `${r}/${Ei(n)}`, a = t[n];
    if (Array.isArray(a)) {
      if (VW[n]) {
        const g = a.length;
        for (let o = 0; o < g; o++)
          ma(a[o], A, e, `${s}/${o}`);
      }
    } else if (ZW[n])
      for (let g in a)
        ma(a[g], A, e, `${s}/${Ei(g)}`);
    else
      ma(a, A, e, s);
  }
  return A;
}
const $W = /^(\d\d\d\d)-(\d\d)-(\d\d)$/, AV = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], eV = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d(?::?\d\d)?)?$/i, tV = /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i, rV = /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i, iV = /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i, nV = /^(?:(?:https?|ftp):\/\/)(?:\S+(?::\S*)?@)?(?:(?!10(?:\.\d{1,3}){3})(?!127(?:\.\d{1,3}){3})(?!169\.254(?:\.\d{1,3}){2})(?!192\.168(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z\u{00a1}-\u{ffff}0-9]+-?)*[a-z\u{00a1}-\u{ffff}0-9]+)(?:\.(?:[a-z\u{00a1}-\u{ffff}0-9]+-?)*[a-z\u{00a1}-\u{ffff}0-9]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu, sV = /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i, aV = /^(?:\/(?:[^~/]|~0|~1)*)*$/, oV = /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i, gV = /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/, uV = (t) => {
  if (t[0] === '"')
    return !1;
  const [A, e, ...r] = t.split("@");
  return !A || !e || r.length !== 0 || A.length > 64 || e.length > 253 || A[0] === "." || A.endsWith(".") || A.includes("..") || !/^[a-z0-9.-]+$/i.test(e) || !/^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+$/i.test(A) ? !1 : e.split(".").every((i) => /^[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?$/i.test(i));
}, cV = /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/, IV = /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i, CV = (t) => t.length > 1 && t.length < 80 && (/^P\d+([.,]\d+)?W$/.test(t) || /^P[\dYMDTHS]*(\d[.,]\d+)?[YMDHS]$/.test(t) && /^P([.,\d]+Y)?([.,\d]+M)?([.,\d]+D)?(T([.,\d]+H)?([.,\d]+M)?([.,\d]+S)?)?$/.test(t));
function Ki(t) {
  return t.test.bind(t);
}
const dv = {
  date: pG,
  time: yG.bind(void 0, !1),
  "date-time": EV,
  duration: CV,
  uri: dV,
  "uri-reference": Ki(rV),
  "uri-template": Ki(iV),
  url: Ki(nV),
  email: uV,
  hostname: Ki(tV),
  ipv4: Ki(cV),
  ipv6: Ki(IV),
  regex: pV,
  uuid: Ki(sV),
  "json-pointer": Ki(aV),
  "json-pointer-uri-fragment": Ki(oV),
  "relative-json-pointer": Ki(gV)
};
function lV(t) {
  return t % 4 === 0 && (t % 100 !== 0 || t % 400 === 0);
}
function pG(t) {
  const A = t.match($W);
  if (!A)
    return !1;
  const e = +A[1], r = +A[2], i = +A[3];
  return r >= 1 && r <= 12 && i >= 1 && i <= (r == 2 && lV(e) ? 29 : AV[r]);
}
function yG(t, A) {
  const e = A.match(eV);
  if (!e)
    return !1;
  const r = +e[1], i = +e[2], n = +e[3], s = !!e[5];
  return (r <= 23 && i <= 59 && n <= 59 || r == 23 && i == 59 && n == 60) && (!t || s);
}
const BV = /t|\s/i;
function EV(t) {
  const A = t.split(BV);
  return A.length == 2 && pG(A[0]) && yG(!0, A[1]);
}
const hV = /\/|:/, QV = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
function dV(t) {
  return hV.test(t) && QV.test(t);
}
const fV = /[^\\]\\Z/;
function pV(t) {
  if (fV.test(t))
    return !1;
  try {
    return new RegExp(t, "u"), !0;
  } catch {
    return !1;
  }
}
function yV(t) {
  let A = 0, e = t.length, r = 0, i;
  for (; r < e; )
    A++, i = t.charCodeAt(r++), i >= 55296 && i <= 56319 && r < e && (i = t.charCodeAt(r), (i & 64512) == 56320 && r++);
  return A;
}
function We(t, A, e = "2019-09", r = ma(A), i = !0, n = null, s = "#", a = "#", g = /* @__PURE__ */ Object.create(null)) {
  if (A === !0)
    return { valid: !0, errors: [] };
  if (A === !1)
    return {
      valid: !1,
      errors: [
        {
          instanceLocation: s,
          keyword: "false",
          keywordLocation: s,
          error: "False boolean schema."
        }
      ]
    };
  const o = typeof t;
  let u;
  switch (o) {
    case "boolean":
    case "number":
    case "string":
      u = o;
      break;
    case "object":
      t === null ? u = "null" : Array.isArray(t) ? u = "array" : u = "object";
      break;
    default:
      throw new Error(`Instances of "${o}" type are not supported.`);
  }
  const { $ref: I, $recursiveRef: c, $recursiveAnchor: C, type: E, const: l, enum: B, required: h, not: Q, anyOf: f, allOf: p, oneOf: y, if: m, then: S, else: w, format: F, properties: b, patternProperties: G, additionalProperties: T, unevaluatedProperties: K, minProperties: H, maxProperties: j, propertyNames: eA, dependentRequired: sA, dependentSchemas: uA, dependencies: rA, prefixItems: hA, items: UA, additionalItems: iA, unevaluatedItems: wA, contains: Re, minContains: zA, maxContains: U, minItems: N, maxItems: CA, uniqueItems: P, minimum: XA, maximum: ue, exclusiveMinimum: Y, exclusiveMaximum: L, multipleOf: V, minLength: Z, maxLength: cA, pattern: X, __absolute_ref__: z, __absolute_recursive_ref__: SA } = A, aA = [];
  if (C === !0 && n === null && (n = A), c === "#") {
    const vA = n === null ? r[SA] : n, RA = `${a}/$recursiveRef`, MA = We(t, n === null ? A : n, e, r, i, vA, s, RA, g);
    MA.valid || aA.push({
      instanceLocation: s,
      keyword: "$recursiveRef",
      keywordLocation: RA,
      error: "A subschema had errors."
    }, ...MA.errors);
  }
  if (I !== void 0) {
    const RA = r[z || I];
    if (RA === void 0) {
      let pA = `Unresolved $ref "${I}".`;
      throw z && z !== I && (pA += `  Absolute URI "${z}".`), pA += `
Known schemas:
- ${Object.keys(r).join(`
- `)}`, new Error(pA);
    }
    const MA = `${a}/$ref`, BA = We(t, RA, e, r, i, n, s, MA, g);
    if (BA.valid || aA.push({
      instanceLocation: s,
      keyword: "$ref",
      keywordLocation: MA,
      error: "A subschema had errors."
    }, ...BA.errors), e === "4" || e === "7")
      return { valid: aA.length === 0, errors: aA };
  }
  if (Array.isArray(E)) {
    let vA = E.length, RA = !1;
    for (let MA = 0; MA < vA; MA++)
      if (u === E[MA] || E[MA] === "integer" && u === "number" && t % 1 === 0 && t === t) {
        RA = !0;
        break;
      }
    RA || aA.push({
      instanceLocation: s,
      keyword: "type",
      keywordLocation: `${a}/type`,
      error: `Instance type "${u}" is invalid. Expected "${E.join('", "')}".`
    });
  } else E === "integer" ? (u !== "number" || t % 1 || t !== t) && aA.push({
    instanceLocation: s,
    keyword: "type",
    keywordLocation: `${a}/type`,
    error: `Instance type "${u}" is invalid. Expected "${E}".`
  }) : E !== void 0 && u !== E && aA.push({
    instanceLocation: s,
    keyword: "type",
    keywordLocation: `${a}/type`,
    error: `Instance type "${u}" is invalid. Expected "${E}".`
  });
  if (l !== void 0 && (u === "object" || u === "array" ? ug(t, l) || aA.push({
    instanceLocation: s,
    keyword: "const",
    keywordLocation: `${a}/const`,
    error: `Instance does not match ${JSON.stringify(l)}.`
  }) : t !== l && aA.push({
    instanceLocation: s,
    keyword: "const",
    keywordLocation: `${a}/const`,
    error: `Instance does not match ${JSON.stringify(l)}.`
  })), B !== void 0 && (u === "object" || u === "array" ? B.some((vA) => ug(t, vA)) || aA.push({
    instanceLocation: s,
    keyword: "enum",
    keywordLocation: `${a}/enum`,
    error: `Instance does not match any of ${JSON.stringify(B)}.`
  }) : B.some((vA) => t === vA) || aA.push({
    instanceLocation: s,
    keyword: "enum",
    keywordLocation: `${a}/enum`,
    error: `Instance does not match any of ${JSON.stringify(B)}.`
  })), Q !== void 0) {
    const vA = `${a}/not`;
    We(t, Q, e, r, i, n, s, vA).valid && aA.push({
      instanceLocation: s,
      keyword: "not",
      keywordLocation: vA,
      error: 'Instance matched "not" schema.'
    });
  }
  let Ae = [];
  if (f !== void 0) {
    const vA = `${a}/anyOf`, RA = aA.length;
    let MA = !1;
    for (let BA = 0; BA < f.length; BA++) {
      const pA = f[BA], EA = Object.create(g), _A = We(t, pA, e, r, i, C === !0 ? n : null, s, `${vA}/${BA}`, EA);
      aA.push(..._A.errors), MA = MA || _A.valid, _A.valid && Ae.push(EA);
    }
    MA ? aA.length = RA : aA.splice(RA, 0, {
      instanceLocation: s,
      keyword: "anyOf",
      keywordLocation: vA,
      error: "Instance does not match any subschemas."
    });
  }
  if (p !== void 0) {
    const vA = `${a}/allOf`, RA = aA.length;
    let MA = !0;
    for (let BA = 0; BA < p.length; BA++) {
      const pA = p[BA], EA = Object.create(g), _A = We(t, pA, e, r, i, C === !0 ? n : null, s, `${vA}/${BA}`, EA);
      aA.push(..._A.errors), MA = MA && _A.valid, _A.valid && Ae.push(EA);
    }
    MA ? aA.length = RA : aA.splice(RA, 0, {
      instanceLocation: s,
      keyword: "allOf",
      keywordLocation: vA,
      error: "Instance does not match every subschema."
    });
  }
  if (y !== void 0) {
    const vA = `${a}/oneOf`, RA = aA.length, MA = y.filter((BA, pA) => {
      const EA = Object.create(g), _A = We(t, BA, e, r, i, C === !0 ? n : null, s, `${vA}/${pA}`, EA);
      return aA.push(..._A.errors), _A.valid && Ae.push(EA), _A.valid;
    }).length;
    MA === 1 ? aA.length = RA : aA.splice(RA, 0, {
      instanceLocation: s,
      keyword: "oneOf",
      keywordLocation: vA,
      error: `Instance does not match exactly one subschema (${MA} matches).`
    });
  }
  if ((u === "object" || u === "array") && Object.assign(g, ...Ae), m !== void 0) {
    const vA = `${a}/if`;
    if (We(t, m, e, r, i, n, s, vA, g).valid) {
      if (S !== void 0) {
        const MA = We(t, S, e, r, i, n, s, `${a}/then`, g);
        MA.valid || aA.push({
          instanceLocation: s,
          keyword: "if",
          keywordLocation: vA,
          error: 'Instance does not match "then" schema.'
        }, ...MA.errors);
      }
    } else if (w !== void 0) {
      const MA = We(t, w, e, r, i, n, s, `${a}/else`, g);
      MA.valid || aA.push({
        instanceLocation: s,
        keyword: "if",
        keywordLocation: vA,
        error: 'Instance does not match "else" schema.'
      }, ...MA.errors);
    }
  }
  if (u === "object") {
    if (h !== void 0)
      for (const BA of h)
        BA in t || aA.push({
          instanceLocation: s,
          keyword: "required",
          keywordLocation: `${a}/required`,
          error: `Instance does not have required property "${BA}".`
        });
    const vA = Object.keys(t);
    if (H !== void 0 && vA.length < H && aA.push({
      instanceLocation: s,
      keyword: "minProperties",
      keywordLocation: `${a}/minProperties`,
      error: `Instance does not have at least ${H} properties.`
    }), j !== void 0 && vA.length > j && aA.push({
      instanceLocation: s,
      keyword: "maxProperties",
      keywordLocation: `${a}/maxProperties`,
      error: `Instance does not have at least ${j} properties.`
    }), eA !== void 0) {
      const BA = `${a}/propertyNames`;
      for (const pA in t) {
        const EA = `${s}/${Ei(pA)}`, _A = We(pA, eA, e, r, i, n, EA, BA);
        _A.valid || aA.push({
          instanceLocation: s,
          keyword: "propertyNames",
          keywordLocation: BA,
          error: `Property name "${pA}" does not match schema.`
        }, ..._A.errors);
      }
    }
    if (sA !== void 0) {
      const BA = `${a}/dependantRequired`;
      for (const pA in sA)
        if (pA in t) {
          const EA = sA[pA];
          for (const _A of EA)
            _A in t || aA.push({
              instanceLocation: s,
              keyword: "dependentRequired",
              keywordLocation: BA,
              error: `Instance has "${pA}" but does not have "${_A}".`
            });
        }
    }
    if (uA !== void 0)
      for (const BA in uA) {
        const pA = `${a}/dependentSchemas`;
        if (BA in t) {
          const EA = We(t, uA[BA], e, r, i, n, s, `${pA}/${Ei(BA)}`, g);
          EA.valid || aA.push({
            instanceLocation: s,
            keyword: "dependentSchemas",
            keywordLocation: pA,
            error: `Instance has "${BA}" but does not match dependant schema.`
          }, ...EA.errors);
        }
      }
    if (rA !== void 0) {
      const BA = `${a}/dependencies`;
      for (const pA in rA)
        if (pA in t) {
          const EA = rA[pA];
          if (Array.isArray(EA))
            for (const _A of EA)
              _A in t || aA.push({
                instanceLocation: s,
                keyword: "dependencies",
                keywordLocation: BA,
                error: `Instance has "${pA}" but does not have "${_A}".`
              });
          else {
            const _A = We(t, EA, e, r, i, n, s, `${BA}/${Ei(pA)}`);
            _A.valid || aA.push({
              instanceLocation: s,
              keyword: "dependencies",
              keywordLocation: BA,
              error: `Instance has "${pA}" but does not match dependant schema.`
            }, ..._A.errors);
          }
        }
    }
    const RA = /* @__PURE__ */ Object.create(null);
    let MA = !1;
    if (b !== void 0) {
      const BA = `${a}/properties`;
      for (const pA in b) {
        if (!(pA in t))
          continue;
        const EA = `${s}/${Ei(pA)}`, _A = We(t[pA], b[pA], e, r, i, n, EA, `${BA}/${Ei(pA)}`);
        if (_A.valid)
          g[pA] = RA[pA] = !0;
        else if (MA = i, aA.push({
          instanceLocation: s,
          keyword: "properties",
          keywordLocation: BA,
          error: `Property "${pA}" does not match schema.`
        }, ..._A.errors), MA)
          break;
      }
    }
    if (!MA && G !== void 0) {
      const BA = `${a}/patternProperties`;
      for (const pA in G) {
        const EA = new RegExp(pA, "u"), _A = G[pA];
        for (const oe in t) {
          if (!EA.test(oe))
            continue;
          const q = `${s}/${Ei(oe)}`, AA = We(t[oe], _A, e, r, i, n, q, `${BA}/${Ei(pA)}`);
          AA.valid ? g[oe] = RA[oe] = !0 : (MA = i, aA.push({
            instanceLocation: s,
            keyword: "patternProperties",
            keywordLocation: BA,
            error: `Property "${oe}" matches pattern "${pA}" but does not match associated schema.`
          }, ...AA.errors));
        }
      }
    }
    if (!MA && T !== void 0) {
      const BA = `${a}/additionalProperties`;
      for (const pA in t) {
        if (RA[pA])
          continue;
        const EA = `${s}/${Ei(pA)}`, _A = We(t[pA], T, e, r, i, n, EA, BA);
        _A.valid ? g[pA] = !0 : (MA = i, aA.push({
          instanceLocation: s,
          keyword: "additionalProperties",
          keywordLocation: BA,
          error: `Property "${pA}" does not match additional properties schema.`
        }, ..._A.errors));
      }
    } else if (!MA && K !== void 0) {
      const BA = `${a}/unevaluatedProperties`;
      for (const pA in t)
        if (!g[pA]) {
          const EA = `${s}/${Ei(pA)}`, _A = We(t[pA], K, e, r, i, n, EA, BA);
          _A.valid ? g[pA] = !0 : aA.push({
            instanceLocation: s,
            keyword: "unevaluatedProperties",
            keywordLocation: BA,
            error: `Property "${pA}" does not match unevaluated properties schema.`
          }, ..._A.errors);
        }
    }
  } else if (u === "array") {
    CA !== void 0 && t.length > CA && aA.push({
      instanceLocation: s,
      keyword: "maxItems",
      keywordLocation: `${a}/maxItems`,
      error: `Array has too many items (${t.length} > ${CA}).`
    }), N !== void 0 && t.length < N && aA.push({
      instanceLocation: s,
      keyword: "minItems",
      keywordLocation: `${a}/minItems`,
      error: `Array has too few items (${t.length} < ${N}).`
    });
    const vA = t.length;
    let RA = 0, MA = !1;
    if (hA !== void 0) {
      const BA = `${a}/prefixItems`, pA = Math.min(hA.length, vA);
      for (; RA < pA; RA++) {
        const EA = We(t[RA], hA[RA], e, r, i, n, `${s}/${RA}`, `${BA}/${RA}`);
        if (g[RA] = !0, !EA.valid && (MA = i, aA.push({
          instanceLocation: s,
          keyword: "prefixItems",
          keywordLocation: BA,
          error: "Items did not match schema."
        }, ...EA.errors), MA))
          break;
      }
    }
    if (UA !== void 0) {
      const BA = `${a}/items`;
      if (Array.isArray(UA)) {
        const pA = Math.min(UA.length, vA);
        for (; RA < pA; RA++) {
          const EA = We(t[RA], UA[RA], e, r, i, n, `${s}/${RA}`, `${BA}/${RA}`);
          if (g[RA] = !0, !EA.valid && (MA = i, aA.push({
            instanceLocation: s,
            keyword: "items",
            keywordLocation: BA,
            error: "Items did not match schema."
          }, ...EA.errors), MA))
            break;
        }
      } else
        for (; RA < vA; RA++) {
          const pA = We(t[RA], UA, e, r, i, n, `${s}/${RA}`, BA);
          if (g[RA] = !0, !pA.valid && (MA = i, aA.push({
            instanceLocation: s,
            keyword: "items",
            keywordLocation: BA,
            error: "Items did not match schema."
          }, ...pA.errors), MA))
            break;
        }
      if (!MA && iA !== void 0) {
        const pA = `${a}/additionalItems`;
        for (; RA < vA; RA++) {
          const EA = We(t[RA], iA, e, r, i, n, `${s}/${RA}`, pA);
          g[RA] = !0, EA.valid || (MA = i, aA.push({
            instanceLocation: s,
            keyword: "additionalItems",
            keywordLocation: pA,
            error: "Items did not match additional items schema."
          }, ...EA.errors));
        }
      }
    }
    if (Re !== void 0)
      if (vA === 0 && zA === void 0)
        aA.push({
          instanceLocation: s,
          keyword: "contains",
          keywordLocation: `${a}/contains`,
          error: "Array is empty. It must contain at least one item matching the schema."
        });
      else if (zA !== void 0 && vA < zA)
        aA.push({
          instanceLocation: s,
          keyword: "minContains",
          keywordLocation: `${a}/minContains`,
          error: `Array has less items (${vA}) than minContains (${zA}).`
        });
      else {
        const BA = `${a}/contains`, pA = aA.length;
        let EA = 0;
        for (let _A = 0; _A < vA; _A++) {
          const oe = We(t[_A], Re, e, r, i, n, `${s}/${_A}`, BA);
          oe.valid ? (g[_A] = !0, EA++) : aA.push(...oe.errors);
        }
        EA >= (zA || 0) && (aA.length = pA), zA === void 0 && U === void 0 && EA === 0 ? aA.splice(pA, 0, {
          instanceLocation: s,
          keyword: "contains",
          keywordLocation: BA,
          error: "Array does not contain item matching schema."
        }) : zA !== void 0 && EA < zA ? aA.push({
          instanceLocation: s,
          keyword: "minContains",
          keywordLocation: `${a}/minContains`,
          error: `Array must contain at least ${zA} items matching schema. Only ${EA} items were found.`
        }) : U !== void 0 && EA > U && aA.push({
          instanceLocation: s,
          keyword: "maxContains",
          keywordLocation: `${a}/maxContains`,
          error: `Array may contain at most ${U} items matching schema. ${EA} items were found.`
        });
      }
    if (!MA && wA !== void 0) {
      const BA = `${a}/unevaluatedItems`;
      for (RA; RA < vA; RA++) {
        if (g[RA])
          continue;
        const pA = We(t[RA], wA, e, r, i, n, `${s}/${RA}`, BA);
        g[RA] = !0, pA.valid || aA.push({
          instanceLocation: s,
          keyword: "unevaluatedItems",
          keywordLocation: BA,
          error: "Items did not match unevaluated items schema."
        }, ...pA.errors);
      }
    }
    if (P)
      for (let BA = 0; BA < vA; BA++) {
        const pA = t[BA], EA = typeof pA == "object" && pA !== null;
        for (let _A = 0; _A < vA; _A++) {
          if (BA === _A)
            continue;
          const oe = t[_A];
          (pA === oe || EA && (typeof oe == "object" && oe !== null) && ug(pA, oe)) && (aA.push({
            instanceLocation: s,
            keyword: "uniqueItems",
            keywordLocation: `${a}/uniqueItems`,
            error: `Duplicate items at indexes ${BA} and ${_A}.`
          }), BA = Number.MAX_SAFE_INTEGER, _A = Number.MAX_SAFE_INTEGER);
        }
      }
  } else if (u === "number") {
    if (e === "4" ? (XA !== void 0 && (Y === !0 && t <= XA || t < XA) && aA.push({
      instanceLocation: s,
      keyword: "minimum",
      keywordLocation: `${a}/minimum`,
      error: `${t} is less than ${Y ? "or equal to " : ""} ${XA}.`
    }), ue !== void 0 && (L === !0 && t >= ue || t > ue) && aA.push({
      instanceLocation: s,
      keyword: "maximum",
      keywordLocation: `${a}/maximum`,
      error: `${t} is greater than ${L ? "or equal to " : ""} ${ue}.`
    })) : (XA !== void 0 && t < XA && aA.push({
      instanceLocation: s,
      keyword: "minimum",
      keywordLocation: `${a}/minimum`,
      error: `${t} is less than ${XA}.`
    }), ue !== void 0 && t > ue && aA.push({
      instanceLocation: s,
      keyword: "maximum",
      keywordLocation: `${a}/maximum`,
      error: `${t} is greater than ${ue}.`
    }), Y !== void 0 && t <= Y && aA.push({
      instanceLocation: s,
      keyword: "exclusiveMinimum",
      keywordLocation: `${a}/exclusiveMinimum`,
      error: `${t} is less than ${Y}.`
    }), L !== void 0 && t >= L && aA.push({
      instanceLocation: s,
      keyword: "exclusiveMaximum",
      keywordLocation: `${a}/exclusiveMaximum`,
      error: `${t} is greater than or equal to ${L}.`
    })), V !== void 0) {
      const vA = t % V;
      Math.abs(0 - vA) >= 11920929e-14 && Math.abs(V - vA) >= 11920929e-14 && aA.push({
        instanceLocation: s,
        keyword: "multipleOf",
        keywordLocation: `${a}/multipleOf`,
        error: `${t} is not a multiple of ${V}.`
      });
    }
  } else if (u === "string") {
    const vA = Z === void 0 && cA === void 0 ? 0 : yV(t);
    Z !== void 0 && vA < Z && aA.push({
      instanceLocation: s,
      keyword: "minLength",
      keywordLocation: `${a}/minLength`,
      error: `String is too short (${vA} < ${Z}).`
    }), cA !== void 0 && vA > cA && aA.push({
      instanceLocation: s,
      keyword: "maxLength",
      keywordLocation: `${a}/maxLength`,
      error: `String is too long (${vA} > ${cA}).`
    }), X !== void 0 && !new RegExp(X, "u").test(t) && aA.push({
      instanceLocation: s,
      keyword: "pattern",
      keywordLocation: `${a}/pattern`,
      error: "String does not match pattern."
    }), F !== void 0 && dv[F] && !dv[F](t) && aA.push({
      instanceLocation: s,
      keyword: "format",
      keywordLocation: `${a}/format`,
      error: `String does not match format "${F}".`
    });
  }
  return { valid: aA.length === 0, errors: aA };
}
class wV {
  constructor(A, e = "2019-09", r = !0) {
    R(this, "schema");
    R(this, "draft");
    R(this, "shortCircuit");
    R(this, "lookup");
    this.schema = A, this.draft = e, this.shortCircuit = r, this.lookup = ma(A);
  }
  validate(A) {
    return We(A, this.schema, this.draft, this.lookup, this.shortCircuit);
  }
  addSchema(A, e) {
    e && (A = { ...A, $id: e }), ma(A, this.lookup);
  }
}
var mV = {};
fe(mV, {
  Validator: () => wV,
  deepCompareStrict: () => ug,
  toJsonSchema: () => Cn,
  validatesOnlyStrings: () => TC
});
function Cn(t) {
  if (Ze(t)) {
    const A = uG(t, !0);
    if (Qn(A)) {
      const e = Rd(A, !0);
      return vd(e);
    } else return vd(t);
  }
  return Ct(t) ? jW(t) : t;
}
function TC(t) {
  if (!t || typeof t != "object" || Object.keys(t).length === 0 || Array.isArray(t)) return !1;
  if ("type" in t)
    return typeof t.type == "string" ? t.type === "string" : Array.isArray(t.type) ? t.type.every((A) => A === "string") : !1;
  if ("enum" in t) return Array.isArray(t.enum) && t.enum.length > 0 && t.enum.every((A) => typeof A == "string");
  if ("const" in t) return typeof t.const == "string";
  if ("allOf" in t && Array.isArray(t.allOf)) return t.allOf.some((A) => TC(A));
  if ("anyOf" in t && Array.isArray(t.anyOf) || "oneOf" in t && Array.isArray(t.oneOf)) {
    const A = "anyOf" in t ? t.anyOf : t.oneOf;
    return A.length > 0 && A.every((e) => TC(e));
  }
  if ("not" in t) return !1;
  if ("$ref" in t && typeof t.$ref == "string") {
    const A = t.$ref, e = ma(t);
    return e[A] ? TC(e[A]) : !1;
  }
  return !1;
}
var DV = {};
fe(DV, { Graph: () => oS });
function SV(t, A) {
  if (t !== void 0 && !GQ(t)) return t;
  if (X0(A)) try {
    let e = A.getName();
    return e = e.startsWith("Runnable") ? e.slice(8) : e, e;
  } catch {
    return A.getName();
  }
  else return A.name ?? "UnknownSchema";
}
function FV(t) {
  return X0(t.data) ? {
    type: "runnable",
    data: {
      id: t.data.lc_id,
      name: t.data.getName()
    }
  } : {
    type: "schema",
    data: {
      ...Cn(t.data.schema),
      title: t.data.name
    }
  };
}
var oS = class wG {
  constructor(A) {
    R(this, "nodes", {});
    R(this, "edges", []);
    this.nodes = (A == null ? void 0 : A.nodes) ?? this.nodes, this.edges = (A == null ? void 0 : A.edges) ?? this.edges;
  }
  toJSON() {
    const A = {};
    return Object.values(this.nodes).forEach((e, r) => {
      A[e.id] = GQ(e.id) ? r : e.id;
    }), {
      nodes: Object.values(this.nodes).map((e) => ({
        id: A[e.id],
        ...FV(e)
      })),
      edges: this.edges.map((e) => {
        const r = {
          source: A[e.source],
          target: A[e.target]
        };
        return typeof e.data < "u" && (r.data = e.data), typeof e.conditional < "u" && (r.conditional = e.conditional), r;
      })
    };
  }
  addNode(A, e, r) {
    if (e !== void 0 && this.nodes[e] !== void 0) throw new Error(`Node with id ${e} already exists`);
    const i = e ?? Hn(), n = {
      id: i,
      data: A,
      name: SV(e, A),
      metadata: r
    };
    return this.nodes[i] = n, n;
  }
  removeNode(A) {
    delete this.nodes[A.id], this.edges = this.edges.filter((e) => e.source !== A.id && e.target !== A.id);
  }
  addEdge(A, e, r, i) {
    if (this.nodes[A.id] === void 0) throw new Error(`Source node ${A.id} not in graph`);
    if (this.nodes[e.id] === void 0) throw new Error(`Target node ${e.id} not in graph`);
    const n = {
      source: A.id,
      target: e.id,
      data: r,
      conditional: i
    };
    return this.edges.push(n), n;
  }
  firstNode() {
    return fv(this);
  }
  lastNode() {
    return pv(this);
  }
  /**
  * Add all nodes and edges from another graph.
  * Note this doesn't check for duplicates, nor does it connect the graphs.
  */
  extend(A, e = "") {
    let r = e;
    Object.values(A.nodes).map((o) => o.id).every(GQ) && (r = "");
    const n = (o) => r ? `${r}:${o}` : o;
    Object.entries(A.nodes).forEach(([o, u]) => {
      this.nodes[n(o)] = {
        ...u,
        id: n(o)
      };
    });
    const s = A.edges.map((o) => ({
      ...o,
      source: n(o.source),
      target: n(o.target)
    }));
    this.edges = [...this.edges, ...s];
    const a = A.firstNode(), g = A.lastNode();
    return [a ? {
      id: n(a.id),
      data: a.data
    } : void 0, g ? {
      id: n(g.id),
      data: g.data
    } : void 0];
  }
  trimFirstNode() {
    const A = this.firstNode();
    A && fv(this, [A.id]) && this.removeNode(A);
  }
  trimLastNode() {
    const A = this.lastNode();
    A && pv(this, [A.id]) && this.removeNode(A);
  }
  /**
  * Return a new graph with all nodes re-identified,
  * using their unique, readable names where possible.
  */
  reid() {
    const A = Object.fromEntries(Object.values(this.nodes).map((i) => [i.id, i.name])), e = /* @__PURE__ */ new Map();
    Object.values(A).forEach((i) => {
      e.set(i, (e.get(i) || 0) + 1);
    });
    const r = (i) => {
      const n = A[i];
      return GQ(i) && e.get(n) === 1 ? n : i;
    };
    return new wG({
      nodes: Object.fromEntries(Object.entries(this.nodes).map(([i, n]) => [r(i), {
        ...n,
        id: r(i)
      }])),
      edges: this.edges.map((i) => ({
        ...i,
        source: r(i.source),
        target: r(i.target)
      }))
    });
  }
  drawMermaid(A) {
    const { withStyles: e, curveStyle: r, nodeColors: i = {
      default: "fill:#f2f0ff,line-height:1.2",
      first: "fill-opacity:0",
      last: "fill:#bfb6fc"
    }, wrapLabelNWords: n } = A ?? {}, s = this.reid(), a = s.firstNode(), g = s.lastNode();
    return L5(s.nodes, s.edges, {
      firstNode: a == null ? void 0 : a.id,
      lastNode: g == null ? void 0 : g.id,
      withStyles: e,
      curveStyle: r,
      nodeColors: i,
      wrapLabelNWords: n
    });
  }
  async drawMermaidPng(A) {
    const e = this.drawMermaid(A);
    return x5(e, { backgroundColor: A == null ? void 0 : A.backgroundColor });
  }
};
function fv(t, A = []) {
  const e = new Set(t.edges.filter((i) => !A.includes(i.source)).map((i) => i.target)), r = [];
  for (const i of Object.values(t.nodes)) !A.includes(i.id) && !e.has(i.id) && r.push(i);
  return r.length === 1 ? r[0] : void 0;
}
function pv(t, A = []) {
  const e = new Set(t.edges.filter((i) => !A.includes(i.target)).map((i) => i.source)), r = [];
  for (const i of Object.values(t.nodes)) !A.includes(i.id) && !e.has(i.id) && r.push(i);
  return r.length === 1 ? r[0] : void 0;
}
function kV(t) {
  const A = new TextEncoder(), e = new ReadableStream({ async start(r) {
    for await (const i of t) r.enqueue(A.encode(`event: data
data: ${JSON.stringify(i)}

`));
    r.enqueue(A.encode(`event: end

`)), r.close();
  } });
  return bi.fromReadableStream(e);
}
function yv(t) {
  return typeof t == "object" && t !== null && typeof t[Symbol.iterator] == "function" && typeof t.next == "function";
}
const vV = (t) => t != null && typeof t == "object" && "next" in t && typeof t.next == "function";
function hm(t) {
  return typeof t == "object" && t !== null && typeof t[Symbol.asyncIterator] == "function";
}
function* wv(t, A) {
  for (; ; ) {
    const { value: e, done: r } = Ri.runWithConfig(ls(t), A.next.bind(A), !0);
    if (r) break;
    yield e;
  }
}
async function* Qm(t, A) {
  const e = A[Symbol.asyncIterator]();
  for (; ; ) {
    const { value: r, done: i } = await Ri.runWithConfig(ls(t), e.next.bind(A), !0);
    if (i) break;
    yield r;
  }
}
function Qt(t, A) {
  return t && !Array.isArray(t) && !(t instanceof Date) && typeof t == "object" ? t : { [A]: t };
}
var rt = class extends Kc {
  constructor() {
    super(...arguments);
    R(this, "lc_runnable", !0);
    R(this, "name");
  }
  getName(A) {
    const e = this.name ?? this.constructor.lc_name() ?? this.constructor.name;
    return A ? `${e}${A}` : e;
  }
  /**
  * Add retry logic to an existing runnable.
  * @param fields.stopAfterAttempt The number of attempts to retry.
  * @param fields.onFailedAttempt A function that is called when a retry fails.
  * @returns A new RunnableRetry that, when invoked, will retry according to the parameters.
  */
  withRetry(A) {
    return new gS({
      bound: this,
      kwargs: {},
      config: {},
      maxAttemptNumber: A == null ? void 0 : A.stopAfterAttempt,
      ...A
    });
  }
  /**
  * Bind config to a Runnable, returning a new Runnable.
  * @param config New configuration parameters to attach to the new runnable.
  * @returns A new RunnableBinding with a config matching what's passed.
  */
  withConfig(A) {
    return new Wc({
      bound: this,
      config: A,
      kwargs: {}
    });
  }
  /**
  * Create a new runnable from the current one that will try invoking
  * other passed fallback runnables if the initial invocation fails.
  * @param fields.fallbacks Other runnables to call if the runnable errors.
  * @returns A new RunnableWithFallbacks.
  */
  withFallbacks(A) {
    const e = Array.isArray(A) ? A : A.fallbacks;
    return new vG({
      runnable: this,
      fallbacks: e
    });
  }
  _getOptionsList(A, e = 0) {
    if (Array.isArray(A) && A.length !== e) throw new Error(`Passed "options" must be an array with the same length as the inputs, but got ${A.length} options for ${e} inputs`);
    if (Array.isArray(A)) return A.map(Se);
    if (e > 1 && !Array.isArray(A) && A.runId) {
      console.warn("Provided runId will be used only for the first element of the batch.");
      const r = Object.fromEntries(Object.entries(A).filter(([i]) => i !== "runId"));
      return Array.from({ length: e }, (i, n) => Se(n === 0 ? A : r));
    }
    return Array.from({ length: e }, () => Se(A));
  }
  async batch(A, e, r) {
    var g;
    const i = this._getOptionsList(e ?? {}, A.length), n = ((g = i[0]) == null ? void 0 : g.maxConcurrency) ?? (r == null ? void 0 : r.maxConcurrency), s = new UE({
      maxConcurrency: n,
      onFailedAttempt: (o) => {
        throw o;
      }
    }), a = A.map((o, u) => s.call(async () => {
      try {
        return await this.invoke(o, i[u]);
      } catch (I) {
        if (r != null && r.returnExceptions) return I;
        throw I;
      }
    }));
    return Promise.all(a);
  }
  /**
  * Default streaming implementation.
  * Subclasses should override this method if they support streaming output.
  * @param input
  * @param options
  */
  async *_streamIterator(A, e) {
    yield this.invoke(A, e);
  }
  /**
  * Stream output in chunks.
  * @param input
  * @param options
  * @returns A readable stream that is also an iterable.
  */
  async stream(A, e) {
    const r = Se(e), i = new mg({
      generator: this._streamIterator(A, r),
      config: r
    });
    return await i.setup, bi.fromAsyncGenerator(i);
  }
  _separateRunnableConfigFromCallOptions(A) {
    let e;
    A === void 0 ? e = Se(A) : e = Se({
      callbacks: A.callbacks,
      tags: A.tags,
      metadata: A.metadata,
      runName: A.runName,
      configurable: A.configurable,
      recursionLimit: A.recursionLimit,
      maxConcurrency: A.maxConcurrency,
      runId: A.runId,
      timeout: A.timeout,
      signal: A.signal
    });
    const r = { ...A };
    return delete r.callbacks, delete r.tags, delete r.metadata, delete r.runName, delete r.configurable, delete r.recursionLimit, delete r.maxConcurrency, delete r.runId, delete r.timeout, delete r.signal, [e, r];
  }
  async _callWithConfig(A, e, r) {
    const i = Se(r), n = await Jr(i), s = await (n == null ? void 0 : n.handleChainStart(this.toJSON(), Qt(e, "input"), i.runId, i == null ? void 0 : i.runType, void 0, void 0, (i == null ? void 0 : i.runName) ?? this.getName()));
    delete i.runId;
    let a;
    try {
      const g = A.call(this, e, i, s);
      a = await Bs(g, r == null ? void 0 : r.signal);
    } catch (g) {
      throw await (s == null ? void 0 : s.handleChainError(g)), g;
    }
    return await (s == null ? void 0 : s.handleChainEnd(Qt(a, "output"))), a;
  }
  /**
  * Internal method that handles batching and configuration for a runnable
  * It takes a function, input values, and optional configuration, and
  * returns a promise that resolves to the output values.
  * @param func The function to be executed for each input value.
  * @param input The input values to be processed.
  * @param config Optional configuration for the function execution.
  * @returns A promise that resolves to the output values.
  */
  async _batchWithConfig(A, e, r, i) {
    var o;
    const n = this._getOptionsList(r ?? {}, e.length), s = await Promise.all(n.map(Jr)), a = await Promise.all(s.map(async (u, I) => {
      const c = await (u == null ? void 0 : u.handleChainStart(this.toJSON(), Qt(e[I], "input"), n[I].runId, n[I].runType, void 0, void 0, n[I].runName ?? this.getName()));
      return delete n[I].runId, c;
    }));
    let g;
    try {
      const u = A.call(this, e, n, a, i);
      g = await Bs(u, (o = n == null ? void 0 : n[0]) == null ? void 0 : o.signal);
    } catch (u) {
      throw await Promise.all(a.map((I) => I == null ? void 0 : I.handleChainError(u))), u;
    }
    return await Promise.all(a.map((u) => u == null ? void 0 : u.handleChainEnd(Qt(g, "output")))), g;
  }
  /** @internal */
  _concatOutputChunks(A, e) {
    return _a(A, e);
  }
  /**
  * Helper method to transform an Iterator of Input values into an Iterator of
  * Output values, with callbacks.
  * Use this to implement `stream()` or `transform()` in Runnable subclasses.
  */
  async *_transformStreamWithConfig(A, e, r) {
    let i, n = !0, s, a = !0;
    const g = Se(r), o = await Jr(g), u = this;
    async function* I() {
      for await (const C of A) {
        if (n) if (i === void 0) i = C;
        else try {
          i = u._concatOutputChunks(i, C);
        } catch {
          i = void 0, n = !1;
        }
        yield C;
      }
    }
    let c;
    try {
      const C = await Fx(e.bind(this), I(), async () => o == null ? void 0 : o.handleChainStart(this.toJSON(), { input: "" }, g.runId, g.runType, void 0, void 0, g.runName ?? this.getName()), r == null ? void 0 : r.signal, g);
      delete g.runId, c = C.setup;
      const E = c == null ? void 0 : c.handlers.find(k3);
      let l = C.output;
      E !== void 0 && c !== void 0 && (l = E.tapOutputIterable(c.runId, l));
      const B = c == null ? void 0 : c.handlers.find(bx);
      B !== void 0 && c !== void 0 && (l = B.tapOutputIterable(c.runId, l));
      for await (const h of l)
        if (yield h, a) if (s === void 0) s = h;
        else try {
          s = this._concatOutputChunks(s, h);
        } catch {
          s = void 0, a = !1;
        }
    } catch (C) {
      throw await (c == null ? void 0 : c.handleChainError(C, void 0, void 0, void 0, { inputs: Qt(i, "input") })), C;
    }
    await (c == null ? void 0 : c.handleChainEnd(s ?? {}, void 0, void 0, void 0, { inputs: Qt(i, "input") }));
  }
  getGraph(A) {
    const e = new oS(), r = e.addNode({
      name: `${this.getName()}Input`,
      schema: Ev()
    }), i = e.addNode(this), n = e.addNode({
      name: `${this.getName()}Output`,
      schema: Ev()
    });
    return e.addEdge(r, i), e.addEdge(i, n), e;
  }
  /**
  * Create a new runnable sequence that runs each individual runnable in series,
  * piping the output of one runnable into another runnable or runnable-like.
  * @param coerceable A runnable, function, or object whose values are functions or runnables.
  * @returns A new runnable sequence.
  */
  pipe(A) {
    return new TE({
      first: this,
      last: ki(A)
    });
  }
  /**
  * Pick keys from the dict output of this runnable. Returns a new runnable.
  */
  pick(A) {
    return this.pipe(new RG(A));
  }
  /**
  * Assigns new fields to the dict output of this runnable. Returns a new runnable.
  */
  assign(A) {
    return this.pipe(new uS(new uI({ steps: A })));
  }
  /**
  * Default implementation of transform, which buffers input and then calls stream.
  * Subclasses should override this method if they can start producing output while
  * input is still being generated.
  * @param generator
  * @param options
  */
  async *transform(A, e) {
    let r;
    for await (const i of A) r === void 0 ? r = i : r = this._concatOutputChunks(r, i);
    yield* this._streamIterator(r, Se(e));
  }
  /**
  * Stream all output from a runnable, as reported to the callback system.
  * This includes all inner runs of LLMs, Retrievers, Tools, etc.
  * Output is streamed as Log objects, which include a list of
  * jsonpatch ops that describe how the state of the run has changed in each
  * step, and the final state of the run.
  * The jsonpatch ops can be applied in order to construct state.
  * @param input
  * @param options
  * @param streamOptions
  */
  async *streamLog(A, e, r) {
    const i = new rm({
      ...r,
      autoClose: !1,
      _schemaFormat: "original"
    }), n = Se(e);
    yield* this._streamLog(A, i, n);
  }
  async *_streamLog(A, e, r) {
    const { callbacks: i } = r;
    if (i === void 0) r.callbacks = [e];
    else if (Array.isArray(i)) r.callbacks = i.concat([e]);
    else {
      const g = i.copy();
      g.addHandler(e, !0), r.callbacks = g;
    }
    const n = this.stream(A, r);
    async function s() {
      try {
        const g = await n;
        for await (const o of g) {
          const u = new Pn({ ops: [{
            op: "add",
            path: "/streamed_output/-",
            value: o
          }] });
          await e.writer.write(u);
        }
      } finally {
        await e.writer.close();
      }
    }
    const a = s();
    try {
      for await (const g of e) yield g;
    } finally {
      await a;
    }
  }
  streamEvents(A, e, r) {
    let i;
    if (e.version === "v1") i = this._streamEventsV1(A, e, r);
    else if (e.version === "v2") i = this._streamEventsV2(A, e, r);
    else throw new Error('Only versions "v1" and "v2" of the schema are currently supported.');
    return e.encoding === "text/event-stream" ? kV(i) : bi.fromAsyncGenerator(i);
  }
  async *_streamEventsV2(A, e, r) {
    var E;
    const i = new v3({
      ...r,
      autoClose: !1
    }), n = Se(e), s = n.runId ?? Hn();
    n.runId = s;
    const a = n.callbacks;
    if (a === void 0) n.callbacks = [i];
    else if (Array.isArray(a)) n.callbacks = a.concat(i);
    else {
      const l = a.copy();
      l.addHandler(i, !0), n.callbacks = l;
    }
    const g = new AbortController(), o = this;
    async function u() {
      let l, B = null;
      try {
        e != null && e.signal ? "any" in AbortSignal ? l = AbortSignal.any([g.signal, e.signal]) : (l = e.signal, B = () => {
          g.abort();
        }, e.signal.addEventListener("abort", B, { once: !0 })) : l = g.signal;
        const h = await o.stream(A, {
          ...n,
          signal: l
        }), Q = i.tapOutputIterable(s, h);
        for await (const f of Q) if (g.signal.aborted) break;
      } finally {
        await i.finish(), l && B && l.removeEventListener("abort", B);
      }
    }
    const I = u();
    let c = !1, C;
    try {
      for await (const l of i) {
        if (!c) {
          l.data.input = A, c = !0, C = l.run_id, yield l;
          continue;
        }
        l.run_id === C && l.event.endsWith("_end") && (E = l.data) != null && E.input && delete l.data.input, yield l;
      }
    } finally {
      g.abort(), await I;
    }
  }
  async *_streamEventsV1(A, e, r) {
    let i, n = !1;
    const s = Se(e), a = s.tags ?? [], g = s.metadata ?? {}, o = s.runName ?? this.getName(), u = new rm({
      ...r,
      autoClose: !1,
      _schemaFormat: "streaming_events"
    }), I = new J3({ ...r }), c = this._streamLog(A, u, s);
    for await (const E of c) {
      if (i ? i = i.concat(E) : i = Z0.fromRunLogPatch(E), i.state === void 0) throw new Error('Internal error: "streamEvents" state is missing. Please open a bug report.');
      if (!n) {
        n = !0;
        const Q = { ...i.state }, f = {
          run_id: Q.id,
          event: `on_${Q.type}_start`,
          name: o,
          tags: a,
          metadata: g,
          data: { input: A }
        };
        I.includeEvent(f, Q.type) && (yield f);
      }
      const l = E.ops.filter((Q) => Q.path.startsWith("/logs/")).map((Q) => Q.path.split("/")[2]), B = [...new Set(l)];
      for (const Q of B) {
        let f, p = {};
        const y = i.state.logs[Q];
        if (y.end_time === void 0 ? y.streamed_output.length > 0 ? f = "stream" : f = "start" : f = "end", f === "start")
          y.inputs !== void 0 && (p.input = y.inputs);
        else if (f === "end")
          y.inputs !== void 0 && (p.input = y.inputs), p.output = y.final_output;
        else if (f === "stream") {
          const m = y.streamed_output.length;
          if (m !== 1) throw new Error(`Expected exactly one chunk of streamed output, got ${m} instead. Encountered in: "${y.name}"`);
          p = { chunk: y.streamed_output[0] }, y.streamed_output = [];
        }
        yield {
          event: `on_${y.type}_${f}`,
          name: y.name,
          run_id: y.id,
          tags: y.tags,
          metadata: y.metadata,
          data: p
        };
      }
      const { state: h } = i;
      if (h.streamed_output.length > 0) {
        const Q = h.streamed_output.length;
        if (Q !== 1) throw new Error(`Expected exactly one chunk of streamed output, got ${Q} instead. Encountered in: "${h.name}"`);
        const f = { chunk: h.streamed_output[0] };
        h.streamed_output = [];
        const p = {
          event: `on_${h.type}_stream`,
          run_id: h.id,
          tags: a,
          metadata: g,
          name: o,
          data: f
        };
        I.includeEvent(p, h.type) && (yield p);
      }
    }
    const C = i == null ? void 0 : i.state;
    if (C !== void 0) {
      const E = {
        event: `on_${C.type}_end`,
        name: o,
        run_id: C.id,
        tags: a,
        metadata: g,
        data: { output: C.final_output }
      };
      I.includeEvent(E, C.type) && (yield E);
    }
  }
  static isRunnable(A) {
    return X0(A);
  }
  /**
  * Bind lifecycle listeners to a Runnable, returning a new Runnable.
  * The Run object contains information about the run, including its id,
  * type, input, output, error, startTime, endTime, and any tags or metadata
  * added to the run.
  *
  * @param {Object} params - The object containing the callback functions.
  * @param {(run: Run) => void} params.onStart - Called before the runnable starts running, with the Run object.
  * @param {(run: Run) => void} params.onEnd - Called after the runnable finishes running, with the Run object.
  * @param {(run: Run) => void} params.onError - Called if the runnable throws an error, with the Run object.
  */
  withListeners({ onStart: A, onEnd: e, onError: r }) {
    return new Wc({
      bound: this,
      config: {},
      configFactories: [(i) => ({ callbacks: [new Nx({
        config: i,
        onStart: A,
        onEnd: e,
        onError: r
      })] })]
    });
  }
  /**
  * Convert a runnable to a tool. Return a new instance of `RunnableToolLike`
  * which contains the runnable, name, description and schema.
  *
  * @template {T extends RunInput = RunInput} RunInput - The input type of the runnable. Should be the same as the `RunInput` type of the runnable.
  *
  * @param fields
  * @param {string | undefined} [fields.name] The name of the tool. If not provided, it will default to the name of the runnable.
  * @param {string | undefined} [fields.description] The description of the tool. Falls back to the description on the Zod schema if not provided, or undefined if neither are provided.
  * @param {z.ZodType<T>} [fields.schema] The Zod schema for the input of the tool. Infers the Zod type from the input type of the runnable.
  * @returns {RunnableToolLike<z.ZodType<T>, RunOutput>} An instance of `RunnableToolLike` which is a runnable that can be used as a tool.
  */
  asTool(A) {
    return NV(this, A);
  }
}, Wc = class mG extends rt {
  constructor(e) {
    super(e);
    R(this, "lc_namespace", ["langchain_core", "runnables"]);
    R(this, "lc_serializable", !0);
    R(this, "bound");
    R(this, "config");
    R(this, "kwargs");
    R(this, "configFactories");
    this.bound = e.bound, this.kwargs = e.kwargs, this.config = e.config, this.configFactories = e.configFactories;
  }
  static lc_name() {
    return "RunnableBinding";
  }
  getName(e) {
    return this.bound.getName(e);
  }
  async _mergeConfig(...e) {
    const r = wd(this.config, ...e);
    return wd(r, ...this.configFactories ? await Promise.all(this.configFactories.map(async (i) => await i(r))) : []);
  }
  withConfig(e) {
    return new this.constructor({
      bound: this.bound,
      kwargs: this.kwargs,
      config: {
        ...this.config,
        ...e
      }
    });
  }
  withRetry(e) {
    return new gS({
      bound: this.bound,
      kwargs: this.kwargs,
      config: this.config,
      maxAttemptNumber: e == null ? void 0 : e.stopAfterAttempt,
      ...e
    });
  }
  async invoke(e, r) {
    return this.bound.invoke(e, await this._mergeConfig(r, this.kwargs));
  }
  async batch(e, r, i) {
    const n = Array.isArray(r) ? await Promise.all(r.map(async (s) => this._mergeConfig(Se(s), this.kwargs))) : await this._mergeConfig(Se(r), this.kwargs);
    return this.bound.batch(e, n, i);
  }
  /** @internal */
  _concatOutputChunks(e, r) {
    return this.bound._concatOutputChunks(e, r);
  }
  async *_streamIterator(e, r) {
    yield* this.bound._streamIterator(e, await this._mergeConfig(Se(r), this.kwargs));
  }
  async stream(e, r) {
    return this.bound.stream(e, await this._mergeConfig(Se(r), this.kwargs));
  }
  async *transform(e, r) {
    yield* this.bound.transform(e, await this._mergeConfig(Se(r), this.kwargs));
  }
  streamEvents(e, r, i) {
    const n = this, s = async function* () {
      yield* n.bound.streamEvents(e, {
        ...await n._mergeConfig(Se(r), n.kwargs),
        version: r.version
      }, i);
    };
    return bi.fromAsyncGenerator(s());
  }
  static isRunnableBinding(e) {
    return e.bound && rt.isRunnable(e.bound);
  }
  /**
  * Bind lifecycle listeners to a Runnable, returning a new Runnable.
  * The Run object contains information about the run, including its id,
  * type, input, output, error, startTime, endTime, and any tags or metadata
  * added to the run.
  *
  * @param {Object} params - The object containing the callback functions.
  * @param {(run: Run) => void} params.onStart - Called before the runnable starts running, with the Run object.
  * @param {(run: Run) => void} params.onEnd - Called after the runnable finishes running, with the Run object.
  * @param {(run: Run) => void} params.onError - Called if the runnable throws an error, with the Run object.
  */
  withListeners({ onStart: e, onEnd: r, onError: i }) {
    return new mG({
      bound: this.bound,
      kwargs: this.kwargs,
      config: this.config,
      configFactories: [(n) => ({ callbacks: [new Nx({
        config: n,
        onStart: e,
        onEnd: r,
        onError: i
      })] })]
    });
  }
}, RV = class DG extends rt {
  constructor(e) {
    super(e);
    R(this, "lc_serializable", !0);
    R(this, "lc_namespace", ["langchain_core", "runnables"]);
    R(this, "bound");
    this.bound = e.bound;
  }
  static lc_name() {
    return "RunnableEach";
  }
  /**
  * Invokes the runnable with the specified input and configuration.
  * @param input The input to invoke the runnable with.
  * @param config The configuration to invoke the runnable with.
  * @returns A promise that resolves to the output of the runnable.
  */
  async invoke(e, r) {
    return this._callWithConfig(this._invoke.bind(this), e, r);
  }
  /**
  * A helper method that is used to invoke the runnable with the specified input and configuration.
  * @param input The input to invoke the runnable with.
  * @param config The configuration to invoke the runnable with.
  * @returns A promise that resolves to the output of the runnable.
  */
  async _invoke(e, r, i) {
    return this.bound.batch(e, Ye(r, { callbacks: i == null ? void 0 : i.getChild() }));
  }
  /**
  * Bind lifecycle listeners to a Runnable, returning a new Runnable.
  * The Run object contains information about the run, including its id,
  * type, input, output, error, startTime, endTime, and any tags or metadata
  * added to the run.
  *
  * @param {Object} params - The object containing the callback functions.
  * @param {(run: Run) => void} params.onStart - Called before the runnable starts running, with the Run object.
  * @param {(run: Run) => void} params.onEnd - Called after the runnable finishes running, with the Run object.
  * @param {(run: Run) => void} params.onError - Called if the runnable throws an error, with the Run object.
  */
  withListeners({ onStart: e, onEnd: r, onError: i }) {
    return new DG({ bound: this.bound.withListeners({
      onStart: e,
      onEnd: r,
      onError: i
    }) });
  }
}, gS = class extends Wc {
  constructor(A) {
    super(A);
    R(this, "lc_namespace", ["langchain_core", "runnables"]);
    R(this, "maxAttemptNumber", 3);
    R(this, "onFailedAttempt", () => {
    });
    this.maxAttemptNumber = A.maxAttemptNumber ?? this.maxAttemptNumber, this.onFailedAttempt = A.onFailedAttempt ?? this.onFailedAttempt;
  }
  static lc_name() {
    return "RunnableRetry";
  }
  _patchConfigForRetry(A, e, r) {
    const i = A > 1 ? `retry:attempt:${A}` : void 0;
    return Ye(e, { callbacks: r == null ? void 0 : r.getChild(i) });
  }
  async _invoke(A, e, r) {
    return im((i) => super.invoke(A, this._patchConfigForRetry(i, e, r)), {
      onFailedAttempt: ({ error: i }) => this.onFailedAttempt(i, A),
      retries: Math.max(this.maxAttemptNumber - 1, 0),
      randomize: !0
    });
  }
  /**
  * Method that invokes the runnable with the specified input, run manager,
  * and config. It handles the retry logic by catching any errors and
  * recursively invoking itself with the updated config for the next retry
  * attempt.
  * @param input The input for the runnable.
  * @param runManager The run manager for the runnable.
  * @param config The config for the runnable.
  * @returns A promise that resolves to the output of the runnable.
  */
  async invoke(A, e) {
    return this._callWithConfig(this._invoke.bind(this), A, e);
  }
  async _batch(A, e, r, i) {
    const n = {};
    try {
      await im(async (s) => {
        const a = A.map((c, C) => C).filter((c) => n[c.toString()] === void 0 || n[c.toString()] instanceof Error), g = a.map((c) => A[c]), o = a.map((c) => this._patchConfigForRetry(s, e == null ? void 0 : e[c], r == null ? void 0 : r[c])), u = await super.batch(g, o, {
          ...i,
          returnExceptions: !0
        });
        let I;
        for (let c = 0; c < u.length; c += 1) {
          const C = u[c], E = a[c];
          C instanceof Error && I === void 0 && (I = C, I.input = g[c]), n[E.toString()] = C;
        }
        if (I) throw I;
        return u;
      }, {
        onFailedAttempt: ({ error: s }) => this.onFailedAttempt(s, s.input),
        retries: Math.max(this.maxAttemptNumber - 1, 0),
        randomize: !0
      });
    } catch (s) {
      if ((i == null ? void 0 : i.returnExceptions) !== !0) throw s;
    }
    return Object.keys(n).sort((s, a) => parseInt(s, 10) - parseInt(a, 10)).map((s) => n[parseInt(s, 10)]);
  }
  async batch(A, e, r) {
    return this._batchWithConfig(this._batch.bind(this), A, e, r);
  }
}, TE = class DC extends rt {
  constructor(e) {
    super(e);
    R(this, "first");
    R(this, "middle", []);
    R(this, "last");
    R(this, "omitSequenceTags", !1);
    R(this, "lc_serializable", !0);
    R(this, "lc_namespace", ["langchain_core", "runnables"]);
    this.first = e.first, this.middle = e.middle ?? this.middle, this.last = e.last, this.name = e.name, this.omitSequenceTags = e.omitSequenceTags ?? this.omitSequenceTags;
  }
  static lc_name() {
    return "RunnableSequence";
  }
  get steps() {
    return [
      this.first,
      ...this.middle,
      this.last
    ];
  }
  async invoke(e, r) {
    var o;
    const i = Se(r), n = await Jr(i), s = await (n == null ? void 0 : n.handleChainStart(this.toJSON(), Qt(e, "input"), i.runId, void 0, void 0, void 0, i == null ? void 0 : i.runName));
    delete i.runId;
    let a = e, g;
    try {
      const u = [this.first, ...this.middle];
      for (let I = 0; I < u.length; I += 1) {
        const C = u[I].invoke(a, Ye(i, { callbacks: s == null ? void 0 : s.getChild(this.omitSequenceTags ? void 0 : `seq:step:${I + 1}`) }));
        a = await Bs(C, r == null ? void 0 : r.signal);
      }
      if ((o = r == null ? void 0 : r.signal) != null && o.aborted) throw XC(r.signal);
      g = await this.last.invoke(a, Ye(i, { callbacks: s == null ? void 0 : s.getChild(this.omitSequenceTags ? void 0 : `seq:step:${this.steps.length}`) }));
    } catch (u) {
      throw await (s == null ? void 0 : s.handleChainError(u)), u;
    }
    return await (s == null ? void 0 : s.handleChainEnd(Qt(g, "output"))), g;
  }
  async batch(e, r, i) {
    var o;
    const n = this._getOptionsList(r ?? {}, e.length), s = await Promise.all(n.map(Jr)), a = await Promise.all(s.map(async (u, I) => {
      const c = await (u == null ? void 0 : u.handleChainStart(this.toJSON(), Qt(e[I], "input"), n[I].runId, void 0, void 0, void 0, n[I].runName));
      return delete n[I].runId, c;
    }));
    let g = e;
    try {
      for (let u = 0; u < this.steps.length; u += 1) {
        const c = this.steps[u].batch(g, a.map((C, E) => {
          const l = C == null ? void 0 : C.getChild(this.omitSequenceTags ? void 0 : `seq:step:${u + 1}`);
          return Ye(n[E], { callbacks: l });
        }), i);
        g = await Bs(c, (o = n[0]) == null ? void 0 : o.signal);
      }
    } catch (u) {
      throw await Promise.all(a.map((I) => I == null ? void 0 : I.handleChainError(u))), u;
    }
    return await Promise.all(a.map((u) => u == null ? void 0 : u.handleChainEnd(Qt(g, "output")))), g;
  }
  /** @internal */
  _concatOutputChunks(e, r) {
    return this.last._concatOutputChunks(e, r);
  }
  async *_streamIterator(e, r) {
    var c;
    const i = await Jr(r), { runId: n, ...s } = r ?? {}, a = await (i == null ? void 0 : i.handleChainStart(this.toJSON(), Qt(e, "input"), n, void 0, void 0, void 0, s == null ? void 0 : s.runName)), g = [
      this.first,
      ...this.middle,
      this.last
    ];
    let o = !0, u;
    async function* I() {
      yield e;
    }
    try {
      let C = g[0].transform(I(), Ye(s, { callbacks: a == null ? void 0 : a.getChild(this.omitSequenceTags ? void 0 : "seq:step:1") }));
      for (let E = 1; E < g.length; E += 1)
        C = await g[E].transform(C, Ye(s, { callbacks: a == null ? void 0 : a.getChild(this.omitSequenceTags ? void 0 : `seq:step:${E + 1}`) }));
      for await (const E of C)
        if ((c = r == null ? void 0 : r.signal) == null || c.throwIfAborted(), yield E, o) if (u === void 0) u = E;
        else try {
          u = this._concatOutputChunks(u, E);
        } catch {
          u = void 0, o = !1;
        }
    } catch (C) {
      throw await (a == null ? void 0 : a.handleChainError(C)), C;
    }
    await (a == null ? void 0 : a.handleChainEnd(Qt(u, "output")));
  }
  getGraph(e) {
    const r = new oS();
    let i = null;
    return this.steps.forEach((n, s) => {
      const a = n.getGraph(e);
      s !== 0 && a.trimFirstNode(), s !== this.steps.length - 1 && a.trimLastNode(), r.extend(a);
      const g = a.firstNode();
      if (!g) throw new Error(`Runnable ${n} has no first node`);
      i && r.addEdge(i, g), i = a.lastNode();
    }), r;
  }
  pipe(e) {
    return DC.isRunnableSequence(e) ? new DC({
      first: this.first,
      middle: this.middle.concat([
        this.last,
        e.first,
        ...e.middle
      ]),
      last: e.last,
      name: this.name ?? e.name
    }) : new DC({
      first: this.first,
      middle: [...this.middle, this.last],
      last: ki(e),
      name: this.name
    });
  }
  static isRunnableSequence(e) {
    return Array.isArray(e.middle) && rt.isRunnable(e);
  }
  static from([e, ...r], i) {
    let n = {};
    return typeof i == "string" ? n.name = i : i !== void 0 && (n = i), new DC({
      ...n,
      first: ki(e),
      middle: r.slice(0, -1).map(ki),
      last: ki(r[r.length - 1])
    });
  }
}, uI = class SG extends rt {
  constructor(e) {
    super(e);
    R(this, "lc_namespace", ["langchain_core", "runnables"]);
    R(this, "lc_serializable", !0);
    R(this, "steps");
    this.steps = {};
    for (const [r, i] of Object.entries(e.steps)) this.steps[r] = ki(i);
  }
  static lc_name() {
    return "RunnableMap";
  }
  getStepsKeys() {
    return Object.keys(this.steps);
  }
  static from(e) {
    return new SG({ steps: e });
  }
  async invoke(e, r) {
    const i = Se(r), n = await Jr(i), s = await (n == null ? void 0 : n.handleChainStart(this.toJSON(), { input: e }, i.runId, void 0, void 0, void 0, i == null ? void 0 : i.runName));
    delete i.runId;
    const a = {};
    try {
      const g = Object.entries(this.steps).map(async ([o, u]) => {
        a[o] = await u.invoke(e, Ye(i, { callbacks: s == null ? void 0 : s.getChild(`map:key:${o}`) }));
      });
      await Bs(Promise.all(g), r == null ? void 0 : r.signal);
    } catch (g) {
      throw await (s == null ? void 0 : s.handleChainError(g)), g;
    }
    return await (s == null ? void 0 : s.handleChainEnd(a)), a;
  }
  async *_transform(e, r, i) {
    const n = { ...this.steps }, s = W0(e, Object.keys(n).length), a = new Map(Object.entries(n).map(([g, o], u) => {
      const I = o.transform(s[u], Ye(i, { callbacks: r == null ? void 0 : r.getChild(`map:key:${g}`) }));
      return [g, I.next().then((c) => ({
        key: g,
        gen: I,
        result: c
      }))];
    }));
    for (; a.size; ) {
      const g = Promise.race(a.values()), { key: o, result: u, gen: I } = await Bs(g, i == null ? void 0 : i.signal);
      a.delete(o), u.done || (yield { [o]: u.value }, a.set(o, I.next().then((c) => ({
        key: o,
        gen: I,
        result: c
      }))));
    }
  }
  transform(e, r) {
    return this._transformStreamWithConfig(e, this._transform.bind(this), r);
  }
  async stream(e, r) {
    async function* i() {
      yield e;
    }
    const n = Se(r), s = new mg({
      generator: this.transform(i(), n),
      config: n
    });
    return await s.setup, bi.fromAsyncGenerator(s);
  }
}, bV = class FG extends rt {
  constructor(e) {
    super(e);
    R(this, "lc_serializable", !1);
    R(this, "lc_namespace", ["langchain_core", "runnables"]);
    R(this, "func");
    if (!j0(e.func)) throw new Error("RunnableTraceable requires a function that is wrapped in traceable higher-order function");
    this.func = e.func;
  }
  async invoke(e, r) {
    const [i] = this._getOptionsList(r ?? {}, 1), n = await Jr(i), s = this.func(Ye(i, { callbacks: n }), e);
    return Bs(s, i == null ? void 0 : i.signal);
  }
  async *_streamIterator(e, r) {
    var s, a;
    const [i] = this._getOptionsList(r ?? {}, 1), n = await this.invoke(e, r);
    if (hm(n)) {
      for await (const g of n)
        (s = i == null ? void 0 : i.signal) == null || s.throwIfAborted(), yield g;
      return;
    }
    if (vV(n)) {
      for (; ; ) {
        (a = i == null ? void 0 : i.signal) == null || a.throwIfAborted();
        const g = n.next();
        if (g.done) break;
        yield g.value;
      }
      return;
    }
    yield n;
  }
  static from(e) {
    return new FG({ func: e });
  }
};
function MV(t) {
  if (j0(t)) throw new Error("RunnableLambda requires a function that is not wrapped in traceable higher-order function. This shouldn't happen.");
}
var ps = class kG extends rt {
  constructor(e) {
    if (j0(e.func)) return bV.from(e.func);
    super(e);
    R(this, "lc_namespace", ["langchain_core", "runnables"]);
    R(this, "func");
    MV(e.func), this.func = e.func;
  }
  static lc_name() {
    return "RunnableLambda";
  }
  static from(e) {
    return new kG({ func: e });
  }
  async _invoke(e, r, i) {
    return new Promise((n, s) => {
      const a = Ye(r, {
        callbacks: i == null ? void 0 : i.getChild(),
        recursionLimit: ((r == null ? void 0 : r.recursionLimit) ?? Iy) - 1
      });
      Ri.runWithConfig(ls(a), async () => {
        var g, o;
        try {
          let u = await this.func(e, { ...a });
          if (u && rt.isRunnable(u)) {
            if ((r == null ? void 0 : r.recursionLimit) === 0) throw new Error("Recursion limit reached.");
            u = await u.invoke(e, {
              ...a,
              recursionLimit: (a.recursionLimit ?? Iy) - 1
            });
          } else if (hm(u)) {
            let I;
            for await (const c of Qm(a, u))
              if ((g = r == null ? void 0 : r.signal) == null || g.throwIfAborted(), I === void 0) I = c;
              else try {
                I = this._concatOutputChunks(I, c);
              } catch {
                I = c;
              }
            u = I;
          } else if (yv(u)) {
            let I;
            for (const c of wv(a, u))
              if ((o = r == null ? void 0 : r.signal) == null || o.throwIfAborted(), I === void 0) I = c;
              else try {
                I = this._concatOutputChunks(I, c);
              } catch {
                I = c;
              }
            u = I;
          }
          n(u);
        } catch (u) {
          s(u);
        }
      });
    });
  }
  async invoke(e, r) {
    return this._callWithConfig(this._invoke.bind(this), e, r);
  }
  async *_transform(e, r, i) {
    var g, o;
    let n;
    for await (const u of e) if (n === void 0) n = u;
    else try {
      n = this._concatOutputChunks(n, u);
    } catch {
      n = u;
    }
    const s = Ye(i, {
      callbacks: r == null ? void 0 : r.getChild(),
      recursionLimit: ((i == null ? void 0 : i.recursionLimit) ?? Iy) - 1
    }), a = await new Promise((u, I) => {
      Ri.runWithConfig(ls(s), async () => {
        try {
          const c = await this.func(n, {
            ...s,
            config: s
          });
          u(c);
        } catch (c) {
          I(c);
        }
      });
    });
    if (a && rt.isRunnable(a)) {
      if ((i == null ? void 0 : i.recursionLimit) === 0) throw new Error("Recursion limit reached.");
      const u = await a.stream(n, s);
      for await (const I of u) yield I;
    } else if (hm(a)) for await (const u of Qm(s, a))
      (g = i == null ? void 0 : i.signal) == null || g.throwIfAborted(), yield u;
    else if (yv(a)) for (const u of wv(s, a))
      (o = i == null ? void 0 : i.signal) == null || o.throwIfAborted(), yield u;
    else yield a;
  }
  transform(e, r) {
    return this._transformStreamWithConfig(e, this._transform.bind(this), r);
  }
  async stream(e, r) {
    async function* i() {
      yield e;
    }
    const n = Se(r), s = new mg({
      generator: this.transform(i(), n),
      config: n
    });
    return await s.setup, bi.fromAsyncGenerator(s);
  }
}, _V = class extends uI {
}, vG = class extends rt {
  constructor(A) {
    super(A);
    R(this, "lc_namespace", ["langchain_core", "runnables"]);
    R(this, "lc_serializable", !0);
    R(this, "runnable");
    R(this, "fallbacks");
    this.runnable = A.runnable, this.fallbacks = A.fallbacks;
  }
  static lc_name() {
    return "RunnableWithFallbacks";
  }
  *runnables() {
    yield this.runnable;
    for (const A of this.fallbacks) yield A;
  }
  async invoke(A, e) {
    const r = Se(e), i = await Jr(r), { runId: n, ...s } = r, a = await (i == null ? void 0 : i.handleChainStart(this.toJSON(), Qt(A, "input"), n, void 0, void 0, void 0, s == null ? void 0 : s.runName)), g = Ye(s, { callbacks: a == null ? void 0 : a.getChild() });
    return await Ri.runWithConfig(g, async () => {
      var I;
      let u;
      for (const c of this.runnables()) {
        (I = r == null ? void 0 : r.signal) == null || I.throwIfAborted();
        try {
          const C = await c.invoke(A, g);
          return await (a == null ? void 0 : a.handleChainEnd(Qt(C, "output"))), C;
        } catch (C) {
          u === void 0 && (u = C);
        }
      }
      throw u === void 0 ? new Error("No error stored at end of fallback.") : (await (a == null ? void 0 : a.handleChainError(u)), u);
    });
  }
  async *_streamIterator(A, e) {
    var I;
    const r = Se(e), i = await Jr(r), { runId: n, ...s } = r, a = await (i == null ? void 0 : i.handleChainStart(this.toJSON(), Qt(A, "input"), n, void 0, void 0, void 0, s == null ? void 0 : s.runName));
    let g, o;
    for (const c of this.runnables()) {
      (I = r == null ? void 0 : r.signal) == null || I.throwIfAborted();
      const C = Ye(s, { callbacks: a == null ? void 0 : a.getChild() });
      try {
        const E = await c.stream(A, C);
        o = Qm(C, E);
        break;
      } catch (E) {
        g === void 0 && (g = E);
      }
    }
    if (o === void 0) {
      const c = g ?? /* @__PURE__ */ new Error("No error stored at end of fallback.");
      throw await (a == null ? void 0 : a.handleChainError(c)), c;
    }
    let u;
    try {
      for await (const c of o) {
        yield c;
        try {
          u = u === void 0 ? u : this._concatOutputChunks(u, c);
        } catch {
          u = void 0;
        }
      }
    } catch (c) {
      throw await (a == null ? void 0 : a.handleChainError(c)), c;
    }
    await (a == null ? void 0 : a.handleChainEnd(Qt(u, "output")));
  }
  async batch(A, e, r) {
    var g;
    if (r != null && r.returnExceptions) throw new Error("Not implemented.");
    const i = this._getOptionsList(e ?? {}, A.length), n = await Promise.all(i.map((o) => Jr(o))), s = await Promise.all(n.map(async (o, u) => {
      const I = await (o == null ? void 0 : o.handleChainStart(this.toJSON(), Qt(A[u], "input"), i[u].runId, void 0, void 0, void 0, i[u].runName));
      return delete i[u].runId, I;
    }));
    let a;
    for (const o of this.runnables()) {
      (g = i[0].signal) == null || g.throwIfAborted();
      try {
        const u = await o.batch(A, s.map((I, c) => Ye(i[c], { callbacks: I == null ? void 0 : I.getChild() })), r);
        return await Promise.all(s.map((I, c) => I == null ? void 0 : I.handleChainEnd(Qt(u[c], "output")))), u;
      } catch (u) {
        a === void 0 && (a = u);
      }
    }
    throw a ? (await Promise.all(s.map((o) => o == null ? void 0 : o.handleChainError(a))), a) : new Error("No error stored at end of fallbacks.");
  }
};
function ki(t) {
  if (typeof t == "function") return new ps({ func: t });
  if (rt.isRunnable(t)) return t;
  if (!Array.isArray(t) && typeof t == "object") {
    const A = {};
    for (const [e, r] of Object.entries(t)) A[e] = ki(r);
    return new uI({ steps: A });
  } else throw new Error(`Expected a Runnable, function or object.
Instead got an unsupported type.`);
}
var uS = class extends rt {
  constructor(A) {
    A instanceof uI && (A = { mapper: A });
    super(A);
    R(this, "lc_namespace", ["langchain_core", "runnables"]);
    R(this, "lc_serializable", !0);
    R(this, "mapper");
    this.mapper = A.mapper;
  }
  static lc_name() {
    return "RunnableAssign";
  }
  async invoke(A, e) {
    const r = await this.mapper.invoke(A, e);
    return {
      ...A,
      ...r
    };
  }
  async *_transform(A, e, r) {
    const i = this.mapper.getStepsKeys(), [n, s] = W0(A), a = this.mapper.transform(s, Ye(r, { callbacks: e == null ? void 0 : e.getChild() })), g = a.next();
    for await (const o of n) {
      if (typeof o != "object" || Array.isArray(o)) throw new Error(`RunnableAssign can only be used with objects as input, got ${typeof o}`);
      const u = Object.fromEntries(Object.entries(o).filter(([I]) => !i.includes(I)));
      Object.keys(u).length > 0 && (yield u);
    }
    yield (await g).value;
    for await (const o of a) yield o;
  }
  transform(A, e) {
    return this._transformStreamWithConfig(A, this._transform.bind(this), e);
  }
  async stream(A, e) {
    async function* r() {
      yield A;
    }
    const i = Se(e), n = new mg({
      generator: this.transform(r(), i),
      config: i
    });
    return await n.setup, bi.fromAsyncGenerator(n);
  }
}, RG = class extends rt {
  constructor(A) {
    (typeof A == "string" || Array.isArray(A)) && (A = { keys: A });
    super(A);
    R(this, "lc_namespace", ["langchain_core", "runnables"]);
    R(this, "lc_serializable", !0);
    R(this, "keys");
    this.keys = A.keys;
  }
  static lc_name() {
    return "RunnablePick";
  }
  async _pick(A) {
    if (typeof this.keys == "string") return A[this.keys];
    {
      const e = this.keys.map((r) => [r, A[r]]).filter((r) => r[1] !== void 0);
      return e.length === 0 ? void 0 : Object.fromEntries(e);
    }
  }
  async invoke(A, e) {
    return this._callWithConfig(this._pick.bind(this), A, e);
  }
  async *_transform(A) {
    for await (const e of A) {
      const r = await this._pick(e);
      r !== void 0 && (yield r);
    }
  }
  transform(A, e) {
    return this._transformStreamWithConfig(A, this._transform.bind(this), e);
  }
  async stream(A, e) {
    async function* r() {
      yield A;
    }
    const i = Se(e), n = new mg({
      generator: this.transform(r(), i),
      config: i
    });
    return await n.setup, bi.fromAsyncGenerator(n);
  }
}, dm = class extends Wc {
  constructor(A) {
    const e = TE.from([ps.from(async (r) => {
      let i;
      if (xC(r)) try {
        i = await op(this.schema, r.args);
      } catch {
        throw new dd("Received tool input did not match expected schema", JSON.stringify(r.args));
      }
      else i = r;
      return i;
    }).withConfig({ runName: `${A.name}:parse_input` }), A.bound]).withConfig({ runName: A.name });
    super({
      bound: e,
      config: A.config ?? {}
    });
    R(this, "name");
    R(this, "description");
    R(this, "schema");
    this.name = A.name, this.description = A.description, this.schema = A.schema;
  }
  static lc_name() {
    return "RunnableToolLike";
  }
};
function NV(t, A) {
  const e = A.name ?? t.getName(), r = A.description ?? gp(A.schema);
  return iS(A.schema) ? new dm({
    name: e,
    description: r,
    schema: Ip({ input: cp() }).transform((i) => i.input),
    bound: t
  }) : new dm({
    name: e,
    description: r,
    schema: A.schema,
    bound: t
  });
}
const Gd = (t, A) => {
  const e = [...new Set(A == null ? void 0 : A.map((i) => {
    if (typeof i == "string") return i;
    const n = new i({});
    if (!("getType" in n) || typeof n.getType != "function") throw new Error("Invalid type provided.");
    return n.getType();
  }))], r = t.getType();
  return e.some((i) => i === r);
};
function LV(t, A) {
  return Array.isArray(t) ? mv(t, A) : ps.from((e) => mv(e, t));
}
function mv(t, A = {}) {
  const { includeNames: e, excludeNames: r, includeTypes: i, excludeTypes: n, includeIds: s, excludeIds: a } = A, g = [];
  for (const o of t)
    if (!(r && o.name && r.includes(o.name))) {
      {
        if (n && Gd(o, n)) continue;
        if (a && o.id && a.includes(o.id)) continue;
      }
      i || s || e ? (e && o.name && e.some((u) => u === o.name) || i && Gd(o, i) || s && o.id && s.some((u) => u === o.id)) && g.push(o) : g.push(o);
    }
  return g;
}
function xV(t) {
  return Array.isArray(t) ? Dv(t) : ps.from(Dv);
}
function Dv(t) {
  if (!t.length) return [];
  const A = [];
  for (const e of t) {
    const r = e, i = A.pop();
    if (!i) A.push(r);
    else if (r.getType() === "tool" || r.getType() !== i.getType()) A.push(i, r);
    else {
      const n = fd(i), s = fd(r), a = n.concat(s);
      typeof n.content == "string" && typeof s.content == "string" && (a.content = `${n.content}
${s.content}`), A.push(TV(a));
    }
  }
  return A;
}
function GV(t, A) {
  if (Array.isArray(t)) {
    const e = t;
    if (!A) throw new Error("Options parameter is required when providing messages.");
    return Sv(e, A);
  } else {
    const e = t;
    return ps.from((r) => Sv(r, e)).withConfig({ runName: "trim_messages" });
  }
}
async function Sv(t, A) {
  const { maxTokens: e, tokenCounter: r, strategy: i = "last", allowPartial: n = !1, endOn: s, startOn: a, includeSystem: g = !1, textSplitter: o } = A;
  if (a && i === "first") throw new Error("`startOn` should only be specified if `strategy` is 'last'.");
  if (g && i === "first") throw new Error("`includeSystem` should only be specified if `strategy` is 'last'.");
  let u;
  "getNumTokens" in r ? u = async (c) => (await Promise.all(c.map((E) => r.getNumTokens(E.content)))).reduce((E, l) => E + l, 0) : u = async (c) => r(c);
  let I = MG;
  if (o && ("splitText" in o ? I = o.splitText : I = async (c) => o(c)), i === "first") return bG(t, {
    maxTokens: e,
    tokenCounter: u,
    textSplitter: I,
    partialStrategy: n ? "first" : void 0,
    endOn: s
  });
  if (i === "last") return UV(t, {
    maxTokens: e,
    tokenCounter: u,
    textSplitter: I,
    allowPartial: n,
    includeSystem: g,
    startOn: a,
    endOn: s
  });
  throw new Error(`Unrecognized strategy: '${i}'. Must be one of 'first' or 'last'.`);
}
async function bG(t, A) {
  const { maxTokens: e, tokenCounter: r, textSplitter: i, partialStrategy: n, endOn: s } = A;
  let a = [...t], g = 0;
  for (let o = 0; o < a.length; o += 1) {
    const u = o > 0 ? a.slice(0, -o) : a;
    if (await r(u) <= e) {
      g = a.length - o;
      break;
    }
  }
  if (g < a.length && n) {
    let o = !1;
    if (Array.isArray(a[g].content)) {
      const u = a[g];
      if (typeof u.content == "string") throw new Error("Expected content to be an array.");
      const I = u.content.length, c = n === "last" ? [...u.content].reverse() : u.content;
      for (let C = 1; C <= I; C += 1) {
        const E = n === "first" ? c.slice(0, C) : c.slice(-C), l = Object.fromEntries(Object.entries(u).filter(([Q]) => Q !== "type" && !Q.startsWith("lc_"))), B = cS(u.getType(), {
          ...l,
          content: E
        }), h = [...a.slice(0, g), B];
        if (await r(h) <= e)
          a = h, g += 1, o = !0;
        else break;
      }
      o && n === "last" && (u.content = [...c].reverse());
    }
    if (!o) {
      const u = a[g];
      let I;
      if (Array.isArray(u.content) && u.content.some((c) => typeof c == "string" || c.type === "text")) {
        const c = u.content.find((C) => C.type === "text" && C.text);
        I = c == null ? void 0 : c.text;
      } else typeof u.content == "string" && (I = u.content);
      if (I) {
        const c = await i(I), C = c.length;
        n === "last" && c.reverse();
        for (let E = 0; E < C - 1; E += 1)
          if (c.pop(), u.content = c.join(""), await r([...a.slice(0, g), u]) <= e) {
            n === "last" && (u.content = [...c].reverse().join("")), a = [...a.slice(0, g), u], g += 1;
            break;
          }
      }
    }
  }
  if (s) {
    const o = Array.isArray(s) ? s : [s];
    for (; g > 0 && !Gd(a[g - 1], o); ) g -= 1;
  }
  return a.slice(0, g);
}
async function UV(t, A) {
  var u;
  const { allowPartial: e = !1, includeSystem: r = !1, endOn: i, startOn: n, ...s } = A;
  let a = t.map((I) => {
    const c = Object.fromEntries(Object.entries(I).filter(([C]) => C !== "type" && !C.startsWith("lc_")));
    return cS(I.getType(), c, S0(I));
  });
  if (i) {
    const I = Array.isArray(i) ? i : [i];
    for (; a.length > 0 && !Gd(a[a.length - 1], I); ) a = a.slice(0, -1);
  }
  const g = r && ((u = a[0]) == null ? void 0 : u.getType()) === "system";
  let o = g ? a.slice(0, 1).concat(a.slice(1).reverse()) : a.reverse();
  return o = await bG(o, {
    ...s,
    partialStrategy: e ? "last" : void 0,
    endOn: n
  }), g ? [o[0], ...o.slice(1).reverse()] : o.reverse();
}
const Fv = {
  human: {
    message: Tr,
    messageChunk: NE
  },
  ai: {
    message: jt,
    messageChunk: kn
  },
  system: {
    message: Zr,
    messageChunk: Ma
  },
  developer: {
    message: Zr,
    messageChunk: Ma
  },
  tool: {
    message: fn,
    messageChunk: bE
  },
  function: {
    message: Pf,
    messageChunk: _E
  },
  generic: {
    message: wg,
    messageChunk: ME
  },
  remove: {
    message: Qd,
    messageChunk: Qd
  }
};
function cS(t, A, e) {
  var n;
  let r, i;
  switch (t) {
    case "human":
      e ? r = new NE(A) : i = new Tr(A);
      break;
    case "ai":
      if (e) {
        let s = { ...A };
        "tool_calls" in s && (s = {
          ...s,
          tool_call_chunks: (n = s.tool_calls) == null ? void 0 : n.map((a) => ({
            ...a,
            type: "tool_call_chunk",
            index: void 0,
            args: JSON.stringify(a.args)
          }))
        }), r = new kn(s);
      } else i = new jt(A);
      break;
    case "system":
      e ? r = new Ma(A) : i = new Zr(A);
      break;
    case "developer":
      e ? r = new Ma({
        ...A,
        additional_kwargs: {
          ...A.additional_kwargs,
          __openai_role__: "developer"
        }
      }) : i = new Zr({
        ...A,
        additional_kwargs: {
          ...A.additional_kwargs,
          __openai_role__: "developer"
        }
      });
      break;
    case "tool":
      if ("tool_call_id" in A) e ? r = new bE(A) : i = new fn(A);
      else throw new Error("Can not convert ToolMessage to ToolMessageChunk if 'tool_call_id' field is not defined.");
      break;
    case "function":
      if (e) r = new _E(A);
      else {
        if (!A.name) throw new Error("FunctionMessage must have a 'name' field");
        i = new Pf(A);
      }
      break;
    case "generic":
      if ("role" in A) e ? r = new ME(A) : i = new wg(A);
      else throw new Error("Can not convert ChatMessage to ChatMessageChunk if 'role' field is not defined.");
      break;
    default:
      throw new Error(`Unrecognized message type ${t}`);
  }
  if (e && r) return r;
  if (i) return i;
  throw new Error(`Unrecognized message type ${t}`);
}
function TV(t) {
  const A = t.getType();
  let e;
  const r = Object.fromEntries(Object.entries(t).filter(([i]) => !["type", "tool_call_chunks"].includes(i) && !i.startsWith("lc_")));
  if (A in Fv && (e = cS(A, r)), !e) throw new Error(`Unrecognized message chunk class ${A}. Supported classes are ${Object.keys(Fv)}`);
  return e;
}
function MG(t) {
  const A = t.split(`
`);
  return Promise.resolve([...A.slice(0, -1).map((e) => `${e}
`), A[A.length - 1]]);
}
const KV = [
  "tool_call",
  "tool_call_chunk",
  "invalid_tool_call",
  "server_tool_call",
  "server_tool_call_chunk",
  "server_tool_call_result"
], JV = [
  "image",
  "video",
  "audio",
  "text-plain",
  "file"
], HV = [
  "text",
  "reasoning",
  ...KV,
  ...JV
];
var PV = {};
fe(PV, {
  AIMessage: () => jt,
  AIMessageChunk: () => kn,
  BaseMessage: () => fs,
  BaseMessageChunk: () => Ga,
  ChatMessage: () => wg,
  ChatMessageChunk: () => ME,
  FunctionMessage: () => Pf,
  FunctionMessageChunk: () => _E,
  HumanMessage: () => Tr,
  HumanMessageChunk: () => NE,
  KNOWN_BLOCK_TYPES: () => HV,
  RemoveMessage: () => Qd,
  SystemMessage: () => Zr,
  SystemMessageChunk: () => Ma,
  ToolMessage: () => fn,
  ToolMessageChunk: () => bE,
  _isMessageFieldWithRole: () => DL,
  _mergeDicts: () => zt,
  _mergeLists: () => RE,
  _mergeObj: () => wL,
  _mergeStatus: () => yL,
  coerceMessageLikeToMessage: () => GC,
  collapseToolCallChunks: () => LL,
  convertToChunk: () => fd,
  convertToOpenAIImageBlock: () => CL,
  convertToProviderContentBlock: () => p0,
  defaultTextSplitter: () => MG,
  defaultToolCallParser: () => k0,
  filterMessages: () => LV,
  getBufferString: () => R0,
  iife: () => NL,
  isAIMessage: () => Yf,
  isAIMessageChunk: () => Pw,
  isBase64ContentBlock: () => f0,
  isBaseMessage: () => wa,
  isBaseMessageChunk: () => S0,
  isChatMessage: () => _P,
  isChatMessageChunk: () => NP,
  isDataContentBlock: () => dn,
  isDirectToolOutput: () => F0,
  isFunctionMessage: () => LP,
  isFunctionMessageChunk: () => xP,
  isHumanMessage: () => GP,
  isHumanMessageChunk: () => UP,
  isIDContentBlock: () => IL,
  isMessage: () => lL,
  isOpenAIToolCallArray: () => vP,
  isPlainTextContentBlock: () => AP,
  isSystemMessage: () => TP,
  isSystemMessageChunk: () => KP,
  isToolMessage: () => vL,
  isToolMessageChunk: () => RL,
  isURLContentBlock: () => d0,
  mapChatMessagesToStoredMessages: () => $P,
  mapStoredMessageToChatMessage: () => b0,
  mapStoredMessagesToChatMessages: () => zP,
  mergeContent: () => Cs,
  mergeMessageRuns: () => xV,
  mergeResponseMetadata: () => SL,
  mergeUsageMetadata: () => kL,
  parseBase64DataUrl: () => jC,
  parseMimeType: () => Jw,
  trimMessages: () => GV
});
const cg = (t) => t();
function KE(t) {
  return t ? !!(/^o\d/.test(t ?? "") || t.startsWith("gpt-5") && !t.startsWith("gpt-5-chat")) : !1;
}
function OV(t) {
  return t.role !== "system" && t.role !== "developer" && t.role !== "assistant" && t.role !== "user" && t.role !== "function" && t.role !== "tool" && console.warn(`Unknown message role: ${t.role}`), t.role;
}
function JE(t) {
  const A = t._getType();
  switch (A) {
    case "system":
      return "system";
    case "ai":
      return "assistant";
    case "human":
      return "user";
    case "function":
      return "function";
    case "tool":
      return "tool";
    case "generic":
      if (!wg.isInstance(t)) throw new Error("Invalid generic chat message");
      return OV(t);
    default:
      throw new Error(`Unknown message type: ${A}`);
  }
}
function YV(t) {
  const { azureOpenAIApiDeploymentName: A, azureOpenAIApiInstanceName: e, azureOpenAIApiKey: r, azureOpenAIBasePath: i, baseURL: n, azureADTokenProvider: s, azureOpenAIEndpoint: a } = t;
  if ((r || s) && i && A) return `${i}/${A}`;
  if ((r || s) && a && A) return `${a}/openai/deployments/${A}`;
  if (r || s) {
    if (!e) throw new Error("azureOpenAIApiInstanceName is required when using azureOpenAIApiKey");
    if (!A) throw new Error("azureOpenAIApiDeploymentName is a required parameter when using azureOpenAIApiKey");
    return `https://${e}.openai.azure.com/openai/deployments/${A}`;
  }
  return n;
}
function kv(t) {
  return typeof Headers < "u" && t !== null && typeof t == "object" && Object.prototype.toString.call(t) === "[object Headers]";
}
function qV(t) {
  const A = cg(() => {
    if (kv(t)) return t;
    if (Array.isArray(t)) return new Headers(t);
    if (typeof t == "object" && t !== null && "values" in t && kv(t.values)) return t.values;
    if (typeof t == "object" && t !== null) {
      const e = Object.entries(t).filter(([, r]) => typeof r == "string").map(([r, i]) => [r, i]);
      return new Headers(e);
    }
    return new Headers();
  });
  return Object.fromEntries(A.entries());
}
function jV() {
  let t = M0();
  return (t === "node" || t === "deno") && (t = `(${t}/${process.version}; ${process.platform}; ${process.arch})`), t;
}
function WV(t, A = !1, e = "1.0.0") {
  const r = qV(t), i = jV(), n = `langchainjs${A ? "-azure" : ""}-openai`;
  return {
    ...r,
    "User-Agent": r["User-Agent"] ? `${n}/${e} (${i})${r["User-Agent"]}` : `${n}/${e} (${i})`
  };
}
function IS(t) {
  return t !== void 0 && Array.isArray(t.lc_namespace);
}
function CS(t) {
  return t !== void 0 && rt.isRunnable(t) && "lc_name" in t.constructor && typeof t.constructor.lc_name == "function" && t.constructor.lc_name() === "RunnableToolLike";
}
function lS(t) {
  return !!t && typeof t == "object" && "name" in t && "schema" in t && (In(t.schema) || t.schema != null && typeof t.schema == "object" && "type" in t.schema && typeof t.schema.type == "string" && [
    "null",
    "boolean",
    "object",
    "array",
    "number",
    "string"
  ].includes(t.schema.type));
}
function Cp(t) {
  return lS(t) || CS(t) || IS(t);
}
var VV = {};
fe(VV, {
  convertToOpenAIFunction: () => _G,
  convertToOpenAITool: () => NG,
  isLangChainTool: () => Cp,
  isRunnableToolLike: () => CS,
  isStructuredTool: () => IS,
  isStructuredToolParams: () => lS
});
function _G(t, A) {
  const e = typeof A == "number" ? void 0 : A;
  return {
    name: t.name,
    description: t.description,
    parameters: Cn(t.schema),
    ...(e == null ? void 0 : e.strict) !== void 0 ? { strict: e.strict } : {}
  };
}
function NG(t, A) {
  const e = typeof A == "number" ? void 0 : A;
  let r;
  return Cp(t) ? r = {
    type: "function",
    function: _G(t)
  } : r = t, (e == null ? void 0 : e.strict) !== void 0 && (r.function.strict = e.strict), r;
}
var ZV = {};
fe(ZV, {
  extendInteropZodObject: () => F5,
  getInteropZodDefaultGetter: () => v5,
  getInteropZodObjectShape: () => am,
  getSchemaDescription: () => gp,
  interopParse: () => m5,
  interopParseAsync: () => op,
  interopSafeParse: () => w5,
  interopSafeParseAsync: () => aG,
  interopZodObjectMakeFieldsOptional: () => M5,
  interopZodObjectPartial: () => k5,
  interopZodObjectPassthrough: () => om,
  interopZodObjectStrict: () => Rd,
  interopZodTransformInputSchema: () => uG,
  isInteropZodError: () => cG,
  isInteropZodLiteral: () => y5,
  isInteropZodObject: () => S5,
  isInteropZodSchema: () => In,
  isShapelessZodSchema: () => D5,
  isSimpleStringZodSchema: () => iS,
  isZodArrayV4: () => up,
  isZodLiteralV3: () => nG,
  isZodLiteralV4: () => sG,
  isZodNullableV4: () => gG,
  isZodObjectV3: () => nS,
  isZodObjectV4: () => Qn,
  isZodOptionalV4: () => oG,
  isZodSchema: () => p5,
  isZodSchemaV3: () => Ct,
  isZodSchemaV4: () => Ze
});
function XV(t, A) {
  let e;
  return Cp(t) ? e = NG(t) : e = t, (A == null ? void 0 : A.strict) !== void 0 && (e.function.strict = A.strict), e;
}
function zV(t) {
  return t.anyOf !== void 0 && Array.isArray(t.anyOf);
}
function $V(t) {
  const A = ["namespace functions {", ""];
  for (const e of t)
    e.description && A.push(`// ${e.description}`), Object.keys(e.parameters.properties ?? {}).length > 0 ? (A.push(`type ${e.name} = (_: {`), A.push(LG(e.parameters, 0)), A.push("}) => any;")) : A.push(`type ${e.name} = () => any;`), A.push("");
  return A.push("} // namespace functions"), A.join(`
`);
}
function LG(t, A) {
  var r;
  const e = [];
  for (const [i, n] of Object.entries(t.properties ?? {}))
    n.description && A < 2 && e.push(`// ${n.description}`), (r = t.required) != null && r.includes(i) ? e.push(`${i}: ${Ud(n, A)},`) : e.push(`${i}?: ${Ud(n, A)},`);
  return e.map((i) => " ".repeat(A) + i).join(`
`);
}
function Ud(t, A) {
  if (zV(t)) return t.anyOf.map((e) => Ud(e, A)).join(" | ");
  switch (t.type) {
    case "string":
      return t.enum ? t.enum.map((e) => `"${e}"`).join(" | ") : "string";
    case "number":
      return t.enum ? t.enum.map((e) => `${e}`).join(" | ") : "number";
    case "integer":
      return t.enum ? t.enum.map((e) => `${e}`).join(" | ") : "number";
    case "boolean":
      return "boolean";
    case "null":
      return "null";
    case "object":
      return [
        "{",
        LG(t, A + 2),
        "}"
      ].join(`
`);
    case "array":
      return t.items ? `${Ud(t.items, A)}[]` : "any[]";
    default:
      return "";
  }
}
function xG(t) {
  if (t) return t === "any" || t === "required" ? "required" : t === "auto" ? "auto" : t === "none" ? "none" : typeof t == "string" ? {
    type: "function",
    function: { name: t }
  } : t;
}
function BS(t) {
  return "type" in t && t.type !== "function";
}
function A9(t) {
  return t != null && typeof t == "object" && "type" in t && t.type !== "function";
}
function Td(t) {
  return typeof t == "object" && t !== null && "metadata" in t && typeof t.metadata == "object" && t.metadata !== null && "customTool" in t.metadata && typeof t.metadata.customTool == "object" && t.metadata.customTool !== null;
}
function GG(t) {
  return "type" in t && t.type === "custom" && "custom" in t && typeof t.custom == "object" && t.custom !== null;
}
function e9(t) {
  if (t.type === "custom_tool_call")
    return {
      ...t,
      type: "tool_call",
      call_id: t.id,
      id: t.call_id,
      name: t.name,
      isCustomTool: !0,
      args: { input: t.input }
    };
}
function t9(t) {
  return t.type === "tool_call" && "isCustomTool" in t && t.isCustomTool === !0;
}
function r9(t) {
  const A = () => {
    if (t.custom.format) {
      if (t.custom.format.type === "grammar") return {
        type: "grammar",
        definition: t.custom.format.grammar.definition,
        syntax: t.custom.format.grammar.syntax
      };
      if (t.custom.format.type === "text") return { type: "text" };
    }
  };
  return {
    type: "custom",
    name: t.custom.name,
    description: t.custom.description,
    format: A()
  };
}
function i9(t) {
  const A = () => {
    if (t.format) {
      if (t.format.type === "grammar") return {
        type: "grammar",
        grammar: {
          definition: t.format.definition,
          syntax: t.format.syntax
        }
      };
      if (t.format.type === "text") return { type: "text" };
    }
  };
  return {
    type: "custom",
    custom: {
      name: t.name,
      description: t.description,
      format: A()
    }
  };
}
const n9 = /* @__PURE__ */ dA("ZodISODateTime", (t, A) => {
  ij.init(t, A), ze.init(t, A);
});
function s9(t) {
  return t5(n9, t);
}
const a9 = /* @__PURE__ */ dA("ZodISODate", (t, A) => {
  nj.init(t, A), ze.init(t, A);
});
function o9(t) {
  return r5(a9, t);
}
const g9 = /* @__PURE__ */ dA("ZodISOTime", (t, A) => {
  sj.init(t, A), ze.init(t, A);
});
function u9(t) {
  return i5(g9, t);
}
const c9 = /* @__PURE__ */ dA("ZodISODuration", (t, A) => {
  aj.init(t, A), ze.init(t, A);
});
function I9(t) {
  return n5(c9, t);
}
const C9 = (t, A) => {
  Ox.init(t, A), t.name = "ZodError", Object.defineProperties(t, {
    format: {
      value: (e) => $3(t, e)
      // enumerable: false,
    },
    flatten: {
      value: (e) => z3(t, e)
      // enumerable: false,
    },
    addIssue: {
      value: (e) => {
        t.issues.push(e), t.message = JSON.stringify(t.issues, nm, 2);
      }
      // enumerable: false,
    },
    addIssues: {
      value: (e) => {
        t.issues.push(...e), t.message = JSON.stringify(t.issues, nm, 2);
      }
      // enumerable: false,
    },
    isEmpty: {
      get() {
        return t.issues.length === 0;
      }
      // enumerable: false,
    }
  });
}, zr = dA("ZodError", C9, {
  Parent: Error
}), l9 = /* @__PURE__ */ tp(zr), B9 = /* @__PURE__ */ ip(zr), E9 = /* @__PURE__ */ np(zr), h9 = /* @__PURE__ */ sp(zr), Q9 = /* @__PURE__ */ iq(zr), d9 = /* @__PURE__ */ nq(zr), f9 = /* @__PURE__ */ sq(zr), p9 = /* @__PURE__ */ aq(zr), y9 = /* @__PURE__ */ oq(zr), w9 = /* @__PURE__ */ gq(zr), m9 = /* @__PURE__ */ uq(zr), D9 = /* @__PURE__ */ cq(zr), _t = /* @__PURE__ */ dA("ZodType", (t, A) => (pt.init(t, A), t.def = A, t.type = A.type, Object.defineProperty(t, "_def", { value: A }), t.check = (...e) => t.clone(Sg(A, {
  checks: [
    ...A.checks ?? [],
    ...e.map((r) => typeof r == "function" ? { _zod: { check: r, def: { check: "custom" }, onattach: [] } } : r)
  ]
})), t.clone = (e, r) => qt(t, e, r), t.brand = () => t, t.register = (e, r) => (e.add(t, r), t), t.parse = (e, r) => l9(t, e, r, { callee: t.parse }), t.safeParse = (e, r) => E9(t, e, r), t.parseAsync = async (e, r) => B9(t, e, r, { callee: t.parseAsync }), t.safeParseAsync = async (e, r) => h9(t, e, r), t.spa = t.safeParseAsync, t.encode = (e, r) => Q9(t, e, r), t.decode = (e, r) => d9(t, e, r), t.encodeAsync = async (e, r) => f9(t, e, r), t.decodeAsync = async (e, r) => p9(t, e, r), t.safeEncode = (e, r) => y9(t, e, r), t.safeDecode = (e, r) => w9(t, e, r), t.safeEncodeAsync = async (e, r) => m9(t, e, r), t.safeDecodeAsync = async (e, r) => D9(t, e, r), t.refine = (e, r) => t.check(BZ(e, r)), t.superRefine = (e) => t.check(EZ(e)), t.overwrite = (e) => t.check(gI(e)), t.optional = () => bv(t), t.nullable = () => Mv(t), t.nullish = () => bv(Mv(t)), t.nonoptional = (e) => oZ(t, e), t.array = () => W9(t), t.or = (e) => X9([t, e]), t.and = (e) => $9(t, e), t.transform = (e) => _v(t, tZ(e)), t.default = (e) => nZ(t, e), t.prefault = (e) => aZ(t, e), t.catch = (e) => uZ(t, e), t.pipe = (e) => _v(t, e), t.readonly = () => CZ(t), t.describe = (e) => {
  const r = t.clone();
  return Rt.add(r, { description: e }), r;
}, Object.defineProperty(t, "description", {
  get() {
    var e;
    return (e = Rt.get(t)) == null ? void 0 : e.description;
  },
  configurable: !0
}), t.meta = (...e) => {
  if (e.length === 0)
    return Rt.get(t);
  const r = t.clone();
  return Rt.add(r, e[0]), r;
}, t.isOptional = () => t.safeParse(void 0).success, t.isNullable = () => t.safeParse(null).success, t)), UG = /* @__PURE__ */ dA("_ZodString", (t, A) => {
  tS.init(t, A), _t.init(t, A);
  const e = t._zod.bag;
  t.format = e.format ?? null, t.minLength = e.minimum ?? null, t.maxLength = e.maximum ?? null, t.regex = (...r) => t.check(s5(...r)), t.includes = (...r) => t.check(g5(...r)), t.startsWith = (...r) => t.check(u5(...r)), t.endsWith = (...r) => t.check(c5(...r)), t.min = (...r) => t.check(kd(...r)), t.max = (...r) => t.check(rG(...r)), t.length = (...r) => t.check(iG(...r)), t.nonempty = (...r) => t.check(kd(1, ...r)), t.lowercase = (r) => t.check(a5(r)), t.uppercase = (r) => t.check(o5(r)), t.trim = () => t.check(C5()), t.normalize = (...r) => t.check(I5(...r)), t.toLowerCase = () => t.check(l5()), t.toUpperCase = () => t.check(B5()), t.slugify = () => t.check(E5());
}), S9 = /* @__PURE__ */ dA("ZodString", (t, A) => {
  tS.init(t, A), UG.init(t, A), t.email = (e) => t.check(Lj(F9, e)), t.url = (e) => t.check(Kj(k9, e)), t.jwt = (e) => t.check(e5(P9, e)), t.emoji = (e) => t.check(Jj(v9, e)), t.guid = (e) => t.check($k(vv, e)), t.uuid = (e) => t.check(xj(mh, e)), t.uuidv4 = (e) => t.check(Gj(mh, e)), t.uuidv6 = (e) => t.check(Uj(mh, e)), t.uuidv7 = (e) => t.check(Tj(mh, e)), t.nanoid = (e) => t.check(Hj(R9, e)), t.guid = (e) => t.check($k(vv, e)), t.cuid = (e) => t.check(Pj(b9, e)), t.cuid2 = (e) => t.check(Oj(M9, e)), t.ulid = (e) => t.check(Yj(_9, e)), t.base64 = (e) => t.check(zj(K9, e)), t.base64url = (e) => t.check($j(J9, e)), t.xid = (e) => t.check(qj(N9, e)), t.ksuid = (e) => t.check(jj(L9, e)), t.ipv4 = (e) => t.check(Wj(x9, e)), t.ipv6 = (e) => t.check(Vj(G9, e)), t.cidrv4 = (e) => t.check(Zj(U9, e)), t.cidrv6 = (e) => t.check(Xj(T9, e)), t.e164 = (e) => t.check(A5(H9, e)), t.datetime = (e) => t.check(s9(e)), t.date = (e) => t.check(o9(e)), t.time = (e) => t.check(u9(e)), t.duration = (e) => t.check(I9(e));
});
function At(t) {
  return Nj(S9, t);
}
const ze = /* @__PURE__ */ dA("ZodStringFormat", (t, A) => {
  Ve.init(t, A), UG.init(t, A);
}), F9 = /* @__PURE__ */ dA("ZodEmail", (t, A) => {
  Vq.init(t, A), ze.init(t, A);
}), vv = /* @__PURE__ */ dA("ZodGUID", (t, A) => {
  jq.init(t, A), ze.init(t, A);
}), mh = /* @__PURE__ */ dA("ZodUUID", (t, A) => {
  Wq.init(t, A), ze.init(t, A);
}), k9 = /* @__PURE__ */ dA("ZodURL", (t, A) => {
  Zq.init(t, A), ze.init(t, A);
}), v9 = /* @__PURE__ */ dA("ZodEmoji", (t, A) => {
  Xq.init(t, A), ze.init(t, A);
}), R9 = /* @__PURE__ */ dA("ZodNanoID", (t, A) => {
  zq.init(t, A), ze.init(t, A);
}), b9 = /* @__PURE__ */ dA("ZodCUID", (t, A) => {
  $q.init(t, A), ze.init(t, A);
}), M9 = /* @__PURE__ */ dA("ZodCUID2", (t, A) => {
  Aj.init(t, A), ze.init(t, A);
}), _9 = /* @__PURE__ */ dA("ZodULID", (t, A) => {
  ej.init(t, A), ze.init(t, A);
}), N9 = /* @__PURE__ */ dA("ZodXID", (t, A) => {
  tj.init(t, A), ze.init(t, A);
}), L9 = /* @__PURE__ */ dA("ZodKSUID", (t, A) => {
  rj.init(t, A), ze.init(t, A);
}), x9 = /* @__PURE__ */ dA("ZodIPv4", (t, A) => {
  oj.init(t, A), ze.init(t, A);
}), G9 = /* @__PURE__ */ dA("ZodIPv6", (t, A) => {
  gj.init(t, A), ze.init(t, A);
}), U9 = /* @__PURE__ */ dA("ZodCIDRv4", (t, A) => {
  uj.init(t, A), ze.init(t, A);
}), T9 = /* @__PURE__ */ dA("ZodCIDRv6", (t, A) => {
  cj.init(t, A), ze.init(t, A);
}), K9 = /* @__PURE__ */ dA("ZodBase64", (t, A) => {
  Ij.init(t, A), ze.init(t, A);
}), J9 = /* @__PURE__ */ dA("ZodBase64URL", (t, A) => {
  lj.init(t, A), ze.init(t, A);
}), H9 = /* @__PURE__ */ dA("ZodE164", (t, A) => {
  Bj.init(t, A), ze.init(t, A);
}), P9 = /* @__PURE__ */ dA("ZodJWT", (t, A) => {
  hj.init(t, A), ze.init(t, A);
}), O9 = /* @__PURE__ */ dA("ZodUnknown", (t, A) => {
  Zx.init(t, A), _t.init(t, A);
});
function Rv() {
  return eG(O9);
}
const Y9 = /* @__PURE__ */ dA("ZodNever", (t, A) => {
  Xx.init(t, A), _t.init(t, A);
});
function q9(t) {
  return tG(Y9, t);
}
const j9 = /* @__PURE__ */ dA("ZodArray", (t, A) => {
  Qj.init(t, A), _t.init(t, A), t.element = A.element, t.min = (e, r) => t.check(kd(e, r)), t.nonempty = (e) => t.check(kd(1, e)), t.max = (e, r) => t.check(rG(e, r)), t.length = (e, r) => t.check(iG(e, r)), t.unwrap = () => t.element;
});
function W9(t, A) {
  return h5(j9, t, A);
}
const V9 = /* @__PURE__ */ dA("ZodObject", (t, A) => {
  fj.init(t, A), _t.init(t, A), Pe(t, "shape", () => A.shape), t.keyof = () => AZ(Object.keys(t._zod.def.shape)), t.catchall = (e) => t.clone({ ...t._zod.def, catchall: e }), t.passthrough = () => t.clone({ ...t._zod.def, catchall: Rv() }), t.loose = () => t.clone({ ...t._zod.def, catchall: Rv() }), t.strict = () => t.clone({ ...t._zod.def, catchall: q9() }), t.strip = () => t.clone({ ...t._zod.def, catchall: void 0 }), t.extend = (e) => Kx(t, e), t.safeExtend = (e) => V3(t, e), t.merge = (e) => Z3(t, e), t.pick = (e) => j3(t, e), t.omit = (e) => W3(t, e), t.partial = (...e) => Jx(TG, t, e[0]), t.required = (...e) => X3(KG, t, e[0]);
});
function ar(t, A) {
  const e = {
    type: "object",
    shape: t ?? {},
    ...ee(A)
  };
  return new V9(e);
}
const Z9 = /* @__PURE__ */ dA("ZodUnion", (t, A) => {
  pj.init(t, A), _t.init(t, A), t.options = A.options;
});
function X9(t, A) {
  return new Z9({
    type: "union",
    options: t,
    ...ee(A)
  });
}
const z9 = /* @__PURE__ */ dA("ZodIntersection", (t, A) => {
  yj.init(t, A), _t.init(t, A);
});
function $9(t, A) {
  return new z9({
    type: "intersection",
    left: t,
    right: A
  });
}
const fm = /* @__PURE__ */ dA("ZodEnum", (t, A) => {
  wj.init(t, A), _t.init(t, A), t.enum = A.entries, t.options = Object.values(A.entries);
  const e = new Set(Object.keys(A.entries));
  t.extract = (r, i) => {
    const n = {};
    for (const s of r)
      if (e.has(s))
        n[s] = A.entries[s];
      else
        throw new Error(`Key ${s} not found in enum`);
    return new fm({
      ...A,
      checks: [],
      ...ee(i),
      entries: n
    });
  }, t.exclude = (r, i) => {
    const n = { ...A.entries };
    for (const s of r)
      if (e.has(s))
        delete n[s];
      else
        throw new Error(`Key ${s} not found in enum`);
    return new fm({
      ...A,
      checks: [],
      ...ee(i),
      entries: n
    });
  };
});
function AZ(t, A) {
  const e = Array.isArray(t) ? Object.fromEntries(t.map((r) => [r, r])) : t;
  return new fm({
    type: "enum",
    entries: e,
    ...ee(A)
  });
}
const eZ = /* @__PURE__ */ dA("ZodTransform", (t, A) => {
  mj.init(t, A), _t.init(t, A), t._zod.parse = (e, r) => {
    if (r.direction === "backward")
      throw new Lx(t.constructor.name);
    e.addIssue = (n) => {
      if (typeof n == "string")
        e.issues.push(el(n, e.value, A));
      else {
        const s = n;
        s.fatal && (s.continue = !1), s.code ?? (s.code = "custom"), s.input ?? (s.input = e.value), s.inst ?? (s.inst = t), e.issues.push(el(s));
      }
    };
    const i = A.transform(e.value, e);
    return i instanceof Promise ? i.then((n) => (e.value = n, e)) : (e.value = i, e);
  };
});
function tZ(t) {
  return new eZ({
    type: "transform",
    transform: t
  });
}
const TG = /* @__PURE__ */ dA("ZodOptional", (t, A) => {
  rS.init(t, A), _t.init(t, A), t.unwrap = () => t._zod.def.innerType;
});
function bv(t) {
  return new TG({
    type: "optional",
    innerType: t
  });
}
const rZ = /* @__PURE__ */ dA("ZodNullable", (t, A) => {
  Dj.init(t, A), _t.init(t, A), t.unwrap = () => t._zod.def.innerType;
});
function Mv(t) {
  return new rZ({
    type: "nullable",
    innerType: t
  });
}
const iZ = /* @__PURE__ */ dA("ZodDefault", (t, A) => {
  Sj.init(t, A), _t.init(t, A), t.unwrap = () => t._zod.def.innerType, t.removeDefault = t.unwrap;
});
function nZ(t, A) {
  return new iZ({
    type: "default",
    innerType: t,
    get defaultValue() {
      return typeof A == "function" ? A() : Tx(A);
    }
  });
}
const sZ = /* @__PURE__ */ dA("ZodPrefault", (t, A) => {
  Fj.init(t, A), _t.init(t, A), t.unwrap = () => t._zod.def.innerType;
});
function aZ(t, A) {
  return new sZ({
    type: "prefault",
    innerType: t,
    get defaultValue() {
      return typeof A == "function" ? A() : Tx(A);
    }
  });
}
const KG = /* @__PURE__ */ dA("ZodNonOptional", (t, A) => {
  kj.init(t, A), _t.init(t, A), t.unwrap = () => t._zod.def.innerType;
});
function oZ(t, A) {
  return new KG({
    type: "nonoptional",
    innerType: t,
    ...ee(A)
  });
}
const gZ = /* @__PURE__ */ dA("ZodCatch", (t, A) => {
  vj.init(t, A), _t.init(t, A), t.unwrap = () => t._zod.def.innerType, t.removeCatch = t.unwrap;
});
function uZ(t, A) {
  return new gZ({
    type: "catch",
    innerType: t,
    catchValue: typeof A == "function" ? A : () => A
  });
}
const cZ = /* @__PURE__ */ dA("ZodPipe", (t, A) => {
  Rj.init(t, A), _t.init(t, A), t.in = A.in, t.out = A.out;
});
function _v(t, A) {
  return new cZ({
    type: "pipe",
    in: t,
    out: A
    // ...util.normalizeParams(params),
  });
}
const IZ = /* @__PURE__ */ dA("ZodReadonly", (t, A) => {
  bj.init(t, A), _t.init(t, A), t.unwrap = () => t._zod.def.innerType;
});
function CZ(t) {
  return new IZ({
    type: "readonly",
    innerType: t
  });
}
const lZ = /* @__PURE__ */ dA("ZodCustom", (t, A) => {
  Mj.init(t, A), _t.init(t, A);
});
function BZ(t, A = {}) {
  return Q5(lZ, t, A);
}
function EZ(t) {
  return d5(t);
}
const hZ = Symbol("Let zodToJsonSchema decide on which parser to use"), Nv = {
  name: void 0,
  $refStrategy: "root",
  effectStrategy: "input",
  pipeStrategy: "all",
  dateStrategy: "format:date-time",
  mapStrategy: "entries",
  nullableStrategy: "from-target",
  removeAdditionalStrategy: "passthrough",
  definitionPath: "definitions",
  target: "jsonSchema7",
  strictUnions: !1,
  errorMessages: !1,
  markdownDescription: !1,
  patternStrategy: "escape",
  applyRegexFlags: !1,
  emailStrategy: "format:email",
  base64Strategy: "contentEncoding:base64",
  nameStrategy: "ref"
}, QZ = (t) => typeof t == "string" ? {
  ...Nv,
  basePath: ["#"],
  definitions: {},
  name: t
} : {
  ...Nv,
  basePath: ["#"],
  definitions: {},
  ...t
}, pm = (t) => "_def" in t ? t._def : t;
function dZ(t) {
  if (!t)
    return !0;
  for (const A in t)
    return !1;
  return !0;
}
const fZ = (t) => {
  const A = QZ(t), e = A.name !== void 0 ? [...A.basePath, A.definitionPath, A.name] : A.basePath;
  return {
    ...A,
    currentPath: e,
    propertyPath: void 0,
    seenRefs: /* @__PURE__ */ new Set(),
    seen: new Map(Object.entries(A.definitions).map(([r, i]) => [
      pm(i),
      {
        def: pm(i),
        path: [...A.basePath, A.definitionPath, r],
        // Resolution of references will be forced even though seen, so it's ok that the schema is undefined here for now.
        jsonSchema: void 0
      }
    ]))
  };
};
function JG(t, A, e, r) {
  r != null && r.errorMessages && e && (t.errorMessage = {
    ...t.errorMessage,
    [A]: e
  });
}
function Ne(t, A, e, r, i) {
  t[A] = e, JG(t, A, r, i);
}
function pZ() {
  return {};
}
function yZ(t, A) {
  var r, i;
  const e = {
    type: "array"
  };
  return ((i = (r = t.type) == null ? void 0 : r._def) == null ? void 0 : i.typeName) !== IA.ZodAny && (e.items = ve(t.type._def, {
    ...A,
    currentPath: [...A.currentPath, "items"]
  })), t.minLength && Ne(e, "minItems", t.minLength.value, t.minLength.message, A), t.maxLength && Ne(e, "maxItems", t.maxLength.value, t.maxLength.message, A), t.exactLength && (Ne(e, "minItems", t.exactLength.value, t.exactLength.message, A), Ne(e, "maxItems", t.exactLength.value, t.exactLength.message, A)), e;
}
function wZ(t, A) {
  const e = {
    type: "integer",
    format: "int64"
  };
  if (!t.checks)
    return e;
  for (const r of t.checks)
    switch (r.kind) {
      case "min":
        A.target === "jsonSchema7" ? r.inclusive ? Ne(e, "minimum", r.value, r.message, A) : Ne(e, "exclusiveMinimum", r.value, r.message, A) : (r.inclusive || (e.exclusiveMinimum = !0), Ne(e, "minimum", r.value, r.message, A));
        break;
      case "max":
        A.target === "jsonSchema7" ? r.inclusive ? Ne(e, "maximum", r.value, r.message, A) : Ne(e, "exclusiveMaximum", r.value, r.message, A) : (r.inclusive || (e.exclusiveMaximum = !0), Ne(e, "maximum", r.value, r.message, A));
        break;
      case "multipleOf":
        Ne(e, "multipleOf", r.value, r.message, A);
        break;
    }
  return e;
}
function mZ() {
  return {
    type: "boolean"
  };
}
function DZ(t, A) {
  return ve(t.type._def, A);
}
const SZ = (t, A) => ve(t.innerType._def, A);
function HG(t, A, e) {
  const r = e ?? A.dateStrategy;
  if (Array.isArray(r))
    return {
      anyOf: r.map((i, n) => HG(t, A, i))
    };
  switch (r) {
    case "string":
    case "format:date-time":
      return {
        type: "string",
        format: "date-time"
      };
    case "format:date":
      return {
        type: "string",
        format: "date"
      };
    case "integer":
      return FZ(t, A);
  }
}
const FZ = (t, A) => {
  const e = {
    type: "integer",
    format: "unix-time"
  };
  if (A.target === "openApi3")
    return e;
  for (const r of t.checks)
    switch (r.kind) {
      case "min":
        Ne(
          e,
          "minimum",
          r.value,
          // This is in milliseconds
          r.message,
          A
        );
        break;
      case "max":
        Ne(
          e,
          "maximum",
          r.value,
          // This is in milliseconds
          r.message,
          A
        );
        break;
    }
  return e;
};
function kZ(t, A) {
  return {
    ...ve(t.innerType._def, A),
    default: t.defaultValue()
  };
}
function vZ(t, A, e) {
  return A.effectStrategy === "input" ? ve(t.schema._def, A, e) : {};
}
function RZ(t) {
  return {
    type: "string",
    enum: [...t.values]
  };
}
const bZ = (t) => "type" in t && t.type === "string" ? !1 : "allOf" in t;
function MZ(t, A) {
  const e = [
    ve(t.left._def, {
      ...A,
      currentPath: [...A.currentPath, "allOf", "0"]
    }),
    ve(t.right._def, {
      ...A,
      currentPath: [...A.currentPath, "allOf", "1"]
    })
  ].filter((n) => !!n);
  let r = A.target === "jsonSchema2019-09" ? { unevaluatedProperties: !1 } : void 0;
  const i = [];
  return e.forEach((n) => {
    if (bZ(n))
      i.push(...n.allOf), n.unevaluatedProperties === void 0 && (r = void 0);
    else {
      let s = n;
      if ("additionalProperties" in n && n.additionalProperties === !1) {
        const { additionalProperties: a, ...g } = n;
        s = g;
      } else
        r = void 0;
      i.push(s);
    }
  }), i.length ? {
    allOf: i,
    ...r
  } : void 0;
}
function _Z(t, A) {
  const e = typeof t.value;
  return e !== "bigint" && e !== "number" && e !== "boolean" && e !== "string" ? {
    type: Array.isArray(t.value) ? "array" : "object"
  } : A.target === "openApi3" ? {
    type: e === "bigint" ? "integer" : e,
    enum: [t.value]
  } : {
    type: e === "bigint" ? "integer" : e,
    const: t.value
  };
}
let hy;
const Ka = {
  /**
   * `c` was changed to `[cC]` to replicate /i flag
   */
  cuid: /^[cC][^\s-]{8,}$/,
  cuid2: /^[0-9a-z]+$/,
  ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,
  /**
   * `a-z` was added to replicate /i flag
   */
  email: /^(?!\.)(?!.*\.\.)([a-zA-Z0-9_'+\-\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\-]*\.)+[a-zA-Z]{2,}$/,
  /**
   * Constructed a valid Unicode RegExp
   *
   * Lazily instantiate since this type of regex isn't supported
   * in all envs (e.g. React Native).
   *
   * See:
   * https://github.com/colinhacks/zod/issues/2433
   * Fix in Zod:
   * https://github.com/colinhacks/zod/commit/9340fd51e48576a75adc919bff65dbc4a5d4c99b
   */
  emoji: () => (hy === void 0 && (hy = RegExp("^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$", "u")), hy),
  base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
  nanoid: /^[a-zA-Z0-9_-]{21}$/
};
function PG(t, A) {
  const e = {
    type: "string"
  };
  function r(i) {
    return A.patternStrategy === "escape" ? NZ(i) : i;
  }
  if (t.checks)
    for (const i of t.checks)
      switch (i.kind) {
        case "min":
          Ne(e, "minLength", typeof e.minLength == "number" ? Math.max(e.minLength, i.value) : i.value, i.message, A);
          break;
        case "max":
          Ne(e, "maxLength", typeof e.maxLength == "number" ? Math.min(e.maxLength, i.value) : i.value, i.message, A);
          break;
        case "email":
          switch (A.emailStrategy) {
            case "format:email":
              ti(e, "email", i.message, A);
              break;
            case "format:idn-email":
              ti(e, "idn-email", i.message, A);
              break;
            case "pattern:zod":
              ri(e, Ka.email, i.message, A);
              break;
          }
          break;
        case "url":
          ti(e, "uri", i.message, A);
          break;
        case "uuid":
          ti(e, "uuid", i.message, A);
          break;
        case "regex":
          ri(e, i.regex, i.message, A);
          break;
        case "cuid":
          ri(e, Ka.cuid, i.message, A);
          break;
        case "cuid2":
          ri(e, Ka.cuid2, i.message, A);
          break;
        case "startsWith":
          ri(e, RegExp(`^${r(i.value)}`), i.message, A);
          break;
        case "endsWith":
          ri(e, RegExp(`${r(i.value)}$`), i.message, A);
          break;
        case "datetime":
          ti(e, "date-time", i.message, A);
          break;
        case "date":
          ti(e, "date", i.message, A);
          break;
        case "time":
          ti(e, "time", i.message, A);
          break;
        case "duration":
          ti(e, "duration", i.message, A);
          break;
        case "length":
          Ne(e, "minLength", typeof e.minLength == "number" ? Math.max(e.minLength, i.value) : i.value, i.message, A), Ne(e, "maxLength", typeof e.maxLength == "number" ? Math.min(e.maxLength, i.value) : i.value, i.message, A);
          break;
        case "includes": {
          ri(e, RegExp(r(i.value)), i.message, A);
          break;
        }
        case "ip": {
          i.version !== "v6" && ti(e, "ipv4", i.message, A), i.version !== "v4" && ti(e, "ipv6", i.message, A);
          break;
        }
        case "emoji":
          ri(e, Ka.emoji, i.message, A);
          break;
        case "ulid": {
          ri(e, Ka.ulid, i.message, A);
          break;
        }
        case "base64": {
          switch (A.base64Strategy) {
            case "format:binary": {
              ti(e, "binary", i.message, A);
              break;
            }
            case "contentEncoding:base64": {
              Ne(e, "contentEncoding", "base64", i.message, A);
              break;
            }
            case "pattern:zod": {
              ri(e, Ka.base64, i.message, A);
              break;
            }
          }
          break;
        }
        case "nanoid":
          ri(e, Ka.nanoid, i.message, A);
      }
  return e;
}
const NZ = (t) => Array.from(t).map((A) => /[a-zA-Z0-9]/.test(A) ? A : `\\${A}`).join(""), ti = (t, A, e, r) => {
  var i;
  t.format || (i = t.anyOf) != null && i.some((n) => n.format) ? (t.anyOf || (t.anyOf = []), t.format && (t.anyOf.push({
    format: t.format,
    ...t.errorMessage && r.errorMessages && {
      errorMessage: { format: t.errorMessage.format }
    }
  }), delete t.format, t.errorMessage && (delete t.errorMessage.format, Object.keys(t.errorMessage).length === 0 && delete t.errorMessage)), t.anyOf.push({
    format: A,
    ...e && r.errorMessages && { errorMessage: { format: e } }
  })) : Ne(t, "format", A, e, r);
}, ri = (t, A, e, r) => {
  var i;
  t.pattern || (i = t.allOf) != null && i.some((n) => n.pattern) ? (t.allOf || (t.allOf = []), t.pattern && (t.allOf.push({
    pattern: t.pattern,
    ...t.errorMessage && r.errorMessages && {
      errorMessage: { pattern: t.errorMessage.pattern }
    }
  }), delete t.pattern, t.errorMessage && (delete t.errorMessage.pattern, Object.keys(t.errorMessage).length === 0 && delete t.errorMessage)), t.allOf.push({
    pattern: Lv(A, r),
    ...e && r.errorMessages && { errorMessage: { pattern: e } }
  })) : Ne(t, "pattern", Lv(A, r), e, r);
}, Lv = (t, A) => {
  var o;
  const e = typeof t == "function" ? t() : t;
  if (!A.applyRegexFlags || !e.flags)
    return e.source;
  const r = {
    i: e.flags.includes("i"),
    // Case-insensitive
    m: e.flags.includes("m"),
    // `^` and `$` matches adjacent to newline characters
    s: e.flags.includes("s")
    // `.` matches newlines
  }, i = r.i ? e.source.toLowerCase() : e.source;
  let n = "", s = !1, a = !1, g = !1;
  for (let u = 0; u < i.length; u++) {
    if (s) {
      n += i[u], s = !1;
      continue;
    }
    if (r.i) {
      if (a) {
        if (i[u].match(/[a-z]/)) {
          g ? (n += i[u], n += `${i[u - 2]}-${i[u]}`.toUpperCase(), g = !1) : i[u + 1] === "-" && ((o = i[u + 2]) != null && o.match(/[a-z]/)) ? (n += i[u], g = !0) : n += `${i[u]}${i[u].toUpperCase()}`;
          continue;
        }
      } else if (i[u].match(/[a-z]/)) {
        n += `[${i[u]}${i[u].toUpperCase()}]`;
        continue;
      }
    }
    if (r.m) {
      if (i[u] === "^") {
        n += `(^|(?<=[\r
]))`;
        continue;
      } else if (i[u] === "$") {
        n += `($|(?=[\r
]))`;
        continue;
      }
    }
    if (r.s && i[u] === ".") {
      n += a ? `${i[u]}\r
` : `[${i[u]}\r
]`;
      continue;
    }
    n += i[u], i[u] === "\\" ? s = !0 : a && i[u] === "]" ? a = !1 : !a && i[u] === "[" && (a = !0);
  }
  try {
    const u = new RegExp(n);
  } catch {
    return console.warn(`Could not convert regex pattern at ${A.currentPath.join("/")} to a flag-independent form! Falling back to the flag-ignorant source`), e.source;
  }
  return n;
};
function OG(t, A) {
  var r, i, n, s;
  if (A.target === "openApi3" && ((r = t.keyType) == null ? void 0 : r._def.typeName) === IA.ZodEnum)
    return {
      type: "object",
      required: t.keyType._def.values,
      properties: t.keyType._def.values.reduce((a, g) => ({
        ...a,
        [g]: ve(t.valueType._def, {
          ...A,
          currentPath: [...A.currentPath, "properties", g]
        }) ?? {}
      }), {}),
      additionalProperties: !1
    };
  const e = {
    type: "object",
    additionalProperties: ve(t.valueType._def, {
      ...A,
      currentPath: [...A.currentPath, "additionalProperties"]
    }) ?? {}
  };
  if (A.target === "openApi3")
    return e;
  if (((i = t.keyType) == null ? void 0 : i._def.typeName) === IA.ZodString && ((n = t.keyType._def.checks) != null && n.length)) {
    const a = Object.entries(PG(t.keyType._def, A)).reduce((g, [o, u]) => o === "type" ? g : { ...g, [o]: u }, {});
    return {
      ...e,
      propertyNames: a
    };
  } else if (((s = t.keyType) == null ? void 0 : s._def.typeName) === IA.ZodEnum)
    return {
      ...e,
      propertyNames: {
        enum: t.keyType._def.values
      }
    };
  return e;
}
function LZ(t, A) {
  if (A.mapStrategy === "record")
    return OG(t, A);
  const e = ve(t.keyType._def, {
    ...A,
    currentPath: [...A.currentPath, "items", "items", "0"]
  }) || {}, r = ve(t.valueType._def, {
    ...A,
    currentPath: [...A.currentPath, "items", "items", "1"]
  }) || {};
  return {
    type: "array",
    maxItems: 125,
    items: {
      type: "array",
      items: [e, r],
      minItems: 2,
      maxItems: 2
    }
  };
}
function xZ(t) {
  const A = t.values, r = Object.keys(t.values).filter((n) => typeof A[A[n]] != "number").map((n) => A[n]), i = Array.from(new Set(r.map((n) => typeof n)));
  return {
    type: i.length === 1 ? i[0] === "string" ? "string" : "number" : ["string", "number"],
    enum: r
  };
}
function GZ() {
  return {
    not: {}
  };
}
function UZ(t) {
  return t.target === "openApi3" ? {
    enum: ["null"],
    nullable: !0
  } : {
    type: "null"
  };
}
const Kd = {
  ZodString: "string",
  ZodNumber: "number",
  ZodBigInt: "integer",
  ZodBoolean: "boolean",
  ZodNull: "null"
};
function TZ(t, A) {
  if (A.target === "openApi3")
    return xv(t, A);
  const e = t.options instanceof Map ? Array.from(t.options.values()) : t.options;
  if (e.every((r) => r._def.typeName in Kd && (!r._def.checks || !r._def.checks.length))) {
    const r = e.reduce((i, n) => {
      const s = Kd[n._def.typeName];
      return s && !i.includes(s) ? [...i, s] : i;
    }, []);
    return {
      type: r.length > 1 ? r : r[0]
    };
  } else if (e.every((r) => r._def.typeName === "ZodLiteral" && !r.description)) {
    const r = e.reduce((i, n) => {
      const s = typeof n._def.value;
      switch (s) {
        case "string":
        case "number":
        case "boolean":
          return [...i, s];
        case "bigint":
          return [...i, "integer"];
        case "object":
          if (n._def.value === null)
            return [...i, "null"];
        case "symbol":
        case "undefined":
        case "function":
        default:
          return i;
      }
    }, []);
    if (r.length === e.length) {
      const i = r.filter((n, s, a) => a.indexOf(n) === s);
      return {
        type: i.length > 1 ? i : i[0],
        enum: e.reduce((n, s) => n.includes(s._def.value) ? n : [...n, s._def.value], [])
      };
    }
  } else if (e.every((r) => r._def.typeName === "ZodEnum"))
    return {
      type: "string",
      enum: e.reduce((r, i) => [...r, ...i._def.values.filter((n) => !r.includes(n))], [])
    };
  return xv(t, A);
}
const xv = (t, A) => {
  const e = (t.options instanceof Map ? Array.from(t.options.values()) : t.options).map((r, i) => ve(r._def, {
    ...A,
    currentPath: [...A.currentPath, "anyOf", `${i}`]
  })).filter((r) => !!r && (!A.strictUnions || typeof r == "object" && Object.keys(r).length > 0));
  return e.length ? { anyOf: e } : void 0;
};
function KZ(t, A) {
  if (["ZodString", "ZodNumber", "ZodBigInt", "ZodBoolean", "ZodNull"].includes(t.innerType._def.typeName) && (!t.innerType._def.checks || !t.innerType._def.checks.length))
    return A.target === "openApi3" || A.nullableStrategy === "property" ? {
      type: Kd[t.innerType._def.typeName],
      nullable: !0
    } : {
      type: [Kd[t.innerType._def.typeName], "null"]
    };
  if (A.target === "openApi3") {
    const r = ve(t.innerType._def, {
      ...A,
      currentPath: [...A.currentPath]
    });
    return r && "$ref" in r ? { allOf: [r], nullable: !0 } : r && { ...r, nullable: !0 };
  }
  const e = ve(t.innerType._def, {
    ...A,
    currentPath: [...A.currentPath, "anyOf", "0"]
  });
  return e && { anyOf: [e, { type: "null" }] };
}
function JZ(t, A) {
  const e = {
    type: "number"
  };
  if (!t.checks)
    return e;
  for (const r of t.checks)
    switch (r.kind) {
      case "int":
        e.type = "integer", JG(e, "type", r.message, A);
        break;
      case "min":
        A.target === "jsonSchema7" ? r.inclusive ? Ne(e, "minimum", r.value, r.message, A) : Ne(e, "exclusiveMinimum", r.value, r.message, A) : (r.inclusive || (e.exclusiveMinimum = !0), Ne(e, "minimum", r.value, r.message, A));
        break;
      case "max":
        A.target === "jsonSchema7" ? r.inclusive ? Ne(e, "maximum", r.value, r.message, A) : Ne(e, "exclusiveMaximum", r.value, r.message, A) : (r.inclusive || (e.exclusiveMaximum = !0), Ne(e, "maximum", r.value, r.message, A));
        break;
      case "multipleOf":
        Ne(e, "multipleOf", r.value, r.message, A);
        break;
    }
  return e;
}
function HZ(t, A) {
  return A.removeAdditionalStrategy === "strict" ? t.catchall._def.typeName === "ZodNever" ? t.unknownKeys !== "strict" : ve(t.catchall._def, {
    ...A,
    currentPath: [...A.currentPath, "additionalProperties"]
  }) ?? !0 : t.catchall._def.typeName === "ZodNever" ? t.unknownKeys === "passthrough" : ve(t.catchall._def, {
    ...A,
    currentPath: [...A.currentPath, "additionalProperties"]
  }) ?? !0;
}
function PZ(t, A) {
  const e = {
    type: "object",
    ...Object.entries(t.shape()).reduce((r, [i, n]) => {
      var g;
      if (n === void 0 || n._def === void 0)
        return r;
      const s = [...A.currentPath, "properties", i], a = ve(n._def, {
        ...A,
        currentPath: s,
        propertyPath: s
      });
      if (a === void 0)
        return r;
      if (A.openaiStrictMode && n.isOptional() && !n.isNullable() && typeof ((g = n._def) == null ? void 0 : g.defaultValue) > "u")
        throw new Error(`Zod field at \`${s.join("/")}\` uses \`.optional()\` without \`.nullable()\` which is not supported by the API. See: https://platform.openai.com/docs/guides/structured-outputs?api-mode=responses#all-fields-must-be-required`);
      return {
        properties: {
          ...r.properties,
          [i]: a
        },
        required: n.isOptional() && !A.openaiStrictMode ? r.required : [...r.required, i]
      };
    }, { properties: {}, required: [] }),
    additionalProperties: HZ(t, A)
  };
  return e.required.length || delete e.required, e;
}
const OZ = (t, A) => {
  if (A.propertyPath && A.currentPath.slice(0, A.propertyPath.length).toString() === A.propertyPath.toString())
    return ve(t.innerType._def, { ...A, currentPath: A.currentPath });
  const e = ve(t.innerType._def, {
    ...A,
    currentPath: [...A.currentPath, "anyOf", "1"]
  });
  return e ? {
    anyOf: [
      {
        not: {}
      },
      e
    ]
  } : {};
}, YZ = (t, A) => {
  if (A.pipeStrategy === "input")
    return ve(t.in._def, A);
  if (A.pipeStrategy === "output")
    return ve(t.out._def, A);
  const e = ve(t.in._def, {
    ...A,
    currentPath: [...A.currentPath, "allOf", "0"]
  }), r = ve(t.out._def, {
    ...A,
    currentPath: [...A.currentPath, "allOf", e ? "1" : "0"]
  });
  return {
    allOf: [e, r].filter((i) => i !== void 0)
  };
};
function qZ(t, A) {
  return ve(t.type._def, A);
}
function jZ(t, A) {
  const r = {
    type: "array",
    uniqueItems: !0,
    items: ve(t.valueType._def, {
      ...A,
      currentPath: [...A.currentPath, "items"]
    })
  };
  return t.minSize && Ne(r, "minItems", t.minSize.value, t.minSize.message, A), t.maxSize && Ne(r, "maxItems", t.maxSize.value, t.maxSize.message, A), r;
}
function WZ(t, A) {
  return t.rest ? {
    type: "array",
    minItems: t.items.length,
    items: t.items.map((e, r) => ve(e._def, {
      ...A,
      currentPath: [...A.currentPath, "items", `${r}`]
    })).reduce((e, r) => r === void 0 ? e : [...e, r], []),
    additionalItems: ve(t.rest._def, {
      ...A,
      currentPath: [...A.currentPath, "additionalItems"]
    })
  } : {
    type: "array",
    minItems: t.items.length,
    maxItems: t.items.length,
    items: t.items.map((e, r) => ve(e._def, {
      ...A,
      currentPath: [...A.currentPath, "items", `${r}`]
    })).reduce((e, r) => r === void 0 ? e : [...e, r], [])
  };
}
function VZ() {
  return {
    not: {}
  };
}
function ZZ() {
  return {};
}
const XZ = (t, A) => ve(t.innerType._def, A);
function ve(t, A, e = !1) {
  var s;
  const r = A.seen.get(t);
  if (A.override) {
    const a = (s = A.override) == null ? void 0 : s.call(A, t, A, r, e);
    if (a !== hZ)
      return a;
  }
  if (r && !e) {
    const a = zZ(r, A);
    if (a !== void 0)
      return "$ref" in a && A.seenRefs.add(a.$ref), a;
  }
  const i = { def: t, path: A.currentPath, jsonSchema: void 0 };
  A.seen.set(t, i);
  const n = A6(t, t.typeName, A, e);
  return n && e6(t, A, n), i.jsonSchema = n, n;
}
const zZ = (t, A) => {
  switch (A.$refStrategy) {
    case "root":
      return { $ref: t.path.join("/") };
    case "extract-to-root":
      const e = t.path.slice(A.basePath.length + 1).join("_");
      return e !== A.name && A.nameStrategy === "duplicate-ref" && (A.definitions[e] = t.def), { $ref: [...A.basePath, A.definitionPath, e].join("/") };
    case "relative":
      return { $ref: $Z(A.currentPath, t.path) };
    case "none":
    case "seen":
      return t.path.length < A.currentPath.length && t.path.every((r, i) => A.currentPath[i] === r) ? (console.warn(`Recursive reference detected at ${A.currentPath.join("/")}! Defaulting to any`), {}) : A.$refStrategy === "seen" ? {} : void 0;
  }
}, $Z = (t, A) => {
  let e = 0;
  for (; e < t.length && e < A.length && t[e] === A[e]; e++)
    ;
  return [(t.length - e).toString(), ...A.slice(e)].join("/");
}, A6 = (t, A, e, r) => {
  switch (A) {
    case IA.ZodString:
      return PG(t, e);
    case IA.ZodNumber:
      return JZ(t, e);
    case IA.ZodObject:
      return PZ(t, e);
    case IA.ZodBigInt:
      return wZ(t, e);
    case IA.ZodBoolean:
      return mZ();
    case IA.ZodDate:
      return HG(t, e);
    case IA.ZodUndefined:
      return VZ();
    case IA.ZodNull:
      return UZ(e);
    case IA.ZodArray:
      return yZ(t, e);
    case IA.ZodUnion:
    case IA.ZodDiscriminatedUnion:
      return TZ(t, e);
    case IA.ZodIntersection:
      return MZ(t, e);
    case IA.ZodTuple:
      return WZ(t, e);
    case IA.ZodRecord:
      return OG(t, e);
    case IA.ZodLiteral:
      return _Z(t, e);
    case IA.ZodEnum:
      return RZ(t);
    case IA.ZodNativeEnum:
      return xZ(t);
    case IA.ZodNullable:
      return KZ(t, e);
    case IA.ZodOptional:
      return OZ(t, e);
    case IA.ZodMap:
      return LZ(t, e);
    case IA.ZodSet:
      return jZ(t, e);
    case IA.ZodLazy:
      return ve(t.getter()._def, e);
    case IA.ZodPromise:
      return qZ(t, e);
    case IA.ZodNaN:
    case IA.ZodNever:
      return GZ();
    case IA.ZodEffects:
      return vZ(t, e, r);
    case IA.ZodAny:
      return pZ();
    case IA.ZodUnknown:
      return ZZ();
    case IA.ZodDefault:
      return kZ(t, e);
    case IA.ZodBranded:
      return DZ(t, e);
    case IA.ZodReadonly:
      return XZ(t, e);
    case IA.ZodCatch:
      return SZ(t, e);
    case IA.ZodPipeline:
      return YZ(t, e);
    case IA.ZodFunction:
    case IA.ZodVoid:
    case IA.ZodSymbol:
      return;
    default:
      return /* @__PURE__ */ ((i) => {
      })();
  }
}, e6 = (t, A, e) => (t.description && (e.description = t.description, A.markdownDescription && (e.markdownDescription = t.description)), e), t6 = (t, A) => {
  const e = fZ(A), r = typeof A == "string" ? A : (A == null ? void 0 : A.nameStrategy) === "title" || A == null ? void 0 : A.name, i = ve(t._def, r === void 0 ? e : {
    ...e,
    currentPath: [...e.basePath, e.definitionPath, r]
  }, !1) ?? {}, n = typeof A == "object" && A.name !== void 0 && A.nameStrategy === "title" ? A.name : void 0;
  n !== void 0 && (i.title = n);
  const s = (() => {
    if (dZ(e.definitions))
      return;
    const g = {}, o = /* @__PURE__ */ new Set();
    for (let u = 0; u < 500; u++) {
      const I = Object.entries(e.definitions).filter(([c]) => !o.has(c));
      if (I.length === 0)
        break;
      for (const [c, C] of I)
        g[c] = ve(pm(C), { ...e, currentPath: [...e.basePath, e.definitionPath, c] }, !0) ?? {}, o.add(c);
    }
    return g;
  })(), a = r === void 0 ? s ? {
    ...i,
    [e.definitionPath]: s
  } : i : e.nameStrategy === "duplicate-ref" ? {
    ...i,
    ...s || e.seenRefs.size ? {
      [e.definitionPath]: {
        ...s,
        // only actually duplicate the schema definition if it was ever referenced
        // otherwise the duplication is completely pointless
        ...e.seenRefs.size ? { [r]: i } : void 0
      }
    } : void 0
  } : {
    $ref: [...e.$refStrategy === "relative" ? [] : e.basePath, e.definitionPath, r].join("/"),
    [e.definitionPath]: {
      ...s,
      [r]: i
    }
  };
  return e.target === "jsonSchema7" ? a.$schema = "http://json-schema.org/draft-07/schema#" : e.target === "jsonSchema2019-09" && (a.$schema = "https://json-schema.org/draft/2019-09/schema#"), a;
};
function r6(t) {
  if (t.type !== "object")
    throw new Error(`Root schema must have type: 'object' but got type: ${t.type ? `'${t.type}'` : "undefined"}`);
  const A = structuredClone(t);
  return Jn(A, [], A);
}
function ym(t) {
  if (typeof t == "boolean")
    return !1;
  if (t.type === "null")
    return !0;
  for (const A of t.oneOf ?? [])
    if (ym(A))
      return !0;
  for (const A of t.anyOf ?? [])
    if (ym(A))
      return !0;
  return !1;
}
function Jn(t, A, e) {
  if (typeof t == "boolean")
    throw new TypeError(`Expected object schema but got boolean; path=${A.join("/")}`);
  if (!eo(t))
    throw new TypeError(`Expected ${JSON.stringify(t)} to be an object; path=${A.join("/")}`);
  const r = t.$defs;
  if (eo(r))
    for (const [c, C] of Object.entries(r))
      Jn(C, [...A, "$defs", c], e);
  const i = t.definitions;
  if (eo(i))
    for (const [c, C] of Object.entries(i))
      Jn(C, [...A, "definitions", c], e);
  t.type === "object" && !("additionalProperties" in t) && (t.additionalProperties = !1);
  const s = t.required ?? [], a = t.properties;
  if (eo(a)) {
    for (const [c, C] of Object.entries(a))
      if (!ym(C) && !s.includes(c))
        throw new Error(`Zod field at \`${[...A, "properties", c].join("/")}\` uses \`.optional()\` without \`.nullable()\` which is not supported by the API. See: https://platform.openai.com/docs/guides/structured-outputs?api-mode=responses#all-fields-must-be-required`);
    t.required = Object.keys(a), t.properties = Object.fromEntries(Object.entries(a).map(([c, C]) => [
      c,
      Jn(C, [...A, "properties", c], e)
    ]));
  }
  const g = t.items;
  eo(g) && (t.items = Jn(g, [...A, "items"], e));
  const o = t.anyOf;
  Array.isArray(o) && (t.anyOf = o.map((c, C) => Jn(c, [...A, "anyOf", String(C)], e)));
  const u = t.allOf;
  if (Array.isArray(u))
    if (u.length === 1) {
      const c = Jn(u[0], [...A, "allOf", "0"], e);
      Object.assign(t, c), delete t.allOf;
    } else
      t.allOf = u.map((c, C) => Jn(c, [...A, "allOf", String(C)], e));
  t.default === null && delete t.default;
  const I = t.$ref;
  if (I && n6(t, 1)) {
    if (typeof I != "string")
      throw new TypeError(`Received non-string $ref - ${I}; path=${A.join("/")}`);
    const c = i6(e, I);
    if (typeof c == "boolean")
      throw new Error(`Expected \`$ref: ${I}\` to resolve to an object schema but got boolean`);
    if (!eo(c))
      throw new Error(`Expected \`$ref: ${I}\` to resolve to an object but got ${JSON.stringify(c)}`);
    return Object.assign(t, { ...c, ...t }), delete t.$ref, Jn(t, A, e);
  }
  return t;
}
function i6(t, A) {
  if (!A.startsWith("#/"))
    throw new Error(`Unexpected $ref format ${JSON.stringify(A)}; Does not start with #/`);
  const e = A.slice(2).split("/");
  let r = t;
  for (const i of e) {
    if (!eo(r))
      throw new Error(`encountered non-object entry while resolving ${A} - ${JSON.stringify(r)}`);
    const n = r[i];
    if (n === void 0)
      throw new Error(`Key ${i} not found while resolving ${A}`);
    r = n;
  }
  return r;
}
function eo(t) {
  return typeof t == "object" && t !== null && !Array.isArray(t);
}
function n6(t, A) {
  let e = 0;
  for (const r in t)
    if (e++, e > A)
      return !0;
  return !1;
}
function s6(t, A) {
  return t6(t, {
    openaiStrictMode: !0,
    name: A.name,
    nameStrategy: "duplicate-ref",
    $refStrategy: "extract-to-root",
    nullableStrategy: "property"
  });
}
function a6(t) {
  return r6(vd(t, {
    target: "draft-7"
  }));
}
function o6(t) {
  return "_zod" in t;
}
function g6(t, A, e) {
  return vH({
    type: "json_schema",
    json_schema: {
      ...e,
      name: A,
      strict: !0,
      schema: o6(t) ? a6(t) : s6(t, { name: A })
    }
  }, (r) => t.parse(JSON.parse(r)));
}
const Gv = [
  "jsonSchema",
  "functionCalling",
  "jsonMode"
];
function u6(t, A) {
  if (typeof A < "u" && !Gv.includes(A)) throw new Error(`Invalid method: ${A}. Supported methods are: ${Gv.join(", ")}`);
  const e = !t.startsWith("gpt-3") && !t.startsWith("gpt-4-") && t !== "gpt-4";
  if (e && !A) return "jsonSchema";
  if (!e && A === "jsonSchema") throw new Error(`JSON Schema is not supported for model "${t}". Please use a different method, e.g. "functionCalling" or "jsonMode".`);
  return A ?? "functionCalling";
}
function c6(t, A) {
  const e = { ...t };
  return Object.defineProperties(e, {
    $brand: {
      value: "auto-parseable-response-format",
      enumerable: !1
    },
    $parseRaw: {
      value: A,
      enumerable: !1
    }
  }), e;
}
function I6(t, A, e) {
  if (Ct(t)) return g6(t, A, e);
  if (Ze(t)) return c6({
    type: "json_schema",
    json_schema: {
      ...e,
      name: A,
      strict: !0,
      schema: vd(t, {
        cycles: "ref",
        reused: "ref",
        override(r) {
          r.jsonSchema.title = A;
        }
      })
    }
  }, (r) => rp(t, JSON.parse(r)));
  throw new Error("Unsupported schema response format");
}
function C6(t, A) {
  if (A && typeof A == "object" && "images" in A && Array.isArray(A.images)) {
    const e = A.images.filter((r) => {
      var i;
      return typeof ((i = r == null ? void 0 : r.image_url) == null ? void 0 : i.url) == "string";
    }).map((r) => ({
      type: "image",
      url: r.image_url.url
    }));
    return [{
      type: "text",
      text: t
    }, ...e];
  }
  return t;
}
const l6 = {
  "gpt-4.1-nano": {
    maxInputTokens: 1047576,
    imageInputs: !0,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 32768,
    reasoningOutput: !1,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !0,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0,
    toolChoice: !0
  },
  "text-embedding-3-small": {
    maxInputTokens: 8191,
    imageInputs: !1,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 1536,
    reasoningOutput: !1,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !1,
    structuredOutput: !0,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0,
    toolChoice: !0
  },
  "gpt-4": {
    maxInputTokens: 8192,
    imageInputs: !1,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 8192,
    reasoningOutput: !1,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !0,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0,
    toolChoice: !0
  },
  "o1-pro": {
    maxInputTokens: 2e5,
    imageInputs: !0,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 1e5,
    reasoningOutput: !0,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !0,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0,
    toolChoice: !0
  },
  "gpt-4o-2024-05-13": {
    maxInputTokens: 128e3,
    imageInputs: !0,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 4096,
    reasoningOutput: !1,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !0,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0,
    toolChoice: !0
  },
  "gpt-4o-2024-08-06": {
    maxInputTokens: 128e3,
    imageInputs: !0,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 16384,
    reasoningOutput: !1,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !0,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0,
    toolChoice: !0
  },
  "gpt-4.1-mini": {
    maxInputTokens: 1047576,
    imageInputs: !0,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 32768,
    reasoningOutput: !1,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !0,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0,
    toolChoice: !0
  },
  "o3-deep-research": {
    maxInputTokens: 2e5,
    imageInputs: !0,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 1e5,
    reasoningOutput: !0,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !0,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0,
    toolChoice: !0
  },
  "gpt-3.5-turbo": {
    maxInputTokens: 16385,
    imageInputs: !1,
    audioInputs: !1,
    pdfInputs: !1,
    videoInputs: !1,
    maxOutputTokens: 4096,
    reasoningOutput: !1,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !1,
    structuredOutput: !1,
    imageUrlInputs: !1,
    pdfToolMessage: !1,
    imageToolMessage: !1,
    toolChoice: !0
  },
  "text-embedding-3-large": {
    maxInputTokens: 8191,
    imageInputs: !1,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 3072,
    reasoningOutput: !1,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !1,
    structuredOutput: !0,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0,
    toolChoice: !0
  },
  "gpt-4-turbo": {
    maxInputTokens: 128e3,
    imageInputs: !0,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 4096,
    reasoningOutput: !1,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !0,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0,
    toolChoice: !0
  },
  "o1-preview": {
    maxInputTokens: 128e3,
    imageInputs: !1,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 32768,
    reasoningOutput: !0,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !1,
    structuredOutput: !0,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0,
    toolChoice: !0
  },
  "o3-mini": {
    maxInputTokens: 2e5,
    imageInputs: !1,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 1e5,
    reasoningOutput: !0,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !0,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0,
    toolChoice: !0
  },
  "codex-mini-latest": {
    maxInputTokens: 2e5,
    imageInputs: !1,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 1e5,
    reasoningOutput: !0,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !0,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0,
    toolChoice: !0
  },
  "gpt-5-nano": {
    maxInputTokens: 4e5,
    imageInputs: !0,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 128e3,
    reasoningOutput: !0,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !0,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0,
    toolChoice: !0
  },
  "gpt-5-codex": {
    maxInputTokens: 4e5,
    imageInputs: !0,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 128e3,
    reasoningOutput: !0,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !0,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0,
    toolChoice: !0
  },
  "gpt-4o": {
    maxInputTokens: 128e3,
    imageInputs: !0,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 16384,
    reasoningOutput: !1,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !0,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0,
    toolChoice: !0
  },
  "gpt-4.1": {
    maxInputTokens: 1047576,
    imageInputs: !0,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 32768,
    reasoningOutput: !1,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !0,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0,
    toolChoice: !0
  },
  "o4-mini": {
    maxInputTokens: 2e5,
    imageInputs: !0,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 1e5,
    reasoningOutput: !0,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !0,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0,
    toolChoice: !0
  },
  o1: {
    maxInputTokens: 2e5,
    imageInputs: !0,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 1e5,
    reasoningOutput: !0,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !0,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0,
    toolChoice: !0
  },
  "gpt-5-mini": {
    maxInputTokens: 4e5,
    imageInputs: !0,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 128e3,
    reasoningOutput: !0,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !0,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0,
    toolChoice: !0
  },
  "o1-mini": {
    maxInputTokens: 128e3,
    imageInputs: !1,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 65536,
    reasoningOutput: !0,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !1,
    structuredOutput: !0,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0,
    toolChoice: !0
  },
  "text-embedding-ada-002": {
    maxInputTokens: 8192,
    imageInputs: !1,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 1536,
    reasoningOutput: !1,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !1,
    structuredOutput: !0,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0,
    toolChoice: !0
  },
  "o3-pro": {
    maxInputTokens: 2e5,
    imageInputs: !0,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 1e5,
    reasoningOutput: !0,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !0,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0,
    toolChoice: !0
  },
  "gpt-4o-2024-11-20": {
    maxInputTokens: 128e3,
    imageInputs: !0,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 16384,
    reasoningOutput: !1,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !0,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0,
    toolChoice: !0
  },
  o3: {
    maxInputTokens: 2e5,
    imageInputs: !0,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 1e5,
    reasoningOutput: !0,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !0,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0,
    toolChoice: !0
  },
  "o4-mini-deep-research": {
    maxInputTokens: 2e5,
    imageInputs: !0,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 1e5,
    reasoningOutput: !0,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !0,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0,
    toolChoice: !0
  },
  "gpt-5-chat-latest": {
    maxInputTokens: 4e5,
    imageInputs: !0,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 128e3,
    reasoningOutput: !0,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !1,
    structuredOutput: !0,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0,
    toolChoice: !0
  },
  "gpt-4o-mini": {
    maxInputTokens: 128e3,
    imageInputs: !0,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 16384,
    reasoningOutput: !1,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !0,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0,
    toolChoice: !0
  },
  "gpt-5": {
    maxInputTokens: 4e5,
    imageInputs: !0,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 128e3,
    reasoningOutput: !0,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !0,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0,
    toolChoice: !0
  },
  "gpt-5-pro": {
    maxInputTokens: 4e5,
    imageInputs: !0,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 272e3,
    reasoningOutput: !0,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !0,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0,
    toolChoice: !0
  }
};
var B6 = l6, E6 = {};
fe(E6, {
  BasePromptValue: () => lp,
  ChatPromptValue: () => qG,
  ImagePromptValue: () => h6,
  StringPromptValue: () => YG
});
var lp = class extends Kc {
}, YG = class extends lp {
  constructor(A) {
    super({ value: A });
    R(this, "lc_namespace", ["langchain_core", "prompt_values"]);
    R(this, "lc_serializable", !0);
    R(this, "value");
    this.value = A;
  }
  static lc_name() {
    return "StringPromptValue";
  }
  toString() {
    return this.value;
  }
  toChatMessages() {
    return [new Tr(this.value)];
  }
}, qG = class extends lp {
  constructor(A) {
    Array.isArray(A) && (A = { messages: A });
    super(A);
    R(this, "lc_namespace", ["langchain_core", "prompt_values"]);
    R(this, "lc_serializable", !0);
    R(this, "messages");
    this.messages = A.messages;
  }
  static lc_name() {
    return "ChatPromptValue";
  }
  toString() {
    return R0(this.messages);
  }
  toChatMessages() {
    return this.messages;
  }
}, h6 = class extends lp {
  constructor(A) {
    "imageUrl" in A || (A = { imageUrl: A });
    super(A);
    R(this, "lc_namespace", ["langchain_core", "prompt_values"]);
    R(this, "lc_serializable", !0);
    R(this, "imageUrl");
    /** @ignore */
    R(this, "value");
    this.imageUrl = A.imageUrl;
  }
  static lc_name() {
    return "ImagePromptValue";
  }
  toString() {
    return this.imageUrl.url;
  }
  toChatMessages() {
    return [new Tr({ content: [{
      type: "image_url",
      image_url: {
        detail: this.imageUrl.detail,
        url: this.imageUrl.url
      }
    }] })];
  }
}, KA = "0123456789abcdef".split(""), Q6 = [
  -2147483648,
  8388608,
  32768,
  128
], ii = [
  24,
  16,
  8,
  0
], Dh = [
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
], wt = [];
function Mi(t, A) {
  A ? (wt[0] = wt[16] = wt[1] = wt[2] = wt[3] = wt[4] = wt[5] = wt[6] = wt[7] = wt[8] = wt[9] = wt[10] = wt[11] = wt[12] = wt[13] = wt[14] = wt[15] = 0, this.blocks = wt) : this.blocks = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
  ], t ? (this.h0 = 3238371032, this.h1 = 914150663, this.h2 = 812702999, this.h3 = 4144912697, this.h4 = 4290775857, this.h5 = 1750603025, this.h6 = 1694076839, this.h7 = 3204075428) : (this.h0 = 1779033703, this.h1 = 3144134277, this.h2 = 1013904242, this.h3 = 2773480762, this.h4 = 1359893119, this.h5 = 2600822924, this.h6 = 528734635, this.h7 = 1541459225), this.block = this.start = this.bytes = this.hBytes = 0, this.finalized = this.hashed = !1, this.first = !0, this.is224 = t;
}
Mi.prototype.update = function(t) {
  if (!this.finalized) {
    var A, e = typeof t;
    if (e !== "string") {
      if (e === "object") {
        if (t === null) throw new Error(ERROR);
        if (ARRAY_BUFFER && t.constructor === ArrayBuffer) t = new Uint8Array(t);
        else if (!Array.isArray(t) && (!ARRAY_BUFFER || !ArrayBuffer.isView(t)))
          throw new Error(ERROR);
      } else throw new Error(ERROR);
      A = !0;
    }
    for (var r, i = 0, n, s = t.length, a = this.blocks; i < s; ) {
      if (this.hashed && (this.hashed = !1, a[0] = this.block, this.block = a[16] = a[1] = a[2] = a[3] = a[4] = a[5] = a[6] = a[7] = a[8] = a[9] = a[10] = a[11] = a[12] = a[13] = a[14] = a[15] = 0), A) for (n = this.start; i < s && n < 64; ++i) a[n >>> 2] |= t[i] << ii[n++ & 3];
      else for (n = this.start; i < s && n < 64; ++i)
        r = t.charCodeAt(i), r < 128 ? a[n >>> 2] |= r << ii[n++ & 3] : r < 2048 ? (a[n >>> 2] |= (192 | r >>> 6) << ii[n++ & 3], a[n >>> 2] |= (128 | r & 63) << ii[n++ & 3]) : r < 55296 || r >= 57344 ? (a[n >>> 2] |= (224 | r >>> 12) << ii[n++ & 3], a[n >>> 2] |= (128 | r >>> 6 & 63) << ii[n++ & 3], a[n >>> 2] |= (128 | r & 63) << ii[n++ & 3]) : (r = 65536 + ((r & 1023) << 10 | t.charCodeAt(++i) & 1023), a[n >>> 2] |= (240 | r >>> 18) << ii[n++ & 3], a[n >>> 2] |= (128 | r >>> 12 & 63) << ii[n++ & 3], a[n >>> 2] |= (128 | r >>> 6 & 63) << ii[n++ & 3], a[n >>> 2] |= (128 | r & 63) << ii[n++ & 3]);
      this.lastByteIndex = n, this.bytes += n - this.start, n >= 64 ? (this.block = a[16], this.start = n - 64, this.hash(), this.hashed = !0) : this.start = n;
    }
    return this.bytes > 4294967295 && (this.hBytes += this.bytes / 4294967296 << 0, this.bytes = this.bytes % 4294967296), this;
  }
};
Mi.prototype.finalize = function() {
  if (!this.finalized) {
    this.finalized = !0;
    var t = this.blocks, A = this.lastByteIndex;
    t[16] = this.block, t[A >>> 2] |= Q6[A & 3], this.block = t[16], A >= 56 && (this.hashed || this.hash(), t[0] = this.block, t[16] = t[1] = t[2] = t[3] = t[4] = t[5] = t[6] = t[7] = t[8] = t[9] = t[10] = t[11] = t[12] = t[13] = t[14] = t[15] = 0), t[14] = this.hBytes << 3 | this.bytes >>> 29, t[15] = this.bytes << 3, this.hash();
  }
};
Mi.prototype.hash = function() {
  var t = this.h0, A = this.h1, e = this.h2, r = this.h3, i = this.h4, n = this.h5, s = this.h6, a = this.h7, g = this.blocks, o, u, I, c, C, E, l, B, h, Q, f;
  for (o = 16; o < 64; ++o)
    C = g[o - 15], u = (C >>> 7 | C << 25) ^ (C >>> 18 | C << 14) ^ C >>> 3, C = g[o - 2], I = (C >>> 17 | C << 15) ^ (C >>> 19 | C << 13) ^ C >>> 10, g[o] = g[o - 16] + u + g[o - 7] + I << 0;
  for (f = A & e, o = 0; o < 64; o += 4)
    this.first ? (this.is224 ? (B = 300032, C = g[0] - 1413257819, a = C - 150054599 << 0, r = C + 24177077 << 0) : (B = 704751109, C = g[0] - 210244248, a = C - 1521486534 << 0, r = C + 143694565 << 0), this.first = !1) : (u = (t >>> 2 | t << 30) ^ (t >>> 13 | t << 19) ^ (t >>> 22 | t << 10), I = (i >>> 6 | i << 26) ^ (i >>> 11 | i << 21) ^ (i >>> 25 | i << 7), B = t & A, c = B ^ t & e ^ f, l = i & n ^ ~i & s, C = a + I + l + Dh[o] + g[o], E = u + c, a = r + C << 0, r = C + E << 0), u = (r >>> 2 | r << 30) ^ (r >>> 13 | r << 19) ^ (r >>> 22 | r << 10), I = (a >>> 6 | a << 26) ^ (a >>> 11 | a << 21) ^ (a >>> 25 | a << 7), h = r & t, c = h ^ r & A ^ B, l = s & a ^ ~s & i, C = n + I + l + Dh[o + 1] + g[o + 1], E = u + c, s = e + C << 0, e = C + E << 0, u = (e >>> 2 | e << 30) ^ (e >>> 13 | e << 19) ^ (e >>> 22 | e << 10), I = (s >>> 6 | s << 26) ^ (s >>> 11 | s << 21) ^ (s >>> 25 | s << 7), Q = e & r, c = Q ^ e & t ^ h, l = n & s ^ ~n & a, C = i + I + l + Dh[o + 2] + g[o + 2], E = u + c, n = A + C << 0, A = C + E << 0, u = (A >>> 2 | A << 30) ^ (A >>> 13 | A << 19) ^ (A >>> 22 | A << 10), I = (n >>> 6 | n << 26) ^ (n >>> 11 | n << 21) ^ (n >>> 25 | n << 7), f = A & e, c = f ^ A & r ^ Q, l = n & s ^ ~n & a, C = i + I + l + Dh[o + 3] + g[o + 3], E = u + c, i = t + C << 0, t = C + E << 0, this.chromeBugWorkAround = !0;
  this.h0 = this.h0 + t << 0, this.h1 = this.h1 + A << 0, this.h2 = this.h2 + e << 0, this.h3 = this.h3 + r << 0, this.h4 = this.h4 + i << 0, this.h5 = this.h5 + n << 0, this.h6 = this.h6 + s << 0, this.h7 = this.h7 + a << 0;
};
Mi.prototype.hex = function() {
  this.finalize();
  var t = this.h0, A = this.h1, e = this.h2, r = this.h3, i = this.h4, n = this.h5, s = this.h6, a = this.h7, g = KA[t >>> 28 & 15] + KA[t >>> 24 & 15] + KA[t >>> 20 & 15] + KA[t >>> 16 & 15] + KA[t >>> 12 & 15] + KA[t >>> 8 & 15] + KA[t >>> 4 & 15] + KA[t & 15] + KA[A >>> 28 & 15] + KA[A >>> 24 & 15] + KA[A >>> 20 & 15] + KA[A >>> 16 & 15] + KA[A >>> 12 & 15] + KA[A >>> 8 & 15] + KA[A >>> 4 & 15] + KA[A & 15] + KA[e >>> 28 & 15] + KA[e >>> 24 & 15] + KA[e >>> 20 & 15] + KA[e >>> 16 & 15] + KA[e >>> 12 & 15] + KA[e >>> 8 & 15] + KA[e >>> 4 & 15] + KA[e & 15] + KA[r >>> 28 & 15] + KA[r >>> 24 & 15] + KA[r >>> 20 & 15] + KA[r >>> 16 & 15] + KA[r >>> 12 & 15] + KA[r >>> 8 & 15] + KA[r >>> 4 & 15] + KA[r & 15] + KA[i >>> 28 & 15] + KA[i >>> 24 & 15] + KA[i >>> 20 & 15] + KA[i >>> 16 & 15] + KA[i >>> 12 & 15] + KA[i >>> 8 & 15] + KA[i >>> 4 & 15] + KA[i & 15] + KA[n >>> 28 & 15] + KA[n >>> 24 & 15] + KA[n >>> 20 & 15] + KA[n >>> 16 & 15] + KA[n >>> 12 & 15] + KA[n >>> 8 & 15] + KA[n >>> 4 & 15] + KA[n & 15] + KA[s >>> 28 & 15] + KA[s >>> 24 & 15] + KA[s >>> 20 & 15] + KA[s >>> 16 & 15] + KA[s >>> 12 & 15] + KA[s >>> 8 & 15] + KA[s >>> 4 & 15] + KA[s & 15];
  return this.is224 || (g += KA[a >>> 28 & 15] + KA[a >>> 24 & 15] + KA[a >>> 20 & 15] + KA[a >>> 16 & 15] + KA[a >>> 12 & 15] + KA[a >>> 8 & 15] + KA[a >>> 4 & 15] + KA[a & 15]), g;
};
Mi.prototype.toString = Mi.prototype.hex;
Mi.prototype.digest = function() {
  this.finalize();
  var t = this.h0, A = this.h1, e = this.h2, r = this.h3, i = this.h4, n = this.h5, s = this.h6, a = this.h7, g = [
    t >>> 24 & 255,
    t >>> 16 & 255,
    t >>> 8 & 255,
    t & 255,
    A >>> 24 & 255,
    A >>> 16 & 255,
    A >>> 8 & 255,
    A & 255,
    e >>> 24 & 255,
    e >>> 16 & 255,
    e >>> 8 & 255,
    e & 255,
    r >>> 24 & 255,
    r >>> 16 & 255,
    r >>> 8 & 255,
    r & 255,
    i >>> 24 & 255,
    i >>> 16 & 255,
    i >>> 8 & 255,
    i & 255,
    n >>> 24 & 255,
    n >>> 16 & 255,
    n >>> 8 & 255,
    n & 255,
    s >>> 24 & 255,
    s >>> 16 & 255,
    s >>> 8 & 255,
    s & 255
  ];
  return this.is224 || g.push(a >>> 24 & 255, a >>> 16 & 255, a >>> 8 & 255, a & 255), g;
};
Mi.prototype.array = Mi.prototype.digest;
Mi.prototype.arrayBuffer = function() {
  this.finalize();
  var t = /* @__PURE__ */ new ArrayBuffer(this.is224 ? 28 : 32), A = new DataView(t);
  return A.setUint32(0, this.h0), A.setUint32(4, this.h1), A.setUint32(8, this.h2), A.setUint32(12, this.h3), A.setUint32(16, this.h4), A.setUint32(20, this.h5), A.setUint32(24, this.h6), this.is224 || A.setUint32(28, this.h7), t;
};
const jG = (...t) => new Mi(!1, !0).update(t.join("")).hex();
var d6 = {};
fe(d6, { sha256: () => jG });
var f6 = {};
fe(f6, {
  BaseCache: () => VG,
  InMemoryCache: () => ZG,
  defaultHashKeyEncoder: () => WG,
  deserializeStoredGeneration: () => p6,
  serializeGeneration: () => y6
});
const WG = (...t) => jG(t.join("_"));
function p6(t) {
  return t.message !== void 0 ? {
    text: t.text,
    message: b0(t.message)
  } : { text: t.text };
}
function y6(t) {
  const A = { text: t.text };
  return t.message !== void 0 && (A.message = t.message.toDict()), A;
}
var VG = class {
  constructor() {
    R(this, "keyEncoder", WG);
  }
  /**
  * Sets a custom key encoder function for the cache.
  * This function should take a prompt and an LLM key and return a string
  * that will be used as the cache key.
  * @param keyEncoderFn The custom key encoder function.
  */
  makeDefaultKeyEncoder(t) {
    this.keyEncoder = t;
  }
};
const w6 = /* @__PURE__ */ new Map();
var ZG = class XG extends VG {
  constructor(e) {
    super();
    R(this, "cache");
    this.cache = e ?? /* @__PURE__ */ new Map();
  }
  /**
  * Retrieves data from the cache using a prompt and an LLM key. If the
  * data is not found, it returns null.
  * @param prompt The prompt used to find the data.
  * @param llmKey The LLM key used to find the data.
  * @returns The data corresponding to the prompt and LLM key, or null if not found.
  */
  lookup(e, r) {
    return Promise.resolve(this.cache.get(this.keyEncoder(e, r)) ?? null);
  }
  /**
  * Updates the cache with new data using a prompt and an LLM key.
  * @param prompt The prompt used to store the data.
  * @param llmKey The LLM key used to store the data.
  * @param value The data to be stored.
  */
  async update(e, r, i) {
    this.cache.set(this.keyEncoder(e, r), i);
  }
  /**
  * Returns a global instance of InMemoryCache using a predefined global
  * map as the initial cache.
  * @returns A global instance of InMemoryCache.
  */
  static global() {
    return new XG(w6);
  }
}, Bp = {};
Bp.byteLength = S6;
Bp.toByteArray = k6;
Bp.fromByteArray = b6;
var on = [], Wr = [], m6 = typeof Uint8Array < "u" ? Uint8Array : Array, Qy = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var xg = 0, D6 = Qy.length; xg < D6; ++xg)
  on[xg] = Qy[xg], Wr[Qy.charCodeAt(xg)] = xg;
Wr[45] = 62;
Wr[95] = 63;
function zG(t) {
  var A = t.length;
  if (A % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var e = t.indexOf("=");
  e === -1 && (e = A);
  var r = e === A ? 0 : 4 - e % 4;
  return [e, r];
}
function S6(t) {
  var A = zG(t), e = A[0], r = A[1];
  return (e + r) * 3 / 4 - r;
}
function F6(t, A, e) {
  return (A + e) * 3 / 4 - e;
}
function k6(t) {
  var A, e = zG(t), r = e[0], i = e[1], n = new m6(F6(t, r, i)), s = 0, a = i > 0 ? r - 4 : r, g;
  for (g = 0; g < a; g += 4)
    A = Wr[t.charCodeAt(g)] << 18 | Wr[t.charCodeAt(g + 1)] << 12 | Wr[t.charCodeAt(g + 2)] << 6 | Wr[t.charCodeAt(g + 3)], n[s++] = A >> 16 & 255, n[s++] = A >> 8 & 255, n[s++] = A & 255;
  return i === 2 && (A = Wr[t.charCodeAt(g)] << 2 | Wr[t.charCodeAt(g + 1)] >> 4, n[s++] = A & 255), i === 1 && (A = Wr[t.charCodeAt(g)] << 10 | Wr[t.charCodeAt(g + 1)] << 4 | Wr[t.charCodeAt(g + 2)] >> 2, n[s++] = A >> 8 & 255, n[s++] = A & 255), n;
}
function v6(t) {
  return on[t >> 18 & 63] + on[t >> 12 & 63] + on[t >> 6 & 63] + on[t & 63];
}
function R6(t, A, e) {
  for (var r, i = [], n = A; n < e; n += 3)
    r = (t[n] << 16 & 16711680) + (t[n + 1] << 8 & 65280) + (t[n + 2] & 255), i.push(v6(r));
  return i.join("");
}
function b6(t) {
  for (var A, e = t.length, r = e % 3, i = [], n = 16383, s = 0, a = e - r; s < a; s += n)
    i.push(R6(t, s, s + n > a ? a : s + n));
  return r === 1 ? (A = t[e - 1], i.push(
    on[A >> 2] + on[A << 4 & 63] + "=="
  )) : r === 2 && (A = (t[e - 2] << 8) + t[e - 1], i.push(
    on[A >> 10] + on[A >> 4 & 63] + on[A << 2 & 63] + "="
  )), i.join("");
}
var M6 = Object.defineProperty, _6 = (t, A, e) => A in t ? M6(t, A, { enumerable: !0, configurable: !0, writable: !0, value: e }) : t[A] = e, N6 = (t, A, e) => (_6(t, A + "", e), e);
function L6(t, A) {
  let e = Array.from(
    { length: t.length },
    (r, i) => ({ start: i, end: i + 1 })
  );
  for (; e.length > 1; ) {
    let r = null;
    for (let i = 0; i < e.length - 1; i++) {
      const n = t.slice(e[i].start, e[i + 1].end), s = A.get(n.join(","));
      s != null && (r == null || s < r[0]) && (r = [s, i]);
    }
    if (r != null) {
      const i = r[1];
      e[i] = { start: e[i].start, end: e[i + 1].end }, e.splice(i + 1, 1);
    } else
      break;
  }
  return e;
}
function x6(t, A) {
  return t.length === 1 ? [A.get(t.join(","))] : L6(t, A).map((e) => A.get(t.slice(e.start, e.end).join(","))).filter((e) => e != null);
}
function G6(t) {
  return t.replace(/[\\^$*+?.()|[\]{}]/g, "\\$&");
}
var wm = class {
  constructor(t, A) {
    /** @internal */
    R(this, "specialTokens");
    /** @internal */
    R(this, "inverseSpecialTokens");
    /** @internal */
    R(this, "patStr");
    /** @internal */
    R(this, "textEncoder", new TextEncoder());
    /** @internal */
    R(this, "textDecoder", new TextDecoder("utf-8"));
    /** @internal */
    R(this, "rankMap", /* @__PURE__ */ new Map());
    /** @internal */
    R(this, "textMap", /* @__PURE__ */ new Map());
    this.patStr = t.pat_str;
    const e = t.bpe_ranks.split(`
`).filter(Boolean).reduce((r, i) => {
      const [n, s, ...a] = i.split(" "), g = Number.parseInt(s, 10);
      return a.forEach((o, u) => r[o] = g + u), r;
    }, {});
    for (const [r, i] of Object.entries(e)) {
      const n = Bp.toByteArray(r);
      this.rankMap.set(n.join(","), i), this.textMap.set(i, n);
    }
    this.specialTokens = { ...t.special_tokens, ...A }, this.inverseSpecialTokens = Object.entries(this.specialTokens).reduce((r, [i, n]) => (r[n] = this.textEncoder.encode(i), r), {});
  }
  encode(t, A = [], e = "all") {
    const r = new RegExp(this.patStr, "ug"), i = wm.specialTokenRegex(
      Object.keys(this.specialTokens)
    ), n = [], s = new Set(
      A === "all" ? Object.keys(this.specialTokens) : A
    ), a = new Set(
      e === "all" ? Object.keys(this.specialTokens).filter(
        (o) => !s.has(o)
      ) : e
    );
    if (a.size > 0) {
      const o = wm.specialTokenRegex([
        ...a
      ]), u = t.match(o);
      if (u != null)
        throw new Error(
          `The text contains a special token that is not allowed: ${u[0]}`
        );
    }
    let g = 0;
    for (; ; ) {
      let o = null, u = g;
      for (; i.lastIndex = u, o = i.exec(t), !(o == null || s.has(o[0])); )
        u = o.index + 1;
      const I = (o == null ? void 0 : o.index) ?? t.length;
      for (const C of t.substring(g, I).matchAll(r)) {
        const E = this.textEncoder.encode(C[0]), l = this.rankMap.get(E.join(","));
        if (l != null) {
          n.push(l);
          continue;
        }
        n.push(...x6(E, this.rankMap));
      }
      if (o == null)
        break;
      let c = this.specialTokens[o[0]];
      n.push(c), g = o.index + o[0].length;
    }
    return n;
  }
  decode(t) {
    const A = [];
    let e = 0;
    for (let n = 0; n < t.length; ++n) {
      const s = t[n], a = this.textMap.get(s) ?? this.inverseSpecialTokens[s];
      a != null && (A.push(a), e += a.length);
    }
    const r = new Uint8Array(e);
    let i = 0;
    for (const n of A)
      r.set(n, i), i += n.length;
    return this.textDecoder.decode(r);
  }
}, $G = wm;
N6($G, "specialTokenRegex", (t) => new RegExp(t.map((A) => G6(A)).join("|"), "g"));
function U6(t) {
  switch (t) {
    case "gpt2":
      return "gpt2";
    case "code-cushman-001":
    case "code-cushman-002":
    case "code-davinci-001":
    case "code-davinci-002":
    case "cushman-codex":
    case "davinci-codex":
    case "davinci-002":
    case "text-davinci-002":
    case "text-davinci-003":
      return "p50k_base";
    case "code-davinci-edit-001":
    case "text-davinci-edit-001":
      return "p50k_edit";
    case "ada":
    case "babbage":
    case "babbage-002":
    case "code-search-ada-code-001":
    case "code-search-babbage-code-001":
    case "curie":
    case "davinci":
    case "text-ada-001":
    case "text-babbage-001":
    case "text-curie-001":
    case "text-davinci-001":
    case "text-search-ada-doc-001":
    case "text-search-babbage-doc-001":
    case "text-search-curie-doc-001":
    case "text-search-davinci-doc-001":
    case "text-similarity-ada-001":
    case "text-similarity-babbage-001":
    case "text-similarity-curie-001":
    case "text-similarity-davinci-001":
      return "r50k_base";
    case "gpt-3.5-turbo-instruct-0914":
    case "gpt-3.5-turbo-instruct":
    case "gpt-3.5-turbo-16k-0613":
    case "gpt-3.5-turbo-16k":
    case "gpt-3.5-turbo-0613":
    case "gpt-3.5-turbo-0301":
    case "gpt-3.5-turbo":
    case "gpt-4-32k-0613":
    case "gpt-4-32k-0314":
    case "gpt-4-32k":
    case "gpt-4-0613":
    case "gpt-4-0314":
    case "gpt-4":
    case "gpt-3.5-turbo-1106":
    case "gpt-35-turbo":
    case "gpt-4-1106-preview":
    case "gpt-4-vision-preview":
    case "gpt-3.5-turbo-0125":
    case "gpt-4-turbo":
    case "gpt-4-turbo-2024-04-09":
    case "gpt-4-turbo-preview":
    case "gpt-4-0125-preview":
    case "text-embedding-ada-002":
    case "text-embedding-3-small":
    case "text-embedding-3-large":
      return "cl100k_base";
    case "gpt-4o":
    case "gpt-4o-2024-05-13":
    case "gpt-4o-2024-08-06":
    case "gpt-4o-2024-11-20":
    case "gpt-4o-mini-2024-07-18":
    case "gpt-4o-mini":
    case "gpt-4o-search-preview":
    case "gpt-4o-search-preview-2025-03-11":
    case "gpt-4o-mini-search-preview":
    case "gpt-4o-mini-search-preview-2025-03-11":
    case "gpt-4o-audio-preview":
    case "gpt-4o-audio-preview-2024-12-17":
    case "gpt-4o-audio-preview-2024-10-01":
    case "gpt-4o-mini-audio-preview":
    case "gpt-4o-mini-audio-preview-2024-12-17":
    case "o1":
    case "o1-2024-12-17":
    case "o1-mini":
    case "o1-mini-2024-09-12":
    case "o1-preview":
    case "o1-preview-2024-09-12":
    case "o1-pro":
    case "o1-pro-2025-03-19":
    case "o3":
    case "o3-2025-04-16":
    case "o3-mini":
    case "o3-mini-2025-01-31":
    case "o4-mini":
    case "o4-mini-2025-04-16":
    case "chatgpt-4o-latest":
    case "gpt-4o-realtime":
    case "gpt-4o-realtime-preview-2024-10-01":
    case "gpt-4o-realtime-preview-2024-12-17":
    case "gpt-4o-mini-realtime-preview":
    case "gpt-4o-mini-realtime-preview-2024-12-17":
    case "gpt-4.1":
    case "gpt-4.1-2025-04-14":
    case "gpt-4.1-mini":
    case "gpt-4.1-mini-2025-04-14":
    case "gpt-4.1-nano":
    case "gpt-4.1-nano-2025-04-14":
    case "gpt-4.5-preview":
    case "gpt-4.5-preview-2025-02-27":
    case "gpt-5":
    case "gpt-5-2025-08-07":
    case "gpt-5-nano":
    case "gpt-5-nano-2025-08-07":
    case "gpt-5-mini":
    case "gpt-5-mini-2025-08-07":
    case "gpt-5-chat-latest":
      return "o200k_base";
    default:
      throw new Error("Unknown model");
  }
}
var T6 = {};
fe(T6, {
  encodingForModel: () => ES,
  getEncoding: () => AU
});
const Sh = {}, K6 = /* @__PURE__ */ new UE({});
async function AU(t) {
  return t in Sh || (Sh[t] = K6.fetch(`https://tiktoken.pages.dev/js/${t}.json`).then((A) => A.json()).then((A) => new $G(A)).catch((A) => {
    throw delete Sh[t], A;
  })), await Sh[t];
}
async function ES(t) {
  return AU(U6(t));
}
var J6 = {};
fe(J6, {
  BaseLangChain: () => QS,
  BaseLanguageModel: () => dS,
  calculateMaxTokens: () => P6,
  getEmbeddingContextSize: () => H6,
  getModelContextSize: () => eU,
  getModelNameForTiktoken: () => Ep,
  isOpenAITool: () => hS
});
const Ep = (t) => t.startsWith("gpt-5") ? "gpt-5" : t.startsWith("gpt-3.5-turbo-16k") ? "gpt-3.5-turbo-16k" : t.startsWith("gpt-3.5-turbo-") ? "gpt-3.5-turbo" : t.startsWith("gpt-4-32k") ? "gpt-4-32k" : t.startsWith("gpt-4-") ? "gpt-4" : t.startsWith("gpt-4o") ? "gpt-4o" : t, H6 = (t) => {
  switch (t) {
    case "text-embedding-ada-002":
      return 8191;
    default:
      return 2046;
  }
}, eU = (t) => {
  switch (Ep(t)) {
    case "gpt-5":
    case "gpt-5-turbo":
    case "gpt-5-turbo-preview":
      return 4e5;
    case "gpt-4o":
    case "gpt-4o-mini":
    case "gpt-4o-2024-05-13":
    case "gpt-4o-2024-08-06":
      return 128e3;
    case "gpt-4-turbo":
    case "gpt-4-turbo-preview":
    case "gpt-4-turbo-2024-04-09":
    case "gpt-4-0125-preview":
    case "gpt-4-1106-preview":
      return 128e3;
    case "gpt-4-32k":
    case "gpt-4-32k-0314":
    case "gpt-4-32k-0613":
      return 32768;
    case "gpt-4":
    case "gpt-4-0314":
    case "gpt-4-0613":
      return 8192;
    case "gpt-3.5-turbo-16k":
    case "gpt-3.5-turbo-16k-0613":
      return 16384;
    case "gpt-3.5-turbo":
    case "gpt-3.5-turbo-0301":
    case "gpt-3.5-turbo-0613":
    case "gpt-3.5-turbo-1106":
    case "gpt-3.5-turbo-0125":
      return 4096;
    case "text-davinci-003":
    case "text-davinci-002":
      return 4097;
    case "text-davinci-001":
      return 2049;
    case "text-curie-001":
    case "text-babbage-001":
    case "text-ada-001":
      return 2048;
    case "code-davinci-002":
    case "code-davinci-001":
      return 8e3;
    case "code-cushman-001":
      return 2048;
    case "claude-3-5-sonnet-20241022":
    case "claude-3-5-sonnet-20240620":
    case "claude-3-opus-20240229":
    case "claude-3-sonnet-20240229":
    case "claude-3-haiku-20240307":
    case "claude-2.1":
      return 2e5;
    case "claude-2.0":
    case "claude-instant-1.2":
      return 1e5;
    case "gemini-1.5-pro":
    case "gemini-1.5-pro-latest":
    case "gemini-1.5-flash":
    case "gemini-1.5-flash-latest":
      return 1e6;
    case "gemini-pro":
    case "gemini-pro-vision":
      return 32768;
    default:
      return 4097;
  }
};
function hS(t) {
  return typeof t != "object" || !t ? !1 : !!("type" in t && t.type === "function" && "function" in t && typeof t.function == "object" && t.function && "name" in t.function && "parameters" in t.function);
}
const P6 = async ({ prompt: t, modelName: A }) => {
  let e;
  try {
    e = (await ES(Ep(A))).encode(t).length;
  } catch {
    console.warn("Failed to calculate number of tokens, falling back to approximate count"), e = Math.ceil(t.length / 4);
  }
  return eU(A) - e;
}, O6 = () => !1;
var QS = class extends rt {
  constructor(A) {
    super(A);
    /**
    * Whether to print out response text.
    */
    R(this, "verbose");
    R(this, "callbacks");
    R(this, "tags");
    R(this, "metadata");
    this.verbose = A.verbose ?? O6(), this.callbacks = A.callbacks, this.tags = A.tags ?? [], this.metadata = A.metadata ?? {};
  }
  get lc_attributes() {
    return {
      callbacks: void 0,
      verbose: void 0
    };
  }
}, dS = class extends QS {
  constructor({ callbacks: A, callbackManager: e, ...r }) {
    const { cache: i, ...n } = r;
    super({
      callbacks: A ?? e,
      ...n
    });
    /**
    * The async caller should be used by subclasses to make any async calls,
    * which will thus benefit from the concurrency and retry logic.
    */
    R(this, "caller");
    R(this, "cache");
    R(this, "_encoding");
    typeof i == "object" ? this.cache = i : i ? this.cache = ZG.global() : this.cache = void 0, this.caller = new UE(r ?? {});
  }
  /**
  * Keys that the language model accepts as call options.
  */
  get callKeys() {
    return [
      "stop",
      "timeout",
      "signal",
      "tags",
      "metadata",
      "callbacks"
    ];
  }
  /**
  * Get the number of tokens in the content.
  * @param content The content to get the number of tokens for.
  * @returns The number of tokens in the content.
  */
  async getNumTokens(A) {
    let e;
    typeof A == "string" ? e = A : e = A.map((i) => typeof i == "string" ? i : i.type === "text" && "text" in i ? i.text : "").join("");
    let r = Math.ceil(e.length / 4);
    if (!this._encoding) try {
      this._encoding = await ES("modelName" in this ? Ep(this.modelName) : "gpt2");
    } catch (i) {
      console.warn("Failed to calculate number of tokens, falling back to approximate count", i);
    }
    if (this._encoding) try {
      r = this._encoding.encode(e).length;
    } catch (i) {
      console.warn("Failed to calculate number of tokens, falling back to approximate count", i);
    }
    return r;
  }
  static _convertInputToPromptValue(A) {
    return typeof A == "string" ? new YG(A) : Array.isArray(A) ? new qG(A.map(GC)) : A;
  }
  /**
  * Get the identifying parameters of the LLM.
  */
  _identifyingParams() {
    return {};
  }
  /**
  * Create a unique cache key for a specific call to a specific language model.
  * @param callOptions Call options for the model
  * @returns A unique cache key.
  */
  _getSerializedCacheKeyParametersForCall({ config: A, ...e }) {
    const r = {
      ...this._identifyingParams(),
      ...e,
      _type: this._llmType(),
      _model: this._modelType()
    };
    return Object.entries(r).filter(([s, a]) => a !== void 0).map(([s, a]) => `${s}:${JSON.stringify(a)}`).sort().join(",");
  }
  /**
  * @deprecated
  * Return a json-like object representing this LLM.
  */
  serialize() {
    return {
      ...this._identifyingParams(),
      _type: this._llmType(),
      _model: this._modelType()
    };
  }
  /**
  * @deprecated
  * Load an LLM from a json-like object describing it.
  */
  static async deserialize(A) {
    throw new Error("Use .toJSON() instead");
  }
  /**
  * Return profiling information for the model.
  *
  * @returns {ModelProfile} An object describing the model's capabilities and constraints
  */
  get profile() {
    return {};
  }
}, Vc = class extends rt {
  constructor(A) {
    super(A);
    R(this, "lc_namespace", ["langchain_core", "runnables"]);
    R(this, "lc_serializable", !0);
    R(this, "func");
    A && (this.func = A.func);
  }
  static lc_name() {
    return "RunnablePassthrough";
  }
  async invoke(A, e) {
    const r = Se(e);
    return this.func && await this.func(A, r), this._callWithConfig((i) => Promise.resolve(i), A, r);
  }
  async *transform(A, e) {
    const r = Se(e);
    let i, n = !0;
    for await (const s of this._transformStreamWithConfig(A, (a) => a, r))
      if (yield s, n) if (i === void 0) i = s;
      else try {
        i = _a(i, s);
      } catch {
        i = void 0, n = !1;
      }
    this.func && i !== void 0 && await this.func(i, r);
  }
  /**
  * A runnable that assigns key-value pairs to the input.
  *
  * The example below shows how you could use it with an inline function.
  *
  * @example
  * ```typescript
  * const prompt =
  *   PromptTemplate.fromTemplate(`Write a SQL query to answer the question using the following schema: {schema}
  * Question: {question}
  * SQL Query:`);
  *
  * // The `RunnablePassthrough.assign()` is used here to passthrough the input from the `.invoke()`
  * // call (in this example it's the question), along with any inputs passed to the `.assign()` method.
  * // In this case, we're passing the schema.
  * const sqlQueryGeneratorChain = RunnableSequence.from([
  *   RunnablePassthrough.assign({
  *     schema: async () => db.getTableInfo(),
  *   }),
  *   prompt,
  *   new ChatOpenAI({ model: "gpt-4o-mini" }).withConfig({ stop: ["\nSQLResult:"] }),
  *   new StringOutputParser(),
  * ]);
  * const result = await sqlQueryGeneratorChain.invoke({
  *   question: "How many employees are there?",
  * });
  * ```
  */
  static assign(A) {
    return new uS(new uI({ steps: A }));
  }
};
const Y6 = (t) => t();
function dy(t) {
  const A = t.constructor;
  return new A({
    ...t,
    content: t.contentBlocks,
    response_metadata: {
      ...t.response_metadata,
      output_version: "v1"
    }
  });
}
var q6 = {};
fe(q6, {
  BaseChatModel: () => fS,
  SimpleChatModel: () => j6
});
function fy(t) {
  const A = [];
  for (const e of t) {
    let r = e;
    if (Array.isArray(e.content)) for (let i = 0; i < e.content.length; i++) {
      const n = e.content[i];
      (d0(n) || f0(n)) && r === e && (r = new e.constructor({
        ...r,
        content: [
          ...e.content.slice(0, i),
          CL(n),
          ...e.content.slice(i + 1)
        ]
      }));
    }
    A.push(r);
  }
  return A;
}
var fS = class to extends dS {
  constructor(e) {
    super(e);
    R(this, "lc_namespace", [
      "langchain",
      "chat_models",
      this._llmType()
    ]);
    R(this, "disableStreaming", !1);
    R(this, "outputVersion");
    this.outputVersion = Y6(() => {
      const r = e.outputVersion ?? hn("LC_OUTPUT_VERSION");
      return r && ["v0", "v1"].includes(r) ? r : "v0";
    });
  }
  get callKeys() {
    return [...super.callKeys, "outputVersion"];
  }
  _separateRunnableConfigFromCallOptionsCompat(e) {
    const [r, i] = super._separateRunnableConfigFromCallOptions(e);
    return i.signal = r.signal, [r, i];
  }
  /**
  * Invokes the chat model with a single input.
  * @param input The input for the language model.
  * @param options The call options.
  * @returns A Promise that resolves to a BaseMessageChunk.
  */
  async invoke(e, r) {
    const i = to._convertInputToPromptValue(e);
    return (await this.generatePrompt([i], r, r == null ? void 0 : r.callbacks)).generations[0][0].message;
  }
  async *_streamResponseChunks(e, r, i) {
    throw new Error("Not implemented.");
  }
  async *_streamIterator(e, r) {
    var i;
    if (this._streamResponseChunks === to.prototype._streamResponseChunks || this.disableStreaming) yield this.invoke(e, r);
    else {
      const s = to._convertInputToPromptValue(e).toChatMessages(), [a, g] = this._separateRunnableConfigFromCallOptionsCompat(r), o = {
        ...a.metadata,
        ...this.getLsParams(g)
      }, u = await fr.configure(a.callbacks, this.callbacks, a.tags, this.tags, o, this.metadata, { verbose: this.verbose }), I = {
        options: g,
        invocation_params: this == null ? void 0 : this.invocationParams(g),
        batch_size: 1
      }, c = g.outputVersion ?? this.outputVersion, C = await (u == null ? void 0 : u.handleChatModelStart(this.toJSON(), [fy(s)], a.runId, void 0, I, void 0, void 0, a.runName));
      let E, l;
      try {
        for await (const B of this._streamResponseChunks(s, g, C == null ? void 0 : C[0])) {
          if (B.message.id == null) {
            const h = (i = C == null ? void 0 : C.at(0)) == null ? void 0 : i.runId;
            h != null && B.message._updateId(`run-${h}`);
          }
          B.message.response_metadata = {
            ...B.generationInfo,
            ...B.message.response_metadata
          }, c === "v1" ? yield dy(B.message) : yield B.message, E ? E = E.concat(B) : E = B, Pw(B.message) && B.message.usage_metadata !== void 0 && (l = { tokenUsage: {
            promptTokens: B.message.usage_metadata.input_tokens,
            completionTokens: B.message.usage_metadata.output_tokens,
            totalTokens: B.message.usage_metadata.total_tokens
          } });
        }
      } catch (B) {
        throw await Promise.all((C ?? []).map((h) => h == null ? void 0 : h.handleLLMError(B))), B;
      }
      await Promise.all((C ?? []).map((B) => B == null ? void 0 : B.handleLLMEnd({
        generations: [[E]],
        llmOutput: l
      })));
    }
  }
  getLsParams(e) {
    const r = this.getName().startsWith("Chat") ? this.getName().replace("Chat", "") : this.getName();
    return {
      ls_model_type: "chat",
      ls_stop: e.stop,
      ls_provider: r
    };
  }
  /** @ignore */
  async _generateUncached(e, r, i, n) {
    var C, E;
    const s = e.map((l) => l.map(GC));
    let a;
    if (n !== void 0 && n.length === s.length) a = n;
    else {
      const l = {
        ...i.metadata,
        ...this.getLsParams(r)
      }, B = await fr.configure(i.callbacks, this.callbacks, i.tags, this.tags, l, this.metadata, { verbose: this.verbose }), h = {
        options: r,
        invocation_params: this == null ? void 0 : this.invocationParams(r),
        batch_size: 1
      };
      a = await (B == null ? void 0 : B.handleChatModelStart(this.toJSON(), s.map(fy), i.runId, void 0, h, void 0, void 0, i.runName));
    }
    const g = r.outputVersion ?? this.outputVersion, o = [], u = [];
    if (!!(a != null && a[0].handlers.find(_0)) && !this.disableStreaming && s.length === 1 && this._streamResponseChunks !== to.prototype._streamResponseChunks) try {
      const l = await this._streamResponseChunks(s[0], r, a == null ? void 0 : a[0]);
      let B, h;
      for await (const Q of l) {
        if (Q.message.id == null) {
          const f = (C = a == null ? void 0 : a.at(0)) == null ? void 0 : C.runId;
          f != null && Q.message._updateId(`run-${f}`);
        }
        B === void 0 ? B = Q : B = _a(B, Q), Pw(Q.message) && Q.message.usage_metadata !== void 0 && (h = { tokenUsage: {
          promptTokens: Q.message.usage_metadata.input_tokens,
          completionTokens: Q.message.usage_metadata.output_tokens,
          totalTokens: Q.message.usage_metadata.total_tokens
        } });
      }
      if (B === void 0) throw new Error("Received empty response from chat model call.");
      o.push([B]), await (a == null ? void 0 : a[0].handleLLMEnd({
        generations: o,
        llmOutput: h
      }));
    } catch (l) {
      throw await (a == null ? void 0 : a[0].handleLLMError(l)), l;
    }
    else {
      const l = await Promise.allSettled(s.map(async (B, h) => {
        const Q = await this._generate(B, {
          ...r,
          promptIndex: h
        }, a == null ? void 0 : a[h]);
        if (g === "v1") for (const f of Q.generations) f.message = dy(f.message);
        return Q;
      }));
      await Promise.all(l.map(async (B, h) => {
        var Q, f, p;
        if (B.status === "fulfilled") {
          const y = B.value;
          for (const m of y.generations) {
            if (m.message.id == null) {
              const S = (Q = a == null ? void 0 : a.at(0)) == null ? void 0 : Q.runId;
              S != null && m.message._updateId(`run-${S}`);
            }
            m.message.response_metadata = {
              ...m.generationInfo,
              ...m.message.response_metadata
            };
          }
          return y.generations.length === 1 && (y.generations[0].message.response_metadata = {
            ...y.llmOutput,
            ...y.generations[0].message.response_metadata
          }), o[h] = y.generations, u[h] = y.llmOutput, (f = a == null ? void 0 : a[h]) == null ? void 0 : f.handleLLMEnd({
            generations: [y.generations],
            llmOutput: y.llmOutput
          });
        } else
          return await ((p = a == null ? void 0 : a[h]) == null ? void 0 : p.handleLLMError(B.reason)), Promise.reject(B.reason);
      }));
    }
    const c = {
      generations: o,
      llmOutput: u.length ? (E = this._combineLLMOutput) == null ? void 0 : E.call(this, ...u) : void 0
    };
    return Object.defineProperty(c, $C, {
      value: a ? { runIds: a == null ? void 0 : a.map((l) => l.runId) } : void 0,
      configurable: !0
    }), c;
  }
  async _generateCached({ messages: e, cache: r, llmStringKey: i, parsedOptions: n, handledOptions: s }) {
    const a = e.map((Q) => Q.map(GC)), g = {
      ...s.metadata,
      ...this.getLsParams(n)
    }, o = await fr.configure(s.callbacks, this.callbacks, s.tags, this.tags, g, this.metadata, { verbose: this.verbose }), u = {
      options: n,
      invocation_params: this == null ? void 0 : this.invocationParams(n),
      batch_size: 1
    }, I = await (o == null ? void 0 : o.handleChatModelStart(this.toJSON(), a.map(fy), s.runId, void 0, u, void 0, void 0, s.runName)), c = [], E = (await Promise.allSettled(a.map(async (Q, f) => {
      const p = to._convertInputToPromptValue(Q).toString(), y = await r.lookup(p, i);
      return y == null && c.push(f), y;
    }))).map((Q, f) => ({
      result: Q,
      runManager: I == null ? void 0 : I[f]
    })).filter(({ result: Q }) => Q.status === "fulfilled" && Q.value != null || Q.status === "rejected"), l = n.outputVersion ?? this.outputVersion, B = [];
    await Promise.all(E.map(async ({ result: Q, runManager: f }, p) => {
      if (Q.status === "fulfilled") {
        const y = Q.value;
        return B[p] = y.map((m) => ("message" in m && wa(m.message) && Yf(m.message) && (m.message.usage_metadata = {
          input_tokens: 0,
          output_tokens: 0,
          total_tokens: 0
        }, l === "v1" && (m.message = dy(m.message))), m.generationInfo = {
          ...m.generationInfo,
          tokenUsage: {}
        }, m)), y.length && await (f == null ? void 0 : f.handleLLMNewToken(y[0].text)), f == null ? void 0 : f.handleLLMEnd({ generations: [y] }, void 0, void 0, void 0, { cached: !0 });
      } else
        return await (f == null ? void 0 : f.handleLLMError(Q.reason, void 0, void 0, void 0, { cached: !0 })), Promise.reject(Q.reason);
    }));
    const h = {
      generations: B,
      missingPromptIndices: c,
      startedRunManagers: I
    };
    return Object.defineProperty(h, $C, {
      value: I ? { runIds: I == null ? void 0 : I.map((Q) => Q.runId) } : void 0,
      configurable: !0
    }), h;
  }
  /**
  * Generates chat based on the input messages.
  * @param messages An array of arrays of BaseMessage instances.
  * @param options The call options or an array of stop sequences.
  * @param callbacks The callbacks for the language model.
  * @returns A Promise that resolves to an LLMResult.
  */
  async generate(e, r, i) {
    let n;
    Array.isArray(r) ? n = { stop: r } : n = r;
    const s = e.map((l) => l.map(GC)), [a, g] = this._separateRunnableConfigFromCallOptionsCompat(n);
    if (a.callbacks = a.callbacks ?? i, !this.cache) return this._generateUncached(s, g, a);
    const { cache: o } = this, u = this._getSerializedCacheKeyParametersForCall(g), { generations: I, missingPromptIndices: c, startedRunManagers: C } = await this._generateCached({
      messages: s,
      cache: o,
      llmStringKey: u,
      parsedOptions: g,
      handledOptions: a
    });
    let E = {};
    if (c.length > 0) {
      const l = await this._generateUncached(c.map((B) => s[B]), g, a, C !== void 0 ? c.map((B) => C == null ? void 0 : C[B]) : void 0);
      await Promise.all(l.generations.map(async (B, h) => {
        const Q = c[h];
        I[Q] = B;
        const f = to._convertInputToPromptValue(s[Q]).toString();
        return o.update(f, u, B);
      })), E = l.llmOutput ?? {};
    }
    return {
      generations: I,
      llmOutput: E
    };
  }
  /**
  * Get the parameters used to invoke the model
  */
  invocationParams(e) {
    return {};
  }
  _modelType() {
    return "base_chat_model";
  }
  /**
  * Generates a prompt based on the input prompt values.
  * @param promptValues An array of BasePromptValue instances.
  * @param options The call options or an array of stop sequences.
  * @param callbacks The callbacks for the language model.
  * @returns A Promise that resolves to an LLMResult.
  */
  async generatePrompt(e, r, i) {
    const n = e.map((s) => s.toChatMessages());
    return this.generate(n, r, i);
  }
  withStructuredOutput(e, r) {
    if (typeof this.bindTools != "function") throw new Error('Chat model must implement ".bindTools()" to use withStructuredOutput.');
    if (r != null && r.strict) throw new Error('"strict" mode is not supported for this model by default.');
    const i = e, n = r == null ? void 0 : r.name, s = gp(i) ?? "A function available to call.", a = r == null ? void 0 : r.method, g = r == null ? void 0 : r.includeRaw;
    if (a === "jsonMode") throw new Error('Base withStructuredOutput implementation only supports "functionCalling" as a method.');
    let o = n ?? "extract", u;
    In(i) ? u = [{
      type: "function",
      function: {
        name: o,
        description: s,
        parameters: Cn(i)
      }
    }] : ("name" in i && (o = i.name), u = [{
      type: "function",
      function: {
        name: o,
        description: s,
        parameters: i
      }
    }]);
    const I = this.bindTools(u), c = ps.from((B) => {
      if (!kn.isInstance(B)) throw new Error("Input is not an AIMessageChunk.");
      if (!B.tool_calls || B.tool_calls.length === 0) throw new Error("No tool calls found in the response.");
      const h = B.tool_calls.find((Q) => Q.name === o);
      if (!h) throw new Error(`No tool call found with name ${o}.`);
      return h.args;
    });
    if (!g) return I.pipe(c).withConfig({ runName: "StructuredOutput" });
    const C = Vc.assign({ parsed: (B, h) => c.invoke(B.raw, h) }), E = Vc.assign({ parsed: () => null }), l = C.withFallbacks({ fallbacks: [E] });
    return TE.from([{ raw: I }, l]).withConfig({ runName: "StructuredOutputRunnable" });
  }
}, j6 = class extends fS {
  async _generate(t, A, e) {
    const r = await this._call(t, A, e), i = new jt(r);
    if (typeof i.content != "string") throw new Error("Cannot generate with a simple chat model when output is not a string.");
    return { generations: [{
      text: i.content,
      message: i
    }] };
  }
}, W6 = class extends rt {
  constructor(A) {
    super(A);
    R(this, "lc_namespace", ["langchain_core", "runnables"]);
    R(this, "lc_serializable", !0);
    R(this, "runnables");
    this.runnables = A.runnables;
  }
  static lc_name() {
    return "RouterRunnable";
  }
  async invoke(A, e) {
    const { key: r, input: i } = A, n = this.runnables[r];
    if (n === void 0) throw new Error(`No runnable associated with key "${r}".`);
    return n.invoke(i, Se(e));
  }
  async batch(A, e, r) {
    var c;
    const i = A.map((C) => C.key), n = A.map((C) => C.input);
    if (i.find((C) => this.runnables[C] === void 0) !== void 0) throw new Error("One or more keys do not have a corresponding runnable.");
    const a = i.map((C) => this.runnables[C]), g = this._getOptionsList(e ?? {}, A.length), o = ((c = g[0]) == null ? void 0 : c.maxConcurrency) ?? (r == null ? void 0 : r.maxConcurrency), u = o && o > 0 ? o : A.length, I = [];
    for (let C = 0; C < n.length; C += u) {
      const E = n.slice(C, C + u).map((B, h) => a[h].invoke(B, g[h])), l = await Promise.all(E);
      I.push(l);
    }
    return I.flat();
  }
  async stream(A, e) {
    const { key: r, input: i } = A, n = this.runnables[r];
    if (n === void 0) throw new Error(`No runnable associated with key "${r}".`);
    return n.stream(i, e);
  }
}, V6 = class extends rt {
  constructor(A) {
    super(A);
    R(this, "lc_namespace", ["langchain_core", "runnables"]);
    R(this, "lc_serializable", !0);
    R(this, "default");
    R(this, "branches");
    this.branches = A.branches, this.default = A.default;
  }
  static lc_name() {
    return "RunnableBranch";
  }
  /**
  * Convenience method for instantiating a RunnableBranch from
  * RunnableLikes (objects, functions, or Runnables).
  *
  * Each item in the input except for the last one should be a
  * tuple with two items. The first is a "condition" RunnableLike that
  * returns "true" if the second RunnableLike in the tuple should run.
  *
  * The final item in the input should be a RunnableLike that acts as a
  * default branch if no other branches match.
  *
  * @example
  * ```ts
  * import { RunnableBranch } from "@langchain/core/runnables";
  *
  * const branch = RunnableBranch.from([
  *   [(x: number) => x > 0, (x: number) => x + 1],
  *   [(x: number) => x < 0, (x: number) => x - 1],
  *   (x: number) => x
  * ]);
  * ```
  * @param branches An array where the every item except the last is a tuple of [condition, runnable]
  *   pairs. The last item is a default runnable which is invoked if no other condition matches.
  * @returns A new RunnableBranch.
  */
  static from(A) {
    if (A.length < 1) throw new Error("RunnableBranch requires at least one branch");
    const r = A.slice(0, -1).map(([n, s]) => [ki(n), ki(s)]), i = ki(A[A.length - 1]);
    return new this({
      branches: r,
      default: i
    });
  }
  async _invoke(A, e, r) {
    let i;
    for (let n = 0; n < this.branches.length; n += 1) {
      const [s, a] = this.branches[n];
      if (await s.invoke(A, Ye(e, { callbacks: r == null ? void 0 : r.getChild(`condition:${n + 1}`) }))) {
        i = await a.invoke(A, Ye(e, { callbacks: r == null ? void 0 : r.getChild(`branch:${n + 1}`) }));
        break;
      }
    }
    return i || (i = await this.default.invoke(A, Ye(e, { callbacks: r == null ? void 0 : r.getChild("branch:default") }))), i;
  }
  async invoke(A, e = {}) {
    return this._callWithConfig(this._invoke, A, e);
  }
  async *_streamIterator(A, e) {
    const r = await Jr(e), i = await (r == null ? void 0 : r.handleChainStart(this.toJSON(), Qt(A, "input"), e == null ? void 0 : e.runId, void 0, void 0, void 0, e == null ? void 0 : e.runName));
    let n, s = !0, a;
    try {
      for (let g = 0; g < this.branches.length; g += 1) {
        const [o, u] = this.branches[g];
        if (await o.invoke(A, Ye(e, { callbacks: i == null ? void 0 : i.getChild(`condition:${g + 1}`) }))) {
          a = await u.stream(A, Ye(e, { callbacks: i == null ? void 0 : i.getChild(`branch:${g + 1}`) }));
          for await (const c of a)
            if (yield c, s) if (n === void 0) n = c;
            else try {
              n = _a(n, c);
            } catch {
              n = void 0, s = !1;
            }
          break;
        }
      }
      if (a === void 0) {
        a = await this.default.stream(A, Ye(e, { callbacks: i == null ? void 0 : i.getChild("branch:default") }));
        for await (const g of a)
          if (yield g, s) if (n === void 0) n = g;
          else try {
            n = _a(n, g);
          } catch {
            n = void 0, s = !1;
          }
      }
    } catch (g) {
      throw await (i == null ? void 0 : i.handleChainError(g)), g;
    }
    await (i == null ? void 0 : i.handleChainEnd(n ?? {}));
  }
}, Z6 = class extends Wc {
  constructor(A) {
    let e = ps.from((s, a) => this._enterHistory(s, a ?? {})).withConfig({ runName: "loadHistory" });
    const r = A.historyMessagesKey ?? A.inputMessagesKey;
    r && (e = Vc.assign({ [r]: e }).withConfig({ runName: "insertHistory" }));
    const i = e.pipe(A.runnable.withListeners({ onEnd: (s, a) => this._exitHistory(s, a ?? {}) })).withConfig({ runName: "RunnableWithMessageHistory" }), n = A.config ?? {};
    super({
      ...A,
      config: n,
      bound: i
    });
    R(this, "runnable");
    R(this, "inputMessagesKey");
    R(this, "outputMessagesKey");
    R(this, "historyMessagesKey");
    R(this, "getMessageHistory");
    this.runnable = A.runnable, this.getMessageHistory = A.getMessageHistory, this.inputMessagesKey = A.inputMessagesKey, this.outputMessagesKey = A.outputMessagesKey, this.historyMessagesKey = A.historyMessagesKey;
  }
  _getInputMessages(A) {
    let e;
    if (typeof A == "object" && !Array.isArray(A) && !wa(A)) {
      let r;
      this.inputMessagesKey ? r = this.inputMessagesKey : Object.keys(A).length === 1 ? r = Object.keys(A)[0] : r = "input", Array.isArray(A[r]) && Array.isArray(A[r][0]) ? e = A[r][0] : e = A[r];
    } else e = A;
    if (typeof e == "string") return [new Tr(e)];
    if (Array.isArray(e)) return e;
    if (wa(e)) return [e];
    throw new Error(`Expected a string, BaseMessage, or array of BaseMessages.
Got ${JSON.stringify(e, null, 2)}`);
  }
  _getOutputMessages(A) {
    let e;
    if (!Array.isArray(A) && !wa(A) && typeof A != "string") {
      let r;
      this.outputMessagesKey !== void 0 ? r = this.outputMessagesKey : Object.keys(A).length === 1 ? r = Object.keys(A)[0] : r = "output", A.generations !== void 0 ? e = A.generations[0][0].message : e = A[r];
    } else e = A;
    if (typeof e == "string") return [new jt(e)];
    if (Array.isArray(e)) return e;
    if (wa(e)) return [e];
    throw new Error(`Expected a string, BaseMessage, or array of BaseMessages. Received: ${JSON.stringify(e, null, 2)}`);
  }
  async _enterHistory(A, e) {
    var n;
    const i = await ((n = e == null ? void 0 : e.configurable) == null ? void 0 : n.messageHistory).getMessages();
    return this.historyMessagesKey === void 0 ? i.concat(this._getInputMessages(A)) : i;
  }
  async _exitHistory(A, e) {
    var g;
    const r = (g = e.configurable) == null ? void 0 : g.messageHistory;
    let i;
    Array.isArray(A.inputs) && Array.isArray(A.inputs[0]) ? i = A.inputs[0] : i = A.inputs;
    let n = this._getInputMessages(i);
    if (this.historyMessagesKey === void 0) {
      const o = await r.getMessages();
      n = n.slice(o.length);
    }
    const s = A.outputs;
    if (!s) throw new Error(`Output values from 'Run' undefined. Run: ${JSON.stringify(A, null, 2)}`);
    const a = this._getOutputMessages(s);
    await r.addMessages([...n, ...a]);
  }
  async _mergeConfig(...A) {
    const e = await super._mergeConfig(...A);
    if (!e.configurable || !e.configurable.sessionId) {
      const i = { [this.inputMessagesKey ?? "input"]: "foo" }, n = { configurable: { sessionId: "123" } };
      throw new Error(`sessionId is required. Pass it in as part of the config argument to .invoke() or .stream()
eg. chain.invoke(${JSON.stringify(i)}, ${JSON.stringify(n)})`);
    }
    const { sessionId: r } = e.configurable;
    return e.configurable.messageHistory = await this.getMessageHistory(r), e;
  }
}, X6 = {};
fe(X6, {
  RouterRunnable: () => W6,
  Runnable: () => rt,
  RunnableAssign: () => uS,
  RunnableBinding: () => Wc,
  RunnableBranch: () => V6,
  RunnableEach: () => RV,
  RunnableLambda: () => ps,
  RunnableMap: () => uI,
  RunnableParallel: () => _V,
  RunnablePassthrough: () => Vc,
  RunnablePick: () => RG,
  RunnableRetry: () => gS,
  RunnableSequence: () => TE,
  RunnableToolLike: () => dm,
  RunnableWithFallbacks: () => vG,
  RunnableWithMessageHistory: () => Z6,
  _coerceToRunnable: () => ki,
  ensureConfig: () => Se,
  getCallbackManagerForConfig: () => Jr,
  mergeConfigs: () => wd,
  patchConfig: () => Ye,
  pickRunnableConfigKeys: () => ls,
  raceWithSignal: () => Bs
});
var tU = class extends rt {
  /**
  * Parses the result of an LLM call with a given prompt. By default, it
  * simply calls `parseResult`.
  * @param generations The generations from an LLM call.
  * @param _prompt The prompt used in the LLM call.
  * @param callbacks Optional callbacks.
  * @returns A promise of the parsed output.
  */
  parseResultWithPrompt(t, A, e) {
    return this.parseResult(t, e);
  }
  _baseMessageToString(t) {
    return typeof t.content == "string" ? t.content : this._baseMessageContentToString(t.content);
  }
  _baseMessageContentToString(t) {
    return JSON.stringify(t);
  }
  /**
  * Calls the parser with a given input and optional configuration options.
  * If the input is a string, it creates a generation with the input as
  * text and calls `parseResult`. If the input is a `BaseMessage`, it
  * creates a generation with the input as a message and the content of the
  * input as text, and then calls `parseResult`.
  * @param input The input to the parser, which can be a string or a `BaseMessage`.
  * @param options Optional configuration options.
  * @returns A promise of the parsed output.
  */
  async invoke(t, A) {
    return typeof t == "string" ? this._callWithConfig(async (e, r) => this.parseResult([{ text: e }], r == null ? void 0 : r.callbacks), t, {
      ...A,
      runType: "parser"
    }) : this._callWithConfig(async (e, r) => this.parseResult([{
      message: e,
      text: this._baseMessageToString(e)
    }], r == null ? void 0 : r.callbacks), t, {
      ...A,
      runType: "parser"
    });
  }
}, hp = class extends tU {
  parseResult(t, A) {
    return this.parse(t[0].text, A);
  }
  async parseWithPrompt(t, A, e) {
    return this.parse(t, e);
  }
  /**
  * Return the string type key uniquely identifying this class of parser
  */
  _type() {
    throw new Error("_type not implemented");
  }
}, gs = class extends Error {
  constructor(A, e, r, i = !1) {
    super(A);
    R(this, "llmOutput");
    R(this, "observation");
    R(this, "sendToLLM");
    if (this.llmOutput = e, this.observation = r, this.sendToLLM = i, i && (r === void 0 || e === void 0))
      throw new Error("Arguments 'observation' & 'llmOutput' are required if 'sendToLlm' is true");
    ML(this, "OUTPUT_PARSING_FAILURE");
  }
}, HE = class extends hp {
  async *_transform(t) {
    for await (const A of t) typeof A == "string" ? yield this.parseResult([{ text: A }]) : yield this.parseResult([{
      message: A,
      text: this._baseMessageToString(A)
    }]);
  }
  /**
  * Transforms an asynchronous generator of input into an asynchronous
  * generator of parsed output.
  * @param inputGenerator An asynchronous generator of input.
  * @param options A configuration object.
  * @returns An asynchronous generator of parsed output.
  */
  async *transform(t, A) {
    yield* this._transformStreamWithConfig(t, this._transform.bind(this), {
      ...A,
      runType: "parser"
    });
  }
}, Qp = class extends HE {
  constructor(A) {
    super(A);
    R(this, "diff", !1);
    this.diff = (A == null ? void 0 : A.diff) ?? this.diff;
  }
  async *_transform(A) {
    let e, r;
    for await (const i of A) {
      if (typeof i != "string" && typeof i.content != "string") throw new Error("Cannot handle non-string output.");
      let n;
      if (S0(i)) {
        if (typeof i.content != "string") throw new Error("Cannot handle non-string message output.");
        n = new Pc({
          message: i,
          text: i.content
        });
      } else if (wa(i)) {
        if (typeof i.content != "string") throw new Error("Cannot handle non-string message output.");
        n = new Pc({
          message: fd(i),
          text: i.content
        });
      } else n = new Hc({ text: i });
      r === void 0 ? r = n : r = r.concat(n);
      const s = await this.parsePartialResult([r]);
      s != null && !ug(s, e) && (this.diff ? yield this._diff(e, s) : yield s, e = s);
    }
  }
  getFormatInstructions() {
    return "";
  }
}, z6 = {};
fe(z6, {
  applyPatch: () => Jc,
  compare: () => V0
});
var mm = class extends Qp {
  constructor() {
    super(...arguments);
    R(this, "lc_namespace", ["langchain_core", "output_parsers"]);
    R(this, "lc_serializable", !0);
  }
  static lc_name() {
    return "JsonOutputParser";
  }
  /** @internal */
  _concatOutputChunks(A, e) {
    return this.diff ? super._concatOutputChunks(A, e) : e;
  }
  _diff(A, e) {
    if (e)
      return A ? V0(A, e) : [{
        op: "replace",
        path: "",
        value: e
      }];
  }
  async parsePartialResult(A) {
    return Hw(A[0].text);
  }
  async parse(A) {
    return Hw(A, JSON.parse);
  }
  getFormatInstructions() {
    return "";
  }
}, $6 = class extends HE {
  constructor() {
    super(...arguments);
    R(this, "lc_namespace", [
      "langchain_core",
      "output_parsers",
      "bytes"
    ]);
    R(this, "lc_serializable", !0);
    R(this, "textEncoder", new TextEncoder());
  }
  static lc_name() {
    return "BytesOutputParser";
  }
  parse(A) {
    return Promise.resolve(this.textEncoder.encode(A));
  }
  getFormatInstructions() {
    return "";
  }
}, PE = class extends HE {
  constructor() {
    super(...arguments);
    R(this, "re");
  }
  async *_transform(A) {
    let e = "";
    for await (const r of A)
      if (typeof r == "string" ? e += r : e += r.content, this.re) {
        const i = [...e.matchAll(this.re)];
        if (i.length > 1) {
          let n = 0;
          for (const s of i.slice(0, -1))
            yield [s[1]], n += (s.index ?? 0) + s[0].length;
          e = e.slice(n);
        }
      } else {
        const i = await this.parse(e);
        if (i.length > 1) {
          for (const n of i.slice(0, -1)) yield [n];
          e = i[i.length - 1];
        }
      }
    for (const r of await this.parse(e)) yield [r];
  }
}, AX = class extends PE {
  constructor() {
    super(...arguments);
    R(this, "lc_namespace", [
      "langchain_core",
      "output_parsers",
      "list"
    ]);
    R(this, "lc_serializable", !0);
  }
  static lc_name() {
    return "CommaSeparatedListOutputParser";
  }
  /**
  * Parses the given text into an array of strings, using a comma as the
  * separator. If the parsing fails, throws an OutputParserException.
  * @param text The text to parse.
  * @returns An array of strings obtained by splitting the input text at each comma.
  */
  async parse(A) {
    try {
      return A.trim().split(",").map((e) => e.trim());
    } catch {
      throw new gs(`Could not parse output: ${A}`, A);
    }
  }
  /**
  * Provides instructions on the expected format of the response for the
  * CommaSeparatedListOutputParser.
  * @returns A string containing instructions on the expected format of the response.
  */
  getFormatInstructions() {
    return "Your response should be a list of comma separated values, eg: `foo, bar, baz`";
  }
}, eX = class extends PE {
  constructor({ length: A, separator: e }) {
    super(...arguments);
    R(this, "lc_namespace", [
      "langchain_core",
      "output_parsers",
      "list"
    ]);
    R(this, "length");
    R(this, "separator");
    this.length = A, this.separator = e || ",";
  }
  /**
  * Parses the given text into an array of strings, using the specified
  * separator. If the parsing fails or the number of items in the list
  * doesn't match the expected length, throws an OutputParserException.
  * @param text The text to parse.
  * @returns An array of strings obtained by splitting the input text at each occurrence of the specified separator.
  */
  async parse(A) {
    try {
      const e = A.trim().split(this.separator).map((r) => r.trim());
      if (this.length !== void 0 && e.length !== this.length) throw new gs(`Incorrect number of items. Expected ${this.length}, got ${e.length}.`);
      return e;
    } catch (e) {
      throw Object.getPrototypeOf(e) === gs.prototype ? e : new gs(`Could not parse output: ${A}`);
    }
  }
  /**
  * Provides instructions on the expected format of the response for the
  * CustomListOutputParser, including the number of items and the
  * separator.
  * @returns A string containing instructions on the expected format of the response.
  */
  getFormatInstructions() {
    return `Your response should be a list of ${this.length === void 0 ? "" : `${this.length} `}items separated by "${this.separator}" (eg: \`foo${this.separator} bar${this.separator} baz\`)`;
  }
}, tX = class extends PE {
  constructor() {
    super(...arguments);
    R(this, "lc_namespace", [
      "langchain_core",
      "output_parsers",
      "list"
    ]);
    R(this, "lc_serializable", !0);
    R(this, "re", /\d+\.\s([^\n]+)/g);
  }
  static lc_name() {
    return "NumberedListOutputParser";
  }
  getFormatInstructions() {
    return `Your response should be a numbered list with each item on a new line. For example: 

1. foo

2. bar

3. baz`;
  }
  async parse(A) {
    return [...A.matchAll(this.re) ?? []].map((e) => e[1]);
  }
}, rX = class extends PE {
  constructor() {
    super(...arguments);
    R(this, "lc_namespace", [
      "langchain_core",
      "output_parsers",
      "list"
    ]);
    R(this, "lc_serializable", !0);
    R(this, "re", /^\s*[-*]\s([^\n]+)$/gm);
  }
  static lc_name() {
    return "NumberedListOutputParser";
  }
  getFormatInstructions() {
    return `Your response should be a numbered list with each item on a new line. For example: 

1. foo

2. bar

3. baz`;
  }
  async parse(A) {
    return [...A.matchAll(this.re) ?? []].map((e) => e[1]);
  }
}, iX = class extends HE {
  constructor() {
    super(...arguments);
    R(this, "lc_namespace", [
      "langchain_core",
      "output_parsers",
      "string"
    ]);
    R(this, "lc_serializable", !0);
  }
  static lc_name() {
    return "StrOutputParser";
  }
  /**
  * Parses a string output from an LLM call. This method is meant to be
  * implemented by subclasses to define how a string output from an LLM
  * should be parsed.
  * @param text The string output from an LLM call.
  * @param callbacks Optional callbacks.
  * @returns A promise of the parsed output.
  */
  parse(A) {
    return Promise.resolve(A);
  }
  getFormatInstructions() {
    return "";
  }
  _textContentToString(A) {
    return A.text;
  }
  _imageUrlContentToString(A) {
    throw new Error('Cannot coerce a multimodal "image_url" message part into a string.');
  }
  _messageContentToString(A) {
    switch (A.type) {
      case "text":
      case "text_delta":
        if ("text" in A) return this._textContentToString(A);
        break;
      case "image_url":
        if ("image_url" in A) return this._imageUrlContentToString(A);
        break;
      default:
        throw new Error(`Cannot coerce "${A.type}" message part into a string.`);
    }
    throw new Error(`Invalid content type: ${A.type}`);
  }
  _baseMessageContentToString(A) {
    return A.reduce((e, r) => e + this._messageContentToString(r), "");
  }
}, Jd = class extends hp {
  constructor(A) {
    super(A);
    R(this, "lc_namespace", [
      "langchain",
      "output_parsers",
      "structured"
    ]);
    this.schema = A;
  }
  static lc_name() {
    return "StructuredOutputParser";
  }
  toJSON() {
    return this.toJSONNotImplemented();
  }
  /**
  * Creates a new StructuredOutputParser from a Zod schema.
  * @param schema The Zod schema which the output should match
  * @returns A new instance of StructuredOutputParser.
  */
  static fromZodSchema(A) {
    return new this(A);
  }
  /**
  * Creates a new StructuredOutputParser from a set of names and
  * descriptions.
  * @param schemas An object where each key is a name and each value is a description
  * @returns A new instance of StructuredOutputParser.
  */
  static fromNamesAndDescriptions(A) {
    const e = Ip(Object.fromEntries(Object.entries(A).map(([r, i]) => [r, cp().describe(i)])));
    return new this(e);
  }
  /**
  * Returns a markdown code snippet with a JSON object formatted according
  * to the schema.
  * @param options Optional. The options for formatting the instructions
  * @returns A markdown code snippet with a JSON object formatted according to the schema.
  */
  getFormatInstructions() {
    return `You must format your output as a JSON value that adheres to a given "JSON Schema" instance.

"JSON Schema" is a declarative language that allows you to annotate and validate JSON documents.

For example, the example "JSON Schema" instance {{"properties": {{"foo": {{"description": "a list of test words", "type": "array", "items": {{"type": "string"}}}}}}, "required": ["foo"]}}
would match an object with one required property, "foo". The "type" property specifies "foo" must be an "array", and the "description" property semantically describes it as "a list of test words". The items within "foo" must be strings.
Thus, the object {{"foo": ["bar", "baz"]}} is a well-formatted instance of this example "JSON Schema". The object {{"properties": {{"foo": ["bar", "baz"]}}}} is not well-formatted.

Your output will be parsed and type-checked according to the provided schema instance, so make sure all fields in your output match the schema exactly and there are no trailing commas!

Here is the JSON Schema instance your output must adhere to. Include the enclosing markdown codeblock:
\`\`\`json
${JSON.stringify(Cn(this.schema))}
\`\`\`
`;
  }
  /**
  * Parses the given text according to the schema.
  * @param text The text to parse
  * @returns The parsed output.
  */
  async parse(A) {
    var e, r;
    try {
      const i = A.trim(), s = (((e = i.match(/^```(?:json)?\s*([\s\S]*?)```/)) == null ? void 0 : e[1]) || ((r = i.match(/```json\s*([\s\S]*?)```/)) == null ? void 0 : r[1]) || i).replace(/"([^"\\]*(\\.[^"\\]*)*)"/g, (a, g) => `"${g.replace(/\n/g, "\\n")}"`).replace(/\n/g, "");
      return await op(this.schema, JSON.parse(s));
    } catch (i) {
      throw new gs(`Failed to parse. Text: "${A}". Error: ${i}`, A);
    }
  }
}, rU = class extends Jd {
  static lc_name() {
    return "JsonMarkdownStructuredOutputParser";
  }
  getFormatInstructions(t) {
    const A = (t == null ? void 0 : t.interpolationDepth) ?? 1;
    if (A < 1) throw new Error("f string interpolation depth must be at least 1");
    return `Return a markdown code snippet with a JSON object formatted to look like:
\`\`\`json
${this._schemaToInstruction(Cn(this.schema)).replaceAll("{", "{".repeat(A)).replaceAll("}", "}".repeat(A))}
\`\`\``;
  }
  _schemaToInstruction(t, A = 2) {
    const e = t;
    if ("type" in e) {
      let r = !1, i;
      if (Array.isArray(e.type)) {
        const a = e.type.findIndex((g) => g === "null");
        a !== -1 && (r = !0, e.type.splice(a, 1)), i = e.type.join(" | ");
      } else i = e.type;
      if (e.type === "object" && e.properties) {
        const a = e.description ? ` // ${e.description}` : "";
        return `{
${Object.entries(e.properties).map(([o, u]) => {
          var c;
          const I = (c = e.required) != null && c.includes(o) ? "" : " (optional)";
          return `${" ".repeat(A)}"${o}": ${this._schemaToInstruction(u, A + 2)}${I}`;
        }).join(`
`)}
${" ".repeat(A - 2)}}${a}`;
      }
      if (e.type === "array" && e.items) {
        const a = e.description ? ` // ${e.description}` : "";
        return `array[
${" ".repeat(A)}${this._schemaToInstruction(e.items, A + 2)}
${" ".repeat(A - 2)}] ${a}`;
      }
      const n = r ? " (nullable)" : "", s = e.description ? ` // ${e.description}` : "";
      return `${i}${s}${n}`;
    }
    if ("anyOf" in e) return e.anyOf.map((r) => this._schemaToInstruction(r, A)).join(`
${" ".repeat(A - 2)}`);
    throw new Error("unsupported schema type");
  }
  static fromZodSchema(t) {
    return new this(t);
  }
  static fromNamesAndDescriptions(t) {
    const A = Ip(Object.fromEntries(Object.entries(t).map(([e, r]) => [e, cp().describe(r)])));
    return new this(A);
  }
}, nX = class extends hp {
  constructor({ inputSchema: A }) {
    super(...arguments);
    R(this, "structuredInputParser");
    this.structuredInputParser = new rU(A);
  }
  async parse(A) {
    let e;
    try {
      e = await this.structuredInputParser.parse(A);
    } catch (r) {
      throw new gs(`Failed to parse. Text: "${A}". Error: ${r}`, A);
    }
    return this.outputProcessor(e);
  }
  getFormatInstructions() {
    return this.structuredInputParser.getFormatInstructions();
  }
};
const sX = function() {
  const t = {};
  t.parser = function(U, N) {
    return new e(U, N);
  }, t.SAXParser = e, t.SAXStream = o, t.createStream = g, t.MAX_BUFFER_LENGTH = 64 * 1024;
  const A = [
    "comment",
    "sgmlDecl",
    "textNode",
    "tagName",
    "doctype",
    "procInstName",
    "procInstBody",
    "entity",
    "attribName",
    "attribValue",
    "cdata",
    "script"
  ];
  t.EVENTS = [
    "text",
    "processinginstruction",
    "sgmldeclaration",
    "doctype",
    "comment",
    "opentagstart",
    "attribute",
    "opentag",
    "closetag",
    "opencdata",
    "cdata",
    "closecdata",
    "error",
    "end",
    "ready",
    "script",
    "opennamespace",
    "closenamespace"
  ];
  function e(U, N) {
    if (!(this instanceof e)) return new e(U, N);
    var CA = this;
    i(CA), CA.q = CA.c = "", CA.bufferCheckPosition = t.MAX_BUFFER_LENGTH, CA.opt = N || {}, CA.opt.lowercase = CA.opt.lowercase || CA.opt.lowercasetags, CA.looseCase = CA.opt.lowercase ? "toLowerCase" : "toUpperCase", CA.tags = [], CA.closed = CA.closedRoot = CA.sawRoot = !1, CA.tag = CA.error = null, CA.strict = !!U, CA.noscript = !!(U || CA.opt.noscript), CA.state = w.BEGIN, CA.strictEntities = CA.opt.strictEntities, CA.ENTITIES = CA.strictEntities ? Object.create(t.XML_ENTITIES) : Object.create(t.ENTITIES), CA.attribList = [], CA.opt.xmlns && (CA.ns = Object.create(E)), CA.trackPosition = CA.opt.position !== !1, CA.trackPosition && (CA.position = CA.line = CA.column = 0), b(CA, "onready");
  }
  Object.create || (Object.create = function(U) {
    function N() {
    }
    N.prototype = U;
    var CA = new N();
    return CA;
  }), Object.keys || (Object.keys = function(U) {
    var N = [];
    for (var CA in U) U.hasOwnProperty(CA) && N.push(CA);
    return N;
  });
  function r(U) {
    for (var N = Math.max(t.MAX_BUFFER_LENGTH, 10), CA = 0, P = 0, XA = A.length; P < XA; P++) {
      var ue = U[A[P]].length;
      if (ue > N) switch (A[P]) {
        case "textNode":
          T(U);
          break;
        case "cdata":
          G(U, "oncdata", U.cdata), U.cdata = "";
          break;
        case "script":
          G(U, "onscript", U.script), U.script = "";
          break;
        default:
          H(U, "Max buffer length exceeded: " + A[P]);
      }
      CA = Math.max(CA, ue);
    }
    var Y = t.MAX_BUFFER_LENGTH - CA;
    U.bufferCheckPosition = Y + U.position;
  }
  function i(U) {
    for (var N = 0, CA = A.length; N < CA; N++) U[A[N]] = "";
  }
  function n(U) {
    T(U), U.cdata !== "" && (G(U, "oncdata", U.cdata), U.cdata = ""), U.script !== "" && (G(U, "onscript", U.script), U.script = "");
  }
  e.prototype = {
    end: function() {
      j(this);
    },
    write: zA,
    resume: function() {
      return this.error = null, this;
    },
    close: function() {
      return this.write(null);
    },
    flush: function() {
      n(this);
    }
  };
  var s = ReadableStream;
  s || (s = function() {
  });
  var a = t.EVENTS.filter(function(U) {
    return U !== "error" && U !== "end";
  });
  function g(U, N) {
    return new o(U, N);
  }
  function o(U, N) {
    if (!(this instanceof o)) return new o(U, N);
    s.apply(this), this._parser = new e(U, N), this.writable = !0, this.readable = !0;
    var CA = this;
    this._parser.onend = function() {
      CA.emit("end");
    }, this._parser.onerror = function(P) {
      CA.emit("error", P), CA._parser.error = null;
    }, this._decoder = null, a.forEach(function(P) {
      Object.defineProperty(CA, "on" + P, {
        get: function() {
          return CA._parser["on" + P];
        },
        set: function(XA) {
          if (!XA)
            return CA.removeAllListeners(P), CA._parser["on" + P] = XA, XA;
          CA.on(P, XA);
        },
        enumerable: !0,
        configurable: !1
      });
    });
  }
  o.prototype = Object.create(s.prototype, { constructor: { value: o } }), o.prototype.write = function(U) {
    return this._parser.write(U.toString()), this.emit("data", U), !0;
  }, o.prototype.end = function(U) {
    return U && U.length && this.write(U), this._parser.end(), !0;
  }, o.prototype.on = function(U, N) {
    var CA = this;
    return !CA._parser["on" + U] && a.indexOf(U) !== -1 && (CA._parser["on" + U] = function() {
      var P = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments);
      P.splice(0, 0, U), CA.emit.apply(CA, P);
    }), s.prototype.on.call(CA, U, N);
  };
  var u = "[CDATA[", I = "DOCTYPE", c = "http://www.w3.org/XML/1998/namespace", C = "http://www.w3.org/2000/xmlns/", E = {
    xml: c,
    xmlns: C
  }, l = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/, B = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/, h = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/, Q = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
  function f(U) {
    return U === " " || U === `
` || U === "\r" || U === "	";
  }
  function p(U) {
    return U === '"' || U === "'";
  }
  function y(U) {
    return U === ">" || f(U);
  }
  function m(U, N) {
    return U.test(N);
  }
  function S(U, N) {
    return !m(U, N);
  }
  var w = 0;
  t.STATE = {
    BEGIN: w++,
    BEGIN_WHITESPACE: w++,
    TEXT: w++,
    TEXT_ENTITY: w++,
    OPEN_WAKA: w++,
    SGML_DECL: w++,
    SGML_DECL_QUOTED: w++,
    DOCTYPE: w++,
    DOCTYPE_QUOTED: w++,
    DOCTYPE_DTD: w++,
    DOCTYPE_DTD_QUOTED: w++,
    COMMENT_STARTING: w++,
    COMMENT: w++,
    COMMENT_ENDING: w++,
    COMMENT_ENDED: w++,
    CDATA: w++,
    CDATA_ENDING: w++,
    CDATA_ENDING_2: w++,
    PROC_INST: w++,
    PROC_INST_BODY: w++,
    PROC_INST_ENDING: w++,
    OPEN_TAG: w++,
    OPEN_TAG_SLASH: w++,
    ATTRIB: w++,
    ATTRIB_NAME: w++,
    ATTRIB_NAME_SAW_WHITE: w++,
    ATTRIB_VALUE: w++,
    ATTRIB_VALUE_QUOTED: w++,
    ATTRIB_VALUE_CLOSED: w++,
    ATTRIB_VALUE_UNQUOTED: w++,
    ATTRIB_VALUE_ENTITY_Q: w++,
    ATTRIB_VALUE_ENTITY_U: w++,
    CLOSE_TAG: w++,
    CLOSE_TAG_SAW_WHITE: w++,
    SCRIPT: w++,
    SCRIPT_ENDING: w++
  }, t.XML_ENTITIES = {
    amp: "&",
    gt: ">",
    lt: "<",
    quot: '"',
    apos: "'"
  }, t.ENTITIES = {
    amp: "&",
    gt: ">",
    lt: "<",
    quot: '"',
    apos: "'",
    AElig: 198,
    Aacute: 193,
    Acirc: 194,
    Agrave: 192,
    Aring: 197,
    Atilde: 195,
    Auml: 196,
    Ccedil: 199,
    ETH: 208,
    Eacute: 201,
    Ecirc: 202,
    Egrave: 200,
    Euml: 203,
    Iacute: 205,
    Icirc: 206,
    Igrave: 204,
    Iuml: 207,
    Ntilde: 209,
    Oacute: 211,
    Ocirc: 212,
    Ograve: 210,
    Oslash: 216,
    Otilde: 213,
    Ouml: 214,
    THORN: 222,
    Uacute: 218,
    Ucirc: 219,
    Ugrave: 217,
    Uuml: 220,
    Yacute: 221,
    aacute: 225,
    acirc: 226,
    aelig: 230,
    agrave: 224,
    aring: 229,
    atilde: 227,
    auml: 228,
    ccedil: 231,
    eacute: 233,
    ecirc: 234,
    egrave: 232,
    eth: 240,
    euml: 235,
    iacute: 237,
    icirc: 238,
    igrave: 236,
    iuml: 239,
    ntilde: 241,
    oacute: 243,
    ocirc: 244,
    ograve: 242,
    oslash: 248,
    otilde: 245,
    ouml: 246,
    szlig: 223,
    thorn: 254,
    uacute: 250,
    ucirc: 251,
    ugrave: 249,
    uuml: 252,
    yacute: 253,
    yuml: 255,
    copy: 169,
    reg: 174,
    nbsp: 160,
    iexcl: 161,
    cent: 162,
    pound: 163,
    curren: 164,
    yen: 165,
    brvbar: 166,
    sect: 167,
    uml: 168,
    ordf: 170,
    laquo: 171,
    not: 172,
    shy: 173,
    macr: 175,
    deg: 176,
    plusmn: 177,
    sup1: 185,
    sup2: 178,
    sup3: 179,
    acute: 180,
    micro: 181,
    para: 182,
    middot: 183,
    cedil: 184,
    ordm: 186,
    raquo: 187,
    frac14: 188,
    frac12: 189,
    frac34: 190,
    iquest: 191,
    times: 215,
    divide: 247,
    OElig: 338,
    oelig: 339,
    Scaron: 352,
    scaron: 353,
    Yuml: 376,
    fnof: 402,
    circ: 710,
    tilde: 732,
    Alpha: 913,
    Beta: 914,
    Gamma: 915,
    Delta: 916,
    Epsilon: 917,
    Zeta: 918,
    Eta: 919,
    Theta: 920,
    Iota: 921,
    Kappa: 922,
    Lambda: 923,
    Mu: 924,
    Nu: 925,
    Xi: 926,
    Omicron: 927,
    Pi: 928,
    Rho: 929,
    Sigma: 931,
    Tau: 932,
    Upsilon: 933,
    Phi: 934,
    Chi: 935,
    Psi: 936,
    Omega: 937,
    alpha: 945,
    beta: 946,
    gamma: 947,
    delta: 948,
    epsilon: 949,
    zeta: 950,
    eta: 951,
    theta: 952,
    iota: 953,
    kappa: 954,
    lambda: 955,
    mu: 956,
    nu: 957,
    xi: 958,
    omicron: 959,
    pi: 960,
    rho: 961,
    sigmaf: 962,
    sigma: 963,
    tau: 964,
    upsilon: 965,
    phi: 966,
    chi: 967,
    psi: 968,
    omega: 969,
    thetasym: 977,
    upsih: 978,
    piv: 982,
    ensp: 8194,
    emsp: 8195,
    thinsp: 8201,
    zwnj: 8204,
    zwj: 8205,
    lrm: 8206,
    rlm: 8207,
    ndash: 8211,
    mdash: 8212,
    lsquo: 8216,
    rsquo: 8217,
    sbquo: 8218,
    ldquo: 8220,
    rdquo: 8221,
    bdquo: 8222,
    dagger: 8224,
    Dagger: 8225,
    bull: 8226,
    hellip: 8230,
    permil: 8240,
    prime: 8242,
    Prime: 8243,
    lsaquo: 8249,
    rsaquo: 8250,
    oline: 8254,
    frasl: 8260,
    euro: 8364,
    image: 8465,
    weierp: 8472,
    real: 8476,
    trade: 8482,
    alefsym: 8501,
    larr: 8592,
    uarr: 8593,
    rarr: 8594,
    darr: 8595,
    harr: 8596,
    crarr: 8629,
    lArr: 8656,
    uArr: 8657,
    rArr: 8658,
    dArr: 8659,
    hArr: 8660,
    forall: 8704,
    part: 8706,
    exist: 8707,
    empty: 8709,
    nabla: 8711,
    isin: 8712,
    notin: 8713,
    ni: 8715,
    prod: 8719,
    sum: 8721,
    minus: 8722,
    lowast: 8727,
    radic: 8730,
    prop: 8733,
    infin: 8734,
    ang: 8736,
    and: 8743,
    or: 8744,
    cap: 8745,
    cup: 8746,
    int: 8747,
    there4: 8756,
    sim: 8764,
    cong: 8773,
    asymp: 8776,
    ne: 8800,
    equiv: 8801,
    le: 8804,
    ge: 8805,
    sub: 8834,
    sup: 8835,
    nsub: 8836,
    sube: 8838,
    supe: 8839,
    oplus: 8853,
    otimes: 8855,
    perp: 8869,
    sdot: 8901,
    lceil: 8968,
    rceil: 8969,
    lfloor: 8970,
    rfloor: 8971,
    lang: 9001,
    rang: 9002,
    loz: 9674,
    spades: 9824,
    clubs: 9827,
    hearts: 9829,
    diams: 9830
  }, Object.keys(t.ENTITIES).forEach(function(U) {
    var N = t.ENTITIES[U], CA = typeof N == "number" ? String.fromCharCode(N) : N;
    t.ENTITIES[U] = CA;
  });
  for (var F in t.STATE) t.STATE[t.STATE[F]] = F;
  w = t.STATE;
  function b(U, N, CA) {
    U[N] && U[N](CA);
  }
  function G(U, N, CA) {
    U.textNode && T(U), b(U, N, CA);
  }
  function T(U) {
    U.textNode = K(U.opt, U.textNode), U.textNode && b(U, "ontext", U.textNode), U.textNode = "";
  }
  function K(U, N) {
    return U.trim && (N = N.trim()), U.normalize && (N = N.replace(/\s+/g, " ")), N;
  }
  function H(U, N) {
    return T(U), U.trackPosition && (N += `
Line: ` + U.line + `
Column: ` + U.column + `
Char: ` + U.c), N = new Error(N), U.error = N, b(U, "onerror", N), U;
  }
  function j(U) {
    return U.sawRoot && !U.closedRoot && eA(U, "Unclosed root tag"), U.state !== w.BEGIN && U.state !== w.BEGIN_WHITESPACE && U.state !== w.TEXT && H(U, "Unexpected end"), T(U), U.c = "", U.closed = !0, b(U, "onend"), e.call(U, U.strict, U.opt), U;
  }
  function eA(U, N) {
    if (typeof U != "object" || !(U instanceof e)) throw new Error("bad call to strictFail");
    U.strict && H(U, N);
  }
  function sA(U) {
    U.strict || (U.tagName = U.tagName[U.looseCase]());
    var N = U.tags[U.tags.length - 1] || U, CA = U.tag = {
      name: U.tagName,
      attributes: {}
    };
    U.opt.xmlns && (CA.ns = N.ns), U.attribList.length = 0, G(U, "onopentagstart", CA);
  }
  function uA(U, N) {
    var CA = U.indexOf(":"), P = CA < 0 ? ["", U] : U.split(":"), XA = P[0], ue = P[1];
    return N && U === "xmlns" && (XA = "xmlns", ue = ""), {
      prefix: XA,
      local: ue
    };
  }
  function rA(U) {
    if (U.strict || (U.attribName = U.attribName[U.looseCase]()), U.attribList.indexOf(U.attribName) !== -1 || U.tag.attributes.hasOwnProperty(U.attribName)) {
      U.attribName = U.attribValue = "";
      return;
    }
    if (U.opt.xmlns) {
      var N = uA(U.attribName, !0), CA = N.prefix, P = N.local;
      if (CA === "xmlns") if (P === "xml" && U.attribValue !== c) eA(U, "xml: prefix must be bound to " + c + `
Actual: ` + U.attribValue);
      else if (P === "xmlns" && U.attribValue !== C) eA(U, "xmlns: prefix must be bound to " + C + `
Actual: ` + U.attribValue);
      else {
        var XA = U.tag, ue = U.tags[U.tags.length - 1] || U;
        XA.ns === ue.ns && (XA.ns = Object.create(ue.ns)), XA.ns[P] = U.attribValue;
      }
      U.attribList.push([U.attribName, U.attribValue]);
    } else
      U.tag.attributes[U.attribName] = U.attribValue, G(U, "onattribute", {
        name: U.attribName,
        value: U.attribValue
      });
    U.attribName = U.attribValue = "";
  }
  function hA(U, N) {
    if (U.opt.xmlns) {
      var CA = U.tag, P = uA(U.tagName);
      CA.prefix = P.prefix, CA.local = P.local, CA.uri = CA.ns[P.prefix] || "", CA.prefix && !CA.uri && (eA(U, "Unbound namespace prefix: " + JSON.stringify(U.tagName)), CA.uri = P.prefix);
      var XA = U.tags[U.tags.length - 1] || U;
      CA.ns && XA.ns !== CA.ns && Object.keys(CA.ns).forEach(function(Ae) {
        G(U, "onopennamespace", {
          prefix: Ae,
          uri: CA.ns[Ae]
        });
      });
      for (var ue = 0, Y = U.attribList.length; ue < Y; ue++) {
        var L = U.attribList[ue], V = L[0], Z = L[1], cA = uA(V, !0), X = cA.prefix, z = cA.local, SA = X === "" ? "" : CA.ns[X] || "", aA = {
          name: V,
          value: Z,
          prefix: X,
          local: z,
          uri: SA
        };
        X && X !== "xmlns" && !SA && (eA(U, "Unbound namespace prefix: " + JSON.stringify(X)), aA.uri = X), U.tag.attributes[V] = aA, G(U, "onattribute", aA);
      }
      U.attribList.length = 0;
    }
    U.tag.isSelfClosing = !!N, U.sawRoot = !0, U.tags.push(U.tag), G(U, "onopentag", U.tag), N || (!U.noscript && U.tagName.toLowerCase() === "script" ? U.state = w.SCRIPT : U.state = w.TEXT, U.tag = null, U.tagName = ""), U.attribName = U.attribValue = "", U.attribList.length = 0;
  }
  function UA(U) {
    if (!U.tagName) {
      eA(U, "Weird empty close tag."), U.textNode += "</>", U.state = w.TEXT;
      return;
    }
    if (U.script) {
      if (U.tagName !== "script") {
        U.script += "</" + U.tagName + ">", U.tagName = "", U.state = w.SCRIPT;
        return;
      }
      G(U, "onscript", U.script), U.script = "";
    }
    var N = U.tags.length, CA = U.tagName;
    U.strict || (CA = CA[U.looseCase]());
    for (var P = CA; N--; ) {
      var XA = U.tags[N];
      if (XA.name !== P) eA(U, "Unexpected close tag");
      else break;
    }
    if (N < 0) {
      eA(U, "Unmatched closing tag: " + U.tagName), U.textNode += "</" + U.tagName + ">", U.state = w.TEXT;
      return;
    }
    U.tagName = CA;
    for (var ue = U.tags.length; ue-- > N; ) {
      var Y = U.tag = U.tags.pop();
      U.tagName = U.tag.name, G(U, "onclosetag", U.tagName);
      var L = {};
      for (var V in Y.ns) L[V] = Y.ns[V];
      var Z = U.tags[U.tags.length - 1] || U;
      U.opt.xmlns && Y.ns !== Z.ns && Object.keys(Y.ns).forEach(function(cA) {
        var X = Y.ns[cA];
        G(U, "onclosenamespace", {
          prefix: cA,
          uri: X
        });
      });
    }
    N === 0 && (U.closedRoot = !0), U.tagName = U.attribValue = U.attribName = "", U.attribList.length = 0, U.state = w.TEXT;
  }
  function iA(U) {
    var N = U.entity, CA = N.toLowerCase(), P, XA = "";
    return U.ENTITIES[N] ? U.ENTITIES[N] : U.ENTITIES[CA] ? U.ENTITIES[CA] : (N = CA, N.charAt(0) === "#" && (N.charAt(1) === "x" ? (N = N.slice(2), P = parseInt(N, 16), XA = P.toString(16)) : (N = N.slice(1), P = parseInt(N, 10), XA = P.toString(10))), N = N.replace(/^0+/, ""), isNaN(P) || XA.toLowerCase() !== N ? (eA(U, "Invalid character entity"), "&" + U.entity + ";") : String.fromCodePoint(P));
  }
  function wA(U, N) {
    N === "<" ? (U.state = w.OPEN_WAKA, U.startTagPosition = U.position) : f(N) || (eA(U, "Non-whitespace before first tag."), U.textNode = N, U.state = w.TEXT);
  }
  function Re(U, N) {
    var CA = "";
    return N < U.length && (CA = U.charAt(N)), CA;
  }
  function zA(U) {
    var N = this;
    if (this.error) throw this.error;
    if (N.closed) return H(N, "Cannot write after close. Assign an onready handler.");
    if (U === null) return j(N);
    typeof U == "object" && (U = U.toString());
    for (var CA = 0, P = ""; P = Re(U, CA++), N.c = P, !!P; )
      switch (N.trackPosition && (N.position++, P === `
` ? (N.line++, N.column = 0) : N.column++), N.state) {
        case w.BEGIN:
          if (N.state = w.BEGIN_WHITESPACE, P === "\uFEFF") continue;
          wA(N, P);
          continue;
        case w.BEGIN_WHITESPACE:
          wA(N, P);
          continue;
        case w.TEXT:
          if (N.sawRoot && !N.closedRoot) {
            for (var XA = CA - 1; P && P !== "<" && P !== "&"; )
              P = Re(U, CA++), P && N.trackPosition && (N.position++, P === `
` ? (N.line++, N.column = 0) : N.column++);
            N.textNode += U.substring(XA, CA - 1);
          }
          P === "<" && !(N.sawRoot && N.closedRoot && !N.strict) ? (N.state = w.OPEN_WAKA, N.startTagPosition = N.position) : (!f(P) && (!N.sawRoot || N.closedRoot) && eA(N, "Text data outside of root node."), P === "&" ? N.state = w.TEXT_ENTITY : N.textNode += P);
          continue;
        case w.SCRIPT:
          P === "<" ? N.state = w.SCRIPT_ENDING : N.script += P;
          continue;
        case w.SCRIPT_ENDING:
          P === "/" ? N.state = w.CLOSE_TAG : (N.script += "<" + P, N.state = w.SCRIPT);
          continue;
        case w.OPEN_WAKA:
          if (P === "!")
            N.state = w.SGML_DECL, N.sgmlDecl = "";
          else if (!f(P)) if (m(l, P))
            N.state = w.OPEN_TAG, N.tagName = P;
          else if (P === "/")
            N.state = w.CLOSE_TAG, N.tagName = "";
          else if (P === "?")
            N.state = w.PROC_INST, N.procInstName = N.procInstBody = "";
          else {
            if (eA(N, "Unencoded <"), N.startTagPosition + 1 < N.position) {
              var ue = N.position - N.startTagPosition;
              P = new Array(ue).join(" ") + P;
            }
            N.textNode += "<" + P, N.state = w.TEXT;
          }
          continue;
        case w.SGML_DECL:
          (N.sgmlDecl + P).toUpperCase() === u ? (G(N, "onopencdata"), N.state = w.CDATA, N.sgmlDecl = "", N.cdata = "") : N.sgmlDecl + P === "--" ? (N.state = w.COMMENT, N.comment = "", N.sgmlDecl = "") : (N.sgmlDecl + P).toUpperCase() === I ? (N.state = w.DOCTYPE, (N.doctype || N.sawRoot) && eA(N, "Inappropriately located doctype declaration"), N.doctype = "", N.sgmlDecl = "") : P === ">" ? (G(N, "onsgmldeclaration", N.sgmlDecl), N.sgmlDecl = "", N.state = w.TEXT) : (p(P) && (N.state = w.SGML_DECL_QUOTED), N.sgmlDecl += P);
          continue;
        case w.SGML_DECL_QUOTED:
          P === N.q && (N.state = w.SGML_DECL, N.q = ""), N.sgmlDecl += P;
          continue;
        case w.DOCTYPE:
          P === ">" ? (N.state = w.TEXT, G(N, "ondoctype", N.doctype), N.doctype = !0) : (N.doctype += P, P === "[" ? N.state = w.DOCTYPE_DTD : p(P) && (N.state = w.DOCTYPE_QUOTED, N.q = P));
          continue;
        case w.DOCTYPE_QUOTED:
          N.doctype += P, P === N.q && (N.q = "", N.state = w.DOCTYPE);
          continue;
        case w.DOCTYPE_DTD:
          N.doctype += P, P === "]" ? N.state = w.DOCTYPE : p(P) && (N.state = w.DOCTYPE_DTD_QUOTED, N.q = P);
          continue;
        case w.DOCTYPE_DTD_QUOTED:
          N.doctype += P, P === N.q && (N.state = w.DOCTYPE_DTD, N.q = "");
          continue;
        case w.COMMENT:
          P === "-" ? N.state = w.COMMENT_ENDING : N.comment += P;
          continue;
        case w.COMMENT_ENDING:
          P === "-" ? (N.state = w.COMMENT_ENDED, N.comment = K(N.opt, N.comment), N.comment && G(N, "oncomment", N.comment), N.comment = "") : (N.comment += "-" + P, N.state = w.COMMENT);
          continue;
        case w.COMMENT_ENDED:
          P !== ">" ? (eA(N, "Malformed comment"), N.comment += "--" + P, N.state = w.COMMENT) : N.state = w.TEXT;
          continue;
        case w.CDATA:
          P === "]" ? N.state = w.CDATA_ENDING : N.cdata += P;
          continue;
        case w.CDATA_ENDING:
          P === "]" ? N.state = w.CDATA_ENDING_2 : (N.cdata += "]" + P, N.state = w.CDATA);
          continue;
        case w.CDATA_ENDING_2:
          P === ">" ? (N.cdata && G(N, "oncdata", N.cdata), G(N, "onclosecdata"), N.cdata = "", N.state = w.TEXT) : P === "]" ? N.cdata += "]" : (N.cdata += "]]" + P, N.state = w.CDATA);
          continue;
        case w.PROC_INST:
          P === "?" ? N.state = w.PROC_INST_ENDING : f(P) ? N.state = w.PROC_INST_BODY : N.procInstName += P;
          continue;
        case w.PROC_INST_BODY:
          if (!N.procInstBody && f(P)) continue;
          P === "?" ? N.state = w.PROC_INST_ENDING : N.procInstBody += P;
          continue;
        case w.PROC_INST_ENDING:
          P === ">" ? (G(N, "onprocessinginstruction", {
            name: N.procInstName,
            body: N.procInstBody
          }), N.procInstName = N.procInstBody = "", N.state = w.TEXT) : (N.procInstBody += "?" + P, N.state = w.PROC_INST_BODY);
          continue;
        case w.OPEN_TAG:
          m(B, P) ? N.tagName += P : (sA(N), P === ">" ? hA(N) : P === "/" ? N.state = w.OPEN_TAG_SLASH : (f(P) || eA(N, "Invalid character in tag name"), N.state = w.ATTRIB));
          continue;
        case w.OPEN_TAG_SLASH:
          P === ">" ? (hA(N, !0), UA(N)) : (eA(N, "Forward-slash in opening tag not followed by >"), N.state = w.ATTRIB);
          continue;
        case w.ATTRIB:
          if (f(P)) continue;
          P === ">" ? hA(N) : P === "/" ? N.state = w.OPEN_TAG_SLASH : m(l, P) ? (N.attribName = P, N.attribValue = "", N.state = w.ATTRIB_NAME) : eA(N, "Invalid attribute name");
          continue;
        case w.ATTRIB_NAME:
          P === "=" ? N.state = w.ATTRIB_VALUE : P === ">" ? (eA(N, "Attribute without value"), N.attribValue = N.attribName, rA(N), hA(N)) : f(P) ? N.state = w.ATTRIB_NAME_SAW_WHITE : m(B, P) ? N.attribName += P : eA(N, "Invalid attribute name");
          continue;
        case w.ATTRIB_NAME_SAW_WHITE:
          if (P === "=") N.state = w.ATTRIB_VALUE;
          else {
            if (f(P)) continue;
            eA(N, "Attribute without value"), N.tag.attributes[N.attribName] = "", N.attribValue = "", G(N, "onattribute", {
              name: N.attribName,
              value: ""
            }), N.attribName = "", P === ">" ? hA(N) : m(l, P) ? (N.attribName = P, N.state = w.ATTRIB_NAME) : (eA(N, "Invalid attribute name"), N.state = w.ATTRIB);
          }
          continue;
        case w.ATTRIB_VALUE:
          if (f(P)) continue;
          p(P) ? (N.q = P, N.state = w.ATTRIB_VALUE_QUOTED) : (eA(N, "Unquoted attribute value"), N.state = w.ATTRIB_VALUE_UNQUOTED, N.attribValue = P);
          continue;
        case w.ATTRIB_VALUE_QUOTED:
          if (P !== N.q) {
            P === "&" ? N.state = w.ATTRIB_VALUE_ENTITY_Q : N.attribValue += P;
            continue;
          }
          rA(N), N.q = "", N.state = w.ATTRIB_VALUE_CLOSED;
          continue;
        case w.ATTRIB_VALUE_CLOSED:
          f(P) ? N.state = w.ATTRIB : P === ">" ? hA(N) : P === "/" ? N.state = w.OPEN_TAG_SLASH : m(l, P) ? (eA(N, "No whitespace between attributes"), N.attribName = P, N.attribValue = "", N.state = w.ATTRIB_NAME) : eA(N, "Invalid attribute name");
          continue;
        case w.ATTRIB_VALUE_UNQUOTED:
          if (!y(P)) {
            P === "&" ? N.state = w.ATTRIB_VALUE_ENTITY_U : N.attribValue += P;
            continue;
          }
          rA(N), P === ">" ? hA(N) : N.state = w.ATTRIB;
          continue;
        case w.CLOSE_TAG:
          if (N.tagName) P === ">" ? UA(N) : m(B, P) ? N.tagName += P : N.script ? (N.script += "</" + N.tagName, N.tagName = "", N.state = w.SCRIPT) : (f(P) || eA(N, "Invalid tagname in closing tag"), N.state = w.CLOSE_TAG_SAW_WHITE);
          else {
            if (f(P)) continue;
            S(l, P) ? N.script ? (N.script += "</" + P, N.state = w.SCRIPT) : eA(N, "Invalid tagname in closing tag.") : N.tagName = P;
          }
          continue;
        case w.CLOSE_TAG_SAW_WHITE:
          if (f(P)) continue;
          P === ">" ? UA(N) : eA(N, "Invalid characters in closing tag");
          continue;
        case w.TEXT_ENTITY:
        case w.ATTRIB_VALUE_ENTITY_Q:
        case w.ATTRIB_VALUE_ENTITY_U:
          var Y, L;
          switch (N.state) {
            case w.TEXT_ENTITY:
              Y = w.TEXT, L = "textNode";
              break;
            case w.ATTRIB_VALUE_ENTITY_Q:
              Y = w.ATTRIB_VALUE_QUOTED, L = "attribValue";
              break;
            case w.ATTRIB_VALUE_ENTITY_U:
              Y = w.ATTRIB_VALUE_UNQUOTED, L = "attribValue";
              break;
          }
          if (P === ";") if (N.opt.unparsedEntities) {
            var V = iA(N);
            N.entity = "", N.state = Y, N.write(V);
          } else
            N[L] += iA(N), N.entity = "", N.state = Y;
          else m(N.entity.length ? Q : h, P) ? N.entity += P : (eA(N, "Invalid character in entity name"), N[L] += "&" + N.entity + P, N.entity = "", N.state = Y);
          continue;
        default:
          throw new Error(N, "Unknown state: " + N.state);
      }
    return N.position >= N.bufferCheckPosition && r(N), N;
  }
  /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */
  return String.fromCodePoint || function() {
    var U = String.fromCharCode, N = Math.floor, CA = function() {
      var P = 16384, XA = [], ue, Y, L = -1, V = arguments.length;
      if (!V) return "";
      for (var Z = ""; ++L < V; ) {
        var cA = Number(arguments[L]);
        if (!isFinite(cA) || cA < 0 || cA > 1114111 || N(cA) !== cA) throw RangeError("Invalid code point: " + cA);
        cA <= 65535 ? XA.push(cA) : (cA -= 65536, ue = (cA >> 10) + 55296, Y = cA % 1024 + 56320, XA.push(ue, Y)), (L + 1 === V || XA.length > P) && (Z += U.apply(null, XA), XA.length = 0);
      }
      return Z;
    };
    Object.defineProperty ? Object.defineProperty(String, "fromCodePoint", {
      value: CA,
      configurable: !0,
      writable: !0
    }) : String.fromCodePoint = CA;
  }(), t;
}, aX = sX(), Dm = `The output should be formatted as a XML file.
1. Output should conform to the tags below. 
2. If tags are not given, make them on your own.
3. Remember to always open and close all the tags.

As an example, for the tags ["foo", "bar", "baz"]:
1. String "<foo>
   <bar>
      <baz></baz>
   </bar>
</foo>" is a well-formatted instance of the schema. 
2. String "<foo>
   <bar>
   </foo>" is a badly-formatted instance.
3. String "<foo>
   <tag>
   </tag>
</foo>" is a badly-formatted instance.

Here are the output tags:
\`\`\`
{tags}
\`\`\``;
var oX = class extends Qp {
  constructor(A) {
    super(A);
    R(this, "tags");
    R(this, "lc_namespace", ["langchain_core", "output_parsers"]);
    R(this, "lc_serializable", !0);
    this.tags = A == null ? void 0 : A.tags;
  }
  static lc_name() {
    return "XMLOutputParser";
  }
  _diff(A, e) {
    if (e)
      return A ? V0(A, e) : [{
        op: "replace",
        path: "",
        value: e
      }];
  }
  async parsePartialResult(A) {
    return Sm(A[0].text);
  }
  async parse(A) {
    return Sm(A);
  }
  getFormatInstructions() {
    var e;
    return !!(this.tags && this.tags.length > 0) ? Dm.replace("{tags}", ((e = this.tags) == null ? void 0 : e.join(", ")) ?? "") : Dm;
  }
};
const gX = (t) => t.split(`
`).map((A) => A.replace(/^\s+/, "")).join(`
`).trim(), iU = (t) => {
  if (Object.keys(t).length === 0) return {};
  const A = {};
  return t.children.length > 0 ? (A[t.name] = t.children.map(iU), A) : (A[t.name] = t.text ?? void 0, A);
};
function Sm(t) {
  const A = gX(t), e = aX.parser(!0);
  let r = {};
  const i = [];
  e.onopentag = (a) => {
    const g = {
      name: a.name,
      attributes: a.attributes,
      children: [],
      text: "",
      isSelfClosing: a.isSelfClosing
    };
    i.length > 0 ? i[i.length - 1].children.push(g) : r = g, a.isSelfClosing || i.push(g);
  }, e.onclosetag = () => {
    if (i.length > 0) {
      const a = i.pop();
      i.length === 0 && a && (r = a);
    }
  }, e.ontext = (a) => {
    if (i.length > 0) {
      const g = i[i.length - 1];
      g.text += a;
    }
  }, e.onattribute = (a) => {
    if (i.length > 0) {
      const g = i[i.length - 1];
      g.attributes[a.name] = a.value;
    }
  };
  const n = /```(xml)?(.*)```/s.exec(A), s = n ? n[2] : A;
  return e.write(s).close(), r && r.name === "?xml" && (r = r.children[0]), iU(r);
}
var uX = {};
fe(uX, {
  AsymmetricStructuredOutputParser: () => nX,
  BaseCumulativeTransformOutputParser: () => Qp,
  BaseLLMOutputParser: () => tU,
  BaseOutputParser: () => hp,
  BaseTransformOutputParser: () => HE,
  BytesOutputParser: () => $6,
  CommaSeparatedListOutputParser: () => AX,
  CustomListOutputParser: () => eX,
  JsonMarkdownStructuredOutputParser: () => rU,
  JsonOutputParser: () => mm,
  ListOutputParser: () => PE,
  MarkdownListOutputParser: () => rX,
  NumberedListOutputParser: () => tX,
  OutputParserException: () => gs,
  StringOutputParser: () => iX,
  StructuredOutputParser: () => Jd,
  XMLOutputParser: () => oX,
  XML_FORMAT_INSTRUCTIONS: () => Dm,
  parseJsonMarkdown: () => Hw,
  parsePartialJson: () => Of,
  parseXMLMarkdown: () => Sm
});
function dp(t, A) {
  if (t.function === void 0) return;
  let e;
  if (A != null && A.partial) try {
    e = Of(t.function.arguments ?? "{}");
  } catch {
    return;
  }
  else try {
    e = JSON.parse(t.function.arguments);
  } catch (i) {
    throw new gs([
      `Function "${t.function.name}" arguments:`,
      "",
      t.function.arguments,
      "",
      "are not valid JSON.",
      `Error: ${i.message}`
    ].join(`
`));
  }
  const r = {
    name: t.function.name,
    args: e,
    type: "tool_call"
  };
  return A != null && A.returnId && (r.id = t.id), r;
}
function nU(t) {
  if (t.id === void 0) throw new Error('All OpenAI tool calls must have an "id" field.');
  return {
    id: t.id,
    type: "function",
    function: {
      name: t.name,
      arguments: JSON.stringify(t.args)
    }
  };
}
function Hd(t, A) {
  var e, r;
  return {
    name: (e = t.function) == null ? void 0 : e.name,
    args: (r = t.function) == null ? void 0 : r.arguments,
    id: t.id,
    error: A,
    type: "invalid_tool_call"
  };
}
var sU = class extends Qp {
  constructor(A) {
    super(A);
    R(this, "returnId", !1);
    R(this, "lc_namespace", [
      "langchain",
      "output_parsers",
      "openai_tools"
    ]);
    R(this, "lc_serializable", !0);
    this.returnId = (A == null ? void 0 : A.returnId) ?? this.returnId;
  }
  static lc_name() {
    return "JsonOutputToolsParser";
  }
  _diff() {
    throw new Error("Not supported.");
  }
  async parse() {
    throw new Error("Not implemented.");
  }
  async parseResult(A) {
    return await this.parsePartialResult(A, !1);
  }
  /**
  * Parses the output and returns a JSON object. If `argsOnly` is true,
  * only the arguments of the function call are returned.
  * @param generations The output of the LLM to parse.
  * @returns A JSON object representation of the function call or its arguments.
  */
  async parsePartialResult(A, e = !0) {
    var s;
    const r = A[0].message;
    let i;
    if (Yf(r) && ((s = r.tool_calls) != null && s.length) ? i = r.tool_calls.map((a) => {
      const { id: g, ...o } = a;
      return this.returnId ? {
        id: g,
        ...o
      } : o;
    }) : r.additional_kwargs.tool_calls !== void 0 && (i = JSON.parse(JSON.stringify(r.additional_kwargs.tool_calls)).map((g) => dp(g, {
      returnId: this.returnId,
      partial: e
    }))), !i) return [];
    const n = [];
    for (const a of i) if (a !== void 0) {
      const g = {
        type: a.name,
        args: a.args,
        id: a.id
      };
      n.push(g);
    }
    return n;
  }
}, Fm = class extends sU {
  constructor(A) {
    super(A);
    R(this, "lc_namespace", [
      "langchain",
      "output_parsers",
      "openai_tools"
    ]);
    R(this, "lc_serializable", !0);
    R(this, "returnId", !1);
    /** The type of tool calls to return. */
    R(this, "keyName");
    /** Whether to return only the first tool call. */
    R(this, "returnSingle", !1);
    R(this, "zodSchema");
    this.keyName = A.keyName, this.returnSingle = A.returnSingle ?? this.returnSingle, this.zodSchema = A.zodSchema;
  }
  static lc_name() {
    return "JsonOutputKeyToolsParser";
  }
  async _validateResult(A) {
    var r;
    if (this.zodSchema === void 0) return A;
    const e = await aG(this.zodSchema, A);
    if (e.success) return e.data;
    throw new gs(`Failed to parse. Text: "${JSON.stringify(A, null, 2)}". Error: ${JSON.stringify((r = e.error) == null ? void 0 : r.issues)}`, JSON.stringify(A, null, 2));
  }
  async parsePartialResult(A) {
    const r = (await super.parsePartialResult(A)).filter((n) => n.type === this.keyName);
    let i = r;
    if (r.length)
      return this.returnId || (i = r.map((n) => n.args)), this.returnSingle ? i[0] : i;
  }
  async parseResult(A) {
    const r = (await super.parsePartialResult(A, !1)).filter((s) => s.type === this.keyName);
    let i = r;
    return r.length ? (this.returnId || (i = r.map((s) => s.args)), this.returnSingle ? this._validateResult(i[0]) : await Promise.all(i.map((s) => this._validateResult(s)))) : void 0;
  }
}, cX = {};
fe(cX, {
  JsonOutputKeyToolsParser: () => Fm,
  JsonOutputToolsParser: () => sU,
  convertLangChainToolCallToOpenAI: () => nU,
  makeInvalidToolCall: () => Hd,
  parseToolCall: () => dp
});
var pS = class extends fS {
  constructor(A) {
    var r, i, n, s;
    super(A ?? {});
    R(this, "temperature");
    R(this, "topP");
    R(this, "frequencyPenalty");
    R(this, "presencePenalty");
    R(this, "n");
    R(this, "logitBias");
    R(this, "model", "gpt-3.5-turbo");
    R(this, "modelKwargs");
    R(this, "stop");
    R(this, "stopSequences");
    R(this, "user");
    R(this, "timeout");
    R(this, "streaming", !1);
    R(this, "streamUsage", !0);
    R(this, "maxTokens");
    R(this, "logprobs");
    R(this, "topLogprobs");
    R(this, "apiKey");
    R(this, "organization");
    R(this, "__includeRawResponse");
    /** @internal */
    R(this, "client");
    /** @internal */
    R(this, "clientConfig");
    /**
    * Whether the model supports the `strict` argument when passing in tools.
    * If `undefined` the `strict` argument will not be passed to OpenAI.
    */
    R(this, "supportsStrictToolCalling");
    R(this, "audio");
    R(this, "modalities");
    R(this, "reasoning");
    /**
    * Must be set to `true` in tenancies with Zero Data Retention. Setting to `true` will disable
    * output storage in the Responses API, but this DOES NOT enable Zero Data Retention in your
    * OpenAI organization or project. This must be configured directly with OpenAI.
    *
    * See:
    * https://platform.openai.com/docs/guides/your-data
    * https://platform.openai.com/docs/api-reference/responses/create#responses-create-store
    *
    * @default false
    */
    R(this, "zdrEnabled");
    /**
    * Service tier to use for this request. Can be "auto", "default", or "flex" or "priority".
    * Specifies the service tier for prioritization and latency optimization.
    */
    R(this, "service_tier");
    /**
    * Used by OpenAI to cache responses for similar requests to optimize your cache
    * hit rates.
    * [Learn more](https://platform.openai.com/docs/guides/prompt-caching).
    */
    R(this, "promptCacheKey");
    /**
    * The verbosity of the model's response.
    */
    R(this, "verbosity");
    R(this, "defaultOptions");
    R(this, "lc_serializable", !0);
    const e = typeof ((r = A == null ? void 0 : A.configuration) == null ? void 0 : r.apiKey) == "string" || typeof ((i = A == null ? void 0 : A.configuration) == null ? void 0 : i.apiKey) == "function" ? (n = A == null ? void 0 : A.configuration) == null ? void 0 : n.apiKey : void 0;
    this.apiKey = (A == null ? void 0 : A.apiKey) ?? e ?? hn("OPENAI_API_KEY"), this.organization = ((s = A == null ? void 0 : A.configuration) == null ? void 0 : s.organization) ?? hn("OPENAI_ORGANIZATION"), this.model = (A == null ? void 0 : A.model) ?? (A == null ? void 0 : A.modelName) ?? this.model, this.modelKwargs = (A == null ? void 0 : A.modelKwargs) ?? {}, this.timeout = A == null ? void 0 : A.timeout, this.temperature = (A == null ? void 0 : A.temperature) ?? this.temperature, this.topP = (A == null ? void 0 : A.topP) ?? this.topP, this.frequencyPenalty = (A == null ? void 0 : A.frequencyPenalty) ?? this.frequencyPenalty, this.presencePenalty = (A == null ? void 0 : A.presencePenalty) ?? this.presencePenalty, this.logprobs = A == null ? void 0 : A.logprobs, this.topLogprobs = A == null ? void 0 : A.topLogprobs, this.n = (A == null ? void 0 : A.n) ?? this.n, this.logitBias = A == null ? void 0 : A.logitBias, this.stop = (A == null ? void 0 : A.stopSequences) ?? (A == null ? void 0 : A.stop), this.stopSequences = this.stop, this.user = A == null ? void 0 : A.user, this.__includeRawResponse = A == null ? void 0 : A.__includeRawResponse, this.audio = A == null ? void 0 : A.audio, this.modalities = A == null ? void 0 : A.modalities, this.reasoning = A == null ? void 0 : A.reasoning, this.maxTokens = (A == null ? void 0 : A.maxCompletionTokens) ?? (A == null ? void 0 : A.maxTokens), this.promptCacheKey = (A == null ? void 0 : A.promptCacheKey) ?? this.promptCacheKey, this.verbosity = (A == null ? void 0 : A.verbosity) ?? this.verbosity, this.disableStreaming = (A == null ? void 0 : A.disableStreaming) === !0, this.streaming = (A == null ? void 0 : A.streaming) === !0, this.disableStreaming && (this.streaming = !1), (A == null ? void 0 : A.streaming) === !1 && (this.disableStreaming = !0), this.streamUsage = (A == null ? void 0 : A.streamUsage) ?? this.streamUsage, this.disableStreaming && (this.streamUsage = !1), this.clientConfig = {
      apiKey: this.apiKey,
      organization: this.organization,
      dangerouslyAllowBrowser: !0,
      ...A == null ? void 0 : A.configuration
    }, (A == null ? void 0 : A.supportsStrictToolCalling) !== void 0 && (this.supportsStrictToolCalling = A.supportsStrictToolCalling), (A == null ? void 0 : A.service_tier) !== void 0 && (this.service_tier = A.service_tier), this.zdrEnabled = (A == null ? void 0 : A.zdrEnabled) ?? !1;
  }
  _llmType() {
    return "openai";
  }
  static lc_name() {
    return "ChatOpenAI";
  }
  get callKeys() {
    return [
      ...super.callKeys,
      "options",
      "function_call",
      "functions",
      "tools",
      "tool_choice",
      "promptIndex",
      "response_format",
      "seed",
      "reasoning",
      "service_tier"
    ];
  }
  get lc_secrets() {
    return {
      apiKey: "OPENAI_API_KEY",
      organization: "OPENAI_ORGANIZATION"
    };
  }
  get lc_aliases() {
    return {
      apiKey: "openai_api_key",
      modelName: "model"
    };
  }
  get lc_serializable_keys() {
    return [
      "configuration",
      "logprobs",
      "topLogprobs",
      "prefixMessages",
      "supportsStrictToolCalling",
      "modalities",
      "audio",
      "temperature",
      "maxTokens",
      "topP",
      "frequencyPenalty",
      "presencePenalty",
      "n",
      "logitBias",
      "user",
      "streaming",
      "streamUsage",
      "model",
      "modelName",
      "modelKwargs",
      "stop",
      "stopSequences",
      "timeout",
      "apiKey",
      "cache",
      "maxConcurrency",
      "maxRetries",
      "verbose",
      "callbacks",
      "tags",
      "metadata",
      "disableStreaming",
      "zdrEnabled",
      "reasoning",
      "promptCacheKey",
      "verbosity"
    ];
  }
  getLsParams(A) {
    const e = this.invocationParams(A);
    return {
      ls_provider: "openai",
      ls_model_name: this.model,
      ls_model_type: "chat",
      ls_temperature: e.temperature ?? void 0,
      ls_max_tokens: e.max_tokens ?? void 0,
      ls_stop: A.stop
    };
  }
  /** @ignore */
  _identifyingParams() {
    return {
      model_name: this.model,
      ...this.invocationParams(),
      ...this.clientConfig
    };
  }
  /**
  * Get the identifying parameters for the model
  */
  identifyingParams() {
    return this._identifyingParams();
  }
  /**
  * Returns backwards compatible reasoning parameters from constructor params and call options
  * @internal
  */
  _getReasoningParams(A) {
    if (!KE(this.model)) return;
    let e;
    return this.reasoning !== void 0 && (e = {
      ...e,
      ...this.reasoning
    }), (A == null ? void 0 : A.reasoning) !== void 0 && (e = {
      ...e,
      ...A.reasoning
    }), e;
  }
  /**
  * Returns an openai compatible response format from a set of options
  * @internal
  */
  _getResponseFormat(A) {
    return A && A.type === "json_schema" && A.json_schema.schema && In(A.json_schema.schema) ? I6(A.json_schema.schema, A.json_schema.name, { description: A.json_schema.description }) : A;
  }
  _combineCallOptions(A) {
    return {
      ...this.defaultOptions,
      ...A ?? {}
    };
  }
  /** @internal */
  _getClientOptions(A) {
    if (!this.client) {
      const r = { baseURL: this.clientConfig.baseURL }, i = YV(r), n = {
        ...this.clientConfig,
        baseURL: i,
        timeout: this.timeout,
        maxRetries: 0
      };
      n.baseURL || delete n.baseURL, n.defaultHeaders = WV(n.defaultHeaders), this.client = new ge(n);
    }
    return {
      ...this.clientConfig,
      ...A
    };
  }
  _convertChatOpenAIToolToCompletionsTool(A, e) {
    return Td(A) ? i9(A.metadata.customTool) : hS(A) ? (e == null ? void 0 : e.strict) !== void 0 ? {
      ...A,
      function: {
        ...A.function,
        strict: e.strict
      }
    } : A : XV(A, e);
  }
  bindTools(A, e) {
    let r;
    return (e == null ? void 0 : e.strict) !== void 0 ? r = e.strict : this.supportsStrictToolCalling !== void 0 && (r = this.supportsStrictToolCalling), this.withConfig({
      tools: A.map((i) => BS(i) || Td(i) ? i : this._convertChatOpenAIToolToCompletionsTool(i, { strict: r })),
      ...e
    });
  }
  async stream(A, e) {
    return super.stream(A, this._combineCallOptions(e));
  }
  async invoke(A, e) {
    return super.invoke(A, this._combineCallOptions(e));
  }
  /** @ignore */
  _combineLLMOutput(...A) {
    return A.reduce((e, r) => (r && r.tokenUsage && (e.tokenUsage.completionTokens += r.tokenUsage.completionTokens ?? 0, e.tokenUsage.promptTokens += r.tokenUsage.promptTokens ?? 0, e.tokenUsage.totalTokens += r.tokenUsage.totalTokens ?? 0), e), { tokenUsage: {
      completionTokens: 0,
      promptTokens: 0,
      totalTokens: 0
    } });
  }
  async getNumTokensFromMessages(A) {
    let e = 0, r = 0, i = 0;
    this.model === "gpt-3.5-turbo-0301" ? (r = 4, i = -1) : (r = 3, i = 1);
    const n = await Promise.all(A.map(async (s) => {
      var c, C, E, l, B, h;
      const a = await this.getNumTokens(s.content), g = await this.getNumTokens(JE(s)), o = s.name !== void 0 ? i + await this.getNumTokens(s.name) : 0;
      let u = a + r + g + o;
      const I = s;
      if (I._getType() === "function" && (u -= 2), (c = I.additional_kwargs) != null && c.function_call && (u += 3), (C = I == null ? void 0 : I.additional_kwargs.function_call) != null && C.name && (u += await this.getNumTokens((E = I.additional_kwargs.function_call) == null ? void 0 : E.name)), (l = I.additional_kwargs.function_call) != null && l.arguments) try {
        u += await this.getNumTokens(JSON.stringify(JSON.parse((B = I.additional_kwargs.function_call) == null ? void 0 : B.arguments)));
      } catch (Q) {
        console.error("Error parsing function arguments", Q, JSON.stringify(I.additional_kwargs.function_call)), u += await this.getNumTokens((h = I.additional_kwargs.function_call) == null ? void 0 : h.arguments);
      }
      return e += u, u;
    }));
    return e += 3, {
      totalCount: e,
      countPerMessage: n
    };
  }
  /** @internal */
  async _getNumTokensFromGenerations(A) {
    return (await Promise.all(A.map(async (r) => {
      var i;
      return (i = r.message.additional_kwargs) != null && i.function_call ? (await this.getNumTokensFromMessages([r.message])).countPerMessage[0] : await this.getNumTokens(r.message.content);
    }))).reduce((r, i) => r + i, 0);
  }
  /** @internal */
  async _getEstimatedTokenCountFromPrompt(A, e, r) {
    let i = (await this.getNumTokensFromMessages(A)).totalCount;
    if (e && r !== "auto") {
      const n = $V(e);
      i += await this.getNumTokens(n), i += 9;
    }
    return e && A.find((n) => n._getType() === "system") && (i -= 4), r === "none" ? i += 1 : typeof r == "object" && (i += await this.getNumTokens(r.name) + 4), i;
  }
  /**
  * Return profiling information for the model.
  *
  * Provides information about the model's capabilities and constraints,
  * including token limits, multimodal support, and advanced features like
  * tool calling and structured output.
  *
  * @returns {ModelProfile} An object describing the model's capabilities and constraints
  *
  * @example
  * ```typescript
  * const model = new ChatOpenAI({ model: "gpt-4o" });
  * const profile = model.profile;
  * console.log(profile.maxInputTokens); // 128000
  * console.log(profile.imageInputs); // true
  * ```
  */
  get profile() {
    return B6[this.model] ?? {};
  }
  /** @internal */
  _getStructuredOutputMethod(A) {
    const e = { ...A };
    if (!this.model.startsWith("gpt-3") && !this.model.startsWith("gpt-4-") && this.model !== "gpt-4") {
      if ((e == null ? void 0 : e.method) === void 0) return "jsonSchema";
    } else e.method === "jsonSchema" && console.warn(`[WARNING]: JSON Schema is not supported for model "${this.model}". Falling back to tool calling.`);
    return e.method;
  }
  /**
  * Add structured output to the model.
  *
  * The OpenAI model family supports the following structured output methods:
  * - `jsonSchema`: Use the `response_format` field in the response to return a JSON schema. Only supported with the `gpt-4o-mini`,
  *   `gpt-4o-mini-2024-07-18`, and `gpt-4o-2024-08-06` model snapshots and later.
  * - `functionCalling`: Function calling is useful when you are building an application that bridges the models and functionality
  *   of your application.
  * - `jsonMode`: JSON mode is a more basic version of the Structured Outputs feature. While JSON mode ensures that model
  *   output is valid JSON, Structured Outputs reliably matches the model's output to the schema you specify.
  *   We recommend you use `functionCalling` or `jsonSchema` if it is supported for your use case.
  *
  * The default method is `functionCalling`.
  *
  * @see https://platform.openai.com/docs/guides/structured-outputs
  * @param outputSchema - The schema to use for structured output.
  * @param config - The structured output method options.
  * @returns The model with structured output.
  */
  withStructuredOutput(A, e) {
    let r, i;
    const { schema: n, name: s, includeRaw: a } = {
      ...e,
      schema: A
    };
    if ((e == null ? void 0 : e.strict) !== void 0 && e.method === "jsonMode") throw new Error("Argument `strict` is only supported for `method` = 'function_calling'");
    const g = u6(this.model, e == null ? void 0 : e.method);
    if (g === "jsonMode") {
      In(n) ? i = Jd.fromZodSchema(n) : i = new mm();
      const c = Cn(n);
      r = this.withConfig({
        outputVersion: "v0",
        response_format: { type: "json_object" },
        ls_structured_output_format: {
          kwargs: { method: "json_mode" },
          schema: {
            title: s ?? "extract",
            ...c
          }
        }
      });
    } else if (g === "jsonSchema") {
      const c = {
        name: s ?? "extract",
        description: gp(n),
        schema: n,
        strict: e == null ? void 0 : e.strict
      }, C = Cn(c.schema);
      if (r = this.withConfig({
        outputVersion: "v0",
        response_format: {
          type: "json_schema",
          json_schema: c
        },
        ls_structured_output_format: {
          kwargs: { method: "json_schema" },
          schema: {
            title: c.name,
            description: c.description,
            ...C
          }
        }
      }), In(n)) {
        const E = Jd.fromZodSchema(n);
        i = ps.from((l) => "parsed" in l.additional_kwargs ? l.additional_kwargs.parsed : E);
      } else i = new mm();
    } else {
      let c = s ?? "extract";
      if (In(n)) {
        const C = Cn(n);
        r = this.withConfig({
          outputVersion: "v0",
          tools: [{
            type: "function",
            function: {
              name: c,
              description: C.description,
              parameters: C
            }
          }],
          tool_choice: {
            type: "function",
            function: { name: c }
          },
          ls_structured_output_format: {
            kwargs: { method: "function_calling" },
            schema: {
              title: c,
              ...C
            }
          },
          ...(e == null ? void 0 : e.strict) !== void 0 ? { strict: e.strict } : {}
        }), i = new Fm({
          returnSingle: !0,
          keyName: c,
          zodSchema: n
        });
      } else {
        let C;
        typeof n.name == "string" && typeof n.parameters == "object" && n.parameters != null ? (C = n, c = n.name) : (c = n.title ?? c, C = {
          name: c,
          description: n.description ?? "",
          parameters: n
        });
        const E = Cn(n);
        r = this.withConfig({
          outputVersion: "v0",
          tools: [{
            type: "function",
            function: C
          }],
          tool_choice: {
            type: "function",
            function: { name: c }
          },
          ls_structured_output_format: {
            kwargs: { method: "function_calling" },
            schema: {
              title: c,
              ...E
            }
          },
          ...(e == null ? void 0 : e.strict) !== void 0 ? { strict: e.strict } : {}
        }), i = new Fm({
          returnSingle: !0,
          keyName: c
        });
      }
    }
    if (!a) return r.pipe(i);
    const o = Vc.assign({ parsed: (c, C) => i.invoke(c.raw, C) }), u = Vc.assign({ parsed: () => null }), I = o.withFallbacks({ fallbacks: [u] });
    return TE.from([{ raw: r }, I]);
  }
};
const aU = {
  providerName: "ChatOpenAI",
  fromStandardTextBlock(t) {
    return {
      type: "text",
      text: t.text
    };
  },
  fromStandardImageBlock(t) {
    var A, e;
    if (t.source_type === "url") return {
      type: "image_url",
      image_url: {
        url: t.url,
        ...(A = t.metadata) != null && A.detail ? { detail: t.metadata.detail } : {}
      }
    };
    if (t.source_type === "base64")
      return {
        type: "image_url",
        image_url: {
          url: `data:${t.mime_type ?? ""};base64,${t.data}`,
          ...(e = t.metadata) != null && e.detail ? { detail: t.metadata.detail } : {}
        }
      };
    throw new Error(`Image content blocks with source_type ${t.source_type} are not supported for ChatOpenAI`);
  },
  fromStandardAudioBlock(t) {
    if (t.source_type === "url") {
      const A = jC({ dataUrl: t.url });
      if (!A) throw new Error(`URL audio blocks with source_type ${t.source_type} must be formatted as a data URL for ChatOpenAI`);
      const e = A.mime_type || t.mime_type || "";
      let r;
      try {
        r = Jw(e);
      } catch {
        throw new Error(`Audio blocks with source_type ${t.source_type} must have mime type of audio/wav or audio/mp3`);
      }
      if (r.type !== "audio" || r.subtype !== "wav" && r.subtype !== "mp3") throw new Error(`Audio blocks with source_type ${t.source_type} must have mime type of audio/wav or audio/mp3`);
      return {
        type: "input_audio",
        input_audio: {
          format: r.subtype,
          data: A.data
        }
      };
    }
    if (t.source_type === "base64") {
      let A;
      try {
        A = Jw(t.mime_type ?? "");
      } catch {
        throw new Error(`Audio blocks with source_type ${t.source_type} must have mime type of audio/wav or audio/mp3`);
      }
      if (A.type !== "audio" || A.subtype !== "wav" && A.subtype !== "mp3") throw new Error(`Audio blocks with source_type ${t.source_type} must have mime type of audio/wav or audio/mp3`);
      return {
        type: "input_audio",
        input_audio: {
          format: A.subtype,
          data: t.data
        }
      };
    }
    throw new Error(`Audio content blocks with source_type ${t.source_type} are not supported for ChatOpenAI`);
  },
  fromStandardFileBlock(t) {
    var A, e, r, i, n, s, a, g, o, u;
    if (t.source_type === "url") {
      if (!jC({ dataUrl: t.url })) throw new Error(`URL file blocks with source_type ${t.source_type} must be formatted as a data URL for ChatOpenAI`);
      return {
        type: "file",
        file: {
          file_data: t.url,
          ...(A = t.metadata) != null && A.filename || (e = t.metadata) != null && e.name ? { filename: ((r = t.metadata) == null ? void 0 : r.filename) || ((i = t.metadata) == null ? void 0 : i.name) } : {}
        }
      };
    }
    if (t.source_type === "base64") return {
      type: "file",
      file: {
        file_data: `data:${t.mime_type ?? ""};base64,${t.data}`,
        ...(n = t.metadata) != null && n.filename || (s = t.metadata) != null && s.name || (a = t.metadata) != null && a.title ? { filename: ((g = t.metadata) == null ? void 0 : g.filename) || ((o = t.metadata) == null ? void 0 : o.name) || ((u = t.metadata) == null ? void 0 : u.title) } : {}
      }
    };
    if (t.source_type === "id") return {
      type: "file",
      file: { file_id: t.id }
    };
    throw new Error(`File content blocks with source_type ${t.source_type} are not supported for ChatOpenAI`);
  }
}, IX = ({ message: t, rawResponse: A, includeRawResponse: e }) => {
  var i, n;
  const r = t.tool_calls;
  switch (t.role) {
    case "assistant": {
      const s = [], a = [];
      for (const I of r ?? []) try {
        s.push(dp(I, { returnId: !0 }));
      } catch (c) {
        a.push(Hd(I, c.message));
      }
      const g = {
        function_call: t.function_call,
        tool_calls: r
      };
      e !== void 0 && (g.__raw_response = A);
      const o = {
        model_provider: "openai",
        model_name: A.model,
        ...A.system_fingerprint ? {
          usage: { ...A.usage },
          system_fingerprint: A.system_fingerprint
        } : {}
      };
      t.audio && (g.audio = t.audio);
      const u = C6(t.content || "", (n = (i = A.choices) == null ? void 0 : i[0]) == null ? void 0 : n.message);
      return new jt({
        content: u,
        tool_calls: s,
        invalid_tool_calls: a,
        additional_kwargs: g,
        response_metadata: o,
        id: A.id
      });
    }
    default:
      return new wg(t.content || "", t.role ?? "unknown");
  }
}, CX = ({ delta: t, rawResponse: A, includeRawResponse: e, defaultRole: r }) => {
  var g, o;
  const i = t.role ?? r, n = t.content ?? "";
  let s;
  t.function_call ? s = { function_call: t.function_call } : t.tool_calls ? s = { tool_calls: t.tool_calls } : s = {}, e && (s.__raw_response = A), t.audio && (s.audio = {
    ...t.audio,
    index: A.choices[0].index
  });
  const a = {
    model_provider: "openai",
    usage: { ...A.usage }
  };
  if (i === "user") return new NE({
    content: n,
    response_metadata: a
  });
  if (i === "assistant") {
    const u = [];
    if (Array.isArray(t.tool_calls)) for (const I of t.tool_calls) u.push({
      name: (g = I.function) == null ? void 0 : g.name,
      args: (o = I.function) == null ? void 0 : o.arguments,
      id: I.id,
      index: I.index,
      type: "tool_call_chunk"
    });
    return new kn({
      content: n,
      tool_call_chunks: u,
      additional_kwargs: s,
      id: A.id,
      response_metadata: a
    });
  } else return i === "system" ? new Ma({
    content: n,
    response_metadata: a
  }) : i === "developer" ? new Ma({
    content: n,
    response_metadata: a,
    additional_kwargs: { __openai_role__: "developer" }
  }) : i === "function" ? new _E({
    content: n,
    additional_kwargs: s,
    name: t.name,
    response_metadata: a
  }) : i === "tool" ? new bE({
    content: n,
    additional_kwargs: s,
    tool_call_id: t.tool_call_id,
    response_metadata: a
  }) : new ME({
    content: n,
    role: i,
    response_metadata: a
  });
}, lX = (t) => {
  if (t.type === "image") {
    if (t.url) return {
      type: "image_url",
      image_url: { url: t.url }
    };
    if (t.data) return {
      type: "image_url",
      image_url: { url: `data:${t.mimeType};base64,${t.data}` }
    };
  }
  if (t.type === "audio" && t.data) {
    const A = NL(() => {
      const [, e] = t.mimeType.split("/");
      return e === "wav" || e === "mp3" ? e : "wav";
    });
    return {
      type: "input_audio",
      input_audio: {
        data: t.data.toString(),
        format: A
      }
    };
  }
  if (t.type === "file") {
    if (t.data) return {
      type: "file",
      file: { file_data: t.data.toString() }
    };
    if (t.fileId) return {
      type: "file",
      file: { file_id: t.fileId }
    };
  }
}, BX = ({ message: t, model: A }) => {
  let e = JE(t);
  if (e === "system" && KE(A) && (e = "developer"), e === "developer") return {
    role: "developer",
    content: t.contentBlocks.filter((i) => i.type === "text")
  };
  if (e === "system") return {
    role: "system",
    content: t.contentBlocks.filter((i) => i.type === "text")
  };
  if (e === "assistant") return {
    role: "assistant",
    content: t.contentBlocks.filter((i) => i.type === "text")
  };
  if (e === "tool" && fn.isInstance(t)) return {
    role: "tool",
    tool_call_id: t.tool_call_id,
    content: t.contentBlocks.filter((i) => i.type === "text")
  };
  if (e === "function") return {
    role: "function",
    name: t.name ?? "",
    content: t.contentBlocks.filter((i) => i.type === "text").join("")
  };
  function* r(i) {
    for (const n of i) {
      n.type === "text" && (yield {
        type: "text",
        text: n.text
      });
      const s = lX(n);
      s && (yield s);
    }
  }
  return {
    role: "user",
    content: Array.from(r(t.contentBlocks))
  };
}, Uv = ({ messages: t, model: A }) => t.flatMap((e) => {
  var s, a;
  if ("output_version" in e.response_metadata && ((s = e.response_metadata) == null ? void 0 : s.output_version) === "v1") return BX({ message: e });
  let r = JE(e);
  r === "system" && KE(A) && (r = "developer");
  const i = typeof e.content == "string" ? e.content : e.content.map((g) => dn(g) ? p0(g, aU) : g), n = {
    role: r,
    content: i
  };
  if (e.name != null && (n.name = e.name), e.additional_kwargs.function_call != null && (n.function_call = e.additional_kwargs.function_call, n.content = ""), jt.isInstance(e) && ((a = e.tool_calls) != null && a.length) ? (n.tool_calls = e.tool_calls.map(nU), n.content = "") : (e.additional_kwargs.tool_calls != null && (n.tool_calls = e.additional_kwargs.tool_calls), fn.isInstance(e) && e.tool_call_id != null && (n.tool_call_id = e.tool_call_id)), e.additional_kwargs.audio && typeof e.additional_kwargs.audio == "object" && "id" in e.additional_kwargs.audio) {
    const g = {
      role: "assistant",
      audio: { id: e.additional_kwargs.audio.id }
    };
    return [n, g];
  }
  return n;
});
var EX = class extends pS {
  /** @internal */
  invocationParams(t, A) {
    var s;
    let e;
    (t == null ? void 0 : t.strict) !== void 0 ? e = t.strict : this.supportsStrictToolCalling !== void 0 && (e = this.supportsStrictToolCalling);
    let r = {};
    (t == null ? void 0 : t.stream_options) !== void 0 ? r = { stream_options: t.stream_options } : this.streamUsage && (this.streaming || A != null && A.streaming) && (r = { stream_options: { include_usage: !0 } });
    const i = {
      model: this.model,
      temperature: this.temperature,
      top_p: this.topP,
      frequency_penalty: this.frequencyPenalty,
      presence_penalty: this.presencePenalty,
      logprobs: this.logprobs,
      top_logprobs: this.topLogprobs,
      n: this.n,
      logit_bias: this.logitBias,
      stop: (t == null ? void 0 : t.stop) ?? this.stopSequences,
      user: this.user,
      stream: this.streaming,
      functions: t == null ? void 0 : t.functions,
      function_call: t == null ? void 0 : t.function_call,
      tools: (s = t == null ? void 0 : t.tools) != null && s.length ? t.tools.map((a) => this._convertChatOpenAIToolToCompletionsTool(a, { strict: e })) : void 0,
      tool_choice: xG(t == null ? void 0 : t.tool_choice),
      response_format: this._getResponseFormat(t == null ? void 0 : t.response_format),
      seed: t == null ? void 0 : t.seed,
      ...r,
      parallel_tool_calls: t == null ? void 0 : t.parallel_tool_calls,
      ...this.audio || t != null && t.audio ? { audio: this.audio || (t == null ? void 0 : t.audio) } : {},
      ...this.modalities || t != null && t.modalities ? { modalities: this.modalities || (t == null ? void 0 : t.modalities) } : {},
      ...this.modelKwargs,
      prompt_cache_key: (t == null ? void 0 : t.promptCacheKey) ?? this.promptCacheKey,
      verbosity: (t == null ? void 0 : t.verbosity) ?? this.verbosity
    };
    (t == null ? void 0 : t.prediction) !== void 0 && (i.prediction = t.prediction), this.service_tier !== void 0 && (i.service_tier = this.service_tier), (t == null ? void 0 : t.service_tier) !== void 0 && (i.service_tier = t.service_tier);
    const n = this._getReasoningParams(t);
    return n !== void 0 && n.effort !== void 0 && (i.reasoning_effort = n.effort), KE(i.model) ? i.max_completion_tokens = this.maxTokens === -1 ? void 0 : this.maxTokens : i.max_tokens = this.maxTokens === -1 ? void 0 : this.maxTokens, i;
  }
  async _generate(t, A, e) {
    var s, a;
    const r = {}, i = this.invocationParams(A), n = Uv({
      messages: t,
      model: this.model
    });
    if (i.stream) {
      const g = this._streamResponseChunks(t, A, e), o = {};
      for await (const l of g) {
        l.message.response_metadata = {
          ...l.generationInfo,
          ...l.message.response_metadata
        };
        const B = ((s = l.generationInfo) == null ? void 0 : s.completion) ?? 0;
        o[B] === void 0 ? o[B] = l : o[B] = o[B].concat(l);
      }
      const u = Object.entries(o).sort(([l], [B]) => parseInt(l, 10) - parseInt(B, 10)).map(([l, B]) => B), { functions: I, function_call: c } = this.invocationParams(A), C = await this._getEstimatedTokenCountFromPrompt(t, I, c), E = await this._getNumTokensFromGenerations(u);
      return r.input_tokens = C, r.output_tokens = E, r.total_tokens = C + E, {
        generations: u,
        llmOutput: { estimatedTokenUsage: {
          promptTokens: r.input_tokens,
          completionTokens: r.output_tokens,
          totalTokens: r.total_tokens
        } }
      };
    } else {
      const g = await this.completionWithRetry({
        ...i,
        stream: !1,
        messages: n
      }, {
        signal: A == null ? void 0 : A.signal,
        ...A == null ? void 0 : A.options
      }), { completion_tokens: o, prompt_tokens: u, total_tokens: I, prompt_tokens_details: c, completion_tokens_details: C } = (g == null ? void 0 : g.usage) ?? {};
      o && (r.output_tokens = (r.output_tokens ?? 0) + o), u && (r.input_tokens = (r.input_tokens ?? 0) + u), I && (r.total_tokens = (r.total_tokens ?? 0) + I), ((c == null ? void 0 : c.audio_tokens) !== null || (c == null ? void 0 : c.cached_tokens) !== null) && (r.input_token_details = {
        ...(c == null ? void 0 : c.audio_tokens) !== null && { audio: c == null ? void 0 : c.audio_tokens },
        ...(c == null ? void 0 : c.cached_tokens) !== null && { cache_read: c == null ? void 0 : c.cached_tokens }
      }), ((C == null ? void 0 : C.audio_tokens) !== null || (C == null ? void 0 : C.reasoning_tokens) !== null) && (r.output_token_details = {
        ...(C == null ? void 0 : C.audio_tokens) !== null && { audio: C == null ? void 0 : C.audio_tokens },
        ...(C == null ? void 0 : C.reasoning_tokens) !== null && { reasoning: C == null ? void 0 : C.reasoning_tokens }
      });
      const E = [];
      for (const l of (g == null ? void 0 : g.choices) ?? []) {
        const h = {
          text: ((a = l.message) == null ? void 0 : a.content) ?? "",
          message: this._convertCompletionsMessageToBaseMessage(l.message ?? { role: "assistant" }, g)
        };
        h.generationInfo = {
          ...l.finish_reason ? { finish_reason: l.finish_reason } : {},
          ...l.logprobs ? { logprobs: l.logprobs } : {}
        }, Yf(h.message) && (h.message.usage_metadata = r), h.message = new jt(Object.fromEntries(Object.entries(h.message).filter(([Q]) => !Q.startsWith("lc_")))), E.push(h);
      }
      return {
        generations: E,
        llmOutput: { tokenUsage: {
          promptTokens: r.input_tokens,
          completionTokens: r.output_tokens,
          totalTokens: r.total_tokens
        } }
      };
    }
  }
  async *_streamResponseChunks(t, A, e) {
    var g, o, u, I, c, C, E, l, B, h;
    const r = Uv({
      messages: t,
      model: this.model
    }), i = {
      ...this.invocationParams(A, { streaming: !0 }),
      messages: r,
      stream: !0
    };
    let n;
    const s = await this.completionWithRetry(i, A);
    let a;
    for await (const Q of s) {
      const f = (g = Q == null ? void 0 : Q.choices) == null ? void 0 : g[0];
      if (Q.usage && (a = Q.usage), !f) continue;
      const { delta: p } = f;
      if (!p) continue;
      const y = this._convertCompletionsDeltaToBaseMessageChunk(p, Q, n);
      n = p.role ?? n;
      const m = {
        prompt: A.promptIndex ?? 0,
        completion: f.index ?? 0
      };
      if (typeof y.content != "string") {
        console.log("[WARNING]: Received non-string content from OpenAI. This is currently not supported.");
        continue;
      }
      const S = { ...m };
      f.finish_reason != null && (S.finish_reason = f.finish_reason, S.system_fingerprint = Q.system_fingerprint, S.model_name = Q.model, S.service_tier = Q.service_tier), this.logprobs && (S.logprobs = f.logprobs);
      const w = new Pc({
        message: y,
        text: y.content,
        generationInfo: S
      });
      yield w, await (e == null ? void 0 : e.handleLLMNewToken(w.text ?? "", m, void 0, void 0, void 0, { chunk: w }));
    }
    if (a) {
      const Q = {
        ...((o = a.prompt_tokens_details) == null ? void 0 : o.audio_tokens) !== null && { audio: (u = a.prompt_tokens_details) == null ? void 0 : u.audio_tokens },
        ...((I = a.prompt_tokens_details) == null ? void 0 : I.cached_tokens) !== null && { cache_read: (c = a.prompt_tokens_details) == null ? void 0 : c.cached_tokens }
      }, f = {
        ...((C = a.completion_tokens_details) == null ? void 0 : C.audio_tokens) !== null && { audio: (E = a.completion_tokens_details) == null ? void 0 : E.audio_tokens },
        ...((l = a.completion_tokens_details) == null ? void 0 : l.reasoning_tokens) !== null && { reasoning: (B = a.completion_tokens_details) == null ? void 0 : B.reasoning_tokens }
      };
      yield new Pc({
        message: new kn({
          content: "",
          response_metadata: { usage: { ...a } },
          usage_metadata: {
            input_tokens: a.prompt_tokens,
            output_tokens: a.completion_tokens,
            total_tokens: a.total_tokens,
            ...Object.keys(Q).length > 0 && { input_token_details: Q },
            ...Object.keys(f).length > 0 && { output_token_details: f }
          }
        }),
        text: ""
      });
    }
    if ((h = A.signal) != null && h.aborted) throw new Error("AbortError");
  }
  async completionWithRetry(t, A) {
    const e = this._getClientOptions(A), r = t.response_format && t.response_format.type === "json_schema";
    return this.caller.call(async () => {
      try {
        return r && !t.stream ? await this.client.chat.completions.parse(t, e) : await this.client.chat.completions.create(t, e);
      } catch (i) {
        throw cL(i);
      }
    });
  }
  /**
  * @deprecated
  * This function was hoisted into a publicly accessible function from a
  * different export, but to maintain backwards compatibility with chat models
  * that depend on ChatOpenAICompletions, we'll keep it here as an overridable
  * method. This will be removed in a future release
  */
  _convertCompletionsDeltaToBaseMessageChunk(t, A, e) {
    return CX({
      delta: t,
      rawResponse: A,
      includeRawResponse: this.__includeRawResponse,
      defaultRole: e
    });
  }
  /**
  * @deprecated
  * This function was hoisted into a publicly accessible function from a
  * different export, but to maintain backwards compatibility with chat models
  * that depend on ChatOpenAICompletions, we'll keep it here as an overridable
  * method. This will be removed in a future release
  */
  _convertCompletionsMessageToBaseMessage(t, A) {
    return IX({
      message: t,
      rawResponse: A,
      includeRawResponse: this.__includeRawResponse
    });
  }
};
const $g = "__openai_function_call_ids__", oU = (t) => {
  var r, i, n, s;
  const A = { ...((r = t == null ? void 0 : t.input_tokens_details) == null ? void 0 : r.cached_tokens) != null && { cache_read: (i = t == null ? void 0 : t.input_tokens_details) == null ? void 0 : i.cached_tokens } }, e = { ...((n = t == null ? void 0 : t.output_tokens_details) == null ? void 0 : n.reasoning_tokens) != null && { reasoning: (s = t == null ? void 0 : t.output_tokens_details) == null ? void 0 : s.reasoning_tokens } };
  return {
    input_tokens: (t == null ? void 0 : t.input_tokens) ?? 0,
    output_tokens: (t == null ? void 0 : t.output_tokens) ?? 0,
    total_tokens: (t == null ? void 0 : t.total_tokens) ?? 0,
    input_token_details: A,
    output_token_details: e
  };
}, gU = (t) => {
  if (t.error) {
    const a = new Error(t.error.message);
    throw a.name = t.error.code, a;
  }
  let A;
  const e = [], r = [], i = [], n = {
    model_provider: "openai",
    model: t.model,
    created_at: t.created_at,
    id: t.id,
    incomplete_details: t.incomplete_details,
    metadata: t.metadata,
    object: t.object,
    status: t.status,
    user: t.user,
    service_tier: t.service_tier,
    model_name: t.model
  }, s = {};
  for (const a of t.output) if (a.type === "message")
    A = a.id, e.push(...a.content.flatMap((g) => g.type === "output_text" ? ("parsed" in g && g.parsed != null && (s.parsed = g.parsed), {
      type: "text",
      text: g.text,
      annotations: g.annotations
    }) : g.type === "refusal" ? (s.refusal = g.refusal, []) : g));
  else if (a.type === "function_call") {
    const g = {
      function: {
        name: a.name,
        arguments: a.arguments
      },
      id: a.call_id
    };
    try {
      r.push(dp(g, { returnId: !0 }));
    } catch (o) {
      let u;
      typeof o == "object" && o != null && "message" in o && typeof o.message == "string" && (u = o.message), i.push(Hd(g, u));
    }
    s[$g] ?? (s[$g] = {}), a.id && (s[$g][a.call_id] = a.id);
  } else if (a.type === "reasoning") s.reasoning = a;
  else if (a.type === "custom_tool_call") {
    const g = e9(a);
    g ? r.push(g) : i.push(Hd(a, "Malformed custom tool call"));
  } else
    s.tool_outputs ?? (s.tool_outputs = []), s.tool_outputs.push(a);
  return new jt({
    id: A,
    content: e,
    tool_calls: r,
    invalid_tool_calls: i,
    usage_metadata: oU(t.usage),
    additional_kwargs: s,
    response_metadata: n
  });
}, hX = (t) => {
  const A = (t.summary.length > 1 ? t.summary.reduce((e, r) => {
    const i = e[e.length - 1];
    return i.index === r.index ? i.text += r.text : e.push(r), e;
  }, [{ ...t.summary[0] }]) : t.summary).map((e) => Object.fromEntries(Object.entries(e).filter(([r]) => r !== "index")));
  return {
    ...t,
    summary: A
  };
}, QX = (t) => {
  var g, o;
  const A = [];
  let e = {}, r;
  const i = [], n = { model_provider: "openai" }, s = {};
  let a;
  if (t.type === "response.output_text.delta") A.push({
    type: "text",
    text: t.delta,
    index: t.content_index
  });
  else if (t.type === "response.output_text.annotation.added") A.push({
    type: "text",
    text: "",
    annotations: [t.annotation],
    index: t.content_index
  });
  else if (t.type === "response.output_item.added" && t.item.type === "message") a = t.item.id;
  else if (t.type === "response.output_item.added" && t.item.type === "function_call")
    i.push({
      type: "tool_call_chunk",
      name: t.item.name,
      args: t.item.arguments,
      id: t.item.call_id,
      index: t.output_index
    }), s[$g] = { [t.item.call_id]: t.item.id };
  else if (t.type === "response.output_item.done" && [
    "web_search_call",
    "file_search_call",
    "computer_call",
    "code_interpreter_call",
    "mcp_call",
    "mcp_list_tools",
    "mcp_approval_request",
    "image_generation_call",
    "custom_tool_call"
  ].includes(t.item.type)) s.tool_outputs = [t.item];
  else if (t.type === "response.created")
    n.id = t.response.id, n.model_name = t.response.model, n.model = t.response.model;
  else if (t.type === "response.completed") {
    const u = gU(t.response);
    r = oU(t.response.usage), ((o = (g = t.response.text) == null ? void 0 : g.format) == null ? void 0 : o.type) === "json_schema" && (s.parsed ?? (s.parsed = JSON.parse(u.text)));
    for (const [I, c] of Object.entries(t.response)) I !== "id" && (n[I] = c);
  } else if (t.type === "response.function_call_arguments.delta" || t.type === "response.custom_tool_call_input.delta") i.push({
    type: "tool_call_chunk",
    args: t.delta,
    index: t.output_index
  });
  else if (t.type === "response.web_search_call.completed" || t.type === "response.file_search_call.completed") e = { tool_outputs: {
    id: t.item_id,
    type: t.type.replace("response.", "").replace(".completed", ""),
    status: "completed"
  } };
  else if (t.type === "response.refusal.done") s.refusal = t.refusal;
  else if (t.type === "response.output_item.added" && "item" in t && t.item.type === "reasoning") {
    const u = t.item.summary ? t.item.summary.map((I, c) => ({
      ...I,
      index: c
    })) : void 0;
    s.reasoning = {
      id: t.item.id,
      type: t.item.type,
      ...u ? { summary: u } : {}
    };
  } else if (t.type === "response.reasoning_summary_part.added") s.reasoning = {
    type: "reasoning",
    summary: [{
      ...t.part,
      index: t.summary_index
    }]
  };
  else if (t.type === "response.reasoning_summary_text.delta") s.reasoning = {
    type: "reasoning",
    summary: [{
      text: t.delta,
      type: "summary_text",
      index: t.summary_index
    }]
  };
  else return t.type === "response.image_generation_call.partial_image", null;
  return new Pc({
    text: A.map((u) => u.text).join(""),
    message: new kn({
      id: a,
      content: A,
      tool_call_chunks: i,
      usage_metadata: r,
      additional_kwargs: s,
      response_metadata: n
    }),
    generationInfo: e
  });
}, dX = (t) => {
  var r;
  const A = jt.isInstance(t) && ((r = t.response_metadata) == null ? void 0 : r.model_provider) === "openai";
  function* e() {
    const i = cg(() => {
      try {
        const Q = JE(t);
        return Q === "system" || Q === "developer" || Q === "assistant" || Q === "user" ? Q : "assistant";
      } catch {
        return "assistant";
      }
    });
    let n;
    const s = /* @__PURE__ */ new Set(), a = /* @__PURE__ */ new Set(), g = /* @__PURE__ */ new Map(), o = /* @__PURE__ */ new Map();
    function* u() {
      if (!n) return;
      const Q = n.content;
      (typeof Q == "string" && Q.length > 0 || Array.isArray(Q) && Q.length > 0) && (yield n), n = void 0;
    }
    const I = (Q) => {
      n || (n = {
        type: "message",
        role: i,
        content: []
      }), typeof n.content == "string" ? n.content = n.content.length > 0 ? [{
        type: "input_text",
        text: n.content
      }, ...Q] : [...Q] : n.content.push(...Q);
    }, c = (Q) => {
      if (typeof Q == "string") return Q;
      try {
        return JSON.stringify(Q ?? {});
      } catch {
        return "{}";
      }
    }, C = (Q) => {
      const f = cg(() => {
        var y;
        const p = (y = Q.metadata) == null ? void 0 : y.detail;
        return p === "low" || p === "high" || p === "auto" ? p : "auto";
      });
      if (Q.fileId) return {
        type: "input_image",
        detail: f,
        file_id: Q.fileId
      };
      if (Q.url) return {
        type: "input_image",
        detail: f,
        image_url: Q.url
      };
      if (Q.data) {
        const p = typeof Q.data == "string" ? Q.data : Buffer.from(Q.data).toString("base64"), y = Q.mimeType ?? "image/png";
        return {
          type: "input_image",
          detail: f,
          image_url: `data:${y};base64,${p}`
        };
      }
    }, E = (Q) => {
      var p, y, m;
      const f = ((p = Q.metadata) == null ? void 0 : p.filename) ?? ((y = Q.metadata) == null ? void 0 : y.name) ?? ((m = Q.metadata) == null ? void 0 : m.title);
      if (Q.fileId && typeof f == "string") return {
        type: "input_file",
        file_id: Q.fileId,
        ...f ? { filename: f } : {}
      };
      if (Q.url && typeof f == "string") return {
        type: "input_file",
        file_url: Q.url,
        ...f ? { filename: f } : {}
      };
      if (Q.data && typeof f == "string") {
        const S = typeof Q.data == "string" ? Q.data : Buffer.from(Q.data).toString("base64");
        return {
          type: "input_file",
          file_data: `data:${Q.mimeType ?? "application/octet-stream"};base64,${S}`,
          ...f ? { filename: f } : {}
        };
      }
    }, l = (Q) => {
      const f = cg(() => {
        if (Array.isArray(Q.summary)) {
          const m = Q.summary, S = (m == null ? void 0 : m.map((w) => w == null ? void 0 : w.text).filter((w) => typeof w == "string")) ?? [];
          if (S.length > 0) return S;
        }
        return Q.reasoning ? [Q.reasoning] : [];
      }), p = f.length > 0 ? f.map((m) => ({
        type: "summary_text",
        text: m
      })) : [{
        type: "summary_text",
        text: ""
      }], y = {
        type: "reasoning",
        id: Q.id ?? "",
        summary: p
      };
      return Q.reasoning && (y.content = [{
        type: "reasoning_text",
        text: Q.reasoning
      }]), y;
    }, B = (Q) => ({
      type: "function_call",
      name: Q.name ?? "",
      call_id: Q.id ?? "",
      arguments: c(Q.args)
    }), h = (Q) => {
      const f = c(Q.output), p = Q.status === "success" ? "completed" : Q.status === "error" ? "incomplete" : void 0;
      return {
        type: "function_call_output",
        call_id: Q.toolCallId ?? "",
        output: f,
        ...p ? { status: p } : {}
      };
    };
    for (const Q of t.contentBlocks) if (Q.type === "text") I([{
      type: "input_text",
      text: Q.text
    }]);
    else if (Q.type !== "invalid_tool_call") {
      if (Q.type === "reasoning")
        yield* u(), yield l(Q);
      else if (Q.type === "tool_call") {
        yield* u();
        const f = Q.id ?? "";
        f && (s.add(f), g.delete(f)), yield B(Q);
      } else if (Q.type === "tool_call_chunk") {
        if (Q.id) {
          const f = g.get(Q.id) ?? {
            name: Q.name,
            args: []
          };
          Q.name && (f.name = Q.name), Q.args && f.args.push(Q.args), g.set(Q.id, f);
        }
      } else if (Q.type === "server_tool_call") {
        yield* u();
        const f = Q.id ?? "";
        f && (a.add(f), o.delete(f)), yield B(Q);
      } else if (Q.type === "server_tool_call_chunk") {
        if (Q.id) {
          const f = o.get(Q.id) ?? {
            name: Q.name,
            args: []
          };
          Q.name && (f.name = Q.name), Q.args && f.args.push(Q.args), o.set(Q.id, f);
        }
      } else if (Q.type === "server_tool_call_result")
        yield* u(), yield h(Q);
      else if (Q.type !== "audio") if (Q.type === "file") {
        const f = E(Q);
        f && I([f]);
      } else if (Q.type === "image") {
        const f = C(Q);
        f && I([f]);
      } else if (Q.type === "video") {
        const f = E(Q);
        f && I([f]);
      } else Q.type === "text-plain" ? Q.text && I([{
        type: "input_text",
        text: Q.text
      }]) : Q.type === "non_standard" && A && (yield* u(), yield Q.value);
    }
    yield* u();
    for (const [Q, f] of g) {
      if (!Q || s.has(Q)) continue;
      const p = f.args.join("");
      !f.name && !p || (yield {
        type: "function_call",
        call_id: Q,
        name: f.name ?? "",
        arguments: p
      });
    }
    for (const [Q, f] of o) {
      if (!Q || a.has(Q)) continue;
      const p = f.args.join("");
      !f.name && !p || (yield {
        type: "function_call",
        call_id: Q,
        name: f.name ?? "",
        arguments: p
      });
    }
  }
  return Array.from(e());
}, Tv = ({ messages: t, zdrEnabled: A, model: e }) => t.flatMap((r) => {
  var a, g, o, u;
  const i = r.response_metadata;
  if ((i == null ? void 0 : i.output_version) === "v1") return dX(r);
  const n = r.additional_kwargs;
  let s = JE(r);
  if (s === "system" && KE(e) && (s = "developer"), s === "function") throw new Error("Function messages are not supported in Responses API");
  if (s === "tool") {
    const I = r;
    return (n == null ? void 0 : n.type) === "computer_call_output" ? {
      type: "computer_call_output",
      output: (() => {
        if (typeof I.content == "string") return {
          type: "computer_screenshot",
          image_url: I.content
        };
        if (Array.isArray(I.content)) {
          const C = I.content.find((l) => l.type === "computer_screenshot");
          if (C) return C;
          const E = I.content.find((l) => l.type === "image_url");
          if (E) return {
            type: "computer_screenshot",
            image_url: typeof E.image_url == "string" ? E.image_url : E.image_url.url
          };
        }
        throw new Error("Invalid computer call output");
      })(),
      call_id: I.tool_call_id
    } : (a = I.additional_kwargs) != null && a.customTool ? {
      type: "custom_tool_call_output",
      call_id: I.tool_call_id,
      output: I.content
    } : {
      type: "function_call_output",
      call_id: I.tool_call_id,
      id: (g = I.id) != null && g.startsWith("fc_") ? I.id : void 0,
      output: typeof I.content != "string" ? JSON.stringify(I.content) : I.content
    };
  }
  if (s === "assistant") {
    if (!A && (i == null ? void 0 : i.output) != null && Array.isArray(i == null ? void 0 : i.output) && (i == null ? void 0 : i.output.length) > 0 && (i != null && i.output.every((B) => "type" in B))) return i == null ? void 0 : i.output;
    const I = [];
    if (n != null && n.reasoning && !A) {
      const B = hX(n.reasoning);
      I.push(B);
    }
    let { content: c } = r;
    n != null && n.refusal && (typeof c == "string" && (c = [{
      type: "output_text",
      text: c,
      annotations: []
    }]), c = [...c, {
      type: "refusal",
      refusal: n.refusal
    }]), (typeof c == "string" || c.length > 0) && I.push({
      type: "message",
      role: "assistant",
      ...r.id && !A && r.id.startsWith("msg_") ? { id: r.id } : {},
      content: cg(() => typeof c == "string" ? c : c.flatMap((B) => B.type === "text" ? {
        type: "output_text",
        text: B.text,
        annotations: B.annotations ?? []
      } : B.type === "output_text" || B.type === "refusal" ? B : []))
    });
    const C = n == null ? void 0 : n[$g];
    jt.isInstance(r) && ((o = r.tool_calls) != null && o.length) ? I.push(...r.tool_calls.map((B) => t9(B) ? {
      type: "custom_tool_call",
      id: B.call_id,
      call_id: B.id ?? "",
      input: B.args.input,
      name: B.name
    } : {
      type: "function_call",
      name: B.name,
      arguments: JSON.stringify(B.args),
      call_id: B.id,
      ...A ? {} : { id: C == null ? void 0 : C[B.id] }
    })) : n != null && n.tool_calls && I.push(...n.tool_calls.map((B) => ({
      type: "function_call",
      name: B.function.name,
      call_id: B.id,
      arguments: B.function.arguments,
      ...A ? {} : { id: C == null ? void 0 : C[B.id] }
    })));
    const E = (u = i == null ? void 0 : i.output) != null && u.length ? i == null ? void 0 : i.output : n.tool_outputs, l = [
      "computer_call",
      "mcp_call",
      "code_interpreter_call",
      "image_generation_call"
    ];
    if (E != null) {
      const B = E, h = B == null ? void 0 : B.filter((Q) => l.includes(Q.type));
      h.length > 0 && I.push(...h);
    }
    return I;
  }
  if (s === "user" || s === "system" || s === "developer") {
    if (typeof r.content == "string") return {
      type: "message",
      role: s,
      content: r.content
    };
    const I = [], c = r.content.flatMap((C) => {
      if (C.type === "mcp_approval_response" && I.push({
        type: "mcp_approval_response",
        approval_request_id: C.approval_request_id,
        approve: C.approve
      }), dn(C)) return p0(C, aU);
      if (C.type === "text") return {
        type: "input_text",
        text: C.text
      };
      if (C.type === "image_url") {
        const E = cg(() => {
          if (typeof C.image_url == "string") return C.image_url;
          if (typeof C.image_url == "object" && C.image_url !== null && "url" in C.image_url) return C.image_url.url;
        }), l = cg(() => {
          if (typeof C.image_url == "string") return "auto";
          if (typeof C.image_url == "object" && C.image_url !== null && "detail" in C.image_url) return C.image_url.detail;
        });
        return {
          type: "input_image",
          image_url: E,
          detail: l
        };
      }
      return C.type === "input_text" || C.type === "input_image" || C.type === "input_file" ? C : [];
    });
    return c.length > 0 && I.push({
      type: "message",
      role: s,
      content: c
    }), I;
  }
  return console.warn(`Unsupported role found when converting to OpenAI Responses API: ${s}`), [];
});
var fX = class extends pS {
  invocationParams(t) {
    var i;
    let A;
    (t == null ? void 0 : t.strict) !== void 0 ? A = t.strict : this.supportsStrictToolCalling !== void 0 && (A = this.supportsStrictToolCalling);
    const e = {
      model: this.model,
      temperature: this.temperature,
      top_p: this.topP,
      user: this.user,
      stream: this.streaming,
      previous_response_id: t == null ? void 0 : t.previous_response_id,
      truncation: t == null ? void 0 : t.truncation,
      include: t == null ? void 0 : t.include,
      tools: (i = t == null ? void 0 : t.tools) != null && i.length ? this._reduceChatOpenAITools(t.tools, {
        stream: this.streaming,
        strict: A
      }) : void 0,
      tool_choice: A9(t == null ? void 0 : t.tool_choice) ? t == null ? void 0 : t.tool_choice : (() => {
        const n = xG(t == null ? void 0 : t.tool_choice);
        if (typeof n == "object" && "type" in n) {
          if (n.type === "function") return {
            type: "function",
            name: n.function.name
          };
          if (n.type === "allowed_tools") return {
            type: "allowed_tools",
            mode: n.allowed_tools.mode,
            tools: n.allowed_tools.tools
          };
          if (n.type === "custom") return {
            type: "custom",
            name: n.custom.name
          };
        }
      })(),
      text: (() => {
        if (t != null && t.text) return t.text;
        const n = this._getResponseFormat(t == null ? void 0 : t.response_format);
        return (n == null ? void 0 : n.type) === "json_schema" ? n.json_schema.schema != null ? {
          format: {
            type: "json_schema",
            schema: n.json_schema.schema,
            description: n.json_schema.description,
            name: n.json_schema.name,
            strict: n.json_schema.strict
          },
          verbosity: t == null ? void 0 : t.verbosity
        } : void 0 : {
          format: n,
          verbosity: t == null ? void 0 : t.verbosity
        };
      })(),
      parallel_tool_calls: t == null ? void 0 : t.parallel_tool_calls,
      max_output_tokens: this.maxTokens === -1 ? void 0 : this.maxTokens,
      prompt_cache_key: (t == null ? void 0 : t.promptCacheKey) ?? this.promptCacheKey,
      ...this.zdrEnabled ? { store: !1 } : {},
      ...this.modelKwargs
    }, r = this._getReasoningParams(t);
    return r !== void 0 && (e.reasoning = r), e;
  }
  async _generate(t, A) {
    var r;
    const e = this.invocationParams(A);
    if (e.stream) {
      const i = this._streamResponseChunks(t, A);
      let n;
      for await (const s of i)
        s.message.response_metadata = {
          ...s.generationInfo,
          ...s.message.response_metadata
        }, n = (n == null ? void 0 : n.concat(s)) ?? s;
      return {
        generations: n ? [n] : [],
        llmOutput: { estimatedTokenUsage: (r = n == null ? void 0 : n.message) == null ? void 0 : r.usage_metadata }
      };
    } else {
      const i = await this.completionWithRetry({
        input: Tv({
          messages: t,
          zdrEnabled: this.zdrEnabled ?? !1,
          model: this.model
        }),
        ...e,
        stream: !1
      }, {
        signal: A == null ? void 0 : A.signal,
        ...A == null ? void 0 : A.options
      });
      return {
        generations: [{
          text: i.output_text,
          message: gU(i)
        }],
        llmOutput: {
          id: i.id,
          estimatedTokenUsage: i.usage ? {
            promptTokens: i.usage.input_tokens,
            completionTokens: i.usage.output_tokens,
            totalTokens: i.usage.total_tokens
          } : void 0
        }
      };
    }
  }
  async *_streamResponseChunks(t, A, e) {
    const r = await this.completionWithRetry({
      ...this.invocationParams(A),
      input: Tv({
        messages: t,
        zdrEnabled: this.zdrEnabled ?? !1,
        model: this.model
      }),
      stream: !0
    }, A);
    for await (const i of r) {
      const n = QX(i);
      n != null && (yield n, await (e == null ? void 0 : e.handleLLMNewToken(n.text || "", {
        prompt: A.promptIndex ?? 0,
        completion: 0
      }, void 0, void 0, void 0, { chunk: n })));
    }
  }
  async completionWithRetry(t, A) {
    return this.caller.call(async () => {
      var r, i;
      const e = this._getClientOptions(A);
      try {
        return ((i = (r = t.text) == null ? void 0 : r.format) == null ? void 0 : i.type) === "json_schema" && !t.stream ? await this.client.responses.parse(t, e) : await this.client.responses.create(t, e);
      } catch (n) {
        throw cL(n);
      }
    });
  }
  /** @internal */
  _reduceChatOpenAITools(t, A) {
    const e = [];
    for (const r of t) if (BS(r))
      r.type === "image_generation" && (A != null && A.stream) && (r.partial_images = 1), e.push(r);
    else if (Td(r)) {
      const i = r.metadata.customTool;
      e.push({
        type: "custom",
        name: i.name,
        description: i.description,
        format: i.format
      });
    } else hS(r) ? e.push({
      type: "function",
      name: r.function.name,
      parameters: r.function.parameters,
      description: r.function.description,
      strict: (A == null ? void 0 : A.strict) ?? null
    }) : GG(r) && e.push(r9(r));
    return e;
  }
}, pX = class uU extends pS {
  constructor(e) {
    super(e);
    /**
    * Whether to use the responses API for all requests. If `false` the responses API will be used
    * only when required in order to fulfill the request.
    */
    R(this, "useResponsesApi", !1);
    R(this, "responses");
    R(this, "completions");
    this.fields = e, this.useResponsesApi = (e == null ? void 0 : e.useResponsesApi) ?? !1, this.responses = (e == null ? void 0 : e.responses) ?? new fX(e), this.completions = (e == null ? void 0 : e.completions) ?? new EX(e);
  }
  get lc_serializable_keys() {
    return [...super.lc_serializable_keys, "useResponsesApi"];
  }
  get callKeys() {
    return [...super.callKeys, "useResponsesApi"];
  }
  _useResponsesApi(e) {
    var s, a, g, o, u;
    const r = (s = e == null ? void 0 : e.tools) == null ? void 0 : s.some(BS), i = (e == null ? void 0 : e.previous_response_id) != null || (e == null ? void 0 : e.text) != null || (e == null ? void 0 : e.truncation) != null || (e == null ? void 0 : e.include) != null || ((a = e == null ? void 0 : e.reasoning) == null ? void 0 : a.summary) != null || ((g = this.reasoning) == null ? void 0 : g.summary) != null, n = ((o = e == null ? void 0 : e.tools) == null ? void 0 : o.some(GG)) || ((u = e == null ? void 0 : e.tools) == null ? void 0 : u.some(Td));
    return this.useResponsesApi || r || i || n;
  }
  getLsParams(e) {
    const r = this._combineCallOptions(e);
    return this._useResponsesApi(e) ? this.responses.getLsParams(r) : this.completions.getLsParams(r);
  }
  invocationParams(e) {
    const r = this._combineCallOptions(e);
    return this._useResponsesApi(e) ? this.responses.invocationParams(r) : this.completions.invocationParams(r);
  }
  /** @ignore */
  async _generate(e, r, i) {
    return this._useResponsesApi(r) ? this.responses._generate(e, r) : this.completions._generate(e, r, i);
  }
  async *_streamResponseChunks(e, r, i) {
    if (this._useResponsesApi(r)) {
      yield* this.responses._streamResponseChunks(e, this._combineCallOptions(r), i);
      return;
    }
    yield* this.completions._streamResponseChunks(e, this._combineCallOptions(r), i);
  }
  withConfig(e) {
    const r = new uU(this.fields);
    return r.defaultOptions = {
      ...this.defaultOptions,
      ...e
    }, r;
  }
}, yX = {};
fe(yX, {
  BaseLLM: () => cU,
  LLM: () => wX
});
var cU = class SC extends dS {
  constructor() {
    super(...arguments);
    R(this, "lc_namespace", [
      "langchain",
      "llms",
      this._llmType()
    ]);
  }
  /**
  * This method takes an input and options, and returns a string. It
  * converts the input to a prompt value and generates a result based on
  * the prompt.
  * @param input Input for the LLM.
  * @param options Options for the LLM call.
  * @returns A string result based on the prompt.
  */
  async invoke(e, r) {
    const i = SC._convertInputToPromptValue(e);
    return (await this.generatePrompt([i], r, r == null ? void 0 : r.callbacks)).generations[0][0].text;
  }
  async *_streamResponseChunks(e, r, i) {
    throw new Error("Not implemented.");
  }
  _separateRunnableConfigFromCallOptionsCompat(e) {
    const [r, i] = super._separateRunnableConfigFromCallOptions(e);
    return i.signal = r.signal, [r, i];
  }
  async *_streamIterator(e, r) {
    if (this._streamResponseChunks === SC.prototype._streamResponseChunks) yield this.invoke(e, r);
    else {
      const i = SC._convertInputToPromptValue(e), [n, s] = this._separateRunnableConfigFromCallOptionsCompat(r), a = await fr.configure(n.callbacks, this.callbacks, n.tags, this.tags, n.metadata, this.metadata, { verbose: this.verbose }), g = {
        options: s,
        invocation_params: this == null ? void 0 : this.invocationParams(s),
        batch_size: 1
      }, o = await (a == null ? void 0 : a.handleLLMStart(this.toJSON(), [i.toString()], n.runId, void 0, g, void 0, void 0, n.runName));
      let u = new Hc({ text: "" });
      try {
        for await (const I of this._streamResponseChunks(i.toString(), s, o == null ? void 0 : o[0]))
          u ? u = u.concat(I) : u = I, typeof I.text == "string" && (yield I.text);
      } catch (I) {
        throw await Promise.all((o ?? []).map((c) => c == null ? void 0 : c.handleLLMError(I))), I;
      }
      await Promise.all((o ?? []).map((I) => I == null ? void 0 : I.handleLLMEnd({ generations: [[u]] })));
    }
  }
  /**
  * This method takes prompt values, options, and callbacks, and generates
  * a result based on the prompts.
  * @param promptValues Prompt values for the LLM.
  * @param options Options for the LLM call.
  * @param callbacks Callbacks for the LLM call.
  * @returns An LLMResult based on the prompts.
  */
  async generatePrompt(e, r, i) {
    const n = e.map((s) => s.toString());
    return this.generate(n, r, i);
  }
  /**
  * Get the parameters used to invoke the model
  */
  invocationParams(e) {
    return {};
  }
  _flattenLLMResult(e) {
    const r = [];
    for (let i = 0; i < e.generations.length; i += 1) {
      const n = e.generations[i];
      if (i === 0) r.push({
        generations: [n],
        llmOutput: e.llmOutput
      });
      else {
        const s = e.llmOutput ? {
          ...e.llmOutput,
          tokenUsage: {}
        } : void 0;
        r.push({
          generations: [n],
          llmOutput: s
        });
      }
    }
    return r;
  }
  /** @ignore */
  async _generateUncached(e, r, i, n) {
    let s;
    if (n !== void 0 && n.length === e.length) s = n;
    else {
      const u = await fr.configure(i.callbacks, this.callbacks, i.tags, this.tags, i.metadata, this.metadata, { verbose: this.verbose }), I = {
        options: r,
        invocation_params: this == null ? void 0 : this.invocationParams(r),
        batch_size: e.length
      };
      s = await (u == null ? void 0 : u.handleLLMStart(this.toJSON(), e, i.runId, void 0, I, void 0, void 0, i == null ? void 0 : i.runName));
    }
    const a = !!(s != null && s[0].handlers.find(_0));
    let g;
    if (a && e.length === 1 && this._streamResponseChunks !== SC.prototype._streamResponseChunks) try {
      const u = await this._streamResponseChunks(e[0], r, s == null ? void 0 : s[0]);
      let I;
      for await (const c of u) I === void 0 ? I = c : I = _a(I, c);
      if (I === void 0) throw new Error("Received empty response from chat model call.");
      g = {
        generations: [[I]],
        llmOutput: {}
      }, await (s == null ? void 0 : s[0].handleLLMEnd(g));
    } catch (u) {
      throw await (s == null ? void 0 : s[0].handleLLMError(u)), u;
    }
    else {
      try {
        g = await this._generate(e, r, s == null ? void 0 : s[0]);
      } catch (I) {
        throw await Promise.all((s ?? []).map((c) => c == null ? void 0 : c.handleLLMError(I))), I;
      }
      const u = this._flattenLLMResult(g);
      await Promise.all((s ?? []).map((I, c) => I == null ? void 0 : I.handleLLMEnd(u[c])));
    }
    const o = (s == null ? void 0 : s.map((u) => u.runId)) || void 0;
    return Object.defineProperty(g, $C, {
      value: o ? { runIds: o } : void 0,
      configurable: !0
    }), g;
  }
  async _generateCached({ prompts: e, cache: r, llmStringKey: i, parsedOptions: n, handledOptions: s, runId: a }) {
    const g = await fr.configure(s.callbacks, this.callbacks, s.tags, this.tags, s.metadata, this.metadata, { verbose: this.verbose }), o = {
      options: n,
      invocation_params: this == null ? void 0 : this.invocationParams(n),
      batch_size: e.length
    }, u = await (g == null ? void 0 : g.handleLLMStart(this.toJSON(), e, a, void 0, o, void 0, void 0, s == null ? void 0 : s.runName)), I = [], C = (await Promise.allSettled(e.map(async (B, h) => {
      const Q = await r.lookup(B, i);
      return Q == null && I.push(h), Q;
    }))).map((B, h) => ({
      result: B,
      runManager: u == null ? void 0 : u[h]
    })).filter(({ result: B }) => B.status === "fulfilled" && B.value != null || B.status === "rejected"), E = [];
    await Promise.all(C.map(async ({ result: B, runManager: h }, Q) => {
      if (B.status === "fulfilled") {
        const f = B.value;
        return E[Q] = f.map((p) => (p.generationInfo = {
          ...p.generationInfo,
          tokenUsage: {}
        }, p)), f.length && await (h == null ? void 0 : h.handleLLMNewToken(f[0].text)), h == null ? void 0 : h.handleLLMEnd({ generations: [f] }, void 0, void 0, void 0, { cached: !0 });
      } else
        return await (h == null ? void 0 : h.handleLLMError(B.reason, void 0, void 0, void 0, { cached: !0 })), Promise.reject(B.reason);
    }));
    const l = {
      generations: E,
      missingPromptIndices: I,
      startedRunManagers: u
    };
    return Object.defineProperty(l, $C, {
      value: u ? { runIds: u == null ? void 0 : u.map((B) => B.runId) } : void 0,
      configurable: !0
    }), l;
  }
  /**
  * Run the LLM on the given prompts and input, handling caching.
  */
  async generate(e, r, i) {
    if (!Array.isArray(e)) throw new Error("Argument 'prompts' is expected to be a string[]");
    let n;
    Array.isArray(r) ? n = { stop: r } : n = r;
    const [s, a] = this._separateRunnableConfigFromCallOptionsCompat(n);
    if (s.callbacks = s.callbacks ?? i, !this.cache) return this._generateUncached(e, a, s);
    const { cache: g } = this, o = this._getSerializedCacheKeyParametersForCall(a), { generations: u, missingPromptIndices: I, startedRunManagers: c } = await this._generateCached({
      prompts: e,
      cache: g,
      llmStringKey: o,
      parsedOptions: a,
      handledOptions: s,
      runId: s.runId
    });
    let C = {};
    if (I.length > 0) {
      const E = await this._generateUncached(I.map((l) => e[l]), a, s, c !== void 0 ? I.map((l) => c == null ? void 0 : c[l]) : void 0);
      await Promise.all(E.generations.map(async (l, B) => {
        const h = I[B];
        return u[h] = l, g.update(e[h], o, l);
      })), C = E.llmOutput ?? {};
    }
    return {
      generations: u,
      llmOutput: C
    };
  }
  /**
  * Get the identifying parameters of the LLM.
  */
  _identifyingParams() {
    return {};
  }
  _modelType() {
    return "base_llm";
  }
}, wX = class extends cU {
  async _generate(t, A, e) {
    return { generations: await Promise.all(t.map((i, n) => this._call(i, {
      ...A,
      promptIndex: n
    }, e).then((s) => [{ text: s }]))) };
  }
}, mX = {};
fe(mX, { chunkArray: () => DX });
const DX = (t, A) => t.reduce((e, r, i) => {
  const n = Math.floor(i / A), s = e[n] || [];
  return e[n] = s.concat([r]), e;
}, []);
var SX = {};
fe(SX, { Embeddings: () => FX });
var FX = class {
  constructor(t) {
    /**
    * The async caller should be used by subclasses to make any async calls,
    * which will thus benefit from the concurrency and retry logic.
    */
    R(this, "caller");
    this.caller = new UE(t ?? {});
  }
}, kX = {};
fe(kX, {
  BaseToolkit: () => vX,
  DynamicStructuredTool: () => lU,
  DynamicTool: () => CU,
  StructuredTool: () => fp,
  Tool: () => IU,
  ToolInputParsingException: () => dd,
  isLangChainTool: () => Cp,
  isRunnableToolLike: () => CS,
  isStructuredTool: () => IS,
  isStructuredToolParams: () => lS,
  tool: () => RX
});
var fp = class extends QS {
  constructor(A) {
    super(A ?? {});
    /**
    * Optional provider-specific extra fields for the tool.
    *
    * This is used to pass provider-specific configuration that doesn't fit into
    * standard tool fields.
    */
    R(this, "extras");
    /**
    * Whether to return the tool's output directly.
    *
    * Setting this to true means that after the tool is called,
    * an agent should stop looping.
    */
    R(this, "returnDirect", !1);
    R(this, "verboseParsingErrors", !1);
    /**
    * The tool response format.
    *
    * If "content" then the output of the tool is interpreted as the contents of a
    * ToolMessage. If "content_and_artifact" then the output is expected to be a
    * two-tuple corresponding to the (content, artifact) of a ToolMessage.
    *
    * @default "content"
    */
    R(this, "responseFormat", "content");
    /**
    * Default config object for the tool runnable.
    */
    R(this, "defaultConfig");
    this.verboseParsingErrors = (A == null ? void 0 : A.verboseParsingErrors) ?? this.verboseParsingErrors, this.responseFormat = (A == null ? void 0 : A.responseFormat) ?? this.responseFormat, this.defaultConfig = (A == null ? void 0 : A.defaultConfig) ?? this.defaultConfig, this.metadata = (A == null ? void 0 : A.metadata) ?? this.metadata, this.extras = (A == null ? void 0 : A.extras) ?? this.extras;
  }
  get lc_namespace() {
    return ["langchain", "tools"];
  }
  /**
  * Invokes the tool with the provided input and configuration.
  * @param input The input for the tool.
  * @param config Optional configuration for the tool.
  * @returns A Promise that resolves with the tool's output.
  */
  async invoke(A, e) {
    let r, i = Se(wd(this.defaultConfig, e));
    return xC(A) ? (r = A.args, i = {
      ...i,
      toolCall: A
    }) : r = A, this.call(r, i);
  }
  /**
  * @deprecated Use .invoke() instead. Will be removed in 0.3.0.
  *
  * Calls the tool with the provided argument, configuration, and tags. It
  * parses the input according to the schema, handles any errors, and
  * manages callbacks.
  * @param arg The input argument for the tool.
  * @param configArg Optional configuration or callbacks for the tool.
  * @param tags Optional tags for the tool.
  * @returns A Promise that resolves with a string.
  */
  async call(A, e, r) {
    const i = xC(A) ? A.args : A;
    let n;
    if (In(this.schema)) try {
      n = await op(this.schema, i);
    } catch (E) {
      let l = "Received tool input did not match expected schema";
      throw this.verboseParsingErrors && (l = `${l}
Details: ${E.message}`), cG(E) && (l = `${l}

${eq(E)}`), new dd(l, JSON.stringify(A));
    }
    else {
      const E = We(i, this.schema);
      if (!E.valid) {
        let l = "Received tool input did not match expected schema";
        throw this.verboseParsingErrors && (l = `${l}
Details: ${E.errors.map((B) => `${B.keywordLocation}: ${B.error}`).join(`
`)}`), new dd(l, JSON.stringify(A));
      }
      n = i;
    }
    const s = $f(e), a = fr.configure(s.callbacks, this.callbacks, s.tags || r, this.tags, s.metadata, this.metadata, { verbose: this.verbose }), g = await (a == null ? void 0 : a.handleToolStart(this.toJSON(), typeof A == "string" ? A : JSON.stringify(A), s.runId, void 0, void 0, void 0, s.runName));
    delete s.runId;
    let o;
    try {
      o = await this._call(n, g, s);
    } catch (E) {
      throw await (g == null ? void 0 : g.handleToolError(E)), E;
    }
    let u, I;
    if (this.responseFormat === "content_and_artifact") if (Array.isArray(o) && o.length === 2) [u, I] = o;
    else throw new Error(`Tool response format is "content_and_artifact" but the output was not a two-tuple.
Result: ${JSON.stringify(o)}`);
    else u = o;
    let c;
    xC(A) && (c = A.id), !c && JP(s) && (c = s.toolCall.id);
    const C = bX({
      content: u,
      artifact: I,
      toolCallId: c,
      name: this.name,
      metadata: this.metadata
    });
    return await (g == null ? void 0 : g.handleToolEnd(C)), C;
  }
}, IU = class extends fp {
  constructor(A) {
    super(A);
    R(this, "schema", Ip({ input: cp().optional() }).transform((A) => A.input));
  }
  /**
  * @deprecated Use .invoke() instead. Will be removed in 0.3.0.
  *
  * Calls the tool with the provided argument and callbacks. It handles
  * string inputs specifically.
  * @param arg The input argument for the tool, which can be a string, undefined, or an input of the tool's schema.
  * @param callbacks Optional callbacks for the tool.
  * @returns A Promise that resolves with a string.
  */
  call(A, e) {
    const r = typeof A == "string" || A == null ? { input: A } : A;
    return super.call(r, e);
  }
}, CU = class extends IU {
  constructor(A) {
    super(A);
    R(this, "name");
    R(this, "description");
    R(this, "func");
    this.name = A.name, this.description = A.description, this.func = A.func, this.returnDirect = A.returnDirect ?? this.returnDirect;
  }
  static lc_name() {
    return "DynamicTool";
  }
  /**
  * @deprecated Use .invoke() instead. Will be removed in 0.3.0.
  */
  async call(A, e) {
    const r = $f(e);
    return r.runName === void 0 && (r.runName = this.name), super.call(A, r);
  }
  /** @ignore */
  async _call(A, e, r) {
    return this.func(A, e, r);
  }
}, lU = class extends fp {
  constructor(A) {
    super(A);
    R(this, "name");
    R(this, "description");
    R(this, "func");
    R(this, "schema");
    this.name = A.name, this.description = A.description, this.func = A.func, this.returnDirect = A.returnDirect ?? this.returnDirect, this.schema = A.schema;
  }
  static lc_name() {
    return "DynamicStructuredTool";
  }
  /**
  * @deprecated Use .invoke() instead. Will be removed in 0.3.0.
  */
  async call(A, e, r) {
    const i = $f(e);
    return i.runName === void 0 && (i.runName = this.name), super.call(A, i, r);
  }
  _call(A, e, r) {
    return this.func(A, e, r);
  }
}, vX = class {
  getTools() {
    return this.tools;
  }
};
function RX(t, A) {
  var s;
  const e = iS(A.schema), r = TC(A.schema);
  if (!A.schema || e || r) return new CU({
    ...A,
    description: A.description ?? ((s = A.schema) == null ? void 0 : s.description) ?? `${A.name} tool`,
    func: async (a, g, o) => new Promise((u, I) => {
      const c = Ye(o, { callbacks: g == null ? void 0 : g.getChild() });
      Ri.runWithConfig(ls(c), async () => {
        try {
          u(t(a, c));
        } catch (C) {
          I(C);
        }
      });
    })
  });
  const i = A.schema, n = A.description ?? A.schema.description ?? `${A.name} tool`;
  return new lU({
    ...A,
    description: n,
    schema: i,
    func: async (a, g, o) => new Promise((u, I) => {
      let c;
      const C = () => {
        o != null && o.signal && c && o.signal.removeEventListener("abort", c);
      };
      o != null && o.signal && (c = () => {
        C(), I(XC(o.signal));
      }, o.signal.addEventListener("abort", c));
      const E = Ye(o, { callbacks: g == null ? void 0 : g.getChild() });
      Ri.runWithConfig(ls(E), async () => {
        var l;
        try {
          const B = await t(a, E);
          if ((l = o == null ? void 0 : o.signal) != null && l.aborted) {
            C();
            return;
          }
          C(), u(B);
        } catch (B) {
          C(), I(B);
        }
      });
    })
  });
}
function bX(t) {
  const { content: A, artifact: e, toolCallId: r, metadata: i } = t;
  return r && !F0(A) ? typeof A == "string" || Array.isArray(A) && A.every((n) => typeof n == "object") ? new fn({
    status: "success",
    content: A,
    artifact: e,
    tool_call_id: r,
    name: t.name,
    metadata: i
  }) : new fn({
    status: "success",
    content: MX(A),
    artifact: e,
    tool_call_id: r,
    name: t.name,
    metadata: i
  }) : A;
}
function MX(t) {
  try {
    return JSON.stringify(t, null, 2) ?? "";
  } catch {
    return `${t}`;
  }
}
var ys = { exports: {} };
const _X = "17.2.3", NX = {
  version: _X
}, km = Rf, Pd = SE, LX = ZD, xX = un, GX = NX, yS = GX.version, Kv = [
  "ðŸ” encrypt with Dotenvx: https://dotenvx.com",
  "ðŸ” prevent committing .env to code: https://dotenvx.com/precommit",
  "ðŸ” prevent building .env in docker: https://dotenvx.com/prebuild",
  "ðŸ“¡ add observability to secrets: https://dotenvx.com/ops",
  "ðŸ‘¥ sync secrets across teammates & machines: https://dotenvx.com/ops",
  "ðŸ—‚ï¸ backup and recover secrets: https://dotenvx.com/ops",
  "âœ… audit secrets and track compliance: https://dotenvx.com/ops",
  "ðŸ”„ add secrets lifecycle management: https://dotenvx.com/ops",
  "ðŸ”‘ add access controls to secrets: https://dotenvx.com/ops",
  "ðŸ› ï¸  run anywhere with `dotenvx run -- yourcommand`",
  "âš™ï¸  specify custom .env file path with { path: '/custom/path/.env' }",
  "âš™ï¸  enable debug logging with { debug: true }",
  "âš™ï¸  override existing env vars with { override: true }",
  "âš™ï¸  suppress all logs with { quiet: true }",
  "âš™ï¸  write to custom object with { processEnv: myObject }",
  "âš™ï¸  load multiple .env files with { path: ['.env.local', '.env'] }"
];
function UX() {
  return Kv[Math.floor(Math.random() * Kv.length)];
}
function Au(t) {
  return typeof t == "string" ? !["false", "0", "no", "off", ""].includes(t.toLowerCase()) : !!t;
}
function TX() {
  return process.stdout.isTTY;
}
function KX(t) {
  return TX() ? `\x1B[2m${t}\x1B[0m` : t;
}
const JX = /(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/mg;
function HX(t) {
  const A = {};
  let e = t.toString();
  e = e.replace(/\r\n?/mg, `
`);
  let r;
  for (; (r = JX.exec(e)) != null; ) {
    const i = r[1];
    let n = r[2] || "";
    n = n.trim();
    const s = n[0];
    n = n.replace(/^(['"`])([\s\S]*)\1$/mg, "$2"), s === '"' && (n = n.replace(/\\n/g, `
`), n = n.replace(/\\r/g, "\r")), A[i] = n;
  }
  return A;
}
function PX(t) {
  t = t || {};
  const A = hU(t);
  t.path = A;
  const e = dt.configDotenv(t);
  if (!e.parsed) {
    const s = new Error(`MISSING_DATA: Cannot parse ${A} for an unknown reason`);
    throw s.code = "MISSING_DATA", s;
  }
  const r = EU(t).split(","), i = r.length;
  let n;
  for (let s = 0; s < i; s++)
    try {
      const a = r[s].trim(), g = YX(e, a);
      n = dt.decrypt(g.ciphertext, g.key);
      break;
    } catch (a) {
      if (s + 1 >= i)
        throw a;
    }
  return dt.parse(n);
}
function OX(t) {
  console.error(`[dotenv@${yS}][WARN] ${t}`);
}
function KC(t) {
  console.log(`[dotenv@${yS}][DEBUG] ${t}`);
}
function BU(t) {
  console.log(`[dotenv@${yS}] ${t}`);
}
function EU(t) {
  return t && t.DOTENV_KEY && t.DOTENV_KEY.length > 0 ? t.DOTENV_KEY : process.env.DOTENV_KEY && process.env.DOTENV_KEY.length > 0 ? process.env.DOTENV_KEY : "";
}
function YX(t, A) {
  let e;
  try {
    e = new URL(A);
  } catch (a) {
    if (a.code === "ERR_INVALID_URL") {
      const g = new Error("INVALID_DOTENV_KEY: Wrong format. Must be in valid uri format like dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=development");
      throw g.code = "INVALID_DOTENV_KEY", g;
    }
    throw a;
  }
  const r = e.password;
  if (!r) {
    const a = new Error("INVALID_DOTENV_KEY: Missing key part");
    throw a.code = "INVALID_DOTENV_KEY", a;
  }
  const i = e.searchParams.get("environment");
  if (!i) {
    const a = new Error("INVALID_DOTENV_KEY: Missing environment part");
    throw a.code = "INVALID_DOTENV_KEY", a;
  }
  const n = `DOTENV_VAULT_${i.toUpperCase()}`, s = t.parsed[n];
  if (!s) {
    const a = new Error(`NOT_FOUND_DOTENV_ENVIRONMENT: Cannot locate environment ${n} in your .env.vault file.`);
    throw a.code = "NOT_FOUND_DOTENV_ENVIRONMENT", a;
  }
  return { ciphertext: s, key: r };
}
function hU(t) {
  let A = null;
  if (t && t.path && t.path.length > 0)
    if (Array.isArray(t.path))
      for (const e of t.path)
        km.existsSync(e) && (A = e.endsWith(".vault") ? e : `${e}.vault`);
    else
      A = t.path.endsWith(".vault") ? t.path : `${t.path}.vault`;
  else
    A = Pd.resolve(process.cwd(), ".env.vault");
  return km.existsSync(A) ? A : null;
}
function Jv(t) {
  return t[0] === "~" ? Pd.join(LX.homedir(), t.slice(1)) : t;
}
function qX(t) {
  const A = Au(process.env.DOTENV_CONFIG_DEBUG || t && t.debug), e = Au(process.env.DOTENV_CONFIG_QUIET || t && t.quiet);
  (A || !e) && BU("Loading env from encrypted .env.vault");
  const r = dt._parseVault(t);
  let i = process.env;
  return t && t.processEnv != null && (i = t.processEnv), dt.populate(i, r, t), { parsed: r };
}
function jX(t) {
  const A = Pd.resolve(process.cwd(), ".env");
  let e = "utf8", r = process.env;
  t && t.processEnv != null && (r = t.processEnv);
  let i = Au(r.DOTENV_CONFIG_DEBUG || t && t.debug), n = Au(r.DOTENV_CONFIG_QUIET || t && t.quiet);
  t && t.encoding ? e = t.encoding : i && KC("No encoding is specified. UTF-8 is used by default");
  let s = [A];
  if (t && t.path)
    if (!Array.isArray(t.path))
      s = [Jv(t.path)];
    else {
      s = [];
      for (const u of t.path)
        s.push(Jv(u));
    }
  let a;
  const g = {};
  for (const u of s)
    try {
      const I = dt.parse(km.readFileSync(u, { encoding: e }));
      dt.populate(g, I, t);
    } catch (I) {
      i && KC(`Failed to load ${u} ${I.message}`), a = I;
    }
  const o = dt.populate(r, g, t);
  if (i = Au(r.DOTENV_CONFIG_DEBUG || i), n = Au(r.DOTENV_CONFIG_QUIET || n), i || !n) {
    const u = Object.keys(o).length, I = [];
    for (const c of s)
      try {
        const C = Pd.relative(process.cwd(), c);
        I.push(C);
      } catch (C) {
        i && KC(`Failed to load ${c} ${C.message}`), a = C;
      }
    BU(`injecting env (${u}) from ${I.join(",")} ${KX(`-- tip: ${UX()}`)}`);
  }
  return a ? { parsed: g, error: a } : { parsed: g };
}
function WX(t) {
  if (EU(t).length === 0)
    return dt.configDotenv(t);
  const A = hU(t);
  return A ? dt._configVault(t) : (OX(`You set DOTENV_KEY but you are missing a .env.vault file at ${A}. Did you forget to build it?`), dt.configDotenv(t));
}
function VX(t, A) {
  const e = Buffer.from(A.slice(-64), "hex");
  let r = Buffer.from(t, "base64");
  const i = r.subarray(0, 12), n = r.subarray(-16);
  r = r.subarray(12, -16);
  try {
    const s = xX.createDecipheriv("aes-256-gcm", e, i);
    return s.setAuthTag(n), `${s.update(r)}${s.final()}`;
  } catch (s) {
    const a = s instanceof RangeError, g = s.message === "Invalid key length", o = s.message === "Unsupported state or unable to authenticate data";
    if (a || g) {
      const u = new Error("INVALID_DOTENV_KEY: It must be 64 characters long (or more)");
      throw u.code = "INVALID_DOTENV_KEY", u;
    } else if (o) {
      const u = new Error("DECRYPTION_FAILED: Please check your DOTENV_KEY");
      throw u.code = "DECRYPTION_FAILED", u;
    } else
      throw s;
  }
}
function ZX(t, A, e = {}) {
  const r = !!(e && e.debug), i = !!(e && e.override), n = {};
  if (typeof A != "object") {
    const s = new Error("OBJECT_REQUIRED: Please check the processEnv argument being passed to populate");
    throw s.code = "OBJECT_REQUIRED", s;
  }
  for (const s of Object.keys(A))
    Object.prototype.hasOwnProperty.call(t, s) ? (i === !0 && (t[s] = A[s], n[s] = A[s]), r && KC(i === !0 ? `"${s}" is already defined and WAS overwritten` : `"${s}" is already defined and was NOT overwritten`)) : (t[s] = A[s], n[s] = A[s]);
  return n;
}
const dt = {
  configDotenv: jX,
  _configVault: qX,
  _parseVault: PX,
  config: WX,
  decrypt: VX,
  parse: HX,
  populate: ZX
};
ys.exports.configDotenv = dt.configDotenv;
ys.exports._configVault = dt._configVault;
ys.exports._parseVault = dt._parseVault;
ys.exports.config = dt.config;
ys.exports.decrypt = dt.decrypt;
ys.exports.parse = dt.parse;
ys.exports.populate = dt.populate;
ys.exports = dt;
var XX = ys.exports;
const zX = /* @__PURE__ */ sI(XX);
class $X {
  constructor() {
    R(this, "tools", /* @__PURE__ */ new Map());
    R(this, "approvalHandler", null);
  }
  setApprovalHandler(A) {
    this.approvalHandler = A;
  }
  register(A) {
    this.tools.has(A.name) && console.warn(`Tool with name ${A.name} is already registered. Overwriting.`), this.tools.set(A.name, A);
  }
  getTool(A) {
    return this.tools.get(A);
  }
  getAllTools() {
    return Array.from(this.tools.values());
  }
  // Convert to LangChain tools format
  toLangChainTools() {
    return this.getAllTools().map((A) => {
      const e = this;
      return new class extends fp {
        constructor() {
          super(...arguments);
          R(this, "name", A.name);
          R(this, "description", A.description);
          R(this, "schema", A.schema);
        }
        async _call(i) {
          return A.requiresApproval && e.approvalHandler && !await e.approvalHandler(A.name, i) ? "User denied execution of this tool." : await A.execute(i);
        }
      }();
    });
  }
}
const Yt = new $X();
zX.config();
class Az {
  constructor() {
    R(this, "model");
    R(this, "onStep");
    const A = process.env.NVIDIA_API_KEY;
    A || console.warn("NVIDIA_API_KEY is not set in environment variables");
    const e = new pX({
      configuration: {
        baseURL: "https://integrate.api.nvidia.com/v1",
        apiKey: A
      },
      modelName: "meta/llama-3.1-70b-instruct",
      temperature: 0.1,
      streaming: !1,
      // Force JSON format via prompt + model config if supported, but Llama3 usually follows prompt well
      modelKwargs: { response_format: { type: "json_object" } }
    });
    this.model = e;
  }
  setStepHandler(A) {
    this.onStep = A;
  }
  emitStep(A, e, r) {
    this.onStep && this.onStep({ type: A, content: e, metadata: r });
  }
  async chat(A) {
    const e = Yt.toLangChainTools();
    try {
      const r = [
        new Zr(`You are a helpful enterprise assistant integrated into a browser. 
        
        You have access to the following tools:
        ${e.map((i) => {
          var n;
          return `- ${i.name}: ${i.description} (Args: ${JSON.stringify(((n = i.schema) == null ? void 0 : n.shape) || {})})`;
        }).join(`
`)}

        CRITICAL INSTRUCTIONS:
        1. You are an agent that MUST use tools to interact with the world.
        2. To call a tool, you MUST output a VALID JSON object in the following format:
           {
             "tool": "tool_name",
             "args": { "arg_name": "value" }
           }
        3. Do not output any other text when calling a tool. Just the JSON.
        4. If you have completed the task or need to ask the user something, output a JSON with tool "final_response":
           {
             "tool": "final_response",
             "args": { "message": "Your text here" }
           }

        BROWSER AUTOMATION STRATEGY:
        - You have no eyes. You must use "browser_observe" to see the page.
        - Step 1: ALWAYS call "browser_navigate" to the target URL.
        - Step 2: ALWAYS call "browser_observe" to see what is on the page.
        - Step 3: Use the selectors returned by "browser_observe" to call "browser_click" or "browser_type".
        - Step 4: Call "browser_observe" again to confirm the action worked.

        Example Interaction:
        User: "Go to Jira"
        Assistant: { "tool": "browser_navigate", "args": { "url": "http://localhost:3000/jira" } }
        User: Tool Output: "Navigated to..."
        Assistant: { "tool": "browser_observe", "args": {} }
        User: Tool Output: { "interactiveElements": [...] }
        Assistant: { "tool": "final_response", "args": { "message": "I have navigated to Jira." } }
        `),
        new Tr(A)
      ];
      for (let i = 0; i < 15; i++) {
        const n = await this.model.invoke(r), s = n.content;
        console.log(`[Agent Turn ${i}] Raw Response:`, s);
        let a;
        try {
          const o = s.replace(/```json/g, "").replace(/```/g, "").trim();
          a = JSON.parse(o), a.tool !== "final_response" && this.emitStep("thought", `Decided to call ${a.tool}`);
        } catch {
          console.warn("Failed to parse JSON response:", s), r.push(n), r.push(new Zr("Error: You must output valid JSON. Please try again using the specified format."));
          continue;
        }
        if (a.tool === "final_response")
          return a.args.message;
        const g = e.find((o) => o.name === a.tool);
        if (g) {
          console.log(`Executing tool: ${g.name} with args:`, a.args), this.emitStep("action", `Executing ${g.name}`, { tool: g.name, args: a.args });
          try {
            const o = await g.invoke(a.args);
            this.emitStep("observation", `Tool Output: ${o}`, { tool: g.name, result: o }), r.push(new jt(s)), r.push(new Tr(`Tool '${a.tool}' Output: ${o}`));
          } catch (o) {
            console.error(`Tool execution failed: ${o}`), r.push(new jt(s)), r.push(new Tr(`Tool Execution Error: ${o.message}`));
          }
        } else
          console.error(`Tool not found: ${a.tool}`), r.push(new jt(s)), r.push(new Zr(`Error: Tool '${a.tool}' not found. Available tools: ${e.map((o) => o.name).join(", ")}`));
      }
      return "I completed the actions, but reached the maximum number of steps.";
    } catch (r) {
      return console.error("Error in AgentService chat:", r), "Sorry, I encountered an error while processing your request.";
    }
  }
  // Future: Implement streaming support
  async *streamChat(A) {
    const e = await this.model.stream([
      new Zr("You are a helpful enterprise assistant integrated into a browser."),
      new Tr(A)
    ]);
    for await (const r of e)
      yield r.content;
  }
}
const Hv = new Az(), Tt = [];
for (let t = 0; t < 256; ++t)
  Tt.push((t + 256).toString(16).slice(1));
function ez(t, A = 0) {
  return (Tt[t[A + 0]] + Tt[t[A + 1]] + Tt[t[A + 2]] + Tt[t[A + 3]] + "-" + Tt[t[A + 4]] + Tt[t[A + 5]] + "-" + Tt[t[A + 6]] + Tt[t[A + 7]] + "-" + Tt[t[A + 8]] + Tt[t[A + 9]] + "-" + Tt[t[A + 10]] + Tt[t[A + 11]] + Tt[t[A + 12]] + Tt[t[A + 13]] + Tt[t[A + 14]] + Tt[t[A + 15]]).toLowerCase();
}
const HQ = new Uint8Array(256);
let Fh = HQ.length;
function tz() {
  return Fh > HQ.length - 16 && (bJ(HQ), Fh = 0), HQ.slice(Fh, Fh += 16);
}
const Pv = { randomUUID: MJ };
function rz(t, A, e) {
  var i;
  t = t || {};
  const r = t.random ?? ((i = t.rng) == null ? void 0 : i.call(t)) ?? tz();
  if (r.length < 16)
    throw new Error("Random bytes length must be >= 16");
  return r[6] = r[6] & 15 | 64, r[8] = r[8] & 63 | 128, ez(r);
}
function iz(t, A, e) {
  return Pv.randomUUID && !t ? Pv.randomUUID() : rz(t);
}
class nz {
  constructor() {
    R(this, "db");
    R(this, "encryptionKey", null);
    R(this, "DB_FILENAME", "audit_logs.db");
    const A = Tc.getPath("userData"), e = SE.join(A, this.DB_FILENAME);
    this.db = new _J(e), this.init();
  }
  async init() {
    this.db.exec(`
      CREATE TABLE IF NOT EXISTS audit_logs (
        id TEXT PRIMARY KEY,
        timestamp TEXT NOT NULL,
        actor TEXT NOT NULL,
        action TEXT NOT NULL,
        details TEXT,
        status TEXT NOT NULL
      )
    `), await this.loadOrGenerateKey();
  }
  async loadOrGenerateKey() {
    let A = await MC.getSecret("audit_db_key");
    A || (A = un.randomBytes(32).toString("hex"), await MC.setSecret("audit_db_key", A)), this.encryptionKey = Buffer.from(A, "hex");
  }
  encrypt(A) {
    if (!this.encryptionKey) return A;
    const e = un.randomBytes(16), r = un.createCipheriv("aes-256-cbc", this.encryptionKey, e);
    let i = r.update(A);
    return i = Buffer.concat([i, r.final()]), e.toString("hex") + ":" + i.toString("hex");
  }
  decrypt(A) {
    if (!this.encryptionKey) return A;
    try {
      const e = A.split(":"), r = Buffer.from(e.shift(), "hex"), i = Buffer.from(e.join(":"), "hex"), n = un.createDecipheriv("aes-256-cbc", this.encryptionKey, r);
      let s = n.update(i);
      return s = Buffer.concat([s, n.final()]), s.toString();
    } catch (e) {
      return console.error("Failed to decrypt log:", e), "[Encrypted Content]";
    }
  }
  async log(A) {
    this.encryptionKey || await this.loadOrGenerateKey();
    const e = iz(), r = (/* @__PURE__ */ new Date()).toISOString(), i = JSON.stringify(A.details), n = this.encrypt(i);
    return this.db.prepare(`
      INSERT INTO audit_logs (id, timestamp, actor, action, details, status)
      VALUES (?, ?, ?, ?, ?, ?)
    `).run(e, r, A.actor, A.action, n, A.status), e;
  }
  getLogs(A = 100) {
    return this.db.prepare("SELECT * FROM audit_logs ORDER BY timestamp DESC LIMIT ?").all(A).map((i) => ({
      ...i,
      details: this.decrypt(i.details)
      // Attempt to decrypt on read
    }));
  }
}
const Ov = new nz();
class sz {
  constructor() {
    R(this, "issues", [
      {
        key: "PROJ-1",
        summary: "Fix login page layout",
        description: "The login button is misaligned on mobile devices.",
        status: "To Do",
        assignee: "jdoe"
      },
      {
        key: "PROJ-2",
        summary: "Update API documentation",
        description: "The /v2/users endpoint docs are outdated.",
        status: "In Progress",
        assignee: "smitchell"
      },
      {
        key: "PROJ-3",
        summary: "Investigate server crash",
        description: "Server 3 crashed with OOM error last night.",
        status: "Done",
        assignee: "jdoe"
      }
    ]);
    this.registerTools();
  }
  async simulateDelay() {
    await new Promise((A) => setTimeout(A, 500));
  }
  registerTools() {
    const A = {
      name: "jira_list_issues",
      description: "List all Jira issues, optionally filtered by status.",
      schema: ar({
        status: At().optional().describe("Filter by status (To Do, In Progress, Done)")
      }),
      execute: async ({ status: i }) => {
        await this.simulateDelay();
        let n = this.issues;
        return i && (n = n.filter((s) => s.status.toLowerCase() === i.toLowerCase())), JSON.stringify(n, null, 2);
      }
    }, e = {
      name: "jira_get_issue",
      description: "Get details of a specific Jira issue by key.",
      schema: ar({
        key: At().describe("The issue key (e.g., PROJ-1)")
      }),
      execute: async ({ key: i }) => {
        await this.simulateDelay();
        const n = this.issues.find((s) => s.key === i);
        return n ? JSON.stringify(n, null, 2) : `Issue ${i} not found.`;
      }
    }, r = {
      name: "jira_create_issue",
      description: "Create a new Jira issue.",
      requiresApproval: !0,
      schema: ar({
        summary: At().describe("The issue summary/title"),
        description: At().describe("The issue description"),
        assignee: At().optional().describe("The user to assign the issue to")
      }),
      execute: async ({ summary: i, description: n, assignee: s }) => {
        await this.simulateDelay();
        const a = `PROJ-${this.issues.length + 1}`, g = {
          key: a,
          summary: i,
          description: n,
          status: "To Do",
          assignee: s || "unassigned"
        };
        return this.issues.push(g), `Successfully created issue ${a}`;
      }
    };
    Yt.register(A), Yt.register(e), Yt.register(r);
  }
}
new sz();
class az {
  constructor() {
    R(this, "pages", [
      {
        id: "1001",
        title: "Project Phoenix Architecture",
        space: "ENG",
        content: "Project Phoenix aims to unify the browser experience. Key components: Electron, React, LangChain.",
        lastUpdated: "2023-10-01"
      },
      {
        id: "1002",
        title: "Q4 Marketing Strategy",
        space: "MKT",
        content: "Focus on enterprise decision makers. Channels: LinkedIn, TechCrunch, Industry Events.",
        lastUpdated: "2023-10-15"
      },
      {
        id: "1003",
        title: "Employee Onboarding Guide",
        space: "HR",
        content: "Welcome to the team! 1. Setup email. 2. Join Slack. 3. Read the handbook.",
        lastUpdated: "2023-09-20"
      }
    ]);
    this.registerTools();
  }
  async simulateDelay() {
    await new Promise((A) => setTimeout(A, 500));
  }
  registerTools() {
    const A = {
      name: "confluence_search",
      description: "Search for Confluence pages by title or content.",
      schema: ar({
        query: At().describe("Search query string")
      }),
      execute: async ({ query: i }) => {
        await this.simulateDelay();
        const n = i.toLowerCase(), s = this.pages.filter(
          (a) => a.title.toLowerCase().includes(n) || a.content.toLowerCase().includes(n)
        ).map(({ content: a, ...g }) => g);
        return JSON.stringify(s, null, 2);
      }
    }, e = {
      name: "confluence_read_page",
      description: "Read the full content of a Confluence page.",
      schema: ar({
        id: At().describe("The page ID (e.g., 1001)")
      }),
      execute: async ({ id: i }) => {
        await this.simulateDelay();
        const n = this.pages.find((s) => s.id === i);
        return n ? JSON.stringify(n, null, 2) : `Page ${i} not found.`;
      }
    }, r = {
      name: "confluence_create_page",
      description: "Create a new Confluence page.",
      schema: ar({
        title: At().describe("Page title"),
        space: At().describe("Space key (e.g. ENG, HR)"),
        content: At().describe("Page content")
      }),
      execute: async ({ title: i, space: n, content: s }) => {
        await this.simulateDelay();
        const a = (1e3 + this.pages.length + 1).toString();
        return this.pages.push({
          id: a,
          title: i,
          space: n,
          content: s,
          lastUpdated: (/* @__PURE__ */ new Date()).toISOString().split("T")[0]
        }), `Created page ${a}: "${i}" in space ${n}`;
      }
    };
    Yt.register(A), Yt.register(e), Yt.register(r);
  }
}
new az();
class oz {
  constructor() {
    R(this, "boards", [
      {
        id: "board-1",
        name: "Product Roadmap",
        lists: [
          { id: "list-1", name: "Backlog" },
          { id: "list-2", name: "Doing" },
          { id: "list-3", name: "Done" }
        ],
        cards: [
          { id: "card-1", title: "Research competitors", listId: "list-1" },
          { id: "card-2", title: "Design new logo", listId: "list-2" }
        ]
      }
    ]);
    this.registerTools();
  }
  async simulateDelay() {
    await new Promise((A) => setTimeout(A, 500));
  }
  registerTools() {
    const A = {
      name: "trello_get_board",
      description: "Get details of a Trello board, including lists and cards.",
      schema: ar({
        id: At().describe("The board ID (e.g., board-1)")
      }),
      execute: async ({ id: i }) => {
        await this.simulateDelay();
        const n = this.boards.find((s) => s.id === i);
        return n ? JSON.stringify(n, null, 2) : `Board ${i} not found.`;
      }
    }, e = {
      name: "trello_move_card",
      description: "Move a Trello card to a different list.",
      schema: ar({
        cardId: At().describe("The ID of the card to move"),
        targetListId: At().describe("The ID of the destination list")
      }),
      execute: async ({ cardId: i, targetListId: n }) => {
        await this.simulateDelay();
        for (const s of this.boards) {
          const a = s.cards.find((g) => g.id === i);
          if (a)
            return s.lists.some((o) => o.id === n) ? (a.listId = n, `Successfully moved card ${i} to list ${n}`) : `List ${n} not found on this board.`;
        }
        return `Card ${i} not found.`;
      }
    }, r = {
      name: "trello_create_card",
      description: "Create a new Trello card.",
      schema: ar({
        boardId: At().describe("Board ID"),
        listId: At().describe("List ID"),
        title: At().describe("Card title")
      }),
      execute: async ({ boardId: i, listId: n, title: s }) => {
        await this.simulateDelay();
        const a = this.boards.find((u) => u.id === i);
        if (!a) return `Board ${i} not found`;
        const g = a.lists.find((u) => u.id === n);
        if (!g) return `List ${n} not found`;
        const o = `card-${Date.now()}`;
        return a.cards.push({ id: o, title: s, listId: n }), `Created card ${o}: "${s}" in list ${g.name}`;
      }
    };
    Yt.register(A), Yt.register(e), Yt.register(r);
  }
}
new oz();
var vm = function(t, A) {
  return vm = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {
    e.__proto__ = r;
  } || function(e, r) {
    for (var i in r) Object.prototype.hasOwnProperty.call(r, i) && (e[i] = r[i]);
  }, vm(t, A);
};
function ws(t, A) {
  if (typeof A != "function" && A !== null)
    throw new TypeError("Class extends value " + String(A) + " is not a constructor or null");
  vm(t, A);
  function e() {
    this.constructor = t;
  }
  t.prototype = A === null ? Object.create(A) : (e.prototype = A.prototype, new e());
}
function gz(t, A, e, r) {
  function i(n) {
    return n instanceof e ? n : new e(function(s) {
      s(n);
    });
  }
  return new (e || (e = Promise))(function(n, s) {
    function a(u) {
      try {
        o(r.next(u));
      } catch (I) {
        s(I);
      }
    }
    function g(u) {
      try {
        o(r.throw(u));
      } catch (I) {
        s(I);
      }
    }
    function o(u) {
      u.done ? n(u.value) : i(u.value).then(a, g);
    }
    o((r = r.apply(t, [])).next());
  });
}
function QU(t, A) {
  var e = { label: 0, sent: function() {
    if (n[0] & 1) throw n[1];
    return n[1];
  }, trys: [], ops: [] }, r, i, n, s = Object.create((typeof Iterator == "function" ? Iterator : Object).prototype);
  return s.next = a(0), s.throw = a(1), s.return = a(2), typeof Symbol == "function" && (s[Symbol.iterator] = function() {
    return this;
  }), s;
  function a(o) {
    return function(u) {
      return g([o, u]);
    };
  }
  function g(o) {
    if (r) throw new TypeError("Generator is already executing.");
    for (; s && (s = 0, o[0] && (e = 0)), e; ) try {
      if (r = 1, i && (n = o[0] & 2 ? i.return : o[0] ? i.throw || ((n = i.return) && n.call(i), 0) : i.next) && !(n = n.call(i, o[1])).done) return n;
      switch (i = 0, n && (o = [o[0] & 2, n.value]), o[0]) {
        case 0:
        case 1:
          n = o;
          break;
        case 4:
          return e.label++, { value: o[1], done: !1 };
        case 5:
          e.label++, i = o[1], o = [0];
          continue;
        case 7:
          o = e.ops.pop(), e.trys.pop();
          continue;
        default:
          if (n = e.trys, !(n = n.length > 0 && n[n.length - 1]) && (o[0] === 6 || o[0] === 2)) {
            e = 0;
            continue;
          }
          if (o[0] === 3 && (!n || o[1] > n[0] && o[1] < n[3])) {
            e.label = o[1];
            break;
          }
          if (o[0] === 6 && e.label < n[1]) {
            e.label = n[1], n = o;
            break;
          }
          if (n && e.label < n[2]) {
            e.label = n[2], e.ops.push(o);
            break;
          }
          n[2] && e.ops.pop(), e.trys.pop();
          continue;
      }
      o = A.call(t, e);
    } catch (u) {
      o = [6, u], i = 0;
    } finally {
      r = n = 0;
    }
    if (o[0] & 5) throw o[1];
    return { value: o[0] ? o[1] : void 0, done: !0 };
  }
}
function us(t) {
  var A = typeof Symbol == "function" && Symbol.iterator, e = A && t[A], r = 0;
  if (e) return e.call(t);
  if (t && typeof t.length == "number") return {
    next: function() {
      return t && r >= t.length && (t = void 0), { value: t && t[r++], done: !t };
    }
  };
  throw new TypeError(A ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function hg(t, A) {
  var e = typeof Symbol == "function" && t[Symbol.iterator];
  if (!e) return t;
  var r = e.call(t), i, n = [], s;
  try {
    for (; (A === void 0 || A-- > 0) && !(i = r.next()).done; ) n.push(i.value);
  } catch (a) {
    s = { error: a };
  } finally {
    try {
      i && !i.done && (e = r.return) && e.call(r);
    } finally {
      if (s) throw s.error;
    }
  }
  return n;
}
function Zc(t, A, e) {
  if (arguments.length === 2) for (var r = 0, i = A.length, n; r < i; r++)
    (n || !(r in A)) && (n || (n = Array.prototype.slice.call(A, 0, r)), n[r] = A[r]);
  return t.concat(n || Array.prototype.slice.call(A));
}
function au(t) {
  return this instanceof au ? (this.v = t, this) : new au(t);
}
function uz(t, A, e) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var r = e.apply(t, A || []), i, n = [];
  return i = Object.create((typeof AsyncIterator == "function" ? AsyncIterator : Object).prototype), a("next"), a("throw"), a("return", s), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function s(C) {
    return function(E) {
      return Promise.resolve(E).then(C, I);
    };
  }
  function a(C, E) {
    r[C] && (i[C] = function(l) {
      return new Promise(function(B, h) {
        n.push([C, l, B, h]) > 1 || g(C, l);
      });
    }, E && (i[C] = E(i[C])));
  }
  function g(C, E) {
    try {
      o(r[C](E));
    } catch (l) {
      c(n[0][3], l);
    }
  }
  function o(C) {
    C.value instanceof au ? Promise.resolve(C.value.v).then(u, I) : c(n[0][2], C);
  }
  function u(C) {
    g("next", C);
  }
  function I(C) {
    g("throw", C);
  }
  function c(C, E) {
    C(E), n.shift(), n.length && g(n[0][0], n[0][1]);
  }
}
function cz(t) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var A = t[Symbol.asyncIterator], e;
  return A ? A.call(t) : (t = typeof us == "function" ? us(t) : t[Symbol.iterator](), e = {}, r("next"), r("throw"), r("return"), e[Symbol.asyncIterator] = function() {
    return this;
  }, e);
  function r(n) {
    e[n] = t[n] && function(s) {
      return new Promise(function(a, g) {
        s = t[n](s), i(a, g, s.done, s.value);
      });
    };
  }
  function i(n, s, a, g) {
    Promise.resolve(g).then(function(o) {
      n({ value: o, done: a });
    }, s);
  }
}
function Le(t) {
  return typeof t == "function";
}
function wS(t) {
  var A = function(r) {
    Error.call(r), r.stack = new Error().stack;
  }, e = t(A);
  return e.prototype = Object.create(Error.prototype), e.prototype.constructor = e, e;
}
var py = wS(function(t) {
  return function(e) {
    t(this), this.message = e ? e.length + ` errors occurred during unsubscription:
` + e.map(function(r, i) {
      return i + 1 + ") " + r.toString();
    }).join(`
  `) : "", this.name = "UnsubscriptionError", this.errors = e;
  };
});
function nl(t, A) {
  if (t) {
    var e = t.indexOf(A);
    0 <= e && t.splice(e, 1);
  }
}
var OE = function() {
  function t(A) {
    this.initialTeardown = A, this.closed = !1, this._parentage = null, this._finalizers = null;
  }
  return t.prototype.unsubscribe = function() {
    var A, e, r, i, n;
    if (!this.closed) {
      this.closed = !0;
      var s = this._parentage;
      if (s)
        if (this._parentage = null, Array.isArray(s))
          try {
            for (var a = us(s), g = a.next(); !g.done; g = a.next()) {
              var o = g.value;
              o.remove(this);
            }
          } catch (l) {
            A = { error: l };
          } finally {
            try {
              g && !g.done && (e = a.return) && e.call(a);
            } finally {
              if (A) throw A.error;
            }
          }
        else
          s.remove(this);
      var u = this.initialTeardown;
      if (Le(u))
        try {
          u();
        } catch (l) {
          n = l instanceof py ? l.errors : [l];
        }
      var I = this._finalizers;
      if (I) {
        this._finalizers = null;
        try {
          for (var c = us(I), C = c.next(); !C.done; C = c.next()) {
            var E = C.value;
            try {
              Yv(E);
            } catch (l) {
              n = n ?? [], l instanceof py ? n = Zc(Zc([], hg(n)), hg(l.errors)) : n.push(l);
            }
          }
        } catch (l) {
          r = { error: l };
        } finally {
          try {
            C && !C.done && (i = c.return) && i.call(c);
          } finally {
            if (r) throw r.error;
          }
        }
      }
      if (n)
        throw new py(n);
    }
  }, t.prototype.add = function(A) {
    var e;
    if (A && A !== this)
      if (this.closed)
        Yv(A);
      else {
        if (A instanceof t) {
          if (A.closed || A._hasParent(this))
            return;
          A._addParent(this);
        }
        (this._finalizers = (e = this._finalizers) !== null && e !== void 0 ? e : []).push(A);
      }
  }, t.prototype._hasParent = function(A) {
    var e = this._parentage;
    return e === A || Array.isArray(e) && e.includes(A);
  }, t.prototype._addParent = function(A) {
    var e = this._parentage;
    this._parentage = Array.isArray(e) ? (e.push(A), e) : e ? [e, A] : A;
  }, t.prototype._removeParent = function(A) {
    var e = this._parentage;
    e === A ? this._parentage = null : Array.isArray(e) && nl(e, A);
  }, t.prototype.remove = function(A) {
    var e = this._finalizers;
    e && nl(e, A), A instanceof t && A._removeParent(this);
  }, t.EMPTY = function() {
    var A = new t();
    return A.closed = !0, A;
  }(), t;
}(), dU = OE.EMPTY;
function fU(t) {
  return t instanceof OE || t && "closed" in t && Le(t.remove) && Le(t.add) && Le(t.unsubscribe);
}
function Yv(t) {
  Le(t) ? t() : t.unsubscribe();
}
var Iz = {
  Promise: void 0
}, Cz = {
  setTimeout: function(t, A) {
    for (var e = [], r = 2; r < arguments.length; r++)
      e[r - 2] = arguments[r];
    return setTimeout.apply(void 0, Zc([t, A], hg(e)));
  },
  clearTimeout: function(t) {
    return clearTimeout(t);
  },
  delegate: void 0
};
function pU(t) {
  Cz.setTimeout(function() {
    throw t;
  });
}
function Xc() {
}
function PQ(t) {
  t();
}
var mS = function(t) {
  ws(A, t);
  function A(e) {
    var r = t.call(this) || this;
    return r.isStopped = !1, e ? (r.destination = e, fU(e) && e.add(r)) : r.destination = Ez, r;
  }
  return A.create = function(e, r, i) {
    return new Od(e, r, i);
  }, A.prototype.next = function(e) {
    this.isStopped || this._next(e);
  }, A.prototype.error = function(e) {
    this.isStopped || (this.isStopped = !0, this._error(e));
  }, A.prototype.complete = function() {
    this.isStopped || (this.isStopped = !0, this._complete());
  }, A.prototype.unsubscribe = function() {
    this.closed || (this.isStopped = !0, t.prototype.unsubscribe.call(this), this.destination = null);
  }, A.prototype._next = function(e) {
    this.destination.next(e);
  }, A.prototype._error = function(e) {
    try {
      this.destination.error(e);
    } finally {
      this.unsubscribe();
    }
  }, A.prototype._complete = function() {
    try {
      this.destination.complete();
    } finally {
      this.unsubscribe();
    }
  }, A;
}(OE), lz = function() {
  function t(A) {
    this.partialObserver = A;
  }
  return t.prototype.next = function(A) {
    var e = this.partialObserver;
    if (e.next)
      try {
        e.next(A);
      } catch (r) {
        kh(r);
      }
  }, t.prototype.error = function(A) {
    var e = this.partialObserver;
    if (e.error)
      try {
        e.error(A);
      } catch (r) {
        kh(r);
      }
    else
      kh(A);
  }, t.prototype.complete = function() {
    var A = this.partialObserver;
    if (A.complete)
      try {
        A.complete();
      } catch (e) {
        kh(e);
      }
  }, t;
}(), Od = function(t) {
  ws(A, t);
  function A(e, r, i) {
    var n = t.call(this) || this, s;
    return Le(e) || !e ? s = {
      next: e ?? void 0,
      error: r ?? void 0,
      complete: i ?? void 0
    } : s = e, n.destination = new lz(s), n;
  }
  return A;
}(mS);
function kh(t) {
  pU(t);
}
function Bz(t) {
  throw t;
}
var Ez = {
  closed: !0,
  next: Xc,
  error: Bz,
  complete: Xc
}, DS = function() {
  return typeof Symbol == "function" && Symbol.observable || "@@observable";
}();
function xi(t) {
  return t;
}
function hz() {
  for (var t = [], A = 0; A < arguments.length; A++)
    t[A] = arguments[A];
  return yU(t);
}
function yU(t) {
  return t.length === 0 ? xi : t.length === 1 ? t[0] : function(e) {
    return t.reduce(function(r, i) {
      return i(r);
    }, e);
  };
}
var ft = function() {
  function t(A) {
    A && (this._subscribe = A);
  }
  return t.prototype.lift = function(A) {
    var e = new t();
    return e.source = this, e.operator = A, e;
  }, t.prototype.subscribe = function(A, e, r) {
    var i = this, n = dz(A) ? A : new Od(A, e, r);
    return PQ(function() {
      var s = i, a = s.operator, g = s.source;
      n.add(a ? a.call(n, g) : g ? i._subscribe(n) : i._trySubscribe(n));
    }), n;
  }, t.prototype._trySubscribe = function(A) {
    try {
      return this._subscribe(A);
    } catch (e) {
      A.error(e);
    }
  }, t.prototype.forEach = function(A, e) {
    var r = this;
    return e = qv(e), new e(function(i, n) {
      var s = new Od({
        next: function(a) {
          try {
            A(a);
          } catch (g) {
            n(g), s.unsubscribe();
          }
        },
        error: n,
        complete: i
      });
      r.subscribe(s);
    });
  }, t.prototype._subscribe = function(A) {
    var e;
    return (e = this.source) === null || e === void 0 ? void 0 : e.subscribe(A);
  }, t.prototype[DS] = function() {
    return this;
  }, t.prototype.pipe = function() {
    for (var A = [], e = 0; e < arguments.length; e++)
      A[e] = arguments[e];
    return yU(A)(this);
  }, t.prototype.toPromise = function(A) {
    var e = this;
    return A = qv(A), new A(function(r, i) {
      var n;
      e.subscribe(function(s) {
        return n = s;
      }, function(s) {
        return i(s);
      }, function() {
        return r(n);
      });
    });
  }, t.create = function(A) {
    return new t(A);
  }, t;
}();
function qv(t) {
  var A;
  return (A = t ?? Iz.Promise) !== null && A !== void 0 ? A : Promise;
}
function Qz(t) {
  return t && Le(t.next) && Le(t.error) && Le(t.complete);
}
function dz(t) {
  return t && t instanceof mS || Qz(t) && fU(t);
}
function fz(t) {
  return Le(t == null ? void 0 : t.lift);
}
function yt(t) {
  return function(A) {
    if (fz(A))
      return A.lift(function(e) {
        try {
          return t(e, this);
        } catch (r) {
          this.error(r);
        }
      });
    throw new TypeError("Unable to lift unknown Observable type");
  };
}
function It(t, A, e, r, i) {
  return new pz(t, A, e, r, i);
}
var pz = function(t) {
  ws(A, t);
  function A(e, r, i, n, s, a) {
    var g = t.call(this, e) || this;
    return g.onFinalize = s, g.shouldUnsubscribe = a, g._next = r ? function(o) {
      try {
        r(o);
      } catch (u) {
        e.error(u);
      }
    } : t.prototype._next, g._error = n ? function(o) {
      try {
        n(o);
      } catch (u) {
        e.error(u);
      } finally {
        this.unsubscribe();
      }
    } : t.prototype._error, g._complete = i ? function() {
      try {
        i();
      } catch (o) {
        e.error(o);
      } finally {
        this.unsubscribe();
      }
    } : t.prototype._complete, g;
  }
  return A.prototype.unsubscribe = function() {
    var e;
    if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
      var r = this.closed;
      t.prototype.unsubscribe.call(this), !r && ((e = this.onFinalize) === null || e === void 0 || e.call(this));
    }
  }, A;
}(mS), yz = wS(function(t) {
  return function() {
    t(this), this.name = "ObjectUnsubscribedError", this.message = "object unsubscribed";
  };
}), wU = function(t) {
  ws(A, t);
  function A() {
    var e = t.call(this) || this;
    return e.closed = !1, e.currentObservers = null, e.observers = [], e.isStopped = !1, e.hasError = !1, e.thrownError = null, e;
  }
  return A.prototype.lift = function(e) {
    var r = new jv(this, this);
    return r.operator = e, r;
  }, A.prototype._throwIfClosed = function() {
    if (this.closed)
      throw new yz();
  }, A.prototype.next = function(e) {
    var r = this;
    PQ(function() {
      var i, n;
      if (r._throwIfClosed(), !r.isStopped) {
        r.currentObservers || (r.currentObservers = Array.from(r.observers));
        try {
          for (var s = us(r.currentObservers), a = s.next(); !a.done; a = s.next()) {
            var g = a.value;
            g.next(e);
          }
        } catch (o) {
          i = { error: o };
        } finally {
          try {
            a && !a.done && (n = s.return) && n.call(s);
          } finally {
            if (i) throw i.error;
          }
        }
      }
    });
  }, A.prototype.error = function(e) {
    var r = this;
    PQ(function() {
      if (r._throwIfClosed(), !r.isStopped) {
        r.hasError = r.isStopped = !0, r.thrownError = e;
        for (var i = r.observers; i.length; )
          i.shift().error(e);
      }
    });
  }, A.prototype.complete = function() {
    var e = this;
    PQ(function() {
      if (e._throwIfClosed(), !e.isStopped) {
        e.isStopped = !0;
        for (var r = e.observers; r.length; )
          r.shift().complete();
      }
    });
  }, A.prototype.unsubscribe = function() {
    this.isStopped = this.closed = !0, this.observers = this.currentObservers = null;
  }, Object.defineProperty(A.prototype, "observed", {
    get: function() {
      var e;
      return ((e = this.observers) === null || e === void 0 ? void 0 : e.length) > 0;
    },
    enumerable: !1,
    configurable: !0
  }), A.prototype._trySubscribe = function(e) {
    return this._throwIfClosed(), t.prototype._trySubscribe.call(this, e);
  }, A.prototype._subscribe = function(e) {
    return this._throwIfClosed(), this._checkFinalizedStatuses(e), this._innerSubscribe(e);
  }, A.prototype._innerSubscribe = function(e) {
    var r = this, i = this, n = i.hasError, s = i.isStopped, a = i.observers;
    return n || s ? dU : (this.currentObservers = null, a.push(e), new OE(function() {
      r.currentObservers = null, nl(a, e);
    }));
  }, A.prototype._checkFinalizedStatuses = function(e) {
    var r = this, i = r.hasError, n = r.thrownError, s = r.isStopped;
    i ? e.error(n) : s && e.complete();
  }, A.prototype.asObservable = function() {
    var e = new ft();
    return e.source = this, e;
  }, A.create = function(e, r) {
    return new jv(e, r);
  }, A;
}(ft), jv = function(t) {
  ws(A, t);
  function A(e, r) {
    var i = t.call(this) || this;
    return i.destination = e, i.source = r, i;
  }
  return A.prototype.next = function(e) {
    var r, i;
    (i = (r = this.destination) === null || r === void 0 ? void 0 : r.next) === null || i === void 0 || i.call(r, e);
  }, A.prototype.error = function(e) {
    var r, i;
    (i = (r = this.destination) === null || r === void 0 ? void 0 : r.error) === null || i === void 0 || i.call(r, e);
  }, A.prototype.complete = function() {
    var e, r;
    (r = (e = this.destination) === null || e === void 0 ? void 0 : e.complete) === null || r === void 0 || r.call(e);
  }, A.prototype._subscribe = function(e) {
    var r, i;
    return (i = (r = this.source) === null || r === void 0 ? void 0 : r.subscribe(e)) !== null && i !== void 0 ? i : dU;
  }, A;
}(wU), SS = {
  now: function() {
    return (SS.delegate || Date).now();
  },
  delegate: void 0
}, wz = function(t) {
  ws(A, t);
  function A(e, r, i) {
    e === void 0 && (e = 1 / 0), r === void 0 && (r = 1 / 0), i === void 0 && (i = SS);
    var n = t.call(this) || this;
    return n._bufferSize = e, n._windowTime = r, n._timestampProvider = i, n._buffer = [], n._infiniteTimeWindow = !0, n._infiniteTimeWindow = r === 1 / 0, n._bufferSize = Math.max(1, e), n._windowTime = Math.max(1, r), n;
  }
  return A.prototype.next = function(e) {
    var r = this, i = r.isStopped, n = r._buffer, s = r._infiniteTimeWindow, a = r._timestampProvider, g = r._windowTime;
    i || (n.push(e), !s && n.push(a.now() + g)), this._trimBuffer(), t.prototype.next.call(this, e);
  }, A.prototype._subscribe = function(e) {
    this._throwIfClosed(), this._trimBuffer();
    for (var r = this._innerSubscribe(e), i = this, n = i._infiniteTimeWindow, s = i._buffer, a = s.slice(), g = 0; g < a.length && !e.closed; g += n ? 1 : 2)
      e.next(a[g]);
    return this._checkFinalizedStatuses(e), r;
  }, A.prototype._trimBuffer = function() {
    var e = this, r = e._bufferSize, i = e._timestampProvider, n = e._buffer, s = e._infiniteTimeWindow, a = (s ? 1 : 2) * r;
    if (r < 1 / 0 && a < n.length && n.splice(0, n.length - a), !s) {
      for (var g = i.now(), o = 0, u = 1; u < n.length && n[u] <= g; u += 2)
        o = u;
      o && n.splice(0, o + 1);
    }
  }, A;
}(wU), mz = function(t) {
  ws(A, t);
  function A(e, r) {
    return t.call(this) || this;
  }
  return A.prototype.schedule = function(e, r) {
    return this;
  }, A;
}(OE), Wv = {
  setInterval: function(t, A) {
    for (var e = [], r = 2; r < arguments.length; r++)
      e[r - 2] = arguments[r];
    return setInterval.apply(void 0, Zc([t, A], hg(e)));
  },
  clearInterval: function(t) {
    return clearInterval(t);
  },
  delegate: void 0
}, Dz = function(t) {
  ws(A, t);
  function A(e, r) {
    var i = t.call(this, e, r) || this;
    return i.scheduler = e, i.work = r, i.pending = !1, i;
  }
  return A.prototype.schedule = function(e, r) {
    var i;
    if (r === void 0 && (r = 0), this.closed)
      return this;
    this.state = e;
    var n = this.id, s = this.scheduler;
    return n != null && (this.id = this.recycleAsyncId(s, n, r)), this.pending = !0, this.delay = r, this.id = (i = this.id) !== null && i !== void 0 ? i : this.requestAsyncId(s, this.id, r), this;
  }, A.prototype.requestAsyncId = function(e, r, i) {
    return i === void 0 && (i = 0), Wv.setInterval(e.flush.bind(e, this), i);
  }, A.prototype.recycleAsyncId = function(e, r, i) {
    if (i === void 0 && (i = 0), i != null && this.delay === i && this.pending === !1)
      return r;
    r != null && Wv.clearInterval(r);
  }, A.prototype.execute = function(e, r) {
    if (this.closed)
      return new Error("executing a cancelled action");
    this.pending = !1;
    var i = this._execute(e, r);
    if (i)
      return i;
    this.pending === !1 && this.id != null && (this.id = this.recycleAsyncId(this.scheduler, this.id, null));
  }, A.prototype._execute = function(e, r) {
    var i = !1, n;
    try {
      this.work(e);
    } catch (s) {
      i = !0, n = s || new Error("Scheduled action threw falsy error");
    }
    if (i)
      return this.unsubscribe(), n;
  }, A.prototype.unsubscribe = function() {
    if (!this.closed) {
      var e = this, r = e.id, i = e.scheduler, n = i.actions;
      this.work = this.state = this.scheduler = null, this.pending = !1, nl(n, this), r != null && (this.id = this.recycleAsyncId(i, r, null)), this.delay = null, t.prototype.unsubscribe.call(this);
    }
  }, A;
}(mz), Vv = function() {
  function t(A, e) {
    e === void 0 && (e = t.now), this.schedulerActionCtor = A, this.now = e;
  }
  return t.prototype.schedule = function(A, e, r) {
    return e === void 0 && (e = 0), new this.schedulerActionCtor(this, A).schedule(r, e);
  }, t.now = SS.now, t;
}(), Sz = function(t) {
  ws(A, t);
  function A(e, r) {
    r === void 0 && (r = Vv.now);
    var i = t.call(this, e, r) || this;
    return i.actions = [], i._active = !1, i;
  }
  return A.prototype.flush = function(e) {
    var r = this.actions;
    if (this._active) {
      r.push(e);
      return;
    }
    var i;
    this._active = !0;
    do
      if (i = e.execute(e.state, e.delay))
        break;
    while (e = r.shift());
    if (this._active = !1, i) {
      for (; e = r.shift(); )
        e.unsubscribe();
      throw i;
    }
  }, A;
}(Vv), Fz = new Sz(Dz), kz = Fz, Ig = new ft(function(t) {
  return t.complete();
});
function vz(t) {
  return t && Le(t.schedule);
}
function FS(t) {
  return t[t.length - 1];
}
function Rz(t) {
  return Le(FS(t)) ? t.pop() : void 0;
}
function YE(t) {
  return vz(FS(t)) ? t.pop() : void 0;
}
function bz(t, A) {
  return typeof FS(t) == "number" ? t.pop() : A;
}
var kS = function(t) {
  return t && typeof t.length == "number" && typeof t != "function";
};
function mU(t) {
  return Le(t == null ? void 0 : t.then);
}
function DU(t) {
  return Le(t[DS]);
}
function SU(t) {
  return Symbol.asyncIterator && Le(t == null ? void 0 : t[Symbol.asyncIterator]);
}
function FU(t) {
  return new TypeError("You provided " + (t !== null && typeof t == "object" ? "an invalid object" : "'" + t + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
}
function Mz() {
  return typeof Symbol != "function" || !Symbol.iterator ? "@@iterator" : Symbol.iterator;
}
var kU = Mz();
function vU(t) {
  return Le(t == null ? void 0 : t[kU]);
}
function RU(t) {
  return uz(this, arguments, function() {
    var e, r, i, n;
    return QU(this, function(s) {
      switch (s.label) {
        case 0:
          e = t.getReader(), s.label = 1;
        case 1:
          s.trys.push([1, , 9, 10]), s.label = 2;
        case 2:
          return [4, au(e.read())];
        case 3:
          return r = s.sent(), i = r.value, n = r.done, n ? [4, au(void 0)] : [3, 5];
        case 4:
          return [2, s.sent()];
        case 5:
          return [4, au(i)];
        case 6:
          return [4, s.sent()];
        case 7:
          return s.sent(), [3, 2];
        case 8:
          return [3, 10];
        case 9:
          return e.releaseLock(), [7];
        case 10:
          return [2];
      }
    });
  });
}
function bU(t) {
  return Le(t == null ? void 0 : t.getReader);
}
function cr(t) {
  if (t instanceof ft)
    return t;
  if (t != null) {
    if (DU(t))
      return _z(t);
    if (kS(t))
      return Nz(t);
    if (mU(t))
      return Lz(t);
    if (SU(t))
      return MU(t);
    if (vU(t))
      return xz(t);
    if (bU(t))
      return Gz(t);
  }
  throw FU(t);
}
function _z(t) {
  return new ft(function(A) {
    var e = t[DS]();
    if (Le(e.subscribe))
      return e.subscribe(A);
    throw new TypeError("Provided object does not correctly implement Symbol.observable");
  });
}
function Nz(t) {
  return new ft(function(A) {
    for (var e = 0; e < t.length && !A.closed; e++)
      A.next(t[e]);
    A.complete();
  });
}
function Lz(t) {
  return new ft(function(A) {
    t.then(function(e) {
      A.closed || (A.next(e), A.complete());
    }, function(e) {
      return A.error(e);
    }).then(null, pU);
  });
}
function xz(t) {
  return new ft(function(A) {
    var e, r;
    try {
      for (var i = us(t), n = i.next(); !n.done; n = i.next()) {
        var s = n.value;
        if (A.next(s), A.closed)
          return;
      }
    } catch (a) {
      e = { error: a };
    } finally {
      try {
        n && !n.done && (r = i.return) && r.call(i);
      } finally {
        if (e) throw e.error;
      }
    }
    A.complete();
  });
}
function MU(t) {
  return new ft(function(A) {
    Uz(t, A).catch(function(e) {
      return A.error(e);
    });
  });
}
function Gz(t) {
  return MU(RU(t));
}
function Uz(t, A) {
  var e, r, i, n;
  return gz(this, void 0, void 0, function() {
    var s, a;
    return QU(this, function(g) {
      switch (g.label) {
        case 0:
          g.trys.push([0, 5, 6, 11]), e = cz(t), g.label = 1;
        case 1:
          return [4, e.next()];
        case 2:
          if (r = g.sent(), !!r.done) return [3, 4];
          if (s = r.value, A.next(s), A.closed)
            return [2];
          g.label = 3;
        case 3:
          return [3, 1];
        case 4:
          return [3, 11];
        case 5:
          return a = g.sent(), i = { error: a }, [3, 11];
        case 6:
          return g.trys.push([6, , 9, 10]), r && !r.done && (n = e.return) ? [4, n.call(e)] : [3, 8];
        case 7:
          g.sent(), g.label = 8;
        case 8:
          return [3, 10];
        case 9:
          if (i) throw i.error;
          return [7];
        case 10:
          return [7];
        case 11:
          return A.complete(), [2];
      }
    });
  });
}
function va(t, A, e, r, i) {
  r === void 0 && (r = 0), i === void 0 && (i = !1);
  var n = A.schedule(function() {
    e(), i ? t.add(this.schedule(null, r)) : this.unsubscribe();
  }, r);
  if (t.add(n), !i)
    return n;
}
function _U(t, A) {
  return A === void 0 && (A = 0), yt(function(e, r) {
    e.subscribe(It(r, function(i) {
      return va(r, t, function() {
        return r.next(i);
      }, A);
    }, function() {
      return va(r, t, function() {
        return r.complete();
      }, A);
    }, function(i) {
      return va(r, t, function() {
        return r.error(i);
      }, A);
    }));
  });
}
function NU(t, A) {
  return A === void 0 && (A = 0), yt(function(e, r) {
    r.add(t.schedule(function() {
      return e.subscribe(r);
    }, A));
  });
}
function Tz(t, A) {
  return cr(t).pipe(NU(A), _U(A));
}
function Kz(t, A) {
  return cr(t).pipe(NU(A), _U(A));
}
function Jz(t, A) {
  return new ft(function(e) {
    var r = 0;
    return A.schedule(function() {
      r === t.length ? e.complete() : (e.next(t[r++]), e.closed || this.schedule());
    });
  });
}
function Hz(t, A) {
  return new ft(function(e) {
    var r;
    return va(e, A, function() {
      r = t[kU](), va(e, A, function() {
        var i, n, s;
        try {
          i = r.next(), n = i.value, s = i.done;
        } catch (a) {
          e.error(a);
          return;
        }
        s ? e.complete() : e.next(n);
      }, 0, !0);
    }), function() {
      return Le(r == null ? void 0 : r.return) && r.return();
    };
  });
}
function LU(t, A) {
  if (!t)
    throw new Error("Iterable cannot be null");
  return new ft(function(e) {
    va(e, A, function() {
      var r = t[Symbol.asyncIterator]();
      va(e, A, function() {
        r.next().then(function(i) {
          i.done ? e.complete() : e.next(i.value);
        });
      }, 0, !0);
    });
  });
}
function Pz(t, A) {
  return LU(RU(t), A);
}
function Oz(t, A) {
  if (t != null) {
    if (DU(t))
      return Tz(t, A);
    if (kS(t))
      return Jz(t, A);
    if (mU(t))
      return Kz(t, A);
    if (SU(t))
      return LU(t, A);
    if (vU(t))
      return Hz(t, A);
    if (bU(t))
      return Pz(t, A);
  }
  throw FU(t);
}
function de(t, A) {
  return A ? Oz(t, A) : cr(t);
}
function Rm() {
  for (var t = [], A = 0; A < arguments.length; A++)
    t[A] = arguments[A];
  var e = YE(t);
  return de(t, e);
}
var pp = wS(function(t) {
  return function() {
    t(this), this.name = "EmptyError", this.message = "no elements in sequence";
  };
});
function Yz(t, A) {
  var e = typeof A == "object";
  return new Promise(function(r, i) {
    var n = !1, s;
    t.subscribe({
      next: function(a) {
        s = a, n = !0;
      },
      error: i,
      complete: function() {
        n ? r(s) : e ? r(A.defaultValue) : i(new pp());
      }
    });
  });
}
function or(t, A) {
  return new Promise(function(e, r) {
    var i = new Od({
      next: function(n) {
        e(n), i.unsubscribe();
      },
      error: r,
      complete: function() {
        r(new pp());
      }
    });
    t.subscribe(i);
  });
}
function qz(t) {
  return t instanceof Date && !isNaN(t);
}
function ht(t, A) {
  return yt(function(e, r) {
    var i = 0;
    e.subscribe(It(r, function(n) {
      r.next(t.call(A, n, i++));
    }));
  });
}
var jz = Array.isArray;
function Wz(t, A) {
  return jz(A) ? t.apply(void 0, Zc([], hg(A))) : t(A);
}
function xU(t) {
  return ht(function(A) {
    return Wz(t, A);
  });
}
var Vz = Array.isArray, Zz = Object.getPrototypeOf, Xz = Object.prototype, zz = Object.keys;
function $z(t) {
  if (t.length === 1) {
    var A = t[0];
    if (Vz(A))
      return { args: A, keys: null };
    if (A$(A)) {
      var e = zz(A);
      return {
        args: e.map(function(r) {
          return A[r];
        }),
        keys: e
      };
    }
  }
  return { args: t, keys: null };
}
function A$(t) {
  return t && typeof t == "object" && Zz(t) === Xz;
}
function e$(t, A) {
  return t.reduce(function(e, r, i) {
    return e[r] = A[i], e;
  }, {});
}
function vsA() {
  for (var t = [], A = 0; A < arguments.length; A++)
    t[A] = arguments[A];
  var e = YE(t), r = Rz(t), i = $z(t), n = i.args, s = i.keys;
  if (n.length === 0)
    return de([], e);
  var a = new ft(t$(n, e, s ? function(g) {
    return e$(s, g);
  } : xi));
  return r ? a.pipe(xU(r)) : a;
}
function t$(t, A, e) {
  return e === void 0 && (e = xi), function(r) {
    Zv(A, function() {
      for (var i = t.length, n = new Array(i), s = i, a = i, g = function(u) {
        Zv(A, function() {
          var I = de(t[u], A), c = !1;
          I.subscribe(It(r, function(C) {
            n[u] = C, c || (c = !0, a--), a || r.next(e(n.slice()));
          }, function() {
            --s || r.complete();
          }));
        }, r);
      }, o = 0; o < i; o++)
        g(o);
    }, r);
  };
}
function Zv(t, A, e) {
  t ? va(e, t, A) : A();
}
function GU(t, A, e, r, i, n, s, a) {
  var g = [], o = 0, u = 0, I = !1, c = function() {
    I && !g.length && !o && A.complete();
  }, C = function(l) {
    return o < r ? E(l) : g.push(l);
  }, E = function(l) {
    n && A.next(l), o++;
    var B = !1;
    cr(e(l, u++)).subscribe(It(A, function(h) {
      i == null || i(h), n ? C(h) : A.next(h);
    }, function() {
      B = !0;
    }, void 0, function() {
      if (B)
        try {
          o--;
          for (var h = function() {
            var Q = g.shift();
            s || E(Q);
          }; g.length && o < r; )
            h();
          c();
        } catch (Q) {
          A.error(Q);
        }
    }));
  };
  return t.subscribe(It(A, C, function() {
    I = !0, c();
  })), function() {
    a == null || a();
  };
}
function gt(t, A, e) {
  return e === void 0 && (e = 1 / 0), Le(A) ? gt(function(r, i) {
    return ht(function(n, s) {
      return A(r, n, i, s);
    })(cr(t(r, i)));
  }, e) : (typeof A == "number" && (e = A), yt(function(r, i) {
    return GU(r, i, t, e);
  }));
}
function UU(t) {
  return t === void 0 && (t = 1 / 0), gt(xi, t);
}
function r$() {
  return UU(1);
}
function bm() {
  for (var t = [], A = 0; A < arguments.length; A++)
    t[A] = arguments[A];
  return r$()(de(t, YE(t)));
}
function ou(t) {
  return new ft(function(A) {
    cr(t()).subscribe(A);
  });
}
var i$ = ["addListener", "removeListener"], n$ = ["addEventListener", "removeEventListener"], s$ = ["on", "off"];
function Yd(t, A, e, r) {
  if (Le(e) && (r = e, e = void 0), r)
    return Yd(t, A, e).pipe(xU(r));
  var i = hg(g$(t) ? n$.map(function(a) {
    return function(g) {
      return t[a](A, g, e);
    };
  }) : a$(t) ? i$.map(Xv(t, A)) : o$(t) ? s$.map(Xv(t, A)) : [], 2), n = i[0], s = i[1];
  if (!n && kS(t))
    return gt(function(a) {
      return Yd(a, A, e);
    })(cr(t));
  if (!n)
    throw new TypeError("Invalid event target");
  return new ft(function(a) {
    var g = function() {
      for (var o = [], u = 0; u < arguments.length; u++)
        o[u] = arguments[u];
      return a.next(1 < o.length ? o : o[0]);
    };
    return n(g), function() {
      return s(g);
    };
  });
}
function Xv(t, A) {
  return function(e) {
    return function(r) {
      return t[e](A, r);
    };
  };
}
function a$(t) {
  return Le(t.addListener) && Le(t.removeListener);
}
function o$(t) {
  return Le(t.on) && Le(t.off);
}
function g$(t) {
  return Le(t.addEventListener) && Le(t.removeEventListener);
}
function yp(t, A, e) {
  return t === void 0 && (t = 0), e === void 0 && (e = kz), new ft(function(r) {
    var i = qz(t) ? +t - e.now() : t;
    i < 0 && (i = 0);
    var n = 0;
    return e.schedule(function() {
      r.closed || (r.next(n++), r.complete());
    }, i);
  });
}
function sl() {
  for (var t = [], A = 0; A < arguments.length; A++)
    t[A] = arguments[A];
  var e = YE(t), r = bz(t, 1 / 0), i = t;
  return i.length ? i.length === 1 ? cr(i[0]) : UU(r)(de(i, e)) : Ig;
}
var TU = new ft(Xc), u$ = Array.isArray;
function c$(t) {
  return t.length === 1 && u$(t[0]) ? t[0] : t;
}
function Fg(t, A) {
  return yt(function(e, r) {
    var i = 0;
    e.subscribe(It(r, function(n) {
      return t.call(A, n, i++) && r.next(n);
    }));
  });
}
function KU() {
  for (var t = [], A = 0; A < arguments.length; A++)
    t[A] = arguments[A];
  return t = c$(t), t.length === 1 ? cr(t[0]) : new ft(JU(t));
}
function JU(t) {
  return function(A) {
    for (var e = [], r = function(n) {
      e.push(cr(t[n]).subscribe(It(A, function(s) {
        if (e) {
          for (var a = 0; a < e.length; a++)
            a !== n && e[a].unsubscribe();
          e = null;
        }
        A.next(s);
      })));
    }, i = 0; e && !A.closed && i < t.length; i++)
      r(i);
  };
}
function I$(t, A) {
  return A === void 0 && (A = null), A = A ?? t, yt(function(e, r) {
    var i = [], n = 0;
    e.subscribe(It(r, function(s) {
      var a, g, o, u, I = null;
      n++ % A === 0 && i.push([]);
      try {
        for (var c = us(i), C = c.next(); !C.done; C = c.next()) {
          var E = C.value;
          E.push(s), t <= E.length && (I = I ?? [], I.push(E));
        }
      } catch (h) {
        a = { error: h };
      } finally {
        try {
          C && !C.done && (g = c.return) && g.call(c);
        } finally {
          if (a) throw a.error;
        }
      }
      if (I)
        try {
          for (var l = us(I), B = l.next(); !B.done; B = l.next()) {
            var E = B.value;
            nl(i, E), r.next(E);
          }
        } catch (h) {
          o = { error: h };
        } finally {
          try {
            B && !B.done && (u = l.return) && u.call(l);
          } finally {
            if (o) throw o.error;
          }
        }
    }, function() {
      var s, a;
      try {
        for (var g = us(i), o = g.next(); !o.done; o = g.next()) {
          var u = o.value;
          r.next(u);
        }
      } catch (I) {
        s = { error: I };
      } finally {
        try {
          o && !o.done && (a = g.return) && a.call(g);
        } finally {
          if (s) throw s.error;
        }
      }
      r.complete();
    }, void 0, function() {
      i = null;
    }));
  });
}
function FC(t) {
  return yt(function(A, e) {
    var r = null, i = !1, n;
    r = A.subscribe(It(e, void 0, void 0, function(s) {
      n = cr(t(s, FC(t)(A))), r ? (r.unsubscribe(), r = null, n.subscribe(e)) : i = !0;
    })), i && (r.unsubscribe(), r = null, n.subscribe(e));
  });
}
function C$(t, A) {
  return Le(A) ? gt(t, A, 1) : gt(t, 1);
}
function HU(t) {
  return yt(function(A, e) {
    var r = !1;
    A.subscribe(It(e, function(i) {
      r = !0, e.next(i);
    }, function() {
      r || e.next(t), e.complete();
    }));
  });
}
function vS(t) {
  return t <= 0 ? function() {
    return Ig;
  } : yt(function(A, e) {
    var r = 0;
    A.subscribe(It(e, function(i) {
      ++r <= t && (e.next(i), t <= r && e.complete());
    }));
  });
}
function OQ() {
  return yt(function(t, A) {
    t.subscribe(It(A, Xc));
  });
}
function l$(t) {
  return ht(function() {
    return t;
  });
}
function RsA(t, A) {
  return gt(function(e, r) {
    return cr(t(e, r)).pipe(vS(1), l$(e));
  });
}
function B$(t, A) {
  return A === void 0 && (A = xi), t = t ?? E$, yt(function(e, r) {
    var i, n = !0;
    e.subscribe(It(r, function(s) {
      var a = A(s);
      (n || !t(i, a)) && (n = !1, i = a, r.next(s));
    }));
  });
}
function E$(t, A) {
  return t === A;
}
function wp(t) {
  return t === void 0 && (t = h$), yt(function(A, e) {
    var r = !1;
    A.subscribe(It(e, function(i) {
      r = !0, e.next(i);
    }, function() {
      return r ? e.complete() : e.error(t());
    }));
  });
}
function h$() {
  return new pp();
}
function qd(t, A) {
  var e = arguments.length >= 2;
  return function(r) {
    return r.pipe(t ? Fg(function(i, n) {
      return t(i, n, r);
    }) : xi, vS(1), e ? HU(A) : wp(function() {
      return new pp();
    }));
  };
}
function Q$(t, A, e) {
  return e === void 0 && (e = 1 / 0), yt(function(r, i) {
    var n = A;
    return GU(r, i, function(s, a) {
      return t(n, s, a);
    }, e, function(s) {
      n = s;
    }, !1, void 0, function() {
      return n = null;
    });
  });
}
function ln() {
  for (var t = [], A = 0; A < arguments.length; A++)
    t[A] = arguments[A];
  return t.length ? yt(function(e, r) {
    JU(Zc([e], hg(t)))(r);
  }) : xi;
}
function YQ(t) {
  t === void 0 && (t = 1 / 0);
  var A;
  t && typeof t == "object" ? A = t : A = {
    count: t
  };
  var e = A.count, r = e === void 0 ? 1 / 0 : e, i = A.delay, n = A.resetOnSuccess, s = n === void 0 ? !1 : n;
  return r <= 0 ? xi : yt(function(a, g) {
    var o = 0, u, I = function() {
      var c = !1;
      u = a.subscribe(It(g, function(C) {
        s && (o = 0), g.next(C);
      }, void 0, function(C) {
        if (o++ < r) {
          var E = function() {
            u ? (u.unsubscribe(), u = null, I()) : c = !0;
          };
          if (i != null) {
            var l = typeof i == "number" ? yp(i) : cr(i(C, o)), B = It(g, function() {
              B.unsubscribe(), E();
            }, function() {
              g.complete();
            });
            l.subscribe(B);
          } else
            E();
        } else
          g.error(C);
      })), c && (u.unsubscribe(), u = null, I());
    };
    I();
  });
}
function d$() {
  for (var t = [], A = 0; A < arguments.length; A++)
    t[A] = arguments[A];
  var e = YE(t);
  return yt(function(r, i) {
    (e ? bm(t, r, e) : bm(t, r)).subscribe(i);
  });
}
function f$(t, A) {
  return yt(function(e, r) {
    var i = null, n = 0, s = !1, a = function() {
      return s && !i && r.complete();
    };
    e.subscribe(It(r, function(g) {
      i == null || i.unsubscribe();
      var o = 0, u = n++;
      cr(t(g, u)).subscribe(i = It(r, function(I) {
        return r.next(A ? A(g, I, u, o++) : I);
      }, function() {
        i = null, a();
      }));
    }, function() {
      s = !0, a();
    }));
  });
}
function PU(t) {
  return yt(function(A, e) {
    cr(t).subscribe(It(e, function() {
      return e.complete();
    }, Xc)), !e.closed && A.subscribe(e);
  });
}
function kC(t, A, e) {
  var r = Le(t) || A || e ? { next: t, error: A, complete: e } : t;
  return r ? yt(function(i, n) {
    var s;
    (s = r.subscribe) === null || s === void 0 || s.call(r);
    var a = !0;
    i.subscribe(It(n, function(g) {
      var o;
      (o = r.next) === null || o === void 0 || o.call(r, g), n.next(g);
    }, function() {
      var g;
      a = !1, (g = r.complete) === null || g === void 0 || g.call(r), n.complete();
    }, function(g) {
      var o;
      a = !1, (o = r.error) === null || o === void 0 || o.call(r, g), n.error(g);
    }, function() {
      var g, o;
      a && ((g = r.unsubscribe) === null || g === void 0 || g.call(r)), (o = r.finalize) === null || o === void 0 || o.call(r);
    }));
  }) : xi;
}
function p$(t) {
  return { all: t = t || /* @__PURE__ */ new Map(), on: function(A, e) {
    var r = t.get(A);
    r ? r.push(e) : t.set(A, [e]);
  }, off: function(A, e) {
    var r = t.get(A);
    r && (e ? r.splice(r.indexOf(e) >>> 0, 1) : t.set(A, []));
  }, emit: function(A, e) {
    var r = t.get(A);
    r && r.slice().map(function(i) {
      i(e);
    }), (r = t.get("*")) && r.slice().map(function(i) {
      i(A, e);
    });
  } };
}
/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
Symbol.dispose ?? (Symbol.dispose = Symbol("dispose"));
Symbol.asyncDispose ?? (Symbol.asyncDispose = Symbol("asyncDispose"));
const ke = Symbol.dispose, sr = Symbol.asyncDispose;
var p_, y_, Ts, ji;
const XS = class XS {
  constructor() {
    k(this, Ts, !1);
    k(this, ji, []);
    R(this, p_, "DisposableStack");
  }
  /**
   * Returns a value indicating whether the stack has been disposed.
   */
  get disposed() {
    return d(this, Ts);
  }
  /**
   * Alias for `[Symbol.dispose]()`.
   */
  dispose() {
    this[ke]();
  }
  /**
   * Adds a disposable resource to the top of stack, returning the resource.
   * Has no effect if provided `null` or `undefined`.
   *
   * @param value - A `Disposable` object, `null`, or `undefined`.
   * `null` and `undefined` will not be added, but will be returned.
   * @returns The provided `value`.
   */
  use(A) {
    return A && typeof A[ke] == "function" && d(this, ji).push(A), A;
  }
  /**
   * Adds a non-disposable resource and a disposal callback to the top of the stack.
   *
   * @param value - A resource to be disposed.
   * @param onDispose - A callback invoked to dispose the provided value.
   * Will be invoked with `value` as the first parameter.
   * @returns The provided `value`.
   */
  adopt(A, e) {
    return d(this, ji).push({
      [ke]() {
        e(A);
      }
    }), A;
  }
  /**
   * Add a disposal callback to the top of the stack to be invoked when stack is disposed.
   * @param onDispose - A callback to invoke when this object is disposed.
   */
  defer(A) {
    d(this, ji).push({
      [ke]() {
        A();
      }
    });
  }
  /**
   * Move all resources out of this stack and into a new `DisposableStack`, and
   * marks this stack as disposed.
   * @returns The new `DisposableStack`.
   *
   * @example
   *
   * ```ts
   * class C {
   *   #res1: Disposable;
   *   #res2: Disposable;
   *   #disposables: DisposableStack;
   *   constructor() {
   *     // stack will be disposed when exiting constructor for any reason
   *     using stack = new DisposableStack();
   *
   *     // get first resource
   *     this.#res1 = stack.use(getResource1());
   *
   *     // get second resource. If this fails, both `stack` and `#res1` will be disposed.
   *     this.#res2 = stack.use(getResource2());
   *
   *     // all operations succeeded, move resources out of `stack` so that
   *     // they aren't disposed when constructor exits
   *     this.#disposables = stack.move();
   *   }
   *
   *   [disposeSymbol]() {
   *     this.#disposables.dispose();
   *   }
   * }
   * ```
   */
  move() {
    if (d(this, Ts))
      throw new ReferenceError("A disposed stack can not use anything new");
    const A = new XS();
    return x(A, ji, d(this, ji)), x(this, ji, []), x(this, Ts, !0), A;
  }
  /**
   * Disposes each resource in the stack in last-in-first-out (LIFO) manner.
   */
  [(y_ = ke, p_ = Symbol.toStringTag, y_)]() {
    if (d(this, Ts))
      return;
    x(this, Ts, !0);
    const A = [];
    for (const e of d(this, ji).reverse())
      try {
        e[ke]();
      } catch (r) {
        A.push(r);
      }
    if (A.length === 1)
      throw A[0];
    if (A.length > 1) {
      let e = null;
      for (const r of A)
        e === null ? e = r : e = new YU(r, e);
      throw e;
    }
  }
};
Ts = new WeakMap(), ji = new WeakMap();
let Mm = XS;
const ms = globalThis.DisposableStack ?? Mm;
var w_, m_, Ks, di;
const zS = class zS {
  constructor() {
    k(this, Ks, !1);
    k(this, di, []);
    R(this, w_, "AsyncDisposableStack");
  }
  /**
   * Returns a value indicating whether the stack has been disposed.
   */
  get disposed() {
    return d(this, Ks);
  }
  /**
   * Alias for `[Symbol.asyncDispose]()`.
   */
  async disposeAsync() {
    await this[sr]();
  }
  /**
   * Adds a AsyncDisposable resource to the top of stack, returning the resource.
   * Has no effect if provided `null` or `undefined`.
   *
   * @param value - A `AsyncDisposable` object, `null`, or `undefined`.
   * `null` and `undefined` will not be added, but will be returned.
   * @returns The provided `value`.
   */
  use(A) {
    if (A) {
      const e = A[sr], r = A[ke];
      typeof e == "function" ? d(this, di).push(A) : typeof r == "function" && d(this, di).push({
        [sr]: async () => {
          A[ke]();
        }
      });
    }
    return A;
  }
  /**
   * Adds a non-disposable resource and a disposal callback to the top of the stack.
   *
   * @param value - A resource to be disposed.
   * @param onDispose - A callback invoked to dispose the provided value.
   * Will be invoked with `value` as the first parameter.
   * @returns The provided `value`.
   */
  adopt(A, e) {
    return d(this, di).push({
      [sr]() {
        return e(A);
      }
    }), A;
  }
  /**
   * Add a disposal callback to the top of the stack to be invoked when stack is disposed.
   * @param onDispose - A callback to invoke when this object is disposed.
   */
  defer(A) {
    d(this, di).push({
      [sr]() {
        return A();
      }
    });
  }
  /**
   * Move all resources out of this stack and into a new `DisposableStack`, and
   * marks this stack as disposed.
   * @returns The new `AsyncDisposableStack`.
   *
   * @example
   *
   * ```ts
   * class C {
   *   #res1: Disposable;
   *   #res2: Disposable;
   *   #disposables: DisposableStack;
   *   constructor() {
   *     // stack will be disposed when exiting constructor for any reason
   *     using stack = new DisposableStack();
   *
   *     // get first resource
   *     this.#res1 = stack.use(getResource1());
   *
   *     // get second resource. If this fails, both `stack` and `#res1` will be disposed.
   *     this.#res2 = stack.use(getResource2());
   *
   *     // all operations succeeded, move resources out of `stack` so that
   *     // they aren't disposed when constructor exits
   *     this.#disposables = stack.move();
   *   }
   *
   *   [disposeSymbol]() {
   *     this.#disposables.dispose();
   *   }
   * }
   * ```
   */
  move() {
    if (d(this, Ks))
      throw new ReferenceError("A disposed stack can not use anything new");
    const A = new zS();
    return x(A, di, d(this, di)), x(this, di, []), x(this, Ks, !0), A;
  }
  /**
   * Disposes each resource in the stack in last-in-first-out (LIFO) manner.
   */
  async [(m_ = sr, w_ = Symbol.toStringTag, m_)]() {
    if (d(this, Ks))
      return;
    x(this, Ks, !0);
    const A = [];
    for (const e of d(this, di).reverse())
      try {
        await e[sr]();
      } catch (r) {
        A.push(r);
      }
    if (A.length === 1)
      throw A[0];
    if (A.length > 1) {
      let e = null;
      for (const r of A)
        e === null ? e = r : e = new YU(r, e);
      throw e;
    }
  }
};
Ks = new WeakMap(), di = new WeakMap();
let _m = zS;
const OU = globalThis.AsyncDisposableStack ?? _m;
var Il, Cl;
class YU extends Error {
  constructor(e, r, i = "An error was suppressed during disposal") {
    super(i);
    k(this, Il);
    k(this, Cl);
    this.name = "SuppressedError", x(this, Il, e), x(this, Cl, r);
  }
  /**
   * The primary error that occurred during disposal.
   */
  get error() {
    return d(this, Il);
  }
  /**
   * The suppressed error i.e. the error that was suppressed
   * because it occurred later in the flow after the original error.
   */
  get suppressed() {
    return d(this, Cl);
  }
}
Il = new WeakMap(), Cl = new WeakMap();
/**
 * @license
 * Copyright 2022 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
var Yn, Wi, D_;
let je = (D_ = class {
  /**
   * If you pass an emitter, the returned emitter will wrap the passed emitter.
   *
   * @internal
   */
  constructor(A = p$(/* @__PURE__ */ new Map())) {
    k(this, Yn);
    k(this, Wi, /* @__PURE__ */ new Map());
    x(this, Yn, A);
  }
  /**
   * Bind an event listener to fire when an event occurs.
   * @param type - the event type you'd like to listen to. Can be a string or symbol.
   * @param handler - the function to be called when the event occurs.
   * @returns `this` to enable you to chain method calls.
   */
  on(A, e) {
    const r = d(this, Wi).get(A);
    return r === void 0 ? d(this, Wi).set(A, [e]) : r.push(e), d(this, Yn).on(A, e), this;
  }
  /**
   * Remove an event listener from firing.
   * @param type - the event type you'd like to stop listening to.
   * @param handler - the function that should be removed.
   * @returns `this` to enable you to chain method calls.
   */
  off(A, e) {
    const r = d(this, Wi).get(A) ?? [];
    if (e === void 0) {
      for (const n of r)
        d(this, Yn).off(A, n);
      return d(this, Wi).delete(A), this;
    }
    const i = r.lastIndexOf(e);
    return i > -1 && d(this, Yn).off(A, ...r.splice(i, 1)), this;
  }
  /**
   * Emit an event and call any associated listeners.
   *
   * @param type - the event you'd like to emit
   * @param eventData - any data you'd like to emit with the event
   * @returns `true` if there are any listeners, `false` if there are not.
   */
  emit(A, e) {
    return d(this, Yn).emit(A, e), this.listenerCount(A) > 0;
  }
  /**
   * Like `on` but the listener will only be fired once and then it will be removed.
   * @param type - the event you'd like to listen to
   * @param handler - the handler function to run when the event occurs
   * @returns `this` to enable you to chain method calls.
   */
  once(A, e) {
    const r = (i) => {
      e(i), this.off(A, r);
    };
    return this.on(A, r);
  }
  /**
   * Gets the number of listeners for a given event.
   *
   * @param type - the event to get the listener count for
   * @returns the number of listeners bound to the given event
   */
  listenerCount(A) {
    var e;
    return ((e = d(this, Wi).get(A)) == null ? void 0 : e.length) || 0;
  }
  /**
   * Removes all listeners. If given an event argument, it will remove only
   * listeners for that event.
   *
   * @param type - the event to remove listeners for.
   * @returns `this` to enable you to chain method calls.
   */
  removeAllListeners(A) {
    return A !== void 0 ? this.off(A) : (this[ke](), this);
  }
  /**
   * @internal
   */
  [ke]() {
    for (const [A, e] of d(this, Wi))
      for (const r of e)
        d(this, Yn).off(A, r);
    d(this, Wi).clear();
  }
}, Yn = new WeakMap(), Wi = new WeakMap(), D_);
/**
 * @license
 * Copyright 2020 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
const RS = !!(typeof process < "u" && process.version), cs = {
  value: {
    get fs() {
      throw new Error("fs is not available in this environment");
    },
    get ScreenRecorder() {
      throw new Error("ScreenRecorder is not available in this environment");
    }
  }
};
/**
 * @license
 * Copyright 2020 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
const bA = (t, A) => {
  if (!t)
    throw new Error(A);
};
/**
 * @license
 * Copyright 2024 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
function bS(t, A = !1) {
  return A ? typeof Buffer == "function" ? Buffer.from(t, "base64") : Uint8Array.from(atob(t), (e) => e.codePointAt(0)) : new TextEncoder().encode(t);
}
function y$(t) {
  return qU(new TextEncoder().encode(t));
}
function qU(t) {
  const e = [];
  for (let i = 0; i < t.length; i += 65534) {
    const n = t.subarray(i, i + 65534);
    e.push(String.fromCodePoint.apply(null, n));
  }
  const r = e.join("");
  return btoa(r);
}
function w$(t) {
  let A = 0;
  for (const i of t)
    A += i.length;
  const e = new Uint8Array(A);
  let r = 0;
  for (const i of t)
    e.set(i, r), r += i.length;
  return e;
}
/**
 * @license
 * Copyright 2025 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
const jU = "24.33.0";
/**
 * @license
 * Copyright 2020 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
let yy = null;
async function m$() {
  return yy || (yy = (await Promise.resolve().then(() => AeA)).default), yy;
}
const MS = (t) => RS ? async (...A) => {
  (await m$())(t)(A);
} : (...A) => {
  const e = globalThis.__PUPPETEER_DEBUG;
  !e || !(e === "*" || /**
   * If the debug level is `foo*`, that means we match any prefix that
   * starts with `foo`. If the level is `foo`, we match only the prefix
   * `foo`.
   */
  (e.endsWith("*") ? t.startsWith(e) : t === e)) || console.log(`${t}:`, ...A);
};
/**
 * @license
 * Copyright 2018 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
class mp extends Error {
  /**
   * @internal
   */
  constructor(A, e) {
    super(A, e), this.name = this.constructor.name;
  }
  /**
   * @internal
   */
  get [Symbol.toStringTag]() {
    return this.constructor.name;
  }
}
let zc = class extends mp {
};
class Nm extends mp {
}
var ll, Bl;
class Qg extends mp {
  constructor() {
    super(...arguments);
    k(this, ll);
    k(this, Bl, "");
  }
  set code(e) {
    x(this, ll, e);
  }
  /**
   * @readonly
   * @public
   */
  get code() {
    return d(this, ll);
  }
  set originalMessage(e) {
    x(this, Bl, e);
  }
  /**
   * @readonly
   * @public
   */
  get originalMessage() {
    return d(this, Bl);
  }
}
ll = new WeakMap(), Bl = new WeakMap();
class _S extends mp {
}
class Da extends Qg {
}
class D$ extends Qg {
}
/**
 * @license
 * Copyright 2020 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
const S$ = {
  letter: {
    cm: { width: 21.59, height: 27.94 },
    in: { width: 8.5, height: 11 }
  },
  legal: {
    cm: { width: 21.59, height: 35.56 },
    in: { width: 8.5, height: 14 }
  },
  tabloid: {
    cm: { width: 27.94, height: 43.18 },
    in: { width: 11, height: 17 }
  },
  ledger: {
    cm: { width: 43.18, height: 27.94 },
    in: { width: 17, height: 11 }
  },
  a0: {
    cm: { width: 84.1, height: 118.9 },
    in: { width: 33.1102, height: 46.811 }
  },
  a1: {
    cm: { width: 59.4, height: 84.1 },
    in: { width: 23.3858, height: 33.1102 }
  },
  a2: {
    cm: { width: 42, height: 59.4 },
    in: { width: 16.5354, height: 23.3858 }
  },
  a3: {
    cm: { width: 29.7, height: 42 },
    in: { width: 11.6929, height: 16.5354 }
  },
  a4: {
    cm: { width: 21, height: 29.7 },
    in: { width: 8.2677, height: 11.6929 }
  },
  a5: {
    cm: { width: 14.8, height: 21 },
    in: { width: 5.8268, height: 8.2677 }
  },
  a6: {
    cm: { width: 10.5, height: 14.8 },
    in: { width: 4.1339, height: 5.8268 }
  }
};
/**
 * @license
 * Copyright 2017 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
const HA = MS("puppeteer:error"), NS = Object.freeze({ width: 800, height: 600 }), jd = Symbol("Source URL for Puppeteer evaluation scripts");
var co, Io;
const oo = class oo {
  constructor() {
    k(this, co);
    k(this, Io);
  }
  static fromCallSite(A, e) {
    const r = new oo();
    return x(r, co, A), x(r, Io, e.toString()), r;
  }
  get functionName() {
    return d(this, co);
  }
  get siteString() {
    return d(this, Io);
  }
  toString() {
    return `pptr:${[
      d(this, co),
      encodeURIComponent(d(this, Io))
    ].join(";")}`;
  }
};
co = new WeakMap(), Io = new WeakMap(), R(oo, "INTERNAL_URL", "pptr:internal"), R(oo, "parse", (A) => {
  A = A.slice(5);
  const [e = "", r = ""] = A.split(";"), i = new oo();
  return x(i, co, e), x(i, Io, decodeURIComponent(r)), i;
}), R(oo, "isPuppeteerURL", (A) => A.startsWith("pptr:"));
let Is = oo;
const bt = (t, A) => {
  if (Object.prototype.hasOwnProperty.call(A, jd))
    return A;
  const e = Error.prepareStackTrace;
  Error.prepareStackTrace = (i, n) => n[2];
  const r = new Error().stack;
  return Error.prepareStackTrace = e, Object.assign(A, {
    [jd]: Is.fromCallSite(t, r)
  });
}, F$ = (t) => {
  if (Object.prototype.hasOwnProperty.call(t, jd))
    return t[jd];
}, kg = (t) => typeof t == "string" || t instanceof String, k$ = (t) => typeof t == "number" || t instanceof Number, _sA = (t) => typeof t == "object" && (t == null ? void 0 : t.constructor) === Object, NsA = (t) => typeof t == "object" && (t == null ? void 0 : t.constructor) === RegExp, LsA = (t) => typeof t == "object" && (t == null ? void 0 : t.constructor) === Date;
function WU(t, ...A) {
  if (kg(t))
    return bA(A.length === 0, "Cannot evaluate a string with arguments"), t;
  function e(r) {
    return Object.is(r, void 0) ? "undefined" : JSON.stringify(r);
  }
  return `(${t})(${A.map(e).join(",")})`;
}
async function VU(t, A) {
  const e = [], r = t.getReader();
  if (A) {
    const i = await cs.value.fs.promises.open(A, "w+");
    try {
      for (; ; ) {
        const { done: n, value: s } = await r.read();
        if (n)
          break;
        e.push(s), await i.writeFile(s);
      }
    } finally {
      await i.close();
    }
  } else
    for (; ; ) {
      const { done: i, value: n } = await r.read();
      if (i)
        break;
      e.push(n);
    }
  try {
    const i = w$(e);
    return i.length === 0 ? null : i;
  } catch (i) {
    return HA(i), null;
  }
}
async function ZU(t, A) {
  return new ReadableStream({
    async pull(e) {
      const { data: r, base64Encoded: i, eof: n } = await t.send("IO.read", {
        handle: A
      });
      e.enqueue(bS(r, i ?? !1)), n && (await t.send("IO.close", { handle: A }), e.close());
    }
  });
}
function v$(t) {
  let A = null;
  return (/* @__PURE__ */ new Set([
    "alert",
    "confirm",
    "prompt",
    "beforeunload"
  ])).has(t) && (A = t), bA(A, `Unknown javascript dialog type: ${t}`), A;
}
function Bn(t, A) {
  return t === 0 ? TU : yp(t).pipe(ht(() => {
    throw new zc(`Timed out after waiting ${t}ms`, { cause: A });
  }));
}
const zv = "__puppeteer_utility_world__" + jU, $v = /^[\x20\t]*\/\/[@#] sourceURL=\s{0,10}(\S*?)\s{0,10}$/m;
function R$(t) {
  return `//# sourceURL=${t}`;
}
const b$ = 500;
function M$(t = {}, A = "in") {
  var s, a, g, o;
  const e = {
    scale: 1,
    displayHeaderFooter: !1,
    headerTemplate: "",
    footerTemplate: "",
    printBackground: !1,
    landscape: !1,
    pageRanges: "",
    preferCSSPageSize: !1,
    omitBackground: !1,
    outline: !1,
    tagged: !0,
    waitForFonts: !0
  };
  let r = 8.5, i = 11;
  if (t.format) {
    const u = S$[t.format.toLowerCase()][A];
    bA(u, "Unknown paper format: " + t.format), r = u.width, i = u.height;
  } else
    r = Gg(t.width, A) ?? r, i = Gg(t.height, A) ?? i;
  const n = {
    top: Gg((s = t.margin) == null ? void 0 : s.top, A) || 0,
    left: Gg((a = t.margin) == null ? void 0 : a.left, A) || 0,
    bottom: Gg((g = t.margin) == null ? void 0 : g.bottom, A) || 0,
    right: Gg((o = t.margin) == null ? void 0 : o.right, A) || 0
  };
  return t.outline && (t.tagged = !0), {
    ...e,
    ...t,
    width: r,
    height: i,
    margin: n
  };
}
const wy = {
  px: 1,
  in: 96,
  cm: 37.8,
  mm: 3.78
};
function Gg(t, A = "in") {
  if (typeof t > "u")
    return;
  let e;
  if (k$(t))
    e = t;
  else if (kg(t)) {
    const r = t;
    let i = r.substring(r.length - 2).toLowerCase(), n = "";
    i in wy ? n = r.substring(0, r.length - 2) : (i = "px", n = r);
    const s = Number(n);
    bA(!isNaN(s), "Failed to parse parameter value: " + r), e = s * wy[i];
  } else
    throw new Error("page.pdf() Cannot handle parameter type: " + typeof t);
  return e / wy[A];
}
function ot(t, A) {
  return new ft((e) => {
    const r = (i) => {
      e.next(i);
    };
    return t.on(A, r), () => {
      t.off(A, r);
    };
  });
}
function eu(t, A) {
  return t ? Yd(t, "abort").pipe(ht(() => {
    throw t.reason instanceof Error ? (t.reason.cause = A, t.reason) : new Error(t.reason, { cause: A });
  })) : TU;
}
function JC(t) {
  return gt((A) => de(Promise.resolve(t(A))).pipe(Fg((e) => e), ht(() => A)));
}
const _$ = /* @__PURE__ */ new Map([
  ["accelerometer", "sensors"],
  ["ambient-light-sensor", "sensors"],
  ["background-sync", "backgroundSync"],
  ["camera", "videoCapture"],
  ["clipboard-read", "clipboardReadWrite"],
  ["clipboard-sanitized-write", "clipboardSanitizedWrite"],
  ["clipboard-write", "clipboardReadWrite"],
  ["geolocation", "geolocation"],
  ["gyroscope", "sensors"],
  ["idle-detection", "idleDetection"],
  ["keyboard-lock", "keyboardLock"],
  ["magnetometer", "sensors"],
  ["microphone", "audioCapture"],
  ["midi", "midi"],
  ["notifications", "notifications"],
  ["payment-handler", "paymentHandler"],
  ["persistent-storage", "durableStorage"],
  ["pointer-lock", "pointerLock"],
  // chrome-specific permissions we have.
  ["midi-sysex", "midiSysex"]
]);
let N$ = class extends je {
  /**
   * @internal
   */
  constructor() {
    super();
  }
  /**
   * Waits until a {@link Target | target} matching the given `predicate`
   * appears and returns it.
   *
   * This will look all open {@link BrowserContext | browser contexts}.
   *
   * @example Finding a target for a page opened via `window.open`:
   *
   * ```ts
   * await page.evaluate(() => window.open('https://www.example.com/'));
   * const newWindowTarget = await browser.waitForTarget(
   *   target => target.url() === 'https://www.example.com/',
   * );
   * ```
   */
  async waitForTarget(A, e = {}) {
    const { timeout: r = 3e4, signal: i } = e;
    return await or(sl(ot(
      this,
      "targetcreated"
      /* BrowserEvent.TargetCreated */
    ), ot(
      this,
      "targetchanged"
      /* BrowserEvent.TargetChanged */
    ), de(this.targets())).pipe(JC(A), ln(eu(i), Bn(r))));
  }
  /**
   * Gets a list of all open {@link Page | pages} inside this {@link Browser}.
   *
   * If there are multiple {@link BrowserContext | browser contexts}, this
   * returns all {@link Page | pages} in all
   * {@link BrowserContext | browser contexts}.
   *
   * @param includeAll - experimental, setting to true includes all kinds of pages.
   *
   * @remarks Non-visible {@link Page | pages}, such as `"background_page"`,
   * will not be listed here. You can find them using {@link Target.page}.
   */
  async pages(A = !1) {
    return (await Promise.all(this.browserContexts().map((r) => r.pages(A)))).reduce((r, i) => r.concat(i), []);
  }
  /**
   * Returns all cookies in the default {@link BrowserContext}.
   *
   * @remarks
   *
   * Shortcut for
   * {@link BrowserContext.cookies | browser.defaultBrowserContext().cookies()}.
   */
  async cookies() {
    return await this.defaultBrowserContext().cookies();
  }
  /**
   * Sets cookies in the default {@link BrowserContext}.
   *
   * @remarks
   *
   * Shortcut for
   * {@link BrowserContext.setCookie | browser.defaultBrowserContext().setCookie()}.
   */
  async setCookie(...A) {
    return await this.defaultBrowserContext().setCookie(...A);
  }
  /**
   * Removes cookies from the default {@link BrowserContext}.
   *
   * @remarks
   *
   * Shortcut for
   * {@link BrowserContext.deleteCookie | browser.defaultBrowserContext().deleteCookie()}.
   */
  async deleteCookie(...A) {
    return await this.defaultBrowserContext().deleteCookie(...A);
  }
  /**
   * Deletes cookies matching the provided filters from the default
   * {@link BrowserContext}.
   *
   * @remarks
   *
   * Shortcut for
   * {@link BrowserContext.deleteMatchingCookies |
   * browser.defaultBrowserContext().deleteMatchingCookies()}.
   */
  async deleteMatchingCookies(...A) {
    return await this.defaultBrowserContext().deleteMatchingCookies(...A);
  }
  /**
   * Whether Puppeteer is connected to this {@link Browser | browser}.
   *
   * @deprecated Use {@link Browser | Browser.connected}.
   */
  isConnected() {
    return this.connected;
  }
  /** @internal */
  [ke]() {
    return this.process() ? void this.close().catch(HA) : void this.disconnect().catch(HA);
  }
  /** @internal */
  [sr]() {
    return this.process() ? this.close() : this.disconnect();
  }
};
/**
 * @license
 * Copyright 2024 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
var Js, Hs, Co, El, lf, Cu, hl, Ql, Lm, lu;
const Bf = class Bf {
  constructor(A) {
    k(this, Ql);
    k(this, Js, !1);
    k(this, Hs, !1);
    k(this, Co);
    // SAFETY: This is ensured by #taskPromise.
    k(this, El);
    // TODO: Switch to Promise.withResolvers with Node 22
    k(this, lf, new Promise((A) => {
      x(this, El, A);
    }));
    k(this, Cu);
    k(this, hl);
    k(this, lu);
    A && A.timeout > 0 && (x(this, hl, new zc(A.message)), x(this, Cu, setTimeout(() => {
      this.reject(d(this, hl));
    }, A.timeout)));
  }
  static create(A) {
    return new Bf(A);
  }
  static async race(A) {
    const e = /* @__PURE__ */ new Set();
    try {
      const r = A.map((i) => i instanceof Bf ? (d(i, Cu) && e.add(i), i.valueOrThrow()) : i);
      return await Promise.race(r);
    } finally {
      for (const r of e)
        r.reject(new Error("Timeout cleared"));
    }
  }
  resolve(A) {
    d(this, Hs) || d(this, Js) || (x(this, Js, !0), O(this, Ql, Lm).call(this, A));
  }
  reject(A) {
    d(this, Hs) || d(this, Js) || (x(this, Hs, !0), O(this, Ql, Lm).call(this, A));
  }
  resolved() {
    return d(this, Js);
  }
  finished() {
    return d(this, Js) || d(this, Hs);
  }
  value() {
    return d(this, Co);
  }
  valueOrThrow() {
    return d(this, lu) || x(this, lu, (async () => {
      if (await d(this, lf), d(this, Hs))
        throw d(this, Co);
      return d(this, Co);
    })()), d(this, lu);
  }
};
Js = new WeakMap(), Hs = new WeakMap(), Co = new WeakMap(), El = new WeakMap(), lf = new WeakMap(), Cu = new WeakMap(), hl = new WeakMap(), Ql = new WeakSet(), Lm = function(A) {
  clearTimeout(d(this, Cu)), x(this, Co, A), d(this, El).call(this);
}, lu = new WeakMap();
let Ke = Bf;
/**
 * @license
 * Copyright 2024 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
var dl, fl, S_, Bu, pl;
const PC = class PC {
  constructor() {
    k(this, Bu, !1);
    k(this, pl, []);
  }
  // This is FIFO.
  async acquire(A) {
    if (!d(this, Bu))
      return x(this, Bu, !0), new PC.Guard(this);
    const e = Ke.create();
    return d(this, pl).push(e.resolve.bind(e)), await e.valueOrThrow(), new PC.Guard(this, A);
  }
  release() {
    const A = d(this, pl).shift();
    if (!A) {
      x(this, Bu, !1);
      return;
    }
    A();
  }
};
Bu = new WeakMap(), pl = new WeakMap(), R(PC, "Guard", (S_ = class {
  constructor(e, r) {
    k(this, dl);
    k(this, fl);
    x(this, dl, e), x(this, fl, r);
  }
  [ke]() {
    var e;
    return (e = d(this, fl)) == null || e.call(this), d(this, dl).release();
  }
}, dl = new WeakMap(), fl = new WeakMap(), S_));
let al = PC;
/**
 * @license
 * Copyright 2017 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
var lo, Eu;
class L$ extends je {
  /**
   * @internal
   */
  constructor() {
    super();
    /**
     * If defined, indicates an ongoing screenshot opereation.
     */
    k(this, lo);
    k(this, Eu, 0);
  }
  /**
   * @internal
   */
  startScreenshot() {
    const e = d(this, lo) || new al();
    return x(this, lo, e), BI(this, Eu)._++, e.acquire(() => {
      BI(this, Eu)._--, d(this, Eu) === 0 && x(this, lo, void 0);
    });
  }
  /**
   * @internal
   */
  waitForScreenshotOperations() {
    var e;
    return (e = d(this, lo)) == null ? void 0 : e.acquire();
  }
  /**
   * Waits until a {@link Target | target} matching the given `predicate`
   * appears and returns it.
   *
   * This will look all open {@link BrowserContext | browser contexts}.
   *
   * @example Finding a target for a page opened via `window.open`:
   *
   * ```ts
   * await page.evaluate(() => window.open('https://www.example.com/'));
   * const newWindowTarget = await browserContext.waitForTarget(
   *   target => target.url() === 'https://www.example.com/',
   * );
   * ```
   */
  async waitForTarget(e, r = {}) {
    const { timeout: i = 3e4 } = r;
    return await or(sl(ot(
      this,
      "targetcreated"
      /* BrowserContextEvent.TargetCreated */
    ), ot(
      this,
      "targetchanged"
      /* BrowserContextEvent.TargetChanged */
    ), de(this.targets())).pipe(JC(e), ln(Bn(i))));
  }
  /**
   * Removes cookie in this browser context.
   *
   * @param cookies - Complete {@link Cookie | cookie} object to be removed.
   */
  async deleteCookie(...e) {
    return await this.setCookie(...e.map((r) => ({
      ...r,
      expires: 1
    })));
  }
  /**
   * Deletes cookies matching the provided filters in this browser context.
   *
   * @param filters - {@link DeleteCookiesRequest}
   */
  async deleteMatchingCookies(...e) {
    const i = (await this.cookies()).filter((n) => e.some((s) => {
      var a, g;
      if (s.name === n.name) {
        if (s.domain !== void 0 && s.domain === n.domain || s.path !== void 0 && s.path === n.path)
          return !0;
        if (s.partitionKey !== void 0 && n.partitionKey !== void 0) {
          if (typeof n.partitionKey != "object")
            throw new Error("Unexpected string partition key");
          if (typeof s.partitionKey == "string") {
            if (s.partitionKey === ((a = n.partitionKey) == null ? void 0 : a.sourceOrigin))
              return !0;
          } else if (s.partitionKey.sourceOrigin === ((g = n.partitionKey) == null ? void 0 : g.sourceOrigin))
            return !0;
        }
        if (s.url !== void 0) {
          const o = new URL(s.url);
          if (o.hostname === n.domain && o.pathname === n.path)
            return !0;
        }
        return !0;
      }
      return !1;
    }));
    await this.deleteCookie(...i);
  }
  /**
   * Whether this {@link BrowserContext | browser context} is closed.
   */
  get closed() {
    return !this.browser().browserContexts().includes(this);
  }
  /**
   * Identifier for this {@link BrowserContext | browser context}.
   */
  get id() {
  }
  /** @internal */
  [ke]() {
    return void this.close().catch(HA);
  }
  /** @internal */
  [sr]() {
    return this.close();
  }
}
lo = new WeakMap(), Eu = new WeakMap();
var He;
(function(t) {
  t.Disconnected = Symbol("CDPSession.Disconnected"), t.Swapped = Symbol("CDPSession.Swapped"), t.Ready = Symbol("CDPSession.Ready"), t.SessionAttached = "sessionattached", t.SessionDetached = "sessiondetached";
})(He || (He = {}));
class XU extends je {
  /**
   * @internal
   */
  constructor() {
    super();
  }
  /**
   * Parent session in terms of CDP's auto-attach mechanism.
   *
   * @internal
   */
  parentSession() {
  }
}
/**
 * @license
 * Copyright 2025 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
class x$ {
  constructor() {
    /**
     * Current list of selectable devices.
     */
    R(this, "devices", []);
  }
}
/**
 * @license
 * Copyright 2017 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
var yl, wl, ml;
class G$ {
  /**
   * @internal
   */
  constructor(A, e, r = "") {
    k(this, yl);
    k(this, wl);
    k(this, ml);
    /**
     * @internal
     */
    R(this, "handled", !1);
    x(this, yl, A), x(this, wl, e), x(this, ml, r);
  }
  /**
   * The type of the dialog.
   */
  type() {
    return d(this, yl);
  }
  /**
   * The message displayed in the dialog.
   */
  message() {
    return d(this, wl);
  }
  /**
   * The default value of the prompt, or an empty string if the dialog
   * is not a `prompt`.
   */
  defaultValue() {
    return d(this, ml);
  }
  /**
   * A promise that resolves when the dialog has been accepted.
   *
   * @param promptText - optional text that will be entered in the dialog
   * prompt. Has no effect if the dialog's type is not `prompt`.
   *
   */
  async accept(A) {
    bA(!this.handled, "Cannot accept dialog which is already handled!"), this.handled = !0, await this.handle({
      accept: !0,
      text: A
    });
  }
  /**
   * A promise which will resolve once the dialog has been dismissed
   */
  async dismiss() {
    bA(!this.handled, "Cannot dismiss dialog which is already handled!"), this.handled = !0, await this.handle({
      accept: !1
    });
  }
}
yl = new WeakMap(), wl = new WeakMap(), ml = new WeakMap();
class Dp {
  static async *map(A, e) {
    for await (const r of A)
      yield await e(r);
  }
  static async *flatMap(A, e) {
    for await (const r of A)
      yield* e(r);
  }
  static async collect(A) {
    const e = [];
    for await (const r of A)
      e.push(r);
    return e;
  }
  static async first(A) {
    for await (const e of A)
      return e;
  }
}
/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
const qQ = Symbol("_isElementHandle");
/**
 * @license
 * Copyright 2022 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
function _i(t) {
  return typeof t == "object" && t !== null && "name" in t && "message" in t;
}
function zU(t, A, e) {
  return t.message = A, t.originalMessage = e ?? t.originalMessage, t;
}
function $U(t) {
  let A = t.error.message;
  return t.error && typeof t.error == "object" && "data" in t.error && (A += ` ${t.error.data}`), A;
}
/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
const AR = /* @__PURE__ */ new Map(), U$ = (t) => {
  let A = AR.get(t);
  return A || (A = new Function(`return ${t}`)(), AR.set(t, A), A);
};
function Ra(t) {
  let A = t.toString();
  if (A.match(/^(async )*function(\(|\s)/) || A.match(/^(async )*function\s*\*\s*/) || A.startsWith("(") || A.match(/^async\s*\(/) || A.match(/^(async)*\s*(?:[$_\p{ID_Start}])(?:[$\u200C\u200D\p{ID_Continue}])*\s*=>/u))
    return A;
  let r = "function ";
  return A.startsWith("async ") && (r = `async ${r}`, A = A.substring(6)), `${r}${A}`;
}
const HC = (t, A) => {
  let e = Ra(t);
  for (const [r, i] of Object.entries(A))
    e = e.replace(
      new RegExp(`PLACEHOLDER\\(\\s*(?:'${r}'|"${r}")\\s*\\)`, "g"),
      // Wrapping this ensures tersers that accidentally inline PLACEHOLDER calls
      // are still valid. Without, we may get calls like ()=>{...}() which is
      // not valid.
      `(${i})`
    );
  return U$(e);
};
/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
var jQ = function(t, A, e) {
  if (A != null) {
    if (typeof A != "object" && typeof A != "function") throw new TypeError("Object expected.");
    var r, i;
    if (e) {
      if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
      r = A[Symbol.asyncDispose];
    }
    if (r === void 0) {
      if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
      r = A[Symbol.dispose], e && (i = r);
    }
    if (typeof r != "function") throw new TypeError("Object not disposable.");
    i && (r = function() {
      try {
        i.call(this);
      } catch (n) {
        return Promise.reject(n);
      }
    }), t.stack.push({ value: A, dispose: r, async: e });
  } else e && t.stack.push({ async: !0 });
  return A;
}, xm = /* @__PURE__ */ function(t) {
  return function(A) {
    function e(s) {
      A.error = A.hasError ? new t(s, A.error, "An error was suppressed during disposal.") : s, A.hasError = !0;
    }
    var r, i = 0;
    function n() {
      for (; r = A.stack.pop(); )
        try {
          if (!r.async && i === 1) return i = 0, A.stack.push(r), Promise.resolve().then(n);
          if (r.dispose) {
            var s = r.dispose.call(r.value);
            if (r.async) return i |= 2, Promise.resolve(s).then(n, function(a) {
              return e(a), n();
            });
          } else i |= 1;
        } catch (a) {
          e(a);
        }
      if (i === 1) return A.hasError ? Promise.reject(A.error) : Promise.resolve();
      if (A.hasError) throw A.error;
    }
    return n();
  };
}(typeof SuppressedError == "function" ? SuppressedError : function(t, A, e) {
  var r = new Error(e);
  return r.name = "SuppressedError", r.error = t, r.suppressed = A, r;
});
const T$ = 20;
async function* K$(t, A) {
  const e = { stack: [], error: void 0, hasError: !1 };
  try {
    const i = await jQ(e, await t.evaluateHandle(async (a, g) => {
      const o = [];
      for (; o.length < g; ) {
        const u = await a.next();
        if (u.done)
          break;
        o.push(u.value);
      }
      return o;
    }, A), !1).getProperties(), n = i.values();
    return jQ(e, new ms(), !1).defer(() => {
      for (const a of n) {
        const g = { stack: [], error: void 0, hasError: !1 };
        try {
          jQ(g, a, !1)[ke]();
        } catch (o) {
          g.error = o, g.hasError = !0;
        } finally {
          xm(g);
        }
      }
    }), yield* n, i.size === 0;
  } catch (r) {
    e.error = r, e.hasError = !0;
  } finally {
    xm(e);
  }
}
async function* J$(t) {
  let A = T$;
  for (; !(yield* K$(t, A)); )
    A <<= 1;
}
async function* A1(t) {
  const A = { stack: [], error: void 0, hasError: !1 };
  try {
    const e = jQ(A, await t.evaluateHandle((r) => async function* () {
      yield* r;
    }()), !1);
    yield* J$(e);
  } catch (e) {
    A.error = e, A.hasError = !0;
  } finally {
    xm(A);
  }
}
/**
 * @license
 * Copyright 2022 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
var Dl;
const Ef = class Ef {
  constructor(A) {
    k(this, Dl);
    x(this, Dl, A);
  }
  async get(A) {
    return await d(this, Dl).call(this, A);
  }
};
Dl = new WeakMap(), R(Ef, "create", (A) => new Ef(A));
let vi = Ef;
/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
var vh = function(t, A, e) {
  if (A != null) {
    if (typeof A != "object" && typeof A != "function") throw new TypeError("Object expected.");
    var r, i;
    if (e) {
      if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
      r = A[Symbol.asyncDispose];
    }
    if (r === void 0) {
      if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
      r = A[Symbol.dispose], e && (i = r);
    }
    if (typeof r != "function") throw new TypeError("Object not disposable.");
    i && (r = function() {
      try {
        i.call(this);
      } catch (n) {
        return Promise.reject(n);
      }
    }), t.stack.push({ value: A, dispose: r, async: e });
  } else e && t.stack.push({ async: !0 });
  return A;
}, Rh = /* @__PURE__ */ function(t) {
  return function(A) {
    function e(s) {
      A.error = A.hasError ? new t(s, A.error, "An error was suppressed during disposal.") : s, A.hasError = !0;
    }
    var r, i = 0;
    function n() {
      for (; r = A.stack.pop(); )
        try {
          if (!r.async && i === 1) return i = 0, A.stack.push(r), Promise.resolve().then(n);
          if (r.dispose) {
            var s = r.dispose.call(r.value);
            if (r.async) return i |= 2, Promise.resolve(s).then(n, function(a) {
              return e(a), n();
            });
          } else i |= 1;
        } catch (a) {
          e(a);
        }
      if (i === 1) return A.hasError ? Promise.reject(A.error) : Promise.resolve();
      if (A.hasError) throw A.error;
    }
    return n();
  };
}(typeof SuppressedError == "function" ? SuppressedError : function(t, A, e) {
  var r = new Error(e);
  return r.name = "SuppressedError", r.error = t, r.suppressed = A, r;
});
class Qs {
  static get _querySelector() {
    if (this.querySelector)
      return this.querySelector;
    if (!this.querySelectorAll)
      throw new Error("Cannot create default `querySelector`.");
    return this.querySelector = HC(async (A, e, r) => {
      const n = PLACEHOLDER("querySelectorAll")(A, e, r);
      for await (const s of n)
        return s;
      return null;
    }, {
      querySelectorAll: Ra(this.querySelectorAll)
    });
  }
  static get _querySelectorAll() {
    if (this.querySelectorAll)
      return this.querySelectorAll;
    if (!this.querySelector)
      throw new Error("Cannot create default `querySelectorAll`.");
    return this.querySelectorAll = HC(async function* (A, e, r) {
      const n = await PLACEHOLDER("querySelector")(A, e, r);
      n && (yield n);
    }, {
      querySelector: Ra(this.querySelector)
    });
  }
  /**
   * Queries for multiple nodes given a selector and {@link ElementHandle}.
   *
   * Akin to {@link https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelectorAll | Document.querySelectorAll()}.
   */
  static async *queryAll(A, e) {
    const r = { stack: [], error: void 0, hasError: !1 };
    try {
      const i = vh(r, await A.evaluateHandle(this._querySelectorAll, e, vi.create((n) => n.puppeteerUtil)), !1);
      yield* A1(i);
    } catch (i) {
      r.error = i, r.hasError = !0;
    } finally {
      Rh(r);
    }
  }
  /**
   * Queries for a single node given a selector and {@link ElementHandle}.
   *
   * Akin to {@link https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelector}.
   */
  static async queryOne(A, e) {
    const r = { stack: [], error: void 0, hasError: !1 };
    try {
      const i = vh(r, await A.evaluateHandle(this._querySelector, e, vi.create((n) => n.puppeteerUtil)), !1);
      return qQ in i ? i.move() : null;
    } catch (i) {
      r.error = i, r.hasError = !0;
    } finally {
      Rh(r);
    }
  }
  /**
   * Waits until a single node appears for a given selector and
   * {@link ElementHandle}.
   *
   * This will always query the handle in the Puppeteer world and migrate the
   * result to the main world.
   */
  static async waitFor(A, e, r) {
    const i = { stack: [], error: void 0, hasError: !1 };
    try {
      let n;
      const s = vh(i, await (async () => {
        if (!(qQ in A)) {
          n = A;
          return;
        }
        return n = A.frame, await n.isolatedRealm().adoptHandle(A);
      })(), !1), { visible: a = !1, hidden: g = !1, timeout: o, signal: u } = r, I = a || g ? "raf" : r.polling;
      try {
        const c = { stack: [], error: void 0, hasError: !1 };
        try {
          u == null || u.throwIfAborted();
          const C = vh(c, await n.isolatedRealm().waitForFunction(async (E, l, B, h, Q) => {
            const p = await E.createFunction(l)(h ?? document, B, E);
            return E.checkVisibility(p, Q);
          }, {
            polling: I,
            root: s,
            timeout: o,
            signal: u
          }, vi.create((E) => E.puppeteerUtil), Ra(this._querySelector), e, s, a ? !0 : g ? !1 : void 0), !1);
          if (u != null && u.aborted)
            throw u.reason;
          return qQ in C ? await n.mainRealm().transferHandle(C) : null;
        } catch (C) {
          c.error = C, c.hasError = !0;
        } finally {
          Rh(c);
        }
      } catch (c) {
        if (!_i(c) || c.name === "AbortError")
          throw c;
        const C = new (c instanceof zc ? zc : Error)(`Waiting for selector \`${e}\` failed`);
        throw C.cause = c, C;
      }
    } catch (n) {
      i.error = n, i.hasError = !0;
    } finally {
      Rh(i);
    }
  }
}
// Either one of these may be implemented, but at least one must be.
R(Qs, "querySelectorAll"), R(Qs, "querySelector");
/**
 * @license
 * Copyright 2020 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
const H$ = (t) => ["name", "role"].includes(t), P$ = /\[\s*(?<attribute>\w+)\s*=\s*(?<quote>"|')(?<value>\\.|.*?(?=\k<quote>))\k<quote>\s*\]/g, O$ = (t) => {
  if (t.length > 1e4)
    throw new Error(`Selector ${t} is too long`);
  const A = {}, e = t.replace(P$, (r, i, n, s) => (bA(H$(i), `Unknown aria attribute "${i}" in selector`), A[i] = s, ""));
  return e && !A.name && (A.name = e), A;
}, OC = class OC extends Qs {
  static async *queryAll(A, e) {
    const { name: r, role: i } = O$(e);
    yield* A.queryAXTree(r, i);
  }
};
R(OC, "querySelector", async (A, e, { ariaQuerySelector: r }) => await r(A, e)), R(OC, "queryOne", async (A, e) => await Dp.first(OC.queryAll(A, e)) ?? null);
let ol = OC;
/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
class Wd extends Qs {
}
R(Wd, "querySelector", (A, e, { cssQuerySelector: r }) => r(A, e)), R(Wd, "querySelectorAll", (A, e, { cssQuerySelectorAll: r }) => r(A, e));
const Y$ = '"use strict";var g=Object.defineProperty;var X=Object.getOwnPropertyDescriptor;var B=Object.getOwnPropertyNames;var Y=Object.prototype.hasOwnProperty;var l=(t,e)=>{for(var r in e)g(t,r,{get:e[r],enumerable:!0})},G=(t,e,r,o)=>{if(e&&typeof e=="object"||typeof e=="function")for(let s of B(e))!Y.call(t,s)&&s!==r&&g(t,s,{get:()=>e[s],enumerable:!(o=X(e,s))||o.enumerable});return t};var J=t=>G(g({},"__esModule",{value:!0}),t);var pe={};l(pe,{default:()=>he});module.exports=J(pe);var N=class extends Error{constructor(e,r){super(e,r),this.name=this.constructor.name}get[Symbol.toStringTag](){return this.constructor.name}},p=class extends N{};var c=class t{static create(e){return new t(e)}static async race(e){let r=new Set;try{let o=e.map(s=>s instanceof t?(s.#s&&r.add(s),s.valueOrThrow()):s);return await Promise.race(o)}finally{for(let o of r)o.reject(new Error("Timeout cleared"))}}#e=!1;#r=!1;#o;#t;#a=new Promise(e=>{this.#t=e});#s;#i;constructor(e){e&&e.timeout>0&&(this.#i=new p(e.message),this.#s=setTimeout(()=>{this.reject(this.#i)},e.timeout))}#l(e){clearTimeout(this.#s),this.#o=e,this.#t()}resolve(e){this.#r||this.#e||(this.#e=!0,this.#l(e))}reject(e){this.#r||this.#e||(this.#r=!0,this.#l(e))}resolved(){return this.#e}finished(){return this.#e||this.#r}value(){return this.#o}#n;valueOrThrow(){return this.#n||(this.#n=(async()=>{if(await this.#a,this.#r)throw this.#o;return this.#o})()),this.#n}};var L=new Map,W=t=>{let e=L.get(t);return e||(e=new Function(`return ${t}`)(),L.set(t,e),e)};var b={};l(b,{ariaQuerySelector:()=>z,ariaQuerySelectorAll:()=>x});var z=(t,e)=>globalThis.__ariaQuerySelector(t,e),x=async function*(t,e){yield*await globalThis.__ariaQuerySelectorAll(t,e)};var E={};l(E,{cssQuerySelector:()=>K,cssQuerySelectorAll:()=>Z});var K=(t,e)=>t.querySelector(e),Z=function(t,e){return t.querySelectorAll(e)};var A={};l(A,{customQuerySelectors:()=>P});var v=class{#e=new Map;register(e,r){if(!r.queryOne&&r.queryAll){let o=r.queryAll;r.queryOne=(s,i)=>{for(let n of o(s,i))return n;return null}}else if(r.queryOne&&!r.queryAll){let o=r.queryOne;r.queryAll=(s,i)=>{let n=o(s,i);return n?[n]:[]}}else if(!r.queryOne||!r.queryAll)throw new Error("At least one query method must be defined.");this.#e.set(e,{querySelector:r.queryOne,querySelectorAll:r.queryAll})}unregister(e){this.#e.delete(e)}get(e){return this.#e.get(e)}clear(){this.#e.clear()}},P=new v;var R={};l(R,{pierceQuerySelector:()=>ee,pierceQuerySelectorAll:()=>te});var ee=(t,e)=>{let r=null,o=s=>{let i=document.createTreeWalker(s,NodeFilter.SHOW_ELEMENT);do{let n=i.currentNode;n.shadowRoot&&o(n.shadowRoot),!(n instanceof ShadowRoot)&&n!==s&&!r&&n.matches(e)&&(r=n)}while(!r&&i.nextNode())};return t instanceof Document&&(t=t.documentElement),o(t),r},te=(t,e)=>{let r=[],o=s=>{let i=document.createTreeWalker(s,NodeFilter.SHOW_ELEMENT);do{let n=i.currentNode;n.shadowRoot&&o(n.shadowRoot),!(n instanceof ShadowRoot)&&n!==s&&n.matches(e)&&r.push(n)}while(i.nextNode())};return t instanceof Document&&(t=t.documentElement),o(t),r};var u=(t,e)=>{if(!t)throw new Error(e)};var y=class{#e;#r;#o;#t;constructor(e,r){this.#e=e,this.#r=r}async start(){let e=this.#t=c.create(),r=await this.#e();if(r){e.resolve(r);return}this.#o=new MutationObserver(async()=>{let o=await this.#e();o&&(e.resolve(o),await this.stop())}),this.#o.observe(this.#r,{childList:!0,subtree:!0,attributes:!0})}async stop(){u(this.#t,"Polling never started."),this.#t.finished()||this.#t.reject(new Error("Polling stopped")),this.#o&&(this.#o.disconnect(),this.#o=void 0)}result(){return u(this.#t,"Polling never started."),this.#t.valueOrThrow()}},w=class{#e;#r;constructor(e){this.#e=e}async start(){let e=this.#r=c.create(),r=await this.#e();if(r){e.resolve(r);return}let o=async()=>{if(e.finished())return;let s=await this.#e();if(!s){window.requestAnimationFrame(o);return}e.resolve(s),await this.stop()};window.requestAnimationFrame(o)}async stop(){u(this.#r,"Polling never started."),this.#r.finished()||this.#r.reject(new Error("Polling stopped"))}result(){return u(this.#r,"Polling never started."),this.#r.valueOrThrow()}},T=class{#e;#r;#o;#t;constructor(e,r){this.#e=e,this.#r=r}async start(){let e=this.#t=c.create(),r=await this.#e();if(r){e.resolve(r);return}this.#o=setInterval(async()=>{let o=await this.#e();o&&(e.resolve(o),await this.stop())},this.#r)}async stop(){u(this.#t,"Polling never started."),this.#t.finished()||this.#t.reject(new Error("Polling stopped")),this.#o&&(clearInterval(this.#o),this.#o=void 0)}result(){return u(this.#t,"Polling never started."),this.#t.valueOrThrow()}};var _={};l(_,{PCombinator:()=>H,pQuerySelector:()=>fe,pQuerySelectorAll:()=>$});var a=class{static async*map(e,r){for await(let o of e)yield await r(o)}static async*flatMap(e,r){for await(let o of e)yield*r(o)}static async collect(e){let r=[];for await(let o of e)r.push(o);return r}static async first(e){for await(let r of e)return r}};var C={};l(C,{textQuerySelectorAll:()=>m});var re=new Set(["checkbox","image","radio"]),oe=t=>t instanceof HTMLSelectElement||t instanceof HTMLTextAreaElement||t instanceof HTMLInputElement&&!re.has(t.type),se=new Set(["SCRIPT","STYLE"]),f=t=>!se.has(t.nodeName)&&!document.head?.contains(t),I=new WeakMap,F=t=>{for(;t;)I.delete(t),t instanceof ShadowRoot?t=t.host:t=t.parentNode},j=new WeakSet,ne=new MutationObserver(t=>{for(let e of t)F(e.target)}),d=t=>{let e=I.get(t);if(e||(e={full:"",immediate:[]},!f(t)))return e;let r="";if(oe(t))e.full=t.value,e.immediate.push(t.value),t.addEventListener("input",o=>{F(o.target)},{once:!0,capture:!0});else{for(let o=t.firstChild;o;o=o.nextSibling){if(o.nodeType===Node.TEXT_NODE){e.full+=o.nodeValue??"",r+=o.nodeValue??"";continue}r&&e.immediate.push(r),r="",o.nodeType===Node.ELEMENT_NODE&&(e.full+=d(o).full)}r&&e.immediate.push(r),t instanceof Element&&t.shadowRoot&&(e.full+=d(t.shadowRoot).full),j.has(t)||(ne.observe(t,{childList:!0,characterData:!0,subtree:!0}),j.add(t))}return I.set(t,e),e};var m=function*(t,e){let r=!1;for(let o of t.childNodes)if(o instanceof Element&&f(o)){let s;o.shadowRoot?s=m(o.shadowRoot,e):s=m(o,e);for(let i of s)yield i,r=!0}r||t instanceof Element&&f(t)&&d(t).full.includes(e)&&(yield t)};var k={};l(k,{checkVisibility:()=>le,pierce:()=>S,pierceAll:()=>O});var ie=["hidden","collapse"],le=(t,e)=>{if(!t)return e===!1;if(e===void 0)return t;let r=t.nodeType===Node.TEXT_NODE?t.parentElement:t,o=window.getComputedStyle(r),s=o&&!ie.includes(o.visibility)&&!ae(r);return e===s?t:!1};function ae(t){let e=t.getBoundingClientRect();return e.width===0||e.height===0}var ce=t=>"shadowRoot"in t&&t.shadowRoot instanceof ShadowRoot;function*S(t){ce(t)?yield t.shadowRoot:yield t}function*O(t){t=S(t).next().value,yield t;let e=[document.createTreeWalker(t,NodeFilter.SHOW_ELEMENT)];for(let r of e){let o;for(;o=r.nextNode();)o.shadowRoot&&(yield o.shadowRoot,e.push(document.createTreeWalker(o.shadowRoot,NodeFilter.SHOW_ELEMENT)))}}var D={};l(D,{xpathQuerySelectorAll:()=>q});var q=function*(t,e,r=-1){let s=(t.ownerDocument||document).evaluate(e,t,null,XPathResult.ORDERED_NODE_ITERATOR_TYPE),i=[],n;for(;(n=s.iterateNext())&&(i.push(n),!(r&&i.length===r)););for(let h=0;h<i.length;h++)n=i[h],yield n,delete i[h]};var ue=/[-\\w\\P{ASCII}*]/u,H=(r=>(r.Descendent=">>>",r.Child=">>>>",r))(H||{}),V=t=>"querySelectorAll"in t,Q=class{#e;#r=[];#o=void 0;elements;constructor(e,r){this.elements=[e],this.#e=r,this.#t()}async run(){if(typeof this.#o=="string")switch(this.#o.trimStart()){case":scope":this.#t();break}for(;this.#o!==void 0;this.#t()){let e=this.#o;typeof e=="string"?e[0]&&ue.test(e[0])?this.elements=a.flatMap(this.elements,async function*(r){V(r)&&(yield*r.querySelectorAll(e))}):this.elements=a.flatMap(this.elements,async function*(r){if(!r.parentElement){if(!V(r))return;yield*r.querySelectorAll(e);return}let o=0;for(let s of r.parentElement.children)if(++o,s===r)break;yield*r.parentElement.querySelectorAll(`:scope>:nth-child(${o})${e}`)}):this.elements=a.flatMap(this.elements,async function*(r){switch(e.name){case"text":yield*m(r,e.value);break;case"xpath":yield*q(r,e.value);break;case"aria":yield*x(r,e.value);break;default:let o=P.get(e.name);if(!o)throw new Error(`Unknown selector type: ${e.name}`);yield*o.querySelectorAll(r,e.value)}})}}#t(){if(this.#r.length!==0){this.#o=this.#r.shift();return}if(this.#e.length===0){this.#o=void 0;return}let e=this.#e.shift();switch(e){case">>>>":{this.elements=a.flatMap(this.elements,S),this.#t();break}case">>>":{this.elements=a.flatMap(this.elements,O),this.#t();break}default:this.#r=e,this.#t();break}}},M=class{#e=new WeakMap;calculate(e,r=[]){if(e===null)return r;e instanceof ShadowRoot&&(e=e.host);let o=this.#e.get(e);if(o)return[...o,...r];let s=0;for(let n=e.previousSibling;n;n=n.previousSibling)++s;let i=this.calculate(e.parentNode,[s]);return this.#e.set(e,i),[...i,...r]}},U=(t,e)=>{if(t.length+e.length===0)return 0;let[r=-1,...o]=t,[s=-1,...i]=e;return r===s?U(o,i):r<s?-1:1},de=async function*(t){let e=new Set;for await(let o of t)e.add(o);let r=new M;yield*[...e.values()].map(o=>[o,r.calculate(o)]).sort(([,o],[,s])=>U(o,s)).map(([o])=>o)},$=function(t,e){let r=JSON.parse(e);if(r.some(o=>{let s=0;return o.some(i=>(typeof i=="string"?++s:s=0,s>1))}))throw new Error("Multiple deep combinators found in sequence.");return de(a.flatMap(r,o=>{let s=new Q(t,o);return s.run(),s.elements}))},fe=async function(t,e){for await(let r of $(t,e))return r;return null};var me=Object.freeze({...b,...A,...R,..._,...C,...k,...D,...E,Deferred:c,createFunction:W,createTextContent:d,IntervalPoller:T,isSuitableNodeForTextMatching:f,MutationPoller:y,RAFPoller:w}),he=me;\n';
/**
 * @license
 * Copyright 2024 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
var hu, Qu, pg, Gm, e1;
class q$ {
  constructor() {
    k(this, pg);
    k(this, hu, !1);
    k(this, Qu, /* @__PURE__ */ new Set());
  }
  // Appends a statement of the form `(PuppeteerUtil) => {...}`.
  append(A) {
    O(this, pg, Gm).call(this, () => {
      d(this, Qu).add(A);
    });
  }
  pop(A) {
    O(this, pg, Gm).call(this, () => {
      d(this, Qu).delete(A);
    });
  }
  inject(A, e = !1) {
    (d(this, hu) || e) && A(O(this, pg, e1).call(this)), x(this, hu, !1);
  }
}
hu = new WeakMap(), Qu = new WeakMap(), pg = new WeakSet(), Gm = function(A) {
  A(), x(this, hu, !0);
}, e1 = function() {
  return `(() => {
      const module = {};
      ${Y$}
      ${[...d(this, Qu)].map((A) => `(${A})(module.exports.default);`).join("")}
      return module.exports.default;
    })()`;
};
const WQ = new q$();
/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
var fi;
class j$ {
  constructor() {
    k(this, fi, /* @__PURE__ */ new Map());
  }
  get(A) {
    const e = d(this, fi).get(A);
    return e ? e[1] : void 0;
  }
  /**
   * Registers a {@link CustomQueryHandler | custom query handler}.
   *
   * @remarks
   * After registration, the handler can be used everywhere where a selector is
   * expected by prepending the selection string with `<name>/`. The name is
   * only allowed to consist of lower- and upper case latin letters.
   *
   * @example
   *
   * ```ts
   * Puppeteer.customQueryHandlers.register('lit', { â€¦ });
   * const aHandle = await page.$('lit/â€¦');
   * ```
   *
   * @param name - Name to register under.
   * @param queryHandler - {@link CustomQueryHandler | Custom query handler} to
   * register.
   */
  register(A, e) {
    var n;
    bA(!d(this, fi).has(A), `Cannot register over existing handler: ${A}`), bA(/^[a-zA-Z]+$/.test(A), "Custom query handler names may only contain [a-zA-Z]"), bA(e.queryAll || e.queryOne, "At least one query method must be implemented.");
    const r = (n = class extends Qs {
    }, R(n, "querySelectorAll", HC((s, a, g) => g.customQuerySelectors.get(PLACEHOLDER("name")).querySelectorAll(s, a), { name: JSON.stringify(A) })), R(n, "querySelector", HC((s, a, g) => g.customQuerySelectors.get(PLACEHOLDER("name")).querySelector(s, a), { name: JSON.stringify(A) })), n), i = HC((s) => {
      s.customQuerySelectors.register(PLACEHOLDER("name"), {
        queryAll: PLACEHOLDER("queryAll"),
        queryOne: PLACEHOLDER("queryOne")
      });
    }, {
      name: JSON.stringify(A),
      queryAll: e.queryAll ? Ra(e.queryAll) : String(void 0),
      queryOne: e.queryOne ? Ra(e.queryOne) : String(void 0)
    }).toString();
    d(this, fi).set(A, [i, r]), WQ.append(i);
  }
  /**
   * Unregisters the {@link CustomQueryHandler | custom query handler} for the
   * given name.
   *
   * @throws `Error` if there is no handler under the given name.
   */
  unregister(A) {
    const e = d(this, fi).get(A);
    if (!e)
      throw new Error(`Cannot unregister unknown handler: ${A}`);
    WQ.pop(e[0]), d(this, fi).delete(A);
  }
  /**
   * Gets the names of all {@link CustomQueryHandler | custom query handlers}.
   */
  names() {
    return [...d(this, fi).keys()];
  }
  /**
   * Unregisters all custom query handlers.
   */
  clear() {
    for (const [A] of d(this, fi))
      WQ.pop(A);
    d(this, fi).clear();
  }
}
fi = new WeakMap();
const Um = new j$();
/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
class Tm extends Qs {
}
R(Tm, "querySelector", (A, e, { pierceQuerySelector: r }) => r(A, e)), R(Tm, "querySelectorAll", (A, e, { pierceQuerySelectorAll: r }) => r(A, e));
/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
class Km extends Qs {
}
R(Km, "querySelectorAll", (A, e, { pQuerySelectorAll: r }) => r(A, e)), R(Km, "querySelector", (A, e, { pQuerySelector: r }) => r(A, e));
var $c = {
  attribute: /\[\s*(?:(?<namespace>\*|[-\w\P{ASCII}]*)\|)?(?<name>[-\w\P{ASCII}]+)\s*(?:(?<operator>\W?=)\s*(?<value>.+?)\s*(\s(?<caseSensitive>[iIsS]))?\s*)?\]/gu,
  id: /#(?<name>[-\w\P{ASCII}]+)/gu,
  class: /\.(?<name>[-\w\P{ASCII}]+)/gu,
  comma: /\s*,\s*/g,
  combinator: /\s*[\s>+~]\s*/g,
  "pseudo-element": /::(?<name>[-\w\P{ASCII}]+)(?:\((?<argument>Â¶*)\))?/gu,
  "pseudo-class": /:(?<name>[-\w\P{ASCII}]+)(?:\((?<argument>Â¶*)\))?/gu,
  universal: /(?:(?<namespace>\*|[-\w\P{ASCII}]*)\|)?\*/gu,
  type: /(?:(?<namespace>\*|[-\w\P{ASCII}]*)\|)?(?<name>[-\w\P{ASCII}]+)/gu
  // this must be last
}, W$ = /* @__PURE__ */ new Set(["combinator", "comma"]), V$ = (t) => {
  switch (t) {
    case "pseudo-element":
    case "pseudo-class":
      return new RegExp($c[t].source.replace("(?<argument>Â¶*)", "(?<argument>.*)"), "gu");
    default:
      return $c[t];
  }
};
function Z$(t, A) {
  let e = 0, r = "";
  for (; A < t.length; A++) {
    const i = t[A];
    switch (i) {
      case "(":
        ++e;
        break;
      case ")":
        --e;
        break;
    }
    if (r += i, e === 0)
      return r;
  }
  return r;
}
function X$(t, A = $c) {
  if (!t)
    return [];
  const e = [t];
  for (const [i, n] of Object.entries(A))
    for (let s = 0; s < e.length; s++) {
      const a = e[s];
      if (typeof a != "string")
        continue;
      n.lastIndex = 0;
      const g = n.exec(a);
      if (!g)
        continue;
      const o = g.index - 1, u = [], I = g[0], c = a.slice(0, o + 1);
      c && u.push(c), u.push({
        ...g.groups,
        type: i,
        content: I
      });
      const C = a.slice(o + I.length + 1);
      C && u.push(C), e.splice(s, 1, ...u);
    }
  let r = 0;
  for (const i of e)
    switch (typeof i) {
      case "string":
        throw new Error(`Unexpected sequence ${i} found at index ${r}`);
      case "object":
        r += i.content.length, i.pos = [r - i.content.length, r], W$.has(i.type) && (i.content = i.content.trim() || " ");
        break;
    }
  return e;
}
var z$ = /(['"])([^\\\n]*?)\1/g, $$ = /\\./g;
function A7(t, A = $c) {
  if (t = t.trim(), t === "")
    return [];
  const e = [];
  t = t.replace($$, (n, s) => (e.push({ value: n, offset: s }), "î€€".repeat(n.length))), t = t.replace(z$, (n, s, a, g) => (e.push({ value: n, offset: g }), `${s}${"î€".repeat(a.length)}${s}`));
  {
    let n = 0, s;
    for (; (s = t.indexOf("(", n)) > -1; ) {
      const a = Z$(t, s);
      e.push({ value: a, offset: s }), t = `${t.substring(0, s)}(${"Â¶".repeat(a.length - 2)})${t.substring(s + a.length)}`, n = s + a.length;
    }
  }
  const r = X$(t, A), i = /* @__PURE__ */ new Set();
  for (const n of e.reverse())
    for (const s of r) {
      const { offset: a, value: g } = n;
      if (!(s.pos[0] <= a && a + g.length <= s.pos[1]))
        continue;
      const { content: o } = s, u = a - s.pos[0];
      s.content = o.slice(0, u) + g + o.slice(u + g.length), s.content !== o && i.add(s);
    }
  for (const n of i) {
    const s = V$(n.type);
    if (!s)
      throw new Error(`Unknown token type: ${n.type}`);
    s.lastIndex = 0;
    const a = s.exec(n.content);
    if (!a)
      throw new Error(`Unable to parse content for ${n.type}: ${n.content}`);
    Object.assign(n, a.groups);
  }
  return r;
}
function gn(t) {
  if (Array.isArray(t))
    return t.map((A) => A.content).join("");
  switch (t.type) {
    case "list":
      return t.list.map(gn).join(",");
    case "relative":
      return t.combinator + gn(t.right);
    case "complex":
      return gn(t.left) + t.combinator + gn(t.right);
    case "compound":
      return t.list.map(gn).join("");
    default:
      return t.content;
  }
}
/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
$c.nesting = /&/g;
$c.combinator = /\s*(>>>>?|[\s>+~])\s*/g;
const e7 = /\\[\s\S]/g, t7 = (t) => t.length <= 1 ? t : ((t[0] === '"' || t[0] === "'") && t.endsWith(t[0]) && (t = t.slice(1, -1)), t.replace(e7, (A) => A[1]));
function r7(t) {
  let A = !0, e = !1, r = !1;
  const i = A7(t);
  if (i.length === 0)
    return [[], A, r, !1];
  let n = [], s = [n];
  const a = [s], g = [];
  for (const o of i) {
    switch (o.type) {
      case "combinator":
        switch (o.content) {
          case ">>>":
            A = !1, g.length && (n.push(gn(g)), g.splice(0)), n = [], s.push(
              ">>>"
              /* PCombinator.Descendent */
            ), s.push(n);
            continue;
          case ">>>>":
            A = !1, g.length && (n.push(gn(g)), g.splice(0)), n = [], s.push(
              ">>>>"
              /* PCombinator.Child */
            ), s.push(n);
            continue;
        }
        break;
      case "pseudo-element":
        if (!o.name.startsWith("-p-"))
          break;
        A = !1, g.length && (n.push(gn(g)), g.splice(0));
        const u = o.name.slice(3);
        u === "aria" && (e = !0), n.push({
          name: u,
          value: t7(o.argument ?? "")
        });
        continue;
      case "pseudo-class":
        r = !0;
        break;
      case "comma":
        g.length && (n.push(gn(g)), g.splice(0)), n = [], s = [n], a.push(s);
        continue;
    }
    g.push(o);
  }
  return g.length && n.push(gn(g)), [a, A, r, e];
}
/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
class t1 extends Qs {
}
R(t1, "querySelectorAll", (A, e, { textQuerySelectorAll: r }) => r(A, e));
/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
class Jm extends Qs {
}
R(Jm, "querySelectorAll", (A, e, { xpathQuerySelectorAll: r }) => r(A, e)), R(Jm, "querySelector", (A, e, { xpathQuerySelectorAll: r }) => {
  for (const i of r(A, e, 1))
    return i;
  return null;
});
/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
const i7 = {
  aria: ol,
  pierce: Tm,
  xpath: Jm,
  text: t1
}, n7 = ["=", "/"];
function VQ(t) {
  for (const A of [
    Um.names().map((e) => [e, Um.get(e)]),
    Object.entries(i7)
  ])
    for (const [e, r] of A)
      for (const i of n7) {
        const n = `${e}${i}`;
        if (t.startsWith(n))
          return t = t.slice(n.length), {
            updatedSelector: t,
            polling: e === "aria" ? "raf" : "mutation",
            QueryHandler: r
          };
      }
  try {
    const [A, e, r, i] = r7(t);
    return e ? {
      updatedSelector: t,
      polling: r ? "raf" : "mutation",
      QueryHandler: Wd
    } : {
      updatedSelector: JSON.stringify(A),
      polling: i ? "raf" : "mutation",
      QueryHandler: Km
    };
  } catch {
    return {
      updatedSelector: t,
      polling: "mutation",
      QueryHandler: Wd
    };
  }
}
/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
var s7 = function(t, A, e) {
  if (A != null) {
    if (typeof A != "object" && typeof A != "function") throw new TypeError("Object expected.");
    var r, i;
    if (e) {
      if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
      r = A[Symbol.asyncDispose];
    }
    if (r === void 0) {
      if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
      r = A[Symbol.dispose], e && (i = r);
    }
    if (typeof r != "function") throw new TypeError("Object not disposable.");
    i && (r = function() {
      try {
        i.call(this);
      } catch (n) {
        return Promise.reject(n);
      }
    }), t.stack.push({ value: A, dispose: r, async: e });
  } else e && t.stack.push({ async: !0 });
  return A;
}, a7 = /* @__PURE__ */ function(t) {
  return function(A) {
    function e(s) {
      A.error = A.hasError ? new t(s, A.error, "An error was suppressed during disposal.") : s, A.hasError = !0;
    }
    var r, i = 0;
    function n() {
      for (; r = A.stack.pop(); )
        try {
          if (!r.async && i === 1) return i = 0, A.stack.push(r), Promise.resolve().then(n);
          if (r.dispose) {
            var s = r.dispose.call(r.value);
            if (r.async) return i |= 2, Promise.resolve(s).then(n, function(a) {
              return e(a), n();
            });
          } else i |= 1;
        } catch (a) {
          e(a);
        }
      if (i === 1) return A.hasError ? Promise.reject(A.error) : Promise.resolve();
      if (A.hasError) throw A.error;
    }
    return n();
  };
}(typeof SuppressedError == "function" ? SuppressedError : function(t, A, e) {
  var r = new Error(e);
  return r.name = "SuppressedError", r.error = t, r.suppressed = A, r;
});
const fI = /* @__PURE__ */ new WeakSet();
function o7(t, A) {
  let e = !1;
  if (t.prototype[ke]) {
    const r = t.prototype[ke];
    t.prototype[ke] = function() {
      if (fI.has(this)) {
        fI.delete(this);
        return;
      }
      return r.call(this);
    }, e = !0;
  }
  if (t.prototype[sr]) {
    const r = t.prototype[sr];
    t.prototype[sr] = function() {
      if (fI.has(this)) {
        fI.delete(this);
        return;
      }
      return r.call(this);
    }, e = !0;
  }
  return e && (t.prototype.move = function() {
    return fI.add(this), this;
  }), t;
}
function Ie(t = (A) => `Attempted to use disposed ${A.constructor.name}.`) {
  return (A, e) => function(...r) {
    if (this.disposed)
      throw new Error(t(this));
    return A.call(this, ...r);
  };
}
function UsA(t, A) {
  return function(...e) {
    if (!this.disposed)
      return t.call(this, ...e);
  };
}
function ni(t, A) {
  const e = /* @__PURE__ */ new WeakMap();
  let r = -1;
  return function(...i) {
    if (r === -1 && (r = i.length), r !== i.length)
      throw new Error("Memoized method was called with the wrong number of arguments");
    let n = !1, s = e;
    for (const a of i)
      s.has(a) || (n = !0, s.set(a, /* @__PURE__ */ new WeakMap())), s = s.get(a);
    if (n)
      return t.call(this, ...i);
  };
}
function Hm(t = function() {
  return this;
}) {
  return (A, e) => {
    const r = /* @__PURE__ */ new WeakMap();
    return async function(...i) {
      const n = { stack: [], error: void 0, hasError: !1 };
      try {
        const s = t.call(this);
        let a = r.get(s);
        a || (a = new al(), r.set(s, a));
        const g = s7(n, await a.acquire(), !0);
        return await A.call(this, ...i);
      } catch (s) {
        n.error = s, n.hasError = !0;
      } finally {
        const s = a7(n);
        s && await s;
      }
    };
  };
}
const Vd = /* @__PURE__ */ new WeakMap(), eR = function(t) {
  const A = Vd.get(this) ?? /* @__PURE__ */ new Map();
  if (A.has(t))
    return;
  const e = t !== void 0 ? (r, i) => {
    t.includes(r) && this.emit(r, i);
  } : (r, i) => {
    this.emit(r, i);
  };
  A.set(t, e), Vd.set(this, A);
};
function TsA(t) {
  return ({ set: A, get: e }, r) => (r.addInitializer(function() {
    return eR.apply(this, [t]);
  }), {
    set(i) {
      const n = Vd.get(this).get(t), s = e.call(this);
      s !== void 0 && s.off("*", n), i !== void 0 && (i.on("*", n), A.call(this, i));
    },
    init(i) {
      if (i === void 0)
        return i;
      eR.apply(this, [t]);
      const n = Vd.get(this).get(t);
      return i.on("*", n), i;
    }
  });
}
/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
var tR = function(t, A, e) {
  for (var r = arguments.length > 2, i = 0; i < A.length; i++)
    e = r ? A[i].call(t, e) : A[i].call(t);
  return r ? e : void 0;
}, my = function(t, A, e, r, i, n) {
  function s(h) {
    if (h !== void 0 && typeof h != "function") throw new TypeError("Function expected");
    return h;
  }
  for (var a = r.kind, g = a === "getter" ? "get" : a === "setter" ? "set" : "value", o = !A && t ? r.static ? t : t.prototype : null, u = A || (o ? Object.getOwnPropertyDescriptor(o, r.name) : {}), I, c = !1, C = e.length - 1; C >= 0; C--) {
    var E = {};
    for (var l in r) E[l] = l === "access" ? {} : r[l];
    for (var l in r.access) E.access[l] = r.access[l];
    E.addInitializer = function(h) {
      if (c) throw new TypeError("Cannot add initializers after decoration has completed");
      n.push(s(h || null));
    };
    var B = (0, e[C])(a === "accessor" ? { get: u.get, set: u.set } : u[g], E);
    if (a === "accessor") {
      if (B === void 0) continue;
      if (B === null || typeof B != "object") throw new TypeError("Object expected");
      (I = s(B.get)) && (u.get = I), (I = s(B.set)) && (u.set = I), (I = s(B.init)) && i.unshift(I);
    } else (I = s(B)) && (a === "field" ? i.unshift(I) : u[g] = I);
  }
  o && Object.defineProperty(o, r.name, u), c = !0;
}, g7 = function(t, A, e) {
  if (A != null) {
    if (typeof A != "object" && typeof A != "function") throw new TypeError("Object expected.");
    var r, i;
    if (e) {
      if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
      r = A[Symbol.asyncDispose];
    }
    if (r === void 0) {
      if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
      r = A[Symbol.dispose], e && (i = r);
    }
    if (typeof r != "function") throw new TypeError("Object not disposable.");
    i && (r = function() {
      try {
        i.call(this);
      } catch (n) {
        return Promise.reject(n);
      }
    }), t.stack.push({ value: A, dispose: r, async: e });
  } else e && t.stack.push({ async: !0 });
  return A;
}, u7 = /* @__PURE__ */ function(t) {
  return function(A) {
    function e(s) {
      A.error = A.hasError ? new t(s, A.error, "An error was suppressed during disposal.") : s, A.hasError = !0;
    }
    var r, i = 0;
    function n() {
      for (; r = A.stack.pop(); )
        try {
          if (!r.async && i === 1) return i = 0, A.stack.push(r), Promise.resolve().then(n);
          if (r.dispose) {
            var s = r.dispose.call(r.value);
            if (r.async) return i |= 2, Promise.resolve(s).then(n, function(a) {
              return e(a), n();
            });
          } else i |= 1;
        } catch (a) {
          e(a);
        }
      if (i === 1) return A.hasError ? Promise.reject(A.error) : Promise.resolve();
      if (A.hasError) throw A.error;
    }
    return n();
  };
}(typeof SuppressedError == "function" ? SuppressedError : function(t, A, e) {
  var r = new Error(e);
  return r.name = "SuppressedError", r.error = t, r.suppressed = A, r;
});
let gu = (() => {
  var a;
  let t = [o7], A, e = [], r, i = [], n, s;
  return a = class {
    /**
     * @internal
     */
    constructor() {
      tR(this, i);
    }
    /**
     * Evaluates the given function with the current handle as its first argument.
     */
    async evaluate(o, ...u) {
      return o = bt(this.evaluate.name, o), await this.realm.evaluate(o, this, ...u);
    }
    /**
     * Evaluates the given function with the current handle as its first argument.
     *
     */
    async evaluateHandle(o, ...u) {
      return o = bt(this.evaluateHandle.name, o), await this.realm.evaluateHandle(o, this, ...u);
    }
    /**
     * @internal
     */
    async getProperty(o) {
      return await this.evaluateHandle((u, I) => u[I], o);
    }
    /**
     * Gets a map of handles representing the properties of the current handle.
     *
     * @example
     *
     * ```ts
     * const listHandle = await page.evaluateHandle(() => document.body.children);
     * const properties = await listHandle.getProperties();
     * const children = [];
     * for (const property of properties.values()) {
     *   const element = property.asElement();
     *   if (element) {
     *     children.push(element);
     *   }
     * }
     * children; // holds elementHandles to all children of document.body
     * ```
     */
    async getProperties() {
      const o = await this.evaluate((c) => {
        var l;
        const C = [], E = Object.getOwnPropertyDescriptors(c);
        for (const B in E)
          (l = E[B]) != null && l.enumerable && C.push(B);
        return C;
      }), u = /* @__PURE__ */ new Map(), I = await Promise.all(o.map((c) => this.getProperty(c)));
      for (const [c, C] of Object.entries(o)) {
        const E = { stack: [], error: void 0, hasError: !1 };
        try {
          const l = g7(E, I[c], !1);
          l && u.set(C, l.move());
        } catch (l) {
          E.error = l, E.hasError = !0;
        } finally {
          u7(E);
        }
      }
      return u;
    }
    /** @internal */
    [(n = [Ie()], s = [Ie()], ke)]() {
      return void this.dispose().catch(HA);
    }
    /** @internal */
    [sr]() {
      return this.dispose();
    }
  }, r = a, (() => {
    const o = typeof Symbol == "function" && Symbol.metadata ? /* @__PURE__ */ Object.create(null) : void 0;
    my(a, null, n, { kind: "method", name: "getProperty", static: !1, private: !1, access: { has: (u) => "getProperty" in u, get: (u) => u.getProperty }, metadata: o }, null, i), my(a, null, s, { kind: "method", name: "getProperties", static: !1, private: !1, access: { has: (u) => "getProperties" in u, get: (u) => u.getProperties }, metadata: o }, null, i), my(null, A = { value: r }, t, { kind: "class", name: r.name, metadata: o }, null, e), r = A.value, o && Object.defineProperty(r, Symbol.metadata, { enumerable: !0, configurable: !0, writable: !0, value: o }), tR(r, e);
  })(), r;
})();
var c7 = function(t, A, e) {
  if (A != null) {
    if (typeof A != "object" && typeof A != "function") throw new TypeError("Object expected.");
    var r, i;
    if (e) {
      if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
      r = A[Symbol.asyncDispose];
    }
    if (r === void 0) {
      if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
      r = A[Symbol.dispose], e && (i = r);
    }
    if (typeof r != "function") throw new TypeError("Object not disposable.");
    i && (r = function() {
      try {
        i.call(this);
      } catch (n) {
        return Promise.reject(n);
      }
    }), t.stack.push({ value: A, dispose: r, async: e });
  } else e && t.stack.push({ async: !0 });
  return A;
}, I7 = /* @__PURE__ */ function(t) {
  return function(A) {
    function e(s) {
      A.error = A.hasError ? new t(s, A.error, "An error was suppressed during disposal.") : s, A.hasError = !0;
    }
    var r, i = 0;
    function n() {
      for (; r = A.stack.pop(); )
        try {
          if (!r.async && i === 1) return i = 0, A.stack.push(r), Promise.resolve().then(n);
          if (r.dispose) {
            var s = r.dispose.call(r.value);
            if (r.async) return i |= 2, Promise.resolve(s).then(n, function(a) {
              return e(a), n();
            });
          } else i |= 1;
        } catch (a) {
          e(a);
        }
      if (i === 1) return A.hasError ? Promise.reject(A.error) : Promise.resolve();
      if (A.hasError) throw A.error;
    }
    return n();
  };
}(typeof SuppressedError == "function" ? SuppressedError : function(t, A, e) {
  var r = new Error(e);
  return r.name = "SuppressedError", r.error = t, r.suppressed = A, r;
}), tu;
(function(t) {
  t.Action = "action";
})(tu || (tu = {}));
var Bo, Eo, ho, Sl, Qo, fo, yn, r1, i1, n1, s1;
class cI extends je {
  constructor() {
    super(...arguments);
    k(this, yn);
    /**
     * @internal
     */
    R(this, "visibility", null);
    /**
     * @internal
     */
    R(this, "_timeout", 3e4);
    k(this, Bo, !0);
    k(this, Eo, !0);
    k(this, ho, !0);
    /**
     * @internal
     */
    R(this, "operators", {
      conditions: (e, r) => gt((i) => sl(...e.map((n) => n(i, r))).pipe(HU(i))),
      retryAndRaceWithSignalAndTimer: (e, r) => {
        const i = [];
        return e && i.push(eu(e, r)), i.push(Bn(this._timeout, r)), hz(YQ({ delay: ZQ }), ln(...i));
      }
    });
    /**
     * If the element has a "disabled" property, wait for the element to be
     * enabled.
     */
    k(this, Sl, (e, r) => d(this, Eo) ? de(e.frame.waitForFunction((i) => i instanceof HTMLElement ? ![
      "BUTTON",
      "INPUT",
      "SELECT",
      "TEXTAREA",
      "OPTION",
      "OPTGROUP"
    ].includes(i.nodeName) || !i.hasAttribute("disabled") : !0, {
      timeout: this._timeout,
      signal: r
    }, e)).pipe(OQ()) : Ig);
    /**
     * Compares the bounding box of the element for two consecutive animation
     * frames and waits till they are the same.
     */
    k(this, Qo, (e) => d(this, ho) ? ou(() => de(e.evaluate((r) => new Promise((i) => {
      window.requestAnimationFrame(() => {
        const n = r.getBoundingClientRect();
        window.requestAnimationFrame(() => {
          const s = r.getBoundingClientRect();
          i([
            {
              x: n.x,
              y: n.y,
              width: n.width,
              height: n.height
            },
            {
              x: s.x,
              y: s.y,
              width: s.width,
              height: s.height
            }
          ]);
        });
      });
    })))).pipe(qd(([r, i]) => r.x === i.x && r.y === i.y && r.width === i.width && r.height === i.height), YQ({ delay: ZQ }), OQ()) : Ig);
    /**
     * Checks if the element is in the viewport and auto-scrolls it if it is not.
     */
    k(this, fo, (e) => d(this, Bo) ? de(e.isIntersectingViewport({ threshold: 0 })).pipe(Fg((r) => !r), gt(() => de(e.scrollIntoView())), gt(() => ou(() => de(e.isIntersectingViewport({ threshold: 0 }))).pipe(qd(xi), YQ({ delay: ZQ }), OQ()))) : Ig);
  }
  /**
   * Creates a race between multiple locators trying to locate elements in
   * parallel but ensures that only a single element receives the action.
   *
   * @public
   */
  static race(e) {
    return Pm.create(e);
  }
  // Determines when the locator will timeout for actions.
  get timeout() {
    return this._timeout;
  }
  /**
   * Creates a new locator instance by cloning the current locator and setting
   * the total timeout for the locator actions.
   *
   * Pass `0` to disable timeout.
   *
   * @defaultValue `Page.getDefaultTimeout()`
   */
  setTimeout(e) {
    const r = this._clone();
    return r._timeout = e, r;
  }
  /**
   * Creates a new locator instance by cloning the current locator with the
   * visibility property changed to the specified value.
   */
  setVisibility(e) {
    const r = this._clone();
    return r.visibility = e, r;
  }
  /**
   * Creates a new locator instance by cloning the current locator and
   * specifying whether to wait for input elements to become enabled before the
   * action. Applicable to `click` and `fill` actions.
   *
   * @defaultValue `true`
   */
  setWaitForEnabled(e) {
    const r = this._clone();
    return x(r, Eo, e), r;
  }
  /**
   * Creates a new locator instance by cloning the current locator and
   * specifying whether the locator should scroll the element into viewport if
   * it is not in the viewport already.
   *
   * @defaultValue `true`
   */
  setEnsureElementIsInTheViewport(e) {
    const r = this._clone();
    return x(r, Bo, e), r;
  }
  /**
   * Creates a new locator instance by cloning the current locator and
   * specifying whether the locator has to wait for the element's bounding box
   * to be same between two consecutive animation frames.
   *
   * @defaultValue `true`
   */
  setWaitForStableBoundingBox(e) {
    const r = this._clone();
    return x(r, ho, e), r;
  }
  /**
   * @internal
   */
  copyOptions(e) {
    return this._timeout = e._timeout, this.visibility = e.visibility, x(this, Eo, d(e, Eo)), x(this, Bo, d(e, Bo)), x(this, ho, d(e, ho)), this;
  }
  /**
   * Clones the locator.
   */
  clone() {
    return this._clone();
  }
  /**
   * Waits for the locator to get a handle from the page.
   *
   * @public
   */
  async waitHandle(e) {
    const r = new Error("Locator.waitHandle");
    return await or(this._wait(e).pipe(this.operators.retryAndRaceWithSignalAndTimer(e == null ? void 0 : e.signal, r)));
  }
  /**
   * Waits for the locator to get the serialized value from the page.
   *
   * Note this requires the value to be JSON-serializable.
   *
   * @public
   */
  async wait(e) {
    const r = { stack: [], error: void 0, hasError: !1 };
    try {
      return await c7(r, await this.waitHandle(e), !1).jsonValue();
    } catch (i) {
      r.error = i, r.hasError = !0;
    } finally {
      I7(r);
    }
  }
  /**
   * Maps the locator using the provided mapper.
   *
   * @public
   */
  map(e) {
    return new zd(this._clone(), (r) => r.evaluateHandle(e));
  }
  /**
   * Creates an expectation that is evaluated against located values.
   *
   * If the expectations do not match, then the locator will retry.
   *
   * @public
   */
  filter(e) {
    return new Xd(this._clone(), async (r, i) => (await r.frame.waitForFunction(e, { signal: i, timeout: this._timeout }, r), !0));
  }
  /**
   * Creates an expectation that is evaluated against located handles.
   *
   * If the expectations do not match, then the locator will retry.
   *
   * @internal
   */
  filterHandle(e) {
    return new Xd(this._clone(), e);
  }
  /**
   * Maps the locator using the provided mapper.
   *
   * @internal
   */
  mapHandle(e) {
    return new zd(this._clone(), e);
  }
  /**
   * Clicks the located element.
   */
  click(e) {
    return or(O(this, yn, r1).call(this, e));
  }
  /**
   * Fills out the input identified by the locator using the provided value. The
   * type of the input is determined at runtime and the appropriate fill-out
   * method is chosen based on the type. `contenteditable`, select, textarea and
   * input elements are supported.
   */
  fill(e, r) {
    return or(O(this, yn, i1).call(this, e, r));
  }
  /**
   * Hovers over the located element.
   */
  hover(e) {
    return or(O(this, yn, n1).call(this, e));
  }
  /**
   * Scrolls the located element.
   */
  scroll(e) {
    return or(O(this, yn, s1).call(this, e));
  }
}
Bo = new WeakMap(), Eo = new WeakMap(), ho = new WeakMap(), Sl = new WeakMap(), Qo = new WeakMap(), fo = new WeakMap(), yn = new WeakSet(), r1 = function(e) {
  const r = e == null ? void 0 : e.signal, i = new Error("Locator.click");
  return this._wait(e).pipe(this.operators.conditions([
    d(this, fo),
    d(this, Qo),
    d(this, Sl)
  ], r), kC(() => this.emit(tu.Action, void 0)), gt((n) => de(n.click(e)).pipe(FC((s) => {
    throw n.dispose().catch(HA), s;
  }))), this.operators.retryAndRaceWithSignalAndTimer(r, i));
}, i1 = function(e, r) {
  const i = r == null ? void 0 : r.signal, n = new Error("Locator.fill");
  return this._wait(r).pipe(this.operators.conditions([
    d(this, fo),
    d(this, Qo),
    d(this, Sl)
  ], i), kC(() => this.emit(tu.Action, void 0)), gt((s) => de(s.evaluate((a) => a instanceof HTMLSelectElement ? "select" : a instanceof HTMLTextAreaElement ? "typeable-input" : a instanceof HTMLInputElement ? (/* @__PURE__ */ new Set([
    "textarea",
    "text",
    "url",
    "tel",
    "search",
    "password",
    "number",
    "email"
  ])).has(a.type) ? "typeable-input" : "other-input" : a.isContentEditable ? "contenteditable" : "unknown")).pipe(gt((a) => {
    switch (a) {
      case "select":
        return de(s.select(e).then(Xc));
      case "contenteditable":
      case "typeable-input":
        return de(s.evaluate((g, o) => {
          const u = g.isContentEditable ? g.innerText : g.value;
          if (o.length <= u.length || !o.startsWith(g.value))
            return g.isContentEditable ? g.innerText = "" : g.value = "", o;
          const I = g.isContentEditable ? g.innerText : g.value;
          return g.isContentEditable ? (g.innerText = "", g.innerText = I) : (g.value = "", g.value = I), o.substring(I.length);
        }, e)).pipe(gt((g) => de(s.type(g))));
      case "other-input":
        return de(s.focus()).pipe(gt(() => de(s.evaluate((g, o) => {
          g.value = o, g.dispatchEvent(new Event("input", { bubbles: !0 })), g.dispatchEvent(new Event("change", { bubbles: !0 }));
        }, e))));
      case "unknown":
        throw new Error("Element cannot be filled out.");
    }
  })).pipe(FC((a) => {
    throw s.dispose().catch(HA), a;
  }))), this.operators.retryAndRaceWithSignalAndTimer(i, n));
}, n1 = function(e) {
  const r = e == null ? void 0 : e.signal, i = new Error("Locator.hover");
  return this._wait(e).pipe(this.operators.conditions([
    d(this, fo),
    d(this, Qo)
  ], r), kC(() => this.emit(tu.Action, void 0)), gt((n) => de(n.hover()).pipe(FC((s) => {
    throw n.dispose().catch(HA), s;
  }))), this.operators.retryAndRaceWithSignalAndTimer(r, i));
}, s1 = function(e) {
  const r = e == null ? void 0 : e.signal, i = new Error("Locator.scroll");
  return this._wait(e).pipe(this.operators.conditions([
    d(this, fo),
    d(this, Qo)
  ], r), kC(() => this.emit(tu.Action, void 0)), gt((n) => de(n.evaluate((s, a, g) => {
    a !== void 0 && (s.scrollTop = a), g !== void 0 && (s.scrollLeft = g);
  }, e == null ? void 0 : e.scrollTop, e == null ? void 0 : e.scrollLeft)).pipe(FC((s) => {
    throw n.dispose().catch(HA), s;
  }))), this.operators.retryAndRaceWithSignalAndTimer(r, i));
};
var du, fu;
const hf = class hf extends cI {
  constructor(e, r) {
    super();
    k(this, du);
    k(this, fu);
    x(this, du, e), x(this, fu, r);
  }
  static create(e, r) {
    return new hf(e, r).setTimeout("getDefaultTimeout" in e ? e.getDefaultTimeout() : e.page().getDefaultTimeout());
  }
  _clone() {
    return new hf(d(this, du), d(this, fu));
  }
  _wait(e) {
    const r = e == null ? void 0 : e.signal;
    return ou(() => de(d(this, du).waitForFunction(d(this, fu), {
      timeout: this.timeout,
      signal: r
    }))).pipe(wp());
  }
};
du = new WeakMap(), fu = new WeakMap();
let Zd = hf;
var Zt;
class a1 extends cI {
  constructor(e) {
    super();
    k(this, Zt);
    x(this, Zt, e), this.copyOptions(d(this, Zt));
  }
  get delegate() {
    return d(this, Zt);
  }
  setTimeout(e) {
    const r = super.setTimeout(e);
    return x(r, Zt, d(this, Zt).setTimeout(e)), r;
  }
  setVisibility(e) {
    const r = super.setVisibility(e);
    return x(r, Zt, d(r, Zt).setVisibility(e)), r;
  }
  setWaitForEnabled(e) {
    const r = super.setWaitForEnabled(e);
    return x(r, Zt, d(this, Zt).setWaitForEnabled(e)), r;
  }
  setEnsureElementIsInTheViewport(e) {
    const r = super.setEnsureElementIsInTheViewport(e);
    return x(r, Zt, d(this, Zt).setEnsureElementIsInTheViewport(e)), r;
  }
  setWaitForStableBoundingBox(e) {
    const r = super.setWaitForStableBoundingBox(e);
    return x(r, Zt, d(this, Zt).setWaitForStableBoundingBox(e)), r;
  }
}
Zt = new WeakMap();
var pu;
const $S = class $S extends a1 {
  constructor(e, r) {
    super(e);
    k(this, pu);
    x(this, pu, r);
  }
  _clone() {
    return new $S(this.delegate.clone(), d(this, pu)).copyOptions(this);
  }
  _wait(e) {
    return this.delegate._wait(e).pipe(gt((r) => de(Promise.resolve(d(this, pu).call(this, r, e == null ? void 0 : e.signal))).pipe(Fg((i) => i), ht(() => r))), wp());
  }
};
pu = new WeakMap();
let Xd = $S;
var yu;
const AF = class AF extends a1 {
  constructor(e, r) {
    super(e);
    k(this, yu);
    x(this, yu, r);
  }
  _clone() {
    return new AF(this.delegate.clone(), d(this, yu)).copyOptions(this);
  }
  _wait(e) {
    return this.delegate._wait(e).pipe(gt((r) => de(Promise.resolve(d(this, yu).call(this, r, e == null ? void 0 : e.signal)))));
  }
};
yu = new WeakMap();
let zd = AF;
var wu, Ps, Qf;
const YC = class YC extends cI {
  constructor(e, r) {
    super();
    k(this, wu);
    k(this, Ps);
    /**
     * Waits for the element to become visible or hidden. visibility === 'visible'
     * means that the element has a computed style, the visibility property other
     * than 'hidden' or 'collapse' and non-empty bounding box. visibility ===
     * 'hidden' means the opposite of that.
     */
    k(this, Qf, (e) => this.visibility ? (() => {
      switch (this.visibility) {
        case "hidden":
          return ou(() => de(e.isHidden()));
        case "visible":
          return ou(() => de(e.isVisible()));
      }
    })().pipe(qd(xi), YQ({ delay: ZQ }), OQ()) : Ig);
    x(this, wu, e), x(this, Ps, r);
  }
  static create(e, r) {
    return new YC(e, r).setTimeout("getDefaultTimeout" in e ? e.getDefaultTimeout() : e.page().getDefaultTimeout());
  }
  static createFromHandle(e, r) {
    return new YC(e, r).setTimeout("getDefaultTimeout" in e ? e.getDefaultTimeout() : e.page().getDefaultTimeout());
  }
  _clone() {
    return new YC(
      d(this, wu),
      // @ts-expect-error TSC does cannot parse private overloads.
      d(this, Ps)
    ).copyOptions(this);
  }
  _wait(e) {
    const r = e == null ? void 0 : e.signal;
    return ou(() => typeof d(this, Ps) == "string" ? de(d(this, wu).waitForSelector(d(this, Ps), {
      visible: !1,
      timeout: this._timeout,
      signal: r
    })) : Rm(d(this, Ps))).pipe(Fg((i) => i !== null), wp(), this.operators.conditions([d(this, Qf)], r));
  }
};
wu = new WeakMap(), Ps = new WeakMap(), Qf = new WeakMap();
let gl = YC;
function C7(t) {
  for (const A of t)
    if (!(A instanceof cI))
      throw new Error("Unknown locator for race candidate");
  return t;
}
var mu;
const df = class df extends cI {
  constructor(e) {
    super();
    k(this, mu);
    x(this, mu, e);
  }
  static create(e) {
    const r = C7(e);
    return new df(r);
  }
  _clone() {
    return new df(d(this, mu).map((e) => e.clone())).copyOptions(this);
  }
  _wait(e) {
    return KU(...d(this, mu).map((r) => r._wait(e)));
  }
};
mu = new WeakMap();
let Pm = df;
const ZQ = 100;
/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
var l7 = function(t, A, e) {
  for (var r = arguments.length > 2, i = 0; i < A.length; i++)
    e = r ? A[i].call(t, e) : A[i].call(t);
  return r ? e : void 0;
}, me = function(t, A, e, r, i, n) {
  function s(h) {
    if (h !== void 0 && typeof h != "function") throw new TypeError("Function expected");
    return h;
  }
  for (var a = r.kind, g = a === "getter" ? "get" : a === "setter" ? "set" : "value", o = !A && t ? r.static ? t : t.prototype : null, u = A || (o ? Object.getOwnPropertyDescriptor(o, r.name) : {}), I, c = !1, C = e.length - 1; C >= 0; C--) {
    var E = {};
    for (var l in r) E[l] = l === "access" ? {} : r[l];
    for (var l in r.access) E.access[l] = r.access[l];
    E.addInitializer = function(h) {
      if (c) throw new TypeError("Cannot add initializers after decoration has completed");
      n.push(s(h || null));
    };
    var B = (0, e[C])(a === "accessor" ? { get: u.get, set: u.set } : u[g], E);
    if (a === "accessor") {
      if (B === void 0) continue;
      if (B === null || typeof B != "object") throw new TypeError("Object expected");
      (I = s(B.get)) && (u.get = I), (I = s(B.set)) && (u.set = I), (I = s(B.init)) && i.unshift(I);
    } else (I = s(B)) && (a === "field" ? i.unshift(I) : u[g] = I);
  }
  o && Object.defineProperty(o, r.name, u), c = !0;
}, pI = function(t, A, e) {
  if (A != null) {
    if (typeof A != "object" && typeof A != "function") throw new TypeError("Object expected.");
    var r, i;
    if (e) {
      if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
      r = A[Symbol.asyncDispose];
    }
    if (r === void 0) {
      if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
      r = A[Symbol.dispose], e && (i = r);
    }
    if (typeof r != "function") throw new TypeError("Object not disposable.");
    i && (r = function() {
      try {
        i.call(this);
      } catch (n) {
        return Promise.reject(n);
      }
    }), t.stack.push({ value: A, dispose: r, async: e });
  } else e && t.stack.push({ async: !0 });
  return A;
}, yI = /* @__PURE__ */ function(t) {
  return function(A) {
    function e(s) {
      A.error = A.hasError ? new t(s, A.error, "An error was suppressed during disposal.") : s, A.hasError = !0;
    }
    var r, i = 0;
    function n() {
      for (; r = A.stack.pop(); )
        try {
          if (!r.async && i === 1) return i = 0, A.stack.push(r), Promise.resolve().then(n);
          if (r.dispose) {
            var s = r.dispose.call(r.value);
            if (r.async) return i |= 2, Promise.resolve(s).then(n, function(a) {
              return e(a), n();
            });
          } else i |= 1;
        } catch (a) {
          e(a);
        }
      if (i === 1) return A.hasError ? Promise.reject(A.error) : Promise.resolve();
      if (A.hasError) throw A.error;
    }
    return n();
  };
}(typeof SuppressedError == "function" ? SuppressedError : function(t, A, e) {
  var r = new Error(e);
  return r.name = "SuppressedError", r.error = t, r.suppressed = A, r;
}), B7 = function(t, A, e) {
  return typeof A == "symbol" && (A = A.description ? "[".concat(A.description, "]") : ""), Object.defineProperty(t, "name", { configurable: !0, value: e ? "".concat(e, " ", A) : A });
};
function De(t, A) {
  return async function(...e) {
    if (this.realm === this.frame.isolatedRealm())
      return await t.call(this, ...e);
    let r;
    this.isolatedHandle ? r = this.isolatedHandle : this.isolatedHandle = r = await this.frame.isolatedRealm().adoptHandle(this);
    const i = await t.call(r, ...e);
    return i === r ? this : i instanceof gu ? await this.realm.transferHandle(i) : (Array.isArray(i) && await Promise.all(i.map(async (n, s, a) => {
      n instanceof gu && (a[s] = await this.realm.transferHandle(n));
    })), i instanceof Map && await Promise.all([...i.entries()].map(async ([n, s]) => {
      s instanceof gu && i.set(n, await this.realm.transferHandle(s));
    })), i);
  };
}
let E7 = (() => {
  var rA, Om, Ym, qm, o1, jm, Wm, g1, u1, c1, P;
  let t = gu, A = [], e, r, i, n, s, a, g, o, u, I, c, C, E, l, B, h, Q, f, p, y, m, S, w, F, b, G, T, K, H, j, eA, sA, uA;
  return P = class extends t {
    /**
     * @internal
     */
    constructor(Y) {
      super();
      k(this, rA);
      /**
       * @internal
       * Cached isolatedHandle to prevent
       * trying to adopt it multiple times
       */
      R(this, "isolatedHandle", l7(this, A));
      /**
       * @internal
       */
      R(this, "handle");
      this.handle = Y, this[qQ] = !0;
    }
    /**
     * @internal
     */
    get id() {
      return this.handle.id;
    }
    /**
     * @internal
     */
    get disposed() {
      return this.handle.disposed;
    }
    /**
     * @internal
     */
    async getProperty(Y) {
      return await this.handle.getProperty(Y);
    }
    /**
     * @internal
     */
    async getProperties() {
      return await this.handle.getProperties();
    }
    /**
     * @internal
     */
    async evaluate(Y, ...L) {
      return Y = bt(this.evaluate.name, Y), await this.handle.evaluate(Y, ...L);
    }
    /**
     * @internal
     */
    async evaluateHandle(Y, ...L) {
      return Y = bt(this.evaluateHandle.name, Y), await this.handle.evaluateHandle(Y, ...L);
    }
    /**
     * @internal
     */
    async jsonValue() {
      return await this.handle.jsonValue();
    }
    /**
     * @internal
     */
    toString() {
      return this.handle.toString();
    }
    /**
     * @internal
     */
    remoteObject() {
      return this.handle.remoteObject();
    }
    /**
     * @internal
     */
    async dispose() {
      var Y;
      await Promise.all([this.handle.dispose(), (Y = this.isolatedHandle) == null ? void 0 : Y.dispose()]);
    }
    /**
     * @internal
     */
    asElement() {
      return this;
    }
    /**
     * Queries the current element for an element matching the given selector.
     *
     * @param selector -
     * {@link https://pptr.dev/guides/page-interactions#selectors | selector}
     * to query the page for.
     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | CSS selectors}
     * can be passed as-is and a
     * {@link https://pptr.dev/guides/page-interactions#non-css-selectors | Puppeteer-specific selector syntax}
     * allows querying by
     * {@link https://pptr.dev/guides/page-interactions#text-selectors--p-text | text},
     * {@link https://pptr.dev/guides/page-interactions#aria-selectors--p-aria | a11y role and name},
     * and
     * {@link https://pptr.dev/guides/page-interactions#xpath-selectors--p-xpath | xpath}
     * and
     * {@link https://pptr.dev/guides/page-interactions#querying-elements-in-shadow-dom | combining these queries across shadow roots}.
     * Alternatively, you can specify the selector type using a
     * {@link https://pptr.dev/guides/page-interactions#prefixed-selector-syntax | prefix}.
     * @returns A {@link ElementHandle | element handle} to the first element
     * matching the given selector. Otherwise, `null`.
     */
    async $(Y) {
      const { updatedSelector: L, QueryHandler: V } = VQ(Y);
      return await V.queryOne(this, L);
    }
    /**
     * Queries the current element for all elements matching the given selector.
     *
     * @param selector -
     * {@link https://pptr.dev/guides/page-interactions#selectors | selector}
     * to query the page for.
     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | CSS selectors}
     * can be passed as-is and a
     * {@link https://pptr.dev/guides/page-interactions#non-css-selectors | Puppeteer-specific selector syntax}
     * allows querying by
     * {@link https://pptr.dev/guides/page-interactions#text-selectors--p-text | text},
     * {@link https://pptr.dev/guides/page-interactions#aria-selectors--p-aria | a11y role and name},
     * and
     * {@link https://pptr.dev/guides/page-interactions#xpath-selectors--p-xpath | xpath}
     * and
     * {@link https://pptr.dev/guides/page-interactions#querying-elements-in-shadow-dom | combining these queries across shadow roots}.
     * Alternatively, you can specify the selector type using a
     * {@link https://pptr.dev/guides/page-interactions#prefixed-selector-syntax | prefix}.
     * @returns An array of {@link ElementHandle | element handles} that point to
     * elements matching the given selector.
     */
    async $$(Y, L) {
      return (L == null ? void 0 : L.isolate) === !1 ? await O(this, rA, Ym).call(this, Y) : await d(this, rA, Om).call(this, Y);
    }
    /**
     * Runs the given function on the first element matching the given selector in
     * the current element.
     *
     * If the given function returns a promise, then this method will wait till
     * the promise resolves.
     *
     * @example
     *
     * ```ts
     * const tweetHandle = await page.$('.tweet');
     * expect(await tweetHandle.$eval('.like', node => node.innerText)).toBe(
     *   '100',
     * );
     * expect(await tweetHandle.$eval('.retweets', node => node.innerText)).toBe(
     *   '10',
     * );
     * ```
     *
     * @param selector -
     * {@link https://pptr.dev/guides/page-interactions#selectors | selector}
     * to query the page for.
     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | CSS selectors}
     * can be passed as-is and a
     * {@link https://pptr.dev/guides/page-interactions#non-css-selectors | Puppeteer-specific selector syntax}
     * allows querying by
     * {@link https://pptr.dev/guides/page-interactions#text-selectors--p-text | text},
     * {@link https://pptr.dev/guides/page-interactions#aria-selectors--p-aria | a11y role and name},
     * and
     * {@link https://pptr.dev/guides/page-interactions#xpath-selectors--p-xpath | xpath}
     * and
     * {@link https://pptr.dev/guides/page-interactions#querying-elements-in-shadow-dom | combining these queries across shadow roots}.
     * Alternatively, you can specify the selector type using a
     * {@link https://pptr.dev/guides/page-interactions#prefixed-selector-syntax | prefix}.
     * @param pageFunction - The function to be evaluated in this element's page's
     * context. The first element matching the selector will be passed in as the
     * first argument.
     * @param args - Additional arguments to pass to `pageFunction`.
     * @returns A promise to the result of the function.
     */
    async $eval(Y, L, ...V) {
      const Z = { stack: [], error: void 0, hasError: !1 };
      try {
        L = bt(this.$eval.name, L);
        const cA = pI(Z, await this.$(Y), !1);
        if (!cA)
          throw new Error(`Error: failed to find element matching selector "${Y}"`);
        return await cA.evaluate(L, ...V);
      } catch (cA) {
        Z.error = cA, Z.hasError = !0;
      } finally {
        yI(Z);
      }
    }
    /**
     * Runs the given function on an array of elements matching the given selector
     * in the current element.
     *
     * If the given function returns a promise, then this method will wait till
     * the promise resolves.
     *
     * @example
     * HTML:
     *
     * ```html
     * <div class="feed">
     *   <div class="tweet">Hello!</div>
     *   <div class="tweet">Hi!</div>
     * </div>
     * ```
     *
     * JavaScript:
     *
     * ```ts
     * const feedHandle = await page.$('.feed');
     *
     * const listOfTweets = await feedHandle.$$eval('.tweet', nodes =>
     *   nodes.map(n => n.innerText),
     * );
     * ```
     *
     * @param selector -
     * {@link https://pptr.dev/guides/page-interactions#selectors | selector}
     * to query the page for.
     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | CSS selectors}
     * can be passed as-is and a
     * {@link https://pptr.dev/guides/page-interactions#non-css-selectors | Puppeteer-specific selector syntax}
     * allows querying by
     * {@link https://pptr.dev/guides/page-interactions#text-selectors--p-text | text},
     * {@link https://pptr.dev/guides/page-interactions#aria-selectors--p-aria | a11y role and name},
     * and
     * {@link https://pptr.dev/guides/page-interactions#xpath-selectors--p-xpath | xpath}
     * and
     * {@link https://pptr.dev/guides/page-interactions#querying-elements-in-shadow-dom | combining these queries across shadow roots}.
     * Alternatively, you can specify the selector type using a
     * {@link https://pptr.dev/guides/page-interactions#prefixed-selector-syntax | prefix}.
     * @param pageFunction - The function to be evaluated in the element's page's
     * context. An array of elements matching the given selector will be passed to
     * the function as its first argument.
     * @param args - Additional arguments to pass to `pageFunction`.
     * @returns A promise to the result of the function.
     */
    async $$eval(Y, L, ...V) {
      const Z = { stack: [], error: void 0, hasError: !1 };
      try {
        L = bt(this.$$eval.name, L);
        const cA = await this.$$(Y), X = pI(Z, await this.evaluateHandle((SA, ...aA) => aA, ...cA), !1), [z] = await Promise.all([
          X.evaluate(L, ...V),
          ...cA.map((SA) => SA.dispose())
        ]);
        return z;
      } catch (cA) {
        Z.error = cA, Z.hasError = !0;
      } finally {
        yI(Z);
      }
    }
    /**
     * Wait for an element matching the given selector to appear in the current
     * element.
     *
     * Unlike {@link Frame.waitForSelector}, this method does not work across
     * navigations or if the element is detached from DOM.
     *
     * @example
     *
     * ```ts
     * import puppeteer from 'puppeteer';
     *
     * const browser = await puppeteer.launch();
     * const page = await browser.newPage();
     * let currentURL;
     * page
     *   .mainFrame()
     *   .waitForSelector('img')
     *   .then(() => console.log('First URL with image: ' + currentURL));
     *
     * for (currentURL of [
     *   'https://example.com',
     *   'https://google.com',
     *   'https://bbc.com',
     * ]) {
     *   await page.goto(currentURL);
     * }
     * await browser.close();
     * ```
     *
     * @param selector - The selector to query and wait for.
     * @param options - Options for customizing waiting behavior.
     * @returns An element matching the given selector.
     * @throws Throws if an element matching the given selector doesn't appear.
     */
    async waitForSelector(Y, L = {}) {
      const { updatedSelector: V, QueryHandler: Z, polling: cA } = VQ(Y);
      return await Z.waitFor(this, V, {
        polling: cA,
        ...L
      });
    }
    /**
     * An element is considered to be visible if all of the following is
     * true:
     *
     * - the element has
     *   {@link https://developer.mozilla.org/en-US/docs/Web/API/Window/getComputedStyle | computed styles}.
     *
     * - the element has a non-empty
     *   {@link https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect | bounding client rect}.
     *
     * - the element's {@link https://developer.mozilla.org/en-US/docs/Web/CSS/visibility | visibility}
     *   is not `hidden` or `collapse`.
     */
    async isVisible() {
      return await O(this, rA, qm).call(this, !0);
    }
    /**
     * An element is considered to be hidden if at least one of the following is true:
     *
     * - the element has no
     *   {@link https://developer.mozilla.org/en-US/docs/Web/API/Window/getComputedStyle | computed styles}.
     *
     * - the element has an empty
     *   {@link https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect | bounding client rect}.
     *
     * - the element's {@link https://developer.mozilla.org/en-US/docs/Web/CSS/visibility | visibility}
     *   is `hidden` or `collapse`.
     */
    async isHidden() {
      return await O(this, rA, qm).call(this, !1);
    }
    /**
     * Converts the current handle to the given element type.
     *
     * @example
     *
     * ```ts
     * const element: ElementHandle<Element> = await page.$(
     *   '.class-name-of-anchor',
     * );
     * // DO NOT DISPOSE `element`, this will be always be the same handle.
     * const anchor: ElementHandle<HTMLAnchorElement> =
     *   await element.toElement('a');
     * ```
     *
     * @param tagName - The tag name of the desired element type.
     * @throws An error if the handle does not match. **The handle will not be
     * automatically disposed.**
     */
    async toElement(Y) {
      if (!await this.evaluate((V, Z) => V.nodeName === Z.toUpperCase(), Y))
        throw new Error(`Element is not a(n) \`${Y}\` element`);
      return this;
    }
    /**
     * Returns the middle point within an element unless a specific offset is provided.
     */
    async clickablePoint(Y) {
      const L = await O(this, rA, o1).call(this);
      if (!L)
        throw new Error("Node is either not clickable or not an Element");
      return Y !== void 0 ? {
        x: L.x + Y.x,
        y: L.y + Y.y
      } : {
        x: L.x + L.width / 2,
        y: L.y + L.height / 2
      };
    }
    /**
     * This method scrolls element into view if needed, and then
     * uses {@link Page.mouse} to hover over the center of the element.
     * If the element is detached from DOM, the method throws an error.
     */
    async hover() {
      await this.scrollIntoViewIfNeeded();
      const { x: Y, y: L } = await this.clickablePoint();
      await this.frame.page().mouse.move(Y, L);
    }
    /**
     * This method scrolls element into view if needed, and then
     * uses {@link Page.mouse} to click in the center of the element.
     * If the element is detached from DOM, the method throws an error.
     */
    async click(Y = {}) {
      await this.scrollIntoViewIfNeeded();
      const { x: L, y: V } = await this.clickablePoint(Y.offset);
      try {
        await this.frame.page().mouse.click(L, V, Y);
      } finally {
        Y.debugHighlight && await this.frame.page().evaluate((Z, cA) => {
          const X = document.createElement("div");
          X.innerHTML = `<style>
        @scope {
          :scope {
              position: fixed;
              left: ${Z}px;
              top: ${cA}px;
              width: 10px;
              height: 10px;
              border-radius: 50%;
              animation: colorChange 10s 1 normal;
              animation-fill-mode: forwards;
          }

          @keyframes colorChange {
              from {
                  background-color: red;
              }
              to {
                  background-color: #FADADD00;
              }
          }
        }
      </style>`, X.addEventListener("animationend", () => {
            X.remove();
          }, { once: !0 }), document.body.append(X);
        }, L, V);
      }
    }
    /**
     * Drags an element over the given element or point.
     *
     * @returns DEPRECATED. When drag interception is enabled, the drag payload is
     * returned.
     */
    async drag(Y) {
      await this.scrollIntoViewIfNeeded();
      const L = this.frame.page();
      if (L.isDragInterceptionEnabled()) {
        const V = await this.clickablePoint();
        return Y instanceof P && (Y = await Y.clickablePoint()), await L.mouse.drag(V, Y);
      }
      try {
        L._isDragging || (L._isDragging = !0, await this.hover(), await L.mouse.down()), Y instanceof P ? await Y.hover() : await L.mouse.move(Y.x, Y.y);
      } catch (V) {
        throw L._isDragging = !1, V;
      }
    }
    /**
     * @deprecated Do not use. `dragenter` will automatically be performed during dragging.
     */
    async dragEnter(Y = { items: [], dragOperationsMask: 1 }) {
      const L = this.frame.page();
      await this.scrollIntoViewIfNeeded();
      const V = await this.clickablePoint();
      await L.mouse.dragEnter(V, Y);
    }
    /**
     * @deprecated Do not use. `dragover` will automatically be performed during dragging.
     */
    async dragOver(Y = { items: [], dragOperationsMask: 1 }) {
      const L = this.frame.page();
      await this.scrollIntoViewIfNeeded();
      const V = await this.clickablePoint();
      await L.mouse.dragOver(V, Y);
    }
    /**
     * @internal
     */
    async drop(Y = {
      items: [],
      dragOperationsMask: 1
    }) {
      const L = this.frame.page();
      if ("items" in Y) {
        await this.scrollIntoViewIfNeeded();
        const V = await this.clickablePoint();
        await L.mouse.drop(V, Y);
      } else
        await Y.drag(this), L._isDragging = !1, await L.mouse.up();
    }
    /**
     * @deprecated Use `ElementHandle.drop` instead.
     */
    async dragAndDrop(Y, L) {
      const V = this.frame.page();
      bA(V.isDragInterceptionEnabled(), "Drag Interception is not enabled!"), await this.scrollIntoViewIfNeeded();
      const Z = await this.clickablePoint(), cA = await Y.clickablePoint();
      await V.mouse.dragAndDrop(Z, cA, L);
    }
    /**
     * Triggers a `change` and `input` event once all the provided options have been
     * selected. If there's no `<select>` element matching `selector`, the method
     * throws an error.
     *
     * @example
     *
     * ```ts
     * handle.select('blue'); // single selection
     * handle.select('red', 'green', 'blue'); // multiple selections
     * ```
     *
     * @param values - Values of options to select. If the `<select>` has the
     * `multiple` attribute, all values are considered, otherwise only the first
     * one is taken into account.
     */
    async select(...Y) {
      for (const L of Y)
        bA(kg(L), 'Values must be strings. Found value "' + L + '" of type "' + typeof L + '"');
      return await this.evaluate((L, V) => {
        const Z = new Set(V);
        if (!(L instanceof HTMLSelectElement))
          throw new Error("Element is not a <select> element.");
        const cA = /* @__PURE__ */ new Set();
        if (L.multiple)
          for (const X of L.options)
            X.selected = Z.has(X.value), X.selected && cA.add(X.value);
        else {
          for (const X of L.options)
            X.selected = !1;
          for (const X of L.options)
            if (Z.has(X.value)) {
              X.selected = !0, cA.add(X.value);
              break;
            }
        }
        return L.dispatchEvent(new Event("input", { bubbles: !0 })), L.dispatchEvent(new Event("change", { bubbles: !0 })), [...cA.values()];
      }, Y);
    }
    /**
     * This method scrolls element into view if needed, and then uses
     * {@link Touchscreen.tap} to tap in the center of the element.
     * If the element is detached from DOM, the method throws an error.
     */
    async tap() {
      await this.scrollIntoViewIfNeeded();
      const { x: Y, y: L } = await this.clickablePoint();
      await this.frame.page().touchscreen.tap(Y, L);
    }
    /**
     * This method scrolls the element into view if needed, and then
     * starts a touch in the center of the element.
     * @returns A {@link TouchHandle} representing the touch that was started
     */
    async touchStart() {
      await this.scrollIntoViewIfNeeded();
      const { x: Y, y: L } = await this.clickablePoint();
      return await this.frame.page().touchscreen.touchStart(Y, L);
    }
    /**
     * This method scrolls the element into view if needed, and then
     * moves the touch to the center of the element.
     * @param touch - An optional {@link TouchHandle}. If provided, this touch
     * will be moved. If not provided, the first active touch will be moved.
     */
    async touchMove(Y) {
      await this.scrollIntoViewIfNeeded();
      const { x: L, y: V } = await this.clickablePoint();
      if (Y)
        return await Y.move(L, V);
      await this.frame.page().touchscreen.touchMove(L, V);
    }
    async touchEnd() {
      await this.scrollIntoViewIfNeeded(), await this.frame.page().touchscreen.touchEnd();
    }
    /**
     * Calls {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/focus | focus} on the element.
     */
    async focus() {
      await this.evaluate((Y) => {
        if (!(Y instanceof HTMLElement))
          throw new Error("Cannot focus non-HTMLElement");
        return Y.focus();
      });
    }
    /**
     * Focuses the element, and then sends a `keydown`, `keypress`/`input`, and
     * `keyup` event for each character in the text.
     *
     * To press a special key, like `Control` or `ArrowDown`,
     * use {@link ElementHandle.press}.
     *
     * @example
     *
     * ```ts
     * await elementHandle.type('Hello'); // Types instantly
     * await elementHandle.type('World', {delay: 100}); // Types slower, like a user
     * ```
     *
     * @example
     * An example of typing into a text field and then submitting the form:
     *
     * ```ts
     * const elementHandle = await page.$('input');
     * await elementHandle.type('some text');
     * await elementHandle.press('Enter');
     * ```
     *
     * @param options - Delay in milliseconds. Defaults to 0.
     */
    async type(Y, L) {
      await this.focus(), await this.frame.page().keyboard.type(Y, L);
    }
    /**
     * Focuses the element, and then uses {@link Keyboard.down} and {@link Keyboard.up}.
     *
     * @remarks
     * If `key` is a single character and no modifier keys besides `Shift`
     * are being held down, a `keypress`/`input` event will also be generated.
     * The `text` option can be specified to force an input event to be generated.
     *
     * **NOTE** Modifier keys DO affect `elementHandle.press`. Holding down `Shift`
     * will type the text in upper case.
     *
     * @param key - Name of key to press, such as `ArrowLeft`.
     * See {@link KeyInput} for a list of all key names.
     */
    async press(Y, L) {
      await this.focus(), await this.frame.page().keyboard.press(Y, L);
    }
    /**
     * This method returns the bounding box of the element (relative to the main frame),
     * or `null` if the element is {@link https://drafts.csswg.org/css-display-4/#box-generation | not part of the layout}
     * (example: `display: none`).
     */
    async boundingBox() {
      const Y = await this.evaluate((V) => {
        if (!(V instanceof Element) || V.getClientRects().length === 0)
          return null;
        const Z = V.getBoundingClientRect();
        return { x: Z.x, y: Z.y, width: Z.width, height: Z.height };
      });
      if (!Y)
        return null;
      const L = await O(this, rA, Wm).call(this);
      return L ? {
        x: Y.x + L.x,
        y: Y.y + L.y,
        height: Y.height,
        width: Y.width
      } : null;
    }
    /**
     * This method returns boxes of the element,
     * or `null` if the element is {@link https://drafts.csswg.org/css-display-4/#box-generation | not part of the layout}
     * (example: `display: none`).
     *
     * @remarks
     *
     * Boxes are represented as an array of points;
     * Each Point is an object `{x, y}`. Box points are sorted clock-wise.
     */
    async boxModel() {
      const Y = await this.evaluate((V) => {
        if (!(V instanceof Element) || V.getClientRects().length === 0)
          return null;
        const Z = V.getBoundingClientRect(), cA = window.getComputedStyle(V), X = {
          padding: {
            left: parseInt(cA.paddingLeft, 10),
            top: parseInt(cA.paddingTop, 10),
            right: parseInt(cA.paddingRight, 10),
            bottom: parseInt(cA.paddingBottom, 10)
          },
          margin: {
            left: -parseInt(cA.marginLeft, 10),
            top: -parseInt(cA.marginTop, 10),
            right: -parseInt(cA.marginRight, 10),
            bottom: -parseInt(cA.marginBottom, 10)
          },
          border: {
            left: parseInt(cA.borderLeft, 10),
            top: parseInt(cA.borderTop, 10),
            right: parseInt(cA.borderRight, 10),
            bottom: parseInt(cA.borderBottom, 10)
          }
        }, z = [
          { x: Z.left, y: Z.top },
          { x: Z.left + Z.width, y: Z.top },
          { x: Z.left + Z.width, y: Z.top + Z.height },
          { x: Z.left, y: Z.top + Z.height }
        ], SA = vA(z, X.border), aA = vA(SA, X.padding), Ae = vA(z, X.margin);
        return {
          content: aA,
          padding: SA,
          border: z,
          margin: Ae,
          width: Z.width,
          height: Z.height
        };
        function vA(RA, MA) {
          return [
            {
              x: RA[0].x + MA.left,
              y: RA[0].y + MA.top
            },
            {
              x: RA[1].x - MA.right,
              y: RA[1].y + MA.top
            },
            {
              x: RA[2].x - MA.right,
              y: RA[2].y - MA.bottom
            },
            {
              x: RA[3].x + MA.left,
              y: RA[3].y - MA.bottom
            }
          ];
        }
      });
      if (!Y)
        return null;
      const L = await O(this, rA, Wm).call(this);
      if (!L)
        return null;
      for (const V of [
        "content",
        "padding",
        "border",
        "margin"
      ])
        for (const Z of Y[V])
          Z.x += L.x, Z.y += L.y;
      return Y;
    }
    async screenshot(Y = {}) {
      const { scrollIntoView: L = !0, clip: V } = Y, Z = this.frame.page();
      L && await this.scrollIntoViewIfNeeded();
      const cA = await O(this, rA, g1).call(this), [X, z] = await this.evaluate(() => {
        if (!window.visualViewport)
          throw new Error("window.visualViewport is not supported.");
        return [
          window.visualViewport.pageLeft,
          window.visualViewport.pageTop
        ];
      });
      return cA.x += X, cA.y += z, V && (cA.x += V.x, cA.y += V.y, cA.height = V.height, cA.width = V.width), await Z.screenshot({ ...Y, clip: cA });
    }
    /**
     * @internal
     */
    async assertConnectedElement() {
      const Y = await this.evaluate(async (L) => {
        if (!L.isConnected)
          return "Node is detached from document";
        if (L.nodeType !== Node.ELEMENT_NODE)
          return "Node is not of type HTMLElement";
      });
      if (Y)
        throw new Error(Y);
    }
    /**
     * @internal
     */
    async scrollIntoViewIfNeeded() {
      await this.isIntersectingViewport({
        threshold: 1
      }) || await this.scrollIntoView();
    }
    /**
     * Resolves to true if the element is visible in the current viewport. If an
     * element is an SVG, we check if the svg owner element is in the viewport
     * instead. See https://crbug.com/963246.
     *
     * @param options - Threshold for the intersection between 0 (no intersection) and 1
     * (full intersection). Defaults to 1.
     */
    async isIntersectingViewport(Y = {}) {
      var V;
      const L = { stack: [], error: void 0, hasError: !1 };
      try {
        await this.assertConnectedElement();
        const Z = await O(this, rA, u1).call(this);
        return await (pI(L, Z && await O(V = Z, rA, c1).call(V), !1) ?? this).evaluate(async (X, z) => {
          const SA = await new Promise((aA) => {
            const Ae = new IntersectionObserver((vA) => {
              aA(vA[0].intersectionRatio), Ae.disconnect();
            });
            Ae.observe(X);
          });
          return z === 1 ? SA === 1 : SA > z;
        }, Y.threshold ?? 0);
      } catch (Z) {
        L.error = Z, L.hasError = !0;
      } finally {
        yI(L);
      }
    }
    /**
     * Scrolls the element into view using either the automation protocol client
     * or by calling element.scrollIntoView.
     */
    async scrollIntoView() {
      await this.assertConnectedElement(), await this.evaluate(async (Y) => {
        Y.scrollIntoView({
          block: "center",
          inline: "center",
          behavior: "instant"
        });
      });
    }
    /**
     * Creates a locator based on an ElementHandle. This would not allow
     * refreshing the element handle if it is stale but it allows re-using other
     * locator pre-conditions.
     */
    asLocator() {
      return gl.createFromHandle(this.frame, this);
    }
  }, rA = new WeakSet(), Om = function() {
    return g.value;
  }, Ym = async function(Y) {
    const { updatedSelector: L, QueryHandler: V } = VQ(Y);
    return await Dp.collect(V.queryAll(this, L));
  }, qm = async function(Y) {
    return await this.evaluate(async (L, V, Z) => !!V.checkVisibility(L, Z), vi.create((L) => L.puppeteerUtil), Y);
  }, o1 = async function() {
    var cA;
    const Y = await this.evaluate((X) => X instanceof Element ? [...X.getClientRects()].map((z) => ({ x: z.x, y: z.y, width: z.width, height: z.height })) : null);
    if (!(Y != null && Y.length))
      return null;
    await O(this, rA, jm).call(this, Y);
    let L = this.frame, V;
    for (; V = L == null ? void 0 : L.parentFrame(); ) {
      const X = { stack: [], error: void 0, hasError: !1 };
      try {
        const z = pI(X, await L.frameElement(), !1);
        if (!z)
          throw new Error("Unsupported frame type");
        const SA = await z.evaluate((aA) => {
          if (aA.getClientRects().length === 0)
            return null;
          const Ae = aA.getBoundingClientRect(), vA = window.getComputedStyle(aA);
          return {
            left: Ae.left + parseInt(vA.paddingLeft, 10) + parseInt(vA.borderLeftWidth, 10),
            top: Ae.top + parseInt(vA.paddingTop, 10) + parseInt(vA.borderTopWidth, 10)
          };
        });
        if (!SA)
          return null;
        for (const aA of Y)
          aA.x += SA.left, aA.y += SA.top;
        await O(cA = z, rA, jm).call(cA, Y), L = V;
      } catch (z) {
        X.error = z, X.hasError = !0;
      } finally {
        yI(X);
      }
    }
    const Z = Y.find((X) => X.width >= 1 && X.height >= 1);
    return Z ? {
      x: Z.x,
      y: Z.y,
      height: Z.height,
      width: Z.width
    } : null;
  }, jm = async function(Y) {
    const { documentWidth: L, documentHeight: V } = await this.frame.isolatedRealm().evaluate(() => ({
      documentWidth: document.documentElement.clientWidth,
      documentHeight: document.documentElement.clientHeight
    }));
    for (const Z of Y)
      h7(Z, L, V);
  }, Wm = async function() {
    const Y = { x: 0, y: 0 };
    let L = this.frame, V;
    for (; V = L == null ? void 0 : L.parentFrame(); ) {
      const Z = { stack: [], error: void 0, hasError: !1 };
      try {
        const cA = pI(Z, await L.frameElement(), !1);
        if (!cA)
          throw new Error("Unsupported frame type");
        const X = await cA.evaluate((z) => {
          if (z.getClientRects().length === 0)
            return null;
          const SA = z.getBoundingClientRect(), aA = window.getComputedStyle(z);
          return {
            left: SA.left + parseInt(aA.paddingLeft, 10) + parseInt(aA.borderLeftWidth, 10),
            top: SA.top + parseInt(aA.paddingTop, 10) + parseInt(aA.borderTopWidth, 10)
          };
        });
        if (!X)
          return null;
        Y.x += X.left, Y.y += X.top, L = V;
      } catch (cA) {
        Z.error = cA, Z.hasError = !0;
      } finally {
        yI(Z);
      }
    }
    return Y;
  }, g1 = async function() {
    const Y = await this.boundingBox();
    return bA(Y, "Node is either not visible or not an HTMLElement"), bA(Y.width !== 0, "Node has 0 width."), bA(Y.height !== 0, "Node has 0 height."), Y;
  }, u1 = async function() {
    return await this.evaluate((Y) => Y instanceof SVGElement) ? this : null;
  }, c1 = async function() {
    return await this.evaluateHandle((Y) => Y instanceof SVGSVGElement ? Y : Y.ownerSVGElement);
  }, (() => {
    const Y = typeof Symbol == "function" && Symbol.metadata ? Object.create(t[Symbol.metadata] ?? null) : void 0;
    e = [Ie(), De], r = [Ie(), De], i = [Ie(), De], n = [Ie(), De], s = [Ie()], a = [De], o = [Ie(), De], u = [Ie(), De], I = [Ie(), De], c = [Ie(), De], C = [Ie(), De], E = [Ie(), De], l = [Ie(), De], B = [Ie(), De], h = [Ie(), De], Q = [Ie(), De], f = [Ie(), De], p = [Ie(), De], y = [Ie(), De], m = [Ie(), De], S = [Ie(), De], w = [Ie(), De], F = [Ie(), De], b = [Ie(), De], G = [Ie(), De], T = [Ie(), De], K = [Ie(), De], H = [Ie(), De], j = [Ie(), De], eA = [Ie(), De], sA = [Ie(), De], uA = [Ie()], me(P, null, e, { kind: "method", name: "getProperty", static: !1, private: !1, access: { has: (L) => "getProperty" in L, get: (L) => L.getProperty }, metadata: Y }, null, A), me(P, null, r, { kind: "method", name: "getProperties", static: !1, private: !1, access: { has: (L) => "getProperties" in L, get: (L) => L.getProperties }, metadata: Y }, null, A), me(P, null, i, { kind: "method", name: "jsonValue", static: !1, private: !1, access: { has: (L) => "jsonValue" in L, get: (L) => L.jsonValue }, metadata: Y }, null, A), me(P, null, n, { kind: "method", name: "$", static: !1, private: !1, access: { has: (L) => "$" in L, get: (L) => L.$ }, metadata: Y }, null, A), me(P, null, s, { kind: "method", name: "$$", static: !1, private: !1, access: { has: (L) => "$$" in L, get: (L) => L.$$ }, metadata: Y }, null, A), me(P, g = { value: B7(async function(L) {
      return await O(this, rA, Ym).call(this, L);
    }, "#$$") }, a, { kind: "method", name: "#$$", static: !1, private: !0, access: { has: (L) => Cr(rA, L), get: (L) => d(L, rA, Om) }, metadata: Y }, null, A), me(P, null, o, { kind: "method", name: "waitForSelector", static: !1, private: !1, access: { has: (L) => "waitForSelector" in L, get: (L) => L.waitForSelector }, metadata: Y }, null, A), me(P, null, u, { kind: "method", name: "isVisible", static: !1, private: !1, access: { has: (L) => "isVisible" in L, get: (L) => L.isVisible }, metadata: Y }, null, A), me(P, null, I, { kind: "method", name: "isHidden", static: !1, private: !1, access: { has: (L) => "isHidden" in L, get: (L) => L.isHidden }, metadata: Y }, null, A), me(P, null, c, { kind: "method", name: "toElement", static: !1, private: !1, access: { has: (L) => "toElement" in L, get: (L) => L.toElement }, metadata: Y }, null, A), me(P, null, C, { kind: "method", name: "clickablePoint", static: !1, private: !1, access: { has: (L) => "clickablePoint" in L, get: (L) => L.clickablePoint }, metadata: Y }, null, A), me(P, null, E, { kind: "method", name: "hover", static: !1, private: !1, access: { has: (L) => "hover" in L, get: (L) => L.hover }, metadata: Y }, null, A), me(P, null, l, { kind: "method", name: "click", static: !1, private: !1, access: { has: (L) => "click" in L, get: (L) => L.click }, metadata: Y }, null, A), me(P, null, B, { kind: "method", name: "drag", static: !1, private: !1, access: { has: (L) => "drag" in L, get: (L) => L.drag }, metadata: Y }, null, A), me(P, null, h, { kind: "method", name: "dragEnter", static: !1, private: !1, access: { has: (L) => "dragEnter" in L, get: (L) => L.dragEnter }, metadata: Y }, null, A), me(P, null, Q, { kind: "method", name: "dragOver", static: !1, private: !1, access: { has: (L) => "dragOver" in L, get: (L) => L.dragOver }, metadata: Y }, null, A), me(P, null, f, { kind: "method", name: "drop", static: !1, private: !1, access: { has: (L) => "drop" in L, get: (L) => L.drop }, metadata: Y }, null, A), me(P, null, p, { kind: "method", name: "dragAndDrop", static: !1, private: !1, access: { has: (L) => "dragAndDrop" in L, get: (L) => L.dragAndDrop }, metadata: Y }, null, A), me(P, null, y, { kind: "method", name: "select", static: !1, private: !1, access: { has: (L) => "select" in L, get: (L) => L.select }, metadata: Y }, null, A), me(P, null, m, { kind: "method", name: "tap", static: !1, private: !1, access: { has: (L) => "tap" in L, get: (L) => L.tap }, metadata: Y }, null, A), me(P, null, S, { kind: "method", name: "touchStart", static: !1, private: !1, access: { has: (L) => "touchStart" in L, get: (L) => L.touchStart }, metadata: Y }, null, A), me(P, null, w, { kind: "method", name: "touchMove", static: !1, private: !1, access: { has: (L) => "touchMove" in L, get: (L) => L.touchMove }, metadata: Y }, null, A), me(P, null, F, { kind: "method", name: "touchEnd", static: !1, private: !1, access: { has: (L) => "touchEnd" in L, get: (L) => L.touchEnd }, metadata: Y }, null, A), me(P, null, b, { kind: "method", name: "focus", static: !1, private: !1, access: { has: (L) => "focus" in L, get: (L) => L.focus }, metadata: Y }, null, A), me(P, null, G, { kind: "method", name: "type", static: !1, private: !1, access: { has: (L) => "type" in L, get: (L) => L.type }, metadata: Y }, null, A), me(P, null, T, { kind: "method", name: "press", static: !1, private: !1, access: { has: (L) => "press" in L, get: (L) => L.press }, metadata: Y }, null, A), me(P, null, K, { kind: "method", name: "boundingBox", static: !1, private: !1, access: { has: (L) => "boundingBox" in L, get: (L) => L.boundingBox }, metadata: Y }, null, A), me(P, null, H, { kind: "method", name: "boxModel", static: !1, private: !1, access: { has: (L) => "boxModel" in L, get: (L) => L.boxModel }, metadata: Y }, null, A), me(P, null, j, { kind: "method", name: "screenshot", static: !1, private: !1, access: { has: (L) => "screenshot" in L, get: (L) => L.screenshot }, metadata: Y }, null, A), me(P, null, eA, { kind: "method", name: "isIntersectingViewport", static: !1, private: !1, access: { has: (L) => "isIntersectingViewport" in L, get: (L) => L.isIntersectingViewport }, metadata: Y }, null, A), me(P, null, sA, { kind: "method", name: "scrollIntoView", static: !1, private: !1, access: { has: (L) => "scrollIntoView" in L, get: (L) => L.scrollIntoView }, metadata: Y }, null, A), me(P, null, uA, { kind: "method", name: "asLocator", static: !1, private: !1, access: { has: (L) => "asLocator" in L, get: (L) => L.asLocator }, metadata: Y }, null, A), Y && Object.defineProperty(P, Symbol.metadata, { enumerable: !0, configurable: !0, writable: !0, value: Y });
  })(), P;
})();
function h7(t, A, e) {
  t.width = Math.max(t.x >= 0 ? Math.min(A - t.x, t.width) : Math.min(A, t.width + t.x), 0), t.height = Math.max(t.y >= 0 ? Math.min(e - t.y, t.height) : Math.min(e, t.height + t.y), 0), t.x = Math.max(t.x, 0), t.y = Math.max(t.y, 0);
}
/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
var Q7 = function(t, A, e) {
  for (var r = arguments.length > 2, i = 0; i < A.length; i++)
    e = r ? A[i].call(t, e) : A[i].call(t);
  return r ? e : void 0;
}, st = function(t, A, e, r, i, n) {
  function s(h) {
    if (h !== void 0 && typeof h != "function") throw new TypeError("Function expected");
    return h;
  }
  for (var a = r.kind, g = a === "getter" ? "get" : a === "setter" ? "set" : "value", o = !A && t ? r.static ? t : t.prototype : null, u = A || (o ? Object.getOwnPropertyDescriptor(o, r.name) : {}), I, c = !1, C = e.length - 1; C >= 0; C--) {
    var E = {};
    for (var l in r) E[l] = l === "access" ? {} : r[l];
    for (var l in r.access) E.access[l] = r.access[l];
    E.addInitializer = function(h) {
      if (c) throw new TypeError("Cannot add initializers after decoration has completed");
      n.push(s(h || null));
    };
    var B = (0, e[C])(a === "accessor" ? { get: u.get, set: u.set } : u[g], E);
    if (a === "accessor") {
      if (B === void 0) continue;
      if (B === null || typeof B != "object") throw new TypeError("Object expected");
      (I = s(B.get)) && (u.get = I), (I = s(B.set)) && (u.set = I), (I = s(B.init)) && i.unshift(I);
    } else (I = s(B)) && (a === "field" ? i.unshift(I) : u[g] = I);
  }
  o && Object.defineProperty(o, r.name, u), c = !0;
}, Rs = function(t, A, e) {
  if (A != null) {
    if (typeof A != "object" && typeof A != "function") throw new TypeError("Object expected.");
    var r, i;
    if (e) {
      if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
      r = A[Symbol.asyncDispose];
    }
    if (r === void 0) {
      if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
      r = A[Symbol.dispose], e && (i = r);
    }
    if (typeof r != "function") throw new TypeError("Object not disposable.");
    i && (r = function() {
      try {
        i.call(this);
      } catch (n) {
        return Promise.reject(n);
      }
    }), t.stack.push({ value: A, dispose: r, async: e });
  } else e && t.stack.push({ async: !0 });
  return A;
}, bs = /* @__PURE__ */ function(t) {
  return function(A) {
    function e(s) {
      A.error = A.hasError ? new t(s, A.error, "An error was suppressed during disposal.") : s, A.hasError = !0;
    }
    var r, i = 0;
    function n() {
      for (; r = A.stack.pop(); )
        try {
          if (!r.async && i === 1) return i = 0, A.stack.push(r), Promise.resolve().then(n);
          if (r.dispose) {
            var s = r.dispose.call(r.value);
            if (r.async) return i |= 2, Promise.resolve(s).then(n, function(a) {
              return e(a), n();
            });
          } else i |= 1;
        } catch (a) {
          e(a);
        }
      if (i === 1) return A.hasError ? Promise.reject(A.error) : Promise.resolve();
      if (A.hasError) throw A.error;
    }
    return n();
  };
}(typeof SuppressedError == "function" ? SuppressedError : function(t, A, e) {
  var r = new Error(e);
  return r.name = "SuppressedError", r.error = t, r.suppressed = A, r;
}), Pt;
(function(t) {
  t.FrameNavigated = Symbol("Frame.FrameNavigated"), t.FrameSwapped = Symbol("Frame.FrameSwapped"), t.LifecycleEvent = Symbol("Frame.LifecycleEvent"), t.FrameNavigatedWithinDocument = Symbol("Frame.FrameNavigatedWithinDocument"), t.FrameDetached = Symbol("Frame.FrameDetached"), t.FrameSwappedByActivation = Symbol("Frame.FrameSwappedByActivation");
})(Pt || (Pt = {}));
const Te = Ie((t) => `Attempted to use detached Frame '${t._id}'.`);
let d7 = (() => {
  var m, S, vC, F;
  let t = je, A = [], e, r, i, n, s, a, g, o, u, I, c, C, E, l, B, h, Q, f, p, y;
  return F = class extends t {
    /**
     * @internal
     */
    constructor() {
      super();
      k(this, S);
      /**
       * @internal
       */
      R(this, "_id", Q7(this, A));
      /**
       * @internal
       */
      R(this, "_parentId");
      /**
       * @internal
       */
      R(this, "_name");
      /**
       * @internal
       */
      R(this, "_hasStartedLoading", !1);
      k(this, m);
    }
    /**
     * Used to clear the document handle that has been destroyed.
     *
     * @internal
     */
    clearDocumentHandle() {
      x(this, m, void 0);
    }
    /**
     * @returns The frame element associated with this frame (if any).
     */
    async frameElement() {
      const T = { stack: [], error: void 0, hasError: !1 };
      try {
        const K = this.parentFrame();
        if (!K)
          return null;
        const H = Rs(T, await K.isolatedRealm().evaluateHandle(() => document.querySelectorAll("iframe,frame")), !1);
        for await (const j of A1(H)) {
          const eA = { stack: [], error: void 0, hasError: !1 };
          try {
            const sA = Rs(eA, j, !1), uA = await sA.contentFrame();
            if ((uA == null ? void 0 : uA._id) === this._id)
              return await K.mainRealm().adoptHandle(sA);
          } catch (sA) {
            eA.error = sA, eA.hasError = !0;
          } finally {
            bs(eA);
          }
        }
        return null;
      } catch (K) {
        T.error = K, T.hasError = !0;
      } finally {
        bs(T);
      }
    }
    /**
     * Behaves identically to {@link Page.evaluateHandle} except it's run within
     * the context of this frame.
     *
     * See {@link Page.evaluateHandle} for details.
     */
    async evaluateHandle(T, ...K) {
      return T = bt(this.evaluateHandle.name, T), await this.mainRealm().evaluateHandle(T, ...K);
    }
    /**
     * Behaves identically to {@link Page.evaluate} except it's run within
     * the context of this frame.
     *
     * See {@link Page.evaluate} for details.
     */
    async evaluate(T, ...K) {
      return T = bt(this.evaluate.name, T), await this.mainRealm().evaluate(T, ...K);
    }
    /**
     * @internal
     */
    locator(T) {
      return typeof T == "string" ? gl.create(this, T) : Zd.create(this, T);
    }
    /**
     * Queries the frame for an element matching the given selector.
     *
     * @param selector -
     * {@link https://pptr.dev/guides/page-interactions#selectors | selector}
     * to query the page for.
     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | CSS selectors}
     * can be passed as-is and a
     * {@link https://pptr.dev/guides/page-interactions#non-css-selectors | Puppeteer-specific selector syntax}
     * allows querying by
     * {@link https://pptr.dev/guides/page-interactions#text-selectors--p-text | text},
     * {@link https://pptr.dev/guides/page-interactions#aria-selectors--p-aria | a11y role and name},
     * and
     * {@link https://pptr.dev/guides/page-interactions#xpath-selectors--p-xpath | xpath}
     * and
     * {@link https://pptr.dev/guides/page-interactions#querying-elements-in-shadow-dom | combining these queries across shadow roots}.
     * Alternatively, you can specify the selector type using a
     * {@link https://pptr.dev/guides/page-interactions#prefixed-selector-syntax | prefix}.
     *
     * @returns A {@link ElementHandle | element handle} to the first element
     * matching the given selector. Otherwise, `null`.
     */
    async $(T) {
      return await (await O(this, S, vC).call(this)).$(T);
    }
    /**
     * Queries the frame for all elements matching the given selector.
     *
     * @param selector -
     * {@link https://pptr.dev/guides/page-interactions#selectors | selector}
     * to query the page for.
     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | CSS selectors}
     * can be passed as-is and a
     * {@link https://pptr.dev/guides/page-interactions#non-css-selectors | Puppeteer-specific selector syntax}
     * allows querying by
     * {@link https://pptr.dev/guides/page-interactions#text-selectors--p-text | text},
     * {@link https://pptr.dev/guides/page-interactions#aria-selectors--p-aria | a11y role and name},
     * and
     * {@link https://pptr.dev/guides/page-interactions#xpath-selectors--p-xpath | xpath}
     * and
     * {@link https://pptr.dev/guides/page-interactions#querying-elements-in-shadow-dom | combining these queries across shadow roots}.
     * Alternatively, you can specify the selector type using a
     * {@link https://pptr.dev/guides/page-interactions#prefixed-selector-syntax | prefix}.
     *
     * @returns An array of {@link ElementHandle | element handles} that point to
     * elements matching the given selector.
     */
    async $$(T, K) {
      return await (await O(this, S, vC).call(this)).$$(T, K);
    }
    /**
     * Runs the given function on the first element matching the given selector in
     * the frame.
     *
     * If the given function returns a promise, then this method will wait till
     * the promise resolves.
     *
     * @example
     *
     * ```ts
     * const searchValue = await frame.$eval('#search', el => el.value);
     * ```
     *
     * @param selector -
     * {@link https://pptr.dev/guides/page-interactions#selectors | selector}
     * to query the page for.
     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | CSS selectors}
     * can be passed as-is and a
     * {@link https://pptr.dev/guides/page-interactions#non-css-selectors | Puppeteer-specific selector syntax}
     * allows querying by
     * {@link https://pptr.dev/guides/page-interactions#text-selectors--p-text | text},
     * {@link https://pptr.dev/guides/page-interactions#aria-selectors--p-aria | a11y role and name},
     * and
     * {@link https://pptr.dev/guides/page-interactions#xpath-selectors--p-xpath | xpath}
     * and
     * {@link https://pptr.dev/guides/page-interactions#querying-elements-in-shadow-dom | combining these queries across shadow roots}.
     * Alternatively, you can specify the selector type using a
     * {@link https://pptr.dev/guides/page-interactions#prefixed-selector-syntax | prefix}.
     * @param pageFunction - The function to be evaluated in the frame's context.
     * The first element matching the selector will be passed to the function as
     * its first argument.
     * @param args - Additional arguments to pass to `pageFunction`.
     * @returns A promise to the result of the function.
     */
    async $eval(T, K, ...H) {
      return K = bt(this.$eval.name, K), await (await O(this, S, vC).call(this)).$eval(T, K, ...H);
    }
    /**
     * Runs the given function on an array of elements matching the given selector
     * in the frame.
     *
     * If the given function returns a promise, then this method will wait till
     * the promise resolves.
     *
     * @example
     *
     * ```ts
     * const divsCounts = await frame.$$eval('div', divs => divs.length);
     * ```
     *
     * @param selector -
     * {@link https://pptr.dev/guides/page-interactions#selectors | selector}
     * to query the page for.
     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | CSS selectors}
     * can be passed as-is and a
     * {@link https://pptr.dev/guides/page-interactions#non-css-selectors | Puppeteer-specific selector syntax}
     * allows querying by
     * {@link https://pptr.dev/guides/page-interactions#text-selectors--p-text | text},
     * {@link https://pptr.dev/guides/page-interactions#aria-selectors--p-aria | a11y role and name},
     * and
     * {@link https://pptr.dev/guides/page-interactions#xpath-selectors--p-xpath | xpath}
     * and
     * {@link https://pptr.dev/guides/page-interactions#querying-elements-in-shadow-dom | combining these queries across shadow roots}.
     * Alternatively, you can specify the selector type using a
     * {@link https://pptr.dev/guides/page-interactions#prefixed-selector-syntax | prefix}.
     * @param pageFunction - The function to be evaluated in the frame's context.
     * An array of elements matching the given selector will be passed to the
     * function as its first argument.
     * @param args - Additional arguments to pass to `pageFunction`.
     * @returns A promise to the result of the function.
     */
    async $$eval(T, K, ...H) {
      return K = bt(this.$$eval.name, K), await (await O(this, S, vC).call(this)).$$eval(T, K, ...H);
    }
    /**
     * Waits for an element matching the given selector to appear in the frame.
     *
     * This method works across navigations.
     *
     * @example
     *
     * ```ts
     * import puppeteer from 'puppeteer';
     *
     * const browser = await puppeteer.launch();
     * const page = await browser.newPage();
     * let currentURL;
     * page
     *   .mainFrame()
     *   .waitForSelector('img')
     *   .then(() => console.log('First URL with image: ' + currentURL));
     *
     * for (currentURL of [
     *   'https://example.com',
     *   'https://google.com',
     *   'https://bbc.com',
     * ]) {
     *   await page.goto(currentURL);
     * }
     * await browser.close();
     * ```
     *
     * @param selector - The selector to query and wait for.
     * @param options - Options for customizing waiting behavior.
     * @returns An element matching the given selector.
     * @throws Throws if an element matching the given selector doesn't appear.
     */
    async waitForSelector(T, K = {}) {
      const { updatedSelector: H, QueryHandler: j, polling: eA } = VQ(T);
      return await j.waitFor(this, H, {
        polling: eA,
        ...K
      });
    }
    /**
     * @example
     * The `waitForFunction` can be used to observe viewport size change:
     *
     * ```ts
     * import puppeteer from 'puppeteer';
     *
     * const browser = await puppeteer.launch();
     * const page = await browser.newPage();
     * const watchDog = page
     *   .mainFrame()
     *   .waitForFunction('window.innerWidth < 100');
     * page.setViewport({width: 50, height: 50});
     * await watchDog;
     * await browser.close();
     * ```
     *
     * To pass arguments from Node.js to the predicate of `page.waitForFunction` function:
     *
     * ```ts
     * const selector = '.foo';
     * await frame.waitForFunction(
     *   selector => !!document.querySelector(selector),
     *   {}, // empty options object
     *   selector,
     * );
     * ```
     *
     * @param pageFunction - the function to evaluate in the frame context.
     * @param options - options to configure the polling method and timeout.
     * @param args - arguments to pass to the `pageFunction`.
     * @returns the promise which resolve when the `pageFunction` returns a truthy value.
     */
    async waitForFunction(T, K = {}, ...H) {
      return await this.mainRealm().waitForFunction(T, K, ...H);
    }
    /**
     * The full HTML contents of the frame, including the DOCTYPE.
     */
    async content() {
      return await this.evaluate(() => {
        let T = "";
        for (const K of document.childNodes)
          switch (K) {
            case document.documentElement:
              T += document.documentElement.outerHTML;
              break;
            default:
              T += new XMLSerializer().serializeToString(K);
              break;
          }
        return T;
      });
    }
    /**
     * @internal
     */
    async setFrameContent(T) {
      return await this.evaluate((K) => {
        document.open(), document.write(K), document.close();
      }, T);
    }
    /**
     * The frame's `name` attribute as specified in the tag.
     *
     * @remarks
     * If the name is empty, it returns the `id` attribute instead.
     *
     * @remarks
     * This value is calculated once when the frame is created, and will not
     * update if the attribute is changed later.
     *
     * @deprecated Use
     *
     * ```ts
     * const element = await frame.frameElement();
     * const nameOrId = await element.evaluate(frame => frame.name ?? frame.id);
     * ```
     */
    name() {
      return this._name || "";
    }
    /**
     * Is`true` if the frame has been detached. Otherwise, `false`.
     *
     * @deprecated Use the `detached` getter.
     */
    isDetached() {
      return this.detached;
    }
    /**
     * @internal
     */
    get disposed() {
      return this.detached;
    }
    /**
     * Adds a `<script>` tag into the page with the desired url or content.
     *
     * @param options - Options for the script.
     * @returns An {@link ElementHandle | element handle} to the injected
     * `<script>` element.
     */
    async addScriptTag(T) {
      let { content: K = "", type: H } = T;
      const { path: j } = T;
      if (+!!T.url + +!!j + +!!K != 1)
        throw new Error("Exactly one of `url`, `path`, or `content` must be specified.");
      return j && (K = await cs.value.fs.promises.readFile(j, "utf8"), K += `//# sourceURL=${j.replace(/\n/g, "")}`), H = H ?? "text/javascript", await this.mainRealm().transferHandle(await this.isolatedRealm().evaluateHandle(async ({ url: eA, id: sA, type: uA, content: rA }) => await new Promise((hA, UA) => {
        const iA = document.createElement("script");
        iA.type = uA, iA.text = rA, iA.addEventListener("error", (wA) => {
          UA(new Error(wA.message ?? "Could not load script"));
        }, { once: !0 }), sA && (iA.id = sA), eA ? (iA.src = eA, iA.addEventListener("load", () => {
          hA(iA);
        }, { once: !0 }), document.head.appendChild(iA)) : (document.head.appendChild(iA), hA(iA));
      }), { ...T, type: H, content: K }));
    }
    /**
     * @internal
     */
    async addStyleTag(T) {
      let { content: K = "" } = T;
      const { path: H } = T;
      if (+!!T.url + +!!H + +!!K != 1)
        throw new Error("Exactly one of `url`, `path`, or `content` must be specified.");
      return H && (K = await cs.value.fs.promises.readFile(H, "utf8"), K += "/*# sourceURL=" + H.replace(/\n/g, "") + "*/", T.content = K), await this.mainRealm().transferHandle(await this.isolatedRealm().evaluateHandle(async ({ url: j, content: eA }) => await new Promise((sA, uA) => {
        let rA;
        if (!j)
          rA = document.createElement("style"), rA.appendChild(document.createTextNode(eA));
        else {
          const hA = document.createElement("link");
          hA.rel = "stylesheet", hA.href = j, rA = hA;
        }
        return rA.addEventListener("load", () => {
          sA(rA);
        }, { once: !0 }), rA.addEventListener("error", (hA) => {
          uA(new Error(hA.message ?? "Could not load style"));
        }, { once: !0 }), document.head.appendChild(rA), rA;
      }), T));
    }
    /**
     * Clicks the first element found that matches `selector`.
     *
     * @remarks
     * If `click()` triggers a navigation event and there's a separate
     * `page.waitForNavigation()` promise to be resolved, you may end up with a
     * race condition that yields unexpected results. The correct pattern for
     * click and wait for navigation is the following:
     *
     * ```ts
     * const [response] = await Promise.all([
     *   page.waitForNavigation(waitOptions),
     *   frame.click(selector, clickOptions),
     * ]);
     * ```
     *
     * @param selector - The selector to query for.
     */
    async click(T, K = {}) {
      const H = { stack: [], error: void 0, hasError: !1 };
      try {
        const j = Rs(H, await this.$(T), !1);
        bA(j, `No element found for selector: ${T}`), await j.click(K), await j.dispose();
      } catch (j) {
        H.error = j, H.hasError = !0;
      } finally {
        bs(H);
      }
    }
    /**
     * Focuses the first element that matches the `selector`.
     *
     * @param selector - The selector to query for.
     * @throws Throws if there's no element matching `selector`.
     */
    async focus(T) {
      const K = { stack: [], error: void 0, hasError: !1 };
      try {
        const H = Rs(K, await this.$(T), !1);
        bA(H, `No element found for selector: ${T}`), await H.focus();
      } catch (H) {
        K.error = H, K.hasError = !0;
      } finally {
        bs(K);
      }
    }
    /**
     * Hovers the pointer over the center of the first element that matches the
     * `selector`.
     *
     * @param selector - The selector to query for.
     * @throws Throws if there's no element matching `selector`.
     */
    async hover(T) {
      const K = { stack: [], error: void 0, hasError: !1 };
      try {
        const H = Rs(K, await this.$(T), !1);
        bA(H, `No element found for selector: ${T}`), await H.hover();
      } catch (H) {
        K.error = H, K.hasError = !0;
      } finally {
        bs(K);
      }
    }
    /**
     * Selects a set of value on the first `<select>` element that matches the
     * `selector`.
     *
     * @example
     *
     * ```ts
     * frame.select('select#colors', 'blue'); // single selection
     * frame.select('select#colors', 'red', 'green', 'blue'); // multiple selections
     * ```
     *
     * @param selector - The selector to query for.
     * @param values - The array of values to select. If the `<select>` has the
     * `multiple` attribute, all values are considered, otherwise only the first
     * one is taken into account.
     * @returns the list of values that were successfully selected.
     * @throws Throws if there's no `<select>` matching `selector`.
     */
    async select(T, ...K) {
      const H = { stack: [], error: void 0, hasError: !1 };
      try {
        const j = Rs(H, await this.$(T), !1);
        return bA(j, `No element found for selector: ${T}`), await j.select(...K);
      } catch (j) {
        H.error = j, H.hasError = !0;
      } finally {
        bs(H);
      }
    }
    /**
     * Taps the first element that matches the `selector`.
     *
     * @param selector - The selector to query for.
     * @throws Throws if there's no element matching `selector`.
     */
    async tap(T) {
      const K = { stack: [], error: void 0, hasError: !1 };
      try {
        const H = Rs(K, await this.$(T), !1);
        bA(H, `No element found for selector: ${T}`), await H.tap();
      } catch (H) {
        K.error = H, K.hasError = !0;
      } finally {
        bs(K);
      }
    }
    /**
     * Sends a `keydown`, `keypress`/`input`, and `keyup` event for each character
     * in the text.
     *
     * @remarks
     * To press a special key, like `Control` or `ArrowDown`, use
     * {@link Keyboard.press}.
     *
     * @example
     *
     * ```ts
     * await frame.type('#mytextarea', 'Hello'); // Types instantly
     * await frame.type('#mytextarea', 'World', {delay: 100}); // Types slower, like a user
     * ```
     *
     * @param selector - the selector for the element to type into. If there are
     * multiple the first will be used.
     * @param text - text to type into the element
     * @param options - takes one option, `delay`, which sets the time to wait
     * between key presses in milliseconds. Defaults to `0`.
     */
    async type(T, K, H) {
      const j = { stack: [], error: void 0, hasError: !1 };
      try {
        const eA = Rs(j, await this.$(T), !1);
        bA(eA, `No element found for selector: ${T}`), await eA.type(K, H);
      } catch (eA) {
        j.error = eA, j.hasError = !0;
      } finally {
        bs(j);
      }
    }
    /**
     * The frame's title.
     */
    async title() {
      return await this.isolatedRealm().evaluate(() => document.title);
    }
  }, m = new WeakMap(), S = new WeakSet(), /**
   * @internal
   */
  vC = function() {
    return d(this, m) || x(this, m, this.mainRealm().evaluateHandle(() => document)), d(this, m);
  }, (() => {
    const T = typeof Symbol == "function" && Symbol.metadata ? Object.create(t[Symbol.metadata] ?? null) : void 0;
    e = [Te], r = [Te], i = [Te], n = [Te], s = [Te], a = [Te], g = [Te], o = [Te], u = [Te], I = [Te], c = [Te], C = [Te], E = [Te], l = [Te], B = [Te], h = [Te], Q = [Te], f = [Te], p = [Te], y = [Te], st(F, null, e, { kind: "method", name: "frameElement", static: !1, private: !1, access: { has: (K) => "frameElement" in K, get: (K) => K.frameElement }, metadata: T }, null, A), st(F, null, r, { kind: "method", name: "evaluateHandle", static: !1, private: !1, access: { has: (K) => "evaluateHandle" in K, get: (K) => K.evaluateHandle }, metadata: T }, null, A), st(F, null, i, { kind: "method", name: "evaluate", static: !1, private: !1, access: { has: (K) => "evaluate" in K, get: (K) => K.evaluate }, metadata: T }, null, A), st(F, null, n, { kind: "method", name: "locator", static: !1, private: !1, access: { has: (K) => "locator" in K, get: (K) => K.locator }, metadata: T }, null, A), st(F, null, s, { kind: "method", name: "$", static: !1, private: !1, access: { has: (K) => "$" in K, get: (K) => K.$ }, metadata: T }, null, A), st(F, null, a, { kind: "method", name: "$$", static: !1, private: !1, access: { has: (K) => "$$" in K, get: (K) => K.$$ }, metadata: T }, null, A), st(F, null, g, { kind: "method", name: "$eval", static: !1, private: !1, access: { has: (K) => "$eval" in K, get: (K) => K.$eval }, metadata: T }, null, A), st(F, null, o, { kind: "method", name: "$$eval", static: !1, private: !1, access: { has: (K) => "$$eval" in K, get: (K) => K.$$eval }, metadata: T }, null, A), st(F, null, u, { kind: "method", name: "waitForSelector", static: !1, private: !1, access: { has: (K) => "waitForSelector" in K, get: (K) => K.waitForSelector }, metadata: T }, null, A), st(F, null, I, { kind: "method", name: "waitForFunction", static: !1, private: !1, access: { has: (K) => "waitForFunction" in K, get: (K) => K.waitForFunction }, metadata: T }, null, A), st(F, null, c, { kind: "method", name: "content", static: !1, private: !1, access: { has: (K) => "content" in K, get: (K) => K.content }, metadata: T }, null, A), st(F, null, C, { kind: "method", name: "addScriptTag", static: !1, private: !1, access: { has: (K) => "addScriptTag" in K, get: (K) => K.addScriptTag }, metadata: T }, null, A), st(F, null, E, { kind: "method", name: "addStyleTag", static: !1, private: !1, access: { has: (K) => "addStyleTag" in K, get: (K) => K.addStyleTag }, metadata: T }, null, A), st(F, null, l, { kind: "method", name: "click", static: !1, private: !1, access: { has: (K) => "click" in K, get: (K) => K.click }, metadata: T }, null, A), st(F, null, B, { kind: "method", name: "focus", static: !1, private: !1, access: { has: (K) => "focus" in K, get: (K) => K.focus }, metadata: T }, null, A), st(F, null, h, { kind: "method", name: "hover", static: !1, private: !1, access: { has: (K) => "hover" in K, get: (K) => K.hover }, metadata: T }, null, A), st(F, null, Q, { kind: "method", name: "select", static: !1, private: !1, access: { has: (K) => "select" in K, get: (K) => K.select }, metadata: T }, null, A), st(F, null, f, { kind: "method", name: "tap", static: !1, private: !1, access: { has: (K) => "tap" in K, get: (K) => K.tap }, metadata: T }, null, A), st(F, null, p, { kind: "method", name: "type", static: !1, private: !1, access: { has: (K) => "type" in K, get: (K) => K.type }, metadata: T }, null, A), st(F, null, y, { kind: "method", name: "title", static: !1, private: !1, access: { has: (K) => "title" in K, get: (K) => K.title }, metadata: T }, null, A), T && Object.defineProperty(F, Symbol.metadata, { enumerable: !0, configurable: !0, writable: !0, value: T });
  })(), F;
})();
class rR {
  /**
   * @internal
   */
  constructor() {
    /**
     * @internal
     */
    R(this, "_interceptionId");
    /**
     * @internal
     */
    R(this, "_failureText", null);
    /**
     * @internal
     */
    R(this, "_response", null);
    /**
     * @internal
     */
    R(this, "_fromMemoryCache", !1);
    /**
     * @internal
     */
    R(this, "_redirectChain", []);
    /**
     * @internal
     */
    R(this, "interception", {
      enabled: !1,
      handled: !1,
      handlers: [],
      resolutionState: {
        action: Oi.None
      },
      requestOverrides: {},
      response: null,
      abortReason: null
    });
  }
  /**
   * The `ContinueRequestOverrides` that will be used
   * if the interception is allowed to continue (ie, `abort()` and
   * `respond()` aren't called).
   */
  continueRequestOverrides() {
    return this.interception.requestOverrides;
  }
  /**
   * The `ResponseForRequest` that gets used if the
   * interception is allowed to respond (ie, `abort()` is not called).
   */
  responseForRequest() {
    return this.interception.response;
  }
  /**
   * The most recent reason for aborting the request
   */
  abortErrorReason() {
    return this.interception.abortReason;
  }
  /**
   * An InterceptResolutionState object describing the current resolution
   * action and priority.
   *
   * InterceptResolutionState contains:
   * action: InterceptResolutionAction
   * priority?: number
   *
   * InterceptResolutionAction is one of: `abort`, `respond`, `continue`,
   * `disabled`, `none`, or `already-handled`.
   */
  interceptResolutionState() {
    return this.interception.enabled ? this.interception.handled ? { action: Oi.AlreadyHandled } : { ...this.interception.resolutionState } : { action: Oi.Disabled };
  }
  /**
   * Is `true` if the intercept resolution has already been handled,
   * `false` otherwise.
   */
  isInterceptResolutionHandled() {
    return this.interception.handled;
  }
  /**
   * Adds an async request handler to the processing queue.
   * Deferred handlers are not guaranteed to execute in any particular order,
   * but they are guaranteed to resolve before the request interception
   * is finalized.
   */
  enqueueInterceptAction(A) {
    this.interception.handlers.push(A);
  }
  /**
   * Awaits pending interception handlers and then decides how to fulfill
   * the request interception.
   */
  async finalizeInterceptions() {
    await this.interception.handlers.reduce((e, r) => e.then(r), Promise.resolve()), this.interception.handlers = [];
    const { action: A } = this.interceptResolutionState();
    switch (A) {
      case "abort":
        return await this._abort(this.interception.abortReason);
      case "respond":
        if (this.interception.response === null)
          throw new Error("Response is missing for the interception");
        return await this._respond(this.interception.response);
      case "continue":
        return await this._continue(this.interception.requestOverrides);
    }
  }
  /**
   * @internal
   */
  verifyInterception() {
    bA(this.interception.enabled, "Request Interception is not enabled!"), bA(!this.interception.handled, "Request is already handled!");
  }
  /**
   * Continues request with optional request overrides.
   *
   * @example
   *
   * ```ts
   * await page.setRequestInterception(true);
   * page.on('request', request => {
   *   // Override headers
   *   const headers = Object.assign({}, request.headers(), {
   *     foo: 'bar', // set "foo" header
   *     origin: undefined, // remove "origin" header
   *   });
   *   request.continue({headers});
   * });
   * ```
   *
   * @param overrides - optional overrides to apply to the request.
   * @param priority - If provided, intercept is resolved using cooperative
   * handling rules. Otherwise, intercept is resolved immediately.
   *
   * @remarks
   *
   * To use this, request interception should be enabled with
   * {@link Page.setRequestInterception}.
   *
   * Exception is immediately thrown if the request interception is not enabled.
   */
  async continue(A = {}, e) {
    if (this.verifyInterception(), !!this.canBeIntercepted()) {
      if (e === void 0)
        return await this._continue(A);
      if (this.interception.requestOverrides = A, this.interception.resolutionState.priority === void 0 || e > this.interception.resolutionState.priority) {
        this.interception.resolutionState = {
          action: Oi.Continue,
          priority: e
        };
        return;
      }
      if (e === this.interception.resolutionState.priority) {
        if (this.interception.resolutionState.action === "abort" || this.interception.resolutionState.action === "respond")
          return;
        this.interception.resolutionState.action = Oi.Continue;
      }
    }
  }
  /**
   * Fulfills a request with the given response.
   *
   * @example
   * An example of fulfilling all requests with 404 responses:
   *
   * ```ts
   * await page.setRequestInterception(true);
   * page.on('request', request => {
   *   request.respond({
   *     status: 404,
   *     contentType: 'text/plain',
   *     body: 'Not Found!',
   *   });
   * });
   * ```
   *
   * NOTE: Mocking responses for dataURL requests is not supported.
   * Calling `request.respond` for a dataURL request is a noop.
   *
   * @param response - the response to fulfill the request with.
   * @param priority - If provided, intercept is resolved using
   * cooperative handling rules. Otherwise, intercept is resolved
   * immediately.
   *
   * @remarks
   *
   * To use this, request
   * interception should be enabled with {@link Page.setRequestInterception}.
   *
   * Exception is immediately thrown if the request interception is not enabled.
   */
  async respond(A, e) {
    if (this.verifyInterception(), !!this.canBeIntercepted()) {
      if (e === void 0)
        return await this._respond(A);
      if (this.interception.response = A, this.interception.resolutionState.priority === void 0 || e > this.interception.resolutionState.priority) {
        this.interception.resolutionState = {
          action: Oi.Respond,
          priority: e
        };
        return;
      }
      if (e === this.interception.resolutionState.priority) {
        if (this.interception.resolutionState.action === "abort")
          return;
        this.interception.resolutionState.action = Oi.Respond;
      }
    }
  }
  /**
   * Aborts a request.
   *
   * @param errorCode - optional error code to provide.
   * @param priority - If provided, intercept is resolved using
   * cooperative handling rules. Otherwise, intercept is resolved
   * immediately.
   *
   * @remarks
   *
   * To use this, request interception should be enabled with
   * {@link Page.setRequestInterception}. If it is not enabled, this method will
   * throw an exception immediately.
   */
  async abort(A = "failed", e) {
    if (this.verifyInterception(), !this.canBeIntercepted())
      return;
    const r = p7[A];
    if (bA(r, "Unknown error code: " + A), e === void 0)
      return await this._abort(r);
    if (this.interception.abortReason = r, this.interception.resolutionState.priority === void 0 || e >= this.interception.resolutionState.priority) {
      this.interception.resolutionState = {
        action: Oi.Abort,
        priority: e
      };
      return;
    }
  }
  /**
   * @internal
   */
  static getResponse(A) {
    const e = kg(A) ? new TextEncoder().encode(A) : A;
    return {
      contentLength: e.byteLength,
      base64: qU(e)
    };
  }
}
var Oi;
(function(t) {
  t.Abort = "abort", t.Respond = "respond", t.Continue = "continue", t.Disabled = "disabled", t.None = "none", t.AlreadyHandled = "already-handled";
})(Oi || (Oi = {}));
function iR(t) {
  const A = [];
  for (const e in t) {
    const r = t[e];
    if (!Object.is(r, void 0)) {
      const i = Array.isArray(r) ? r : [r];
      A.push(...i.map((n) => ({ name: e, value: n + "" })));
    }
  }
  return A;
}
const f7 = {
  100: "Continue",
  101: "Switching Protocols",
  102: "Processing",
  103: "Early Hints",
  200: "OK",
  201: "Created",
  202: "Accepted",
  203: "Non-Authoritative Information",
  204: "No Content",
  205: "Reset Content",
  206: "Partial Content",
  207: "Multi-Status",
  208: "Already Reported",
  226: "IM Used",
  300: "Multiple Choices",
  301: "Moved Permanently",
  302: "Found",
  303: "See Other",
  304: "Not Modified",
  305: "Use Proxy",
  306: "Switch Proxy",
  307: "Temporary Redirect",
  308: "Permanent Redirect",
  400: "Bad Request",
  401: "Unauthorized",
  402: "Payment Required",
  403: "Forbidden",
  404: "Not Found",
  405: "Method Not Allowed",
  406: "Not Acceptable",
  407: "Proxy Authentication Required",
  408: "Request Timeout",
  409: "Conflict",
  410: "Gone",
  411: "Length Required",
  412: "Precondition Failed",
  413: "Payload Too Large",
  414: "URI Too Long",
  415: "Unsupported Media Type",
  416: "Range Not Satisfiable",
  417: "Expectation Failed",
  418: "I'm a teapot",
  421: "Misdirected Request",
  422: "Unprocessable Entity",
  423: "Locked",
  424: "Failed Dependency",
  425: "Too Early",
  426: "Upgrade Required",
  428: "Precondition Required",
  429: "Too Many Requests",
  431: "Request Header Fields Too Large",
  451: "Unavailable For Legal Reasons",
  500: "Internal Server Error",
  501: "Not Implemented",
  502: "Bad Gateway",
  503: "Service Unavailable",
  504: "Gateway Timeout",
  505: "HTTP Version Not Supported",
  506: "Variant Also Negotiates",
  507: "Insufficient Storage",
  508: "Loop Detected",
  510: "Not Extended",
  511: "Network Authentication Required"
}, p7 = {
  aborted: "Aborted",
  accessdenied: "AccessDenied",
  addressunreachable: "AddressUnreachable",
  blockedbyclient: "BlockedByClient",
  blockedbyresponse: "BlockedByResponse",
  connectionaborted: "ConnectionAborted",
  connectionclosed: "ConnectionClosed",
  connectionfailed: "ConnectionFailed",
  connectionrefused: "ConnectionRefused",
  connectionreset: "ConnectionReset",
  internetdisconnected: "InternetDisconnected",
  namenotresolved: "NameNotResolved",
  timedout: "TimedOut",
  failed: "Failed"
};
function Dy(t) {
  if (t.originalMessage.includes("Invalid header") || t.originalMessage.includes("Unsafe header") || t.originalMessage.includes('Expected "header"') || // WebDriver BiDi error for invalid values, for example, headers.
  t.originalMessage.includes("invalid argument"))
    throw t;
  HA(t);
}
/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
class y7 {
  /**
   * @internal
   */
  constructor() {
  }
  /**
   * True if the response was successful (status in the range 200-299).
   */
  ok() {
    const A = this.status();
    return A === 0 || A >= 200 && A <= 299;
  }
  /**
   * {@inheritDoc HTTPResponse.content}
   */
  async buffer() {
    const A = await this.content();
    return Buffer.from(A);
  }
  /**
   * Promise which resolves to a text (utf8) representation of response body.
   */
  async text() {
    const A = await this.content();
    return new TextDecoder().decode(A);
  }
  /**
   * Promise which resolves to a JSON representation of response body.
   *
   * @remarks
   *
   * This method will throw if the response body is not parsable via
   * `JSON.parse`.
   */
  async json() {
    const A = await this.text();
    return JSON.parse(A);
  }
}
/**
 * @license
 * Copyright 2024 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
function qE() {
  let t = 0;
  return () => (t === Number.MAX_SAFE_INTEGER && (t = 0), ++t);
}
/**
 * @license
 * Copyright 2017 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
class w7 {
  /**
   * @internal
   */
  constructor() {
  }
}
const Ot = Object.freeze({
  Left: "left",
  Right: "right",
  Middle: "middle",
  Back: "back",
  Forward: "forward"
});
class m7 {
  /**
   * @internal
   */
  constructor() {
  }
}
class D7 {
  /**
   * @internal
   */
  constructor() {
    /**
     * @internal
     */
    R(this, "idGenerator", qE());
    /**
     * @internal
     */
    R(this, "touches", []);
  }
  /**
   * @internal
   */
  removeHandle(A) {
    const e = this.touches.indexOf(A);
    e !== -1 && this.touches.splice(e, 1);
  }
  /**
   * Dispatches a `touchstart` and `touchend` event.
   * @param x - Horizontal position of the tap.
   * @param y - Vertical position of the tap.
   */
  async tap(A, e) {
    await (await this.touchStart(A, e)).end();
  }
  /**
   * Dispatches a `touchMove` event on the first touch that is active.
   * @param x - Horizontal position of the move.
   * @param y - Vertical position of the move.
   *
   * @remarks
   *
   * Not every `touchMove` call results in a `touchmove` event being emitted,
   * depending on the browser's optimizations. For example, Chrome
   * {@link https://developer.chrome.com/blog/a-more-compatible-smoother-touch/#chromes-new-model-the-throttled-async-touchmove-model | throttles}
   * touch move events.
   */
  async touchMove(A, e) {
    const r = this.touches[0];
    if (!r)
      throw new Nm("Must start a new Touch first");
    return await r.move(A, e);
  }
  /**
   * Dispatches a `touchend` event on the first touch that is active.
   */
  async touchEnd() {
    const A = this.touches.shift();
    if (!A)
      throw new Nm("Must start a new Touch first");
    await A.end();
  }
}
/**
 * @license
 * Copyright 2019 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
const nR = 3e4;
var qn, po;
class LS {
  constructor() {
    k(this, qn);
    k(this, po);
    x(this, qn, null), x(this, po, null);
  }
  setDefaultTimeout(A) {
    x(this, qn, A);
  }
  setDefaultNavigationTimeout(A) {
    x(this, po, A);
  }
  navigationTimeout() {
    return d(this, po) !== null ? d(this, po) : d(this, qn) !== null ? d(this, qn) : nR;
  }
  timeout() {
    return d(this, qn) !== null ? d(this, qn) : nR;
  }
}
qn = new WeakMap(), po = new WeakMap();
/**
 * @license
 * Copyright 2017 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
var S7 = function(t, A, e) {
  for (var r = arguments.length > 2, i = 0; i < A.length; i++)
    e = r ? A[i].call(t, e) : A[i].call(t);
  return r ? e : void 0;
}, F7 = function(t, A, e, r, i, n) {
  function s(h) {
    if (h !== void 0 && typeof h != "function") throw new TypeError("Function expected");
    return h;
  }
  for (var a = r.kind, g = a === "getter" ? "get" : a === "setter" ? "set" : "value", o = !A && t ? r.static ? t : t.prototype : null, u = A || (o ? Object.getOwnPropertyDescriptor(o, r.name) : {}), I, c = !1, C = e.length - 1; C >= 0; C--) {
    var E = {};
    for (var l in r) E[l] = l === "access" ? {} : r[l];
    for (var l in r.access) E.access[l] = r.access[l];
    E.addInitializer = function(h) {
      if (c) throw new TypeError("Cannot add initializers after decoration has completed");
      n.push(s(h || null));
    };
    var B = (0, e[C])(a === "accessor" ? { get: u.get, set: u.set } : u[g], E);
    if (a === "accessor") {
      if (B === void 0) continue;
      if (B === null || typeof B != "object") throw new TypeError("Object expected");
      (I = s(B.get)) && (u.get = I), (I = s(B.set)) && (u.set = I), (I = s(B.init)) && i.unshift(I);
    } else (I = s(B)) && (a === "field" ? i.unshift(I) : u[g] = I);
  }
  o && Object.defineProperty(o, r.name, u), c = !0;
}, Sy = function(t, A, e) {
  if (A != null) {
    if (typeof A != "object" && typeof A != "function") throw new TypeError("Object expected.");
    var r, i;
    if (e) {
      if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
      r = A[Symbol.asyncDispose];
    }
    if (r === void 0) {
      if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
      r = A[Symbol.dispose], e && (i = r);
    }
    if (typeof r != "function") throw new TypeError("Object not disposable.");
    i && (r = function() {
      try {
        i.call(this);
      } catch (n) {
        return Promise.reject(n);
      }
    }), t.stack.push({ value: A, dispose: r, async: e });
  } else e && t.stack.push({ async: !0 });
  return A;
}, sR = /* @__PURE__ */ function(t) {
  return function(A) {
    function e(s) {
      A.error = A.hasError ? new t(s, A.error, "An error was suppressed during disposal.") : s, A.hasError = !0;
    }
    var r, i = 0;
    function n() {
      for (; r = A.stack.pop(); )
        try {
          if (!r.async && i === 1) return i = 0, A.stack.push(r), Promise.resolve().then(n);
          if (r.dispose) {
            var s = r.dispose.call(r.value);
            if (r.async) return i |= 2, Promise.resolve(s).then(n, function(a) {
              return e(a), n();
            });
          } else i |= 1;
        } catch (a) {
          e(a);
        }
      if (i === 1) return A.hasError ? Promise.reject(A.error) : Promise.resolve();
      if (A.hasError) throw A.error;
    }
    return n();
  };
}(typeof SuppressedError == "function" ? SuppressedError : function(t, A, e) {
  var r = new Error(e);
  return r.name = "SuppressedError", r.error = t, r.suppressed = A, r;
});
function k7(t) {
  t.optimizeForSpeed ?? (t.optimizeForSpeed = !1), t.type ?? (t.type = "png"), t.fromSurface ?? (t.fromSurface = !0), t.fullPage ?? (t.fullPage = !1), t.omitBackground ?? (t.omitBackground = !1), t.encoding ?? (t.encoding = "binary"), t.captureBeyondViewport ?? (t.captureBeyondViewport = !0);
}
let v7 = (() => {
  var r, i, n, s, a, I1, o;
  let t = je, A = [], e;
  return o = class extends t {
    /**
     * @internal
     */
    constructor() {
      super();
      k(this, a);
      /**
       * @internal
       */
      R(this, "_isDragging", (S7(this, A), !1));
      /**
       * @internal
       */
      R(this, "_timeoutSettings", new LS());
      k(this, r, /* @__PURE__ */ new WeakMap());
      k(this, i, new wz(1));
      k(this, n, 0);
      k(this, s);
      ot(
        this,
        "request"
        /* PageEvent.Request */
      ).pipe(gt((c) => bm(Rm(1), sl(ot(
        this,
        "requestfailed"
        /* PageEvent.RequestFailed */
      ), ot(
        this,
        "requestfinished"
        /* PageEvent.RequestFinished */
      ), ot(
        this,
        "response"
        /* PageEvent.Response */
      ).pipe(ht((C) => C.request()))).pipe(Fg((C) => C.id === c.id), vS(1), ht(() => -1)))), Q$((c, C) => Rm(c + C), 0), PU(ot(
        this,
        "close"
        /* PageEvent.Close */
      )), d$(0)).subscribe(d(this, i));
    }
    /**
     * Listen to page events.
     *
     * @remarks
     * This method exists to define event typings and handle proper wireup of
     * cooperative request interception. Actual event listening and dispatching is
     * delegated to {@link EventEmitter}.
     *
     * @internal
     */
    on(c, C) {
      if (c !== "request")
        return super.on(c, C);
      let E = d(this, r).get(C);
      return E === void 0 && (E = (l) => {
        l.enqueueInterceptAction(() => C(l));
      }, d(this, r).set(C, E)), super.on(c, E);
    }
    /**
     * @internal
     */
    off(c, C) {
      return c === "request" && (C = d(this, r).get(C) || C), super.off(c, C);
    }
    /**
     * {@inheritDoc Accessibility}
     */
    get accessibility() {
      return this.mainFrame().accessibility;
    }
    locator(c) {
      return typeof c == "string" ? gl.create(this, c) : Zd.create(this, c);
    }
    /**
     * A shortcut for {@link Locator.race} that does not require static imports.
     *
     * @internal
     */
    locatorRace(c) {
      return cI.race(c);
    }
    /**
     * Finds the first element that matches the selector. If no element matches
     * the selector, the return value resolves to `null`.
     *
     * @param selector -
     * {@link https://pptr.dev/guides/page-interactions#selectors | selector}
     * to query the page for.
     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | CSS selectors}
     * can be passed as-is and a
     * {@link https://pptr.dev/guides/page-interactions#non-css-selectors | Puppeteer-specific selector syntax}
     * allows querying by
     * {@link https://pptr.dev/guides/page-interactions#text-selectors--p-text | text},
     * {@link https://pptr.dev/guides/page-interactions#aria-selectors--p-aria | a11y role and name},
     * and
     * {@link https://pptr.dev/guides/page-interactions#xpath-selectors--p-xpath | xpath}
     * and
     * {@link https://pptr.dev/guides/page-interactions#querying-elements-in-shadow-dom | combining these queries across shadow roots}.
     * Alternatively, you can specify the selector type using a
     * {@link https://pptr.dev/guides/page-interactions#prefixed-selector-syntax | prefix}.
     *
     * @remarks
     *
     * Shortcut for {@link Frame.$ | Page.mainFrame().$(selector) }.
     */
    async $(c) {
      return await this.mainFrame().$(c);
    }
    /**
     * Finds elements on the page that match the selector. If no elements
     * match the selector, the return value resolves to `[]`.
     *
     * @param selector -
     * {@link https://pptr.dev/guides/page-interactions#selectors | selector}
     * to query the page for.
     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | CSS selectors}
     * can be passed as-is and a
     * {@link https://pptr.dev/guides/page-interactions#non-css-selectors | Puppeteer-specific selector syntax}
     * allows querying by
     * {@link https://pptr.dev/guides/page-interactions#text-selectors--p-text | text},
     * {@link https://pptr.dev/guides/page-interactions#aria-selectors--p-aria | a11y role and name},
     * and
     * {@link https://pptr.dev/guides/page-interactions#xpath-selectors--p-xpath | xpath}
     * and
     * {@link https://pptr.dev/guides/page-interactions#querying-elements-in-shadow-dom | combining these queries across shadow roots}.
     * Alternatively, you can specify the selector type using a
     * {@link https://pptr.dev/guides/page-interactions#prefixed-selector-syntax | prefix}.
     *
     * @remarks
     *
     * Shortcut for {@link Frame.$$ | Page.mainFrame().$$(selector) }.
     */
    async $$(c, C) {
      return await this.mainFrame().$$(c, C);
    }
    /**
     * @remarks
     *
     * The only difference between {@link Page.evaluate | page.evaluate} and
     * `page.evaluateHandle` is that `evaluateHandle` will return the value
     * wrapped in an in-page object.
     *
     * If the function passed to `page.evaluateHandle` returns a Promise, the
     * function will wait for the promise to resolve and return its value.
     *
     * You can pass a string instead of a function (although functions are
     * recommended as they are easier to debug and use with TypeScript):
     *
     * @example
     *
     * ```ts
     * const aHandle = await page.evaluateHandle('document');
     * ```
     *
     * @example
     * {@link JSHandle} instances can be passed as arguments to the `pageFunction`:
     *
     * ```ts
     * const aHandle = await page.evaluateHandle(() => document.body);
     * const resultHandle = await page.evaluateHandle(
     *   body => body.innerHTML,
     *   aHandle,
     * );
     * console.log(await resultHandle.jsonValue());
     * await resultHandle.dispose();
     * ```
     *
     * Most of the time this function returns a {@link JSHandle},
     * but if `pageFunction` returns a reference to an element,
     * you instead get an {@link ElementHandle} back:
     *
     * @example
     *
     * ```ts
     * const button = await page.evaluateHandle(() =>
     *   document.querySelector('button'),
     * );
     * // can call `click` because `button` is an `ElementHandle`
     * await button.click();
     * ```
     *
     * The TypeScript definitions assume that `evaluateHandle` returns
     * a `JSHandle`, but if you know it's going to return an
     * `ElementHandle`, pass it as the generic argument:
     *
     * ```ts
     * const button = await page.evaluateHandle<ElementHandle>(...);
     * ```
     *
     * @param pageFunction - a function that is run within the page
     * @param args - arguments to be passed to the pageFunction
     */
    async evaluateHandle(c, ...C) {
      return c = bt(this.evaluateHandle.name, c), await this.mainFrame().evaluateHandle(c, ...C);
    }
    /**
     * This method finds the first element within the page that matches the selector
     * and passes the result as the first argument to the `pageFunction`.
     *
     * @remarks
     *
     * If no element is found matching `selector`, the method will throw an error.
     *
     * If `pageFunction` returns a promise `$eval` will wait for the promise to
     * resolve and then return its value.
     *
     * @example
     *
     * ```ts
     * const searchValue = await page.$eval('#search', el => el.value);
     * const preloadHref = await page.$eval('link[rel=preload]', el => el.href);
     * const html = await page.$eval('.main-container', el => el.outerHTML);
     * ```
     *
     * If you are using TypeScript, you may have to provide an explicit type to the
     * first argument of the `pageFunction`.
     * By default it is typed as `Element`, but you may need to provide a more
     * specific sub-type:
     *
     * @example
     *
     * ```ts
     * // if you don't provide HTMLInputElement here, TS will error
     * // as `value` is not on `Element`
     * const searchValue = await page.$eval(
     *   '#search',
     *   (el: HTMLInputElement) => el.value,
     * );
     * ```
     *
     * The compiler should be able to infer the return type
     * from the `pageFunction` you provide. If it is unable to, you can use the generic
     * type to tell the compiler what return type you expect from `$eval`:
     *
     * @example
     *
     * ```ts
     * // The compiler can infer the return type in this case, but if it can't
     * // or if you want to be more explicit, provide it as the generic type.
     * const searchValue = await page.$eval<string>(
     *   '#search',
     *   (el: HTMLInputElement) => el.value,
     * );
     * ```
     *
     * @param selector -
     * {@link https://pptr.dev/guides/page-interactions#selectors | selector}
     * to query the page for.
     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | CSS selectors}
     * can be passed as-is and a
     * {@link https://pptr.dev/guides/page-interactions#non-css-selectors | Puppeteer-specific selector syntax}
     * allows querying by
     * {@link https://pptr.dev/guides/page-interactions#text-selectors--p-text | text},
     * {@link https://pptr.dev/guides/page-interactions#aria-selectors--p-aria | a11y role and name},
     * and
     * {@link https://pptr.dev/guides/page-interactions#xpath-selectors--p-xpath | xpath}
     * and
     * {@link https://pptr.dev/guides/page-interactions#querying-elements-in-shadow-dom | combining these queries across shadow roots}.
     * Alternatively, you can specify the selector type using a
     * {@link https://pptr.dev/guides/page-interactions#prefixed-selector-syntax | prefix}.
     * @param pageFunction - the function to be evaluated in the page context.
     * Will be passed the result of the element matching the selector as its
     * first argument.
     * @param args - any additional arguments to pass through to `pageFunction`.
     *
     * @returns The result of calling `pageFunction`. If it returns an element it
     * is wrapped in an {@link ElementHandle}, else the raw value itself is
     * returned.
     */
    async $eval(c, C, ...E) {
      return C = bt(this.$eval.name, C), await this.mainFrame().$eval(c, C, ...E);
    }
    /**
     * This method returns all elements matching the selector and passes the
     * resulting array as the first argument to the `pageFunction`.
     *
     * @remarks
     * If `pageFunction` returns a promise `$$eval` will wait for the promise to
     * resolve and then return its value.
     *
     * @example
     *
     * ```ts
     * // get the amount of divs on the page
     * const divCount = await page.$$eval('div', divs => divs.length);
     *
     * // get the text content of all the `.options` elements:
     * const options = await page.$$eval('div > span.options', options => {
     *   return options.map(option => option.textContent);
     * });
     * ```
     *
     * If you are using TypeScript, you may have to provide an explicit type to the
     * first argument of the `pageFunction`.
     * By default it is typed as `Element[]`, but you may need to provide a more
     * specific sub-type:
     *
     * @example
     *
     * ```ts
     * await page.$$eval('input', elements => {
     *   return elements.map(e => e.value);
     * });
     * ```
     *
     * The compiler should be able to infer the return type
     * from the `pageFunction` you provide. If it is unable to, you can use the generic
     * type to tell the compiler what return type you expect from `$$eval`:
     *
     * @example
     *
     * ```ts
     * const allInputValues = await page.$$eval('input', elements =>
     *   elements.map(e => e.textContent),
     * );
     * ```
     *
     * @param selector -
     * {@link https://pptr.dev/guides/page-interactions#selectors | selector}
     * to query the page for.
     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | CSS selectors}
     * can be passed as-is and a
     * {@link https://pptr.dev/guides/page-interactions#non-css-selectors | Puppeteer-specific selector syntax}
     * allows querying by
     * {@link https://pptr.dev/guides/page-interactions#text-selectors--p-text | text},
     * {@link https://pptr.dev/guides/page-interactions#aria-selectors--p-aria | a11y role and name},
     * and
     * {@link https://pptr.dev/guides/page-interactions#xpath-selectors--p-xpath | xpath}
     * and
     * {@link https://pptr.dev/guides/page-interactions#querying-elements-in-shadow-dom | combining these queries across shadow roots}.
     * Alternatively, you can specify the selector type using a
     * {@link https://pptr.dev/guides/page-interactions#prefixed-selector-syntax | prefix}.
     * @param pageFunction - the function to be evaluated in the page context.
     * Will be passed an array of matching elements as its first argument.
     * @param args - any additional arguments to pass through to `pageFunction`.
     *
     * @returns The result of calling `pageFunction`. If it returns an element it
     * is wrapped in an {@link ElementHandle}, else the raw value itself is
     * returned.
     */
    async $$eval(c, C, ...E) {
      return C = bt(this.$$eval.name, C), await this.mainFrame().$$eval(c, C, ...E);
    }
    /**
     * Adds a `<script>` tag into the page with the desired URL or content.
     *
     * @remarks
     * Shortcut for
     * {@link Frame.addScriptTag | page.mainFrame().addScriptTag(options)}.
     *
     * @param options - Options for the script.
     * @returns An {@link ElementHandle | element handle} to the injected
     * `<script>` element.
     */
    async addScriptTag(c) {
      return await this.mainFrame().addScriptTag(c);
    }
    async addStyleTag(c) {
      return await this.mainFrame().addStyleTag(c);
    }
    /**
     * The page's URL.
     *
     * @remarks
     *
     * Shortcut for {@link Frame.url | page.mainFrame().url()}.
     */
    url() {
      return this.mainFrame().url();
    }
    /**
     * The full HTML contents of the page, including the DOCTYPE.
     */
    async content() {
      return await this.mainFrame().content();
    }
    /**
     * Set the content of the page.
     *
     * @param html - HTML markup to assign to the page.
     * @param options - Parameters that has some properties.
     */
    async setContent(c, C) {
      await this.mainFrame().setContent(c, C);
    }
    /**
     * {@inheritDoc Frame.goto}
     */
    async goto(c, C) {
      return await this.mainFrame().goto(c, C);
    }
    /**
     * Waits for the page to navigate to a new URL or to reload. It is useful when
     * you run code that will indirectly cause the page to navigate.
     *
     * @example
     *
     * ```ts
     * const [response] = await Promise.all([
     *   page.waitForNavigation(), // The promise resolves after navigation has finished
     *   page.click('a.my-link'), // Clicking the link will indirectly cause a navigation
     * ]);
     * ```
     *
     * @remarks
     *
     * Usage of the
     * {@link https://developer.mozilla.org/en-US/docs/Web/API/History_API | History API}
     * to change the URL is considered a navigation.
     *
     * @param options - Navigation parameters which might have the following
     * properties:
     * @returns A `Promise` which resolves to the main resource response.
     *
     * - In case of multiple redirects, the navigation will resolve with the
     *   response of the last redirect.
     * - In case of navigation to a different anchor or navigation due to History
     *   API usage, the navigation will resolve with `null`.
     */
    async waitForNavigation(c = {}) {
      return await this.mainFrame().waitForNavigation(c);
    }
    /**
     * @param urlOrPredicate - A URL or predicate to wait for
     * @param options - Optional waiting parameters
     * @returns Promise which resolves to the matched request
     * @example
     *
     * ```ts
     * const firstRequest = await page.waitForRequest(
     *   'https://example.com/resource',
     * );
     * const finalRequest = await page.waitForRequest(
     *   request => request.url() === 'https://example.com',
     * );
     * return finalRequest.response()?.ok();
     * ```
     *
     * @remarks
     * Optional Waiting Parameters have:
     *
     * - `timeout`: Maximum wait time in milliseconds, defaults to `30` seconds, pass
     *   `0` to disable the timeout. The default value can be changed by using the
     *   {@link Page.setDefaultTimeout} method.
     */
    waitForRequest(c, C = {}) {
      const { timeout: E = this._timeoutSettings.timeout(), signal: l } = C;
      if (typeof c == "string") {
        const h = c;
        c = (Q) => Q.url() === h;
      }
      const B = ot(
        this,
        "request"
        /* PageEvent.Request */
      ).pipe(JC(c), ln(Bn(E), eu(l), ot(
        this,
        "close"
        /* PageEvent.Close */
      ).pipe(ht(() => {
        throw new Da("Page closed!");
      }))));
      return or(B);
    }
    /**
     * @param urlOrPredicate - A URL or predicate to wait for.
     * @param options - Optional waiting parameters
     * @returns Promise which resolves to the matched response.
     * @example
     *
     * ```ts
     * const firstResponse = await page.waitForResponse(
     *   'https://example.com/resource',
     * );
     * const finalResponse = await page.waitForResponse(
     *   response =>
     *     response.url() === 'https://example.com' && response.status() === 200,
     * );
     * const finalResponse = await page.waitForResponse(async response => {
     *   return (await response.text()).includes('<html>');
     * });
     * return finalResponse.ok();
     * ```
     *
     * @remarks
     * Optional Parameter have:
     *
     * - `timeout`: Maximum wait time in milliseconds, defaults to `30` seconds,
     *   pass `0` to disable the timeout. The default value can be changed by using
     *   the {@link Page.setDefaultTimeout} method.
     */
    waitForResponse(c, C = {}) {
      const { timeout: E = this._timeoutSettings.timeout(), signal: l } = C;
      if (typeof c == "string") {
        const h = c;
        c = (Q) => Q.url() === h;
      }
      const B = ot(
        this,
        "response"
        /* PageEvent.Response */
      ).pipe(JC(c), ln(Bn(E), eu(l), ot(
        this,
        "close"
        /* PageEvent.Close */
      ).pipe(ht(() => {
        throw new Da("Page closed!");
      }))));
      return or(B);
    }
    /**
     * Waits for the network to be idle.
     *
     * @remarks The function will always wait at least the
     * set {@link WaitForNetworkIdleOptions.idleTime | IdleTime}.
     *
     * @param options - Options to configure waiting behavior.
     * @returns A promise which resolves once the network is idle.
     */
    waitForNetworkIdle(c = {}) {
      return or(this.waitForNetworkIdle$(c));
    }
    /**
     * @internal
     */
    waitForNetworkIdle$(c = {}) {
      const { timeout: C = this._timeoutSettings.timeout(), idleTime: E = b$, concurrency: l = 0, signal: B } = c;
      return d(this, i).pipe(ht((h) => h > l), B$(), f$((h) => h ? Ig : yp(E)), ht(() => {
      }), ln(Bn(C), eu(B), ot(
        this,
        "close"
        /* PageEvent.Close */
      ).pipe(ht(() => {
        throw new Da("Page closed!");
      }))));
    }
    /**
     * Waits for a frame matching the given conditions to appear.
     *
     * @example
     *
     * ```ts
     * const frame = await page.waitForFrame(async frame => {
     *   const frameElement = await frame.frameElement();
     *   if (!frameElement) {
     *     return false;
     *   }
     *   const name = await frameElement.evaluate(el => el.getAttribute('name'));
     *   return name === 'test';
     * });
     * ```
     */
    async waitForFrame(c, C = {}) {
      const { timeout: E = this.getDefaultTimeout(), signal: l } = C, B = kg(c) ? (h) => c === h.url() : c;
      return await or(sl(ot(
        this,
        "frameattached"
        /* PageEvent.FrameAttached */
      ), ot(
        this,
        "framenavigated"
        /* PageEvent.FrameNavigated */
      ), de(this.frames())).pipe(JC(B), qd(), ln(Bn(E), eu(l), ot(
        this,
        "close"
        /* PageEvent.Close */
      ).pipe(ht(() => {
        throw new Da("Page closed.");
      })))));
    }
    /**
     * Emulates a given device's metrics and user agent.
     *
     * To aid emulation, Puppeteer provides a list of known devices that can be
     * via {@link KnownDevices}.
     *
     * @remarks
     * This method is a shortcut for calling two methods:
     * {@link Page.(setUserAgent:2) } and {@link Page.setViewport}.
     *
     * This method will resize the page. A lot of websites don't expect phones to
     * change size, so you should emulate before navigating to the page.
     *
     * @example
     *
     * ```ts
     * import {KnownDevices} from 'puppeteer';
     * const iPhone = KnownDevices['iPhone 15 Pro'];
     *
     * const browser = await puppeteer.launch();
     * const page = await browser.newPage();
     * await page.emulate(iPhone);
     * await page.goto('https://www.google.com');
     * // other actions...
     * await browser.close();
     * ```
     */
    async emulate(c) {
      await Promise.all([
        this.setUserAgent({ userAgent: c.userAgent }),
        this.setViewport(c.viewport)
      ]);
    }
    /**
     * Evaluates a function in the page's context and returns the result.
     *
     * If the function passed to `page.evaluate` returns a Promise, the
     * function will wait for the promise to resolve and return its value.
     *
     * @example
     *
     * ```ts
     * const result = await frame.evaluate(() => {
     *   return Promise.resolve(8 * 7);
     * });
     * console.log(result); // prints "56"
     * ```
     *
     * You can pass a string instead of a function (although functions are
     * recommended as they are easier to debug and use with TypeScript):
     *
     * @example
     *
     * ```ts
     * const aHandle = await page.evaluate('1 + 2');
     * ```
     *
     * To get the best TypeScript experience, you should pass in as the
     * generic the type of `pageFunction`:
     *
     * ```ts
     * const aHandle = await page.evaluate(() => 2);
     * ```
     *
     * @example
     *
     * {@link ElementHandle} instances (including {@link JSHandle}s) can be passed
     * as arguments to the `pageFunction`:
     *
     * ```ts
     * const bodyHandle = await page.$('body');
     * const html = await page.evaluate(body => body.innerHTML, bodyHandle);
     * await bodyHandle.dispose();
     * ```
     *
     * @param pageFunction - a function that is run within the page
     * @param args - arguments to be passed to the pageFunction
     *
     * @returns the return value of `pageFunction`.
     */
    async evaluate(c, ...C) {
      return c = bt(this.evaluate.name, c), await this.mainFrame().evaluate(c, ...C);
    }
    /**
     * @internal
     */
    async _maybeWriteTypedArrayToFile(c, C) {
      c && await cs.value.fs.promises.writeFile(c, C);
    }
    /**
     * Captures a screencast of this {@link Page | page}.
     *
     * @example
     * Recording a {@link Page | page}:
     *
     * ```
     * import puppeteer from 'puppeteer';
     *
     * // Launch a browser
     * const browser = await puppeteer.launch();
     *
     * // Create a new page
     * const page = await browser.newPage();
     *
     * // Go to your site.
     * await page.goto("https://www.example.com");
     *
     * // Start recording.
     * const recorder = await page.screencast({path: 'recording.webm'});
     *
     * // Do something.
     *
     * // Stop recording.
     * await recorder.stop();
     *
     * browser.close();
     * ```
     *
     * @param options - Configures screencast behavior.
     *
     * @experimental
     *
     * @remarks
     *
     * By default, all recordings will be {@link https://www.webmproject.org/ | WebM} format using
     * the {@link https://www.webmproject.org/vp9/ | VP9} video codec, with a frame rate of 30 FPS.
     *
     * You must have {@link https://ffmpeg.org/ | ffmpeg} installed on your system.
     */
    async screencast(c = {}) {
      const C = cs.value.ScreenRecorder, [E, l, B] = await O(this, a, I1).call(this);
      let h;
      if (c.crop) {
        const { x: f, y: p, width: y, height: m } = oR(aR(c.crop));
        if (f < 0 || p < 0)
          throw new Error("`crop.x` and `crop.y` must be greater than or equal to 0.");
        if (y <= 0 || m <= 0)
          throw new Error("`crop.height` and `crop.width` must be greater than or equal to 0.");
        const S = E / B, w = l / B;
        if (f + y > S)
          throw new Error(`\`crop.width\` cannot be larger than the viewport width (${S}).`);
        if (p + m > w)
          throw new Error(`\`crop.height\` cannot be larger than the viewport height (${w}).`);
        h = {
          x: f * B,
          y: p * B,
          width: y * B,
          height: m * B
        };
      }
      if (c.speed !== void 0 && c.speed <= 0)
        throw new Error("`speed` must be greater than 0.");
      if (c.scale !== void 0 && c.scale <= 0)
        throw new Error("`scale` must be greater than 0.");
      const Q = new C(this, E, l, {
        ...c,
        crop: h
      });
      try {
        await this._startScreencast();
      } catch (f) {
        throw Q.stop(), f;
      }
      if (c.path) {
        const { createWriteStream: f } = cs.value.fs, p = f(c.path, "binary");
        Q.pipe(p);
      }
      return Q;
    }
    /**
     * @internal
     */
    async _startScreencast() {
      ++BI(this, n)._, d(this, s) || x(this, s, this.mainFrame().client.send("Page.startScreencast", { format: "png" }).then(() => new Promise((c) => this.mainFrame().client.once("Page.screencastFrame", () => c())))), await d(this, s);
    }
    /**
     * @internal
     */
    async _stopScreencast() {
      --BI(this, n)._, d(this, s) && (x(this, s, void 0), d(this, n) === 0 && await this.mainFrame().client.send("Page.stopScreencast"));
    }
    async screenshot(c = {}) {
      const C = { stack: [], error: void 0, hasError: !1 };
      try {
        const E = Sy(C, await this.browserContext().startScreenshot(), !1), l = {
          ...c,
          clip: c.clip ? {
            ...c.clip
          } : void 0
        };
        if (l.type === void 0 && l.path !== void 0) {
          const f = l.path;
          switch (f.slice(f.lastIndexOf(".") + 1).toLowerCase()) {
            case "png":
              l.type = "png";
              break;
            case "jpeg":
            case "jpg":
              l.type = "jpeg";
              break;
            case "webp":
              l.type = "webp";
              break;
          }
        }
        if (l.quality !== void 0) {
          if (l.quality < 0 || l.quality > 100)
            throw new Error(`Expected 'quality' (${l.quality}) to be between 0 and 100, inclusive.`);
          if (l.type === void 0 || !["jpeg", "webp"].includes(l.type))
            throw new Error(`${l.type ?? "png"} screenshots do not support 'quality'.`);
        }
        if (l.clip) {
          if (l.clip.width <= 0)
            throw new Error("'width' in 'clip' must be positive.");
          if (l.clip.height <= 0)
            throw new Error("'height' in 'clip' must be positive.");
        }
        k7(l);
        const B = Sy(C, new OU(), !0);
        if (l.clip) {
          if (l.fullPage)
            throw new Error("'clip' and 'fullPage' are mutually exclusive");
          l.clip = oR(aR(l.clip));
        } else if (l.fullPage) {
          if (!l.captureBeyondViewport) {
            const f = await this.mainFrame().isolatedRealm().evaluate(() => {
              const y = document.documentElement;
              return {
                width: y.scrollWidth,
                height: y.scrollHeight
              };
            }), p = this.viewport();
            await this.setViewport({
              ...p,
              ...f
            }), B.defer(async () => {
              await this.setViewport(p).catch(HA);
            });
          }
        } else
          l.captureBeyondViewport = !1;
        const h = await this._screenshot(l);
        if (l.encoding === "base64")
          return h;
        const Q = bS(h, !0);
        return await this._maybeWriteTypedArrayToFile(l.path, Q), Q;
      } catch (E) {
        C.error = E, C.hasError = !0;
      } finally {
        const E = sR(C);
        E && await E;
      }
    }
    /**
     * The page's title
     *
     * @remarks
     *
     * Shortcut for {@link Frame.title | page.mainFrame().title()}.
     */
    async title() {
      return await this.mainFrame().title();
    }
    /**
     * This method fetches an element with `selector`, scrolls it into view if
     * needed, and then uses {@link Page.mouse} to click in the center of the
     * element. If there's no element matching `selector`, the method throws an
     * error.
     *
     * @remarks
     *
     * Bear in mind that if `click()` triggers a navigation event and
     * there's a separate `page.waitForNavigation()` promise to be resolved, you
     * may end up with a race condition that yields unexpected results. The
     * correct pattern for click and wait for navigation is the following:
     *
     * ```ts
     * const [response] = await Promise.all([
     *   page.waitForNavigation(waitOptions),
     *   page.click(selector, clickOptions),
     * ]);
     * ```
     *
     * Shortcut for {@link Frame.click | page.mainFrame().click(selector[, options]) }.
     * @param selector -
     * {@link https://pptr.dev/guides/page-interactions#selectors | selector}
     * to query the page for.
     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | CSS selectors}
     * can be passed as-is and a
     * {@link https://pptr.dev/guides/page-interactions#non-css-selectors | Puppeteer-specific selector syntax}
     * allows querying by
     * {@link https://pptr.dev/guides/page-interactions#text-selectors--p-text | text},
     * {@link https://pptr.dev/guides/page-interactions#aria-selectors--p-aria | a11y role and name},
     * and
     * {@link https://pptr.dev/guides/page-interactions#xpath-selectors--p-xpath | xpath}
     * and
     * {@link https://pptr.dev/guides/page-interactions#querying-elements-in-shadow-dom | combining these queries across shadow roots}.
     * Alternatively, you can specify the selector type using a
     * {@link https://pptr.dev/guides/page-interactions#prefixed-selector-syntax | prefix}. If there are
     * multiple elements satisfying the `selector`, the first will be clicked
     * @param options - `Object`
     * @returns Promise which resolves when the element matching `selector` is
     * successfully clicked. The Promise will be rejected if there is no element
     * matching `selector`.
     */
    click(c, C) {
      return this.mainFrame().click(c, C);
    }
    /**
     * This method fetches an element with `selector` and focuses it. If
     * there's no element matching `selector`, the method throws an error.
     * @param selector -
     * {@link https://pptr.dev/guides/page-interactions#selectors | selector}
     * to query the page for.
     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | CSS selectors}
     * can be passed as-is and a
     * {@link https://pptr.dev/guides/page-interactions#non-css-selectors | Puppeteer-specific selector syntax}
     * allows querying by
     * {@link https://pptr.dev/guides/page-interactions#text-selectors--p-text | text},
     * {@link https://pptr.dev/guides/page-interactions#aria-selectors--p-aria | a11y role and name},
     * and
     * {@link https://pptr.dev/guides/page-interactions#xpath-selectors--p-xpath | xpath}
     * and
     * {@link https://pptr.dev/guides/page-interactions#querying-elements-in-shadow-dom | combining these queries across shadow roots}.
     * Alternatively, you can specify the selector type using a
     * {@link https://pptr.dev/guides/page-interactions#prefixed-selector-syntax | prefix}.
     * If there are multiple elements satisfying the selector, the first
     * will be focused.
     * @returns Promise which resolves when the element matching selector
     * is successfully focused. The promise will be rejected if there is
     * no element matching selector.
     *
     * @remarks
     *
     * Shortcut for
     * {@link Frame.focus | page.mainFrame().focus(selector)}.
     */
    focus(c) {
      return this.mainFrame().focus(c);
    }
    /**
     * This method fetches an element with `selector`, scrolls it into view if
     * needed, and then uses {@link Page.mouse}
     * to hover over the center of the element.
     * If there's no element matching `selector`, the method throws an error.
     * @param selector -
     * {@link https://pptr.dev/guides/page-interactions#selectors | selector}
     * to query the page for.
     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | CSS selectors}
     * can be passed as-is and a
     * {@link https://pptr.dev/guides/page-interactions#non-css-selectors | Puppeteer-specific selector syntax}
     * allows querying by
     * {@link https://pptr.dev/guides/page-interactions#text-selectors--p-text | text},
     * {@link https://pptr.dev/guides/page-interactions#aria-selectors--p-aria | a11y role and name},
     * and
     * {@link https://pptr.dev/guides/page-interactions#xpath-selectors--p-xpath | xpath}
     * and
     * {@link https://pptr.dev/guides/page-interactions#querying-elements-in-shadow-dom | combining these queries across shadow roots}.
     * Alternatively, you can specify the selector type using a
     * {@link https://pptr.dev/guides/page-interactions#prefixed-selector-syntax | prefix}. If there are
     * multiple elements satisfying the `selector`, the first will be hovered.
     * @returns Promise which resolves when the element matching `selector` is
     * successfully hovered. Promise gets rejected if there's no element matching
     * `selector`.
     *
     * @remarks
     *
     * Shortcut for {@link Page.hover | page.mainFrame().hover(selector)}.
     */
    hover(c) {
      return this.mainFrame().hover(c);
    }
    /**
     * Triggers a `change` and `input` event once all the provided options have been
     * selected. If there's no `<select>` element matching `selector`, the method
     * throws an error.
     *
     * @example
     *
     * ```ts
     * page.select('select#colors', 'blue'); // single selection
     * page.select('select#colors', 'red', 'green', 'blue'); // multiple selections
     * ```
     *
     * @param selector -
     * {@link https://pptr.dev/guides/page-interactions#selectors | selector}
     * to query the page for.
     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | CSS selectors}
     * can be passed as-is and a
     * {@link https://pptr.dev/guides/page-interactions#non-css-selectors | Puppeteer-specific selector syntax}
     * allows querying by
     * {@link https://pptr.dev/guides/page-interactions#text-selectors--p-text | text},
     * {@link https://pptr.dev/guides/page-interactions#aria-selectors--p-aria | a11y role and name},
     * and
     * {@link https://pptr.dev/guides/page-interactions#xpath-selectors--p-xpath | xpath}
     * and
     * {@link https://pptr.dev/guides/page-interactions#querying-elements-in-shadow-dom | combining these queries across shadow roots}.
     * Alternatively, you can specify the selector type using a
     * {@link https://pptr.dev/guides/page-interactions#prefixed-selector-syntax | prefix}.
     * @param values - Values of options to select. If the `<select>` has the
     * `multiple` attribute, all values are considered, otherwise only the first one
     * is taken into account.
     * @returns
     *
     * @remarks
     *
     * Shortcut for {@link Frame.select | page.mainFrame().select()}
     */
    select(c, ...C) {
      return this.mainFrame().select(c, ...C);
    }
    /**
     * This method fetches an element with `selector`, scrolls it into view if
     * needed, and then uses {@link Page.touchscreen}
     * to tap in the center of the element.
     * If there's no element matching `selector`, the method throws an error.
     * @param selector -
     * {@link https://pptr.dev/guides/page-interactions#selectors | selector}
     * to query the page for.
     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | CSS selectors}
     * can be passed as-is and a
     * {@link https://pptr.dev/guides/page-interactions#non-css-selectors | Puppeteer-specific selector syntax}
     * allows querying by
     * {@link https://pptr.dev/guides/page-interactions#text-selectors--p-text | text},
     * {@link https://pptr.dev/guides/page-interactions#aria-selectors--p-aria | a11y role and name},
     * and
     * {@link https://pptr.dev/guides/page-interactions#xpath-selectors--p-xpath | xpath}
     * and
     * {@link https://pptr.dev/guides/page-interactions#querying-elements-in-shadow-dom | combining these queries across shadow roots}.
     * Alternatively, you can specify the selector type using a
     * {@link https://pptr.dev/guides/page-interactions#prefixed-selector-syntax | prefix}. If there are multiple elements satisfying the
     * selector, the first will be tapped.
     *
     * @remarks
     *
     * Shortcut for {@link Frame.tap | page.mainFrame().tap(selector)}.
     */
    tap(c) {
      return this.mainFrame().tap(c);
    }
    /**
     * Sends a `keydown`, `keypress/input`, and `keyup` event for each character
     * in the text.
     *
     * To press a special key, like `Control` or `ArrowDown`, use {@link Keyboard.press}.
     * @example
     *
     * ```ts
     * await page.type('#mytextarea', 'Hello');
     * // Types instantly
     * await page.type('#mytextarea', 'World', {delay: 100});
     * // Types slower, like a user
     * ```
     *
     * @param selector -
     * {@link https://pptr.dev/guides/page-interactions#selectors | selector}
     * to query the page for.
     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | CSS selectors}
     * can be passed as-is and a
     * {@link https://pptr.dev/guides/page-interactions#non-css-selectors | Puppeteer-specific selector syntax}
     * allows querying by
     * {@link https://pptr.dev/guides/page-interactions#text-selectors--p-text | text},
     * {@link https://pptr.dev/guides/page-interactions#aria-selectors--p-aria | a11y role and name},
     * and
     * {@link https://pptr.dev/guides/page-interactions#xpath-selectors--p-xpath | xpath}
     * and
     * {@link https://pptr.dev/guides/page-interactions#querying-elements-in-shadow-dom | combining these queries across shadow roots}.
     * Alternatively, you can specify the selector type using a
     * {@link https://pptr.dev/guides/page-interactions#prefixed-selector-syntax | prefix}.
     * @param text - A text to type into a focused element.
     * @param options - have property `delay` which is the Time to wait between
     * key presses in milliseconds. Defaults to `0`.
     * @returns
     */
    type(c, C, E) {
      return this.mainFrame().type(c, C, E);
    }
    /**
     * Wait for the `selector` to appear in page. If at the moment of calling the
     * method the `selector` already exists, the method will return immediately. If
     * the `selector` doesn't appear after the `timeout` milliseconds of waiting, the
     * function will throw.
     *
     * @example
     * This method works across navigations:
     *
     * ```ts
     * import puppeteer from 'puppeteer';
     *
     * const browser = await puppeteer.launch();
     * const page = await browser.newPage();
     * let currentURL;
     * page
     *   .waitForSelector('img')
     *   .then(() => console.log('First URL with image: ' + currentURL));
     * for (currentURL of [
     *   'https://example.com',
     *   'https://google.com',
     *   'https://bbc.com',
     * ]) {
     *   await page.goto(currentURL);
     * }
     * await browser.close();
     * ```
     *
     * @param selector -
     * {@link https://pptr.dev/guides/page-interactions#selectors | selector}
     * to query the page for.
     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | CSS selectors}
     * can be passed as-is and a
     * {@link https://pptr.dev/guides/page-interactions#non-css-selectors | Puppeteer-specific selector syntax}
     * allows querying by
     * {@link https://pptr.dev/guides/page-interactions#text-selectors--p-text | text},
     * {@link https://pptr.dev/guides/page-interactions#aria-selectors--p-aria | a11y role and name},
     * and
     * {@link https://pptr.dev/guides/page-interactions#xpath-selectors--p-xpath | xpath}
     * and
     * {@link https://pptr.dev/guides/page-interactions#querying-elements-in-shadow-dom | combining these queries across shadow roots}.
     * Alternatively, you can specify the selector type using a
     * {@link https://pptr.dev/guides/page-interactions#prefixed-selector-syntax | prefix}.
     * @param options - Optional waiting parameters
     * @returns Promise which resolves when element specified by selector string
     * is added to DOM. Resolves to `null` if waiting for hidden: `true` and
     * selector is not found in DOM.
     *
     * @remarks
     * The optional Parameter in Arguments `options` are:
     *
     * - `visible`: A boolean wait for element to be present in DOM and to be
     *   visible, i.e. to not have `display: none` or `visibility: hidden` CSS
     *   properties. Defaults to `false`.
     *
     * - `hidden`: Wait for element to not be found in the DOM or to be hidden,
     *   i.e. have `display: none` or `visibility: hidden` CSS properties. Defaults to
     *   `false`.
     *
     * - `timeout`: maximum time to wait for in milliseconds. Defaults to `30000`
     *   (30 seconds). Pass `0` to disable timeout. The default value can be changed
     *   by using the {@link Page.setDefaultTimeout} method.
     */
    async waitForSelector(c, C = {}) {
      return await this.mainFrame().waitForSelector(c, C);
    }
    /**
     * Waits for the provided function, `pageFunction`, to return a truthy value when
     * evaluated in the page's context.
     *
     * @example
     * {@link Page.waitForFunction} can be used to observe a viewport size change:
     *
     * ```ts
     * import puppeteer from 'puppeteer';
     *
     * const browser = await puppeteer.launch();
     * const page = await browser.newPage();
     * const watchDog = page.waitForFunction('window.innerWidth < 100');
     * await page.setViewport({width: 50, height: 50});
     * await watchDog;
     * await browser.close();
     * ```
     *
     * @example
     * Arguments can be passed from Node.js to `pageFunction`:
     *
     * ```ts
     * const selector = '.foo';
     * await page.waitForFunction(
     *   selector => !!document.querySelector(selector),
     *   {},
     *   selector,
     * );
     * ```
     *
     * @example
     * The provided `pageFunction` can be asynchronous:
     *
     * ```ts
     * const username = 'github-username';
     * await page.waitForFunction(
     *   async username => {
     *     const githubResponse = await fetch(
     *       `https://api.github.com/users/${username}`,
     *     );
     *     const githubUser = await githubResponse.json();
     *     // show the avatar
     *     const img = document.createElement('img');
     *     img.src = githubUser.avatar_url;
     *     // wait 3 seconds
     *     await new Promise((resolve, reject) => setTimeout(resolve, 3000));
     *     img.remove();
     *   },
     *   {},
     *   username,
     * );
     * ```
     *
     * @param pageFunction - Function to be evaluated in browser context until it returns a
     * truthy value.
     * @param options - Options for configuring waiting behavior.
     */
    waitForFunction(c, C, ...E) {
      return this.mainFrame().waitForFunction(c, C, ...E);
    }
    /** @internal */
    [(e = [Hm(function() {
      return this.browser();
    })], ke)]() {
      return void this.close().catch(HA);
    }
    /** @internal */
    [sr]() {
      return this.close();
    }
  }, r = new WeakMap(), i = new WeakMap(), n = new WeakMap(), s = new WeakMap(), a = new WeakSet(), I1 = async function() {
    const c = { stack: [], error: void 0, hasError: !1 };
    try {
      const C = this.viewport(), E = Sy(c, new ms(), !1);
      return C && C.deviceScaleFactor !== 0 && (await this.setViewport({ ...C, deviceScaleFactor: 0 }), E.defer(() => {
        this.setViewport(C).catch(HA);
      })), await this.mainFrame().isolatedRealm().evaluate(() => [
        window.visualViewport.width * window.devicePixelRatio,
        window.visualViewport.height * window.devicePixelRatio,
        window.devicePixelRatio
      ]);
    } catch (C) {
      c.error = C, c.hasError = !0;
    } finally {
      sR(c);
    }
  }, (() => {
    const c = typeof Symbol == "function" && Symbol.metadata ? Object.create(t[Symbol.metadata] ?? null) : void 0;
    F7(o, null, e, { kind: "method", name: "screenshot", static: !1, private: !1, access: { has: (C) => "screenshot" in C, get: (C) => C.screenshot }, metadata: c }, null, A), c && Object.defineProperty(o, Symbol.metadata, { enumerable: !0, configurable: !0, writable: !0, value: c });
  })(), o;
})();
function aR(t) {
  return {
    ...t,
    ...t.width < 0 ? {
      x: t.x + t.width,
      width: -t.width
    } : {
      x: t.x,
      width: t.width
    },
    ...t.height < 0 ? {
      y: t.y + t.height,
      height: -t.height
    } : {
      y: t.y,
      height: t.height
    }
  };
}
function oR(t) {
  const A = Math.round(t.x), e = Math.round(t.y), r = Math.round(t.width + t.x - A), i = Math.round(t.height + t.y - e);
  return { ...t, x: A, y: e, width: r, height: i };
}
/**
 * @license
 * Copyright 2022 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
var jn, Du, Fl, Os, yo, kl, vl, Rl, wo, br, mo, Su, bl;
class R7 {
  constructor(A, e, r, ...i) {
    k(this, jn);
    k(this, Du);
    k(this, Fl);
    k(this, Os);
    k(this, yo);
    k(this, kl);
    k(this, vl, new Error("Waiting failed"));
    k(this, Rl);
    k(this, wo, Ke.create());
    k(this, br);
    k(this, mo);
    k(this, Su, []);
    k(this, bl, () => {
      var A;
      this.terminate((A = d(this, mo)) == null ? void 0 : A.reason);
    });
    var n;
    switch (x(this, jn, A), x(this, Du, e.polling), x(this, Fl, e.root), x(this, mo, e.signal), (n = d(this, mo)) == null || n.addEventListener("abort", d(this, bl), {
      once: !0
    }), typeof r) {
      case "string":
        x(this, Os, `() => {return (${r});}`);
        break;
      default:
        x(this, Os, Ra(r));
        break;
    }
    x(this, yo, i), d(this, jn).taskManager.add(this), e.timeout && (x(this, Rl, new zc(`Waiting failed: ${e.timeout}ms exceeded`)), x(this, kl, setTimeout(() => {
      this.terminate(d(this, Rl));
    }, e.timeout))), this.rerun();
  }
  get result() {
    return d(this, wo).valueOrThrow();
  }
  async rerun() {
    for (const e of d(this, Su))
      e.abort();
    d(this, Su).length = 0;
    const A = new AbortController();
    d(this, Su).push(A);
    try {
      switch (d(this, Du)) {
        case "raf":
          x(this, br, await d(this, jn).evaluateHandle(({ RAFPoller: r, createFunction: i }, n, ...s) => {
            const a = i(n);
            return new r(() => a(...s));
          }, vi.create((r) => r.puppeteerUtil), d(this, Os), ...d(this, yo)));
          break;
        case "mutation":
          x(this, br, await d(this, jn).evaluateHandle(({ MutationPoller: r, createFunction: i }, n, s, ...a) => {
            const g = i(s);
            return new r(() => g(...a), n || document);
          }, vi.create((r) => r.puppeteerUtil), d(this, Fl), d(this, Os), ...d(this, yo)));
          break;
        default:
          x(this, br, await d(this, jn).evaluateHandle(({ IntervalPoller: r, createFunction: i }, n, s, ...a) => {
            const g = i(s);
            return new r(() => g(...a), n);
          }, vi.create((r) => r.puppeteerUtil), d(this, Du), d(this, Os), ...d(this, yo)));
          break;
      }
      await d(this, br).evaluate((r) => {
        r.start();
      });
      const e = await d(this, br).evaluateHandle((r) => r.result());
      d(this, wo).resolve(e), await this.terminate();
    } catch (e) {
      if (A.signal.aborted)
        return;
      const r = this.getBadError(e);
      r && (d(this, vl).cause = r, await this.terminate(d(this, vl)));
    }
  }
  async terminate(A) {
    var e;
    if (d(this, jn).taskManager.delete(this), (e = d(this, mo)) == null || e.removeEventListener("abort", d(this, bl)), clearTimeout(d(this, kl)), A && !d(this, wo).finished() && d(this, wo).reject(A), d(this, br))
      try {
        await d(this, br).evaluate(async (r) => {
          await r.stop();
        }), d(this, br) && (await d(this, br).dispose(), x(this, br, void 0));
      } catch {
      }
  }
  /**
   * Not all errors lead to termination. They usually imply we need to rerun the task.
   */
  getBadError(A) {
    return _i(A) ? A.message.includes("Execution context is not available in detached frame") ? new Error("Waiting failed: Frame detached") : A.message.includes("Execution context was destroyed") || A.message.includes("Cannot find context with specified id") || A.message.includes("DiscardedBrowsingContextError") ? void 0 : A : new Error("WaitTask failed with an error", {
      cause: A
    });
  }
}
jn = new WeakMap(), Du = new WeakMap(), Fl = new WeakMap(), Os = new WeakMap(), yo = new WeakMap(), kl = new WeakMap(), vl = new WeakMap(), Rl = new WeakMap(), wo = new WeakMap(), br = new WeakMap(), mo = new WeakMap(), Su = new WeakMap(), bl = new WeakMap();
var Ys;
class b7 {
  constructor() {
    k(this, Ys, /* @__PURE__ */ new Set());
  }
  add(A) {
    d(this, Ys).add(A);
  }
  delete(A) {
    d(this, Ys).delete(A);
  }
  terminateAll(A) {
    for (const e of d(this, Ys))
      e.terminate(A);
    d(this, Ys).clear();
  }
  async rerunAll() {
    await Promise.all([...d(this, Ys)].map((A) => A.rerun()));
  }
}
Ys = new WeakMap();
/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
var Ml;
class M7 {
  constructor(A) {
    R(this, "timeoutSettings");
    R(this, "taskManager", new b7());
    k(this, Ml, !1);
    this.timeoutSettings = A;
  }
  async waitForFunction(A, e = {}, ...r) {
    const { polling: i = "raf", timeout: n = this.timeoutSettings.timeout(), root: s, signal: a } = e;
    if (typeof i == "number" && i < 0)
      throw new Error("Cannot poll with non-positive interval");
    return await new R7(this, {
      polling: i,
      root: s,
      timeout: n,
      signal: a
    }, A, ...r).result;
  }
  get disposed() {
    return d(this, Ml);
  }
  /** @internal */
  dispose() {
    x(this, Ml, !0), this.taskManager.terminateAll(new Error("waitForFunction failed: frame got detached."));
  }
  /** @internal */
  [ke]() {
    this.dispose();
  }
}
Ml = new WeakMap();
/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
var xr;
(function(t) {
  t.PAGE = "page", t.BACKGROUND_PAGE = "background_page", t.SERVICE_WORKER = "service_worker", t.SHARED_WORKER = "shared_worker", t.BROWSER = "browser", t.WEBVIEW = "webview", t.OTHER = "other", t.TAB = "tab";
})(xr || (xr = {}));
class _7 {
  /**
   * @internal
   */
  constructor() {
  }
  /**
   * If the target is not of type `"service_worker"` or `"shared_worker"`, returns `null`.
   */
  async worker() {
    return null;
  }
  /**
   * If the target is not of type `"page"`, `"webview"` or `"background_page"`,
   * returns `null`.
   */
  async page() {
    return null;
  }
}
/**
 * @license
 * Copyright 2018 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
var _l;
class N7 extends je {
  /**
   * @internal
   */
  constructor(e) {
    super();
    /**
     * @internal
     */
    R(this, "timeoutSettings", new LS());
    k(this, _l);
    x(this, _l, e);
  }
  /**
   * The URL of this web worker.
   */
  url() {
    return d(this, _l);
  }
  /**
   * Evaluates a given function in the {@link WebWorker | worker}.
   *
   * @remarks If the given function returns a promise,
   * {@link WebWorker.evaluate | evaluate} will wait for the promise to resolve.
   *
   * As a rule of thumb, if the return value of the given function is more
   * complicated than a JSON object (e.g. most classes), then
   * {@link WebWorker.evaluate | evaluate} will _likely_ return some truncated
   * value (or `{}`). This is because we are not returning the actual return
   * value, but a deserialized version as a result of transferring the return
   * value through a protocol to Puppeteer.
   *
   * In general, you should use
   * {@link WebWorker.evaluateHandle | evaluateHandle} if
   * {@link WebWorker.evaluate | evaluate} cannot serialize the return value
   * properly or you need a mutable {@link JSHandle | handle} to the return
   * object.
   *
   * @param func - Function to be evaluated.
   * @param args - Arguments to pass into `func`.
   * @returns The result of `func`.
   */
  async evaluate(e, ...r) {
    return e = bt(this.evaluate.name, e), await this.mainRealm().evaluate(e, ...r);
  }
  /**
   * Evaluates a given function in the {@link WebWorker | worker}.
   *
   * @remarks If the given function returns a promise,
   * {@link WebWorker.evaluate | evaluate} will wait for the promise to resolve.
   *
   * In general, you should use
   * {@link WebWorker.evaluateHandle | evaluateHandle} if
   * {@link WebWorker.evaluate | evaluate} cannot serialize the return value
   * properly or you need a mutable {@link JSHandle | handle} to the return
   * object.
   *
   * @param func - Function to be evaluated.
   * @param args - Arguments to pass into `func`.
   * @returns A {@link JSHandle | handle} to the return value of `func`.
   */
  async evaluateHandle(e, ...r) {
    return e = bt(this.evaluateHandle.name, e), await this.mainRealm().evaluateHandle(e, ...r);
  }
  async close() {
    throw new _S("WebWorker.close() is not supported");
  }
}
_l = new WeakMap();
/**
 * @license
 * Copyright 2018 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
var C1 = function(t, A, e) {
  if (A != null) {
    if (typeof A != "object" && typeof A != "function") throw new TypeError("Object expected.");
    var r, i;
    if (e) {
      if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
      r = A[Symbol.asyncDispose];
    }
    if (r === void 0) {
      if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
      r = A[Symbol.dispose], e && (i = r);
    }
    if (typeof r != "function") throw new TypeError("Object not disposable.");
    i && (r = function() {
      try {
        i.call(this);
      } catch (n) {
        return Promise.reject(n);
      }
    }), t.stack.push({ value: A, dispose: r, async: e });
  } else e && t.stack.push({ async: !0 });
  return A;
}, l1 = /* @__PURE__ */ function(t) {
  return function(A) {
    function e(s) {
      A.error = A.hasError ? new t(s, A.error, "An error was suppressed during disposal.") : s, A.hasError = !0;
    }
    var r, i = 0;
    function n() {
      for (; r = A.stack.pop(); )
        try {
          if (!r.async && i === 1) return i = 0, A.stack.push(r), Promise.resolve().then(n);
          if (r.dispose) {
            var s = r.dispose.call(r.value);
            if (r.async) return i |= 2, Promise.resolve(s).then(n, function(a) {
              return e(a), n();
            });
          } else i |= 1;
        } catch (a) {
          e(a);
        }
      if (i === 1) return A.hasError ? Promise.reject(A.error) : Promise.resolve();
      if (A.hasError) throw A.error;
    }
    return n();
  };
}(typeof SuppressedError == "function" ? SuppressedError : function(t, A, e) {
  var r = new Error(e);
  return r.name = "SuppressedError", r.error = t, r.suppressed = A, r;
}), qs, Nl;
class L7 {
  /**
   * @internal
   */
  constructor(A, e = "") {
    k(this, qs);
    k(this, Nl);
    x(this, qs, A), x(this, Nl, e);
  }
  /**
   * Captures the current state of the accessibility tree.
   * The returned object represents the root accessible node of the page.
   *
   * @remarks
   *
   * **NOTE** The Chrome accessibility tree contains nodes that go unused on
   * most platforms and by most screen readers. Puppeteer will discard them as
   * well for an easier to process tree, unless `interestingOnly` is set to
   * `false`.
   *
   * @example
   * An example of dumping the entire accessibility tree:
   *
   * ```ts
   * const snapshot = await page.accessibility.snapshot();
   * console.log(snapshot);
   * ```
   *
   * @example
   * An example of logging the focused node's name:
   *
   * ```ts
   * const snapshot = await page.accessibility.snapshot();
   * const node = findFocusedNode(snapshot);
   * console.log(node && node.name);
   *
   * function findFocusedNode(node) {
   *   if (node.focused) return node;
   *   for (const child of node.children || []) {
   *     const foundNode = findFocusedNode(child);
   *     return foundNode;
   *   }
   *   return null;
   * }
   * ```
   *
   * @returns An AXNode object representing the snapshot.
   */
  async snapshot(A = {}) {
    const { interestingOnly: e = !0, root: r = null, includeIframes: i = !1 } = A, { nodes: n } = await d(this, qs).environment.client.send("Accessibility.getFullAXTree", {
      frameId: d(this, Nl)
    });
    let s;
    if (r) {
      const { node: I } = await d(this, qs).environment.client.send("DOM.describeNode", {
        objectId: r.id
      });
      s = I.backendNodeId;
    }
    const a = Vm.createTree(d(this, qs), n), g = async (I) => {
      var c;
      if (((c = I.payload.role) == null ? void 0 : c.value) === "Iframe") {
        const C = { stack: [], error: void 0, hasError: !1 };
        try {
          if (!I.payload.backendDOMNodeId)
            return;
          const E = C1(C, await d(this, qs).adoptBackendNode(I.payload.backendDOMNodeId), !1);
          if (!E || !("contentFrame" in E))
            return;
          const l = await E.contentFrame();
          if (!l)
            return;
          try {
            const B = await l.accessibility.snapshot(A);
            I.iframeSnapshot = B ?? void 0;
          } catch (B) {
            HA(B);
          }
        } catch (E) {
          C.error = E, C.hasError = !0;
        } finally {
          l1(C);
        }
      }
      for (const C of I.children)
        await g(C);
    };
    let o = a;
    if (!a || (i && await g(a), s && (o = a.find((I) => I.payload.backendDOMNodeId === s)), !o))
      return null;
    if (!e)
      return this.serializeTree(o)[0] ?? null;
    const u = /* @__PURE__ */ new Set();
    return this.collectInterestingNodes(u, a, !1), this.serializeTree(o, u)[0] ?? null;
  }
  serializeTree(A, e) {
    const r = [];
    for (const n of A.children)
      r.push(...this.serializeTree(n, e));
    if (e && !e.has(A))
      return r;
    const i = A.serialize();
    return r.length && (i.children = r), A.iframeSnapshot && (i.children || (i.children = []), i.children.push(A.iframeSnapshot)), [i];
  }
  collectInterestingNodes(A, e, r) {
    if ((e.isInteresting(r) || e.iframeSnapshot) && A.add(e), !e.isLeafNode()) {
      r = r || e.isControl();
      for (const i of e.children)
        this.collectInterestingNodes(A, i, r);
    }
  }
}
qs = new WeakMap(), Nl = new WeakMap();
var Fu, Ll, ku, xl, vu, Br, Gl, Do, Ul, ds, B1, E1, Zm;
const eF = class eF {
  constructor(A, e) {
    k(this, ds);
    R(this, "payload");
    R(this, "children", []);
    R(this, "iframeSnapshot");
    k(this, Fu, !1);
    k(this, Ll, !1);
    k(this, ku, !1);
    k(this, xl, !1);
    k(this, vu);
    k(this, Br);
    k(this, Gl);
    k(this, Do);
    k(this, Ul);
    this.payload = e, x(this, vu, this.payload.name ? this.payload.name.value : ""), x(this, Br, this.payload.role ? this.payload.role.value : "Unknown"), x(this, Gl, this.payload.ignored), x(this, Ul, A);
    for (const r of this.payload.properties || [])
      r.name === "editable" && (x(this, Fu, r.value.value === "richtext"), x(this, Ll, !0)), r.name === "focusable" && x(this, ku, r.value.value), r.name === "hidden" && x(this, xl, r.value.value);
  }
  find(A) {
    if (A(this))
      return this;
    for (const e of this.children) {
      const r = e.find(A);
      if (r)
        return r;
    }
    return null;
  }
  isLeafNode() {
    if (!this.children.length || O(this, ds, B1).call(this) || O(this, ds, E1).call(this))
      return !0;
    switch (d(this, Br)) {
      case "doc-cover":
      case "graphics-symbol":
      case "img":
      case "image":
      case "Meter":
      case "scrollbar":
      case "slider":
      case "separator":
      case "progressbar":
        return !0;
    }
    return O(this, ds, Zm).call(this) ? !1 : !!(d(this, Br) === "heading" && d(this, vu));
  }
  isControl() {
    switch (d(this, Br)) {
      case "button":
      case "checkbox":
      case "ColorWell":
      case "combobox":
      case "DisclosureTriangle":
      case "listbox":
      case "menu":
      case "menubar":
      case "menuitem":
      case "menuitemcheckbox":
      case "menuitemradio":
      case "radio":
      case "scrollbar":
      case "searchbox":
      case "slider":
      case "spinbutton":
      case "switch":
      case "tab":
      case "textbox":
      case "tree":
      case "treeitem":
        return !0;
      default:
        return !1;
    }
  }
  isLandmark() {
    switch (d(this, Br)) {
      case "banner":
      case "complementary":
      case "contentinfo":
      case "form":
      case "main":
      case "navigation":
      case "region":
      case "search":
        return !0;
      default:
        return !1;
    }
  }
  isInteresting(A) {
    return d(this, Br) === "Ignored" || d(this, xl) || d(this, Gl) ? !1 : this.isLandmark() || d(this, ku) || d(this, Fu) || this.isControl() ? !0 : A ? !1 : this.isLeafNode() && !!d(this, vu);
  }
  serialize() {
    const A = /* @__PURE__ */ new Map();
    for (const c of this.payload.properties || [])
      A.set(c.name.toLowerCase(), c.value.value);
    this.payload.name && A.set("name", this.payload.name.value), this.payload.value && A.set("value", this.payload.value.value), this.payload.description && A.set("description", this.payload.description.value);
    const e = {
      role: d(this, Br),
      elementHandle: async () => {
        const c = { stack: [], error: void 0, hasError: !1 };
        try {
          return this.payload.backendDOMNodeId ? await C1(c, await d(this, Ul).adoptBackendNode(this.payload.backendDOMNodeId), !1).evaluateHandle((E) => E.nodeType === Node.TEXT_NODE ? E.parentElement : E) : null;
        } catch (C) {
          c.error = C, c.hasError = !0;
        } finally {
          l1(c);
        }
      },
      backendNodeId: this.payload.backendDOMNodeId
    }, r = [
      "name",
      "value",
      "description",
      "keyshortcuts",
      "roledescription",
      "valuetext",
      "url"
    ], i = (c) => A.get(c);
    for (const c of r)
      A.has(c) && (e[c] = i(c));
    const n = [
      "disabled",
      "expanded",
      "focused",
      "modal",
      "multiline",
      "multiselectable",
      "readonly",
      "required",
      "selected"
    ], s = (c) => A.get(c);
    for (const c of n)
      c === "focused" && d(this, Br) === "RootWebArea" || s(c) === void 0 || (e[c] = s(c));
    const a = ["checked", "pressed"];
    for (const c of a) {
      if (!A.has(c))
        continue;
      const C = A.get(c);
      e[c] = C === "mixed" ? "mixed" : C === "true";
    }
    const g = [
      "level",
      "valuemax",
      "valuemin"
    ], o = (c) => A.get(c);
    for (const c of g)
      A.has(c) && (e[c] = o(c));
    const u = [
      "autocomplete",
      "haspopup",
      "invalid",
      "orientation"
    ], I = (c) => A.get(c);
    for (const c of u) {
      const C = I(c);
      !C || C === "false" || (e[c] = I(c));
    }
    return e;
  }
  static createTree(A, e) {
    const r = /* @__PURE__ */ new Map();
    for (const i of e)
      r.set(i.nodeId, new eF(A, i));
    for (const i of r.values())
      for (const n of i.payload.childIds || []) {
        const s = r.get(n);
        s && i.children.push(s);
      }
    return r.values().next().value ?? null;
  }
};
Fu = new WeakMap(), Ll = new WeakMap(), ku = new WeakMap(), xl = new WeakMap(), vu = new WeakMap(), Br = new WeakMap(), Gl = new WeakMap(), Do = new WeakMap(), Ul = new WeakMap(), ds = new WeakSet(), B1 = function() {
  return d(this, Fu) ? !1 : d(this, Ll) ? !0 : d(this, Br) === "textbox" || d(this, Br) === "searchbox";
}, E1 = function() {
  const A = d(this, Br);
  return A === "LineBreak" || A === "text" || A === "InlineTextBox" || A === "StaticText";
}, Zm = function() {
  var A;
  if (d(this, Do) === void 0) {
    x(this, Do, !1);
    for (const e of this.children)
      if (d(e, ku) || O(A = e, ds, Zm).call(A)) {
        x(this, Do, !0);
        break;
      }
  }
  return d(this, Do);
};
let Vm = eF;
var x7 = function(t, A, e) {
  if (A != null) {
    if (typeof A != "object" && typeof A != "function") throw new TypeError("Object expected.");
    var r, i;
    if (e) {
      if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
      r = A[Symbol.asyncDispose];
    }
    if (r === void 0) {
      if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
      r = A[Symbol.dispose], e && (i = r);
    }
    if (typeof r != "function") throw new TypeError("Object not disposable.");
    i && (r = function() {
      try {
        i.call(this);
      } catch (n) {
        return Promise.reject(n);
      }
    }), t.stack.push({ value: A, dispose: r, async: e });
  } else e && t.stack.push({ async: !0 });
  return A;
}, G7 = /* @__PURE__ */ function(t) {
  return function(A) {
    function e(s) {
      A.error = A.hasError ? new t(s, A.error, "An error was suppressed during disposal.") : s, A.hasError = !0;
    }
    var r, i = 0;
    function n() {
      for (; r = A.stack.pop(); )
        try {
          if (!r.async && i === 1) return i = 0, A.stack.push(r), Promise.resolve().then(n);
          if (r.dispose) {
            var s = r.dispose.call(r.value);
            if (r.async) return i |= 2, Promise.resolve(s).then(n, function(a) {
              return e(a), n();
            });
          } else i |= 1;
        } catch (a) {
          e(a);
        }
      if (i === 1) return A.hasError ? Promise.reject(A.error) : Promise.resolve();
      if (A.hasError) throw A.error;
    }
    return n();
  };
}(typeof SuppressedError == "function" ? SuppressedError : function(t, A, e) {
  var r = new Error(e);
  return r.name = "SuppressedError", r.error = t, r.suppressed = A, r;
}), Wn, Tl, Kl;
class $d {
  constructor(A, e, r) {
    k(this, Wn);
    k(this, Tl);
    k(this, Kl);
    x(this, Wn, A), x(this, Tl, e), x(this, Kl, r);
  }
  get name() {
    return d(this, Wn);
  }
  get initSource() {
    return d(this, Kl);
  }
  /**
   * @param context - Context to run the binding in; the context should have
   * the binding added to it beforehand.
   * @param id - ID of the call. This should come from the CDP
   * `onBindingCalled` response.
   * @param args - Plain arguments from CDP.
   */
  async run(A, e, r, i) {
    const n = new ms();
    try {
      if (!i) {
        const s = { stack: [], error: void 0, hasError: !1 };
        try {
          const g = await x7(s, await A.evaluateHandle((o, u) => globalThis[o].args.get(u), d(this, Wn), e), !1).getProperties();
          for (const [o, u] of g)
            if (o in r)
              switch (u.remoteObject().subtype) {
                case "node":
                  r[+o] = u;
                  break;
                default:
                  n.use(u);
              }
            else
              n.use(u);
        } catch (a) {
          s.error = a, s.hasError = !0;
        } finally {
          G7(s);
        }
      }
      await A.evaluate((s, a, g) => {
        const o = globalThis[s].callbacks;
        o.get(a).resolve(g), o.delete(a);
      }, d(this, Wn), e, await d(this, Tl).call(this, ...r));
      for (const s of r)
        s instanceof gu && n.use(s);
    } catch (s) {
      _i(s) ? await A.evaluate((a, g, o, u) => {
        const I = new Error(o);
        I.stack = u;
        const c = globalThis[a].callbacks;
        c.get(g).reject(I), c.delete(g);
      }, d(this, Wn), e, s.message, s.stack).catch(HA) : await A.evaluate((a, g, o) => {
        const u = globalThis[a].callbacks;
        u.get(g).reject(o), u.delete(g);
      }, d(this, Wn), e, s).catch(HA);
    }
  }
}
Wn = new WeakMap(), Tl = new WeakMap(), Kl = new WeakMap();
var js;
class U7 {
  constructor(A) {
    k(this, js);
    x(this, js, A);
  }
  async emulateAdapter(A, e = !0) {
    await d(this, js).send("BluetoothEmulation.disable"), await d(this, js).send("BluetoothEmulation.enable", {
      state: A,
      leSupported: e
    });
  }
  async disableEmulation() {
    await d(this, js).send("BluetoothEmulation.disable");
  }
  async simulatePreconnectedPeripheral(A) {
    await d(this, js).send("BluetoothEmulation.simulatePreconnectedPeripheral", A);
  }
}
js = new WeakMap();
/**
 * @license
 * Copyright 2020 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
var Jl, Hl, Pl, Ru, bu, Ol;
class gR {
  /**
   * @internal
   */
  constructor(A, e, r, i, n, s) {
    k(this, Jl);
    k(this, Hl);
    k(this, Pl);
    k(this, Ru);
    k(this, bu);
    k(this, Ol);
    x(this, Jl, A), x(this, Hl, e), x(this, Pl, r), x(this, Ru, i), x(this, bu, n), x(this, Ol, s);
  }
  /**
   * The type of the console message.
   */
  type() {
    return d(this, Jl);
  }
  /**
   * The text of the console message.
   */
  text() {
    return d(this, Hl);
  }
  /**
   * An array of arguments passed to the console.
   */
  args() {
    return d(this, Pl);
  }
  /**
   * The location of the console message.
   */
  location() {
    return d(this, Ru)[0] ?? (d(this, bu) ? { url: d(this, bu).url() } : {});
  }
  /**
   * The array of locations on the stack of the console message.
   */
  stackTrace() {
    return d(this, Ru);
  }
  /**
   * The underlying protocol stack trace if available.
   *
   * @internal
   */
  _rawStackTrace() {
    return d(this, Ol);
  }
}
Jl = new WeakMap(), Hl = new WeakMap(), Pl = new WeakMap(), Ru = new WeakMap(), bu = new WeakMap(), Ol = new WeakMap();
/**
 * @license
 * Copyright 2020 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
var Mu, Yl, So;
class T7 {
  /**
   * @internal
   */
  constructor(A, e) {
    k(this, Mu);
    k(this, Yl);
    k(this, So, !1);
    x(this, Mu, A), x(this, Yl, e);
  }
  /**
   * Whether file chooser allow for
   * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/file#attr-multiple | multiple}
   * file selection.
   */
  isMultiple() {
    return d(this, Yl);
  }
  /**
   * Accept the file chooser request with the given file paths.
   *
   * @remarks This will not validate whether the file paths exists. Also, if a
   * path is relative, then it is resolved against the
   * {@link https://nodejs.org/api/process.html#process_process_cwd | current working directory}.
   * For locals script connecting to remote chrome environments, paths must be
   * absolute.
   */
  async accept(A) {
    bA(!d(this, So), "Cannot accept FileChooser which is already handled!"), x(this, So, !0), await d(this, Mu).uploadFile(...A);
  }
  /**
   * Closes the file chooser without selecting any files.
   */
  async cancel() {
    bA(!d(this, So), "Cannot cancel FileChooser which is already handled!"), x(this, So, !0), await d(this, Mu).evaluate((A) => {
      A.dispatchEvent(new Event("cancel", { bubbles: !0 }));
    });
  }
}
Mu = new WeakMap(), Yl = new WeakMap(), So = new WeakMap();
/**
 * @license
 * Copyright 2022 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
var kt;
(function(t) {
  t.Request = Symbol("NetworkManager.Request"), t.RequestServedFromCache = Symbol("NetworkManager.RequestServedFromCache"), t.Response = Symbol("NetworkManager.Response"), t.RequestFailed = Symbol("NetworkManager.RequestFailed"), t.RequestFinished = Symbol("NetworkManager.RequestFinished");
})(kt || (kt = {}));
/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
var Vr, ql;
class h1 {
  constructor(A) {
    k(this, Vr, /* @__PURE__ */ new Map());
    k(this, ql);
    x(this, ql, A);
  }
  create(A, e, r) {
    const i = new K7(d(this, ql).call(this), A, e);
    d(this, Vr).set(i.id, i);
    try {
      r(i.id);
    } catch (n) {
      throw i.promise.catch(HA).finally(() => {
        d(this, Vr).delete(i.id);
      }), i.reject(n), n;
    }
    return i.promise.finally(() => {
      d(this, Vr).delete(i.id);
    });
  }
  reject(A, e, r) {
    const i = d(this, Vr).get(A);
    i && this._reject(i, e, r);
  }
  rejectRaw(A, e) {
    const r = d(this, Vr).get(A);
    r && r.reject(e);
  }
  _reject(A, e, r) {
    let i, n;
    e instanceof Qg ? (i = e, i.cause = A.error, n = e.message) : (i = A.error, n = e), A.reject(zU(i, `Protocol error (${A.label}): ${n}`, r));
  }
  resolve(A, e) {
    const r = d(this, Vr).get(A);
    r && r.resolve(e);
  }
  clear() {
    for (const A of d(this, Vr).values())
      this._reject(A, new Da("Target closed"));
    d(this, Vr).clear();
  }
  /**
   * @internal
   */
  getPendingProtocolErrors() {
    const A = [];
    for (const e of d(this, Vr).values())
      A.push(new Error(`${e.label} timed out. Trace: ${e.error.stack}`));
    return A;
  }
}
Vr = new WeakMap(), ql = new WeakMap();
var jl, Wl, Fo, _u, Vl;
class K7 {
  constructor(A, e, r) {
    k(this, jl);
    k(this, Wl, new Qg());
    k(this, Fo, Ke.create());
    k(this, _u);
    k(this, Vl);
    x(this, jl, A), x(this, Vl, e), r && x(this, _u, setTimeout(() => {
      d(this, Fo).reject(zU(d(this, Wl), `${e} timed out. Increase the 'protocolTimeout' setting in launch/connect calls for a higher timeout if needed.`));
    }, r));
  }
  resolve(A) {
    clearTimeout(d(this, _u)), d(this, Fo).resolve(A);
  }
  reject(A) {
    clearTimeout(d(this, _u)), d(this, Fo).reject(A);
  }
  get id() {
    return d(this, jl);
  }
  get promise() {
    return d(this, Fo).valueOrThrow();
  }
  get error() {
    return d(this, Wl);
  }
  get label() {
    return d(this, Vl);
  }
}
jl = new WeakMap(), Wl = new WeakMap(), Fo = new WeakMap(), _u = new WeakMap(), Vl = new WeakMap();
/**
 * @license
 * Copyright 2017 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
var ko, Nu, Vi, Vn, Lu, xu, Zl, Gu;
class uu extends XU {
  /**
   * @internal
   */
  constructor(e, r, i, n, s) {
    super();
    k(this, ko);
    k(this, Nu);
    k(this, Vi);
    k(this, Vn);
    k(this, Lu);
    k(this, xu);
    k(this, Zl, !1);
    k(this, Gu, !1);
    x(this, Vn, e), x(this, Nu, r), x(this, Vi, new h1(e._idGenerator)), x(this, ko, i), x(this, Lu, n), x(this, Zl, s);
  }
  /**
   * Sets the {@link CdpTarget} associated with the session instance.
   *
   * @internal
   */
  setTarget(e) {
    x(this, xu, e);
  }
  /**
   * Gets the {@link CdpTarget} associated with the session instance.
   *
   * @internal
   */
  target() {
    return bA(d(this, xu), "Target must exist"), d(this, xu);
  }
  connection() {
    return d(this, Vn);
  }
  get detached() {
    return d(this, Vn)._closed || d(this, Gu);
  }
  parentSession() {
    var r;
    return d(this, Lu) ? ((r = d(this, Vn)) == null ? void 0 : r.session(d(this, Lu))) ?? void 0 : this;
  }
  send(e, r, i) {
    return this.detached ? Promise.reject(new Da(`Protocol error (${e}): Session closed. Most likely the ${d(this, Nu)} has been closed.`)) : d(this, Vn)._rawSend(d(this, Vi), e, r, d(this, ko), i);
  }
  /**
   * @internal
   */
  onMessage(e) {
    e.id ? e.error ? d(this, Zl) ? d(this, Vi).rejectRaw(e.id, e.error) : d(this, Vi).reject(e.id, $U(e), e.error.message) : d(this, Vi).resolve(e.id, e.result) : (bA(!e.id), this.emit(e.method, e.params));
  }
  /**
   * Detaches the cdpSession from the target. Once detached, the cdpSession object
   * won't emit any events and can't be used to send messages.
   */
  async detach() {
    if (this.detached)
      throw new Error(`Session already detached. Most likely the ${d(this, Nu)} has been closed.`);
    await d(this, Vn).send("Target.detachFromTarget", {
      sessionId: d(this, ko)
    }), x(this, Gu, !0);
  }
  /**
   * @internal
   */
  onClosed() {
    d(this, Vi).clear(), x(this, Gu, !0), this.emit(He.Disconnected, void 0);
  }
  /**
   * Returns the session's id.
   */
  id() {
    return d(this, ko);
  }
  /**
   * @internal
   */
  getPendingProtocolErrors() {
    return d(this, Vi).getPendingProtocolErrors();
  }
}
ko = new WeakMap(), Nu = new WeakMap(), Vi = new WeakMap(), Vn = new WeakMap(), Lu = new WeakMap(), xu = new WeakMap(), Zl = new WeakMap(), Gu = new WeakMap();
/**
 * @license
 * Copyright 2017 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
const J7 = MS("puppeteer:protocol:SEND â–º"), H7 = MS("puppeteer:protocol:RECV â—€");
var Xl, Zi, vo, Uu, rr, Ro, Tu, Xi, Ku, zl, $l, Xm;
class Af extends je {
  constructor(e, r, i = 0, n, s = !1, a = qE()) {
    super();
    k(this, $l);
    k(this, Xl);
    k(this, Zi);
    k(this, vo);
    k(this, Uu);
    k(this, rr, /* @__PURE__ */ new Map());
    k(this, Ro, !1);
    k(this, Tu, /* @__PURE__ */ new Set());
    k(this, Xi);
    k(this, Ku, !1);
    k(this, zl);
    x(this, Ku, s), x(this, zl, a), x(this, Xi, new h1(a)), x(this, Xl, e), x(this, vo, i), x(this, Uu, n ?? 18e4), x(this, Zi, r), d(this, Zi).onmessage = this.onMessage.bind(this), d(this, Zi).onclose = O(this, $l, Xm).bind(this);
  }
  static fromSession(e) {
    return e.connection();
  }
  /**
   * @internal
   */
  get delay() {
    return d(this, vo);
  }
  get timeout() {
    return d(this, Uu);
  }
  /**
   * @internal
   */
  get _closed() {
    return d(this, Ro);
  }
  /**
   * @internal
   */
  get _idGenerator() {
    return d(this, zl);
  }
  /**
   * @internal
   */
  get _sessions() {
    return d(this, rr);
  }
  /**
   * @internal
   */
  _session(e) {
    return d(this, rr).get(e) || null;
  }
  /**
   * @param sessionId - The session id
   * @returns The current CDP session if it exists
   */
  session(e) {
    return this._session(e);
  }
  url() {
    return d(this, Xl);
  }
  send(e, r, i) {
    return this._rawSend(d(this, Xi), e, r, void 0, i);
  }
  /**
   * @internal
   */
  _rawSend(e, r, i, n, s) {
    return d(this, Ro) ? Promise.reject(new D$("Connection closed.")) : e.create(r, (s == null ? void 0 : s.timeout) ?? d(this, Uu), (a) => {
      const g = JSON.stringify({
        method: r,
        params: i,
        id: a,
        sessionId: n
      });
      J7(g), d(this, Zi).send(g);
    });
  }
  /**
   * @internal
   */
  async closeBrowser() {
    await this.send("Browser.close");
  }
  /**
   * @internal
   */
  async onMessage(e) {
    d(this, vo) && await new Promise((i) => setTimeout(i, d(this, vo))), H7(e);
    const r = JSON.parse(e);
    if (r.method === "Target.attachedToTarget") {
      const i = r.params.sessionId, n = new uu(this, r.params.targetInfo.type, i, r.sessionId, d(this, Ku));
      d(this, rr).set(i, n), this.emit(He.SessionAttached, n);
      const s = d(this, rr).get(r.sessionId);
      s && s.emit(He.SessionAttached, n);
    } else if (r.method === "Target.detachedFromTarget") {
      const i = d(this, rr).get(r.params.sessionId);
      if (i) {
        i.onClosed(), d(this, rr).delete(r.params.sessionId), this.emit(He.SessionDetached, i);
        const n = d(this, rr).get(r.sessionId);
        n && n.emit(He.SessionDetached, i);
      }
    }
    if (r.sessionId) {
      const i = d(this, rr).get(r.sessionId);
      i && i.onMessage(r);
    } else r.id ? r.error ? d(this, Ku) ? d(this, Xi).rejectRaw(r.id, r.error) : d(this, Xi).reject(r.id, $U(r), r.error.message) : d(this, Xi).resolve(r.id, r.result) : this.emit(r.method, r.params);
  }
  dispose() {
    O(this, $l, Xm).call(this), d(this, Zi).close();
  }
  /**
   * @internal
   */
  isAutoAttached(e) {
    return !d(this, Tu).has(e);
  }
  /**
   * @internal
   */
  async _createSession(e, r = !0) {
    r || d(this, Tu).add(e.targetId);
    const { sessionId: i } = await this.send("Target.attachToTarget", {
      targetId: e.targetId,
      flatten: !0
    });
    d(this, Tu).delete(e.targetId);
    const n = d(this, rr).get(i);
    if (!n)
      throw new Error("CDPSession creation failed.");
    return n;
  }
  /**
   * @param targetInfo - The target info
   * @returns The CDP session that is created
   */
  async createSession(e) {
    return await this._createSession(e, !1);
  }
  /**
   * @internal
   */
  getPendingProtocolErrors() {
    const e = [];
    e.push(...d(this, Xi).getPendingProtocolErrors());
    for (const r of d(this, rr).values())
      e.push(...r.getPendingProtocolErrors());
    return e;
  }
}
Xl = new WeakMap(), Zi = new WeakMap(), vo = new WeakMap(), Uu = new WeakMap(), rr = new WeakMap(), Ro = new WeakMap(), Tu = new WeakMap(), Xi = new WeakMap(), Ku = new WeakMap(), zl = new WeakMap(), $l = new WeakSet(), Xm = function() {
  if (!d(this, Ro)) {
    x(this, Ro, !0), d(this, Zi).onmessage = void 0, d(this, Zi).onclose = void 0, d(this, Xi).clear();
    for (const e of d(this, rr).values())
      e.onClosed();
    d(this, rr).clear(), this.emit(He.Disconnected, void 0);
  }
};
function ef(t) {
  return t instanceof Da;
}
/**
 * @license
 * Copyright 2017 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
var bo, Mo;
class P7 {
  /**
   * @internal
   */
  constructor(A) {
    k(this, bo);
    k(this, Mo);
    x(this, bo, new O7(A)), x(this, Mo, new Y7(A));
  }
  /**
   * @internal
   */
  updateClient(A) {
    d(this, bo).updateClient(A), d(this, Mo).updateClient(A);
  }
  /**
   * @param options - Set of configurable options for coverage defaults to
   * `resetOnNavigation : true, reportAnonymousScripts : false,`
   * `includeRawScriptCoverage : false, useBlockCoverage : true`
   * @returns Promise that resolves when coverage is started.
   *
   * @remarks
   * Anonymous scripts are ones that don't have an associated url. These are
   * scripts that are dynamically created on the page using `eval` or
   * `new Function`. If `reportAnonymousScripts` is set to `true`, anonymous
   * scripts URL will start with `debugger://VM` (unless a magic //# sourceURL
   * comment is present, in which case that will the be URL).
   */
  async startJSCoverage(A = {}) {
    return await d(this, bo).start(A);
  }
  /**
   * Promise that resolves to the array of coverage reports for
   * all scripts.
   *
   * @remarks
   * JavaScript Coverage doesn't include anonymous scripts by default.
   * However, scripts with sourceURLs are reported.
   */
  async stopJSCoverage() {
    return await d(this, bo).stop();
  }
  /**
   * @param options - Set of configurable options for coverage, defaults to
   * `resetOnNavigation : true`
   * @returns Promise that resolves when coverage is started.
   */
  async startCSSCoverage(A = {}) {
    return await d(this, Mo).start(A);
  }
  /**
   * Promise that resolves to the array of coverage reports
   * for all stylesheets.
   *
   * @remarks
   * CSS Coverage doesn't include dynamically injected style tags
   * without sourceURLs.
   */
  async stopCSSCoverage() {
    return await d(this, Mo).stop();
  }
}
bo = new WeakMap(), Mo = new WeakMap();
var ir, _o, No, Lo, Ju, AB, Hu, Pu, eI, Q1, d1;
class O7 {
  /**
   * @internal
   */
  constructor(A) {
    k(this, eI);
    k(this, ir);
    k(this, _o, !1);
    k(this, No, /* @__PURE__ */ new Map());
    k(this, Lo, /* @__PURE__ */ new Map());
    k(this, Ju);
    k(this, AB, !1);
    k(this, Hu, !1);
    k(this, Pu, !1);
    x(this, ir, A);
  }
  /**
   * @internal
   */
  updateClient(A) {
    x(this, ir, A);
  }
  async start(A = {}) {
    bA(!d(this, _o), "JSCoverage is already enabled");
    const { resetOnNavigation: e = !0, reportAnonymousScripts: r = !1, includeRawScriptCoverage: i = !1, useBlockCoverage: n = !0 } = A;
    x(this, AB, e), x(this, Hu, r), x(this, Pu, i), x(this, _o, !0), d(this, No).clear(), d(this, Lo).clear(), x(this, Ju, new ms());
    const s = d(this, Ju).use(new je(d(this, ir)));
    s.on("Debugger.scriptParsed", O(this, eI, d1).bind(this)), s.on("Runtime.executionContextsCleared", O(this, eI, Q1).bind(this)), await Promise.all([
      d(this, ir).send("Profiler.enable"),
      d(this, ir).send("Profiler.startPreciseCoverage", {
        callCount: d(this, Pu),
        detailed: n
      }),
      d(this, ir).send("Debugger.enable"),
      d(this, ir).send("Debugger.setSkipAllPauses", { skip: !0 })
    ]);
  }
  async stop() {
    var i;
    bA(d(this, _o), "JSCoverage is not enabled"), x(this, _o, !1);
    const A = await Promise.all([
      d(this, ir).send("Profiler.takePreciseCoverage"),
      d(this, ir).send("Profiler.stopPreciseCoverage"),
      d(this, ir).send("Profiler.disable"),
      d(this, ir).send("Debugger.disable")
    ]);
    (i = d(this, Ju)) == null || i.dispose();
    const e = [], r = A[0];
    for (const n of r.result) {
      let s = d(this, No).get(n.scriptId);
      !s && d(this, Hu) && (s = "debugger://VM" + n.scriptId);
      const a = d(this, Lo).get(n.scriptId);
      if (a === void 0 || s === void 0)
        continue;
      const g = [];
      for (const u of n.functions)
        g.push(...u.ranges);
      const o = y1(g);
      d(this, Pu) ? e.push({ url: s, ranges: o, text: a, rawScriptCoverage: n }) : e.push({ url: s, ranges: o, text: a });
    }
    return e;
  }
}
ir = new WeakMap(), _o = new WeakMap(), No = new WeakMap(), Lo = new WeakMap(), Ju = new WeakMap(), AB = new WeakMap(), Hu = new WeakMap(), Pu = new WeakMap(), eI = new WeakSet(), Q1 = function() {
  d(this, AB) && (d(this, No).clear(), d(this, Lo).clear());
}, d1 = async function(A) {
  if (!Is.isPuppeteerURL(A.url) && !(!A.url && !d(this, Hu)))
    try {
      const e = await d(this, ir).send("Debugger.getScriptSource", {
        scriptId: A.scriptId
      });
      d(this, No).set(A.scriptId, A.url), d(this, Lo).set(A.scriptId, e.scriptSource);
    } catch (e) {
      HA(e);
    }
};
var Mr, xo, Ws, Go, Ou, eB, tI, f1, p1;
class Y7 {
  constructor(A) {
    k(this, tI);
    k(this, Mr);
    k(this, xo, !1);
    k(this, Ws, /* @__PURE__ */ new Map());
    k(this, Go, /* @__PURE__ */ new Map());
    k(this, Ou);
    k(this, eB, !1);
    x(this, Mr, A);
  }
  /**
   * @internal
   */
  updateClient(A) {
    x(this, Mr, A);
  }
  async start(A = {}) {
    bA(!d(this, xo), "CSSCoverage is already enabled");
    const { resetOnNavigation: e = !0 } = A;
    x(this, eB, e), x(this, xo, !0), d(this, Ws).clear(), d(this, Go).clear(), x(this, Ou, new ms());
    const r = d(this, Ou).use(new je(d(this, Mr)));
    r.on("CSS.styleSheetAdded", O(this, tI, p1).bind(this)), r.on("Runtime.executionContextsCleared", O(this, tI, f1).bind(this)), await Promise.all([
      d(this, Mr).send("DOM.enable"),
      d(this, Mr).send("CSS.enable"),
      d(this, Mr).send("CSS.startRuleUsageTracking")
    ]);
  }
  async stop() {
    var i;
    bA(d(this, xo), "CSSCoverage is not enabled"), x(this, xo, !1);
    const A = await d(this, Mr).send("CSS.stopRuleUsageTracking");
    await Promise.all([
      d(this, Mr).send("CSS.disable"),
      d(this, Mr).send("DOM.disable")
    ]), (i = d(this, Ou)) == null || i.dispose();
    const e = /* @__PURE__ */ new Map();
    for (const n of A.ruleUsage) {
      let s = e.get(n.styleSheetId);
      s || (s = [], e.set(n.styleSheetId, s)), s.push({
        startOffset: n.startOffset,
        endOffset: n.endOffset,
        count: n.used ? 1 : 0
      });
    }
    const r = [];
    for (const n of d(this, Ws).keys()) {
      const s = d(this, Ws).get(n);
      bA(typeof s < "u", `Stylesheet URL is undefined (styleSheetId=${n})`);
      const a = d(this, Go).get(n);
      bA(typeof a < "u", `Stylesheet text is undefined (styleSheetId=${n})`);
      const g = y1(e.get(n) || []);
      r.push({ url: s, ranges: g, text: a });
    }
    return r;
  }
}
Mr = new WeakMap(), xo = new WeakMap(), Ws = new WeakMap(), Go = new WeakMap(), Ou = new WeakMap(), eB = new WeakMap(), tI = new WeakSet(), f1 = function() {
  d(this, eB) && (d(this, Ws).clear(), d(this, Go).clear());
}, p1 = async function(A) {
  const e = A.header;
  if (e.sourceURL)
    try {
      const r = await d(this, Mr).send("CSS.getStyleSheetText", {
        styleSheetId: e.styleSheetId
      });
      d(this, Ws).set(e.styleSheetId, e.sourceURL), d(this, Go).set(e.styleSheetId, r.text);
    } catch (r) {
      HA(r);
    }
};
function y1(t) {
  const A = [];
  for (const n of t)
    A.push({ offset: n.startOffset, type: 0, range: n }), A.push({ offset: n.endOffset, type: 1, range: n });
  A.sort((n, s) => {
    if (n.offset !== s.offset)
      return n.offset - s.offset;
    if (n.type !== s.type)
      return s.type - n.type;
    const a = n.range.endOffset - n.range.startOffset, g = s.range.endOffset - s.range.startOffset;
    return n.type === 0 ? g - a : a - g;
  });
  const e = [], r = [];
  let i = 0;
  for (const n of A) {
    if (e.length && i < n.offset && e[e.length - 1] > 0) {
      const s = r[r.length - 1];
      s && s.end === i ? s.end = n.offset : r.push({ start: i, end: n.offset });
    }
    i = n.offset, n.type === 0 ? e.push(n.range.count) : e.pop();
  }
  return r.filter((n) => n.end - n.start > 0);
}
/**
 * @license
 * Copyright 2017 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
var tB;
class q7 extends G$ {
  constructor(e, r, i, n = "") {
    super(r, i, n);
    k(this, tB);
    x(this, tB, e);
  }
  async handle(e) {
    await d(this, tB).send("Page.handleJavaScriptDialog", {
      accept: e.accept,
      promptText: e.text
    });
  }
}
tB = new WeakMap();
var j7 = function(t, A, e) {
  for (var r = arguments.length > 2, i = 0; i < A.length; i++)
    e = r ? A[i].call(t, e) : A[i].call(t);
  return r ? e : void 0;
}, si = function(t, A, e, r, i, n) {
  function s(h) {
    if (h !== void 0 && typeof h != "function") throw new TypeError("Function expected");
    return h;
  }
  for (var a = r.kind, g = a === "getter" ? "get" : a === "setter" ? "set" : "value", o = !A && t ? r.static ? t : t.prototype : null, u = A || (o ? Object.getOwnPropertyDescriptor(o, r.name) : {}), I, c = !1, C = e.length - 1; C >= 0; C--) {
    var E = {};
    for (var l in r) E[l] = l === "access" ? {} : r[l];
    for (var l in r.access) E.access[l] = r.access[l];
    E.addInitializer = function(h) {
      if (c) throw new TypeError("Cannot add initializers after decoration has completed");
      n.push(s(h || null));
    };
    var B = (0, e[C])(a === "accessor" ? { get: u.get, set: u.set } : u[g], E);
    if (a === "accessor") {
      if (B === void 0) continue;
      if (B === null || typeof B != "object") throw new TypeError("Object expected");
      (I = s(B.get)) && (u.get = I), (I = s(B.set)) && (u.set = I), (I = s(B.init)) && i.unshift(I);
    } else (I = s(B)) && (a === "field" ? i.unshift(I) : u[g] = I);
  }
  o && Object.defineProperty(o, r.name, u), c = !0;
}, ai = function(t, A, e) {
  return typeof A == "symbol" && (A = A.description ? "[".concat(A.description, "]") : ""), Object.defineProperty(t, "name", { configurable: !0, value: e ? "".concat(e, " ", A) : A });
}, Uo, Yu, rB;
class oi {
  constructor(A, e, r) {
    k(this, Uo);
    k(this, Yu);
    k(this, rB);
    x(this, Uo, A), x(this, Yu, e), x(this, rB, r), d(this, Yu).registerState(this);
  }
  async setState(A) {
    x(this, Uo, A), await this.sync();
  }
  get state() {
    return d(this, Uo);
  }
  async sync() {
    await Promise.all(d(this, Yu).clients().map((A) => d(this, rB).call(this, A, d(this, Uo))));
  }
}
Uo = new WeakMap(), Yu = new WeakMap(), rB = new WeakMap();
let W7 = (() => {
  var S, w, F, b, G, T, K, H, j, eA, sA, uA, rA, hA, UA, iA, wA, zm, $m, AD, eD, tD, rD, iD, nD, sD, aD, oD, Z;
  let t = [], A, e, r, i, n, s, a, g, o, u, I, c, C, E, l, B, h, Q, f, p, y, m;
  return Z = class {
    constructor(X) {
      k(this, wA);
      k(this, S, j7(this, t));
      k(this, w, !1);
      k(this, F, !1);
      k(this, b, []);
      k(this, G, new oi({
        active: !1
      }, this, d(this, wA, zm)));
      k(this, T, new oi({
        active: !1
      }, this, d(this, wA, $m)));
      k(this, K, new oi({
        active: !1
      }, this, d(this, wA, AD)));
      k(this, H, new oi({
        active: !1
      }, this, d(this, wA, eD)));
      k(this, j, new oi({
        active: !1
      }, this, d(this, wA, tD)));
      k(this, eA, new oi({
        active: !1
      }, this, d(this, wA, rD)));
      k(this, sA, new oi({
        active: !1
      }, this, d(this, wA, iD)));
      k(this, uA, new oi({
        active: !1
      }, this, d(this, wA, nD)));
      k(this, rA, new oi({
        active: !1
      }, this, d(this, wA, sD)));
      k(this, hA, new oi({
        javaScriptEnabled: !0,
        active: !1
      }, this, d(this, wA, aD)));
      k(this, UA, new oi({
        enabled: !0,
        active: !1
      }, this, d(this, wA, oD)));
      k(this, iA, /* @__PURE__ */ new Set());
      x(this, S, X);
    }
    updateClient(X) {
      x(this, S, X), d(this, iA).delete(X);
    }
    registerState(X) {
      d(this, b).push(X);
    }
    clients() {
      return [d(this, S), ...Array.from(d(this, iA))];
    }
    async registerSpeculativeSession(X) {
      d(this, iA).add(X), X.once(He.Disconnected, () => {
        d(this, iA).delete(X);
      }), Promise.all(d(this, b).map((z) => z.sync().catch(HA)));
    }
    get javascriptEnabled() {
      return d(this, hA).state.javaScriptEnabled;
    }
    async emulateViewport(X) {
      const z = d(this, G).state;
      if (!X && !z.active)
        return !1;
      await d(this, G).setState(X ? {
        viewport: X,
        active: !0
      } : {
        active: !1
      });
      const SA = (X == null ? void 0 : X.isMobile) || !1, aA = (X == null ? void 0 : X.hasTouch) || !1, Ae = d(this, w) !== SA || d(this, F) !== aA;
      return x(this, w, SA), x(this, F, aA), Ae;
    }
    async emulateIdleState(X) {
      await d(this, T).setState({
        active: !0,
        overrides: X
      });
    }
    async emulateTimezone(X) {
      await d(this, K).setState({
        timezoneId: X,
        active: !0
      });
    }
    async emulateVisionDeficiency(X) {
      bA(!X || (/* @__PURE__ */ new Set([
        "none",
        "achromatopsia",
        "blurredVision",
        "deuteranopia",
        "protanopia",
        "reducedContrast",
        "tritanopia"
      ])).has(X), `Unsupported vision deficiency: ${X}`), await d(this, H).setState({
        active: !0,
        visionDeficiency: X
      });
    }
    async emulateCPUThrottling(X) {
      bA(X === null || X >= 1, "Throttling rate should be greater or equal to 1"), await d(this, j).setState({
        active: !0,
        factor: X ?? void 0
      });
    }
    async emulateMediaFeatures(X) {
      if (Array.isArray(X))
        for (const z of X) {
          const SA = z.name;
          bA(/^(?:prefers-(?:color-scheme|reduced-motion)|color-gamut)$/.test(SA), "Unsupported media feature: " + SA);
        }
      await d(this, eA).setState({
        active: !0,
        mediaFeatures: X
      });
    }
    async emulateMediaType(X) {
      bA(X === "screen" || X === "print" || (X ?? void 0) === void 0, "Unsupported media type: " + X), await d(this, sA).setState({
        type: X,
        active: !0
      });
    }
    async setGeolocation(X) {
      const { longitude: z, latitude: SA, accuracy: aA = 0 } = X;
      if (z < -180 || z > 180)
        throw new Error(`Invalid longitude "${z}": precondition -180 <= LONGITUDE <= 180 failed.`);
      if (SA < -90 || SA > 90)
        throw new Error(`Invalid latitude "${SA}": precondition -90 <= LATITUDE <= 90 failed.`);
      if (aA < 0)
        throw new Error(`Invalid accuracy "${aA}": precondition 0 <= ACCURACY failed.`);
      await d(this, uA).setState({
        active: !0,
        geoLocation: {
          longitude: z,
          latitude: SA,
          accuracy: aA
        }
      });
    }
    /**
     * Resets default white background
     */
    async resetDefaultBackgroundColor() {
      await d(this, rA).setState({
        active: !0,
        color: void 0
      });
    }
    /**
     * Hides default white background
     */
    async setTransparentBackgroundColor() {
      await d(this, rA).setState({
        active: !0,
        color: { r: 0, g: 0, b: 0, a: 0 }
      });
    }
    async setJavaScriptEnabled(X) {
      await d(this, hA).setState({
        active: !0,
        javaScriptEnabled: X
      });
    }
    async emulateFocus(X) {
      await d(this, UA).setState({
        active: !0,
        enabled: X
      });
    }
  }, S = new WeakMap(), w = new WeakMap(), F = new WeakMap(), b = new WeakMap(), G = new WeakMap(), T = new WeakMap(), K = new WeakMap(), H = new WeakMap(), j = new WeakMap(), eA = new WeakMap(), sA = new WeakMap(), uA = new WeakMap(), rA = new WeakMap(), hA = new WeakMap(), UA = new WeakMap(), iA = new WeakMap(), wA = new WeakSet(), zm = function() {
    return e.value;
  }, $m = function() {
    return i.value;
  }, AD = function() {
    return s.value;
  }, eD = function() {
    return g.value;
  }, tD = function() {
    return u.value;
  }, rD = function() {
    return c.value;
  }, iD = function() {
    return E.value;
  }, nD = function() {
    return B.value;
  }, sD = function() {
    return Q.value;
  }, aD = function() {
    return p.value;
  }, oD = function() {
    return m.value;
  }, (() => {
    const X = typeof Symbol == "function" && Symbol.metadata ? /* @__PURE__ */ Object.create(null) : void 0;
    A = [ni], r = [ni], n = [ni], a = [ni], o = [ni], I = [ni], C = [ni], l = [ni], h = [ni], f = [ni], y = [ni], si(Z, e = { value: ai(async function(z, SA) {
      if (!SA.viewport) {
        await Promise.all([
          z.send("Emulation.clearDeviceMetricsOverride"),
          z.send("Emulation.setTouchEmulationEnabled", {
            enabled: !1
          })
        ]).catch(HA);
        return;
      }
      const { viewport: aA } = SA, Ae = aA.isMobile || !1, vA = aA.width, RA = aA.height, MA = aA.deviceScaleFactor ?? 1, BA = aA.isLandscape ? { angle: 90, type: "landscapePrimary" } : { angle: 0, type: "portraitPrimary" }, pA = aA.hasTouch || !1;
      await Promise.all([
        z.send("Emulation.setDeviceMetricsOverride", {
          mobile: Ae,
          width: vA,
          height: RA,
          deviceScaleFactor: MA,
          screenOrientation: BA
        }).catch((EA) => {
          if (EA.message.includes("Target does not support metrics override")) {
            HA(EA);
            return;
          }
          throw EA;
        }),
        z.send("Emulation.setTouchEmulationEnabled", {
          enabled: pA
        })
      ]);
    }, "#applyViewport") }, A, { kind: "method", name: "#applyViewport", static: !1, private: !0, access: { has: (z) => Cr(wA, z), get: (z) => d(z, wA, zm) }, metadata: X }, null, t), si(Z, i = { value: ai(async function(z, SA) {
      SA.active && (SA.overrides ? await z.send("Emulation.setIdleOverride", {
        isUserActive: SA.overrides.isUserActive,
        isScreenUnlocked: SA.overrides.isScreenUnlocked
      }) : await z.send("Emulation.clearIdleOverride"));
    }, "#emulateIdleState") }, r, { kind: "method", name: "#emulateIdleState", static: !1, private: !0, access: { has: (z) => Cr(wA, z), get: (z) => d(z, wA, $m) }, metadata: X }, null, t), si(Z, s = { value: ai(async function(z, SA) {
      if (SA.active)
        try {
          await z.send("Emulation.setTimezoneOverride", {
            timezoneId: SA.timezoneId || ""
          });
        } catch (aA) {
          throw _i(aA) && aA.message.includes("Invalid timezone") ? new Error(`Invalid timezone ID: ${SA.timezoneId}`) : aA;
        }
    }, "#emulateTimezone") }, n, { kind: "method", name: "#emulateTimezone", static: !1, private: !0, access: { has: (z) => Cr(wA, z), get: (z) => d(z, wA, AD) }, metadata: X }, null, t), si(Z, g = { value: ai(async function(z, SA) {
      SA.active && await z.send("Emulation.setEmulatedVisionDeficiency", {
        type: SA.visionDeficiency || "none"
      });
    }, "#emulateVisionDeficiency") }, a, { kind: "method", name: "#emulateVisionDeficiency", static: !1, private: !0, access: { has: (z) => Cr(wA, z), get: (z) => d(z, wA, eD) }, metadata: X }, null, t), si(Z, u = { value: ai(async function(z, SA) {
      SA.active && await z.send("Emulation.setCPUThrottlingRate", {
        rate: SA.factor ?? 1
      });
    }, "#emulateCpuThrottling") }, o, { kind: "method", name: "#emulateCpuThrottling", static: !1, private: !0, access: { has: (z) => Cr(wA, z), get: (z) => d(z, wA, tD) }, metadata: X }, null, t), si(Z, c = { value: ai(async function(z, SA) {
      SA.active && await z.send("Emulation.setEmulatedMedia", {
        features: SA.mediaFeatures
      });
    }, "#emulateMediaFeatures") }, I, { kind: "method", name: "#emulateMediaFeatures", static: !1, private: !0, access: { has: (z) => Cr(wA, z), get: (z) => d(z, wA, rD) }, metadata: X }, null, t), si(Z, E = { value: ai(async function(z, SA) {
      SA.active && await z.send("Emulation.setEmulatedMedia", {
        media: SA.type || ""
      });
    }, "#emulateMediaType") }, C, { kind: "method", name: "#emulateMediaType", static: !1, private: !0, access: { has: (z) => Cr(wA, z), get: (z) => d(z, wA, iD) }, metadata: X }, null, t), si(Z, B = { value: ai(async function(z, SA) {
      SA.active && await z.send("Emulation.setGeolocationOverride", SA.geoLocation ? {
        longitude: SA.geoLocation.longitude,
        latitude: SA.geoLocation.latitude,
        accuracy: SA.geoLocation.accuracy
      } : void 0);
    }, "#setGeolocation") }, l, { kind: "method", name: "#setGeolocation", static: !1, private: !0, access: { has: (z) => Cr(wA, z), get: (z) => d(z, wA, nD) }, metadata: X }, null, t), si(Z, Q = { value: ai(async function(z, SA) {
      SA.active && await z.send("Emulation.setDefaultBackgroundColorOverride", {
        color: SA.color
      });
    }, "#setDefaultBackgroundColor") }, h, { kind: "method", name: "#setDefaultBackgroundColor", static: !1, private: !0, access: { has: (z) => Cr(wA, z), get: (z) => d(z, wA, sD) }, metadata: X }, null, t), si(Z, p = { value: ai(async function(z, SA) {
      SA.active && await z.send("Emulation.setScriptExecutionDisabled", {
        value: !SA.javaScriptEnabled
      });
    }, "#setJavaScriptEnabled") }, f, { kind: "method", name: "#setJavaScriptEnabled", static: !1, private: !0, access: { has: (z) => Cr(wA, z), get: (z) => d(z, wA, aD) }, metadata: X }, null, t), si(Z, m = { value: ai(async function(z, SA) {
      SA.active && await z.send("Emulation.setFocusEmulationEnabled", {
        enabled: SA.enabled
      });
    }, "#emulateFocus") }, y, { kind: "method", name: "#emulateFocus", static: !1, private: !0, access: { has: (z) => Cr(wA, z), get: (z) => d(z, wA, oD) }, metadata: X }, null, t), X && Object.defineProperty(Z, Symbol.metadata, { enumerable: !0, configurable: !0, writable: !0, value: X });
  })(), Z;
})();
/**
 * @license
 * Copyright 2024 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
var iB, nB, qu;
class V7 {
  constructor(A, e, r) {
    /**
     * This is the ID of the preload script returned by
     * Page.addScriptToEvaluateOnNewDocument in the main frame.
     *
     * Sub-frames would get a different CDP ID because
     * addScriptToEvaluateOnNewDocument is called for each subframe. But
     * users only see this ID and subframe IDs are internal to Puppeteer.
     */
    k(this, iB);
    k(this, nB);
    k(this, qu, /* @__PURE__ */ new WeakMap());
    x(this, iB, e), x(this, nB, r), d(this, qu).set(A, e);
  }
  get id() {
    return d(this, iB);
  }
  get source() {
    return d(this, nB);
  }
  getIdForFrame(A) {
    return d(this, qu).get(A);
  }
  setIdForFrame(A, e) {
    d(this, qu).set(A, e);
  }
}
iB = new WeakMap(), nB = new WeakMap(), qu = new WeakMap();
/**
 * @license
 * Copyright 2022 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
var _r, sB, To, Ko, ju, Wu, aB, gD;
class Z7 extends x$ {
  constructor(e, r, i) {
    super();
    k(this, aB);
    k(this, _r);
    k(this, sB);
    k(this, To);
    k(this, Ko, !1);
    k(this, ju, O(this, aB, gD).bind(this));
    k(this, Wu, /* @__PURE__ */ new Set());
    x(this, _r, e), x(this, sB, r), x(this, To, i.id), d(this, _r).on("DeviceAccess.deviceRequestPrompted", d(this, ju)), d(this, _r).on("Target.detachedFromTarget", () => {
      x(this, _r, null);
    }), O(this, aB, gD).call(this, i);
  }
  async waitForDevice(e, r = {}) {
    for (const a of this.devices)
      if (e(a))
        return a;
    const { timeout: i = d(this, sB).timeout() } = r, n = Ke.create({
      message: `Waiting for \`DeviceRequestPromptDevice\` failed: ${i}ms exceeded`,
      timeout: i
    });
    r.signal && r.signal.addEventListener("abort", () => {
      var a;
      n.reject((a = r.signal) == null ? void 0 : a.reason);
    }, { once: !0 });
    const s = { filter: e, promise: n };
    d(this, Wu).add(s);
    try {
      return await n.valueOrThrow();
    } finally {
      d(this, Wu).delete(s);
    }
  }
  async select(e) {
    return bA(d(this, _r) !== null, "Cannot select device through detached session!"), bA(this.devices.includes(e), "Cannot select unknown device!"), bA(!d(this, Ko), "Cannot select DeviceRequestPrompt which is already handled!"), d(this, _r).off("DeviceAccess.deviceRequestPrompted", d(this, ju)), x(this, Ko, !0), await d(this, _r).send("DeviceAccess.selectPrompt", {
      id: d(this, To),
      deviceId: e.id
    });
  }
  async cancel() {
    return bA(d(this, _r) !== null, "Cannot cancel prompt through detached session!"), bA(!d(this, Ko), "Cannot cancel DeviceRequestPrompt which is already handled!"), d(this, _r).off("DeviceAccess.deviceRequestPrompted", d(this, ju)), x(this, Ko, !0), await d(this, _r).send("DeviceAccess.cancelPrompt", { id: d(this, To) });
  }
}
_r = new WeakMap(), sB = new WeakMap(), To = new WeakMap(), Ko = new WeakMap(), ju = new WeakMap(), Wu = new WeakMap(), aB = new WeakSet(), gD = function(e) {
  if (e.id === d(this, To))
    for (const r of e.devices) {
      if (this.devices.some((n) => n.id === r.id))
        continue;
      const i = { id: r.id, name: r.name };
      this.devices.push(i);
      for (const n of d(this, Wu))
        n.filter(i) && n.promise.resolve(i);
    }
};
var pi, Vu, Zn, ff, w1;
class X7 {
  constructor(A, e) {
    k(this, ff);
    k(this, pi);
    k(this, Vu);
    k(this, Zn, /* @__PURE__ */ new Set());
    x(this, pi, A), x(this, Vu, e), d(this, pi).on("DeviceAccess.deviceRequestPrompted", (r) => {
      O(this, ff, w1).call(this, r);
    }), d(this, pi).on("Target.detachedFromTarget", () => {
      x(this, pi, null);
    });
  }
  async waitForDevicePrompt(A = {}) {
    bA(d(this, pi) !== null, "Cannot wait for device prompt through detached session!");
    const e = d(this, Zn).size === 0;
    let r;
    e && (r = d(this, pi).send("DeviceAccess.enable"));
    const { timeout: i = d(this, Vu).timeout() } = A, n = Ke.create({
      message: `Waiting for \`DeviceRequestPrompt\` failed: ${i}ms exceeded`,
      timeout: i
    });
    A.signal && A.signal.addEventListener("abort", () => {
      var s;
      n.reject((s = A.signal) == null ? void 0 : s.reason);
    }, { once: !0 }), d(this, Zn).add(n);
    try {
      const [s] = await Promise.all([
        n.valueOrThrow(),
        r
      ]);
      return s;
    } finally {
      d(this, Zn).delete(n);
    }
  }
}
pi = new WeakMap(), Vu = new WeakMap(), Zn = new WeakMap(), ff = new WeakSet(), w1 = function(A) {
  if (!d(this, Zn).size)
    return;
  bA(d(this, pi) !== null);
  const e = new Z7(d(this, pi), d(this, Vu), A);
  for (const r of d(this, Zn))
    r.resolve(e);
  d(this, Zn).clear();
};
/**
 * @license
 * Copyright 2017 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
function uR(t) {
  let A, e;
  if (!t.exception)
    A = "Error", e = t.text;
  else {
    if ((t.exception.type !== "object" || t.exception.subtype !== "error") && !t.exception.objectId)
      return dg(t.exception);
    {
      const a = m1(t);
      A = a.name, e = a.message;
    }
  }
  const r = e.split(`
`).length, i = new Error(e);
  i.name = A;
  const n = i.stack.split(`
`), s = n.splice(0, r);
  if (n.shift(), t.stackTrace && n.length < Error.stackTraceLimit)
    for (const a of t.stackTrace.callFrames.reverse()) {
      if (Is.isPuppeteerURL(a.url) && a.url !== Is.INTERNAL_URL) {
        const g = Is.parse(a.url);
        n.unshift(`    at ${a.functionName || g.functionName} (${g.functionName} at ${g.siteString}, <anonymous>:${a.lineNumber}:${a.columnNumber})`);
      } else
        n.push(`    at ${a.functionName || "<anonymous>"} (${a.url}:${a.lineNumber}:${a.columnNumber})`);
      if (n.length >= Error.stackTraceLimit)
        break;
    }
  return i.stack = [...s, ...n].join(`
`), i;
}
const m1 = (t) => {
  var n, s, a, g;
  let A = "", e;
  const r = ((s = (n = t.exception) == null ? void 0 : n.description) == null ? void 0 : s.split(`
    at `)) ?? [], i = Math.min(((a = t.stackTrace) == null ? void 0 : a.callFrames.length) ?? 0, r.length - 1);
  return r.splice(-i, i), (g = t.exception) != null && g.className && (A = t.exception.className), e = r.join(`
`), A && e.startsWith(`${A}: `) && (e = e.slice(A.length + 2)), { message: e, name: A };
};
function z7(t) {
  let A, e;
  if (!t.exception)
    A = "Error", e = t.text;
  else {
    if ((t.exception.type !== "object" || t.exception.subtype !== "error") && !t.exception.objectId)
      return dg(t.exception);
    {
      const a = m1(t);
      A = a.name, e = a.message;
    }
  }
  const r = new Error(e);
  r.name = A;
  const i = r.message.split(`
`).length, n = r.stack.split(`
`).splice(0, i), s = [];
  if (t.stackTrace) {
    for (const a of t.stackTrace.callFrames)
      if (s.push(`    at ${a.functionName || "<anonymous>"} (${a.url}:${a.lineNumber + 1}:${a.columnNumber + 1})`), s.length >= Error.stackTraceLimit)
        break;
  }
  return r.stack = [...n, ...s].join(`
`), r;
}
function dg(t) {
  if (bA(!t.objectId, "Cannot extract value when objectId is given"), t.unserializableValue) {
    if (t.type === "bigint")
      return BigInt(t.unserializableValue.replace("n", ""));
    switch (t.unserializableValue) {
      case "-0":
        return -0;
      case "NaN":
        return NaN;
      case "Infinity":
        return 1 / 0;
      case "-Infinity":
        return -1 / 0;
      default:
        throw new Error("Unsupported unserializable value: " + t.unserializableValue);
    }
  }
  return t.value;
}
function D1(t, A, e) {
  globalThis[A] || Object.assign(globalThis, {
    [A](...r) {
      const i = globalThis[A];
      i.args ?? (i.args = /* @__PURE__ */ new Map()), i.callbacks ?? (i.callbacks = /* @__PURE__ */ new Map());
      const n = (i.lastSeq ?? 0) + 1;
      return i.lastSeq = n, i.args.set(n, r), globalThis[e + A](JSON.stringify({
        type: t,
        name: A,
        seq: n,
        args: r,
        isTrivial: !r.some((s) => s instanceof Node)
      })), new Promise((s, a) => {
        i.callbacks.set(n, {
          resolve(g) {
            i.args.delete(n), s(g);
          },
          reject(g) {
            i.args.delete(n), a(g);
          }
        });
      });
    }
  });
}
const cu = "puppeteer_";
function $7(t, A) {
  return WU(D1, t, A, cu);
}
/**
 * @license
 * Copyright 2019 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
var Zu, Er, Xu;
class Sp extends gu {
  constructor(e, r) {
    super();
    k(this, Zu, !1);
    k(this, Er);
    k(this, Xu);
    x(this, Xu, e), x(this, Er, r);
  }
  get disposed() {
    return d(this, Zu);
  }
  get realm() {
    return d(this, Xu);
  }
  get client() {
    return this.realm.environment.client;
  }
  async jsonValue() {
    if (!d(this, Er).objectId)
      return dg(d(this, Er));
    const e = await this.evaluate((r) => r);
    if (e === void 0)
      throw new Error("Could not serialize referenced object");
    return e;
  }
  /**
   * Either `null` or the handle itself if the handle is an
   * instance of {@link ElementHandle}.
   */
  asElement() {
    return null;
  }
  async dispose() {
    d(this, Zu) || (x(this, Zu, !0), await S1(this.client, d(this, Er)));
  }
  toString() {
    return d(this, Er).objectId ? "JSHandle@" + (d(this, Er).subtype || d(this, Er).type) : "JSHandle:" + dg(d(this, Er));
  }
  get id() {
    return d(this, Er).objectId;
  }
  remoteObject() {
    return d(this, Er);
  }
  async getProperties() {
    const e = await this.client.send("Runtime.getProperties", {
      objectId: d(this, Er).objectId,
      ownProperties: !0
    }), r = /* @__PURE__ */ new Map();
    for (const i of e.result)
      !i.enumerable || !i.value || r.set(i.name, d(this, Xu).createCdpHandle(i.value));
    return r;
  }
}
Zu = new WeakMap(), Er = new WeakMap(), Xu = new WeakMap();
async function S1(t, A) {
  A.objectId && await t.send("Runtime.releaseObject", { objectId: A.objectId }).catch((e) => {
    HA(e);
  });
}
/**
 * @license
 * Copyright 2019 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
var AAA = function(t, A, e) {
  for (var r = arguments.length > 2, i = 0; i < A.length; i++)
    e = r ? A[i].call(t, e) : A[i].call(t);
  return r ? e : void 0;
}, bh = function(t, A, e, r, i, n) {
  function s(h) {
    if (h !== void 0 && typeof h != "function") throw new TypeError("Function expected");
    return h;
  }
  for (var a = r.kind, g = a === "getter" ? "get" : a === "setter" ? "set" : "value", o = !A && t ? r.static ? t : t.prototype : null, u = A || (o ? Object.getOwnPropertyDescriptor(o, r.name) : {}), I, c = !1, C = e.length - 1; C >= 0; C--) {
    var E = {};
    for (var l in r) E[l] = l === "access" ? {} : r[l];
    for (var l in r.access) E.access[l] = r.access[l];
    E.addInitializer = function(h) {
      if (c) throw new TypeError("Cannot add initializers after decoration has completed");
      n.push(s(h || null));
    };
    var B = (0, e[C])(a === "accessor" ? { get: u.get, set: u.set } : u[g], E);
    if (a === "accessor") {
      if (B === void 0) continue;
      if (B === null || typeof B != "object") throw new TypeError("Object expected");
      (I = s(B.get)) && (u.get = I), (I = s(B.set)) && (u.set = I), (I = s(B.init)) && i.unshift(I);
    } else (I = s(B)) && (a === "field" ? i.unshift(I) : u[g] = I);
  }
  o && Object.defineProperty(o, r.name, u), c = !0;
};
const eAA = /* @__PURE__ */ new Set(["StaticText", "InlineTextBox"]);
let F1 = (() => {
  var s, a, k1, o;
  let t = E7, A = [], e, r, i, n;
  return o = class extends t {
    constructor(c, C) {
      super(new Sp(c, C));
      k(this, a);
      k(this, s, AAA(this, A));
    }
    get realm() {
      return this.handle.realm;
    }
    get client() {
      return this.handle.client;
    }
    remoteObject() {
      return this.handle.remoteObject();
    }
    get frame() {
      return this.realm.environment;
    }
    async contentFrame() {
      const c = await this.client.send("DOM.describeNode", {
        objectId: this.id
      });
      return typeof c.node.frameId != "string" ? null : d(this, a, k1).frame(c.node.frameId);
    }
    async scrollIntoView() {
      await this.assertConnectedElement();
      try {
        await this.client.send("DOM.scrollIntoViewIfNeeded", {
          objectId: this.id
        });
      } catch (c) {
        HA(c), await super.scrollIntoView();
      }
    }
    async uploadFile(...c) {
      const C = await this.evaluate((B) => B.multiple);
      bA(c.length <= 1 || C, "Multiple file uploads only work with <input type=file multiple>");
      const E = cs.value.path;
      if (E && (c = c.map((B) => E.win32.isAbsolute(B) || E.posix.isAbsolute(B) ? B : E.resolve(B))), c.length === 0) {
        await this.evaluate((B) => {
          B.files = new DataTransfer().files, B.dispatchEvent(new Event("input", { bubbles: !0, composed: !0 })), B.dispatchEvent(new Event("change", { bubbles: !0 }));
        });
        return;
      }
      const { node: { backendNodeId: l } } = await this.client.send("DOM.describeNode", {
        objectId: this.id
      });
      await this.client.send("DOM.setFileInputFiles", {
        objectId: this.id,
        files: c,
        backendNodeId: l
      });
    }
    async autofill(c) {
      const E = (await this.client.send("DOM.describeNode", {
        objectId: this.handle.id
      })).node.backendNodeId, l = this.frame._id;
      await this.client.send("Autofill.trigger", {
        fieldId: E,
        frameId: l,
        card: c.creditCard
      });
    }
    async *queryAXTree(c, C) {
      const { nodes: E } = await this.client.send("Accessibility.queryAXTree", {
        objectId: this.id,
        accessibleName: c,
        role: C
      }), l = E.filter((B) => !(B.ignored || !B.role || eAA.has(B.role.value)));
      return yield* Dp.map(l, (B) => this.realm.adoptBackendNode(B.backendDOMNodeId));
    }
    async backendNodeId() {
      if (d(this, s))
        return d(this, s);
      const { node: c } = await this.client.send("DOM.describeNode", {
        objectId: this.handle.id
      });
      return x(this, s, c.backendNodeId), d(this, s);
    }
  }, s = new WeakMap(), a = new WeakSet(), k1 = function() {
    return this.frame._frameManager;
  }, (() => {
    const c = typeof Symbol == "function" && Symbol.metadata ? Object.create(t[Symbol.metadata] ?? null) : void 0;
    e = [Ie()], r = [Ie(), De], i = [Ie(), De], n = [Ie()], bh(o, null, e, { kind: "method", name: "contentFrame", static: !1, private: !1, access: { has: (C) => "contentFrame" in C, get: (C) => C.contentFrame }, metadata: c }, null, A), bh(o, null, r, { kind: "method", name: "scrollIntoView", static: !1, private: !1, access: { has: (C) => "scrollIntoView" in C, get: (C) => C.scrollIntoView }, metadata: c }, null, A), bh(o, null, i, { kind: "method", name: "uploadFile", static: !1, private: !1, access: { has: (C) => "uploadFile" in C, get: (C) => C.uploadFile }, metadata: c }, null, A), bh(o, null, n, { kind: "method", name: "autofill", static: !1, private: !1, access: { has: (C) => "autofill" in C, get: (C) => C.autofill }, metadata: c }, null, A), c && Object.defineProperty(o, Symbol.metadata, { enumerable: !0, configurable: !0, writable: !0, value: c });
  })(), o;
})();
/**
 * @license
 * Copyright 2017 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
var tAA = function(t, A, e) {
  if (A != null) {
    if (typeof A != "object" && typeof A != "function") throw new TypeError("Object expected.");
    var r, i;
    if (e) {
      if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
      r = A[Symbol.asyncDispose];
    }
    if (r === void 0) {
      if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
      r = A[Symbol.dispose], e && (i = r);
    }
    if (typeof r != "function") throw new TypeError("Object not disposable.");
    i && (r = function() {
      try {
        i.call(this);
      } catch (n) {
        return Promise.reject(n);
      }
    }), t.stack.push({ value: A, dispose: r, async: e });
  } else e && t.stack.push({ async: !0 });
  return A;
}, rAA = /* @__PURE__ */ function(t) {
  return function(A) {
    function e(s) {
      A.error = A.hasError ? new t(s, A.error, "An error was suppressed during disposal.") : s, A.hasError = !0;
    }
    var r, i = 0;
    function n() {
      for (; r = A.stack.pop(); )
        try {
          if (!r.async && i === 1) return i = 0, A.stack.push(r), Promise.resolve().then(n);
          if (r.dispose) {
            var s = r.dispose.call(r.value);
            if (r.async) return i |= 2, Promise.resolve(s).then(n, function(a) {
              return e(a), n();
            });
          } else i |= 1;
        } catch (a) {
          e(a);
        }
      if (i === 1) return A.hasError ? Promise.reject(A.error) : Promise.resolve();
      if (A.hasError) throw A.error;
    }
    return n();
  };
}(typeof SuppressedError == "function" ? SuppressedError : function(t, A, e) {
  var r = new Error(e);
  return r.name = "SuppressedError", r.error = t, r.suppressed = A, r;
});
const iAA = new $d("__ariaQuerySelector", ol.queryOne, ""), nAA = new $d("__ariaQuerySelectorAll", async (t, A) => {
  const e = ol.queryAll(t, A);
  return await t.realm.evaluateHandle((...r) => r, ...await Dp.collect(e));
}, "");
var Vs, Jo, yi, zu, oB, Ho, pf, pr, R1, b1, M1, gB, Zs, uD, cD;
class v1 extends je {
  constructor(e, r, i) {
    super();
    k(this, pr);
    k(this, Vs);
    k(this, Jo);
    k(this, yi);
    k(this, zu);
    k(this, oB, new ms());
    // Contains mapping from functions that should be bound to Puppeteer functions.
    k(this, Ho, /* @__PURE__ */ new Map());
    // If multiple waitFor are set up asynchronously, we need to wait for the
    // first one to set up the binding in the page before running the others.
    k(this, pf, new al());
    k(this, gB, !1);
    k(this, Zs);
    x(this, Vs, e), x(this, Jo, i), x(this, yi, r.id), r.name && x(this, zu, r.name);
    const n = d(this, oB).use(new je(d(this, Vs)));
    n.on("Runtime.bindingCalled", O(this, pr, b1).bind(this)), n.on("Runtime.executionContextDestroyed", async (s) => {
      s.executionContextId === d(this, yi) && this[ke]();
    }), n.on("Runtime.executionContextsCleared", async () => {
      this[ke]();
    }), n.on("Runtime.consoleAPICalled", O(this, pr, M1).bind(this)), n.on(He.Disconnected, () => {
      this[ke]();
    });
  }
  get id() {
    return d(this, yi);
  }
  get puppeteerUtil() {
    let e = Promise.resolve();
    return d(this, gB) || (e = Promise.all([
      O(this, pr, uD).call(this, iAA),
      O(this, pr, uD).call(this, nAA)
    ]), x(this, gB, !0)), WQ.inject((r) => {
      d(this, Zs) && d(this, Zs).then((i) => {
        i.dispose();
      }), x(this, Zs, e.then(() => this.evaluateHandle(r)));
    }, !d(this, Zs)), d(this, Zs);
  }
  /**
   * Evaluates the given function.
   *
   * @example
   *
   * ```ts
   * const executionContext = await page.mainFrame().executionContext();
   * const result = await executionContext.evaluate(() => Promise.resolve(8 * 7))* ;
   * console.log(result); // prints "56"
   * ```
   *
   * @example
   * A string can also be passed in instead of a function:
   *
   * ```ts
   * console.log(await executionContext.evaluate('1 + 2')); // prints "3"
   * ```
   *
   * @example
   * Handles can also be passed as `args`. They resolve to their referenced object:
   *
   * ```ts
   * const oneHandle = await executionContext.evaluateHandle(() => 1);
   * const twoHandle = await executionContext.evaluateHandle(() => 2);
   * const result = await executionContext.evaluate(
   *   (a, b) => a + b,
   *   oneHandle,
   *   twoHandle,
   * );
   * await oneHandle.dispose();
   * await twoHandle.dispose();
   * console.log(result); // prints '3'.
   * ```
   *
   * @param pageFunction - The function to evaluate.
   * @param args - Additional arguments to pass into the function.
   * @returns The result of evaluating the function. If the result is an object,
   * a vanilla object containing the serializable properties of the result is
   * returned.
   */
  async evaluate(e, ...r) {
    return await O(this, pr, cD).call(this, !0, e, ...r);
  }
  /**
   * Evaluates the given function.
   *
   * Unlike {@link ExecutionContext.evaluate | evaluate}, this method returns a
   * handle to the result of the function.
   *
   * This method may be better suited if the object cannot be serialized (e.g.
   * `Map`) and requires further manipulation.
   *
   * @example
   *
   * ```ts
   * const context = await page.mainFrame().executionContext();
   * const handle: JSHandle<typeof globalThis> = await context.evaluateHandle(
   *   () => Promise.resolve(self),
   * );
   * ```
   *
   * @example
   * A string can also be passed in instead of a function.
   *
   * ```ts
   * const handle: JSHandle<number> = await context.evaluateHandle('1 + 2');
   * ```
   *
   * @example
   * Handles can also be passed as `args`. They resolve to their referenced object:
   *
   * ```ts
   * const bodyHandle: ElementHandle<HTMLBodyElement> =
   *   await context.evaluateHandle(() => {
   *     return document.body;
   *   });
   * const stringHandle: JSHandle<string> = await context.evaluateHandle(
   *   body => body.innerHTML,
   *   body,
   * );
   * console.log(await stringHandle.jsonValue()); // prints body's innerHTML
   * // Always dispose your garbage! :)
   * await bodyHandle.dispose();
   * await stringHandle.dispose();
   * ```
   *
   * @param pageFunction - The function to evaluate.
   * @param args - Additional arguments to pass into the function.
   * @returns A {@link JSHandle | handle} to the result of evaluating the
   * function. If the result is a `Node`, then this will return an
   * {@link ElementHandle | element handle}.
   */
  async evaluateHandle(e, ...r) {
    return await O(this, pr, cD).call(this, !1, e, ...r);
  }
  [ke]() {
    d(this, oB).dispose(), this.emit("disposed", void 0);
  }
}
Vs = new WeakMap(), Jo = new WeakMap(), yi = new WeakMap(), zu = new WeakMap(), oB = new WeakMap(), Ho = new WeakMap(), pf = new WeakMap(), pr = new WeakSet(), R1 = async function(e) {
  const r = { stack: [], error: void 0, hasError: !1 };
  try {
    if (d(this, Ho).has(e.name))
      return;
    const i = tAA(r, await d(this, pf).acquire(), !1);
    try {
      await d(this, Vs).send("Runtime.addBinding", d(this, zu) ? {
        name: cu + e.name,
        executionContextName: d(this, zu)
      } : {
        name: cu + e.name,
        executionContextId: d(this, yi)
      }), await this.evaluate(D1, "internal", e.name, cu), d(this, Ho).set(e.name, e);
    } catch (n) {
      if (n instanceof Error && (n.message.includes("Execution context was destroyed") || n.message.includes("Cannot find context with specified id")))
        return;
      HA(n);
    }
  } catch (i) {
    r.error = i, r.hasError = !0;
  } finally {
    rAA(r);
  }
}, b1 = async function(e) {
  if (e.executionContextId !== d(this, yi))
    return;
  let r;
  try {
    r = JSON.parse(e.payload);
  } catch {
    return;
  }
  const { type: i, name: n, seq: s, args: a, isTrivial: g } = r;
  if (i !== "internal") {
    this.emit("bindingcalled", e);
    return;
  }
  if (!d(this, Ho).has(n)) {
    this.emit("bindingcalled", e);
    return;
  }
  try {
    const o = d(this, Ho).get(n);
    await (o == null ? void 0 : o.run(this, s, a, g));
  } catch (o) {
    HA(o);
  }
}, M1 = function(e) {
  e.executionContextId === d(this, yi) && this.emit("consoleapicalled", e);
}, gB = new WeakMap(), Zs = new WeakMap(), uD = async function(e) {
  try {
    await O(this, pr, R1).call(this, e);
  } catch (r) {
    HA(r);
  }
}, cD = async function(e, r, ...i) {
  var C;
  const n = R$(((C = F$(r)) == null ? void 0 : C.toString()) ?? Is.INTERNAL_URL);
  if (kg(r)) {
    const E = d(this, yi), l = r, B = $v.test(l) ? l : `${l}
${n}
`, { exceptionDetails: h, result: Q } = await d(this, Vs).send("Runtime.evaluate", {
      expression: B,
      contextId: E,
      returnByValue: e,
      awaitPromise: !0,
      userGesture: !0
    }).catch(cR);
    if (h)
      throw uR(h);
    return e ? dg(Q) : d(this, Jo).createCdpHandle(Q);
  }
  const s = Ra(r), a = $v.test(s) ? s : `${s}
${n}
`;
  let g;
  try {
    g = d(this, Vs).send("Runtime.callFunctionOn", {
      functionDeclaration: a,
      executionContextId: d(this, yi),
      // LazyArgs are used only internally and should not affect the order
      // evaluate calls for the public APIs.
      arguments: i.some((E) => E instanceof vi) ? await Promise.all(i.map((E) => I(this, E))) : i.map((E) => c(this, E)),
      returnByValue: e,
      awaitPromise: !0,
      userGesture: !0
    });
  } catch (E) {
    throw E instanceof TypeError && E.message.startsWith("Converting circular structure to JSON") && (E.message += " Recursive objects are not allowed."), E;
  }
  const { exceptionDetails: o, result: u } = await g.catch(cR);
  if (o)
    throw uR(o);
  if (e)
    return dg(u);
  return d(this, Jo).createCdpHandle(u);
  async function I(E, l) {
    return l instanceof vi && (l = await l.get(E)), c(E, l);
  }
  function c(E, l) {
    if (typeof l == "bigint")
      return { unserializableValue: `${l.toString()}n` };
    if (Object.is(l, -0))
      return { unserializableValue: "-0" };
    if (Object.is(l, 1 / 0))
      return { unserializableValue: "Infinity" };
    if (Object.is(l, -1 / 0))
      return { unserializableValue: "-Infinity" };
    if (Object.is(l, NaN))
      return { unserializableValue: "NaN" };
    const B = l && (l instanceof Sp || l instanceof F1) ? l : null;
    if (B) {
      if (B.realm !== d(E, Jo))
        throw new Error("JSHandles can be evaluated only in the context they were created!");
      if (B.disposed)
        throw new Error("JSHandle is disposed!");
      return B.remoteObject().unserializableValue ? {
        unserializableValue: B.remoteObject().unserializableValue
      } : B.remoteObject().objectId ? { objectId: B.remoteObject().objectId } : { value: B.remoteObject().value };
    }
    return { value: l };
  }
};
const cR = (t) => {
  if (t.message.includes("Object reference chain is too long"))
    return { result: { type: "undefined" } };
  if (t.message.includes("Object couldn't be returned by value"))
    return { result: { type: "undefined" } };
  throw t.message.endsWith("Cannot find context with specified id") || t.message.endsWith("Inspected target navigated or closed") ? new Error("Execution context was destroyed, most likely because of a navigation.") : t;
};
/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
var vt;
(function(t) {
  t.FrameAttached = Symbol("FrameManager.FrameAttached"), t.FrameNavigated = Symbol("FrameManager.FrameNavigated"), t.FrameDetached = Symbol("FrameManager.FrameDetached"), t.FrameSwapped = Symbol("FrameManager.FrameSwapped"), t.LifecycleEvent = Symbol("FrameManager.LifecycleEvent"), t.FrameNavigatedWithinDocument = Symbol("FrameManager.FrameNavigatedWithinDocument"), t.ConsoleApiCalled = Symbol("FrameManager.ConsoleApiCalled"), t.BindingCalled = Symbol("FrameManager.BindingCalled");
})(vt || (vt = {}));
/**
 * @license
 * Copyright 2019 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
var zi, wi, Xs, Xt, _1, N1, L1, XQ, zQ;
class ID extends M7 {
  constructor(e, r) {
    super(r);
    k(this, Xt);
    k(this, zi);
    k(this, wi, new je());
    k(this, Xs);
    x(this, Xs, e);
  }
  get environment() {
    return d(this, Xs);
  }
  get client() {
    return d(this, Xs).client;
  }
  get emitter() {
    return d(this, wi);
  }
  setContext(e) {
    var r;
    (r = d(this, zi)) == null || r[ke](), e.once("disposed", O(this, Xt, _1).bind(this)), e.on("consoleapicalled", O(this, Xt, N1).bind(this)), e.on("bindingcalled", O(this, Xt, L1).bind(this)), x(this, zi, e), d(this, wi).emit("context", e), this.taskManager.rerunAll();
  }
  hasContext() {
    return !!d(this, zi);
  }
  get context() {
    return d(this, zi);
  }
  async evaluateHandle(e, ...r) {
    e = bt(this.evaluateHandle.name, e);
    let i = O(this, Xt, XQ).call(this);
    return i || (i = await O(this, Xt, zQ).call(this)), await i.evaluateHandle(e, ...r);
  }
  async evaluate(e, ...r) {
    e = bt(this.evaluate.name, e);
    let i = O(this, Xt, XQ).call(this);
    return i || (i = await O(this, Xt, zQ).call(this)), await i.evaluate(e, ...r);
  }
  async adoptBackendNode(e) {
    let r = O(this, Xt, XQ).call(this);
    r || (r = await O(this, Xt, zQ).call(this));
    const { object: i } = await this.client.send("DOM.resolveNode", {
      backendNodeId: e,
      executionContextId: r.id
    });
    return this.createCdpHandle(i);
  }
  async adoptHandle(e) {
    if (e.realm === this)
      return await e.evaluateHandle((i) => i);
    const r = await this.client.send("DOM.describeNode", {
      objectId: e.id
    });
    return await this.adoptBackendNode(r.node.backendNodeId);
  }
  async transferHandle(e) {
    if (e.realm === this || e.remoteObject().objectId === void 0)
      return e;
    const r = await this.client.send("DOM.describeNode", {
      objectId: e.remoteObject().objectId
    }), i = await this.adoptBackendNode(r.node.backendNodeId);
    return await e.dispose(), i;
  }
  /**
   * @internal
   */
  createCdpHandle(e) {
    return e.subtype === "node" ? new F1(this, e) : new Sp(this, e);
  }
  [ke]() {
    var e;
    (e = d(this, zi)) == null || e[ke](), d(this, wi).emit("disposed", void 0), super[ke](), d(this, wi).removeAllListeners();
  }
}
zi = new WeakMap(), wi = new WeakMap(), Xs = new WeakMap(), Xt = new WeakSet(), _1 = function() {
  x(this, zi, void 0), "clearDocumentHandle" in d(this, Xs) && d(this, Xs).clearDocumentHandle();
}, N1 = function(e) {
  d(this, wi).emit("consoleapicalled", e);
}, L1 = function(e) {
  d(this, wi).emit("bindingcalled", e);
}, XQ = function() {
  if (this.disposed)
    throw new Error(`Execution context is not available in detached frame or worker "${this.environment.url()}" (are you trying to evaluate?)`);
  return d(this, zi);
}, zQ = async function() {
  const e = new Error("Execution context was destroyed");
  return await or(ot(d(this, wi), "context").pipe(ln(ot(d(this, wi), "disposed").pipe(ht(() => {
    throw e;
  })), Bn(this.timeoutSettings.timeout()))));
};
/**
 * @license
 * Copyright 2022 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
const Yi = Symbol("mainWorld"), $Q = Symbol("puppeteerWorld");
/**
 * @license
 * Copyright 2019 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
const sAA = /* @__PURE__ */ new Map([
  ["load", "load"],
  ["domcontentloaded", "DOMContentLoaded"],
  ["networkidle0", "networkIdle"],
  ["networkidle2", "networkAlmostIdle"]
]);
var uB, zs, $u, $s, Po, cB, Aa, IB, CB, lB, ea, BB, EB, Xn, qe, x1, G1, U1, T1, K1, J1, Ad, ro;
class Fy {
  constructor(A, e, r, i, n) {
    k(this, qe);
    k(this, uB);
    k(this, zs);
    k(this, $u);
    k(this, $s, null);
    k(this, Po, new ms());
    k(this, cB);
    k(this, Aa);
    k(this, IB, Ke.create());
    k(this, CB, Ke.create());
    k(this, lB, Ke.create());
    k(this, ea, new Error("LifecycleWatcher terminated"));
    k(this, BB);
    k(this, EB);
    k(this, Xn);
    Array.isArray(r) ? r = r.slice() : typeof r == "string" && (r = [r]), x(this, cB, e._loaderId), x(this, uB, r.map((o) => {
      const u = sAA.get(o);
      return bA(u, "Unknown value for options.waitUntil: " + o), u;
    })), n == null || n.addEventListener("abort", () => {
      n.reason instanceof Error && (n.reason.cause = d(this, ea)), d(this, Aa).reject(n.reason);
    }), x(this, zs, e), x(this, $u, i), d(this, Po).use(new je(e._frameManager)).on(vt.LifecycleEvent, O(this, qe, ro).bind(this));
    const a = d(this, Po).use(new je(e));
    a.on(Pt.FrameNavigatedWithinDocument, O(this, qe, K1).bind(this)), a.on(Pt.FrameNavigated, O(this, qe, J1).bind(this)), a.on(Pt.FrameSwapped, O(this, qe, Ad).bind(this)), a.on(Pt.FrameSwappedByActivation, O(this, qe, Ad).bind(this)), a.on(Pt.FrameDetached, O(this, qe, T1).bind(this));
    const g = d(this, Po).use(new je(A));
    g.on(kt.Request, O(this, qe, x1).bind(this)), g.on(kt.Response, O(this, qe, U1).bind(this)), g.on(kt.RequestFailed, O(this, qe, G1).bind(this)), x(this, Aa, Ke.create({
      timeout: d(this, $u),
      message: `Navigation timeout of ${d(this, $u)} ms exceeded`
    })), O(this, qe, ro).call(this);
  }
  async navigationResponse() {
    var A;
    return await ((A = d(this, Xn)) == null ? void 0 : A.valueOrThrow()), d(this, $s) ? d(this, $s).response() : null;
  }
  sameDocumentNavigationPromise() {
    return d(this, IB).valueOrThrow();
  }
  newDocumentNavigationPromise() {
    return d(this, lB).valueOrThrow();
  }
  lifecyclePromise() {
    return d(this, CB).valueOrThrow();
  }
  terminationPromise() {
    return d(this, Aa).valueOrThrow();
  }
  dispose() {
    d(this, Po).dispose(), d(this, ea).cause = new Error("LifecycleWatcher disposed"), d(this, Aa).resolve(d(this, ea));
  }
}
uB = new WeakMap(), zs = new WeakMap(), $u = new WeakMap(), $s = new WeakMap(), Po = new WeakMap(), cB = new WeakMap(), Aa = new WeakMap(), IB = new WeakMap(), CB = new WeakMap(), lB = new WeakMap(), ea = new WeakMap(), BB = new WeakMap(), EB = new WeakMap(), Xn = new WeakMap(), qe = new WeakSet(), x1 = function(A) {
  var e, r;
  A.frame() !== d(this, zs) || !A.isNavigationRequest() || (x(this, $s, A), (e = d(this, Xn)) == null || e.resolve(), x(this, Xn, Ke.create()), A.response() !== null && ((r = d(this, Xn)) == null || r.resolve()));
}, G1 = function(A) {
  var e, r;
  ((e = d(this, $s)) == null ? void 0 : e.id) === A.id && ((r = d(this, Xn)) == null || r.resolve());
}, U1 = function(A) {
  var e, r;
  ((e = d(this, $s)) == null ? void 0 : e.id) === A.request().id && ((r = d(this, Xn)) == null || r.resolve());
}, T1 = function(A) {
  if (d(this, zs) === A) {
    d(this, ea).message = "Navigating frame was detached", d(this, Aa).resolve(d(this, ea));
    return;
  }
  O(this, qe, ro).call(this);
}, K1 = function() {
  x(this, BB, !0), O(this, qe, ro).call(this);
}, J1 = function(A) {
  if (A === "BackForwardCacheRestore")
    return O(this, qe, Ad).call(this);
  O(this, qe, ro).call(this);
}, Ad = function() {
  x(this, EB, !0), O(this, qe, ro).call(this);
}, ro = function() {
  if (!A(d(this, zs), d(this, uB)))
    return;
  d(this, CB).resolve(), d(this, BB) && d(this, IB).resolve(void 0), (d(this, EB) || d(this, zs)._loaderId !== d(this, cB)) && d(this, lB).resolve(void 0);
  function A(e, r) {
    for (const i of r)
      if (!e._lifecycleEvents.has(i))
        return !1;
    for (const i of e.childFrames())
      if (i._hasStartedLoading && !A(i, r))
        return !1;
    return !0;
  }
};
/**
 * @license
 * Copyright 2017 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
var aAA = function(t, A, e) {
  for (var r = arguments.length > 2, i = 0; i < A.length; i++)
    e = r ? A[i].call(t, e) : A[i].call(t);
  return r ? e : void 0;
}, Ja = function(t, A, e, r, i, n) {
  function s(h) {
    if (h !== void 0 && typeof h != "function") throw new TypeError("Function expected");
    return h;
  }
  for (var a = r.kind, g = a === "getter" ? "get" : a === "setter" ? "set" : "value", o = !A && t ? r.static ? t : t.prototype : null, u = A || (o ? Object.getOwnPropertyDescriptor(o, r.name) : {}), I, c = !1, C = e.length - 1; C >= 0; C--) {
    var E = {};
    for (var l in r) E[l] = l === "access" ? {} : r[l];
    for (var l in r.access) E.access[l] = r.access[l];
    E.addInitializer = function(h) {
      if (c) throw new TypeError("Cannot add initializers after decoration has completed");
      n.push(s(h || null));
    };
    var B = (0, e[C])(a === "accessor" ? { get: u.get, set: u.set } : u[g], E);
    if (a === "accessor") {
      if (B === void 0) continue;
      if (B === null || typeof B != "object") throw new TypeError("Object expected");
      (I = s(B.get)) && (u.get = I), (I = s(B.set)) && (u.set = I), (I = s(B.init)) && i.unshift(I);
    } else (I = s(B)) && (a === "field" ? i.unshift(I) : u[g] = I);
  }
  o && Object.defineProperty(o, r.name, u), c = !0;
};
let IR = (() => {
  var o, u, I, c, H1, P1, O1, B;
  let t = d7, A = [], e, r, i, n, s, a, g;
  return B = class extends t {
    constructor(f, p, y, m) {
      super();
      k(this, c);
      k(this, o, (aAA(this, A), ""));
      k(this, u, !1);
      k(this, I);
      R(this, "_frameManager");
      R(this, "_loaderId", "");
      R(this, "_lifecycleEvents", /* @__PURE__ */ new Set());
      R(this, "_id");
      R(this, "_parentId");
      R(this, "accessibility");
      R(this, "worlds");
      this._frameManager = f, x(this, o, ""), this._id = p, this._parentId = y, x(this, u, !1), x(this, I, m), this._loaderId = "", this.worlds = {
        [Yi]: new ID(this, this._frameManager.timeoutSettings),
        [$Q]: new ID(this, this._frameManager.timeoutSettings)
      }, this.accessibility = new L7(this.worlds[Yi], p), this.on(Pt.FrameSwappedByActivation, () => {
        this._onLoadingStarted(), this._onLoadingStopped();
      }), this.worlds[Yi].emitter.on("consoleapicalled", O(this, c, H1).bind(this)), this.worlds[Yi].emitter.on("bindingcalled", O(this, c, P1).bind(this));
    }
    /**
     * This is used internally in DevTools.
     *
     * @internal
     */
    _client() {
      return d(this, I);
    }
    /**
     * Updates the frame ID with the new ID. This happens when the main frame is
     * replaced by a different frame.
     */
    updateId(f) {
      this._id = f;
    }
    updateClient(f) {
      x(this, I, f);
    }
    page() {
      return this._frameManager.page();
    }
    async goto(f, p = {}) {
      const { referer: y = this._frameManager.networkManager.extraHTTPHeaders().referer, referrerPolicy: m = this._frameManager.networkManager.extraHTTPHeaders()["referer-policy"], waitUntil: S = ["load"], timeout: w = this._frameManager.timeoutSettings.navigationTimeout() } = p;
      let F = !1;
      const b = new Fy(this._frameManager.networkManager, this, S, w);
      let G = await Ke.race([
        T(d(this, I), f, y, m ? oAA(m) : void 0, this._id),
        b.terminationPromise()
      ]);
      G || (G = await Ke.race([
        b.terminationPromise(),
        F ? b.newDocumentNavigationPromise() : b.sameDocumentNavigationPromise()
      ]));
      try {
        if (G)
          throw G;
        return await b.navigationResponse();
      } finally {
        b.dispose();
      }
      async function T(K, H, j, eA, sA) {
        try {
          const uA = await K.send("Page.navigate", {
            url: H,
            referrer: j,
            frameId: sA,
            referrerPolicy: eA
          });
          return F = !!uA.loaderId, uA.errorText === "net::ERR_HTTP_RESPONSE_CODE_FAILURE" ? null : uA.errorText ? new Error(`${uA.errorText} at ${H}`) : null;
        } catch (uA) {
          if (_i(uA))
            return uA;
          throw uA;
        }
      }
    }
    async waitForNavigation(f = {}) {
      const { waitUntil: p = ["load"], timeout: y = this._frameManager.timeoutSettings.navigationTimeout(), signal: m } = f, S = new Fy(this._frameManager.networkManager, this, p, y, m), w = await Ke.race([
        S.terminationPromise(),
        ...f.ignoreSameDocumentNavigation ? [] : [S.sameDocumentNavigationPromise()],
        S.newDocumentNavigationPromise()
      ]);
      try {
        if (w)
          throw w;
        const F = await Ke.race([S.terminationPromise(), S.navigationResponse()]);
        if (F instanceof Error)
          throw w;
        return F || null;
      } finally {
        S.dispose();
      }
    }
    get client() {
      return d(this, I);
    }
    mainRealm() {
      return this.worlds[Yi];
    }
    isolatedRealm() {
      return this.worlds[$Q];
    }
    async setContent(f, p = {}) {
      const { waitUntil: y = ["load"], timeout: m = this._frameManager.timeoutSettings.navigationTimeout() } = p;
      await this.setFrameContent(f);
      const S = new Fy(this._frameManager.networkManager, this, y, m), w = await Ke.race([
        S.terminationPromise(),
        S.lifecyclePromise()
      ]);
      if (S.dispose(), w)
        throw w;
    }
    url() {
      return d(this, o);
    }
    parentFrame() {
      return this._frameManager._frameTree.parentFrame(this._id) || null;
    }
    childFrames() {
      return this._frameManager._frameTree.childFrames(this._id);
    }
    async addPreloadScript(f) {
      const p = this.parentFrame();
      if (p && d(this, I) === p.client || f.getIdForFrame(this))
        return;
      const { identifier: y } = await d(this, I).send("Page.addScriptToEvaluateOnNewDocument", {
        source: f.source
      });
      f.setIdForFrame(this, y);
    }
    async addExposedFunctionBinding(f) {
      this !== this._frameManager.mainFrame() && !this._hasStartedLoading || await Promise.all([
        d(this, I).send("Runtime.addBinding", {
          name: cu + f.name
        }),
        this.evaluate(f.initSource).catch(HA)
      ]);
    }
    async removeExposedFunctionBinding(f) {
      this !== this._frameManager.mainFrame() && !this._hasStartedLoading || await Promise.all([
        d(this, I).send("Runtime.removeBinding", {
          name: cu + f.name
        }),
        this.evaluate((p) => {
          globalThis[p] = void 0;
        }, f.name).catch(HA)
      ]);
    }
    async waitForDevicePrompt(f = {}) {
      return await O(this, c, O1).call(this).waitForDevicePrompt(f);
    }
    _navigated(f) {
      this._name = f.name, x(this, o, `${f.url}${f.urlFragment || ""}`);
    }
    _navigatedWithinDocument(f) {
      x(this, o, f);
    }
    _onLifecycleEvent(f, p) {
      p === "init" && (this._loaderId = f, this._lifecycleEvents.clear()), this._lifecycleEvents.add(p);
    }
    _onLoadingStopped() {
      this._lifecycleEvents.add("DOMContentLoaded"), this._lifecycleEvents.add("load");
    }
    _onLoadingStarted() {
      this._hasStartedLoading = !0;
    }
    get detached() {
      return d(this, u);
    }
    [(e = [Te], r = [Te], i = [Te], n = [Te], s = [Te], a = [Te], g = [Te], ke)]() {
      d(this, u) || (x(this, u, !0), this.worlds[Yi][ke](), this.worlds[$Q][ke]());
    }
    exposeFunction() {
      throw new _S();
    }
    async frameElement() {
      const f = this.parentFrame();
      if (!f)
        return null;
      const { backendNodeId: p } = await f.client.send("DOM.getFrameOwner", {
        frameId: this._id
      });
      return await f.mainRealm().adoptBackendNode(p);
    }
  }, o = new WeakMap(), u = new WeakMap(), I = new WeakMap(), c = new WeakSet(), H1 = function(f) {
    this._frameManager.emit(vt.ConsoleApiCalled, [
      this.worlds[Yi],
      f
    ]);
  }, P1 = function(f) {
    this._frameManager.emit(vt.BindingCalled, [
      this.worlds[Yi],
      f
    ]);
  }, O1 = function() {
    return this._frameManager._deviceRequestPromptManager(d(this, I));
  }, (() => {
    const f = typeof Symbol == "function" && Symbol.metadata ? Object.create(t[Symbol.metadata] ?? null) : void 0;
    Ja(B, null, e, { kind: "method", name: "goto", static: !1, private: !1, access: { has: (p) => "goto" in p, get: (p) => p.goto }, metadata: f }, null, A), Ja(B, null, r, { kind: "method", name: "waitForNavigation", static: !1, private: !1, access: { has: (p) => "waitForNavigation" in p, get: (p) => p.waitForNavigation }, metadata: f }, null, A), Ja(B, null, i, { kind: "method", name: "setContent", static: !1, private: !1, access: { has: (p) => "setContent" in p, get: (p) => p.setContent }, metadata: f }, null, A), Ja(B, null, n, { kind: "method", name: "addPreloadScript", static: !1, private: !1, access: { has: (p) => "addPreloadScript" in p, get: (p) => p.addPreloadScript }, metadata: f }, null, A), Ja(B, null, s, { kind: "method", name: "addExposedFunctionBinding", static: !1, private: !1, access: { has: (p) => "addExposedFunctionBinding" in p, get: (p) => p.addExposedFunctionBinding }, metadata: f }, null, A), Ja(B, null, a, { kind: "method", name: "removeExposedFunctionBinding", static: !1, private: !1, access: { has: (p) => "removeExposedFunctionBinding" in p, get: (p) => p.removeExposedFunctionBinding }, metadata: f }, null, A), Ja(B, null, g, { kind: "method", name: "waitForDevicePrompt", static: !1, private: !1, access: { has: (p) => "waitForDevicePrompt" in p, get: (p) => p.waitForDevicePrompt }, metadata: f }, null, A), f && Object.defineProperty(B, Symbol.metadata, { enumerable: !0, configurable: !0, writable: !0, value: f });
  })(), B;
})();
function oAA(t) {
  return t.replaceAll(/-./g, (A) => A[1].toUpperCase());
}
/**
 * @license
 * Copyright 2022 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
var Oo, Ac, ta, ec, tc, hB;
class gAA {
  constructor() {
    k(this, Oo, /* @__PURE__ */ new Map());
    // frameID -> parentFrameID
    k(this, Ac, /* @__PURE__ */ new Map());
    // frameID -> childFrameIDs
    k(this, ta, /* @__PURE__ */ new Map());
    k(this, ec);
    k(this, tc, !1);
    k(this, hB, /* @__PURE__ */ new Map());
  }
  getMainFrame() {
    return d(this, ec);
  }
  getById(A) {
    return d(this, Oo).get(A);
  }
  /**
   * Returns a promise that is resolved once the frame with
   * the given ID is added to the tree.
   */
  waitForFrame(A) {
    const e = this.getById(A);
    if (e)
      return Promise.resolve(e);
    const r = Ke.create();
    return (d(this, hB).get(A) || /* @__PURE__ */ new Set()).add(r), r.valueOrThrow();
  }
  frames() {
    return Array.from(d(this, Oo).values());
  }
  addFrame(A) {
    var e;
    d(this, Oo).set(A._id, A), A._parentId ? (d(this, Ac).set(A._id, A._parentId), d(this, ta).has(A._parentId) || d(this, ta).set(A._parentId, /* @__PURE__ */ new Set()), d(this, ta).get(A._parentId).add(A._id)) : (!d(this, ec) || d(this, tc)) && (x(this, ec, A), x(this, tc, !1)), (e = d(this, hB).get(A._id)) == null || e.forEach((r) => r.resolve(A));
  }
  removeFrame(A) {
    var e;
    d(this, Oo).delete(A._id), d(this, Ac).delete(A._id), A._parentId ? (e = d(this, ta).get(A._parentId)) == null || e.delete(A._id) : x(this, tc, !0);
  }
  childFrames(A) {
    const e = d(this, ta).get(A);
    return e ? Array.from(e).map((r) => this.getById(r)).filter((r) => r !== void 0) : [];
  }
  parentFrame(A) {
    const e = d(this, Ac).get(A);
    return e ? this.getById(e) : void 0;
  }
}
Oo = new WeakMap(), Ac = new WeakMap(), ta = new WeakMap(), ec = new WeakMap(), tc = new WeakMap(), hB = new WeakMap();
var $i, QB, dB, fB, pB, yB, wB, mB, DB, SB;
class CD extends rR {
  constructor(e, r, i, n, s, a) {
    super();
    R(this, "id");
    k(this, $i);
    k(this, QB);
    k(this, dB);
    k(this, fB);
    k(this, pB);
    k(this, yB, !1);
    k(this, wB);
    k(this, mB, {});
    k(this, DB);
    k(this, SB);
    x(this, $i, e), this.id = s.requestId, x(this, QB, s.requestId === s.loaderId && s.type === "Document"), this._interceptionId = i, x(this, dB, s.request.url + (s.request.urlFragment ?? "")), x(this, fB, (s.type || "other").toLowerCase()), x(this, pB, s.request.method), x(this, wB, s.request.postData), x(this, yB, s.request.hasPostData ?? !1), x(this, DB, r), this._redirectChain = a, x(this, SB, s.initiator), this.interception.enabled = n, this.updateHeaders(s.request.headers);
  }
  get client() {
    return d(this, $i);
  }
  set client(e) {
    x(this, $i, e);
  }
  updateHeaders(e) {
    for (const [r, i] of Object.entries(e))
      d(this, mB)[r.toLowerCase()] = i;
  }
  url() {
    return d(this, dB);
  }
  resourceType() {
    return d(this, fB);
  }
  method() {
    return d(this, pB);
  }
  postData() {
    return d(this, wB);
  }
  hasPostData() {
    return d(this, yB);
  }
  async fetchPostData() {
    try {
      return (await d(this, $i).send("Network.getRequestPostData", {
        requestId: this.id
      })).postData;
    } catch (e) {
      HA(e);
      return;
    }
  }
  headers() {
    return structuredClone(d(this, mB));
  }
  response() {
    return this._response;
  }
  frame() {
    return d(this, DB);
  }
  isNavigationRequest() {
    return d(this, QB);
  }
  initiator() {
    return d(this, SB);
  }
  redirectChain() {
    return this._redirectChain.slice();
  }
  failure() {
    return this._failureText ? {
      errorText: this._failureText
    } : null;
  }
  canBeIntercepted() {
    return !this.url().startsWith("data:") && !this._fromMemoryCache;
  }
  /**
   * @internal
   */
  async _continue(e = {}) {
    const { url: r, method: i, postData: n, headers: s } = e;
    this.interception.handled = !0;
    const a = n ? y$(n) : void 0;
    if (this._interceptionId === void 0)
      throw new Error("HTTPRequest is missing _interceptionId needed for Fetch.continueRequest");
    await d(this, $i).send("Fetch.continueRequest", {
      requestId: this._interceptionId,
      url: r,
      method: i,
      postData: a,
      headers: s ? iR(s) : void 0
    }).catch((g) => (this.interception.handled = !1, Dy(g)));
  }
  async _respond(e) {
    this.interception.handled = !0;
    let r;
    e.body && (r = rR.getResponse(e.body));
    const i = {};
    if (e.headers)
      for (const s of Object.keys(e.headers)) {
        const a = e.headers[s];
        i[s.toLowerCase()] = Array.isArray(a) ? a.map((g) => String(g)) : String(a);
      }
    e.contentType && (i["content-type"] = e.contentType), r != null && r.contentLength && !("content-length" in i) && (i["content-length"] = String(r.contentLength));
    const n = e.status || 200;
    if (this._interceptionId === void 0)
      throw new Error("HTTPRequest is missing _interceptionId needed for Fetch.fulfillRequest");
    await d(this, $i).send("Fetch.fulfillRequest", {
      requestId: this._interceptionId,
      responseCode: n,
      responsePhrase: f7[n],
      responseHeaders: iR(i),
      body: r == null ? void 0 : r.base64
    }).catch((s) => (this.interception.handled = !1, Dy(s)));
  }
  async _abort(e) {
    if (this.interception.handled = !0, this._interceptionId === void 0)
      throw new Error("HTTPRequest is missing _interceptionId needed for Fetch.failRequest");
    await d(this, $i).send("Fetch.failRequest", {
      requestId: this._interceptionId,
      errorReason: e || "Failed"
    }).catch(Dy);
  }
}
$i = new WeakMap(), QB = new WeakMap(), dB = new WeakMap(), fB = new WeakMap(), pB = new WeakMap(), yB = new WeakMap(), wB = new WeakMap(), mB = new WeakMap(), DB = new WeakMap(), SB = new WeakMap();
/**
 * @license
 * Copyright 2020 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
var FB, kB, vB, RB, bB, MB;
class uAA {
  /**
   * @internal
   */
  constructor(A) {
    k(this, FB);
    k(this, kB);
    k(this, vB);
    k(this, RB);
    k(this, bB);
    k(this, MB);
    x(this, FB, A.subjectName), x(this, kB, A.issuer), x(this, vB, A.validFrom), x(this, RB, A.validTo), x(this, bB, A.protocol), x(this, MB, A.sanList);
  }
  /**
   * The name of the issuer of the certificate.
   */
  issuer() {
    return d(this, kB);
  }
  /**
   * {@link https://en.wikipedia.org/wiki/Unix_time | Unix timestamp}
   * marking the start of the certificate's validity.
   */
  validFrom() {
    return d(this, vB);
  }
  /**
   * {@link https://en.wikipedia.org/wiki/Unix_time | Unix timestamp}
   * marking the end of the certificate's validity.
   */
  validTo() {
    return d(this, RB);
  }
  /**
   * The security protocol being used, e.g. "TLS 1.2".
   */
  protocol() {
    return d(this, bB);
  }
  /**
   * The name of the subject to which the certificate was issued.
   */
  subjectName() {
    return d(this, FB);
  }
  /**
   * The list of {@link https://en.wikipedia.org/wiki/Subject_Alternative_Name | subject alternative names (SANs)} of the certificate.
   */
  subjectAlternativeNames() {
    return d(this, MB);
  }
}
FB = new WeakMap(), kB = new WeakMap(), vB = new WeakMap(), RB = new WeakMap(), bB = new WeakMap(), MB = new WeakMap();
var An, rc, ic, _B, NB, LB, xB, GB, UB, TB, KB, yf, Y1;
class CR extends y7 {
  constructor(e, r, i) {
    super();
    k(this, yf);
    k(this, An);
    k(this, rc, null);
    k(this, ic, Ke.create());
    k(this, _B);
    k(this, NB);
    k(this, LB);
    k(this, xB);
    k(this, GB);
    k(this, UB, {});
    k(this, TB);
    k(this, KB);
    x(this, An, e), x(this, _B, {
      ip: r.remoteIPAddress,
      port: r.remotePort
    }), x(this, LB, O(this, yf, Y1).call(this, i) || r.statusText), x(this, xB, !!r.fromDiskCache), x(this, GB, !!r.fromServiceWorker), x(this, NB, i ? i.statusCode : r.status);
    const n = i ? i.headers : r.headers;
    for (const [s, a] of Object.entries(n))
      d(this, UB)[s.toLowerCase()] = a;
    x(this, TB, r.securityDetails ? new uAA(r.securityDetails) : null), x(this, KB, r.timing || null);
  }
  _resolveBody(e) {
    return e ? d(this, ic).reject(e) : d(this, ic).resolve();
  }
  remoteAddress() {
    return d(this, _B);
  }
  url() {
    return d(this, An).url();
  }
  status() {
    return d(this, NB);
  }
  statusText() {
    return d(this, LB);
  }
  headers() {
    return d(this, UB);
  }
  securityDetails() {
    return d(this, TB);
  }
  timing() {
    return d(this, KB);
  }
  content() {
    return d(this, rc) || x(this, rc, d(this, ic).valueOrThrow().then(async () => {
      try {
        const e = await d(this, An).client.send("Network.getResponseBody", {
          requestId: d(this, An).id
        });
        return bS(e.body, e.base64Encoded);
      } catch (e) {
        throw e instanceof Qg && e.originalMessage === "No resource with given identifier found" ? new Qg("Could not load response body for this request. This might happen if the request is a preflight request.") : e;
      }
    })), d(this, rc);
  }
  request() {
    return d(this, An);
  }
  fromCache() {
    return d(this, xB) || d(this, An)._fromMemoryCache;
  }
  fromServiceWorker() {
    return d(this, GB);
  }
  frame() {
    return d(this, An).frame();
  }
}
An = new WeakMap(), rc = new WeakMap(), ic = new WeakMap(), _B = new WeakMap(), NB = new WeakMap(), LB = new WeakMap(), xB = new WeakMap(), GB = new WeakMap(), UB = new WeakMap(), TB = new WeakMap(), KB = new WeakMap(), yf = new WeakSet(), Y1 = function(e) {
  if (!e || !e.headersText)
    return;
  const r = e.headersText.split("\r", 1)[0];
  if (!r || r.length > 1e3)
    return;
  const i = r.match(/[^ ]* [^ ]* (.*)/);
  if (!i)
    return;
  const n = i[1];
  if (n)
    return n;
};
/**
 * @license
 * Copyright 2022 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
var ra, ia, na, Yo, sa, qo, jo;
class cAA {
  constructor() {
    /**
     * There are four possible orders of events:
     * A. `_onRequestWillBeSent`
     * B. `_onRequestWillBeSent`, `_onRequestPaused`
     * C. `_onRequestPaused`, `_onRequestWillBeSent`
     * D. `_onRequestPaused`, `_onRequestWillBeSent`, `_onRequestPaused`,
     * `_onRequestWillBeSent`, `_onRequestPaused`, `_onRequestPaused`
     * (see crbug.com/1196004)
     *
     * For `_onRequest` we need the event from `_onRequestWillBeSent` and
     * optionally the `interceptionId` from `_onRequestPaused`.
     *
     * If request interception is disabled, call `_onRequest` once per call to
     * `_onRequestWillBeSent`.
     * If request interception is enabled, call `_onRequest` once per call to
     * `_onRequestPaused` (once per `interceptionId`).
     *
     * Events are stored to allow for subsequent events to call `_onRequest`.
     *
     * Note that (chains of) redirect requests have the same `requestId` (!) as
     * the original request. We have to anticipate series of events like these:
     * A. `_onRequestWillBeSent`,
     * `_onRequestWillBeSent`, ...
     * B. `_onRequestWillBeSent`, `_onRequestPaused`,
     * `_onRequestWillBeSent`, `_onRequestPaused`, ...
     * C. `_onRequestWillBeSent`, `_onRequestPaused`,
     * `_onRequestPaused`, `_onRequestWillBeSent`, ...
     * D. `_onRequestPaused`, `_onRequestWillBeSent`,
     * `_onRequestPaused`, `_onRequestWillBeSent`, `_onRequestPaused`,
     * `_onRequestWillBeSent`, `_onRequestPaused`, `_onRequestPaused`, ...
     * (see crbug.com/1196004)
     */
    k(this, ra, /* @__PURE__ */ new Map());
    k(this, ia, /* @__PURE__ */ new Map());
    k(this, na, /* @__PURE__ */ new Map());
    k(this, Yo, /* @__PURE__ */ new Map());
    /*
     * The below maps are used to reconcile Network.responseReceivedExtraInfo
     * events with their corresponding request. Each response and redirect
     * response gets an ExtraInfo event, and we don't know which will come first.
     * This means that we have to store a Response or an ExtraInfo for each
     * response, and emit the event when we get both of them. In addition, to
     * handle redirects, we have to make them Arrays to represent the chain of
     * events.
     */
    k(this, sa, /* @__PURE__ */ new Map());
    k(this, qo, /* @__PURE__ */ new Map());
    k(this, jo, /* @__PURE__ */ new Map());
  }
  forget(A) {
    d(this, ra).delete(A), d(this, ia).delete(A), d(this, Yo).delete(A), d(this, jo).delete(A), d(this, qo).delete(A), d(this, sa).delete(A);
  }
  requestExtraInfo(A) {
    return d(this, Yo).has(A) || d(this, Yo).set(A, []), d(this, Yo).get(A);
  }
  responseExtraInfo(A) {
    return d(this, sa).has(A) || d(this, sa).set(A, []), d(this, sa).get(A);
  }
  queuedRedirectInfo(A) {
    return d(this, qo).has(A) || d(this, qo).set(A, []), d(this, qo).get(A);
  }
  queueRedirectInfo(A, e) {
    this.queuedRedirectInfo(A).push(e);
  }
  takeQueuedRedirectInfo(A) {
    return this.queuedRedirectInfo(A).shift();
  }
  inFlightRequestsCount() {
    let A = 0;
    for (const e of d(this, na).values())
      e.response() || A++;
    return A;
  }
  storeRequestWillBeSent(A, e) {
    d(this, ra).set(A, e);
  }
  getRequestWillBeSent(A) {
    return d(this, ra).get(A);
  }
  forgetRequestWillBeSent(A) {
    d(this, ra).delete(A);
  }
  getRequestPaused(A) {
    return d(this, ia).get(A);
  }
  forgetRequestPaused(A) {
    d(this, ia).delete(A);
  }
  storeRequestPaused(A, e) {
    d(this, ia).set(A, e);
  }
  getRequest(A) {
    return d(this, na).get(A);
  }
  storeRequest(A, e) {
    d(this, na).set(A, e);
  }
  forgetRequest(A) {
    d(this, na).delete(A);
  }
  getQueuedEventGroup(A) {
    return d(this, jo).get(A);
  }
  queueEventGroup(A, e) {
    d(this, jo).set(A, e);
  }
  forgetQueuedEventGroup(A) {
    d(this, jo).delete(A);
  }
  printState() {
    function A(e, r) {
      return r instanceof Map ? {
        dataType: "Map",
        value: Array.from(r.entries())
        // or with spread: value: [...value]
      } : r instanceof CD ? {
        dataType: "CdpHTTPRequest",
        value: `${r.id}: ${r.url()}`
      } : r;
    }
    console.log("httpRequestsMap", JSON.stringify(d(this, na), A, 2)), console.log("requestWillBeSentMap", JSON.stringify(d(this, ra), A, 2)), console.log("requestWillBeSentMap", JSON.stringify(d(this, sa), A, 2)), console.log("requestWillBeSentMap", JSON.stringify(d(this, ia), A, 2));
  }
}
ra = new WeakMap(), ia = new WeakMap(), na = new WeakMap(), Yo = new WeakMap(), sa = new WeakMap(), qo = new WeakMap(), jo = new WeakMap();
/**
 * @license
 * Copyright 2017 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
var nc, Be, Wo, aa, sc, en, tn, oa, Kt, ac, JB, HB, wf, ga, PB, kA, io, q1, lD, _s, ed, BD, td, RC, j1, W1, V1, ED, Z1, jg, X1, z1, $1, hD, AT, eT, rd, tT, QD, rT, dD, fD;
class IAA extends je {
  constructor(e, r) {
    super();
    k(this, kA);
    k(this, nc);
    k(this, Be, new cAA());
    k(this, Wo);
    k(this, aa, null);
    k(this, sc, /* @__PURE__ */ new Set());
    k(this, en, !1);
    k(this, tn);
    k(this, oa);
    k(this, Kt);
    k(this, ac);
    k(this, JB);
    k(this, HB);
    k(this, wf, [
      ["Fetch.requestPaused", O(this, kA, V1)],
      ["Fetch.authRequired", O(this, kA, W1)],
      ["Network.requestWillBeSent", O(this, kA, j1)],
      ["Network.requestWillBeSentExtraInfo", O(this, kA, X1)],
      ["Network.requestServedFromCache", O(this, kA, z1)],
      ["Network.responseReceived", O(this, kA, AT)],
      ["Network.loadingFinished", O(this, kA, tT)],
      ["Network.loadingFailed", O(this, kA, rT)],
      ["Network.responseReceivedExtraInfo", O(this, kA, eT)],
      [He.Disconnected, O(this, kA, q1)]
    ]);
    k(this, ga, /* @__PURE__ */ new Map());
    k(this, PB, !0);
    x(this, nc, e), x(this, PB, r ?? !0);
  }
  async addClient(e) {
    if (!d(this, PB) || d(this, ga).has(e))
      return;
    const r = new ms();
    d(this, ga).set(e, r);
    const i = r.use(new je(e));
    for (const [n, s] of d(this, wf))
      i.on(n, (a) => s.bind(this)(e, a));
    try {
      await Promise.all([
        e.send("Network.enable"),
        O(this, kA, lD).call(this, e),
        O(this, kA, ed).call(this, e),
        O(this, kA, RC).call(this, e),
        O(this, kA, td).call(this, e),
        O(this, kA, BD).call(this, e)
      ]);
    } catch (n) {
      if (O(this, kA, io).call(this, n))
        return;
      throw n;
    }
  }
  async authenticate(e) {
    x(this, aa, e);
    const r = d(this, en) || !!d(this, aa);
    r !== d(this, tn) && (x(this, tn, r), await O(this, kA, _s).call(this, O(this, kA, td).bind(this)));
  }
  async setExtraHTTPHeaders(e) {
    const r = {};
    for (const [i, n] of Object.entries(e))
      bA(kg(n), `Expected value of header "${i}" to be String, but "${typeof n}" is found.`), r[i.toLowerCase()] = n;
    x(this, Wo, r), await O(this, kA, _s).call(this, O(this, kA, lD).bind(this));
  }
  extraHTTPHeaders() {
    return Object.assign({}, d(this, Wo));
  }
  inFlightRequestsCount() {
    return d(this, Be).inFlightRequestsCount();
  }
  async setOfflineMode(e) {
    d(this, Kt) || x(this, Kt, {
      offline: !1,
      upload: -1,
      download: -1,
      latency: 0
    }), d(this, Kt).offline = e, await O(this, kA, _s).call(this, O(this, kA, ed).bind(this));
  }
  async emulateNetworkConditions(e) {
    d(this, Kt) || x(this, Kt, {
      offline: (e == null ? void 0 : e.offline) ?? !1,
      upload: -1,
      download: -1,
      latency: 0
    }), d(this, Kt).upload = e ? e.upload : -1, d(this, Kt).download = e ? e.download : -1, d(this, Kt).latency = e ? e.latency : 0, d(this, Kt).offline = (e == null ? void 0 : e.offline) ?? !1, await O(this, kA, _s).call(this, O(this, kA, ed).bind(this));
  }
  async setUserAgent(e, r, i) {
    x(this, ac, e), x(this, JB, r), x(this, HB, i), await O(this, kA, _s).call(this, O(this, kA, BD).bind(this));
  }
  async setCacheEnabled(e) {
    x(this, oa, !e), await O(this, kA, _s).call(this, O(this, kA, RC).bind(this));
  }
  async setRequestInterception(e) {
    x(this, en, e);
    const r = d(this, en) || !!d(this, aa);
    r !== d(this, tn) && (x(this, tn, r), await O(this, kA, _s).call(this, O(this, kA, td).bind(this)));
  }
}
nc = new WeakMap(), Be = new WeakMap(), Wo = new WeakMap(), aa = new WeakMap(), sc = new WeakMap(), en = new WeakMap(), tn = new WeakMap(), oa = new WeakMap(), Kt = new WeakMap(), ac = new WeakMap(), JB = new WeakMap(), HB = new WeakMap(), wf = new WeakMap(), ga = new WeakMap(), PB = new WeakMap(), kA = new WeakSet(), io = function(e) {
  return _i(e) && (ef(e) || e.message.includes("Not supported") || e.message.includes("wasn't found"));
}, q1 = async function(e) {
  var r;
  (r = d(this, ga).get(e)) == null || r.dispose(), d(this, ga).delete(e);
}, lD = async function(e) {
  if (d(this, Wo) !== void 0)
    try {
      await e.send("Network.setExtraHTTPHeaders", {
        headers: d(this, Wo)
      });
    } catch (r) {
      if (O(this, kA, io).call(this, r))
        return;
      throw r;
    }
}, _s = async function(e) {
  await Promise.all(Array.from(d(this, ga).keys()).map((r) => e(r)));
}, ed = async function(e) {
  if (d(this, Kt) !== void 0)
    try {
      await e.send("Network.emulateNetworkConditions", {
        offline: d(this, Kt).offline,
        latency: d(this, Kt).latency,
        uploadThroughput: d(this, Kt).upload,
        downloadThroughput: d(this, Kt).download
      });
    } catch (r) {
      if (O(this, kA, io).call(this, r))
        return;
      throw r;
    }
}, BD = async function(e) {
  if (d(this, ac) !== void 0)
    try {
      await e.send("Network.setUserAgentOverride", {
        userAgent: d(this, ac),
        userAgentMetadata: d(this, JB),
        platform: d(this, HB)
      });
    } catch (r) {
      if (O(this, kA, io).call(this, r))
        return;
      throw r;
    }
}, td = async function(e) {
  if (d(this, tn) !== void 0) {
    d(this, oa) === void 0 && x(this, oa, !1);
    try {
      d(this, tn) ? await Promise.all([
        O(this, kA, RC).call(this, e),
        e.send("Fetch.enable", {
          handleAuthRequests: !0,
          patterns: [{ urlPattern: "*" }]
        })
      ]) : await Promise.all([
        O(this, kA, RC).call(this, e),
        e.send("Fetch.disable")
      ]);
    } catch (r) {
      if (O(this, kA, io).call(this, r))
        return;
      throw r;
    }
  }
}, RC = async function(e) {
  if (d(this, oa) !== void 0)
    try {
      await e.send("Network.setCacheDisabled", {
        cacheDisabled: d(this, oa)
      });
    } catch (r) {
      if (O(this, kA, io).call(this, r))
        return;
      throw r;
    }
}, j1 = function(e, r) {
  if (d(this, en) && !r.request.url.startsWith("data:")) {
    const { requestId: i } = r;
    d(this, Be).storeRequestWillBeSent(i, r);
    const n = d(this, Be).getRequestPaused(i);
    if (n) {
      const { requestId: s } = n;
      O(this, kA, ED).call(this, r, n), O(this, kA, jg).call(this, e, r, s), d(this, Be).forgetRequestPaused(i);
    }
    return;
  }
  O(this, kA, jg).call(this, e, r, void 0);
}, W1 = function(e, r) {
  let i = "Default";
  d(this, sc).has(r.requestId) ? i = "CancelAuth" : d(this, aa) && (i = "ProvideCredentials", d(this, sc).add(r.requestId));
  const { username: n, password: s } = d(this, aa) || {
    username: void 0,
    password: void 0
  };
  e.send("Fetch.continueWithAuth", {
    requestId: r.requestId,
    authChallengeResponse: { response: i, username: n, password: s }
  }).catch(HA);
}, /**
 * CDP may send a Fetch.requestPaused without or before a
 * Network.requestWillBeSent
 *
 * CDP may send multiple Fetch.requestPaused
 * for the same Network.requestWillBeSent.
 */
V1 = function(e, r) {
  !d(this, en) && d(this, tn) && e.send("Fetch.continueRequest", {
    requestId: r.requestId
  }).catch(HA);
  const { networkId: i, requestId: n } = r;
  if (!i) {
    O(this, kA, Z1).call(this, e, r);
    return;
  }
  const s = (() => {
    const a = d(this, Be).getRequestWillBeSent(i);
    if (a && (a.request.url !== r.request.url || a.request.method !== r.request.method)) {
      d(this, Be).forgetRequestWillBeSent(i);
      return;
    }
    return a;
  })();
  s ? (O(this, kA, ED).call(this, s, r), O(this, kA, jg).call(this, e, s, n)) : d(this, Be).storeRequestPaused(i, r);
}, ED = function(e, r) {
  e.request.headers = {
    ...e.request.headers,
    // includes extra headers, like: Accept, Origin
    ...r.request.headers
  };
}, Z1 = function(e, r) {
  const i = r.frameId ? d(this, nc).frame(r.frameId) : null, n = new CD(e, i, r.requestId, d(this, en), r, []);
  this.emit(kt.Request, n), n.finalizeInterceptions();
}, jg = function(e, r, i, n = !1) {
  let s = [];
  if (r.redirectResponse) {
    let u = null;
    if (r.redirectHasExtraInfo && (u = d(this, Be).responseExtraInfo(r.requestId).shift(), !u)) {
      d(this, Be).queueRedirectInfo(r.requestId, {
        event: r,
        fetchRequestId: i
      });
      return;
    }
    const I = d(this, Be).getRequest(r.requestId);
    if (I) {
      O(this, kA, $1).call(this, e, I, r.redirectResponse, u), s = I._redirectChain;
      const c = d(this, Be).requestExtraInfo(r.requestId).shift();
      c && I.updateHeaders(c.headers);
    }
  }
  const a = r.frameId ? d(this, nc).frame(r.frameId) : null, g = new CD(e, a, i, d(this, en), r, s), o = d(this, Be).requestExtraInfo(r.requestId).shift();
  o && g.updateHeaders(o.headers), g._fromMemoryCache = n, d(this, Be).storeRequest(r.requestId, g), this.emit(kt.Request, g), g.finalizeInterceptions();
}, X1 = function(e, r) {
  const i = d(this, Be).getRequest(r.requestId);
  i ? i.updateHeaders(r.headers) : d(this, Be).requestExtraInfo(r.requestId).push(r);
}, z1 = function(e, r) {
  const i = d(this, Be).getRequestWillBeSent(r.requestId);
  let n = d(this, Be).getRequest(r.requestId);
  if (n && (n._fromMemoryCache = !0), !n && i && (O(this, kA, jg).call(this, e, i, void 0, !0), n = d(this, Be).getRequest(r.requestId)), !n) {
    HA(new Error(`Request ${r.requestId} was served from cache but we could not find the corresponding request object`));
    return;
  }
  this.emit(kt.RequestServedFromCache, n);
}, $1 = function(e, r, i, n) {
  const s = new CR(r, i, n);
  r._response = s, r._redirectChain.push(r), s._resolveBody(new Error("Response body is unavailable for redirect responses")), O(this, kA, rd).call(this, r, !1), this.emit(kt.Response, s), this.emit(kt.RequestFinished, r);
}, hD = function(e, r, i) {
  const n = d(this, Be).getRequest(r.requestId);
  if (!n)
    return;
  d(this, Be).responseExtraInfo(r.requestId).length && HA(new Error("Unexpected extraInfo events for request " + r.requestId)), r.response.fromDiskCache && (i = null);
  const a = new CR(n, r.response, i);
  n._response = a, this.emit(kt.Response, a);
}, AT = function(e, r) {
  const i = d(this, Be).getRequest(r.requestId);
  let n = null;
  if (i && !i._fromMemoryCache && r.hasExtraInfo && (n = d(this, Be).responseExtraInfo(r.requestId).shift(), !n)) {
    d(this, Be).queueEventGroup(r.requestId, {
      responseReceivedEvent: r
    });
    return;
  }
  O(this, kA, hD).call(this, e, r, n);
}, eT = function(e, r) {
  const i = d(this, Be).takeQueuedRedirectInfo(r.requestId);
  if (i) {
    d(this, Be).responseExtraInfo(r.requestId).push(r), O(this, kA, jg).call(this, e, i.event, i.fetchRequestId);
    return;
  }
  const n = d(this, Be).getQueuedEventGroup(r.requestId);
  if (n) {
    d(this, Be).forgetQueuedEventGroup(r.requestId), O(this, kA, hD).call(this, e, n.responseReceivedEvent, r), n.loadingFinishedEvent && O(this, kA, QD).call(this, e, n.loadingFinishedEvent), n.loadingFailedEvent && O(this, kA, dD).call(this, e, n.loadingFailedEvent);
    return;
  }
  d(this, Be).responseExtraInfo(r.requestId).push(r);
}, rd = function(e, r) {
  const i = e.id, n = e._interceptionId;
  d(this, Be).forgetRequest(i), n !== void 0 && d(this, sc).delete(n), r && d(this, Be).forget(i);
}, tT = function(e, r) {
  const i = d(this, Be).getQueuedEventGroup(r.requestId);
  i ? i.loadingFinishedEvent = r : O(this, kA, QD).call(this, e, r);
}, QD = function(e, r) {
  var n;
  const i = d(this, Be).getRequest(r.requestId);
  i && (O(this, kA, fD).call(this, e, i), i.response() && ((n = i.response()) == null || n._resolveBody()), O(this, kA, rd).call(this, i, !0), this.emit(kt.RequestFinished, i));
}, rT = function(e, r) {
  const i = d(this, Be).getQueuedEventGroup(r.requestId);
  i ? i.loadingFailedEvent = r : O(this, kA, dD).call(this, e, r);
}, dD = function(e, r) {
  const i = d(this, Be).getRequest(r.requestId);
  if (!i)
    return;
  O(this, kA, fD).call(this, e, i), i._failureText = r.errorText;
  const n = i.response();
  n && n._resolveBody(), O(this, kA, rd).call(this, i, !0), this.emit(kt.RequestFailed, i);
}, fD = function(e, r) {
  e !== r.client && (r.client = e);
};
/**
 * @license
 * Copyright 2017 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
const CAA = 100;
var oc, ua, gc, OB, mi, Vo, uc, Zo, YB, nr, he, pD, iT, nT, sT, yD, wD, mD, aT, oT, gT, uT, no;
class lAA extends je {
  constructor(e, r, i) {
    super();
    k(this, he);
    k(this, oc);
    k(this, ua);
    k(this, gc);
    k(this, OB, /* @__PURE__ */ new Set());
    k(this, mi);
    k(this, Vo, /* @__PURE__ */ new Map());
    k(this, uc, /* @__PURE__ */ new Set());
    R(this, "_frameTree", new gAA());
    /**
     * Set of frame IDs stored to indicate if a frame has received a
     * frameNavigated event so that frame tree responses could be ignored as the
     * frameNavigated event usually contains the latest information.
     */
    k(this, Zo, /* @__PURE__ */ new Set());
    k(this, YB, /* @__PURE__ */ new WeakMap());
    k(this, nr);
    x(this, mi, e), x(this, oc, r), x(this, ua, new IAA(this, r.browser().isNetworkEnabled())), x(this, gc, i), this.setupEventListeners(d(this, mi)), e.once(He.Disconnected, () => {
      O(this, he, pD).call(this).catch(HA);
    });
  }
  get timeoutSettings() {
    return d(this, gc);
  }
  get networkManager() {
    return d(this, ua);
  }
  get client() {
    return d(this, mi);
  }
  /**
   * When the main frame is replaced by another main frame,
   * we maintain the main frame object identity while updating
   * its frame tree and ID.
   */
  async swapFrameTree(e) {
    x(this, mi, e);
    const r = this._frameTree.getMainFrame();
    r && (d(this, Zo).add(d(this, mi).target()._targetId), this._frameTree.removeFrame(r), r.updateId(d(this, mi).target()._targetId), this._frameTree.addFrame(r), r.updateClient(e)), this.setupEventListeners(e), e.once(He.Disconnected, () => {
      O(this, he, pD).call(this).catch(HA);
    }), await this.initialize(e, r), await d(this, ua).addClient(e), r && r.emit(Pt.FrameSwappedByActivation, void 0);
  }
  async registerSpeculativeSession(e) {
    await d(this, ua).addClient(e);
  }
  setupEventListeners(e) {
    e.on("Page.frameAttached", async (r) => {
      var i;
      await ((i = d(this, nr)) == null ? void 0 : i.valueOrThrow()), O(this, he, wD).call(this, e, r.frameId, r.parentFrameId);
    }), e.on("Page.frameNavigated", async (r) => {
      var i;
      d(this, Zo).add(r.frame.id), await ((i = d(this, nr)) == null ? void 0 : i.valueOrThrow()), O(this, he, mD).call(this, r.frame, r.type);
    }), e.on("Page.navigatedWithinDocument", async (r) => {
      var i;
      await ((i = d(this, nr)) == null ? void 0 : i.valueOrThrow()), O(this, he, oT).call(this, r.frameId, r.url);
    }), e.on("Page.frameDetached", async (r) => {
      var i;
      await ((i = d(this, nr)) == null ? void 0 : i.valueOrThrow()), O(this, he, gT).call(this, r.frameId, r.reason);
    }), e.on("Page.frameStartedLoading", async (r) => {
      var i;
      await ((i = d(this, nr)) == null ? void 0 : i.valueOrThrow()), O(this, he, nT).call(this, r.frameId);
    }), e.on("Page.frameStoppedLoading", async (r) => {
      var i;
      await ((i = d(this, nr)) == null ? void 0 : i.valueOrThrow()), O(this, he, sT).call(this, r.frameId);
    }), e.on("Runtime.executionContextCreated", async (r) => {
      var i;
      await ((i = d(this, nr)) == null ? void 0 : i.valueOrThrow()), O(this, he, uT).call(this, r.context, e);
    }), e.on("Page.lifecycleEvent", async (r) => {
      var i;
      await ((i = d(this, nr)) == null ? void 0 : i.valueOrThrow()), O(this, he, iT).call(this, r);
    });
  }
  async initialize(e, r) {
    var i, n;
    try {
      (i = d(this, nr)) == null || i.resolve(), x(this, nr, Ke.create()), await Promise.all([
        d(this, ua).addClient(e),
        e.send("Page.enable"),
        e.send("Page.getFrameTree").then(({ frameTree: s }) => {
          var a;
          O(this, he, yD).call(this, e, s), (a = d(this, nr)) == null || a.resolve();
        }),
        e.send("Page.setLifecycleEventsEnabled", { enabled: !0 }),
        e.send("Runtime.enable").then(() => O(this, he, aT).call(this, e, zv)),
        ...(r ? Array.from(d(this, Vo).values()) : []).map((s) => r == null ? void 0 : r.addPreloadScript(s)),
        ...(r ? Array.from(d(this, uc).values()) : []).map((s) => r == null ? void 0 : r.addExposedFunctionBinding(s))
      ]);
    } catch (s) {
      if ((n = d(this, nr)) == null || n.resolve(), _i(s) && ef(s))
        return;
      throw s;
    }
  }
  page() {
    return d(this, oc);
  }
  mainFrame() {
    const e = this._frameTree.getMainFrame();
    return bA(e, "Requesting main frame too early!"), e;
  }
  frames() {
    return Array.from(this._frameTree.frames());
  }
  frame(e) {
    return this._frameTree.getById(e) || null;
  }
  async addExposedFunctionBinding(e) {
    d(this, uc).add(e), await Promise.all(this.frames().map(async (r) => await r.addExposedFunctionBinding(e)));
  }
  async removeExposedFunctionBinding(e) {
    d(this, uc).delete(e), await Promise.all(this.frames().map(async (r) => await r.removeExposedFunctionBinding(e)));
  }
  async evaluateOnNewDocument(e) {
    const { identifier: r } = await this.mainFrame()._client().send("Page.addScriptToEvaluateOnNewDocument", {
      source: e
    }), i = new V7(this.mainFrame(), r, e);
    return d(this, Vo).set(r, i), await Promise.all(this.frames().map(async (n) => await n.addPreloadScript(i))), { identifier: r };
  }
  async removeScriptToEvaluateOnNewDocument(e) {
    const r = d(this, Vo).get(e);
    if (!r)
      throw new Error(`Script to evaluate on new document with id ${e} not found`);
    d(this, Vo).delete(e), await Promise.all(this.frames().map((i) => {
      const n = r.getIdForFrame(i);
      if (n)
        return i._client().send("Page.removeScriptToEvaluateOnNewDocument", {
          identifier: n
        }).catch(HA);
    }));
  }
  onAttachedToTarget(e) {
    if (e._getTargetInfo().type !== "iframe")
      return;
    const r = this.frame(e._getTargetInfo().targetId);
    r && r.updateClient(e._session()), this.setupEventListeners(e._session()), this.initialize(e._session(), r);
  }
  _deviceRequestPromptManager(e) {
    let r = d(this, YB).get(e);
    return r === void 0 && (r = new X7(e, d(this, gc)), d(this, YB).set(e, r)), r;
  }
}
oc = new WeakMap(), ua = new WeakMap(), gc = new WeakMap(), OB = new WeakMap(), mi = new WeakMap(), Vo = new WeakMap(), uc = new WeakMap(), Zo = new WeakMap(), YB = new WeakMap(), nr = new WeakMap(), he = new WeakSet(), pD = async function() {
  const e = this._frameTree.getMainFrame();
  if (!e)
    return;
  if (!d(this, oc).browser().connected) {
    O(this, he, no).call(this, e);
    return;
  }
  for (const i of e.childFrames())
    O(this, he, no).call(this, i);
  const r = Ke.create({
    timeout: CAA,
    message: "Frame was not swapped"
  });
  e.once(Pt.FrameSwappedByActivation, () => {
    r.resolve();
  });
  try {
    await r.valueOrThrow();
  } catch {
    O(this, he, no).call(this, e);
  }
}, iT = function(e) {
  const r = this.frame(e.frameId);
  r && (r._onLifecycleEvent(e.loaderId, e.name), this.emit(vt.LifecycleEvent, r), r.emit(Pt.LifecycleEvent, void 0));
}, nT = function(e) {
  const r = this.frame(e);
  r && r._onLoadingStarted();
}, sT = function(e) {
  const r = this.frame(e);
  r && (r._onLoadingStopped(), this.emit(vt.LifecycleEvent, r), r.emit(Pt.LifecycleEvent, void 0));
}, yD = function(e, r) {
  if (r.frame.parentId && O(this, he, wD).call(this, e, r.frame.id, r.frame.parentId), d(this, Zo).has(r.frame.id) ? d(this, Zo).delete(r.frame.id) : O(this, he, mD).call(this, r.frame, "Navigation"), !!r.childFrames)
    for (const i of r.childFrames)
      O(this, he, yD).call(this, e, i);
}, wD = function(e, r, i) {
  let n = this.frame(r);
  if (n) {
    const s = this.frame(i);
    e && s && n.client !== (s == null ? void 0 : s.client) && n.updateClient(e);
    return;
  }
  n = new IR(this, r, i, e), this._frameTree.addFrame(n), this.emit(vt.FrameAttached, n);
}, mD = async function(e, r) {
  const i = e.id, n = !e.parentId;
  let s = this._frameTree.getById(i);
  if (s)
    for (const a of s.childFrames())
      O(this, he, no).call(this, a);
  n && (s ? (this._frameTree.removeFrame(s), s._id = i) : s = new IR(this, i, void 0, d(this, mi)), this._frameTree.addFrame(s)), s = await this._frameTree.waitForFrame(i), s._navigated(e), this.emit(vt.FrameNavigated, s), s.emit(Pt.FrameNavigated, r);
}, aT = async function(e, r) {
  const i = `${e.id()}:${r}`;
  d(this, OB).has(i) || (await e.send("Page.addScriptToEvaluateOnNewDocument", {
    source: `//# sourceURL=${Is.INTERNAL_URL}`,
    worldName: r
  }), await Promise.all(this.frames().filter((n) => n.client === e).map((n) => e.send("Page.createIsolatedWorld", {
    frameId: n._id,
    worldName: r,
    grantUniveralAccess: !0
  }).catch(HA))), d(this, OB).add(i));
}, oT = function(e, r) {
  const i = this.frame(e);
  i && (i._navigatedWithinDocument(r), this.emit(vt.FrameNavigatedWithinDocument, i), i.emit(Pt.FrameNavigatedWithinDocument, void 0), this.emit(vt.FrameNavigated, i), i.emit(Pt.FrameNavigated, "Navigation"));
}, gT = function(e, r) {
  const i = this.frame(e);
  if (i)
    switch (r) {
      case "remove":
        O(this, he, no).call(this, i);
        break;
      case "swap":
        this.emit(vt.FrameSwapped, i), i.emit(Pt.FrameSwapped, void 0);
        break;
    }
}, uT = function(e, r) {
  const i = e.auxData, n = i && i.frameId, s = typeof n == "string" ? this.frame(n) : void 0;
  let a;
  if (s) {
    if (s.client !== r)
      return;
    e.auxData && e.auxData.isDefault ? a = s.worlds[Yi] : e.name === zv && (a = s.worlds[$Q]);
  }
  if (!a)
    return;
  const g = new v1((s == null ? void 0 : s.client) || d(this, mi), e, a);
  a.setContext(g);
}, no = function(e) {
  for (const r of e.childFrames())
    O(this, he, no).call(this, r);
  e[ke](), this._frameTree.removeFrame(e), this.emit(vt.FrameDetached, e), e.emit(Pt.FrameDetached, e);
};
/**
 * @license
 * Copyright 2017 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
const lR = {
  0: { keyCode: 48, key: "0", code: "Digit0" },
  1: { keyCode: 49, key: "1", code: "Digit1" },
  2: { keyCode: 50, key: "2", code: "Digit2" },
  3: { keyCode: 51, key: "3", code: "Digit3" },
  4: { keyCode: 52, key: "4", code: "Digit4" },
  5: { keyCode: 53, key: "5", code: "Digit5" },
  6: { keyCode: 54, key: "6", code: "Digit6" },
  7: { keyCode: 55, key: "7", code: "Digit7" },
  8: { keyCode: 56, key: "8", code: "Digit8" },
  9: { keyCode: 57, key: "9", code: "Digit9" },
  Power: { key: "Power", code: "Power" },
  Eject: { key: "Eject", code: "Eject" },
  Abort: { keyCode: 3, code: "Abort", key: "Cancel" },
  Help: { keyCode: 6, code: "Help", key: "Help" },
  Backspace: { keyCode: 8, code: "Backspace", key: "Backspace" },
  Tab: { keyCode: 9, code: "Tab", key: "Tab" },
  Numpad5: {
    keyCode: 12,
    shiftKeyCode: 101,
    key: "Clear",
    code: "Numpad5",
    shiftKey: "5",
    location: 3
  },
  NumpadEnter: {
    keyCode: 13,
    code: "NumpadEnter",
    key: "Enter",
    text: "\r",
    location: 3
  },
  Enter: { keyCode: 13, code: "Enter", key: "Enter", text: "\r" },
  "\r": { keyCode: 13, code: "Enter", key: "Enter", text: "\r" },
  "\n": { keyCode: 13, code: "Enter", key: "Enter", text: "\r" },
  ShiftLeft: { keyCode: 16, code: "ShiftLeft", key: "Shift", location: 1 },
  ShiftRight: { keyCode: 16, code: "ShiftRight", key: "Shift", location: 2 },
  ControlLeft: {
    keyCode: 17,
    code: "ControlLeft",
    key: "Control",
    location: 1
  },
  ControlRight: {
    keyCode: 17,
    code: "ControlRight",
    key: "Control",
    location: 2
  },
  AltLeft: { keyCode: 18, code: "AltLeft", key: "Alt", location: 1 },
  AltRight: { keyCode: 18, code: "AltRight", key: "Alt", location: 2 },
  Pause: { keyCode: 19, code: "Pause", key: "Pause" },
  CapsLock: { keyCode: 20, code: "CapsLock", key: "CapsLock" },
  Escape: { keyCode: 27, code: "Escape", key: "Escape" },
  Convert: { keyCode: 28, code: "Convert", key: "Convert" },
  NonConvert: { keyCode: 29, code: "NonConvert", key: "NonConvert" },
  Space: { keyCode: 32, code: "Space", key: " " },
  Numpad9: {
    keyCode: 33,
    shiftKeyCode: 105,
    key: "PageUp",
    code: "Numpad9",
    shiftKey: "9",
    location: 3
  },
  PageUp: { keyCode: 33, code: "PageUp", key: "PageUp" },
  Numpad3: {
    keyCode: 34,
    shiftKeyCode: 99,
    key: "PageDown",
    code: "Numpad3",
    shiftKey: "3",
    location: 3
  },
  PageDown: { keyCode: 34, code: "PageDown", key: "PageDown" },
  End: { keyCode: 35, code: "End", key: "End" },
  Numpad1: {
    keyCode: 35,
    shiftKeyCode: 97,
    key: "End",
    code: "Numpad1",
    shiftKey: "1",
    location: 3
  },
  Home: { keyCode: 36, code: "Home", key: "Home" },
  Numpad7: {
    keyCode: 36,
    shiftKeyCode: 103,
    key: "Home",
    code: "Numpad7",
    shiftKey: "7",
    location: 3
  },
  ArrowLeft: { keyCode: 37, code: "ArrowLeft", key: "ArrowLeft" },
  Numpad4: {
    keyCode: 37,
    shiftKeyCode: 100,
    key: "ArrowLeft",
    code: "Numpad4",
    shiftKey: "4",
    location: 3
  },
  Numpad8: {
    keyCode: 38,
    shiftKeyCode: 104,
    key: "ArrowUp",
    code: "Numpad8",
    shiftKey: "8",
    location: 3
  },
  ArrowUp: { keyCode: 38, code: "ArrowUp", key: "ArrowUp" },
  ArrowRight: { keyCode: 39, code: "ArrowRight", key: "ArrowRight" },
  Numpad6: {
    keyCode: 39,
    shiftKeyCode: 102,
    key: "ArrowRight",
    code: "Numpad6",
    shiftKey: "6",
    location: 3
  },
  Numpad2: {
    keyCode: 40,
    shiftKeyCode: 98,
    key: "ArrowDown",
    code: "Numpad2",
    shiftKey: "2",
    location: 3
  },
  ArrowDown: { keyCode: 40, code: "ArrowDown", key: "ArrowDown" },
  Select: { keyCode: 41, code: "Select", key: "Select" },
  Open: { keyCode: 43, code: "Open", key: "Execute" },
  PrintScreen: { keyCode: 44, code: "PrintScreen", key: "PrintScreen" },
  Insert: { keyCode: 45, code: "Insert", key: "Insert" },
  Numpad0: {
    keyCode: 45,
    shiftKeyCode: 96,
    key: "Insert",
    code: "Numpad0",
    shiftKey: "0",
    location: 3
  },
  Delete: { keyCode: 46, code: "Delete", key: "Delete" },
  NumpadDecimal: {
    keyCode: 46,
    shiftKeyCode: 110,
    code: "NumpadDecimal",
    key: "\0",
    shiftKey: ".",
    location: 3
  },
  Digit0: { keyCode: 48, code: "Digit0", shiftKey: ")", key: "0" },
  Digit1: { keyCode: 49, code: "Digit1", shiftKey: "!", key: "1" },
  Digit2: { keyCode: 50, code: "Digit2", shiftKey: "@", key: "2" },
  Digit3: { keyCode: 51, code: "Digit3", shiftKey: "#", key: "3" },
  Digit4: { keyCode: 52, code: "Digit4", shiftKey: "$", key: "4" },
  Digit5: { keyCode: 53, code: "Digit5", shiftKey: "%", key: "5" },
  Digit6: { keyCode: 54, code: "Digit6", shiftKey: "^", key: "6" },
  Digit7: { keyCode: 55, code: "Digit7", shiftKey: "&", key: "7" },
  Digit8: { keyCode: 56, code: "Digit8", shiftKey: "*", key: "8" },
  Digit9: { keyCode: 57, code: "Digit9", shiftKey: "(", key: "9" },
  KeyA: { keyCode: 65, code: "KeyA", shiftKey: "A", key: "a" },
  KeyB: { keyCode: 66, code: "KeyB", shiftKey: "B", key: "b" },
  KeyC: { keyCode: 67, code: "KeyC", shiftKey: "C", key: "c" },
  KeyD: { keyCode: 68, code: "KeyD", shiftKey: "D", key: "d" },
  KeyE: { keyCode: 69, code: "KeyE", shiftKey: "E", key: "e" },
  KeyF: { keyCode: 70, code: "KeyF", shiftKey: "F", key: "f" },
  KeyG: { keyCode: 71, code: "KeyG", shiftKey: "G", key: "g" },
  KeyH: { keyCode: 72, code: "KeyH", shiftKey: "H", key: "h" },
  KeyI: { keyCode: 73, code: "KeyI", shiftKey: "I", key: "i" },
  KeyJ: { keyCode: 74, code: "KeyJ", shiftKey: "J", key: "j" },
  KeyK: { keyCode: 75, code: "KeyK", shiftKey: "K", key: "k" },
  KeyL: { keyCode: 76, code: "KeyL", shiftKey: "L", key: "l" },
  KeyM: { keyCode: 77, code: "KeyM", shiftKey: "M", key: "m" },
  KeyN: { keyCode: 78, code: "KeyN", shiftKey: "N", key: "n" },
  KeyO: { keyCode: 79, code: "KeyO", shiftKey: "O", key: "o" },
  KeyP: { keyCode: 80, code: "KeyP", shiftKey: "P", key: "p" },
  KeyQ: { keyCode: 81, code: "KeyQ", shiftKey: "Q", key: "q" },
  KeyR: { keyCode: 82, code: "KeyR", shiftKey: "R", key: "r" },
  KeyS: { keyCode: 83, code: "KeyS", shiftKey: "S", key: "s" },
  KeyT: { keyCode: 84, code: "KeyT", shiftKey: "T", key: "t" },
  KeyU: { keyCode: 85, code: "KeyU", shiftKey: "U", key: "u" },
  KeyV: { keyCode: 86, code: "KeyV", shiftKey: "V", key: "v" },
  KeyW: { keyCode: 87, code: "KeyW", shiftKey: "W", key: "w" },
  KeyX: { keyCode: 88, code: "KeyX", shiftKey: "X", key: "x" },
  KeyY: { keyCode: 89, code: "KeyY", shiftKey: "Y", key: "y" },
  KeyZ: { keyCode: 90, code: "KeyZ", shiftKey: "Z", key: "z" },
  MetaLeft: { keyCode: 91, code: "MetaLeft", key: "Meta", location: 1 },
  MetaRight: { keyCode: 92, code: "MetaRight", key: "Meta", location: 2 },
  ContextMenu: { keyCode: 93, code: "ContextMenu", key: "ContextMenu" },
  NumpadMultiply: {
    keyCode: 106,
    code: "NumpadMultiply",
    key: "*",
    location: 3
  },
  NumpadAdd: { keyCode: 107, code: "NumpadAdd", key: "+", location: 3 },
  NumpadSubtract: {
    keyCode: 109,
    code: "NumpadSubtract",
    key: "-",
    location: 3
  },
  NumpadDivide: { keyCode: 111, code: "NumpadDivide", key: "/", location: 3 },
  F1: { keyCode: 112, code: "F1", key: "F1" },
  F2: { keyCode: 113, code: "F2", key: "F2" },
  F3: { keyCode: 114, code: "F3", key: "F3" },
  F4: { keyCode: 115, code: "F4", key: "F4" },
  F5: { keyCode: 116, code: "F5", key: "F5" },
  F6: { keyCode: 117, code: "F6", key: "F6" },
  F7: { keyCode: 118, code: "F7", key: "F7" },
  F8: { keyCode: 119, code: "F8", key: "F8" },
  F9: { keyCode: 120, code: "F9", key: "F9" },
  F10: { keyCode: 121, code: "F10", key: "F10" },
  F11: { keyCode: 122, code: "F11", key: "F11" },
  F12: { keyCode: 123, code: "F12", key: "F12" },
  F13: { keyCode: 124, code: "F13", key: "F13" },
  F14: { keyCode: 125, code: "F14", key: "F14" },
  F15: { keyCode: 126, code: "F15", key: "F15" },
  F16: { keyCode: 127, code: "F16", key: "F16" },
  F17: { keyCode: 128, code: "F17", key: "F17" },
  F18: { keyCode: 129, code: "F18", key: "F18" },
  F19: { keyCode: 130, code: "F19", key: "F19" },
  F20: { keyCode: 131, code: "F20", key: "F20" },
  F21: { keyCode: 132, code: "F21", key: "F21" },
  F22: { keyCode: 133, code: "F22", key: "F22" },
  F23: { keyCode: 134, code: "F23", key: "F23" },
  F24: { keyCode: 135, code: "F24", key: "F24" },
  NumLock: { keyCode: 144, code: "NumLock", key: "NumLock" },
  ScrollLock: { keyCode: 145, code: "ScrollLock", key: "ScrollLock" },
  AudioVolumeMute: {
    keyCode: 173,
    code: "AudioVolumeMute",
    key: "AudioVolumeMute"
  },
  AudioVolumeDown: {
    keyCode: 174,
    code: "AudioVolumeDown",
    key: "AudioVolumeDown"
  },
  AudioVolumeUp: { keyCode: 175, code: "AudioVolumeUp", key: "AudioVolumeUp" },
  MediaTrackNext: {
    keyCode: 176,
    code: "MediaTrackNext",
    key: "MediaTrackNext"
  },
  MediaTrackPrevious: {
    keyCode: 177,
    code: "MediaTrackPrevious",
    key: "MediaTrackPrevious"
  },
  MediaStop: { keyCode: 178, code: "MediaStop", key: "MediaStop" },
  MediaPlayPause: {
    keyCode: 179,
    code: "MediaPlayPause",
    key: "MediaPlayPause"
  },
  Semicolon: { keyCode: 186, code: "Semicolon", shiftKey: ":", key: ";" },
  Equal: { keyCode: 187, code: "Equal", shiftKey: "+", key: "=" },
  NumpadEqual: { keyCode: 187, code: "NumpadEqual", key: "=", location: 3 },
  Comma: { keyCode: 188, code: "Comma", shiftKey: "<", key: "," },
  Minus: { keyCode: 189, code: "Minus", shiftKey: "_", key: "-" },
  Period: { keyCode: 190, code: "Period", shiftKey: ">", key: "." },
  Slash: { keyCode: 191, code: "Slash", shiftKey: "?", key: "/" },
  Backquote: { keyCode: 192, code: "Backquote", shiftKey: "~", key: "`" },
  BracketLeft: { keyCode: 219, code: "BracketLeft", shiftKey: "{", key: "[" },
  Backslash: { keyCode: 220, code: "Backslash", shiftKey: "|", key: "\\" },
  BracketRight: { keyCode: 221, code: "BracketRight", shiftKey: "}", key: "]" },
  Quote: { keyCode: 222, code: "Quote", shiftKey: '"', key: "'" },
  AltGraph: { keyCode: 225, code: "AltGraph", key: "AltGraph" },
  Props: { keyCode: 247, code: "Props", key: "CrSel" },
  Cancel: { keyCode: 3, key: "Cancel", code: "Abort" },
  Clear: { keyCode: 12, key: "Clear", code: "Numpad5", location: 3 },
  Shift: { keyCode: 16, key: "Shift", code: "ShiftLeft", location: 1 },
  Control: { keyCode: 17, key: "Control", code: "ControlLeft", location: 1 },
  Alt: { keyCode: 18, key: "Alt", code: "AltLeft", location: 1 },
  Accept: { keyCode: 30, key: "Accept" },
  ModeChange: { keyCode: 31, key: "ModeChange" },
  " ": { keyCode: 32, key: " ", code: "Space" },
  Print: { keyCode: 42, key: "Print" },
  Execute: { keyCode: 43, key: "Execute", code: "Open" },
  "\0": { keyCode: 46, key: "\0", code: "NumpadDecimal", location: 3 },
  a: { keyCode: 65, key: "a", code: "KeyA" },
  b: { keyCode: 66, key: "b", code: "KeyB" },
  c: { keyCode: 67, key: "c", code: "KeyC" },
  d: { keyCode: 68, key: "d", code: "KeyD" },
  e: { keyCode: 69, key: "e", code: "KeyE" },
  f: { keyCode: 70, key: "f", code: "KeyF" },
  g: { keyCode: 71, key: "g", code: "KeyG" },
  h: { keyCode: 72, key: "h", code: "KeyH" },
  i: { keyCode: 73, key: "i", code: "KeyI" },
  j: { keyCode: 74, key: "j", code: "KeyJ" },
  k: { keyCode: 75, key: "k", code: "KeyK" },
  l: { keyCode: 76, key: "l", code: "KeyL" },
  m: { keyCode: 77, key: "m", code: "KeyM" },
  n: { keyCode: 78, key: "n", code: "KeyN" },
  o: { keyCode: 79, key: "o", code: "KeyO" },
  p: { keyCode: 80, key: "p", code: "KeyP" },
  q: { keyCode: 81, key: "q", code: "KeyQ" },
  r: { keyCode: 82, key: "r", code: "KeyR" },
  s: { keyCode: 83, key: "s", code: "KeyS" },
  t: { keyCode: 84, key: "t", code: "KeyT" },
  u: { keyCode: 85, key: "u", code: "KeyU" },
  v: { keyCode: 86, key: "v", code: "KeyV" },
  w: { keyCode: 87, key: "w", code: "KeyW" },
  x: { keyCode: 88, key: "x", code: "KeyX" },
  y: { keyCode: 89, key: "y", code: "KeyY" },
  z: { keyCode: 90, key: "z", code: "KeyZ" },
  Meta: { keyCode: 91, key: "Meta", code: "MetaLeft", location: 1 },
  "*": { keyCode: 106, key: "*", code: "NumpadMultiply", location: 3 },
  "+": { keyCode: 107, key: "+", code: "NumpadAdd", location: 3 },
  "-": { keyCode: 109, key: "-", code: "NumpadSubtract", location: 3 },
  "/": { keyCode: 111, key: "/", code: "NumpadDivide", location: 3 },
  ";": { keyCode: 186, key: ";", code: "Semicolon" },
  "=": { keyCode: 187, key: "=", code: "Equal" },
  ",": { keyCode: 188, key: ",", code: "Comma" },
  ".": { keyCode: 190, key: ".", code: "Period" },
  "`": { keyCode: 192, key: "`", code: "Backquote" },
  "[": { keyCode: 219, key: "[", code: "BracketLeft" },
  "\\": { keyCode: 220, key: "\\", code: "Backslash" },
  "]": { keyCode: 221, key: "]", code: "BracketRight" },
  "'": { keyCode: 222, key: "'", code: "Quote" },
  Attn: { keyCode: 246, key: "Attn" },
  CrSel: { keyCode: 247, key: "CrSel", code: "Props" },
  ExSel: { keyCode: 248, key: "ExSel" },
  EraseEof: { keyCode: 249, key: "EraseEof" },
  Play: { keyCode: 250, key: "Play" },
  ZoomOut: { keyCode: 251, key: "ZoomOut" },
  ")": { keyCode: 48, key: ")", code: "Digit0" },
  "!": { keyCode: 49, key: "!", code: "Digit1" },
  "@": { keyCode: 50, key: "@", code: "Digit2" },
  "#": { keyCode: 51, key: "#", code: "Digit3" },
  $: { keyCode: 52, key: "$", code: "Digit4" },
  "%": { keyCode: 53, key: "%", code: "Digit5" },
  "^": { keyCode: 54, key: "^", code: "Digit6" },
  "&": { keyCode: 55, key: "&", code: "Digit7" },
  "(": { keyCode: 57, key: "(", code: "Digit9" },
  A: { keyCode: 65, key: "A", code: "KeyA" },
  B: { keyCode: 66, key: "B", code: "KeyB" },
  C: { keyCode: 67, key: "C", code: "KeyC" },
  D: { keyCode: 68, key: "D", code: "KeyD" },
  E: { keyCode: 69, key: "E", code: "KeyE" },
  F: { keyCode: 70, key: "F", code: "KeyF" },
  G: { keyCode: 71, key: "G", code: "KeyG" },
  H: { keyCode: 72, key: "H", code: "KeyH" },
  I: { keyCode: 73, key: "I", code: "KeyI" },
  J: { keyCode: 74, key: "J", code: "KeyJ" },
  K: { keyCode: 75, key: "K", code: "KeyK" },
  L: { keyCode: 76, key: "L", code: "KeyL" },
  M: { keyCode: 77, key: "M", code: "KeyM" },
  N: { keyCode: 78, key: "N", code: "KeyN" },
  O: { keyCode: 79, key: "O", code: "KeyO" },
  P: { keyCode: 80, key: "P", code: "KeyP" },
  Q: { keyCode: 81, key: "Q", code: "KeyQ" },
  R: { keyCode: 82, key: "R", code: "KeyR" },
  S: { keyCode: 83, key: "S", code: "KeyS" },
  T: { keyCode: 84, key: "T", code: "KeyT" },
  U: { keyCode: 85, key: "U", code: "KeyU" },
  V: { keyCode: 86, key: "V", code: "KeyV" },
  W: { keyCode: 87, key: "W", code: "KeyW" },
  X: { keyCode: 88, key: "X", code: "KeyX" },
  Y: { keyCode: 89, key: "Y", code: "KeyY" },
  Z: { keyCode: 90, key: "Z", code: "KeyZ" },
  ":": { keyCode: 186, key: ":", code: "Semicolon" },
  "<": { keyCode: 188, key: "<", code: "Comma" },
  _: { keyCode: 189, key: "_", code: "Minus" },
  ">": { keyCode: 190, key: ">", code: "Period" },
  "?": { keyCode: 191, key: "?", code: "Slash" },
  "~": { keyCode: 192, key: "~", code: "Backquote" },
  "{": { keyCode: 219, key: "{", code: "BracketLeft" },
  "|": { keyCode: 220, key: "|", code: "Backslash" },
  "}": { keyCode: 221, key: "}", code: "BracketRight" },
  '"': { keyCode: 222, key: '"', code: "Quote" },
  SoftLeft: { key: "SoftLeft", code: "SoftLeft", location: 4 },
  SoftRight: { key: "SoftRight", code: "SoftRight", location: 4 },
  Camera: { keyCode: 44, key: "Camera", code: "Camera", location: 4 },
  Call: { key: "Call", code: "Call", location: 4 },
  EndCall: { keyCode: 95, key: "EndCall", code: "EndCall", location: 4 },
  VolumeDown: {
    keyCode: 182,
    key: "VolumeDown",
    code: "VolumeDown",
    location: 4
  },
  VolumeUp: { keyCode: 183, key: "VolumeUp", code: "VolumeUp", location: 4 }
};
/**
 * @license
 * Copyright 2017 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
var ca, cc, xa, DD, SD;
class BAA extends w7 {
  constructor(e) {
    super();
    k(this, xa);
    k(this, ca);
    k(this, cc, /* @__PURE__ */ new Set());
    R(this, "_modifiers", 0);
    x(this, ca, e);
  }
  updateClient(e) {
    x(this, ca, e);
  }
  async down(e, r = {
    text: void 0,
    commands: []
  }) {
    const i = O(this, xa, SD).call(this, e), n = d(this, cc).has(i.code);
    d(this, cc).add(i.code), this._modifiers |= O(this, xa, DD).call(this, i.key);
    const s = r.text === void 0 ? i.text : r.text;
    await d(this, ca).send("Input.dispatchKeyEvent", {
      type: s ? "keyDown" : "rawKeyDown",
      modifiers: this._modifiers,
      windowsVirtualKeyCode: i.keyCode,
      code: i.code,
      key: i.key,
      text: s,
      unmodifiedText: s,
      autoRepeat: n,
      location: i.location,
      isKeypad: i.location === 3,
      commands: r.commands
    });
  }
  async up(e) {
    const r = O(this, xa, SD).call(this, e);
    this._modifiers &= ~O(this, xa, DD).call(this, r.key), d(this, cc).delete(r.code), await d(this, ca).send("Input.dispatchKeyEvent", {
      type: "keyUp",
      modifiers: this._modifiers,
      key: r.key,
      windowsVirtualKeyCode: r.keyCode,
      code: r.code,
      location: r.location
    });
  }
  async sendCharacter(e) {
    await d(this, ca).send("Input.insertText", { text: e });
  }
  charIsKey(e) {
    return !!lR[e];
  }
  async type(e, r = {}) {
    const i = r.delay || void 0;
    for (const n of e)
      this.charIsKey(n) ? await this.press(n, { delay: i }) : (i && await new Promise((s) => setTimeout(s, i)), await this.sendCharacter(n));
  }
  async press(e, r = {}) {
    const { delay: i = null } = r;
    await this.down(e, r), i && await new Promise((n) => setTimeout(n, r.delay)), await this.up(e);
  }
}
ca = new WeakMap(), cc = new WeakMap(), xa = new WeakSet(), DD = function(e) {
  return e === "Alt" ? 1 : e === "Control" ? 2 : e === "Meta" ? 4 : e === "Shift" ? 8 : 0;
}, SD = function(e) {
  const r = this._modifiers & 8, i = {
    key: "",
    keyCode: 0,
    code: "",
    text: "",
    location: 0
  }, n = lR[e];
  return bA(n, `Unknown key: "${e}"`), n.key && (i.key = n.key), r && n.shiftKey && (i.key = n.shiftKey), n.keyCode && (i.keyCode = n.keyCode), r && n.shiftKeyCode && (i.keyCode = n.shiftKeyCode), n.code && (i.code = n.code), n.location && (i.location = n.location), i.key.length === 1 && (i.text = i.key), n.text && (i.text = n.text), r && n.shiftText && (i.text = n.shiftText), this._modifiers & -9 && (i.text = ""), i;
};
const BR = (t) => {
  switch (t) {
    case Ot.Left:
      return 1;
    case Ot.Right:
      return 2;
    case Ot.Middle:
      return 4;
    case Ot.Back:
      return 8;
    case Ot.Forward:
      return 16;
  }
}, EAA = (t) => t & 1 ? Ot.Left : t & 2 ? Ot.Right : t & 4 ? Ot.Middle : t & 8 ? Ot.Back : t & 16 ? Ot.Forward : "none";
var Nr, Di, Ic, tt, kr, Xo, cT, id;
class hAA extends m7 {
  constructor(e, r) {
    super();
    k(this, tt);
    k(this, Nr);
    k(this, Di);
    k(this, Ic, {
      position: { x: 0, y: 0 },
      buttons: 0
    });
    // Transactions can run in parallel, so we store each of thme in this array.
    k(this, Xo, []);
    x(this, Nr, e), x(this, Di, r);
  }
  updateClient(e) {
    x(this, Nr, e);
  }
  async reset() {
    const e = [];
    for (const [r, i] of [
      [1, Ot.Left],
      [4, Ot.Middle],
      [2, Ot.Right],
      [16, Ot.Forward],
      [8, Ot.Back]
    ])
      d(this, tt, kr).buttons & r && e.push(this.up({ button: i }));
    (d(this, tt, kr).position.x !== 0 || d(this, tt, kr).position.y !== 0) && e.push(this.move(0, 0)), await Promise.all(e);
  }
  async move(e, r, i = {}) {
    const { steps: n = 1 } = i, s = d(this, tt, kr).position, a = { x: e, y: r };
    for (let g = 1; g <= n; g++)
      await O(this, tt, id).call(this, (o) => {
        o({
          position: {
            x: s.x + (a.x - s.x) * (g / n),
            y: s.y + (a.y - s.y) * (g / n)
          }
        });
        const { buttons: u, position: I } = d(this, tt, kr);
        return d(this, Nr).send("Input.dispatchMouseEvent", {
          type: "mouseMoved",
          modifiers: d(this, Di)._modifiers,
          buttons: u,
          button: EAA(u),
          ...I
        });
      });
  }
  async down(e = {}) {
    const { button: r = Ot.Left, clickCount: i = 1 } = e, n = BR(r);
    if (!n)
      throw new Error(`Unsupported mouse button: ${r}`);
    if (d(this, tt, kr).buttons & n)
      throw new Error(`'${r}' is already pressed.`);
    await O(this, tt, id).call(this, (s) => {
      s({
        buttons: d(this, tt, kr).buttons | n
      });
      const { buttons: a, position: g } = d(this, tt, kr);
      return d(this, Nr).send("Input.dispatchMouseEvent", {
        type: "mousePressed",
        modifiers: d(this, Di)._modifiers,
        clickCount: i,
        buttons: a,
        button: r,
        ...g
      });
    });
  }
  async up(e = {}) {
    const { button: r = Ot.Left, clickCount: i = 1 } = e, n = BR(r);
    if (!n)
      throw new Error(`Unsupported mouse button: ${r}`);
    if (!(d(this, tt, kr).buttons & n))
      throw new Error(`'${r}' is not pressed.`);
    await O(this, tt, id).call(this, (s) => {
      s({
        buttons: d(this, tt, kr).buttons & ~n
      });
      const { buttons: a, position: g } = d(this, tt, kr);
      return d(this, Nr).send("Input.dispatchMouseEvent", {
        type: "mouseReleased",
        modifiers: d(this, Di)._modifiers,
        clickCount: i,
        buttons: a,
        button: r,
        ...g
      });
    });
  }
  async click(e, r, i = {}) {
    const { delay: n, count: s = 1, clickCount: a = s } = i;
    if (s < 1)
      throw new Error("Click must occur a positive number of times.");
    const g = [this.move(e, r)];
    if (a === s)
      for (let o = 1; o < s; ++o)
        g.push(this.down({ ...i, clickCount: o }), this.up({ ...i, clickCount: o }));
    g.push(this.down({ ...i, clickCount: a })), typeof n == "number" && (await Promise.all(g), g.length = 0, await new Promise((o) => {
      setTimeout(o, n);
    })), g.push(this.up({ ...i, clickCount: a })), await Promise.all(g);
  }
  async wheel(e = {}) {
    const { deltaX: r = 0, deltaY: i = 0 } = e, { position: n, buttons: s } = d(this, tt, kr);
    await d(this, Nr).send("Input.dispatchMouseEvent", {
      type: "mouseWheel",
      pointerType: "mouse",
      modifiers: d(this, Di)._modifiers,
      deltaY: i,
      deltaX: r,
      buttons: s,
      ...n
    });
  }
  async drag(e, r) {
    const i = new Promise((n) => {
      d(this, Nr).once("Input.dragIntercepted", (s) => n(s.data));
    });
    return await this.move(e.x, e.y), await this.down(), await this.move(r.x, r.y), await i;
  }
  async dragEnter(e, r) {
    await d(this, Nr).send("Input.dispatchDragEvent", {
      type: "dragEnter",
      x: e.x,
      y: e.y,
      modifiers: d(this, Di)._modifiers,
      data: r
    });
  }
  async dragOver(e, r) {
    await d(this, Nr).send("Input.dispatchDragEvent", {
      type: "dragOver",
      x: e.x,
      y: e.y,
      modifiers: d(this, Di)._modifiers,
      data: r
    });
  }
  async drop(e, r) {
    await d(this, Nr).send("Input.dispatchDragEvent", {
      type: "drop",
      x: e.x,
      y: e.y,
      modifiers: d(this, Di)._modifiers,
      data: r
    });
  }
  async dragAndDrop(e, r, i = {}) {
    const { delay: n = null } = i, s = await this.drag(e, r);
    await this.dragEnter(r, s), await this.dragOver(r, s), n && await new Promise((a) => setTimeout(a, n)), await this.drop(r, s), await this.up();
  }
}
Nr = new WeakMap(), Di = new WeakMap(), Ic = new WeakMap(), tt = new WeakSet(), kr = function() {
  return Object.assign({ ...d(this, Ic) }, ...d(this, Xo));
}, Xo = new WeakMap(), cT = function() {
  const e = {};
  d(this, Xo).push(e);
  const r = () => {
    d(this, Xo).splice(d(this, Xo).indexOf(e), 1);
  };
  return {
    update: (i) => {
      Object.assign(e, i);
    },
    commit: () => {
      x(this, Ic, { ...d(this, Ic), ...e }), r();
    },
    rollback: r
  };
}, id = async function(e) {
  const { update: r, commit: i, rollback: n } = O(this, tt, cT).call(this);
  try {
    await e(r), i();
  } catch (s) {
    throw n(), s;
  }
};
var qB, jB, zn, Ia, zo;
class QAA {
  constructor(A, e, r, i) {
    k(this, qB, !1);
    k(this, jB);
    k(this, zn);
    k(this, Ia);
    k(this, zo);
    x(this, Ia, A), x(this, jB, e), x(this, zo, r), x(this, zn, i);
  }
  updateClient(A) {
    x(this, Ia, A);
  }
  async start() {
    if (d(this, qB))
      throw new Nm("Touch has already started");
    await d(this, Ia).send("Input.dispatchTouchEvent", {
      type: "touchStart",
      touchPoints: [d(this, zn)],
      modifiers: d(this, zo)._modifiers
    }), x(this, qB, !0);
  }
  move(A, e) {
    return d(this, zn).x = Math.round(A), d(this, zn).y = Math.round(e), d(this, Ia).send("Input.dispatchTouchEvent", {
      type: "touchMove",
      touchPoints: [d(this, zn)],
      modifiers: d(this, zo)._modifiers
    });
  }
  async end() {
    await d(this, Ia).send("Input.dispatchTouchEvent", {
      type: "touchEnd",
      touchPoints: [d(this, zn)],
      modifiers: d(this, zo)._modifiers
    }), d(this, jB).removeHandle(this);
  }
}
qB = new WeakMap(), jB = new WeakMap(), zn = new WeakMap(), Ia = new WeakMap(), zo = new WeakMap();
var Cc, WB;
class dAA extends D7 {
  constructor(e, r) {
    super();
    k(this, Cc);
    k(this, WB);
    x(this, Cc, e), x(this, WB, r);
  }
  updateClient(e) {
    x(this, Cc, e), this.touches.forEach((r) => {
      r.updateClient(e);
    });
  }
  async touchStart(e, r) {
    const i = this.idGenerator(), n = {
      x: Math.round(e),
      y: Math.round(r),
      radiusX: 0.5,
      radiusY: 0.5,
      force: 0.5,
      id: i
    }, s = new QAA(d(this, Cc), this, d(this, WB), n);
    return await s.start(), this.touches.push(s), s;
  }
}
Cc = new WeakMap(), WB = new WeakMap();
var $n, lc, VB;
class fAA {
  /**
   * @internal
   */
  constructor(A) {
    k(this, $n);
    k(this, lc, !1);
    k(this, VB);
    x(this, $n, A);
  }
  /**
   * @internal
   */
  updateClient(A) {
    x(this, $n, A);
  }
  /**
   * Starts a trace for the current page.
   * @remarks
   * Only one trace can be active at a time per browser.
   *
   * @param options - Optional `TracingOptions`.
   */
  async start(A = {}) {
    bA(!d(this, lc), "Cannot start recording trace while already recording trace.");
    const e = [
      "-*",
      "devtools.timeline",
      "v8.execute",
      "disabled-by-default-devtools.timeline",
      "disabled-by-default-devtools.timeline.frame",
      "toplevel",
      "blink.console",
      "blink.user_timing",
      "latencyInfo",
      "disabled-by-default-devtools.timeline.stack",
      "disabled-by-default-v8.cpu_profiler"
    ], { path: r, screenshots: i = !1, categories: n = e } = A;
    i && n.push("disabled-by-default-devtools.screenshot");
    const s = n.filter((g) => g.startsWith("-")).map((g) => g.slice(1)), a = n.filter((g) => !g.startsWith("-"));
    x(this, VB, r), x(this, lc, !0), await d(this, $n).send("Tracing.start", {
      transferMode: "ReturnAsStream",
      traceConfig: {
        excludedCategories: s,
        includedCategories: a
      }
    });
  }
  /**
   * Stops a trace started with the `start` method.
   * @returns Promise which resolves to buffer with trace data.
   */
  async stop() {
    const A = Ke.create();
    return d(this, $n).once("Tracing.tracingComplete", async (e) => {
      try {
        bA(e.stream, 'Missing "stream"');
        const r = await ZU(d(this, $n), e.stream), i = await VU(r, d(this, VB));
        A.resolve(i ?? void 0);
      } catch (r) {
        _i(r) ? A.reject(r) : A.reject(new Error(`Unknown error: ${r}`));
      }
    }), await d(this, $n).send("Tracing.end"), x(this, lc, !1), await A.valueOrThrow();
  }
}
$n = new WeakMap(), lc = new WeakMap(), VB = new WeakMap();
var rn, nn, Bc, ZB;
class IT extends N7 {
  constructor(e, r, i, n, s, a, g) {
    super(r);
    k(this, rn);
    k(this, nn);
    k(this, Bc);
    k(this, ZB);
    x(this, Bc, i), x(this, nn, e), x(this, ZB, n), x(this, rn, new ID(this, new LS())), d(this, nn).once("Runtime.executionContextCreated", async (o) => {
      d(this, rn).setContext(new v1(e, o.context, d(this, rn)));
    }), d(this, rn).emitter.on("consoleapicalled", async (o) => {
      try {
        return s(o.type, o.args.map((u) => new Sp(d(this, rn), u)), o.stackTrace);
      } catch (u) {
        HA(u);
      }
    }), d(this, nn).on("Runtime.exceptionThrown", a), d(this, nn).once(He.Disconnected, () => {
      d(this, rn).dispose();
    }), g == null || g.addClient(d(this, nn)).catch(HA), d(this, nn).send("Runtime.enable").catch(HA);
  }
  mainRealm() {
    return d(this, rn);
  }
  get client() {
    return d(this, nn);
  }
  async close() {
    var e, r, i;
    switch (d(this, ZB)) {
      case xr.SERVICE_WORKER: {
        await ((e = this.client.connection()) == null ? void 0 : e.send("Target.closeTarget", {
          targetId: d(this, Bc)
        })), await ((r = this.client.connection()) == null ? void 0 : r.send("Target.detachFromTarget", {
          sessionId: this.client.id()
        }));
        break;
      }
      case xr.SHARED_WORKER: {
        await ((i = this.client.connection()) == null ? void 0 : i.send("Target.closeTarget", {
          targetId: d(this, Bc)
        }));
        break;
      }
      default:
        await this.evaluate(() => {
          self.close();
        });
    }
  }
}
rn = new WeakMap(), nn = new WeakMap(), Bc = new WeakMap(), ZB = new WeakMap();
/**
 * @license
 * Copyright 2017 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
var ky = function(t, A, e) {
  if (A != null) {
    if (typeof A != "object" && typeof A != "function") throw new TypeError("Object expected.");
    var r, i;
    if (e) {
      if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
      r = A[Symbol.asyncDispose];
    }
    if (r === void 0) {
      if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
      r = A[Symbol.dispose], e && (i = r);
    }
    if (typeof r != "function") throw new TypeError("Object not disposable.");
    i && (r = function() {
      try {
        i.call(this);
      } catch (n) {
        return Promise.reject(n);
      }
    }), t.stack.push({ value: A, dispose: r, async: e });
  } else e && t.stack.push({ async: !0 });
  return A;
}, vy = /* @__PURE__ */ function(t) {
  return function(A) {
    function e(s) {
      A.error = A.hasError ? new t(s, A.error, "An error was suppressed during disposal.") : s, A.hasError = !0;
    }
    var r, i = 0;
    function n() {
      for (; r = A.stack.pop(); )
        try {
          if (!r.async && i === 1) return i = 0, A.stack.push(r), Promise.resolve().then(n);
          if (r.dispose) {
            var s = r.dispose.call(r.value);
            if (r.async) return i |= 2, Promise.resolve(s).then(n, function(a) {
              return e(a), n();
            });
          } else i |= 1;
        } catch (a) {
          e(a);
        }
      if (i === 1) return A.hasError ? Promise.reject(A.error) : Promise.resolve();
      if (A.hasError) throw A.error;
    }
    return n();
  };
}(typeof SuppressedError == "function" ? SuppressedError : function(t, A, e) {
  var r = new Error(e);
  return r.name = "SuppressedError", r.error = t, r.suppressed = A, r;
});
function Ry(t) {
  switch (t) {
    case "warning":
      return "warn";
    default:
      return t;
  }
}
var XB, Ca, zB, pe, Si, la, $o, Ba, Ec, hc, xe, et, Qc, Ea, dc, fc, pc, Ag, As, mf, $B, AE, ce, CT, lT, BT, FD, eE, yc, ET, hT, QT, dT, fT, kD, vD, pT, yT, RD, wT, bD;
const tF = class tF extends v7 {
  constructor(e, r) {
    super();
    k(this, ce);
    k(this, XB, !1);
    k(this, Ca);
    k(this, zB);
    k(this, pe);
    k(this, Si);
    k(this, la);
    k(this, $o);
    k(this, Ba);
    k(this, Ec);
    k(this, hc);
    k(this, xe);
    k(this, et);
    k(this, Qc);
    k(this, Ea, /* @__PURE__ */ new Map());
    k(this, dc, /* @__PURE__ */ new Map());
    k(this, fc);
    k(this, pc);
    k(this, Ag, /* @__PURE__ */ new Map());
    k(this, As, /* @__PURE__ */ new Set());
    k(this, mf, Ke.create());
    k(this, $B, !1);
    k(this, AE, !1);
    k(this, eE, (e) => {
      var n;
      const r = (n = e._session()) == null ? void 0 : n.id(), i = d(this, Ag).get(r);
      i && (d(this, Ag).delete(r), this.emit("workerdestroyed", i));
    });
    k(this, yc, (e) => {
      if (bA(e instanceof uu), d(this, xe).onAttachedToTarget(e.target()), e.target()._getTargetInfo().type === "worker") {
        const r = new IT(e, e.target().url(), e.target()._targetId, e.target().type(), O(this, ce, RD).bind(this), O(this, ce, vD).bind(this), d(this, xe).networkManager);
        d(this, Ag).set(e.id(), r), this.emit("workercreated", r);
      }
      e.on(He.Ready, d(this, yc));
    });
    x(this, pe, e), x(this, la, e.parentSession()), bA(d(this, la), "Tab target session is not defined."), x(this, $o, d(this, la).target()), bA(d(this, $o), "Tab target is not defined."), x(this, Si, r), x(this, Ca, r._targetManager()), x(this, Ba, new BAA(e)), x(this, Ec, new hAA(e, d(this, Ba))), x(this, hc, new dAA(e, d(this, Ba))), x(this, xe, new lAA(e, this, this._timeoutSettings)), x(this, et, new W7(e)), x(this, Qc, new fAA(e)), x(this, fc, new P7(e)), x(this, pc, null), x(this, zB, new U7(d(this, pe).connection()));
    const i = new je(d(this, xe));
    i.on(vt.FrameAttached, (s) => {
      this.emit("frameattached", s);
    }), i.on(vt.FrameDetached, (s) => {
      this.emit("framedetached", s);
    }), i.on(vt.FrameNavigated, (s) => {
      this.emit("framenavigated", s);
    }), i.on(vt.ConsoleApiCalled, ([s, a]) => {
      O(this, ce, pT).call(this, s, a);
    }), i.on(vt.BindingCalled, ([s, a]) => {
      O(this, ce, yT).call(this, s, a);
    });
    const n = new je(d(this, xe).networkManager);
    n.on(kt.Request, (s) => {
      this.emit("request", s);
    }), n.on(kt.RequestServedFromCache, (s) => {
      this.emit("requestservedfromcache", s);
    }), n.on(kt.Response, (s) => {
      this.emit("response", s);
    }), n.on(kt.RequestFailed, (s) => {
      this.emit("requestfailed", s);
    }), n.on(kt.RequestFinished, (s) => {
      this.emit("requestfinished", s);
    }), d(this, la).on(He.Swapped, O(this, ce, lT).bind(this)), d(this, la).on(He.Ready, O(this, ce, BT).bind(this)), d(this, Ca).on("targetGone", d(this, eE)), d(this, $o)._isClosedDeferred.valueOrThrow().then(() => {
      d(this, Ca).off("targetGone", d(this, eE)), this.emit("close", void 0), x(this, XB, !0);
    }).catch(HA), O(this, ce, FD).call(this), O(this, ce, CT).call(this);
  }
  static async _create(e, r, i) {
    var s;
    const n = new tF(e, r);
    if (await O(s = n, ce, ET).call(s), i)
      try {
        await n.setViewport(i);
      } catch (a) {
        if (_i(a) && ef(a))
          HA(a);
        else
          throw a;
      }
    return n;
  }
  async resize(e) {
    const r = await this.windowId();
    await d(this, pe).send("Browser.setContentsSize", {
      windowId: Number(r),
      width: e.contentWidth,
      height: e.contentHeight
    });
  }
  async windowId() {
    const { windowId: e } = await d(this, pe).send("Browser.getWindowForTarget");
    return e.toString();
  }
  _client() {
    return d(this, pe);
  }
  isServiceWorkerBypassed() {
    return d(this, $B);
  }
  isDragInterceptionEnabled() {
    return d(this, AE);
  }
  isJavaScriptEnabled() {
    return d(this, et).javascriptEnabled;
  }
  async openDevTools() {
    const e = this.target()._targetId;
    return await this.browser()._createDevToolsPage(e);
  }
  async waitForFileChooser(e = {}) {
    const r = d(this, As).size === 0, { timeout: i = this._timeoutSettings.timeout() } = e, n = Ke.create({
      message: `Waiting for \`FileChooser\` failed: ${i}ms exceeded`,
      timeout: i
    });
    e.signal && e.signal.addEventListener("abort", () => {
      var a;
      n.reject((a = e.signal) == null ? void 0 : a.reason);
    }, { once: !0 }), d(this, As).add(n);
    let s;
    r && (s = d(this, pe).send("Page.setInterceptFileChooserDialog", {
      enabled: !0
    }));
    try {
      const [a] = await Promise.all([
        n.valueOrThrow(),
        s
      ]);
      return a;
    } catch (a) {
      throw d(this, As).delete(n), a;
    }
  }
  async setGeolocation(e) {
    return await d(this, et).setGeolocation(e);
  }
  target() {
    return d(this, Si);
  }
  browser() {
    return d(this, Si).browser();
  }
  browserContext() {
    return d(this, Si).browserContext();
  }
  mainFrame() {
    return d(this, xe).mainFrame();
  }
  get keyboard() {
    return d(this, Ba);
  }
  get touchscreen() {
    return d(this, hc);
  }
  get coverage() {
    return d(this, fc);
  }
  get tracing() {
    return d(this, Qc);
  }
  frames() {
    return d(this, xe).frames();
  }
  workers() {
    return Array.from(d(this, Ag).values());
  }
  async setRequestInterception(e) {
    return await d(this, xe).networkManager.setRequestInterception(e);
  }
  async setBypassServiceWorker(e) {
    return x(this, $B, e), await d(this, pe).send("Network.setBypassServiceWorker", { bypass: e });
  }
  async setDragInterception(e) {
    return x(this, AE, e), await d(this, pe).send("Input.setInterceptDrags", {
      enabled: e
    });
  }
  async setOfflineMode(e) {
    return await d(this, xe).networkManager.setOfflineMode(e);
  }
  async emulateNetworkConditions(e) {
    return await d(this, xe).networkManager.emulateNetworkConditions(e);
  }
  async emulateFocusedPage(e) {
    return await d(this, et).emulateFocus(e);
  }
  setDefaultNavigationTimeout(e) {
    this._timeoutSettings.setDefaultNavigationTimeout(e);
  }
  setDefaultTimeout(e) {
    this._timeoutSettings.setDefaultTimeout(e);
  }
  getDefaultTimeout() {
    return this._timeoutSettings.timeout();
  }
  getDefaultNavigationTimeout() {
    return this._timeoutSettings.navigationTimeout();
  }
  async queryObjects(e) {
    bA(!e.disposed, "Prototype JSHandle is disposed!"), bA(e.id, "Prototype JSHandle must not be referencing primitive value");
    const r = await this.mainFrame().client.send("Runtime.queryObjects", {
      prototypeObjectId: e.id
    });
    return this.mainFrame().mainRealm().createCdpHandle(r.objects);
  }
  async cookies(...e) {
    const r = (await d(this, pe).send("Network.getCookies", {
      urls: e.length ? e : [this.url()]
    })).cookies, i = ["sourcePort"], n = (s) => {
      for (const a of i)
        delete s[a];
      return s;
    };
    return r.map(n).map((s) => ({
      ...s,
      // TODO: a breaking change is needed in Puppeteer types to support other
      // partition keys.
      partitionKey: s.partitionKey ? s.partitionKey.topLevelSite : void 0
    }));
  }
  async deleteCookie(...e) {
    const r = this.url();
    for (const i of e) {
      const n = {
        ...i,
        partitionKey: MD(i.partitionKey)
      };
      if (!i.url && r.startsWith("http") && (n.url = r), await d(this, pe).send("Network.deleteCookies", n), r.startsWith("http") && !n.partitionKey) {
        const s = new URL(r);
        await d(this, pe).send("Network.deleteCookies", {
          ...n,
          partitionKey: {
            topLevelSite: s.origin.replace(`:${s.port}`, ""),
            hasCrossSiteAncestor: !1
          }
        });
      }
    }
  }
  async setCookie(...e) {
    const r = this.url(), i = r.startsWith("http"), n = e.map((s) => {
      const a = Object.assign({}, s);
      return !a.url && i && (a.url = r), bA(a.url !== "about:blank", `Blank page can not have cookie "${a.name}"`), bA(!String.prototype.startsWith.call(a.url || "", "data:"), `Data URL page can not have cookie "${a.name}"`), a;
    });
    await this.deleteCookie(...n), n.length && await d(this, pe).send("Network.setCookies", {
      cookies: n.map((s) => ({
        ...s,
        partitionKey: MD(s.partitionKey)
      }))
    });
  }
  async exposeFunction(e, r) {
    if (d(this, Ea).has(e))
      throw new Error(`Failed to add page binding with name ${e}: window['${e}'] already exists!`);
    const i = $7("exposedFun", e);
    let n;
    switch (typeof r) {
      case "function":
        n = new $d(e, r, i);
        break;
      default:
        n = new $d(e, r.default, i);
        break;
    }
    d(this, Ea).set(e, n);
    const [{ identifier: s }] = await Promise.all([
      d(this, xe).evaluateOnNewDocument(i),
      d(this, xe).addExposedFunctionBinding(n)
    ]);
    d(this, dc).set(e, s);
  }
  async removeExposedFunction(e) {
    const r = d(this, dc).get(e);
    if (!r)
      throw new Error(`Function with name "${e}" does not exist`);
    const i = d(this, Ea).get(e);
    d(this, dc).delete(e), d(this, Ea).delete(e), await Promise.all([
      d(this, xe).removeScriptToEvaluateOnNewDocument(r),
      d(this, xe).removeExposedFunctionBinding(i)
    ]);
  }
  async authenticate(e) {
    return await d(this, xe).networkManager.authenticate(e);
  }
  async setExtraHTTPHeaders(e) {
    return await d(this, xe).networkManager.setExtraHTTPHeaders(e);
  }
  async setUserAgent(e, r) {
    if (typeof e == "string")
      return await d(this, xe).networkManager.setUserAgent(e, r);
    {
      const i = e.userAgent ?? await this.browser().userAgent();
      return await d(this, xe).networkManager.setUserAgent(i, e.userAgentMetadata, e.platform);
    }
  }
  async metrics() {
    const e = await d(this, pe).send("Performance.getMetrics");
    return O(this, ce, kD).call(this, e.metrics);
  }
  async reload(e) {
    const [r] = await Promise.all([
      this.waitForNavigation({
        ...e,
        ignoreSameDocumentNavigation: !0
      }),
      d(this, pe).send("Page.reload", {
        ignoreCache: (e == null ? void 0 : e.ignoreCache) ?? !1
      })
    ]);
    return r;
  }
  async createCDPSession() {
    return await this.target().createCDPSession();
  }
  async goBack(e = {}) {
    return await O(this, ce, bD).call(this, -1, e);
  }
  async goForward(e = {}) {
    return await O(this, ce, bD).call(this, 1, e);
  }
  async bringToFront() {
    await d(this, pe).send("Page.bringToFront");
  }
  async setJavaScriptEnabled(e) {
    return await d(this, et).setJavaScriptEnabled(e);
  }
  async setBypassCSP(e) {
    await d(this, pe).send("Page.setBypassCSP", { enabled: e });
  }
  async emulateMediaType(e) {
    return await d(this, et).emulateMediaType(e);
  }
  async emulateCPUThrottling(e) {
    return await d(this, et).emulateCPUThrottling(e);
  }
  async emulateMediaFeatures(e) {
    return await d(this, et).emulateMediaFeatures(e);
  }
  async emulateTimezone(e) {
    return await d(this, et).emulateTimezone(e);
  }
  async emulateIdleState(e) {
    return await d(this, et).emulateIdleState(e);
  }
  async emulateVisionDeficiency(e) {
    return await d(this, et).emulateVisionDeficiency(e);
  }
  async setViewport(e) {
    const r = await d(this, et).emulateViewport(e);
    x(this, pc, e), r && await this.reload();
  }
  viewport() {
    return d(this, pc);
  }
  async evaluateOnNewDocument(e, ...r) {
    const i = WU(e, ...r);
    return await d(this, xe).evaluateOnNewDocument(i);
  }
  async removeScriptToEvaluateOnNewDocument(e) {
    return await d(this, xe).removeScriptToEvaluateOnNewDocument(e);
  }
  async setCacheEnabled(e = !0) {
    await d(this, xe).networkManager.setCacheEnabled(e);
  }
  async _screenshot(e) {
    const r = { stack: [], error: void 0, hasError: !1 };
    try {
      const { fromSurface: i, omitBackground: n, optimizeForSpeed: s, quality: a, clip: g, type: o, captureBeyondViewport: u } = e, I = ky(r, new OU(), !0);
      n && (o === "png" || o === "webp") && (await d(this, et).setTransparentBackgroundColor(), I.defer(async () => {
        await d(this, et).resetDefaultBackgroundColor().catch(HA);
      }));
      let c = g;
      if (c && !u) {
        const E = await this.mainFrame().isolatedRealm().evaluate(() => {
          const { height: l, pageLeft: B, pageTop: h, width: Q } = window.visualViewport;
          return { x: B, y: h, height: l, width: Q };
        });
        c = yAA(c, E);
      }
      const { data: C } = await d(this, pe).send("Page.captureScreenshot", {
        format: o,
        optimizeForSpeed: s,
        fromSurface: i,
        ...a !== void 0 ? { quality: Math.round(a) } : {},
        ...c ? { clip: { ...c, scale: c.scale ?? 1 } } : {},
        captureBeyondViewport: u
      });
      return C;
    } catch (i) {
      r.error = i, r.hasError = !0;
    } finally {
      const i = vy(r);
      i && await i;
    }
  }
  async createPDFStream(e = {}) {
    const { timeout: r = this._timeoutSettings.timeout() } = e, { landscape: i, displayHeaderFooter: n, headerTemplate: s, footerTemplate: a, printBackground: g, scale: o, width: u, height: I, margin: c, pageRanges: C, preferCSSPageSize: E, omitBackground: l, tagged: B, outline: h, waitForFonts: Q } = M$(e);
    l && await d(this, et).setTransparentBackgroundColor(), Q && await or(de(this.mainFrame().isolatedRealm().evaluate(() => document.fonts.ready)).pipe(ln(Bn(r))));
    const f = d(this, pe).send("Page.printToPDF", {
      transferMode: "ReturnAsStream",
      landscape: i,
      displayHeaderFooter: n,
      headerTemplate: s,
      footerTemplate: a,
      printBackground: g,
      scale: o,
      paperWidth: u,
      paperHeight: I,
      marginTop: c.top,
      marginBottom: c.bottom,
      marginLeft: c.left,
      marginRight: c.right,
      pageRanges: C,
      preferCSSPageSize: E,
      generateTaggedPDF: B,
      generateDocumentOutline: h
    }), p = await or(de(f).pipe(ln(Bn(r))));
    return l && await d(this, et).resetDefaultBackgroundColor(), bA(p.stream, "`stream` is missing from `Page.printToPDF"), await ZU(d(this, pe), p.stream);
  }
  async pdf(e = {}) {
    const { path: r = void 0 } = e, i = await this.createPDFStream(e), n = await VU(i, r);
    return bA(n, "Could not create typed array"), n;
  }
  async close(e = { runBeforeUnload: void 0 }) {
    const r = { stack: [], error: void 0, hasError: !1 };
    try {
      const i = ky(r, await this.browserContext().waitForScreenshotOperations(), !1), n = d(this, pe).connection();
      bA(n, "Connection closed. Most likely the page has been closed."), !!e.runBeforeUnload ? await d(this, pe).send("Page.close") : (await n.send("Target.closeTarget", {
        targetId: d(this, Si)._targetId
      }), await d(this, $o)._isClosedDeferred.valueOrThrow());
    } catch (i) {
      r.error = i, r.hasError = !0;
    } finally {
      vy(r);
    }
  }
  isClosed() {
    return d(this, XB);
  }
  get mouse() {
    return d(this, Ec);
  }
  /**
   * This method is typically coupled with an action that triggers a device
   * request from an api such as WebBluetooth.
   *
   * :::caution
   *
   * This must be called before the device request is made. It will not return a
   * currently active device prompt.
   *
   * :::
   *
   * @example
   *
   * ```ts
   * const [devicePrompt] = Promise.all([
   *   page.waitForDevicePrompt(),
   *   page.click('#connect-bluetooth'),
   * ]);
   * await devicePrompt.select(
   *   await devicePrompt.waitForDevice(({name}) => name.includes('My Device')),
   * );
   * ```
   */
  async waitForDevicePrompt(e = {}) {
    return await this.mainFrame().waitForDevicePrompt(e);
  }
  get bluetooth() {
    return d(this, zB);
  }
};
XB = new WeakMap(), Ca = new WeakMap(), zB = new WeakMap(), pe = new WeakMap(), Si = new WeakMap(), la = new WeakMap(), $o = new WeakMap(), Ba = new WeakMap(), Ec = new WeakMap(), hc = new WeakMap(), xe = new WeakMap(), et = new WeakMap(), Qc = new WeakMap(), Ea = new WeakMap(), dc = new WeakMap(), fc = new WeakMap(), pc = new WeakMap(), Ag = new WeakMap(), As = new WeakMap(), mf = new WeakMap(), $B = new WeakMap(), AE = new WeakMap(), ce = new WeakSet(), CT = function() {
  const e = [];
  for (const i of d(this, Ca).getChildTargets(d(this, Si)))
    e.push(i);
  let r = 0;
  for (; r < e.length; ) {
    const i = e[r];
    r++;
    const n = i._session();
    n && d(this, yc).call(this, n);
    for (const s of d(this, Ca).getChildTargets(i))
      e.push(s);
  }
}, lT = async function(e) {
  bA(e instanceof uu, "CDPSession is not instance of CdpCDPSession"), x(this, pe, e), x(this, Si, e.target()), bA(d(this, Si), "Missing target on swap"), d(this, Ba).updateClient(e), d(this, Ec).updateClient(e), d(this, hc).updateClient(e), d(this, et).updateClient(e), d(this, Qc).updateClient(e), d(this, fc).updateClient(e), await d(this, xe).swapFrameTree(e), O(this, ce, FD).call(this);
}, BT = async function(e) {
  bA(e instanceof uu), e.target()._subtype() === "prerender" && (d(this, xe).registerSpeculativeSession(e).catch(HA), d(this, et).registerSpeculativeSession(e).catch(HA));
}, /**
 * Sets up listeners for the primary target. The primary target can change
 * during a navigation to a prerended page.
 */
FD = function() {
  const e = new je(d(this, pe));
  e.on(He.Ready, d(this, yc)), e.on(He.Disconnected, () => {
    d(this, mf).reject(new Da("Target closed"));
  }), e.on("Page.domContentEventFired", () => {
    this.emit("domcontentloaded", void 0);
  }), e.on("Page.loadEventFired", () => {
    this.emit("load", void 0);
  }), e.on("Page.javascriptDialogOpening", O(this, ce, wT).bind(this)), e.on("Runtime.exceptionThrown", O(this, ce, vD).bind(this)), e.on("Inspector.targetCrashed", O(this, ce, QT).bind(this)), e.on("Performance.metrics", O(this, ce, fT).bind(this)), e.on("Log.entryAdded", O(this, ce, dT).bind(this)), e.on("Page.fileChooserOpened", O(this, ce, hT).bind(this));
}, eE = new WeakMap(), yc = new WeakMap(), ET = async function() {
  try {
    await Promise.all([
      d(this, xe).initialize(d(this, pe)),
      d(this, pe).send("Performance.enable"),
      d(this, pe).send("Log.enable")
    ]);
  } catch (e) {
    if (_i(e) && ef(e))
      HA(e);
    else
      throw e;
  }
}, hT = async function(e) {
  const r = { stack: [], error: void 0, hasError: !1 };
  try {
    if (!d(this, As).size)
      return;
    const i = d(this, xe).frame(e.frameId);
    bA(i, "This should never happen.");
    const n = ky(r, await i.worlds[Yi].adoptBackendNode(e.backendNodeId), !1), s = new T7(n.move(), e.mode !== "selectSingle");
    for (const a of d(this, As))
      a.resolve(s);
    d(this, As).clear();
  } catch (i) {
    r.error = i, r.hasError = !0;
  } finally {
    vy(r);
  }
}, QT = function() {
  this.emit("error", new Error("Page crashed!"));
}, dT = function(e) {
  const { level: r, text: i, args: n, source: s, url: a, lineNumber: g, stackTrace: o } = e.entry;
  n && n.map((u) => {
    S1(d(this, pe), u);
  }), s !== "worker" && this.emit("console", new gR(Ry(r), i, [], [{ url: a, lineNumber: g }], void 0, o));
}, fT = function(e) {
  this.emit("metrics", {
    title: e.title,
    metrics: O(this, ce, kD).call(this, e.metrics)
  });
}, kD = function(e) {
  const r = {};
  for (const i of e || [])
    pAA.has(i.name) && (r[i.name] = i.value);
  return r;
}, vD = function(e) {
  this.emit("pageerror", z7(e.exceptionDetails));
}, pT = function(e, r) {
  const i = r.args.map((n) => e.createCdpHandle(n));
  O(this, ce, RD).call(this, Ry(r.type), i, r.stackTrace);
}, yT = async function(e, r) {
  let i;
  try {
    i = JSON.parse(r.payload);
  } catch {
    return;
  }
  const { type: n, name: s, seq: a, args: g, isTrivial: o } = i;
  if (n !== "exposedFun")
    return;
  const u = e.context;
  if (!u)
    return;
  const I = d(this, Ea).get(s);
  await (I == null ? void 0 : I.run(u, a, g, o));
}, RD = function(e, r, i) {
  if (!this.listenerCount(
    "console"
    /* PageEvent.Console */
  )) {
    r.forEach((g) => g.dispose());
    return;
  }
  const n = [];
  for (const g of r) {
    const o = g.remoteObject();
    o.objectId ? n.push(g.toString()) : n.push(dg(o));
  }
  const s = [];
  if (i)
    for (const g of i.callFrames)
      s.push({
        url: g.url,
        lineNumber: g.lineNumber,
        columnNumber: g.columnNumber
      });
  const a = new gR(Ry(e), n.join(" "), r, s, void 0, i);
  this.emit("console", a);
}, wT = function(e) {
  const r = v$(e.type), i = new q7(d(this, pe), r, e.message, e.defaultPrompt);
  this.emit("dialog", i);
}, bD = async function(e, r) {
  const i = await d(this, pe).send("Page.getNavigationHistory"), n = i.entries[i.currentIndex + e];
  if (!n)
    throw new Error("History entry to navigate to not found.");
  return (await Promise.all([
    this.waitForNavigation(r),
    d(this, pe).send("Page.navigateToHistoryEntry", {
      entryId: n.id
    })
  ]))[0];
};
let ul = tF;
const pAA = /* @__PURE__ */ new Set([
  "Timestamp",
  "Documents",
  "Frames",
  "JSEventListeners",
  "Nodes",
  "LayoutCount",
  "RecalcStyleCount",
  "LayoutDuration",
  "RecalcStyleDuration",
  "ScriptDuration",
  "TaskDuration",
  "JSHeapUsedSize",
  "JSHeapTotalSize"
]);
function yAA(t, A) {
  const e = Math.max(t.x, A.x), r = Math.max(t.y, A.y);
  return {
    x: e,
    y: r,
    width: Math.max(Math.min(t.x + t.width, A.x + A.width) - e, 0),
    height: Math.max(Math.min(t.y + t.height, A.y + A.height) - r, 0)
  };
}
function MD(t) {
  if (t !== void 0)
    return typeof t == "string" ? {
      topLevelSite: t,
      hasCrossSiteAncestor: !1
    } : {
      topLevelSite: t.sourceOrigin,
      hasCrossSiteAncestor: t.hasCrossSiteAncestor ?? !1
    };
}
/**
 * @license
 * Copyright 2024 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
var wAA = function(t, A, e) {
  if (A != null) {
    if (typeof A != "object" && typeof A != "function") throw new TypeError("Object expected.");
    var r, i;
    if (e) {
      if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
      r = A[Symbol.asyncDispose];
    }
    if (r === void 0) {
      if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
      r = A[Symbol.dispose], e && (i = r);
    }
    if (typeof r != "function") throw new TypeError("Object not disposable.");
    i && (r = function() {
      try {
        i.call(this);
      } catch (n) {
        return Promise.reject(n);
      }
    }), t.stack.push({ value: A, dispose: r, async: e });
  } else e && t.stack.push({ async: !0 });
  return A;
}, mAA = /* @__PURE__ */ function(t) {
  return function(A) {
    function e(s) {
      A.error = A.hasError ? new t(s, A.error, "An error was suppressed during disposal.") : s, A.hasError = !0;
    }
    var r, i = 0;
    function n() {
      for (; r = A.stack.pop(); )
        try {
          if (!r.async && i === 1) return i = 0, A.stack.push(r), Promise.resolve().then(n);
          if (r.dispose) {
            var s = r.dispose.call(r.value);
            if (r.async) return i |= 2, Promise.resolve(s).then(n, function(a) {
              return e(a), n();
            });
          } else i |= 1;
        } catch (a) {
          e(a);
        }
      if (i === 1) return A.hasError ? Promise.reject(A.error) : Promise.resolve();
      if (A.hasError) throw A.error;
    }
    return n();
  };
}(typeof SuppressedError == "function" ? SuppressedError : function(t, A, e) {
  var r = new Error(e);
  return r.name = "SuppressedError", r.error = t, r.suppressed = A, r;
}), es, ts, Lr;
class by extends L$ {
  constructor(e, r, i) {
    super();
    k(this, es);
    k(this, ts);
    k(this, Lr);
    x(this, es, e), x(this, ts, r), x(this, Lr, i);
  }
  get id() {
    return d(this, Lr);
  }
  targets() {
    return d(this, ts).targets().filter((e) => e.browserContext() === this);
  }
  async pages(e = !1) {
    return (await Promise.all(this.targets().filter((i) => {
      var n;
      return i.type() === "page" || (i.type() === "other" || e) && ((n = d(this, ts)._getIsPageTargetCallback()) == null ? void 0 : n(i));
    }).map((i) => i.page()))).filter((i) => !!i);
  }
  async overridePermissions(e, r) {
    const i = r.map((n) => {
      const s = _$.get(n);
      if (!s)
        throw new Error("Unknown permission: " + n);
      return s;
    });
    await d(this, es).send("Browser.grantPermissions", {
      origin: e,
      browserContextId: d(this, Lr) || void 0,
      permissions: i
    });
  }
  async clearPermissionOverrides() {
    await d(this, es).send("Browser.resetPermissions", {
      browserContextId: d(this, Lr) || void 0
    });
  }
  async newPage(e) {
    const r = { stack: [], error: void 0, hasError: !1 };
    try {
      const i = wAA(r, await this.waitForScreenshotOperations(), !1);
      return await d(this, ts)._createPageInContext(d(this, Lr), e);
    } catch (i) {
      r.error = i, r.hasError = !0;
    } finally {
      mAA(r);
    }
  }
  browser() {
    return d(this, ts);
  }
  async close() {
    bA(d(this, Lr), "Default BrowserContext cannot be closed!"), await d(this, ts)._disposeContext(d(this, Lr));
  }
  async cookies() {
    const { cookies: e } = await d(this, es).send("Storage.getCookies", {
      browserContextId: d(this, Lr)
    });
    return e.map((r) => ({
      ...r,
      partitionKey: r.partitionKey ? {
        sourceOrigin: r.partitionKey.topLevelSite,
        hasCrossSiteAncestor: r.partitionKey.hasCrossSiteAncestor
      } : void 0
    }));
  }
  async setCookie(...e) {
    return await d(this, es).send("Storage.setCookies", {
      browserContextId: d(this, Lr),
      cookies: e.map((r) => ({
        ...r,
        partitionKey: MD(r.partitionKey)
      }))
    });
  }
  async setDownloadBehavior(e) {
    await d(this, es).send("Browser.setDownloadBehavior", {
      behavior: e.policy,
      downloadPath: e.downloadPath,
      browserContextId: d(this, Lr)
    });
  }
}
es = new WeakMap(), ts = new WeakMap(), Lr = new WeakMap();
/**
 * @license
 * Copyright 2019 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
var Gr;
(function(t) {
  t.SUCCESS = "success", t.ABORTED = "aborted";
})(Gr || (Gr = {}));
var ha, eg, sn, wc, Qa, mc;
class xS extends _7 {
  /**
   * To initialize the target for use, call initialize.
   *
   * @internal
   */
  constructor(e, r, i, n, s) {
    super();
    k(this, ha);
    k(this, eg);
    k(this, sn);
    k(this, wc);
    k(this, Qa);
    k(this, mc, /* @__PURE__ */ new Set());
    R(this, "_initializedDeferred", Ke.create());
    R(this, "_isClosedDeferred", Ke.create());
    R(this, "_targetId");
    x(this, eg, r), x(this, wc, n), x(this, sn, e), x(this, ha, i), this._targetId = e.targetId, x(this, Qa, s), d(this, eg) && d(this, eg).setTarget(this);
  }
  async asPage() {
    const e = this._session();
    return e ? await ul._create(e, this, null) : await this.createCDPSession().then((r) => ul._create(r, this, null));
  }
  _subtype() {
    return d(this, sn).subtype;
  }
  _session() {
    return d(this, eg);
  }
  _addChildTarget(e) {
    d(this, mc).add(e);
  }
  _removeChildTarget(e) {
    d(this, mc).delete(e);
  }
  _childTargets() {
    return d(this, mc);
  }
  _sessionFactory() {
    if (!d(this, Qa))
      throw new Error("sessionFactory is not initialized");
    return d(this, Qa);
  }
  createCDPSession() {
    if (!d(this, Qa))
      throw new Error("sessionFactory is not initialized");
    return d(this, Qa).call(this, !1).then((e) => (e.setTarget(this), e));
  }
  url() {
    return d(this, sn).url;
  }
  type() {
    switch (d(this, sn).type) {
      case "page":
        return xr.PAGE;
      case "background_page":
        return xr.BACKGROUND_PAGE;
      case "service_worker":
        return xr.SERVICE_WORKER;
      case "shared_worker":
        return xr.SHARED_WORKER;
      case "browser":
        return xr.BROWSER;
      case "webview":
        return xr.WEBVIEW;
      case "tab":
        return xr.TAB;
      default:
        return xr.OTHER;
    }
  }
  _targetManager() {
    if (!d(this, wc))
      throw new Error("targetManager is not initialized");
    return d(this, wc);
  }
  _getTargetInfo() {
    return d(this, sn);
  }
  browser() {
    if (!d(this, ha))
      throw new Error("browserContext is not initialized");
    return d(this, ha).browser();
  }
  browserContext() {
    if (!d(this, ha))
      throw new Error("browserContext is not initialized");
    return d(this, ha);
  }
  opener() {
    const { openerId: e } = d(this, sn);
    if (e)
      return this.browser().targets().find((r) => r._targetId === e);
  }
  _targetInfoChanged(e) {
    x(this, sn, e), this._checkIfInitialized();
  }
  _initialize() {
    this._initializedDeferred.resolve(Gr.SUCCESS);
  }
  _isTargetExposed() {
    return this.type() !== xr.TAB && !this._subtype();
  }
  _checkIfInitialized() {
    this._initializedDeferred.resolved() || this._initializedDeferred.resolve(Gr.SUCCESS);
  }
}
ha = new WeakMap(), eg = new WeakMap(), sn = new WeakMap(), wc = new WeakMap(), Qa = new WeakMap(), mc = new WeakMap();
var tE;
const rF = class rF extends xS {
  constructor(e, r, i, n, s, a) {
    super(e, r, i, n, s);
    k(this, tE);
    R(this, "pagePromise");
    x(this, tE, a ?? void 0);
  }
  _initialize() {
    this._initializedDeferred.valueOrThrow().then(async (e) => {
      if (e === Gr.ABORTED)
        return;
      const r = this.opener();
      if (!(r instanceof rF))
        return;
      if (!r || !r.pagePromise || this.type() !== "page")
        return !0;
      const i = await r.pagePromise;
      if (!i.listenerCount(
        "popup"
        /* PageEvent.Popup */
      ))
        return !0;
      const n = await this.page();
      return i.emit("popup", n), !0;
    }).catch(HA), this._checkIfInitialized();
  }
  async page() {
    if (!this.pagePromise) {
      const e = this._session();
      this.pagePromise = (e ? Promise.resolve(e) : this._sessionFactory()(
        /* isAutoAttachEmulated=*/
        !1
      )).then((r) => ul._create(r, this, d(this, tE) ?? null));
    }
    return await this.pagePromise ?? null;
  }
  _checkIfInitialized() {
    this._initializedDeferred.resolved() || this._getTargetInfo().url !== "" && this._initializedDeferred.resolve(Gr.SUCCESS);
  }
};
tE = new WeakMap();
let tf = rF;
class DAA extends tf {
}
var Dc;
class SAA extends xS {
  constructor() {
    super(...arguments);
    k(this, Dc);
  }
  async worker() {
    if (!d(this, Dc)) {
      const e = this._session();
      x(this, Dc, (e ? Promise.resolve(e) : this._sessionFactory()(
        /* isAutoAttachEmulated=*/
        !1
      )).then((r) => new IT(
        r,
        this._getTargetInfo().url,
        this._targetId,
        this.type(),
        () => {
        },
        () => {
        },
        void 0
        /* networkManager */
      )));
    }
    return await d(this, Dc);
  }
}
Dc = new WeakMap();
class FAA extends xS {
}
/**
 * @license
 * Copyright 2022 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
function kAA(t, A) {
  return !!t._subtype() && !A.subtype;
}
var Dt, tg, St, rg, rE, Sc, ig, ng, da, iE, nE, Fc, kc, vc, Kr, _D, ND, sE, aE, oE, gE, Df, bC, Sf;
class vAA extends je {
  constructor(e, r, i, n = !0) {
    super();
    k(this, Kr);
    k(this, Dt);
    /**
     * Keeps track of the following events: 'Target.targetCreated',
     * 'Target.targetDestroyed', 'Target.targetInfoChanged'.
     *
     * A target becomes discovered when 'Target.targetCreated' is received.
     * A target is removed from this map once 'Target.targetDestroyed' is
     * received.
     *
     * `targetFilterCallback` has no effect on this map.
     */
    k(this, tg, /* @__PURE__ */ new Map());
    /**
     * A target is added to this map once TargetManager has created
     * a Target and attached at least once to it.
     */
    k(this, St, /* @__PURE__ */ new Map());
    /**
     * Tracks which sessions attach to which target.
     */
    k(this, rg, /* @__PURE__ */ new Map());
    /**
     * If a target was filtered out by `targetFilterCallback`, we still receive
     * events about it from CDP, but we don't forward them to the rest of Puppeteer.
     */
    k(this, rE, /* @__PURE__ */ new Set());
    k(this, Sc);
    k(this, ig);
    k(this, ng, /* @__PURE__ */ new WeakMap());
    k(this, da, /* @__PURE__ */ new WeakMap());
    k(this, iE, Ke.create());
    k(this, nE, !0);
    k(this, Fc, [{}]);
    // IDs of tab targets detected while running the initial Target.setAutoAttach
    // request. These are the targets whose initialization we want to await for
    // before resolving puppeteer.connect() or launch() to avoid flakiness.
    // Whenever a sub-target whose parent is a tab target is attached, we remove
    // the tab target from this list. Once the list is empty, we resolve the
    // initializeDeferred.
    k(this, kc, /* @__PURE__ */ new Set());
    // This is false until the connection-level Target.setAutoAttach request is
    // done. It indicates whethere we are running the initial auto-attach step or
    // if we are handling targets after that.
    k(this, vc, !1);
    k(this, sE, (e) => {
      O(this, Kr, ND).call(this, e);
    });
    k(this, aE, async (e) => {
      if (d(this, tg).set(e.targetInfo.targetId, e.targetInfo), this.emit("targetDiscovered", e.targetInfo), e.targetInfo.type === "browser" && e.targetInfo.attached) {
        if (d(this, St).has(e.targetInfo.targetId))
          return;
        const r = d(this, ig).call(this, e.targetInfo, void 0);
        r._initialize(), d(this, St).set(e.targetInfo.targetId, r);
      }
    });
    k(this, oE, (e) => {
      const r = d(this, tg).get(e.targetId);
      if (d(this, tg).delete(e.targetId), O(this, Kr, bC).call(this, e.targetId), (r == null ? void 0 : r.type) === "service_worker" && d(this, St).has(e.targetId)) {
        const i = d(this, St).get(e.targetId);
        i && (this.emit("targetGone", i), d(this, St).delete(e.targetId));
      }
    });
    k(this, gE, (e) => {
      var s;
      if (d(this, tg).set(e.targetInfo.targetId, e.targetInfo), d(this, rE).has(e.targetInfo.targetId) || !d(this, St).has(e.targetInfo.targetId) || !e.targetInfo.attached)
        return;
      const r = d(this, St).get(e.targetInfo.targetId);
      if (!r)
        return;
      const i = r.url(), n = r._initializedDeferred.value() === Gr.SUCCESS;
      if (kAA(r, e.targetInfo)) {
        const a = r == null ? void 0 : r._session();
        bA(a, "Target that is being activated is missing a CDPSession."), (s = a.parentSession()) == null || s.emit(He.Swapped, a);
      }
      r._targetInfoChanged(e.targetInfo), n && i !== r.url() && this.emit("targetChanged", {
        target: r,
        wasInitialized: n,
        previousURL: i
      });
    });
    k(this, Df, async (e, r) => {
      const i = r.targetInfo, n = d(this, Dt)._session(r.sessionId);
      if (!n)
        throw new Error(`Session ${r.sessionId} was not created.`);
      const s = async () => {
        await n.send("Runtime.runIfWaitingForDebugger").catch(HA), await e.send("Target.detachFromTarget", {
          sessionId: n.id()
        }).catch(HA);
      };
      if (!d(this, Dt).isAutoAttached(i.targetId))
        return;
      if (i.type === "service_worker") {
        if (await s(), d(this, St).has(i.targetId))
          return;
        const u = d(this, ig).call(this, i);
        u._initialize(), d(this, St).set(i.targetId, u), this.emit("targetAvailable", u);
        return;
      }
      const a = d(this, St).has(i.targetId), g = a ? d(this, St).get(i.targetId) : d(this, ig).call(this, i, n, e instanceof uu ? e : void 0), o = e instanceof uu ? e.target() : null;
      if (d(this, Sc) && !d(this, Sc).call(this, g)) {
        d(this, rE).add(i.targetId), (o == null ? void 0 : o.type()) === "tab" && O(this, Kr, bC).call(this, o._targetId), await s();
        return;
      }
      d(this, nE) && r.targetInfo.type === "tab" && !d(this, vc) && d(this, kc).add(r.targetInfo.targetId), O(this, Kr, _D).call(this, n), a ? (n.setTarget(g), d(this, rg).set(n.id(), d(this, St).get(i.targetId))) : (g._initialize(), d(this, St).set(i.targetId, g), d(this, rg).set(n.id(), g)), o == null || o._addChildTarget(g), e.emit(He.Ready, n), a || this.emit("targetAvailable", g), (o == null ? void 0 : o.type()) === "tab" && O(this, Kr, bC).call(this, o._targetId), await Promise.all([
        n.send("Target.setAutoAttach", {
          waitForDebuggerOnStart: !0,
          flatten: !0,
          autoAttach: !0,
          filter: d(this, Fc)
        }),
        n.send("Runtime.runIfWaitingForDebugger")
      ]).catch(HA);
    });
    k(this, Sf, (e, r) => {
      const i = d(this, rg).get(r.sessionId);
      d(this, rg).delete(r.sessionId), i && (e instanceof XU && e.target()._removeChildTarget(i), d(this, St).delete(i._targetId), this.emit("targetGone", i));
    });
    x(this, Dt, e), x(this, Sc, i), x(this, ig, r), x(this, nE, n), d(this, Dt).on("Target.targetCreated", d(this, aE)), d(this, Dt).on("Target.targetDestroyed", d(this, oE)), d(this, Dt).on("Target.targetInfoChanged", d(this, gE)), d(this, Dt).on(He.SessionDetached, d(this, sE)), O(this, Kr, _D).call(this, d(this, Dt));
  }
  async initialize() {
    await d(this, Dt).send("Target.setDiscoverTargets", {
      discover: !0,
      filter: d(this, Fc)
    }), await d(this, Dt).send("Target.setAutoAttach", {
      waitForDebuggerOnStart: !0,
      flatten: !0,
      autoAttach: !0,
      filter: [
        {
          type: "page",
          exclude: !0
        },
        ...d(this, Fc)
      ]
    }), x(this, vc, !0), O(this, Kr, bC).call(this), await d(this, iE).valueOrThrow();
  }
  getChildTargets(e) {
    return e._childTargets();
  }
  dispose() {
    d(this, Dt).off("Target.targetCreated", d(this, aE)), d(this, Dt).off("Target.targetDestroyed", d(this, oE)), d(this, Dt).off("Target.targetInfoChanged", d(this, gE)), d(this, Dt).off(He.SessionDetached, d(this, sE)), O(this, Kr, ND).call(this, d(this, Dt));
  }
  getAvailableTargets() {
    return d(this, St);
  }
}
Dt = new WeakMap(), tg = new WeakMap(), St = new WeakMap(), rg = new WeakMap(), rE = new WeakMap(), Sc = new WeakMap(), ig = new WeakMap(), ng = new WeakMap(), da = new WeakMap(), iE = new WeakMap(), nE = new WeakMap(), Fc = new WeakMap(), kc = new WeakMap(), vc = new WeakMap(), Kr = new WeakSet(), _D = function(e) {
  const r = (n) => {
    d(this, Df).call(this, e, n);
  };
  bA(!d(this, ng).has(e)), d(this, ng).set(e, r), e.on("Target.attachedToTarget", r);
  const i = (n) => d(this, Sf).call(this, e, n);
  bA(!d(this, da).has(e)), d(this, da).set(e, i), e.on("Target.detachedFromTarget", i);
}, ND = function(e) {
  const r = d(this, ng).get(e);
  r && (e.off("Target.attachedToTarget", r), d(this, ng).delete(e)), d(this, da).has(e) && (e.off("Target.detachedFromTarget", d(this, da).get(e)), d(this, da).delete(e));
}, sE = new WeakMap(), aE = new WeakMap(), oE = new WeakMap(), gE = new WeakMap(), Df = new WeakMap(), bC = function(e) {
  e !== void 0 && d(this, kc).delete(e), d(this, vc) && d(this, kc).size === 0 && d(this, iE).resolve();
}, Sf = new WeakMap();
/**
 * @license
 * Copyright 2017 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
var Rc, uE, Je, cE, IE, bc, rs, is, CE, at, lE, BE, yg, mT, Ff, EE, hE, QE, dE, LD;
const iF = class iF extends N$ {
  constructor(e, r, i, n, s, a, g, o = !0, u = !0, I = !1) {
    super();
    k(this, yg);
    R(this, "protocol", "cdp");
    k(this, Rc);
    k(this, uE);
    k(this, Je);
    k(this, cE);
    k(this, IE);
    k(this, bc);
    k(this, rs);
    k(this, is, /* @__PURE__ */ new Map());
    k(this, CE, !0);
    k(this, at);
    k(this, lE, !1);
    k(this, BE, () => {
      this.emit("disconnected", void 0);
    });
    k(this, Ff, (e, r) => {
      var g;
      const { browserContextId: i } = e, n = i && d(this, is).has(i) ? d(this, is).get(i) : d(this, rs);
      if (!n)
        throw new Error("Missing browser context");
      const s = (o) => d(this, Je)._createSession(e, o), a = new FAA(e, r, n, d(this, at), s);
      return (g = e.url) != null && g.startsWith("devtools://") ? new DAA(e, r, n, d(this, at), s, d(this, Rc) ?? null) : d(this, bc).call(this, a) ? new tf(e, r, n, d(this, at), s, d(this, Rc) ?? null) : e.type === "service_worker" || e.type === "shared_worker" ? new SAA(e, r, n, d(this, at), s) : a;
    });
    k(this, EE, async (e) => {
      e._isTargetExposed() && await e._initializedDeferred.valueOrThrow() === Gr.SUCCESS && (this.emit("targetcreated", e), e.browserContext().emit("targetcreated", e));
    });
    k(this, hE, async (e) => {
      e._initializedDeferred.resolve(Gr.ABORTED), e._isClosedDeferred.resolve(), e._isTargetExposed() && await e._initializedDeferred.valueOrThrow() === Gr.SUCCESS && (this.emit("targetdestroyed", e), e.browserContext().emit("targetdestroyed", e));
    });
    k(this, QE, ({ target: e }) => {
      this.emit("targetchanged", e), e.browserContext().emit("targetchanged", e);
    });
    k(this, dE, (e) => {
      this.emit("targetdiscovered", e);
    });
    x(this, CE, u), x(this, Rc, i), x(this, uE, n), x(this, Je, e), x(this, cE, s || (() => {
    })), x(this, IE, a || (() => !0)), x(this, lE, I), O(this, yg, mT).call(this, g), x(this, at, new vAA(e, d(this, Ff), d(this, IE), o)), x(this, rs, new by(d(this, Je), this));
    for (const c of r)
      d(this, is).set(c, new by(d(this, Je), this, c));
  }
  static async _create(e, r, i, n, s, a, g, o, u, I = !0, c = !0, C = !1) {
    const E = new iF(e, r, n, a, g, o, u, I, c, C);
    return i && await e.send("Security.setIgnoreCertificateErrors", {
      ignore: !0
    }), await E._attach(s), E;
  }
  async _attach(e) {
    d(this, Je).on(He.Disconnected, d(this, BE)), e && await d(this, rs).setDownloadBehavior(e), d(this, at).on("targetAvailable", d(this, EE)), d(this, at).on("targetGone", d(this, hE)), d(this, at).on("targetChanged", d(this, QE)), d(this, at).on("targetDiscovered", d(this, dE)), await d(this, at).initialize();
  }
  _detach() {
    d(this, Je).off(He.Disconnected, d(this, BE)), d(this, at).off("targetAvailable", d(this, EE)), d(this, at).off("targetGone", d(this, hE)), d(this, at).off("targetChanged", d(this, QE)), d(this, at).off("targetDiscovered", d(this, dE));
  }
  process() {
    return d(this, uE) ?? null;
  }
  _targetManager() {
    return d(this, at);
  }
  _getIsPageTargetCallback() {
    return d(this, bc);
  }
  async createBrowserContext(e = {}) {
    const { proxyServer: r, proxyBypassList: i, downloadBehavior: n } = e, { browserContextId: s } = await d(this, Je).send("Target.createBrowserContext", {
      proxyServer: r,
      proxyBypassList: i && i.join(",")
    }), a = new by(d(this, Je), this, s);
    return n && await a.setDownloadBehavior(n), d(this, is).set(s, a), a;
  }
  browserContexts() {
    return [d(this, rs), ...Array.from(d(this, is).values())];
  }
  defaultBrowserContext() {
    return d(this, rs);
  }
  async _disposeContext(e) {
    e && (await d(this, Je).send("Target.disposeBrowserContext", {
      browserContextId: e
    }), d(this, is).delete(e));
  }
  wsEndpoint() {
    return d(this, Je).url();
  }
  async newPage(e) {
    return await d(this, rs).newPage(e);
  }
  async _createPageInContext(e, r) {
    const i = this.targets().filter((u) => u.browserContext().id === e).length > 0, n = (r == null ? void 0 : r.type) === "window" ? r.windowBounds : void 0, { targetId: s } = await d(this, Je).send("Target.createTarget", {
      url: "about:blank",
      browserContextId: e || void 0,
      left: n == null ? void 0 : n.left,
      top: n == null ? void 0 : n.top,
      width: n == null ? void 0 : n.width,
      height: n == null ? void 0 : n.height,
      windowState: n == null ? void 0 : n.windowState,
      // Works around crbug.com/454825274.
      newWindow: i && (r == null ? void 0 : r.type) === "window" ? !0 : void 0
    }), a = await this.waitForTarget((u) => u._targetId === s);
    if (!a)
      throw new Error(`Missing target for page (id = ${s})`);
    if (!(await a._initializedDeferred.valueOrThrow() === Gr.SUCCESS))
      throw new Error(`Failed to create target for page (id = ${s})`);
    const o = await a.page();
    if (!o)
      throw new Error(`Failed to create a page for context (id = ${e})`);
    return o;
  }
  async _createDevToolsPage(e) {
    const r = await d(this, Je).send("Target.openDevTools", {
      targetId: e
    }), i = await this.waitForTarget((a) => a._targetId === r.targetId);
    if (!i)
      throw new Error(`Missing target for DevTools page (id = ${e})`);
    if (!(await i._initializedDeferred.valueOrThrow() === Gr.SUCCESS))
      throw new Error(`Failed to create target for DevTools page (id = ${e})`);
    const s = await i.page();
    if (!s)
      throw new Error(`Failed to create a DevTools Page for target (id = ${e})`);
    return s;
  }
  async installExtension(e) {
    const { id: r } = await d(this, Je).send("Extensions.loadUnpacked", { path: e });
    return r;
  }
  uninstallExtension(e) {
    return d(this, Je).send("Extensions.uninstall", { id: e });
  }
  async screens() {
    const { screenInfos: e } = await d(this, Je).send("Emulation.getScreenInfos");
    return e;
  }
  async addScreen(e) {
    const { screenInfo: r } = await d(this, Je).send("Emulation.addScreen", e);
    return r;
  }
  async removeScreen(e) {
    return await d(this, Je).send("Emulation.removeScreen", { screenId: e });
  }
  async getWindowBounds(e) {
    const { bounds: r } = await d(this, Je).send("Browser.getWindowBounds", {
      windowId: Number(e)
    });
    return r;
  }
  async setWindowBounds(e, r) {
    await d(this, Je).send("Browser.setWindowBounds", {
      windowId: Number(e),
      bounds: r
    });
  }
  targets() {
    return Array.from(d(this, at).getAvailableTargets().values()).filter((e) => e._isTargetExposed() && e._initializedDeferred.value() === Gr.SUCCESS);
  }
  target() {
    const e = this.targets().find((r) => r.type() === "browser");
    if (!e)
      throw new Error("Browser target is not found");
    return e;
  }
  async version() {
    return (await O(this, yg, LD).call(this)).product;
  }
  async userAgent() {
    return (await O(this, yg, LD).call(this)).userAgent;
  }
  async close() {
    await d(this, cE).call(null), await this.disconnect();
  }
  disconnect() {
    return d(this, at).dispose(), d(this, Je).dispose(), this._detach(), Promise.resolve();
  }
  get connected() {
    return !d(this, Je)._closed;
  }
  get debugInfo() {
    return {
      pendingProtocolErrors: d(this, Je).getPendingProtocolErrors()
    };
  }
  isNetworkEnabled() {
    return d(this, CE);
  }
};
Rc = new WeakMap(), uE = new WeakMap(), Je = new WeakMap(), cE = new WeakMap(), IE = new WeakMap(), bc = new WeakMap(), rs = new WeakMap(), is = new WeakMap(), CE = new WeakMap(), at = new WeakMap(), lE = new WeakMap(), BE = new WeakMap(), yg = new WeakSet(), mT = function(e) {
  x(this, bc, e || ((r) => r.type() === "page" || r.type() === "background_page" || r.type() === "webview" || d(this, lE) && r.type() === "other" && r.url().startsWith("devtools://devtools/bundled/devtools_app.html")));
}, Ff = new WeakMap(), EE = new WeakMap(), hE = new WeakMap(), QE = new WeakMap(), dE = new WeakMap(), LD = function() {
  return d(this, Je).send("Browser.getVersion");
};
let rf = iF;
/**
 * @license
 * Copyright 2020 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
async function RAA(t, A, e) {
  const { acceptInsecureCerts: r = !1, networkEnabled: i = !0, defaultViewport: n = NS, downloadBehavior: s, targetFilter: a, _isPageTarget: g, slowMo: o = 0, protocolTimeout: u, handleDevToolsAsPage: I, idGenerator: c = qE() } = e, C = new Af(
    A,
    t,
    o,
    u,
    /* rawErrors */
    !1,
    c
  ), { browserContextIds: E } = await C.send("Target.getBrowserContexts");
  return await rf._create(C, E, r, n, s, void 0, () => C.send("Browser.close").catch(HA), a, g, void 0, i, I);
}
/**
 * @license
 * Copyright 2017 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
const bAA = [
  {
    name: "Blackberry PlayBook",
    userAgent: "Mozilla/5.0 (PlayBook; U; RIM Tablet OS 2.1.0; en-US) AppleWebKit/536.2+ (KHTML like Gecko) Version/7.2.1.0 Safari/536.2+",
    viewport: {
      width: 600,
      height: 1024,
      deviceScaleFactor: 1,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !1
    }
  },
  {
    name: "Blackberry PlayBook landscape",
    userAgent: "Mozilla/5.0 (PlayBook; U; RIM Tablet OS 2.1.0; en-US) AppleWebKit/536.2+ (KHTML like Gecko) Version/7.2.1.0 Safari/536.2+",
    viewport: {
      width: 1024,
      height: 600,
      deviceScaleFactor: 1,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !0
    }
  },
  {
    name: "BlackBerry Z30",
    userAgent: "Mozilla/5.0 (BB10; Touch) AppleWebKit/537.10+ (KHTML, like Gecko) Version/10.0.9.2372 Mobile Safari/537.10+",
    viewport: {
      width: 360,
      height: 640,
      deviceScaleFactor: 2,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !1
    }
  },
  {
    name: "BlackBerry Z30 landscape",
    userAgent: "Mozilla/5.0 (BB10; Touch) AppleWebKit/537.10+ (KHTML, like Gecko) Version/10.0.9.2372 Mobile Safari/537.10+",
    viewport: {
      width: 640,
      height: 360,
      deviceScaleFactor: 2,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !0
    }
  },
  {
    name: "Galaxy Note 3",
    userAgent: "Mozilla/5.0 (Linux; U; Android 4.3; en-us; SM-N900T Build/JSS15J) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30",
    viewport: {
      width: 360,
      height: 640,
      deviceScaleFactor: 3,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !1
    }
  },
  {
    name: "Galaxy Note 3 landscape",
    userAgent: "Mozilla/5.0 (Linux; U; Android 4.3; en-us; SM-N900T Build/JSS15J) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30",
    viewport: {
      width: 640,
      height: 360,
      deviceScaleFactor: 3,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !0
    }
  },
  {
    name: "Galaxy Note II",
    userAgent: "Mozilla/5.0 (Linux; U; Android 4.1; en-us; GT-N7100 Build/JRO03C) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30",
    viewport: {
      width: 360,
      height: 640,
      deviceScaleFactor: 2,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !1
    }
  },
  {
    name: "Galaxy Note II landscape",
    userAgent: "Mozilla/5.0 (Linux; U; Android 4.1; en-us; GT-N7100 Build/JRO03C) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30",
    viewport: {
      width: 640,
      height: 360,
      deviceScaleFactor: 2,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !0
    }
  },
  {
    name: "Galaxy S III",
    userAgent: "Mozilla/5.0 (Linux; U; Android 4.0; en-us; GT-I9300 Build/IMM76D) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30",
    viewport: {
      width: 360,
      height: 640,
      deviceScaleFactor: 2,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !1
    }
  },
  {
    name: "Galaxy S III landscape",
    userAgent: "Mozilla/5.0 (Linux; U; Android 4.0; en-us; GT-I9300 Build/IMM76D) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30",
    viewport: {
      width: 640,
      height: 360,
      deviceScaleFactor: 2,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !0
    }
  },
  {
    name: "Galaxy S5",
    userAgent: "Mozilla/5.0 (Linux; Android 5.0; SM-G900P Build/LRX21T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
    viewport: {
      width: 360,
      height: 640,
      deviceScaleFactor: 3,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !1
    }
  },
  {
    name: "Galaxy S5 landscape",
    userAgent: "Mozilla/5.0 (Linux; Android 5.0; SM-G900P Build/LRX21T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
    viewport: {
      width: 640,
      height: 360,
      deviceScaleFactor: 3,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !0
    }
  },
  {
    name: "Galaxy S8",
    userAgent: "Mozilla/5.0 (Linux; Android 7.0; SM-G950U Build/NRD90M) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.84 Mobile Safari/537.36",
    viewport: {
      width: 360,
      height: 740,
      deviceScaleFactor: 3,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !1
    }
  },
  {
    name: "Galaxy S8 landscape",
    userAgent: "Mozilla/5.0 (Linux; Android 7.0; SM-G950U Build/NRD90M) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.84 Mobile Safari/537.36",
    viewport: {
      width: 740,
      height: 360,
      deviceScaleFactor: 3,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !0
    }
  },
  {
    name: "Galaxy S9+",
    userAgent: "Mozilla/5.0 (Linux; Android 8.0.0; SM-G965U Build/R16NW) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.111 Mobile Safari/537.36",
    viewport: {
      width: 320,
      height: 658,
      deviceScaleFactor: 4.5,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !1
    }
  },
  {
    name: "Galaxy S9+ landscape",
    userAgent: "Mozilla/5.0 (Linux; Android 8.0.0; SM-G965U Build/R16NW) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.111 Mobile Safari/537.36",
    viewport: {
      width: 658,
      height: 320,
      deviceScaleFactor: 4.5,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !0
    }
  },
  {
    name: "Galaxy Tab S4",
    userAgent: "Mozilla/5.0 (Linux; Android 8.1.0; SM-T837A) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.80 Safari/537.36",
    viewport: {
      width: 712,
      height: 1138,
      deviceScaleFactor: 2.25,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !1
    }
  },
  {
    name: "Galaxy Tab S4 landscape",
    userAgent: "Mozilla/5.0 (Linux; Android 8.1.0; SM-T837A) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.80 Safari/537.36",
    viewport: {
      width: 1138,
      height: 712,
      deviceScaleFactor: 2.25,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !0
    }
  },
  {
    name: "iPad",
    userAgent: "Mozilla/5.0 (iPad; CPU OS 11_0 like Mac OS X) AppleWebKit/604.1.34 (KHTML, like Gecko) Version/11.0 Mobile/15A5341f Safari/604.1",
    viewport: {
      width: 768,
      height: 1024,
      deviceScaleFactor: 2,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !1
    }
  },
  {
    name: "iPad landscape",
    userAgent: "Mozilla/5.0 (iPad; CPU OS 11_0 like Mac OS X) AppleWebKit/604.1.34 (KHTML, like Gecko) Version/11.0 Mobile/15A5341f Safari/604.1",
    viewport: {
      width: 1024,
      height: 768,
      deviceScaleFactor: 2,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !0
    }
  },
  {
    name: "iPad (gen 6)",
    userAgent: "Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 768,
      height: 1024,
      deviceScaleFactor: 2,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !1
    }
  },
  {
    name: "iPad (gen 6) landscape",
    userAgent: "Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 1024,
      height: 768,
      deviceScaleFactor: 2,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !0
    }
  },
  {
    name: "iPad (gen 7)",
    userAgent: "Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 810,
      height: 1080,
      deviceScaleFactor: 2,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !1
    }
  },
  {
    name: "iPad (gen 7) landscape",
    userAgent: "Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 1080,
      height: 810,
      deviceScaleFactor: 2,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !0
    }
  },
  {
    name: "iPad Mini",
    userAgent: "Mozilla/5.0 (iPad; CPU OS 11_0 like Mac OS X) AppleWebKit/604.1.34 (KHTML, like Gecko) Version/11.0 Mobile/15A5341f Safari/604.1",
    viewport: {
      width: 768,
      height: 1024,
      deviceScaleFactor: 2,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !1
    }
  },
  {
    name: "iPad Mini landscape",
    userAgent: "Mozilla/5.0 (iPad; CPU OS 11_0 like Mac OS X) AppleWebKit/604.1.34 (KHTML, like Gecko) Version/11.0 Mobile/15A5341f Safari/604.1",
    viewport: {
      width: 1024,
      height: 768,
      deviceScaleFactor: 2,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !0
    }
  },
  {
    name: "iPad Pro",
    userAgent: "Mozilla/5.0 (iPad; CPU OS 11_0 like Mac OS X) AppleWebKit/604.1.34 (KHTML, like Gecko) Version/11.0 Mobile/15A5341f Safari/604.1",
    viewport: {
      width: 1024,
      height: 1366,
      deviceScaleFactor: 2,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !1
    }
  },
  {
    name: "iPad Pro landscape",
    userAgent: "Mozilla/5.0 (iPad; CPU OS 11_0 like Mac OS X) AppleWebKit/604.1.34 (KHTML, like Gecko) Version/11.0 Mobile/15A5341f Safari/604.1",
    viewport: {
      width: 1366,
      height: 1024,
      deviceScaleFactor: 2,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !0
    }
  },
  {
    name: "iPad Pro 11",
    userAgent: "Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 834,
      height: 1194,
      deviceScaleFactor: 2,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !1
    }
  },
  {
    name: "iPad Pro 11 landscape",
    userAgent: "Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 1194,
      height: 834,
      deviceScaleFactor: 2,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !0
    }
  },
  {
    name: "iPhone 4",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 7_1_2 like Mac OS X) AppleWebKit/537.51.2 (KHTML, like Gecko) Version/7.0 Mobile/11D257 Safari/9537.53",
    viewport: {
      width: 320,
      height: 480,
      deviceScaleFactor: 2,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !1
    }
  },
  {
    name: "iPhone 4 landscape",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 7_1_2 like Mac OS X) AppleWebKit/537.51.2 (KHTML, like Gecko) Version/7.0 Mobile/11D257 Safari/9537.53",
    viewport: {
      width: 480,
      height: 320,
      deviceScaleFactor: 2,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !0
    }
  },
  {
    name: "iPhone 5",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 10_3_1 like Mac OS X) AppleWebKit/603.1.30 (KHTML, like Gecko) Version/10.0 Mobile/14E304 Safari/602.1",
    viewport: {
      width: 320,
      height: 568,
      deviceScaleFactor: 2,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !1
    }
  },
  {
    name: "iPhone 5 landscape",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 10_3_1 like Mac OS X) AppleWebKit/603.1.30 (KHTML, like Gecko) Version/10.0 Mobile/14E304 Safari/602.1",
    viewport: {
      width: 568,
      height: 320,
      deviceScaleFactor: 2,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !0
    }
  },
  {
    name: "iPhone 6",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
    viewport: {
      width: 375,
      height: 667,
      deviceScaleFactor: 2,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !1
    }
  },
  {
    name: "iPhone 6 landscape",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
    viewport: {
      width: 667,
      height: 375,
      deviceScaleFactor: 2,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !0
    }
  },
  {
    name: "iPhone 6 Plus",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
    viewport: {
      width: 414,
      height: 736,
      deviceScaleFactor: 3,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !1
    }
  },
  {
    name: "iPhone 6 Plus landscape",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
    viewport: {
      width: 736,
      height: 414,
      deviceScaleFactor: 3,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !0
    }
  },
  {
    name: "iPhone 7",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
    viewport: {
      width: 375,
      height: 667,
      deviceScaleFactor: 2,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !1
    }
  },
  {
    name: "iPhone 7 landscape",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
    viewport: {
      width: 667,
      height: 375,
      deviceScaleFactor: 2,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !0
    }
  },
  {
    name: "iPhone 7 Plus",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
    viewport: {
      width: 414,
      height: 736,
      deviceScaleFactor: 3,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !1
    }
  },
  {
    name: "iPhone 7 Plus landscape",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
    viewport: {
      width: 736,
      height: 414,
      deviceScaleFactor: 3,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !0
    }
  },
  {
    name: "iPhone 8",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
    viewport: {
      width: 375,
      height: 667,
      deviceScaleFactor: 2,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !1
    }
  },
  {
    name: "iPhone 8 landscape",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
    viewport: {
      width: 667,
      height: 375,
      deviceScaleFactor: 2,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !0
    }
  },
  {
    name: "iPhone 8 Plus",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
    viewport: {
      width: 414,
      height: 736,
      deviceScaleFactor: 3,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !1
    }
  },
  {
    name: "iPhone 8 Plus landscape",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
    viewport: {
      width: 736,
      height: 414,
      deviceScaleFactor: 3,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !0
    }
  },
  {
    name: "iPhone SE",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 10_3_1 like Mac OS X) AppleWebKit/603.1.30 (KHTML, like Gecko) Version/10.0 Mobile/14E304 Safari/602.1",
    viewport: {
      width: 320,
      height: 568,
      deviceScaleFactor: 2,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !1
    }
  },
  {
    name: "iPhone SE landscape",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 10_3_1 like Mac OS X) AppleWebKit/603.1.30 (KHTML, like Gecko) Version/10.0 Mobile/14E304 Safari/602.1",
    viewport: {
      width: 568,
      height: 320,
      deviceScaleFactor: 2,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !0
    }
  },
  {
    name: "iPhone X",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
    viewport: {
      width: 375,
      height: 812,
      deviceScaleFactor: 3,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !1
    }
  },
  {
    name: "iPhone X landscape",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
    viewport: {
      width: 812,
      height: 375,
      deviceScaleFactor: 3,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !0
    }
  },
  {
    name: "iPhone XR",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 12_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/12.0 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 414,
      height: 896,
      deviceScaleFactor: 3,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !1
    }
  },
  {
    name: "iPhone XR landscape",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 12_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/12.0 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 896,
      height: 414,
      deviceScaleFactor: 3,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !0
    }
  },
  {
    name: "iPhone 11",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 13_7 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.1 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 414,
      height: 828,
      deviceScaleFactor: 2,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !1
    }
  },
  {
    name: "iPhone 11 landscape",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 13_7 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.1 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 828,
      height: 414,
      deviceScaleFactor: 2,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !0
    }
  },
  {
    name: "iPhone 11 Pro",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 13_7 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.1 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 375,
      height: 812,
      deviceScaleFactor: 3,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !1
    }
  },
  {
    name: "iPhone 11 Pro landscape",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 13_7 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.1 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 812,
      height: 375,
      deviceScaleFactor: 3,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !0
    }
  },
  {
    name: "iPhone 11 Pro Max",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 13_7 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.1 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 414,
      height: 896,
      deviceScaleFactor: 3,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !1
    }
  },
  {
    name: "iPhone 11 Pro Max landscape",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 13_7 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.1 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 896,
      height: 414,
      deviceScaleFactor: 3,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !0
    }
  },
  {
    name: "iPhone 12",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 390,
      height: 844,
      deviceScaleFactor: 3,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !1
    }
  },
  {
    name: "iPhone 12 landscape",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 844,
      height: 390,
      deviceScaleFactor: 3,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !0
    }
  },
  {
    name: "iPhone 12 Pro",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 390,
      height: 844,
      deviceScaleFactor: 3,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !1
    }
  },
  {
    name: "iPhone 12 Pro landscape",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 844,
      height: 390,
      deviceScaleFactor: 3,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !0
    }
  },
  {
    name: "iPhone 12 Pro Max",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 428,
      height: 926,
      deviceScaleFactor: 3,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !1
    }
  },
  {
    name: "iPhone 12 Pro Max landscape",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 926,
      height: 428,
      deviceScaleFactor: 3,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !0
    }
  },
  {
    name: "iPhone 12 Mini",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 375,
      height: 812,
      deviceScaleFactor: 3,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !1
    }
  },
  {
    name: "iPhone 12 Mini landscape",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 812,
      height: 375,
      deviceScaleFactor: 3,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !0
    }
  },
  {
    name: "iPhone 13",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 390,
      height: 844,
      deviceScaleFactor: 3,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !1
    }
  },
  {
    name: "iPhone 13 landscape",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 844,
      height: 390,
      deviceScaleFactor: 3,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !0
    }
  },
  {
    name: "iPhone 13 Pro",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 390,
      height: 844,
      deviceScaleFactor: 3,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !1
    }
  },
  {
    name: "iPhone 13 Pro landscape",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 844,
      height: 390,
      deviceScaleFactor: 3,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !0
    }
  },
  {
    name: "iPhone 13 Pro Max",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 428,
      height: 926,
      deviceScaleFactor: 3,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !1
    }
  },
  {
    name: "iPhone 13 Pro Max landscape",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 926,
      height: 428,
      deviceScaleFactor: 3,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !0
    }
  },
  {
    name: "iPhone 13 Mini",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 375,
      height: 812,
      deviceScaleFactor: 3,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !1
    }
  },
  {
    name: "iPhone 13 Mini landscape",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 812,
      height: 375,
      deviceScaleFactor: 3,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !0
    }
  },
  {
    name: "iPhone 14",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 16_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 390,
      height: 663,
      deviceScaleFactor: 3,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !1
    }
  },
  {
    name: "iPhone 14 landscape",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 16_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 750,
      height: 340,
      deviceScaleFactor: 3,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !0
    }
  },
  {
    name: "iPhone 14 Plus",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 16_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 428,
      height: 745,
      deviceScaleFactor: 3,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !1
    }
  },
  {
    name: "iPhone 14 Plus landscape",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 16_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 832,
      height: 378,
      deviceScaleFactor: 3,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !0
    }
  },
  {
    name: "iPhone 14 Pro",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 16_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 393,
      height: 659,
      deviceScaleFactor: 3,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !1
    }
  },
  {
    name: "iPhone 14 Pro landscape",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 16_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 734,
      height: 343,
      deviceScaleFactor: 3,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !0
    }
  },
  {
    name: "iPhone 14 Pro Max",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 16_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 430,
      height: 739,
      deviceScaleFactor: 3,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !1
    }
  },
  {
    name: "iPhone 14 Pro Max landscape",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 16_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 814,
      height: 380,
      deviceScaleFactor: 3,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !0
    }
  },
  {
    name: "iPhone 15",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 17_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.5 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 393,
      height: 659,
      deviceScaleFactor: 3,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !1
    }
  },
  {
    name: "iPhone 15 landscape",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 17_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.5 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 734,
      height: 343,
      deviceScaleFactor: 3,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !0
    }
  },
  {
    name: "iPhone 15 Plus",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 17_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.5 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 430,
      height: 739,
      deviceScaleFactor: 3,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !1
    }
  },
  {
    name: "iPhone 15 Plus landscape",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 17_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.5 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 814,
      height: 380,
      deviceScaleFactor: 3,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !0
    }
  },
  {
    name: "iPhone 15 Pro",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 17_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.5 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 393,
      height: 659,
      deviceScaleFactor: 3,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !1
    }
  },
  {
    name: "iPhone 15 Pro landscape",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 17_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.5 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 734,
      height: 343,
      deviceScaleFactor: 3,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !0
    }
  },
  {
    name: "iPhone 15 Pro Max",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 17_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.5 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 430,
      height: 739,
      deviceScaleFactor: 3,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !1
    }
  },
  {
    name: "iPhone 15 Pro Max landscape",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 17_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.5 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 814,
      height: 380,
      deviceScaleFactor: 3,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !0
    }
  },
  {
    name: "JioPhone 2",
    userAgent: "Mozilla/5.0 (Mobile; LYF/F300B/LYF-F300B-001-01-15-130718-i;Android; rv:48.0) Gecko/48.0 Firefox/48.0 KAIOS/2.5",
    viewport: {
      width: 240,
      height: 320,
      deviceScaleFactor: 1,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !1
    }
  },
  {
    name: "JioPhone 2 landscape",
    userAgent: "Mozilla/5.0 (Mobile; LYF/F300B/LYF-F300B-001-01-15-130718-i;Android; rv:48.0) Gecko/48.0 Firefox/48.0 KAIOS/2.5",
    viewport: {
      width: 320,
      height: 240,
      deviceScaleFactor: 1,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !0
    }
  },
  {
    name: "Kindle Fire HDX",
    userAgent: "Mozilla/5.0 (Linux; U; en-us; KFAPWI Build/JDQ39) AppleWebKit/535.19 (KHTML, like Gecko) Silk/3.13 Safari/535.19 Silk-Accelerated=true",
    viewport: {
      width: 800,
      height: 1280,
      deviceScaleFactor: 2,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !1
    }
  },
  {
    name: "Kindle Fire HDX landscape",
    userAgent: "Mozilla/5.0 (Linux; U; en-us; KFAPWI Build/JDQ39) AppleWebKit/535.19 (KHTML, like Gecko) Silk/3.13 Safari/535.19 Silk-Accelerated=true",
    viewport: {
      width: 1280,
      height: 800,
      deviceScaleFactor: 2,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !0
    }
  },
  {
    name: "LG Optimus L70",
    userAgent: "Mozilla/5.0 (Linux; U; Android 4.4.2; en-us; LGMS323 Build/KOT49I.MS32310c) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/75.0.3765.0 Mobile Safari/537.36",
    viewport: {
      width: 384,
      height: 640,
      deviceScaleFactor: 1.25,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !1
    }
  },
  {
    name: "LG Optimus L70 landscape",
    userAgent: "Mozilla/5.0 (Linux; U; Android 4.4.2; en-us; LGMS323 Build/KOT49I.MS32310c) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/75.0.3765.0 Mobile Safari/537.36",
    viewport: {
      width: 640,
      height: 384,
      deviceScaleFactor: 1.25,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !0
    }
  },
  {
    name: "Microsoft Lumia 550",
    userAgent: "Mozilla/5.0 (Windows Phone 10.0; Android 4.2.1; Microsoft; Lumia 550) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2486.0 Mobile Safari/537.36 Edge/14.14263",
    viewport: {
      width: 640,
      height: 360,
      deviceScaleFactor: 2,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !1
    }
  },
  {
    name: "Microsoft Lumia 950",
    userAgent: "Mozilla/5.0 (Windows Phone 10.0; Android 4.2.1; Microsoft; Lumia 950) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2486.0 Mobile Safari/537.36 Edge/14.14263",
    viewport: {
      width: 360,
      height: 640,
      deviceScaleFactor: 4,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !1
    }
  },
  {
    name: "Microsoft Lumia 950 landscape",
    userAgent: "Mozilla/5.0 (Windows Phone 10.0; Android 4.2.1; Microsoft; Lumia 950) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2486.0 Mobile Safari/537.36 Edge/14.14263",
    viewport: {
      width: 640,
      height: 360,
      deviceScaleFactor: 4,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !0
    }
  },
  {
    name: "Nexus 10",
    userAgent: "Mozilla/5.0 (Linux; Android 6.0.1; Nexus 10 Build/MOB31T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Safari/537.36",
    viewport: {
      width: 800,
      height: 1280,
      deviceScaleFactor: 2,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !1
    }
  },
  {
    name: "Nexus 10 landscape",
    userAgent: "Mozilla/5.0 (Linux; Android 6.0.1; Nexus 10 Build/MOB31T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Safari/537.36",
    viewport: {
      width: 1280,
      height: 800,
      deviceScaleFactor: 2,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !0
    }
  },
  {
    name: "Nexus 4",
    userAgent: "Mozilla/5.0 (Linux; Android 4.4.2; Nexus 4 Build/KOT49H) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
    viewport: {
      width: 384,
      height: 640,
      deviceScaleFactor: 2,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !1
    }
  },
  {
    name: "Nexus 4 landscape",
    userAgent: "Mozilla/5.0 (Linux; Android 4.4.2; Nexus 4 Build/KOT49H) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
    viewport: {
      width: 640,
      height: 384,
      deviceScaleFactor: 2,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !0
    }
  },
  {
    name: "Nexus 5",
    userAgent: "Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
    viewport: {
      width: 360,
      height: 640,
      deviceScaleFactor: 3,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !1
    }
  },
  {
    name: "Nexus 5 landscape",
    userAgent: "Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
    viewport: {
      width: 640,
      height: 360,
      deviceScaleFactor: 3,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !0
    }
  },
  {
    name: "Nexus 5X",
    userAgent: "Mozilla/5.0 (Linux; Android 8.0.0; Nexus 5X Build/OPR4.170623.006) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
    viewport: {
      width: 412,
      height: 732,
      deviceScaleFactor: 2.625,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !1
    }
  },
  {
    name: "Nexus 5X landscape",
    userAgent: "Mozilla/5.0 (Linux; Android 8.0.0; Nexus 5X Build/OPR4.170623.006) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
    viewport: {
      width: 732,
      height: 412,
      deviceScaleFactor: 2.625,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !0
    }
  },
  {
    name: "Nexus 6",
    userAgent: "Mozilla/5.0 (Linux; Android 7.1.1; Nexus 6 Build/N6F26U) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
    viewport: {
      width: 412,
      height: 732,
      deviceScaleFactor: 3.5,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !1
    }
  },
  {
    name: "Nexus 6 landscape",
    userAgent: "Mozilla/5.0 (Linux; Android 7.1.1; Nexus 6 Build/N6F26U) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
    viewport: {
      width: 732,
      height: 412,
      deviceScaleFactor: 3.5,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !0
    }
  },
  {
    name: "Nexus 6P",
    userAgent: "Mozilla/5.0 (Linux; Android 8.0.0; Nexus 6P Build/OPP3.170518.006) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
    viewport: {
      width: 412,
      height: 732,
      deviceScaleFactor: 3.5,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !1
    }
  },
  {
    name: "Nexus 6P landscape",
    userAgent: "Mozilla/5.0 (Linux; Android 8.0.0; Nexus 6P Build/OPP3.170518.006) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
    viewport: {
      width: 732,
      height: 412,
      deviceScaleFactor: 3.5,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !0
    }
  },
  {
    name: "Nexus 7",
    userAgent: "Mozilla/5.0 (Linux; Android 6.0.1; Nexus 7 Build/MOB30X) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Safari/537.36",
    viewport: {
      width: 600,
      height: 960,
      deviceScaleFactor: 2,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !1
    }
  },
  {
    name: "Nexus 7 landscape",
    userAgent: "Mozilla/5.0 (Linux; Android 6.0.1; Nexus 7 Build/MOB30X) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Safari/537.36",
    viewport: {
      width: 960,
      height: 600,
      deviceScaleFactor: 2,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !0
    }
  },
  {
    name: "Nokia Lumia 520",
    userAgent: "Mozilla/5.0 (compatible; MSIE 10.0; Windows Phone 8.0; Trident/6.0; IEMobile/10.0; ARM; Touch; NOKIA; Lumia 520)",
    viewport: {
      width: 320,
      height: 533,
      deviceScaleFactor: 1.5,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !1
    }
  },
  {
    name: "Nokia Lumia 520 landscape",
    userAgent: "Mozilla/5.0 (compatible; MSIE 10.0; Windows Phone 8.0; Trident/6.0; IEMobile/10.0; ARM; Touch; NOKIA; Lumia 520)",
    viewport: {
      width: 533,
      height: 320,
      deviceScaleFactor: 1.5,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !0
    }
  },
  {
    name: "Nokia N9",
    userAgent: "Mozilla/5.0 (MeeGo; NokiaN9) AppleWebKit/534.13 (KHTML, like Gecko) NokiaBrowser/8.5.0 Mobile Safari/534.13",
    viewport: {
      width: 480,
      height: 854,
      deviceScaleFactor: 1,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !1
    }
  },
  {
    name: "Nokia N9 landscape",
    userAgent: "Mozilla/5.0 (MeeGo; NokiaN9) AppleWebKit/534.13 (KHTML, like Gecko) NokiaBrowser/8.5.0 Mobile Safari/534.13",
    viewport: {
      width: 854,
      height: 480,
      deviceScaleFactor: 1,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !0
    }
  },
  {
    name: "Pixel 2",
    userAgent: "Mozilla/5.0 (Linux; Android 8.0; Pixel 2 Build/OPD3.170816.012) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
    viewport: {
      width: 411,
      height: 731,
      deviceScaleFactor: 2.625,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !1
    }
  },
  {
    name: "Pixel 2 landscape",
    userAgent: "Mozilla/5.0 (Linux; Android 8.0; Pixel 2 Build/OPD3.170816.012) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
    viewport: {
      width: 731,
      height: 411,
      deviceScaleFactor: 2.625,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !0
    }
  },
  {
    name: "Pixel 2 XL",
    userAgent: "Mozilla/5.0 (Linux; Android 8.0.0; Pixel 2 XL Build/OPD1.170816.004) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
    viewport: {
      width: 411,
      height: 823,
      deviceScaleFactor: 3.5,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !1
    }
  },
  {
    name: "Pixel 2 XL landscape",
    userAgent: "Mozilla/5.0 (Linux; Android 8.0.0; Pixel 2 XL Build/OPD1.170816.004) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
    viewport: {
      width: 823,
      height: 411,
      deviceScaleFactor: 3.5,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !0
    }
  },
  {
    name: "Pixel 3",
    userAgent: "Mozilla/5.0 (Linux; Android 9; Pixel 3 Build/PQ1A.181105.017.A1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.158 Mobile Safari/537.36",
    viewport: {
      width: 393,
      height: 786,
      deviceScaleFactor: 2.75,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !1
    }
  },
  {
    name: "Pixel 3 landscape",
    userAgent: "Mozilla/5.0 (Linux; Android 9; Pixel 3 Build/PQ1A.181105.017.A1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.158 Mobile Safari/537.36",
    viewport: {
      width: 786,
      height: 393,
      deviceScaleFactor: 2.75,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !0
    }
  },
  {
    name: "Pixel 4",
    userAgent: "Mozilla/5.0 (Linux; Android 10; Pixel 4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.138 Mobile Safari/537.36",
    viewport: {
      width: 353,
      height: 745,
      deviceScaleFactor: 3,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !1
    }
  },
  {
    name: "Pixel 4 landscape",
    userAgent: "Mozilla/5.0 (Linux; Android 10; Pixel 4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.138 Mobile Safari/537.36",
    viewport: {
      width: 745,
      height: 353,
      deviceScaleFactor: 3,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !0
    }
  },
  {
    name: "Pixel 4a (5G)",
    userAgent: "Mozilla/5.0 (Linux; Android 11; Pixel 4a (5G)) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4812.0 Mobile Safari/537.36",
    viewport: {
      width: 353,
      height: 745,
      deviceScaleFactor: 3,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !1
    }
  },
  {
    name: "Pixel 4a (5G) landscape",
    userAgent: "Mozilla/5.0 (Linux; Android 11; Pixel 4a (5G)) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4812.0 Mobile Safari/537.36",
    viewport: {
      width: 745,
      height: 353,
      deviceScaleFactor: 3,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !0
    }
  },
  {
    name: "Pixel 5",
    userAgent: "Mozilla/5.0 (Linux; Android 11; Pixel 5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4812.0 Mobile Safari/537.36",
    viewport: {
      width: 393,
      height: 851,
      deviceScaleFactor: 3,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !1
    }
  },
  {
    name: "Pixel 5 landscape",
    userAgent: "Mozilla/5.0 (Linux; Android 11; Pixel 5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4812.0 Mobile Safari/537.36",
    viewport: {
      width: 851,
      height: 393,
      deviceScaleFactor: 3,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !0
    }
  },
  {
    name: "Moto G4",
    userAgent: "Mozilla/5.0 (Linux; Android 7.0; Moto G (4)) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4812.0 Mobile Safari/537.36",
    viewport: {
      width: 360,
      height: 640,
      deviceScaleFactor: 3,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !1
    }
  },
  {
    name: "Moto G4 landscape",
    userAgent: "Mozilla/5.0 (Linux; Android 7.0; Moto G (4)) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4812.0 Mobile Safari/537.36",
    viewport: {
      width: 640,
      height: 360,
      deviceScaleFactor: 3,
      isMobile: !0,
      hasTouch: !0,
      isLandscape: !0
    }
  }
], DT = {};
for (const t of bAA)
  DT[t.name] = t;
Object.freeze(DT);
/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
async function MAA(t, A, e) {
  const { acceptInsecureCerts: r = !1, networkEnabled: i = !0, defaultViewport: n = NS } = e, { bidiConnection: s, cdpConnection: a, closeCallback: g } = await _AA(t, A, e);
  return await (await import(
    /* webpackIgnore: true */
    "./bidi-igbSTPgO.js"
  )).BidiBrowser.create({
    connection: s,
    cdpConnection: a,
    closeCallback: g,
    process: void 0,
    defaultViewport: n,
    acceptInsecureCerts: r,
    networkEnabled: i,
    capabilities: e.capabilities
  });
}
async function _AA(t, A, e) {
  const r = await import(
    /* webpackIgnore: true */
    "./bidi-igbSTPgO.js"
  ), { slowMo: i = 0, protocolTimeout: n, idGenerator: s = qE() } = e, a = new r.BidiConnection(A, t, s, i, n);
  try {
    const I = await a.send("session.status", {});
    if ("type" in I && I.type === "success")
      return {
        bidiConnection: a,
        closeCallback: async () => {
          await a.send("browser.close", {}).catch(HA);
        }
      };
  } catch (I) {
    if (!(I instanceof Qg))
      throw I;
  }
  a.unbind();
  const g = new Af(
    A,
    t,
    i,
    n,
    /* rawErrors= */
    !0,
    s
  );
  if ((await g.send("Browser.getVersion")).product.toLowerCase().includes("firefox"))
    throw new _S("Firefox is not supported in BiDi over CDP mode.");
  const u = await r.connectBidiOverCdp(g);
  return {
    cdpConnection: g,
    bidiConnection: u,
    closeCallback: async () => {
      await g.send("Browser.close").catch(HA);
    }
  };
}
/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
const My = async () => RS ? (await Promise.resolve().then(() => unA)).NodeWebSocketTransport : (await import("./BrowserWebSocketTransport-Bn0KCDWB.js")).BrowserWebSocketTransport;
async function NAA(t) {
  const { connectionTransport: A, endpointUrl: e } = await LAA(t);
  return t.protocol === "webDriverBiDi" ? await MAA(A, e, t) : await RAA(A, e, t);
}
async function LAA(t) {
  const { browserWSEndpoint: A, browserURL: e, channel: r, transport: i, headers: n = {} } = t;
  if (bA(+!!A + +!!e + +!!i + +!!r == 1, "Exactly one of browserWSEndpoint, browserURL, transport or channel must be passed to puppeteer.connect"), i)
    return { connectionTransport: i, endpointUrl: "" };
  if (A)
    return {
      connectionTransport: await (await My()).create(A, n),
      endpointUrl: A
    };
  if (e) {
    const s = await xAA(e);
    return {
      connectionTransport: await (await My()).create(s),
      endpointUrl: s
    };
  } else if (t.channel && RS) {
    const { detectBrowserPlatform: s, resolveDefaultUserDataDir: a, Browser: g } = await import("./main-B5y7KfTD.js"), o = s();
    if (!o)
      throw new Error("Could not detect required browser platform");
    const { convertPuppeteerChannelToBrowsersChannel: u } = await Promise.resolve().then(() => InA), { join: I } = await import("node:path"), c = a(g.CHROME, o, u(t.channel)), C = I(c, "DevToolsActivePort");
    try {
      const E = await cs.value.fs.promises.readFile(C, "ascii"), [l, B] = E.split(`
`).map((y) => y.trim()).filter((y) => !!y);
      if (!l || !B)
        throw new Error(`Invalid DevToolsActivePort '${E}' found`);
      const h = parseInt(l, 10);
      if (isNaN(h) || h <= 0 || h > 65535)
        throw new Error(`Invalid port '${l}' found`);
      const Q = `ws://localhost:${h}${B}`;
      return {
        connectionTransport: await (await My()).create(Q, n),
        endpointUrl: Q
      };
    } catch (E) {
      throw new Error(`Could not find DevToolsActivePort for ${t.channel} at ${C}`, {
        cause: E
      });
    }
  }
  throw new Error("Invalid connection options");
}
async function xAA(t) {
  const A = new URL("/json/version", t);
  try {
    const e = await globalThis.fetch(A.toString(), {
      method: "GET"
    });
    if (!e.ok)
      throw new Error(`HTTP ${e.statusText}`);
    return (await e.json()).webSocketDebuggerUrl;
  } catch (e) {
    throw _i(e) && (e.message = `Failed to fetch browser webSocket URL from ${A}: ` + e.message), e;
  }
}
/**
 * @license
 * Copyright 2017 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
class ST {
  /**
   * @internal
   */
  constructor(A) {
    /**
     * @internal
     */
    R(this, "_isPuppeteerCore");
    /**
     * @internal
     */
    R(this, "_changedBrowsers", !1);
    this._isPuppeteerCore = A.isPuppeteerCore, this.connect = this.connect.bind(this);
  }
  /**
   * Registers a {@link CustomQueryHandler | custom query handler}.
   *
   * @remarks
   * After registration, the handler can be used everywhere where a selector is
   * expected by prepending the selection string with `<name>/`. The name is only
   * allowed to consist of lower- and upper case latin letters.
   *
   * @example
   *
   * ```
   * import {Puppeteer}, puppeteer from 'puppeteer';
   *
   * Puppeteer.registerCustomQueryHandler('text', { â€¦ });
   * const aHandle = await page.$('text/â€¦');
   * ```
   *
   * @param name - The name that the custom query handler will be registered
   * under.
   * @param queryHandler - The {@link CustomQueryHandler | custom query handler}
   * to register.
   *
   * @public
   */
  static registerCustomQueryHandler(A, e) {
    return this.customQueryHandlers.register(A, e);
  }
  /**
   * Unregisters a custom query handler for a given name.
   */
  static unregisterCustomQueryHandler(A) {
    return this.customQueryHandlers.unregister(A);
  }
  /**
   * Gets the names of all custom query handlers.
   */
  static customQueryHandlerNames() {
    return this.customQueryHandlers.names();
  }
  /**
   * Unregisters all custom query handlers.
   */
  static clearCustomQueryHandlers() {
    return this.customQueryHandlers.clear();
  }
  /**
   * This method attaches Puppeteer to an existing browser instance.
   *
   * @remarks
   *
   * @param options - Set of configurable options to set on the browser.
   * @returns Promise which resolves to browser instance.
   */
  connect(A) {
    return NAA(A);
  }
}
/**
 * Operations for {@link CustomQueryHandler | custom query handlers}. See
 * {@link CustomQueryHandlerRegistry}.
 *
 * @internal
 */
R(ST, "customQueryHandlers", Um);
/**
 * @license
 * Copyright 2020 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
const wI = Object.freeze({
  chrome: "143.0.7499.42",
  "chrome-headless-shell": "143.0.7499.42",
  firefox: "stable_146.0"
});
/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
var ZA;
(function(t) {
  t.CHROME = "chrome", t.CHROMEHEADLESSSHELL = "chrome-headless-shell", t.CHROMIUM = "chromium", t.FIREFOX = "firefox", t.CHROMEDRIVER = "chromedriver";
})(ZA || (ZA = {}));
var QA;
(function(t) {
  t.LINUX = "linux", t.LINUX_ARM = "linux_arm", t.MAC = "mac", t.MAC_ARM = "mac_arm", t.WIN32 = "win32", t.WIN64 = "win64";
})(QA || (QA = {}));
var ae;
(function(t) {
  t.CANARY = "canary", t.NIGHTLY = "nightly", t.BETA = "beta", t.DEV = "dev", t.DEVEDITION = "devedition", t.STABLE = "stable", t.ESR = "esr", t.LATEST = "latest";
})(ae || (ae = {}));
var ie;
(function(t) {
  t.STABLE = "stable", t.DEV = "dev", t.CANARY = "canary", t.BETA = "beta";
})(ie || (ie = {}));
var FT = {};
const mI = typeof performance == "object" && performance && typeof performance.now == "function" ? performance : Date, GAA = typeof AbortController == "function", nf = GAA ? AbortController : class {
  constructor() {
    this.signal = new kT();
  }
  abort(A = new Error("This operation was aborted")) {
    this.signal.reason = this.signal.reason || A, this.signal.aborted = !0, this.signal.dispatchEvent({
      type: "abort",
      target: this.signal
    });
  }
}, UAA = typeof AbortSignal == "function", TAA = typeof nf.AbortSignal == "function", kT = UAA ? AbortSignal : TAA ? nf.AbortController : class {
  constructor() {
    this.reason = void 0, this.aborted = !1, this._listeners = [];
  }
  dispatchEvent(A) {
    A.type === "abort" && (this.aborted = !0, this.onabort(A), this._listeners.forEach((e) => e(A), this));
  }
  onabort() {
  }
  addEventListener(A, e) {
    A === "abort" && this._listeners.push(e);
  }
  removeEventListener(A, e) {
    A === "abort" && (this._listeners = this._listeners.filter((r) => r !== e));
  }
}, GS = /* @__PURE__ */ new Set(), _y = (t, A) => {
  const e = `LRU_CACHE_OPTION_${t}`;
  Fp(e) && US(e, `${t} option`, `options.${A}`, fg);
}, Ny = (t, A) => {
  const e = `LRU_CACHE_METHOD_${t}`;
  if (Fp(e)) {
    const { prototype: r } = fg, { get: i } = Object.getOwnPropertyDescriptor(r, t);
    US(e, `${t} method`, `cache.${A}()`, i);
  }
}, KAA = (t, A) => {
  const e = `LRU_CACHE_PROPERTY_${t}`;
  if (Fp(e)) {
    const { prototype: r } = fg, { get: i } = Object.getOwnPropertyDescriptor(r, t);
    US(e, `${t} property`, `cache.${A}`, i);
  }
}, vT = (...t) => {
  typeof process == "object" && process && typeof process.emitWarning == "function" ? process.emitWarning(...t) : console.error(...t);
}, Fp = (t) => !GS.has(t), US = (t, A, e, r) => {
  GS.add(t);
  const i = `The ${A} is deprecated. Please use ${e} instead.`;
  vT(i, "DeprecationWarning", t, r);
}, Ns = (t) => t && t === Math.floor(t) && t > 0 && isFinite(t), RT = (t) => Ns(t) ? t <= Math.pow(2, 8) ? Uint8Array : t <= Math.pow(2, 16) ? Uint16Array : t <= Math.pow(2, 32) ? Uint32Array : t <= Number.MAX_SAFE_INTEGER ? nd : null : null;
class nd extends Array {
  constructor(A) {
    super(A), this.fill(0);
  }
}
class JAA {
  constructor(A) {
    if (A === 0)
      return [];
    const e = RT(A);
    this.heap = new e(A), this.length = 0;
  }
  push(A) {
    this.heap[this.length++] = A;
  }
  pop() {
    return this.heap[--this.length];
  }
}
class fg {
  constructor(A = {}) {
    const {
      max: e = 0,
      ttl: r,
      ttlResolution: i = 1,
      ttlAutopurge: n,
      updateAgeOnGet: s,
      updateAgeOnHas: a,
      allowStale: g,
      dispose: o,
      disposeAfter: u,
      noDisposeOnSet: I,
      noUpdateTTL: c,
      maxSize: C = 0,
      maxEntrySize: E = 0,
      sizeCalculation: l,
      fetchMethod: B,
      fetchContext: h,
      noDeleteOnFetchRejection: Q,
      noDeleteOnStaleGet: f,
      allowStaleOnFetchRejection: p,
      allowStaleOnFetchAbort: y,
      ignoreFetchAbort: m
    } = A, { length: S, maxAge: w, stale: F } = A instanceof fg ? {} : A;
    if (e !== 0 && !Ns(e))
      throw new TypeError("max option must be a nonnegative integer");
    const b = e ? RT(e) : Array;
    if (!b)
      throw new Error("invalid max value: " + e);
    if (this.max = e, this.maxSize = C, this.maxEntrySize = E || this.maxSize, this.sizeCalculation = l || S, this.sizeCalculation) {
      if (!this.maxSize && !this.maxEntrySize)
        throw new TypeError(
          "cannot set sizeCalculation without setting maxSize or maxEntrySize"
        );
      if (typeof this.sizeCalculation != "function")
        throw new TypeError("sizeCalculation set to non-function");
    }
    if (this.fetchMethod = B || null, this.fetchMethod && typeof this.fetchMethod != "function")
      throw new TypeError(
        "fetchMethod must be a function if specified"
      );
    if (this.fetchContext = h, !this.fetchMethod && h !== void 0)
      throw new TypeError(
        "cannot set fetchContext without fetchMethod"
      );
    if (this.keyMap = /* @__PURE__ */ new Map(), this.keyList = new Array(e).fill(null), this.valList = new Array(e).fill(null), this.next = new b(e), this.prev = new b(e), this.head = 0, this.tail = 0, this.free = new JAA(e), this.initialFill = 1, this.size = 0, typeof o == "function" && (this.dispose = o), typeof u == "function" ? (this.disposeAfter = u, this.disposed = []) : (this.disposeAfter = null, this.disposed = null), this.noDisposeOnSet = !!I, this.noUpdateTTL = !!c, this.noDeleteOnFetchRejection = !!Q, this.allowStaleOnFetchRejection = !!p, this.allowStaleOnFetchAbort = !!y, this.ignoreFetchAbort = !!m, this.maxEntrySize !== 0) {
      if (this.maxSize !== 0 && !Ns(this.maxSize))
        throw new TypeError(
          "maxSize must be a positive integer if specified"
        );
      if (!Ns(this.maxEntrySize))
        throw new TypeError(
          "maxEntrySize must be a positive integer if specified"
        );
      this.initializeSizeTracking();
    }
    if (this.allowStale = !!g || !!F, this.noDeleteOnStaleGet = !!f, this.updateAgeOnGet = !!s, this.updateAgeOnHas = !!a, this.ttlResolution = Ns(i) || i === 0 ? i : 1, this.ttlAutopurge = !!n, this.ttl = r || w || 0, this.ttl) {
      if (!Ns(this.ttl))
        throw new TypeError(
          "ttl must be a positive integer if specified"
        );
      this.initializeTTLTracking();
    }
    if (this.max === 0 && this.ttl === 0 && this.maxSize === 0)
      throw new TypeError(
        "At least one of max, maxSize, or ttl is required"
      );
    if (!this.ttlAutopurge && !this.max && !this.maxSize) {
      const G = "LRU_CACHE_UNBOUNDED";
      Fp(G) && (GS.add(G), vT("TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.", "UnboundedCacheWarning", G, fg));
    }
    F && _y("stale", "allowStale"), w && _y("maxAge", "ttl"), S && _y("length", "sizeCalculation");
  }
  getRemainingTTL(A) {
    return this.has(A, { updateAgeOnHas: !1 }) ? 1 / 0 : 0;
  }
  initializeTTLTracking() {
    this.ttls = new nd(this.max), this.starts = new nd(this.max), this.setItemTTL = (r, i, n = mI.now()) => {
      if (this.starts[r] = i !== 0 ? n : 0, this.ttls[r] = i, i !== 0 && this.ttlAutopurge) {
        const s = setTimeout(() => {
          this.isStale(r) && this.delete(this.keyList[r]);
        }, i + 1);
        s.unref && s.unref();
      }
    }, this.updateItemAge = (r) => {
      this.starts[r] = this.ttls[r] !== 0 ? mI.now() : 0;
    }, this.statusTTL = (r, i) => {
      r && (r.ttl = this.ttls[i], r.start = this.starts[i], r.now = A || e(), r.remainingTTL = r.now + r.ttl - r.start);
    };
    let A = 0;
    const e = () => {
      const r = mI.now();
      if (this.ttlResolution > 0) {
        A = r;
        const i = setTimeout(
          () => A = 0,
          this.ttlResolution
        );
        i.unref && i.unref();
      }
      return r;
    };
    this.getRemainingTTL = (r) => {
      const i = this.keyMap.get(r);
      return i === void 0 ? 0 : this.ttls[i] === 0 || this.starts[i] === 0 ? 1 / 0 : this.starts[i] + this.ttls[i] - (A || e());
    }, this.isStale = (r) => this.ttls[r] !== 0 && this.starts[r] !== 0 && (A || e()) - this.starts[r] > this.ttls[r];
  }
  updateItemAge(A) {
  }
  statusTTL(A, e) {
  }
  setItemTTL(A, e, r) {
  }
  isStale(A) {
    return !1;
  }
  initializeSizeTracking() {
    this.calculatedSize = 0, this.sizes = new nd(this.max), this.removeItemSize = (A) => {
      this.calculatedSize -= this.sizes[A], this.sizes[A] = 0;
    }, this.requireSize = (A, e, r, i) => {
      if (this.isBackgroundFetch(e))
        return 0;
      if (!Ns(r))
        if (i) {
          if (typeof i != "function")
            throw new TypeError("sizeCalculation must be a function");
          if (r = i(e, A), !Ns(r))
            throw new TypeError(
              "sizeCalculation return invalid (expect positive integer)"
            );
        } else
          throw new TypeError(
            "invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set."
          );
      return r;
    }, this.addItemSize = (A, e, r) => {
      if (this.sizes[A] = e, this.maxSize) {
        const i = this.maxSize - this.sizes[A];
        for (; this.calculatedSize > i; )
          this.evict(!0);
      }
      this.calculatedSize += this.sizes[A], r && (r.entrySize = e, r.totalCalculatedSize = this.calculatedSize);
    };
  }
  removeItemSize(A) {
  }
  addItemSize(A, e) {
  }
  requireSize(A, e, r, i) {
    if (r || i)
      throw new TypeError(
        "cannot set size without setting maxSize or maxEntrySize on cache"
      );
  }
  *indexes({ allowStale: A = this.allowStale } = {}) {
    if (this.size)
      for (let e = this.tail; !(!this.isValidIndex(e) || ((A || !this.isStale(e)) && (yield e), e === this.head)); )
        e = this.prev[e];
  }
  *rindexes({ allowStale: A = this.allowStale } = {}) {
    if (this.size)
      for (let e = this.head; !(!this.isValidIndex(e) || ((A || !this.isStale(e)) && (yield e), e === this.tail)); )
        e = this.next[e];
  }
  isValidIndex(A) {
    return A !== void 0 && this.keyMap.get(this.keyList[A]) === A;
  }
  *entries() {
    for (const A of this.indexes())
      this.valList[A] !== void 0 && this.keyList[A] !== void 0 && !this.isBackgroundFetch(this.valList[A]) && (yield [this.keyList[A], this.valList[A]]);
  }
  *rentries() {
    for (const A of this.rindexes())
      this.valList[A] !== void 0 && this.keyList[A] !== void 0 && !this.isBackgroundFetch(this.valList[A]) && (yield [this.keyList[A], this.valList[A]]);
  }
  *keys() {
    for (const A of this.indexes())
      this.keyList[A] !== void 0 && !this.isBackgroundFetch(this.valList[A]) && (yield this.keyList[A]);
  }
  *rkeys() {
    for (const A of this.rindexes())
      this.keyList[A] !== void 0 && !this.isBackgroundFetch(this.valList[A]) && (yield this.keyList[A]);
  }
  *values() {
    for (const A of this.indexes())
      this.valList[A] !== void 0 && !this.isBackgroundFetch(this.valList[A]) && (yield this.valList[A]);
  }
  *rvalues() {
    for (const A of this.rindexes())
      this.valList[A] !== void 0 && !this.isBackgroundFetch(this.valList[A]) && (yield this.valList[A]);
  }
  [Symbol.iterator]() {
    return this.entries();
  }
  find(A, e) {
    for (const r of this.indexes()) {
      const i = this.valList[r], n = this.isBackgroundFetch(i) ? i.__staleWhileFetching : i;
      if (n !== void 0 && A(n, this.keyList[r], this))
        return this.get(this.keyList[r], e);
    }
  }
  forEach(A, e = this) {
    for (const r of this.indexes()) {
      const i = this.valList[r], n = this.isBackgroundFetch(i) ? i.__staleWhileFetching : i;
      n !== void 0 && A.call(e, n, this.keyList[r], this);
    }
  }
  rforEach(A, e = this) {
    for (const r of this.rindexes()) {
      const i = this.valList[r], n = this.isBackgroundFetch(i) ? i.__staleWhileFetching : i;
      n !== void 0 && A.call(e, n, this.keyList[r], this);
    }
  }
  get prune() {
    return Ny("prune", "purgeStale"), this.purgeStale;
  }
  purgeStale() {
    let A = !1;
    for (const e of this.rindexes({ allowStale: !0 }))
      this.isStale(e) && (this.delete(this.keyList[e]), A = !0);
    return A;
  }
  dump() {
    const A = [];
    for (const e of this.indexes({ allowStale: !0 })) {
      const r = this.keyList[e], i = this.valList[e], n = this.isBackgroundFetch(i) ? i.__staleWhileFetching : i;
      if (n === void 0) continue;
      const s = { value: n };
      if (this.ttls) {
        s.ttl = this.ttls[e];
        const a = mI.now() - this.starts[e];
        s.start = Math.floor(Date.now() - a);
      }
      this.sizes && (s.size = this.sizes[e]), A.unshift([r, s]);
    }
    return A;
  }
  load(A) {
    this.clear();
    for (const [e, r] of A) {
      if (r.start) {
        const i = Date.now() - r.start;
        r.start = mI.now() - i;
      }
      this.set(e, r.value, r);
    }
  }
  dispose(A, e, r) {
  }
  set(A, e, {
    ttl: r = this.ttl,
    start: i,
    noDisposeOnSet: n = this.noDisposeOnSet,
    size: s = 0,
    sizeCalculation: a = this.sizeCalculation,
    noUpdateTTL: g = this.noUpdateTTL,
    status: o
  } = {}) {
    if (s = this.requireSize(A, e, s, a), this.maxEntrySize && s > this.maxEntrySize)
      return o && (o.set = "miss", o.maxEntrySizeExceeded = !0), this.delete(A), this;
    let u = this.size === 0 ? void 0 : this.keyMap.get(A);
    if (u === void 0)
      u = this.newIndex(), this.keyList[u] = A, this.valList[u] = e, this.keyMap.set(A, u), this.next[this.tail] = u, this.prev[u] = this.tail, this.tail = u, this.size++, this.addItemSize(u, s, o), o && (o.set = "add"), g = !1;
    else {
      this.moveToTail(u);
      const I = this.valList[u];
      if (e !== I) {
        if (this.isBackgroundFetch(I) ? I.__abortController.abort(new Error("replaced")) : n || (this.dispose(I, A, "set"), this.disposeAfter && this.disposed.push([I, A, "set"])), this.removeItemSize(u), this.valList[u] = e, this.addItemSize(u, s, o), o) {
          o.set = "replace";
          const c = I && this.isBackgroundFetch(I) ? I.__staleWhileFetching : I;
          c !== void 0 && (o.oldValue = c);
        }
      } else o && (o.set = "update");
    }
    if (r !== 0 && this.ttl === 0 && !this.ttls && this.initializeTTLTracking(), g || this.setItemTTL(u, r, i), this.statusTTL(o, u), this.disposeAfter)
      for (; this.disposed.length; )
        this.disposeAfter(...this.disposed.shift());
    return this;
  }
  newIndex() {
    return this.size === 0 ? this.tail : this.size === this.max && this.max !== 0 ? this.evict(!1) : this.free.length !== 0 ? this.free.pop() : this.initialFill++;
  }
  pop() {
    if (this.size) {
      const A = this.valList[this.head];
      return this.evict(!0), A;
    }
  }
  evict(A) {
    const e = this.head, r = this.keyList[e], i = this.valList[e];
    return this.isBackgroundFetch(i) ? i.__abortController.abort(new Error("evicted")) : (this.dispose(i, r, "evict"), this.disposeAfter && this.disposed.push([i, r, "evict"])), this.removeItemSize(e), A && (this.keyList[e] = null, this.valList[e] = null, this.free.push(e)), this.head = this.next[e], this.keyMap.delete(r), this.size--, e;
  }
  has(A, { updateAgeOnHas: e = this.updateAgeOnHas, status: r } = {}) {
    const i = this.keyMap.get(A);
    if (i !== void 0)
      if (this.isStale(i))
        r && (r.has = "stale", this.statusTTL(r, i));
      else return e && this.updateItemAge(i), r && (r.has = "hit"), this.statusTTL(r, i), !0;
    else r && (r.has = "miss");
    return !1;
  }
  // like get(), but without any LRU updating or TTL expiration
  peek(A, { allowStale: e = this.allowStale } = {}) {
    const r = this.keyMap.get(A);
    if (r !== void 0 && (e || !this.isStale(r))) {
      const i = this.valList[r];
      return this.isBackgroundFetch(i) ? i.__staleWhileFetching : i;
    }
  }
  backgroundFetch(A, e, r, i) {
    const n = e === void 0 ? void 0 : this.valList[e];
    if (this.isBackgroundFetch(n))
      return n;
    const s = new nf();
    r.signal && r.signal.addEventListener(
      "abort",
      () => s.abort(r.signal.reason)
    );
    const a = {
      signal: s.signal,
      options: r,
      context: i
    }, g = (C, E = !1) => {
      const { aborted: l } = s.signal, B = r.ignoreFetchAbort && C !== void 0;
      return r.status && (l && !E ? (r.status.fetchAborted = !0, r.status.fetchError = s.signal.reason, B && (r.status.fetchAbortIgnored = !0)) : r.status.fetchResolved = !0), l && !B && !E ? u(s.signal.reason) : (this.valList[e] === c && (C === void 0 ? c.__staleWhileFetching ? this.valList[e] = c.__staleWhileFetching : this.delete(A) : (r.status && (r.status.fetchUpdated = !0), this.set(A, C, a.options))), C);
    }, o = (C) => (r.status && (r.status.fetchRejected = !0, r.status.fetchError = C), u(C)), u = (C) => {
      const { aborted: E } = s.signal, l = E && r.allowStaleOnFetchAbort, B = l || r.allowStaleOnFetchRejection, h = B || r.noDeleteOnFetchRejection;
      if (this.valList[e] === c && (!h || c.__staleWhileFetching === void 0 ? this.delete(A) : l || (this.valList[e] = c.__staleWhileFetching)), B)
        return r.status && c.__staleWhileFetching !== void 0 && (r.status.returnedStale = !0), c.__staleWhileFetching;
      if (c.__returned === c)
        throw C;
    }, I = (C, E) => {
      this.fetchMethod(A, n, a).then((l) => C(l), E), s.signal.addEventListener("abort", () => {
        (!r.ignoreFetchAbort || r.allowStaleOnFetchAbort) && (C(), r.allowStaleOnFetchAbort && (C = (l) => g(l, !0)));
      });
    };
    r.status && (r.status.fetchDispatched = !0);
    const c = new Promise(I).then(g, o);
    return c.__abortController = s, c.__staleWhileFetching = n, c.__returned = null, e === void 0 ? (this.set(A, c, { ...a.options, status: void 0 }), e = this.keyMap.get(A)) : this.valList[e] = c, c;
  }
  isBackgroundFetch(A) {
    return A && typeof A == "object" && typeof A.then == "function" && Object.prototype.hasOwnProperty.call(
      A,
      "__staleWhileFetching"
    ) && Object.prototype.hasOwnProperty.call(A, "__returned") && (A.__returned === A || A.__returned === null);
  }
  // this takes the union of get() and set() opts, because it does both
  async fetch(A, {
    // get options
    allowStale: e = this.allowStale,
    updateAgeOnGet: r = this.updateAgeOnGet,
    noDeleteOnStaleGet: i = this.noDeleteOnStaleGet,
    // set options
    ttl: n = this.ttl,
    noDisposeOnSet: s = this.noDisposeOnSet,
    size: a = 0,
    sizeCalculation: g = this.sizeCalculation,
    noUpdateTTL: o = this.noUpdateTTL,
    // fetch exclusive options
    noDeleteOnFetchRejection: u = this.noDeleteOnFetchRejection,
    allowStaleOnFetchRejection: I = this.allowStaleOnFetchRejection,
    ignoreFetchAbort: c = this.ignoreFetchAbort,
    allowStaleOnFetchAbort: C = this.allowStaleOnFetchAbort,
    fetchContext: E = this.fetchContext,
    forceRefresh: l = !1,
    status: B,
    signal: h
  } = {}) {
    if (!this.fetchMethod)
      return B && (B.fetch = "get"), this.get(A, {
        allowStale: e,
        updateAgeOnGet: r,
        noDeleteOnStaleGet: i,
        status: B
      });
    const Q = {
      allowStale: e,
      updateAgeOnGet: r,
      noDeleteOnStaleGet: i,
      ttl: n,
      noDisposeOnSet: s,
      size: a,
      sizeCalculation: g,
      noUpdateTTL: o,
      noDeleteOnFetchRejection: u,
      allowStaleOnFetchRejection: I,
      allowStaleOnFetchAbort: C,
      ignoreFetchAbort: c,
      status: B,
      signal: h
    };
    let f = this.keyMap.get(A);
    if (f === void 0) {
      B && (B.fetch = "miss");
      const p = this.backgroundFetch(A, f, Q, E);
      return p.__returned = p;
    } else {
      const p = this.valList[f];
      if (this.isBackgroundFetch(p)) {
        const F = e && p.__staleWhileFetching !== void 0;
        return B && (B.fetch = "inflight", F && (B.returnedStale = !0)), F ? p.__staleWhileFetching : p.__returned = p;
      }
      const y = this.isStale(f);
      if (!l && !y)
        return B && (B.fetch = "hit"), this.moveToTail(f), r && this.updateItemAge(f), this.statusTTL(B, f), p;
      const m = this.backgroundFetch(A, f, Q, E), S = m.__staleWhileFetching !== void 0, w = S && e;
      return B && (B.fetch = S && y ? "stale" : "refresh", w && y && (B.returnedStale = !0)), w ? m.__staleWhileFetching : m.__returned = m;
    }
  }
  get(A, {
    allowStale: e = this.allowStale,
    updateAgeOnGet: r = this.updateAgeOnGet,
    noDeleteOnStaleGet: i = this.noDeleteOnStaleGet,
    status: n
  } = {}) {
    const s = this.keyMap.get(A);
    if (s !== void 0) {
      const a = this.valList[s], g = this.isBackgroundFetch(a);
      return this.statusTTL(n, s), this.isStale(s) ? (n && (n.get = "stale"), g ? (n && (n.returnedStale = e && a.__staleWhileFetching !== void 0), e ? a.__staleWhileFetching : void 0) : (i || this.delete(A), n && (n.returnedStale = e), e ? a : void 0)) : (n && (n.get = "hit"), g ? a.__staleWhileFetching : (this.moveToTail(s), r && this.updateItemAge(s), a));
    } else n && (n.get = "miss");
  }
  connect(A, e) {
    this.prev[e] = A, this.next[A] = e;
  }
  moveToTail(A) {
    A !== this.tail && (A === this.head ? this.head = this.next[A] : this.connect(this.prev[A], this.next[A]), this.connect(this.tail, A), this.tail = A);
  }
  get del() {
    return Ny("del", "delete"), this.delete;
  }
  delete(A) {
    let e = !1;
    if (this.size !== 0) {
      const r = this.keyMap.get(A);
      if (r !== void 0)
        if (e = !0, this.size === 1)
          this.clear();
        else {
          this.removeItemSize(r);
          const i = this.valList[r];
          this.isBackgroundFetch(i) ? i.__abortController.abort(new Error("deleted")) : (this.dispose(i, A, "delete"), this.disposeAfter && this.disposed.push([i, A, "delete"])), this.keyMap.delete(A), this.keyList[r] = null, this.valList[r] = null, r === this.tail ? this.tail = this.prev[r] : r === this.head ? this.head = this.next[r] : (this.next[this.prev[r]] = this.next[r], this.prev[this.next[r]] = this.prev[r]), this.size--, this.free.push(r);
        }
    }
    if (this.disposed)
      for (; this.disposed.length; )
        this.disposeAfter(...this.disposed.shift());
    return e;
  }
  clear() {
    for (const A of this.rindexes({ allowStale: !0 })) {
      const e = this.valList[A];
      if (this.isBackgroundFetch(e))
        e.__abortController.abort(new Error("deleted"));
      else {
        const r = this.keyList[A];
        this.dispose(e, r, "delete"), this.disposeAfter && this.disposed.push([e, r, "delete"]);
      }
    }
    if (this.keyMap.clear(), this.valList.fill(null), this.keyList.fill(null), this.ttls && (this.ttls.fill(0), this.starts.fill(0)), this.sizes && this.sizes.fill(0), this.head = 0, this.tail = 0, this.initialFill = 1, this.free.length = 0, this.calculatedSize = 0, this.size = 0, this.disposed)
      for (; this.disposed.length; )
        this.disposeAfter(...this.disposed.shift());
  }
  get reset() {
    return Ny("reset", "clear"), this.clear;
  }
  get length() {
    return KAA("length", "size"), this.size;
  }
  static get AbortController() {
    return nf;
  }
  static get AbortSignal() {
    return kT;
  }
}
var HAA = fg, kp = {}, ba = {}, PAA = W && W.__createBinding || (Object.create ? function(t, A, e, r) {
  r === void 0 && (r = e);
  var i = Object.getOwnPropertyDescriptor(A, e);
  (!i || ("get" in i ? !A.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
    return A[e];
  } }), Object.defineProperty(t, r, i);
} : function(t, A, e, r) {
  r === void 0 && (r = e), t[r] = A[e];
}), OAA = W && W.__setModuleDefault || (Object.create ? function(t, A) {
  Object.defineProperty(t, "default", { enumerable: !0, value: A });
} : function(t, A) {
  t.default = A;
}), bT = W && W.__importStar || function(t) {
  if (t && t.__esModule) return t;
  var A = {};
  if (t != null) for (var e in t) e !== "default" && Object.prototype.hasOwnProperty.call(t, e) && PAA(A, t, e);
  return OAA(A, t), A;
};
Object.defineProperty(ba, "__esModule", { value: !0 });
ba.req = ba.json = ba.toBuffer = void 0;
const YAA = bT(wn), qAA = bT(mn);
async function MT(t) {
  let A = 0;
  const e = [];
  for await (const r of t)
    A += r.length, e.push(r);
  return Buffer.concat(e, A);
}
ba.toBuffer = MT;
async function jAA(t) {
  const e = (await MT(t)).toString("utf8");
  try {
    return JSON.parse(e);
  } catch (r) {
    const i = r;
    throw i.message += ` (input: ${e})`, i;
  }
}
ba.json = jAA;
function WAA(t, A = {}) {
  const r = ((typeof t == "string" ? t : t.href).startsWith("https:") ? qAA : YAA).request(t, A), i = new Promise((n, s) => {
    r.once("response", n).once("error", s).end();
  });
  return r.then = i.then.bind(i), r;
}
ba.req = WAA;
(function(t) {
  var A = W && W.__createBinding || (Object.create ? function(u, I, c, C) {
    C === void 0 && (C = c);
    var E = Object.getOwnPropertyDescriptor(I, c);
    (!E || ("get" in E ? !I.__esModule : E.writable || E.configurable)) && (E = { enumerable: !0, get: function() {
      return I[c];
    } }), Object.defineProperty(u, C, E);
  } : function(u, I, c, C) {
    C === void 0 && (C = c), u[C] = I[c];
  }), e = W && W.__setModuleDefault || (Object.create ? function(u, I) {
    Object.defineProperty(u, "default", { enumerable: !0, value: I });
  } : function(u, I) {
    u.default = I;
  }), r = W && W.__importStar || function(u) {
    if (u && u.__esModule) return u;
    var I = {};
    if (u != null) for (var c in u) c !== "default" && Object.prototype.hasOwnProperty.call(u, c) && A(I, u, c);
    return e(I, u), I;
  }, i = W && W.__exportStar || function(u, I) {
    for (var c in u) c !== "default" && !Object.prototype.hasOwnProperty.call(I, c) && A(I, u, c);
  };
  Object.defineProperty(t, "__esModule", { value: !0 }), t.Agent = void 0;
  const n = r(yr), s = r(wn), a = mn;
  i(ba, t);
  const g = Symbol("AgentBaseInternalState");
  class o extends s.Agent {
    constructor(I) {
      super(I), this[g] = {};
    }
    /**
     * Determine whether this is an `http` or `https` request.
     */
    isSecureEndpoint(I) {
      if (I) {
        if (typeof I.secureEndpoint == "boolean")
          return I.secureEndpoint;
        if (typeof I.protocol == "string")
          return I.protocol === "https:";
      }
      const { stack: c } = new Error();
      return typeof c != "string" ? !1 : c.split(`
`).some((C) => C.indexOf("(https.js:") !== -1 || C.indexOf("node:https:") !== -1);
    }
    // In order to support async signatures in `connect()` and Node's native
    // connection pooling in `http.Agent`, the array of sockets for each origin
    // has to be updated synchronously. This is so the length of the array is
    // accurate when `addRequest()` is next called. We achieve this by creating a
    // fake socket and adding it to `sockets[origin]` and incrementing
    // `totalSocketCount`.
    incrementSockets(I) {
      if (this.maxSockets === 1 / 0 && this.maxTotalSockets === 1 / 0)
        return null;
      this.sockets[I] || (this.sockets[I] = []);
      const c = new n.Socket({ writable: !1 });
      return this.sockets[I].push(c), this.totalSocketCount++, c;
    }
    decrementSockets(I, c) {
      if (!this.sockets[I] || c === null)
        return;
      const C = this.sockets[I], E = C.indexOf(c);
      E !== -1 && (C.splice(E, 1), this.totalSocketCount--, C.length === 0 && delete this.sockets[I]);
    }
    // In order to properly update the socket pool, we need to call `getName()` on
    // the core `https.Agent` if it is a secureEndpoint.
    getName(I) {
      return this.isSecureEndpoint(I) ? a.Agent.prototype.getName.call(this, I) : super.getName(I);
    }
    createSocket(I, c, C) {
      const E = {
        ...c,
        secureEndpoint: this.isSecureEndpoint(c)
      }, l = this.getName(E), B = this.incrementSockets(l);
      Promise.resolve().then(() => this.connect(I, E)).then((h) => {
        if (this.decrementSockets(l, B), h instanceof s.Agent)
          try {
            return h.addRequest(I, E);
          } catch (Q) {
            return C(Q);
          }
        this[g].currentSocket = h, super.createSocket(I, c, C);
      }, (h) => {
        this.decrementSockets(l, B), C(h);
      });
    }
    createConnection() {
      const I = this[g].currentSocket;
      if (this[g].currentSocket = void 0, !I)
        throw new Error("No socket was returned in the `connect()` function");
      return I;
    }
    get defaultPort() {
      return this[g].defaultPort ?? (this.protocol === "https:" ? 443 : 80);
    }
    set defaultPort(I) {
      this[g] && (this[g].defaultPort = I);
    }
    get protocol() {
      return this[g].protocol ?? (this.isSecureEndpoint() ? "https:" : "http:");
    }
    set protocol(I) {
      this[g] && (this[g].protocol = I);
    }
  }
  t.Agent = o;
})(kp);
var xD = { exports: {} }, Mh = { exports: {} }, Ly, ER;
function VAA() {
  if (ER) return Ly;
  ER = 1;
  var t = 1e3, A = t * 60, e = A * 60, r = e * 24, i = r * 7, n = r * 365.25;
  Ly = function(u, I) {
    I = I || {};
    var c = typeof u;
    if (c === "string" && u.length > 0)
      return s(u);
    if (c === "number" && isFinite(u))
      return I.long ? g(u) : a(u);
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(u)
    );
  };
  function s(u) {
    if (u = String(u), !(u.length > 100)) {
      var I = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        u
      );
      if (I) {
        var c = parseFloat(I[1]), C = (I[2] || "ms").toLowerCase();
        switch (C) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return c * n;
          case "weeks":
          case "week":
          case "w":
            return c * i;
          case "days":
          case "day":
          case "d":
            return c * r;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return c * e;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return c * A;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return c * t;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return c;
          default:
            return;
        }
      }
    }
  }
  function a(u) {
    var I = Math.abs(u);
    return I >= r ? Math.round(u / r) + "d" : I >= e ? Math.round(u / e) + "h" : I >= A ? Math.round(u / A) + "m" : I >= t ? Math.round(u / t) + "s" : u + "ms";
  }
  function g(u) {
    var I = Math.abs(u);
    return I >= r ? o(u, I, r, "day") : I >= e ? o(u, I, e, "hour") : I >= A ? o(u, I, A, "minute") : I >= t ? o(u, I, t, "second") : u + " ms";
  }
  function o(u, I, c, C) {
    var E = I >= c * 1.5;
    return Math.round(u / c) + " " + C + (E ? "s" : "");
  }
  return Ly;
}
var xy, hR;
function _T() {
  if (hR) return xy;
  hR = 1;
  function t(A) {
    r.debug = r, r.default = r, r.coerce = o, r.disable = a, r.enable = n, r.enabled = g, r.humanize = VAA(), r.destroy = u, Object.keys(A).forEach((I) => {
      r[I] = A[I];
    }), r.names = [], r.skips = [], r.formatters = {};
    function e(I) {
      let c = 0;
      for (let C = 0; C < I.length; C++)
        c = (c << 5) - c + I.charCodeAt(C), c |= 0;
      return r.colors[Math.abs(c) % r.colors.length];
    }
    r.selectColor = e;
    function r(I) {
      let c, C = null, E, l;
      function B(...h) {
        if (!B.enabled)
          return;
        const Q = B, f = Number(/* @__PURE__ */ new Date()), p = f - (c || f);
        Q.diff = p, Q.prev = c, Q.curr = f, c = f, h[0] = r.coerce(h[0]), typeof h[0] != "string" && h.unshift("%O");
        let y = 0;
        h[0] = h[0].replace(/%([a-zA-Z%])/g, (S, w) => {
          if (S === "%%")
            return "%";
          y++;
          const F = r.formatters[w];
          if (typeof F == "function") {
            const b = h[y];
            S = F.call(Q, b), h.splice(y, 1), y--;
          }
          return S;
        }), r.formatArgs.call(Q, h), (Q.log || r.log).apply(Q, h);
      }
      return B.namespace = I, B.useColors = r.useColors(), B.color = r.selectColor(I), B.extend = i, B.destroy = r.destroy, Object.defineProperty(B, "enabled", {
        enumerable: !0,
        configurable: !1,
        get: () => C !== null ? C : (E !== r.namespaces && (E = r.namespaces, l = r.enabled(I)), l),
        set: (h) => {
          C = h;
        }
      }), typeof r.init == "function" && r.init(B), B;
    }
    function i(I, c) {
      const C = r(this.namespace + (typeof c > "u" ? ":" : c) + I);
      return C.log = this.log, C;
    }
    function n(I) {
      r.save(I), r.namespaces = I, r.names = [], r.skips = [];
      const c = (typeof I == "string" ? I : "").trim().replace(/\s+/g, ",").split(",").filter(Boolean);
      for (const C of c)
        C[0] === "-" ? r.skips.push(C.slice(1)) : r.names.push(C);
    }
    function s(I, c) {
      let C = 0, E = 0, l = -1, B = 0;
      for (; C < I.length; )
        if (E < c.length && (c[E] === I[C] || c[E] === "*"))
          c[E] === "*" ? (l = E, B = C, E++) : (C++, E++);
        else if (l !== -1)
          E = l + 1, B++, C = B;
        else
          return !1;
      for (; E < c.length && c[E] === "*"; )
        E++;
      return E === c.length;
    }
    function a() {
      const I = [
        ...r.names,
        ...r.skips.map((c) => "-" + c)
      ].join(",");
      return r.enable(""), I;
    }
    function g(I) {
      for (const c of r.skips)
        if (s(I, c))
          return !1;
      for (const c of r.names)
        if (s(I, c))
          return !0;
      return !1;
    }
    function o(I) {
      return I instanceof Error ? I.stack || I.message : I;
    }
    function u() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    return r.enable(r.load()), r;
  }
  return xy = t, xy;
}
var QR;
function ZAA() {
  return QR || (QR = 1, function(t, A) {
    A.formatArgs = r, A.save = i, A.load = n, A.useColors = e, A.storage = s(), A.destroy = /* @__PURE__ */ (() => {
      let g = !1;
      return () => {
        g || (g = !0, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
      };
    })(), A.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function e() {
      if (typeof window < "u" && window.process && (window.process.type === "renderer" || window.process.__nwjs))
        return !0;
      if (typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/))
        return !1;
      let g;
      return typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator < "u" && navigator.userAgent && (g = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(g[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function r(g) {
      if (g[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + g[0] + (this.useColors ? "%c " : " ") + "+" + t.exports.humanize(this.diff), !this.useColors)
        return;
      const o = "color: " + this.color;
      g.splice(1, 0, o, "color: inherit");
      let u = 0, I = 0;
      g[0].replace(/%[a-zA-Z%]/g, (c) => {
        c !== "%%" && (u++, c === "%c" && (I = u));
      }), g.splice(I, 0, o);
    }
    A.log = console.debug || console.log || (() => {
    });
    function i(g) {
      try {
        g ? A.storage.setItem("debug", g) : A.storage.removeItem("debug");
      } catch {
      }
    }
    function n() {
      let g;
      try {
        g = A.storage.getItem("debug") || A.storage.getItem("DEBUG");
      } catch {
      }
      return !g && typeof process < "u" && "env" in process && (g = process.env.DEBUG), g;
    }
    function s() {
      try {
        return localStorage;
      } catch {
      }
    }
    t.exports = _T()(A);
    const { formatters: a } = t.exports;
    a.j = function(g) {
      try {
        return JSON.stringify(g);
      } catch (o) {
        return "[UnexpectedJSONParseError]: " + o.message;
      }
    };
  }(Mh, Mh.exports)), Mh.exports;
}
var _h = { exports: {} }, Gy, dR;
function XAA() {
  return dR || (dR = 1, Gy = (t, A = process.argv) => {
    const e = t.startsWith("-") ? "" : t.length === 1 ? "-" : "--", r = A.indexOf(e + t), i = A.indexOf("--");
    return r !== -1 && (i === -1 || r < i);
  }), Gy;
}
var Uy, fR;
function zAA() {
  if (fR) return Uy;
  fR = 1;
  const t = ZD, A = v_, e = XAA(), { env: r } = process;
  let i;
  e("no-color") || e("no-colors") || e("color=false") || e("color=never") ? i = 0 : (e("color") || e("colors") || e("color=true") || e("color=always")) && (i = 1), "FORCE_COLOR" in r && (r.FORCE_COLOR === "true" ? i = 1 : r.FORCE_COLOR === "false" ? i = 0 : i = r.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(r.FORCE_COLOR, 10), 3));
  function n(g) {
    return g === 0 ? !1 : {
      level: g,
      hasBasic: !0,
      has256: g >= 2,
      has16m: g >= 3
    };
  }
  function s(g, o) {
    if (i === 0)
      return 0;
    if (e("color=16m") || e("color=full") || e("color=truecolor"))
      return 3;
    if (e("color=256"))
      return 2;
    if (g && !o && i === void 0)
      return 0;
    const u = i || 0;
    if (r.TERM === "dumb")
      return u;
    if (process.platform === "win32") {
      const I = t.release().split(".");
      return Number(I[0]) >= 10 && Number(I[2]) >= 10586 ? Number(I[2]) >= 14931 ? 3 : 2 : 1;
    }
    if ("CI" in r)
      return ["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((I) => I in r) || r.CI_NAME === "codeship" ? 1 : u;
    if ("TEAMCITY_VERSION" in r)
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(r.TEAMCITY_VERSION) ? 1 : 0;
    if (r.COLORTERM === "truecolor")
      return 3;
    if ("TERM_PROGRAM" in r) {
      const I = parseInt((r.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
      switch (r.TERM_PROGRAM) {
        case "iTerm.app":
          return I >= 3 ? 3 : 2;
        case "Apple_Terminal":
          return 2;
      }
    }
    return /-256(color)?$/i.test(r.TERM) ? 2 : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(r.TERM) || "COLORTERM" in r ? 1 : u;
  }
  function a(g) {
    const o = s(g, g && g.isTTY);
    return n(o);
  }
  return Uy = {
    supportsColor: a,
    stdout: n(s(!0, A.isatty(1))),
    stderr: n(s(!0, A.isatty(2)))
  }, Uy;
}
var pR;
function $AA() {
  return pR || (pR = 1, function(t, A) {
    const e = v_, r = bf;
    A.init = u, A.log = a, A.formatArgs = n, A.save = g, A.load = o, A.useColors = i, A.destroy = r.deprecate(
      () => {
      },
      "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
    ), A.colors = [6, 2, 3, 4, 5, 1];
    try {
      const c = zAA();
      c && (c.stderr || c).level >= 2 && (A.colors = [
        20,
        21,
        26,
        27,
        32,
        33,
        38,
        39,
        40,
        41,
        42,
        43,
        44,
        45,
        56,
        57,
        62,
        63,
        68,
        69,
        74,
        75,
        76,
        77,
        78,
        79,
        80,
        81,
        92,
        93,
        98,
        99,
        112,
        113,
        128,
        129,
        134,
        135,
        148,
        149,
        160,
        161,
        162,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        171,
        172,
        173,
        178,
        179,
        184,
        185,
        196,
        197,
        198,
        199,
        200,
        201,
        202,
        203,
        204,
        205,
        206,
        207,
        208,
        209,
        214,
        215,
        220,
        221
      ]);
    } catch {
    }
    A.inspectOpts = Object.keys(process.env).filter((c) => /^debug_/i.test(c)).reduce((c, C) => {
      const E = C.substring(6).toLowerCase().replace(/_([a-z])/g, (B, h) => h.toUpperCase());
      let l = process.env[C];
      return /^(yes|on|true|enabled)$/i.test(l) ? l = !0 : /^(no|off|false|disabled)$/i.test(l) ? l = !1 : l === "null" ? l = null : l = Number(l), c[E] = l, c;
    }, {});
    function i() {
      return "colors" in A.inspectOpts ? !!A.inspectOpts.colors : e.isatty(process.stderr.fd);
    }
    function n(c) {
      const { namespace: C, useColors: E } = this;
      if (E) {
        const l = this.color, B = "\x1B[3" + (l < 8 ? l : "8;5;" + l), h = `  ${B};1m${C} \x1B[0m`;
        c[0] = h + c[0].split(`
`).join(`
` + h), c.push(B + "m+" + t.exports.humanize(this.diff) + "\x1B[0m");
      } else
        c[0] = s() + C + " " + c[0];
    }
    function s() {
      return A.inspectOpts.hideDate ? "" : (/* @__PURE__ */ new Date()).toISOString() + " ";
    }
    function a(...c) {
      return process.stderr.write(r.formatWithOptions(A.inspectOpts, ...c) + `
`);
    }
    function g(c) {
      c ? process.env.DEBUG = c : delete process.env.DEBUG;
    }
    function o() {
      return process.env.DEBUG;
    }
    function u(c) {
      c.inspectOpts = {};
      const C = Object.keys(A.inspectOpts);
      for (let E = 0; E < C.length; E++)
        c.inspectOpts[C[E]] = A.inspectOpts[C[E]];
    }
    t.exports = _T()(A);
    const { formatters: I } = t.exports;
    I.o = function(c) {
      return this.inspectOpts.colors = this.useColors, r.inspect(c, this.inspectOpts).split(`
`).map((C) => C.trim()).join(" ");
    }, I.O = function(c) {
      return this.inspectOpts.colors = this.useColors, r.inspect(c, this.inspectOpts);
    };
  }(_h, _h.exports)), _h.exports;
}
typeof process > "u" || process.type === "renderer" || process.browser === !0 || process.__nwjs ? xD.exports = ZAA() : xD.exports = $AA();
var Ir = xD.exports;
const II = /* @__PURE__ */ sI(Ir), AeA = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: II
}, Symbol.toStringTag, { value: "Module" }));
var NT = {}, eeA = Dn.parse, teA = {
  ftp: 21,
  gopher: 70,
  http: 80,
  https: 443,
  ws: 80,
  wss: 443
}, reA = String.prototype.endsWith || function(t) {
  return t.length <= this.length && this.indexOf(t, this.length - t.length) !== -1;
};
function ieA(t) {
  var A = typeof t == "string" ? eeA(t) : t || {}, e = A.protocol, r = A.host, i = A.port;
  if (typeof r != "string" || !r || typeof e != "string" || (e = e.split(":", 1)[0], r = r.replace(/:\d*$/, ""), i = parseInt(i) || teA[e] || 0, !neA(r, i)))
    return "";
  var n = ru("npm_config_" + e + "_proxy") || ru(e + "_proxy") || ru("npm_config_proxy") || ru("all_proxy");
  return n && n.indexOf("://") === -1 && (n = e + "://" + n), n;
}
function neA(t, A) {
  var e = (ru("npm_config_no_proxy") || ru("no_proxy")).toLowerCase();
  return e ? e === "*" ? !1 : e.split(/[,\s]/).every(function(r) {
    if (!r)
      return !0;
    var i = r.match(/^(.+):(\d+)$/), n = i ? i[1] : r, s = i ? parseInt(i[2]) : 0;
    return s && s !== A ? !0 : /^[.*]/.test(n) ? (n.charAt(0) === "*" && (n = n.slice(1)), !reA.call(t, n)) : t !== n;
  }) : !0;
}
function ru(t) {
  return process.env[t.toLowerCase()] || process.env[t.toUpperCase()] || "";
}
NT.getProxyForUrl = ieA;
var DI = {}, yR;
function seA() {
  if (yR) return DI;
  yR = 1;
  var t = W && W.__createBinding || (Object.create ? function(C, E, l, B) {
    B === void 0 && (B = l);
    var h = Object.getOwnPropertyDescriptor(E, l);
    (!h || ("get" in h ? !E.__esModule : h.writable || h.configurable)) && (h = { enumerable: !0, get: function() {
      return E[l];
    } }), Object.defineProperty(C, B, h);
  } : function(C, E, l, B) {
    B === void 0 && (B = l), C[B] = E[l];
  }), A = W && W.__setModuleDefault || (Object.create ? function(C, E) {
    Object.defineProperty(C, "default", { enumerable: !0, value: E });
  } : function(C, E) {
    C.default = E;
  }), e = W && W.__importStar || function(C) {
    if (C && C.__esModule) return C;
    var E = {};
    if (C != null) for (var l in C) l !== "default" && Object.prototype.hasOwnProperty.call(C, l) && t(E, C, l);
    return A(E, C), E;
  }, r = W && W.__importDefault || function(C) {
    return C && C.__esModule ? C : { default: C };
  };
  Object.defineProperty(DI, "__esModule", { value: !0 }), DI.HttpProxyAgent = void 0;
  const i = e(yr), n = e(Sn), s = r(Ir), a = rI, g = kp, o = Dn, u = (0, s.default)("http-proxy-agent");
  class I extends g.Agent {
    constructor(E, l) {
      super(l), this.proxy = typeof E == "string" ? new o.URL(E) : E, this.proxyHeaders = (l == null ? void 0 : l.headers) ?? {}, u("Creating new HttpProxyAgent instance: %o", this.proxy.href);
      const B = (this.proxy.hostname || this.proxy.host).replace(/^\[|\]$/g, ""), h = this.proxy.port ? parseInt(this.proxy.port, 10) : this.proxy.protocol === "https:" ? 443 : 80;
      this.connectOpts = {
        ...l ? c(l, "headers") : null,
        host: B,
        port: h
      };
    }
    addRequest(E, l) {
      E._header = null, this.setRequestProps(E, l), super.addRequest(E, l);
    }
    setRequestProps(E, l) {
      const { proxy: B } = this, h = l.secureEndpoint ? "https:" : "http:", Q = E.getHeader("host") || "localhost", f = `${h}//${Q}`, p = new o.URL(E.path, f);
      l.port !== 80 && (p.port = String(l.port)), E.path = String(p);
      const y = typeof this.proxyHeaders == "function" ? this.proxyHeaders() : { ...this.proxyHeaders };
      if (B.username || B.password) {
        const m = `${decodeURIComponent(B.username)}:${decodeURIComponent(B.password)}`;
        y["Proxy-Authorization"] = `Basic ${Buffer.from(m).toString("base64")}`;
      }
      y["Proxy-Connection"] || (y["Proxy-Connection"] = this.keepAlive ? "Keep-Alive" : "close");
      for (const m of Object.keys(y)) {
        const S = y[m];
        S && E.setHeader(m, S);
      }
    }
    async connect(E, l) {
      E._header = null, E.path.includes("://") || this.setRequestProps(E, l);
      let B, h;
      u("Regenerating stored HTTP header string for request"), E._implicitHeader(), E.outputData && E.outputData.length > 0 && (u("Patching connection write() output buffer with updated header"), B = E.outputData[0].data, h = B.indexOf(`\r
\r
`) + 4, E.outputData[0].data = E._header + B.substring(h), u("Output buffer: %o", E.outputData[0].data));
      let Q;
      return this.proxy.protocol === "https:" ? (u("Creating `tls.Socket`: %o", this.connectOpts), Q = n.connect(this.connectOpts)) : (u("Creating `net.Socket`: %o", this.connectOpts), Q = i.connect(this.connectOpts)), await (0, a.once)(Q, "connect"), Q;
    }
  }
  I.protocols = ["http", "https"], DI.HttpProxyAgent = I;
  function c(C, ...E) {
    const l = {};
    let B;
    for (B in C)
      E.includes(B) || (l[B] = C[B]);
    return l;
  }
  return DI;
}
var SI = {}, FI = {}, wR;
function aeA() {
  if (wR) return FI;
  wR = 1;
  var t = W && W.__importDefault || function(i) {
    return i && i.__esModule ? i : { default: i };
  };
  Object.defineProperty(FI, "__esModule", { value: !0 }), FI.parseProxyResponse = void 0;
  const e = (0, t(Ir).default)("https-proxy-agent:parse-proxy-response");
  function r(i) {
    return new Promise((n, s) => {
      let a = 0;
      const g = [];
      function o() {
        const E = i.read();
        E ? C(E) : i.once("readable", o);
      }
      function u() {
        i.removeListener("end", I), i.removeListener("error", c), i.removeListener("readable", o);
      }
      function I() {
        u(), e("onend"), s(new Error("Proxy connection ended before receiving CONNECT response"));
      }
      function c(E) {
        u(), e("onerror %o", E), s(E);
      }
      function C(E) {
        g.push(E), a += E.length;
        const l = Buffer.concat(g, a), B = l.indexOf(`\r
\r
`);
        if (B === -1) {
          e("have not received end of HTTP headers yet..."), o();
          return;
        }
        const h = l.slice(0, B).toString("ascii").split(`\r
`), Q = h.shift();
        if (!Q)
          return i.destroy(), s(new Error("No header received from proxy CONNECT response"));
        const f = Q.split(" "), p = +f[1], y = f.slice(2).join(" "), m = {};
        for (const S of h) {
          if (!S)
            continue;
          const w = S.indexOf(":");
          if (w === -1)
            return i.destroy(), s(new Error(`Invalid header from proxy CONNECT response: "${S}"`));
          const F = S.slice(0, w).toLowerCase(), b = S.slice(w + 1).trimStart(), G = m[F];
          typeof G == "string" ? m[F] = [G, b] : Array.isArray(G) ? G.push(b) : m[F] = b;
        }
        e("got proxy server response: %o %o", Q, m), u(), n({
          connect: {
            statusCode: p,
            statusText: y,
            headers: m
          },
          buffered: l
        });
      }
      i.on("error", c), i.on("end", I), o();
    });
  }
  return FI.parseProxyResponse = r, FI;
}
var mR;
function oeA() {
  if (mR) return SI;
  mR = 1;
  var t = W && W.__createBinding || (Object.create ? function(B, h, Q, f) {
    f === void 0 && (f = Q);
    var p = Object.getOwnPropertyDescriptor(h, Q);
    (!p || ("get" in p ? !h.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {
      return h[Q];
    } }), Object.defineProperty(B, f, p);
  } : function(B, h, Q, f) {
    f === void 0 && (f = Q), B[f] = h[Q];
  }), A = W && W.__setModuleDefault || (Object.create ? function(B, h) {
    Object.defineProperty(B, "default", { enumerable: !0, value: h });
  } : function(B, h) {
    B.default = h;
  }), e = W && W.__importStar || function(B) {
    if (B && B.__esModule) return B;
    var h = {};
    if (B != null) for (var Q in B) Q !== "default" && Object.prototype.hasOwnProperty.call(B, Q) && t(h, B, Q);
    return A(h, B), h;
  }, r = W && W.__importDefault || function(B) {
    return B && B.__esModule ? B : { default: B };
  };
  Object.defineProperty(SI, "__esModule", { value: !0 }), SI.HttpsProxyAgent = void 0;
  const i = e(yr), n = e(Sn), s = r(R_), a = r(Ir), g = kp, o = Dn, u = aeA(), I = (0, a.default)("https-proxy-agent"), c = (B) => B.servername === void 0 && B.host && !i.isIP(B.host) ? {
    ...B,
    servername: B.host
  } : B;
  class C extends g.Agent {
    constructor(h, Q) {
      super(Q), this.options = { path: void 0 }, this.proxy = typeof h == "string" ? new o.URL(h) : h, this.proxyHeaders = (Q == null ? void 0 : Q.headers) ?? {}, I("Creating new HttpsProxyAgent instance: %o", this.proxy.href);
      const f = (this.proxy.hostname || this.proxy.host).replace(/^\[|\]$/g, ""), p = this.proxy.port ? parseInt(this.proxy.port, 10) : this.proxy.protocol === "https:" ? 443 : 80;
      this.connectOpts = {
        // Attempt to negotiate http/1.1 for proxy servers that support http/2
        ALPNProtocols: ["http/1.1"],
        ...Q ? l(Q, "headers") : null,
        host: f,
        port: p
      };
    }
    /**
     * Called when the node-core HTTP client library is creating a
     * new HTTP request.
     */
    async connect(h, Q) {
      const { proxy: f } = this;
      if (!Q.host)
        throw new TypeError('No "host" provided');
      let p;
      f.protocol === "https:" ? (I("Creating `tls.Socket`: %o", this.connectOpts), p = n.connect(c(this.connectOpts))) : (I("Creating `net.Socket`: %o", this.connectOpts), p = i.connect(this.connectOpts));
      const y = typeof this.proxyHeaders == "function" ? this.proxyHeaders() : { ...this.proxyHeaders }, m = i.isIPv6(Q.host) ? `[${Q.host}]` : Q.host;
      let S = `CONNECT ${m}:${Q.port} HTTP/1.1\r
`;
      if (f.username || f.password) {
        const T = `${decodeURIComponent(f.username)}:${decodeURIComponent(f.password)}`;
        y["Proxy-Authorization"] = `Basic ${Buffer.from(T).toString("base64")}`;
      }
      y.Host = `${m}:${Q.port}`, y["Proxy-Connection"] || (y["Proxy-Connection"] = this.keepAlive ? "Keep-Alive" : "close");
      for (const T of Object.keys(y))
        S += `${T}: ${y[T]}\r
`;
      const w = (0, u.parseProxyResponse)(p);
      p.write(`${S}\r
`);
      const { connect: F, buffered: b } = await w;
      if (h.emit("proxyConnect", F), this.emit("proxyConnect", F, h), F.statusCode === 200)
        return h.once("socket", E), Q.secureEndpoint ? (I("Upgrading socket connection to TLS"), n.connect({
          ...l(c(Q), "host", "path", "port"),
          socket: p
        })) : p;
      p.destroy();
      const G = new i.Socket({ writable: !1 });
      return G.readable = !0, h.once("socket", (T) => {
        I("Replaying proxy buffer for failed request"), (0, s.default)(T.listenerCount("data") > 0), T.push(b), T.push(null);
      }), G;
    }
  }
  C.protocols = ["http", "https"], SI.HttpsProxyAgent = C;
  function E(B) {
    B.resume();
  }
  function l(B, ...h) {
    const Q = {};
    let f;
    for (f in B)
      h.includes(f) || (Q[f] = B[f]);
    return Q;
  }
  return SI;
}
var kI = {}, Ty = {}, Ky = {}, Nh = {}, Ji = {}, DR;
function geA() {
  if (DR) return Ji;
  DR = 1, Object.defineProperty(Ji, "__esModule", { value: !0 });
  const t = b_, A = {
    INVALID_ENCODING: "Invalid encoding provided. Please specify a valid encoding the internal Node.js Buffer supports.",
    INVALID_SMARTBUFFER_SIZE: "Invalid size provided. Size must be a valid integer greater than zero.",
    INVALID_SMARTBUFFER_BUFFER: "Invalid Buffer provided in SmartBufferOptions.",
    INVALID_SMARTBUFFER_OBJECT: "Invalid SmartBufferOptions object supplied to SmartBuffer constructor or factory methods.",
    INVALID_OFFSET: "An invalid offset value was provided.",
    INVALID_OFFSET_NON_NUMBER: "An invalid offset value was provided. A numeric value is required.",
    INVALID_LENGTH: "An invalid length value was provided.",
    INVALID_LENGTH_NON_NUMBER: "An invalid length value was provived. A numeric value is required.",
    INVALID_TARGET_OFFSET: "Target offset is beyond the bounds of the internal SmartBuffer data.",
    INVALID_TARGET_LENGTH: "Specified length value moves cursor beyong the bounds of the internal SmartBuffer data.",
    INVALID_READ_BEYOND_BOUNDS: "Attempted to read beyond the bounds of the managed data.",
    INVALID_WRITE_BEYOND_BOUNDS: "Attempted to write beyond the bounds of the managed data."
  };
  Ji.ERRORS = A;
  function e(u) {
    if (!t.Buffer.isEncoding(u))
      throw new Error(A.INVALID_ENCODING);
  }
  Ji.checkEncoding = e;
  function r(u) {
    return typeof u == "number" && isFinite(u) && g(u);
  }
  Ji.isFiniteInteger = r;
  function i(u, I) {
    if (typeof u == "number") {
      if (!r(u) || u < 0)
        throw new Error(I ? A.INVALID_OFFSET : A.INVALID_LENGTH);
    } else
      throw new Error(I ? A.INVALID_OFFSET_NON_NUMBER : A.INVALID_LENGTH_NON_NUMBER);
  }
  function n(u) {
    i(u, !1);
  }
  Ji.checkLengthValue = n;
  function s(u) {
    i(u, !0);
  }
  Ji.checkOffsetValue = s;
  function a(u, I) {
    if (u < 0 || u > I.length)
      throw new Error(A.INVALID_TARGET_OFFSET);
  }
  Ji.checkTargetOffset = a;
  function g(u) {
    return typeof u == "number" && isFinite(u) && Math.floor(u) === u;
  }
  function o(u) {
    if (typeof BigInt > "u")
      throw new Error("Platform does not support JS BigInt type.");
    if (typeof t.Buffer.prototype[u] > "u")
      throw new Error(`Platform does not support Buffer.prototype.${u}.`);
  }
  return Ji.bigIntAndBufferInt64Check = o, Ji;
}
var SR;
function ueA() {
  if (SR) return Nh;
  SR = 1, Object.defineProperty(Nh, "__esModule", { value: !0 });
  const t = geA(), A = 4096, e = "utf8";
  class r {
    /**
     * Creates a new SmartBuffer instance.
     *
     * @param options { SmartBufferOptions } The SmartBufferOptions to apply to this instance.
     */
    constructor(n) {
      if (this.length = 0, this._encoding = e, this._writeOffset = 0, this._readOffset = 0, r.isSmartBufferOptions(n))
        if (n.encoding && (t.checkEncoding(n.encoding), this._encoding = n.encoding), n.size)
          if (t.isFiniteInteger(n.size) && n.size > 0)
            this._buff = Buffer.allocUnsafe(n.size);
          else
            throw new Error(t.ERRORS.INVALID_SMARTBUFFER_SIZE);
        else if (n.buff)
          if (Buffer.isBuffer(n.buff))
            this._buff = n.buff, this.length = n.buff.length;
          else
            throw new Error(t.ERRORS.INVALID_SMARTBUFFER_BUFFER);
        else
          this._buff = Buffer.allocUnsafe(A);
      else {
        if (typeof n < "u")
          throw new Error(t.ERRORS.INVALID_SMARTBUFFER_OBJECT);
        this._buff = Buffer.allocUnsafe(A);
      }
    }
    /**
     * Creates a new SmartBuffer instance with the provided internal Buffer size and optional encoding.
     *
     * @param size { Number } The size of the internal Buffer.
     * @param encoding { String } The BufferEncoding to use for strings.
     *
     * @return { SmartBuffer }
     */
    static fromSize(n, s) {
      return new this({
        size: n,
        encoding: s
      });
    }
    /**
     * Creates a new SmartBuffer instance with the provided Buffer and optional encoding.
     *
     * @param buffer { Buffer } The Buffer to use as the internal Buffer value.
     * @param encoding { String } The BufferEncoding to use for strings.
     *
     * @return { SmartBuffer }
     */
    static fromBuffer(n, s) {
      return new this({
        buff: n,
        encoding: s
      });
    }
    /**
     * Creates a new SmartBuffer instance with the provided SmartBufferOptions options.
     *
     * @param options { SmartBufferOptions } The options to use when creating the SmartBuffer instance.
     */
    static fromOptions(n) {
      return new this(n);
    }
    /**
     * Type checking function that determines if an object is a SmartBufferOptions object.
     */
    static isSmartBufferOptions(n) {
      const s = n;
      return s && (s.encoding !== void 0 || s.size !== void 0 || s.buff !== void 0);
    }
    // Signed integers
    /**
     * Reads an Int8 value from the current read position or an optionally provided offset.
     *
     * @param offset { Number } The offset to read data from (optional)
     * @return { Number }
     */
    readInt8(n) {
      return this._readNumberValue(Buffer.prototype.readInt8, 1, n);
    }
    /**
     * Reads an Int16BE value from the current read position or an optionally provided offset.
     *
     * @param offset { Number } The offset to read data from (optional)
     * @return { Number }
     */
    readInt16BE(n) {
      return this._readNumberValue(Buffer.prototype.readInt16BE, 2, n);
    }
    /**
     * Reads an Int16LE value from the current read position or an optionally provided offset.
     *
     * @param offset { Number } The offset to read data from (optional)
     * @return { Number }
     */
    readInt16LE(n) {
      return this._readNumberValue(Buffer.prototype.readInt16LE, 2, n);
    }
    /**
     * Reads an Int32BE value from the current read position or an optionally provided offset.
     *
     * @param offset { Number } The offset to read data from (optional)
     * @return { Number }
     */
    readInt32BE(n) {
      return this._readNumberValue(Buffer.prototype.readInt32BE, 4, n);
    }
    /**
     * Reads an Int32LE value from the current read position or an optionally provided offset.
     *
     * @param offset { Number } The offset to read data from (optional)
     * @return { Number }
     */
    readInt32LE(n) {
      return this._readNumberValue(Buffer.prototype.readInt32LE, 4, n);
    }
    /**
     * Reads a BigInt64BE value from the current read position or an optionally provided offset.
     *
     * @param offset { Number } The offset to read data from (optional)
     * @return { BigInt }
     */
    readBigInt64BE(n) {
      return t.bigIntAndBufferInt64Check("readBigInt64BE"), this._readNumberValue(Buffer.prototype.readBigInt64BE, 8, n);
    }
    /**
     * Reads a BigInt64LE value from the current read position or an optionally provided offset.
     *
     * @param offset { Number } The offset to read data from (optional)
     * @return { BigInt }
     */
    readBigInt64LE(n) {
      return t.bigIntAndBufferInt64Check("readBigInt64LE"), this._readNumberValue(Buffer.prototype.readBigInt64LE, 8, n);
    }
    /**
     * Writes an Int8 value to the current write position (or at optional offset).
     *
     * @param value { Number } The value to write.
     * @param offset { Number } The offset to write the value at.
     *
     * @return this
     */
    writeInt8(n, s) {
      return this._writeNumberValue(Buffer.prototype.writeInt8, 1, n, s), this;
    }
    /**
     * Inserts an Int8 value at the given offset value.
     *
     * @param value { Number } The value to insert.
     * @param offset { Number } The offset to insert the value at.
     *
     * @return this
     */
    insertInt8(n, s) {
      return this._insertNumberValue(Buffer.prototype.writeInt8, 1, n, s);
    }
    /**
     * Writes an Int16BE value to the current write position (or at optional offset).
     *
     * @param value { Number } The value to write.
     * @param offset { Number } The offset to write the value at.
     *
     * @return this
     */
    writeInt16BE(n, s) {
      return this._writeNumberValue(Buffer.prototype.writeInt16BE, 2, n, s);
    }
    /**
     * Inserts an Int16BE value at the given offset value.
     *
     * @param value { Number } The value to insert.
     * @param offset { Number } The offset to insert the value at.
     *
     * @return this
     */
    insertInt16BE(n, s) {
      return this._insertNumberValue(Buffer.prototype.writeInt16BE, 2, n, s);
    }
    /**
     * Writes an Int16LE value to the current write position (or at optional offset).
     *
     * @param value { Number } The value to write.
     * @param offset { Number } The offset to write the value at.
     *
     * @return this
     */
    writeInt16LE(n, s) {
      return this._writeNumberValue(Buffer.prototype.writeInt16LE, 2, n, s);
    }
    /**
     * Inserts an Int16LE value at the given offset value.
     *
     * @param value { Number } The value to insert.
     * @param offset { Number } The offset to insert the value at.
     *
     * @return this
     */
    insertInt16LE(n, s) {
      return this._insertNumberValue(Buffer.prototype.writeInt16LE, 2, n, s);
    }
    /**
     * Writes an Int32BE value to the current write position (or at optional offset).
     *
     * @param value { Number } The value to write.
     * @param offset { Number } The offset to write the value at.
     *
     * @return this
     */
    writeInt32BE(n, s) {
      return this._writeNumberValue(Buffer.prototype.writeInt32BE, 4, n, s);
    }
    /**
     * Inserts an Int32BE value at the given offset value.
     *
     * @param value { Number } The value to insert.
     * @param offset { Number } The offset to insert the value at.
     *
     * @return this
     */
    insertInt32BE(n, s) {
      return this._insertNumberValue(Buffer.prototype.writeInt32BE, 4, n, s);
    }
    /**
     * Writes an Int32LE value to the current write position (or at optional offset).
     *
     * @param value { Number } The value to write.
     * @param offset { Number } The offset to write the value at.
     *
     * @return this
     */
    writeInt32LE(n, s) {
      return this._writeNumberValue(Buffer.prototype.writeInt32LE, 4, n, s);
    }
    /**
     * Inserts an Int32LE value at the given offset value.
     *
     * @param value { Number } The value to insert.
     * @param offset { Number } The offset to insert the value at.
     *
     * @return this
     */
    insertInt32LE(n, s) {
      return this._insertNumberValue(Buffer.prototype.writeInt32LE, 4, n, s);
    }
    /**
     * Writes a BigInt64BE value to the current write position (or at optional offset).
     *
     * @param value { BigInt } The value to write.
     * @param offset { Number } The offset to write the value at.
     *
     * @return this
     */
    writeBigInt64BE(n, s) {
      return t.bigIntAndBufferInt64Check("writeBigInt64BE"), this._writeNumberValue(Buffer.prototype.writeBigInt64BE, 8, n, s);
    }
    /**
     * Inserts a BigInt64BE value at the given offset value.
     *
     * @param value { BigInt } The value to insert.
     * @param offset { Number } The offset to insert the value at.
     *
     * @return this
     */
    insertBigInt64BE(n, s) {
      return t.bigIntAndBufferInt64Check("writeBigInt64BE"), this._insertNumberValue(Buffer.prototype.writeBigInt64BE, 8, n, s);
    }
    /**
     * Writes a BigInt64LE value to the current write position (or at optional offset).
     *
     * @param value { BigInt } The value to write.
     * @param offset { Number } The offset to write the value at.
     *
     * @return this
     */
    writeBigInt64LE(n, s) {
      return t.bigIntAndBufferInt64Check("writeBigInt64LE"), this._writeNumberValue(Buffer.prototype.writeBigInt64LE, 8, n, s);
    }
    /**
     * Inserts a Int64LE value at the given offset value.
     *
     * @param value { BigInt } The value to insert.
     * @param offset { Number } The offset to insert the value at.
     *
     * @return this
     */
    insertBigInt64LE(n, s) {
      return t.bigIntAndBufferInt64Check("writeBigInt64LE"), this._insertNumberValue(Buffer.prototype.writeBigInt64LE, 8, n, s);
    }
    // Unsigned Integers
    /**
     * Reads an UInt8 value from the current read position or an optionally provided offset.
     *
     * @param offset { Number } The offset to read data from (optional)
     * @return { Number }
     */
    readUInt8(n) {
      return this._readNumberValue(Buffer.prototype.readUInt8, 1, n);
    }
    /**
     * Reads an UInt16BE value from the current read position or an optionally provided offset.
     *
     * @param offset { Number } The offset to read data from (optional)
     * @return { Number }
     */
    readUInt16BE(n) {
      return this._readNumberValue(Buffer.prototype.readUInt16BE, 2, n);
    }
    /**
     * Reads an UInt16LE value from the current read position or an optionally provided offset.
     *
     * @param offset { Number } The offset to read data from (optional)
     * @return { Number }
     */
    readUInt16LE(n) {
      return this._readNumberValue(Buffer.prototype.readUInt16LE, 2, n);
    }
    /**
     * Reads an UInt32BE value from the current read position or an optionally provided offset.
     *
     * @param offset { Number } The offset to read data from (optional)
     * @return { Number }
     */
    readUInt32BE(n) {
      return this._readNumberValue(Buffer.prototype.readUInt32BE, 4, n);
    }
    /**
     * Reads an UInt32LE value from the current read position or an optionally provided offset.
     *
     * @param offset { Number } The offset to read data from (optional)
     * @return { Number }
     */
    readUInt32LE(n) {
      return this._readNumberValue(Buffer.prototype.readUInt32LE, 4, n);
    }
    /**
     * Reads a BigUInt64BE value from the current read position or an optionally provided offset.
     *
     * @param offset { Number } The offset to read data from (optional)
     * @return { BigInt }
     */
    readBigUInt64BE(n) {
      return t.bigIntAndBufferInt64Check("readBigUInt64BE"), this._readNumberValue(Buffer.prototype.readBigUInt64BE, 8, n);
    }
    /**
     * Reads a BigUInt64LE value from the current read position or an optionally provided offset.
     *
     * @param offset { Number } The offset to read data from (optional)
     * @return { BigInt }
     */
    readBigUInt64LE(n) {
      return t.bigIntAndBufferInt64Check("readBigUInt64LE"), this._readNumberValue(Buffer.prototype.readBigUInt64LE, 8, n);
    }
    /**
     * Writes an UInt8 value to the current write position (or at optional offset).
     *
     * @param value { Number } The value to write.
     * @param offset { Number } The offset to write the value at.
     *
     * @return this
     */
    writeUInt8(n, s) {
      return this._writeNumberValue(Buffer.prototype.writeUInt8, 1, n, s);
    }
    /**
     * Inserts an UInt8 value at the given offset value.
     *
     * @param value { Number } The value to insert.
     * @param offset { Number } The offset to insert the value at.
     *
     * @return this
     */
    insertUInt8(n, s) {
      return this._insertNumberValue(Buffer.prototype.writeUInt8, 1, n, s);
    }
    /**
     * Writes an UInt16BE value to the current write position (or at optional offset).
     *
     * @param value { Number } The value to write.
     * @param offset { Number } The offset to write the value at.
     *
     * @return this
     */
    writeUInt16BE(n, s) {
      return this._writeNumberValue(Buffer.prototype.writeUInt16BE, 2, n, s);
    }
    /**
     * Inserts an UInt16BE value at the given offset value.
     *
     * @param value { Number } The value to insert.
     * @param offset { Number } The offset to insert the value at.
     *
     * @return this
     */
    insertUInt16BE(n, s) {
      return this._insertNumberValue(Buffer.prototype.writeUInt16BE, 2, n, s);
    }
    /**
     * Writes an UInt16LE value to the current write position (or at optional offset).
     *
     * @param value { Number } The value to write.
     * @param offset { Number } The offset to write the value at.
     *
     * @return this
     */
    writeUInt16LE(n, s) {
      return this._writeNumberValue(Buffer.prototype.writeUInt16LE, 2, n, s);
    }
    /**
     * Inserts an UInt16LE value at the given offset value.
     *
     * @param value { Number } The value to insert.
     * @param offset { Number } The offset to insert the value at.
     *
     * @return this
     */
    insertUInt16LE(n, s) {
      return this._insertNumberValue(Buffer.prototype.writeUInt16LE, 2, n, s);
    }
    /**
     * Writes an UInt32BE value to the current write position (or at optional offset).
     *
     * @param value { Number } The value to write.
     * @param offset { Number } The offset to write the value at.
     *
     * @return this
     */
    writeUInt32BE(n, s) {
      return this._writeNumberValue(Buffer.prototype.writeUInt32BE, 4, n, s);
    }
    /**
     * Inserts an UInt32BE value at the given offset value.
     *
     * @param value { Number } The value to insert.
     * @param offset { Number } The offset to insert the value at.
     *
     * @return this
     */
    insertUInt32BE(n, s) {
      return this._insertNumberValue(Buffer.prototype.writeUInt32BE, 4, n, s);
    }
    /**
     * Writes an UInt32LE value to the current write position (or at optional offset).
     *
     * @param value { Number } The value to write.
     * @param offset { Number } The offset to write the value at.
     *
     * @return this
     */
    writeUInt32LE(n, s) {
      return this._writeNumberValue(Buffer.prototype.writeUInt32LE, 4, n, s);
    }
    /**
     * Inserts an UInt32LE value at the given offset value.
     *
     * @param value { Number } The value to insert.
     * @param offset { Number } The offset to insert the value at.
     *
     * @return this
     */
    insertUInt32LE(n, s) {
      return this._insertNumberValue(Buffer.prototype.writeUInt32LE, 4, n, s);
    }
    /**
     * Writes a BigUInt64BE value to the current write position (or at optional offset).
     *
     * @param value { Number } The value to write.
     * @param offset { Number } The offset to write the value at.
     *
     * @return this
     */
    writeBigUInt64BE(n, s) {
      return t.bigIntAndBufferInt64Check("writeBigUInt64BE"), this._writeNumberValue(Buffer.prototype.writeBigUInt64BE, 8, n, s);
    }
    /**
     * Inserts a BigUInt64BE value at the given offset value.
     *
     * @param value { Number } The value to insert.
     * @param offset { Number } The offset to insert the value at.
     *
     * @return this
     */
    insertBigUInt64BE(n, s) {
      return t.bigIntAndBufferInt64Check("writeBigUInt64BE"), this._insertNumberValue(Buffer.prototype.writeBigUInt64BE, 8, n, s);
    }
    /**
     * Writes a BigUInt64LE value to the current write position (or at optional offset).
     *
     * @param value { Number } The value to write.
     * @param offset { Number } The offset to write the value at.
     *
     * @return this
     */
    writeBigUInt64LE(n, s) {
      return t.bigIntAndBufferInt64Check("writeBigUInt64LE"), this._writeNumberValue(Buffer.prototype.writeBigUInt64LE, 8, n, s);
    }
    /**
     * Inserts a BigUInt64LE value at the given offset value.
     *
     * @param value { Number } The value to insert.
     * @param offset { Number } The offset to insert the value at.
     *
     * @return this
     */
    insertBigUInt64LE(n, s) {
      return t.bigIntAndBufferInt64Check("writeBigUInt64LE"), this._insertNumberValue(Buffer.prototype.writeBigUInt64LE, 8, n, s);
    }
    // Floating Point
    /**
     * Reads an FloatBE value from the current read position or an optionally provided offset.
     *
     * @param offset { Number } The offset to read data from (optional)
     * @return { Number }
     */
    readFloatBE(n) {
      return this._readNumberValue(Buffer.prototype.readFloatBE, 4, n);
    }
    /**
     * Reads an FloatLE value from the current read position or an optionally provided offset.
     *
     * @param offset { Number } The offset to read data from (optional)
     * @return { Number }
     */
    readFloatLE(n) {
      return this._readNumberValue(Buffer.prototype.readFloatLE, 4, n);
    }
    /**
     * Writes a FloatBE value to the current write position (or at optional offset).
     *
     * @param value { Number } The value to write.
     * @param offset { Number } The offset to write the value at.
     *
     * @return this
     */
    writeFloatBE(n, s) {
      return this._writeNumberValue(Buffer.prototype.writeFloatBE, 4, n, s);
    }
    /**
     * Inserts a FloatBE value at the given offset value.
     *
     * @param value { Number } The value to insert.
     * @param offset { Number } The offset to insert the value at.
     *
     * @return this
     */
    insertFloatBE(n, s) {
      return this._insertNumberValue(Buffer.prototype.writeFloatBE, 4, n, s);
    }
    /**
     * Writes a FloatLE value to the current write position (or at optional offset).
     *
     * @param value { Number } The value to write.
     * @param offset { Number } The offset to write the value at.
     *
     * @return this
     */
    writeFloatLE(n, s) {
      return this._writeNumberValue(Buffer.prototype.writeFloatLE, 4, n, s);
    }
    /**
     * Inserts a FloatLE value at the given offset value.
     *
     * @param value { Number } The value to insert.
     * @param offset { Number } The offset to insert the value at.
     *
     * @return this
     */
    insertFloatLE(n, s) {
      return this._insertNumberValue(Buffer.prototype.writeFloatLE, 4, n, s);
    }
    // Double Floating Point
    /**
     * Reads an DoublEBE value from the current read position or an optionally provided offset.
     *
     * @param offset { Number } The offset to read data from (optional)
     * @return { Number }
     */
    readDoubleBE(n) {
      return this._readNumberValue(Buffer.prototype.readDoubleBE, 8, n);
    }
    /**
     * Reads an DoubleLE value from the current read position or an optionally provided offset.
     *
     * @param offset { Number } The offset to read data from (optional)
     * @return { Number }
     */
    readDoubleLE(n) {
      return this._readNumberValue(Buffer.prototype.readDoubleLE, 8, n);
    }
    /**
     * Writes a DoubleBE value to the current write position (or at optional offset).
     *
     * @param value { Number } The value to write.
     * @param offset { Number } The offset to write the value at.
     *
     * @return this
     */
    writeDoubleBE(n, s) {
      return this._writeNumberValue(Buffer.prototype.writeDoubleBE, 8, n, s);
    }
    /**
     * Inserts a DoubleBE value at the given offset value.
     *
     * @param value { Number } The value to insert.
     * @param offset { Number } The offset to insert the value at.
     *
     * @return this
     */
    insertDoubleBE(n, s) {
      return this._insertNumberValue(Buffer.prototype.writeDoubleBE, 8, n, s);
    }
    /**
     * Writes a DoubleLE value to the current write position (or at optional offset).
     *
     * @param value { Number } The value to write.
     * @param offset { Number } The offset to write the value at.
     *
     * @return this
     */
    writeDoubleLE(n, s) {
      return this._writeNumberValue(Buffer.prototype.writeDoubleLE, 8, n, s);
    }
    /**
     * Inserts a DoubleLE value at the given offset value.
     *
     * @param value { Number } The value to insert.
     * @param offset { Number } The offset to insert the value at.
     *
     * @return this
     */
    insertDoubleLE(n, s) {
      return this._insertNumberValue(Buffer.prototype.writeDoubleLE, 8, n, s);
    }
    // Strings
    /**
     * Reads a String from the current read position.
     *
     * @param arg1 { Number | String } The number of bytes to read as a String, or the BufferEncoding to use for
     *             the string (Defaults to instance level encoding).
     * @param encoding { String } The BufferEncoding to use for the string (Defaults to instance level encoding).
     *
     * @return { String }
     */
    readString(n, s) {
      let a;
      typeof n == "number" ? (t.checkLengthValue(n), a = Math.min(n, this.length - this._readOffset)) : (s = n, a = this.length - this._readOffset), typeof s < "u" && t.checkEncoding(s);
      const g = this._buff.slice(this._readOffset, this._readOffset + a).toString(s || this._encoding);
      return this._readOffset += a, g;
    }
    /**
     * Inserts a String
     *
     * @param value { String } The String value to insert.
     * @param offset { Number } The offset to insert the string at.
     * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).
     *
     * @return this
     */
    insertString(n, s, a) {
      return t.checkOffsetValue(s), this._handleString(n, !0, s, a);
    }
    /**
     * Writes a String
     *
     * @param value { String } The String value to write.
     * @param arg2 { Number | String } The offset to write the string at, or the BufferEncoding to use.
     * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).
     *
     * @return this
     */
    writeString(n, s, a) {
      return this._handleString(n, !1, s, a);
    }
    /**
     * Reads a null-terminated String from the current read position.
     *
     * @param encoding { String } The BufferEncoding to use for the string (Defaults to instance level encoding).
     *
     * @return { String }
     */
    readStringNT(n) {
      typeof n < "u" && t.checkEncoding(n);
      let s = this.length;
      for (let g = this._readOffset; g < this.length; g++)
        if (this._buff[g] === 0) {
          s = g;
          break;
        }
      const a = this._buff.slice(this._readOffset, s);
      return this._readOffset = s + 1, a.toString(n || this._encoding);
    }
    /**
     * Inserts a null-terminated String.
     *
     * @param value { String } The String value to write.
     * @param arg2 { Number | String } The offset to write the string to, or the BufferEncoding to use.
     * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).
     *
     * @return this
     */
    insertStringNT(n, s, a) {
      return t.checkOffsetValue(s), this.insertString(n, s, a), this.insertUInt8(0, s + n.length), this;
    }
    /**
     * Writes a null-terminated String.
     *
     * @param value { String } The String value to write.
     * @param arg2 { Number | String } The offset to write the string to, or the BufferEncoding to use.
     * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).
     *
     * @return this
     */
    writeStringNT(n, s, a) {
      return this.writeString(n, s, a), this.writeUInt8(0, typeof s == "number" ? s + n.length : this.writeOffset), this;
    }
    // Buffers
    /**
     * Reads a Buffer from the internal read position.
     *
     * @param length { Number } The length of data to read as a Buffer.
     *
     * @return { Buffer }
     */
    readBuffer(n) {
      typeof n < "u" && t.checkLengthValue(n);
      const s = typeof n == "number" ? n : this.length, a = Math.min(this.length, this._readOffset + s), g = this._buff.slice(this._readOffset, a);
      return this._readOffset = a, g;
    }
    /**
     * Writes a Buffer to the current write position.
     *
     * @param value { Buffer } The Buffer to write.
     * @param offset { Number } The offset to write the Buffer to.
     *
     * @return this
     */
    insertBuffer(n, s) {
      return t.checkOffsetValue(s), this._handleBuffer(n, !0, s);
    }
    /**
     * Writes a Buffer to the current write position.
     *
     * @param value { Buffer } The Buffer to write.
     * @param offset { Number } The offset to write the Buffer to.
     *
     * @return this
     */
    writeBuffer(n, s) {
      return this._handleBuffer(n, !1, s);
    }
    /**
     * Reads a null-terminated Buffer from the current read poisiton.
     *
     * @return { Buffer }
     */
    readBufferNT() {
      let n = this.length;
      for (let a = this._readOffset; a < this.length; a++)
        if (this._buff[a] === 0) {
          n = a;
          break;
        }
      const s = this._buff.slice(this._readOffset, n);
      return this._readOffset = n + 1, s;
    }
    /**
     * Inserts a null-terminated Buffer.
     *
     * @param value { Buffer } The Buffer to write.
     * @param offset { Number } The offset to write the Buffer to.
     *
     * @return this
     */
    insertBufferNT(n, s) {
      return t.checkOffsetValue(s), this.insertBuffer(n, s), this.insertUInt8(0, s + n.length), this;
    }
    /**
     * Writes a null-terminated Buffer.
     *
     * @param value { Buffer } The Buffer to write.
     * @param offset { Number } The offset to write the Buffer to.
     *
     * @return this
     */
    writeBufferNT(n, s) {
      return typeof s < "u" && t.checkOffsetValue(s), this.writeBuffer(n, s), this.writeUInt8(0, typeof s == "number" ? s + n.length : this._writeOffset), this;
    }
    /**
     * Clears the SmartBuffer instance to its original empty state.
     */
    clear() {
      return this._writeOffset = 0, this._readOffset = 0, this.length = 0, this;
    }
    /**
     * Gets the remaining data left to be read from the SmartBuffer instance.
     *
     * @return { Number }
     */
    remaining() {
      return this.length - this._readOffset;
    }
    /**
     * Gets the current read offset value of the SmartBuffer instance.
     *
     * @return { Number }
     */
    get readOffset() {
      return this._readOffset;
    }
    /**
     * Sets the read offset value of the SmartBuffer instance.
     *
     * @param offset { Number } - The offset value to set.
     */
    set readOffset(n) {
      t.checkOffsetValue(n), t.checkTargetOffset(n, this), this._readOffset = n;
    }
    /**
     * Gets the current write offset value of the SmartBuffer instance.
     *
     * @return { Number }
     */
    get writeOffset() {
      return this._writeOffset;
    }
    /**
     * Sets the write offset value of the SmartBuffer instance.
     *
     * @param offset { Number } - The offset value to set.
     */
    set writeOffset(n) {
      t.checkOffsetValue(n), t.checkTargetOffset(n, this), this._writeOffset = n;
    }
    /**
     * Gets the currently set string encoding of the SmartBuffer instance.
     *
     * @return { BufferEncoding } The string Buffer encoding currently set.
     */
    get encoding() {
      return this._encoding;
    }
    /**
     * Sets the string encoding of the SmartBuffer instance.
     *
     * @param encoding { BufferEncoding } The string Buffer encoding to set.
     */
    set encoding(n) {
      t.checkEncoding(n), this._encoding = n;
    }
    /**
     * Gets the underlying internal Buffer. (This includes unmanaged data in the Buffer)
     *
     * @return { Buffer } The Buffer value.
     */
    get internalBuffer() {
      return this._buff;
    }
    /**
     * Gets the value of the internal managed Buffer (Includes managed data only)
     *
     * @param { Buffer }
     */
    toBuffer() {
      return this._buff.slice(0, this.length);
    }
    /**
     * Gets the String value of the internal managed Buffer
     *
     * @param encoding { String } The BufferEncoding to display the Buffer as (defaults to instance level encoding).
     */
    toString(n) {
      const s = typeof n == "string" ? n : this._encoding;
      return t.checkEncoding(s), this._buff.toString(s, 0, this.length);
    }
    /**
     * Destroys the SmartBuffer instance.
     */
    destroy() {
      return this.clear(), this;
    }
    /**
     * Handles inserting and writing strings.
     *
     * @param value { String } The String value to insert.
     * @param isInsert { Boolean } True if inserting a string, false if writing.
     * @param arg2 { Number | String } The offset to insert the string at, or the BufferEncoding to use.
     * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).
     */
    _handleString(n, s, a, g) {
      let o = this._writeOffset, u = this._encoding;
      typeof a == "number" ? o = a : typeof a == "string" && (t.checkEncoding(a), u = a), typeof g == "string" && (t.checkEncoding(g), u = g);
      const I = Buffer.byteLength(n, u);
      return s ? this.ensureInsertable(I, o) : this._ensureWriteable(I, o), this._buff.write(n, o, I, u), s ? this._writeOffset += I : typeof a == "number" ? this._writeOffset = Math.max(this._writeOffset, o + I) : this._writeOffset += I, this;
    }
    /**
     * Handles writing or insert of a Buffer.
     *
     * @param value { Buffer } The Buffer to write.
     * @param offset { Number } The offset to write the Buffer to.
     */
    _handleBuffer(n, s, a) {
      const g = typeof a == "number" ? a : this._writeOffset;
      return s ? this.ensureInsertable(n.length, g) : this._ensureWriteable(n.length, g), n.copy(this._buff, g), s ? this._writeOffset += n.length : typeof a == "number" ? this._writeOffset = Math.max(this._writeOffset, g + n.length) : this._writeOffset += n.length, this;
    }
    /**
     * Ensures that the internal Buffer is large enough to read data.
     *
     * @param length { Number } The length of the data that needs to be read.
     * @param offset { Number } The offset of the data that needs to be read.
     */
    ensureReadable(n, s) {
      let a = this._readOffset;
      if (typeof s < "u" && (t.checkOffsetValue(s), a = s), a < 0 || a + n > this.length)
        throw new Error(t.ERRORS.INVALID_READ_BEYOND_BOUNDS);
    }
    /**
     * Ensures that the internal Buffer is large enough to insert data.
     *
     * @param dataLength { Number } The length of the data that needs to be written.
     * @param offset { Number } The offset of the data to be written.
     */
    ensureInsertable(n, s) {
      t.checkOffsetValue(s), this._ensureCapacity(this.length + n), s < this.length && this._buff.copy(this._buff, s + n, s, this._buff.length), s + n > this.length ? this.length = s + n : this.length += n;
    }
    /**
     * Ensures that the internal Buffer is large enough to write data.
     *
     * @param dataLength { Number } The length of the data that needs to be written.
     * @param offset { Number } The offset of the data to be written (defaults to writeOffset).
     */
    _ensureWriteable(n, s) {
      const a = typeof s == "number" ? s : this._writeOffset;
      this._ensureCapacity(a + n), a + n > this.length && (this.length = a + n);
    }
    /**
     * Ensures that the internal Buffer is large enough to write at least the given amount of data.
     *
     * @param minLength { Number } The minimum length of the data needs to be written.
     */
    _ensureCapacity(n) {
      const s = this._buff.length;
      if (n > s) {
        let a = this._buff, g = s * 3 / 2 + 1;
        g < n && (g = n), this._buff = Buffer.allocUnsafe(g), a.copy(this._buff, 0, 0, s);
      }
    }
    /**
     * Reads a numeric number value using the provided function.
     *
     * @typeparam T { number | bigint } The type of the value to be read
     *
     * @param func { Function(offset: number) => number } The function to read data on the internal Buffer with.
     * @param byteSize { Number } The number of bytes read.
     * @param offset { Number } The offset to read from (optional). When this is not provided, the managed readOffset is used instead.
     *
     * @returns { T } the number value
     */
    _readNumberValue(n, s, a) {
      this.ensureReadable(s, a);
      const g = n.call(this._buff, typeof a == "number" ? a : this._readOffset);
      return typeof a > "u" && (this._readOffset += s), g;
    }
    /**
     * Inserts a numeric number value based on the given offset and value.
     *
     * @typeparam T { number | bigint } The type of the value to be written
     *
     * @param func { Function(offset: T, offset?) => number} The function to write data on the internal Buffer with.
     * @param byteSize { Number } The number of bytes written.
     * @param value { T } The number value to write.
     * @param offset { Number } the offset to write the number at (REQUIRED).
     *
     * @returns SmartBuffer this buffer
     */
    _insertNumberValue(n, s, a, g) {
      return t.checkOffsetValue(g), this.ensureInsertable(s, g), n.call(this._buff, a, g), this._writeOffset += s, this;
    }
    /**
     * Writes a numeric number value based on the given offset and value.
     *
     * @typeparam T { number | bigint } The type of the value to be written
     *
     * @param func { Function(offset: T, offset?) => number} The function to write data on the internal Buffer with.
     * @param byteSize { Number } The number of bytes written.
     * @param value { T } The number value to write.
     * @param offset { Number } the offset to write the number at (REQUIRED).
     *
     * @returns SmartBuffer this buffer
     */
    _writeNumberValue(n, s, a, g) {
      if (typeof g == "number") {
        if (g < 0)
          throw new Error(t.ERRORS.INVALID_WRITE_BEYOND_BOUNDS);
        t.checkOffsetValue(g);
      }
      const o = typeof g == "number" ? g : this._writeOffset;
      return this._ensureWriteable(s, o), n.call(this._buff, a, o), typeof g == "number" ? this._writeOffset = Math.max(this._writeOffset, o + s) : this._writeOffset += s, this;
    }
  }
  return Nh.SmartBuffer = r, Nh;
}
var Ge = {}, FR;
function LT() {
  if (FR) return Ge;
  FR = 1, Object.defineProperty(Ge, "__esModule", { value: !0 }), Ge.SOCKS5_NO_ACCEPTABLE_AUTH = Ge.SOCKS5_CUSTOM_AUTH_END = Ge.SOCKS5_CUSTOM_AUTH_START = Ge.SOCKS_INCOMING_PACKET_SIZES = Ge.SocksClientState = Ge.Socks5Response = Ge.Socks5HostType = Ge.Socks5Auth = Ge.Socks4Response = Ge.SocksCommand = Ge.ERRORS = Ge.DEFAULT_TIMEOUT = void 0;
  const t = 3e4;
  Ge.DEFAULT_TIMEOUT = t;
  const A = {
    InvalidSocksCommand: "An invalid SOCKS command was provided. Valid options are connect, bind, and associate.",
    InvalidSocksCommandForOperation: "An invalid SOCKS command was provided. Only a subset of commands are supported for this operation.",
    InvalidSocksCommandChain: "An invalid SOCKS command was provided. Chaining currently only supports the connect command.",
    InvalidSocksClientOptionsDestination: "An invalid destination host was provided.",
    InvalidSocksClientOptionsExistingSocket: "An invalid existing socket was provided. This should be an instance of stream.Duplex.",
    InvalidSocksClientOptionsProxy: "Invalid SOCKS proxy details were provided.",
    InvalidSocksClientOptionsTimeout: "An invalid timeout value was provided. Please enter a value above 0 (in ms).",
    InvalidSocksClientOptionsProxiesLength: "At least two socks proxies must be provided for chaining.",
    InvalidSocksClientOptionsCustomAuthRange: "Custom auth must be a value between 0x80 and 0xFE.",
    InvalidSocksClientOptionsCustomAuthOptions: "When a custom_auth_method is provided, custom_auth_request_handler, custom_auth_response_size, and custom_auth_response_handler must also be provided and valid.",
    NegotiationError: "Negotiation error",
    SocketClosed: "Socket closed",
    ProxyConnectionTimedOut: "Proxy connection timed out",
    InternalError: "SocksClient internal error (this should not happen)",
    InvalidSocks4HandshakeResponse: "Received invalid Socks4 handshake response",
    Socks4ProxyRejectedConnection: "Socks4 Proxy rejected connection",
    InvalidSocks4IncomingConnectionResponse: "Socks4 invalid incoming connection response",
    Socks4ProxyRejectedIncomingBoundConnection: "Socks4 Proxy rejected incoming bound connection",
    InvalidSocks5InitialHandshakeResponse: "Received invalid Socks5 initial handshake response",
    InvalidSocks5IntiailHandshakeSocksVersion: "Received invalid Socks5 initial handshake (invalid socks version)",
    InvalidSocks5InitialHandshakeNoAcceptedAuthType: "Received invalid Socks5 initial handshake (no accepted authentication type)",
    InvalidSocks5InitialHandshakeUnknownAuthType: "Received invalid Socks5 initial handshake (unknown authentication type)",
    Socks5AuthenticationFailed: "Socks5 Authentication failed",
    InvalidSocks5FinalHandshake: "Received invalid Socks5 final handshake response",
    InvalidSocks5FinalHandshakeRejected: "Socks5 proxy rejected connection",
    InvalidSocks5IncomingConnectionResponse: "Received invalid Socks5 incoming connection response",
    Socks5ProxyRejectedIncomingBoundConnection: "Socks5 Proxy rejected incoming bound connection"
  };
  Ge.ERRORS = A;
  const e = {
    Socks5InitialHandshakeResponse: 2,
    Socks5UserPassAuthenticationResponse: 2,
    // Command response + incoming connection (bind)
    Socks5ResponseHeader: 5,
    // We need at least 5 to read the hostname length, then we wait for the address+port information.
    Socks5ResponseIPv4: 10,
    // 4 header + 4 ip + 2 port
    Socks5ResponseIPv6: 22,
    // 4 header + 16 ip + 2 port
    Socks5ResponseHostname: (c) => c + 7,
    // 4 header + 1 host length + host + 2 port
    // Command response + incoming connection (bind)
    Socks4Response: 8
    // 2 header + 2 port + 4 ip
  };
  Ge.SOCKS_INCOMING_PACKET_SIZES = e;
  var r;
  (function(c) {
    c[c.connect = 1] = "connect", c[c.bind = 2] = "bind", c[c.associate = 3] = "associate";
  })(r || (Ge.SocksCommand = r = {}));
  var i;
  (function(c) {
    c[c.Granted = 90] = "Granted", c[c.Failed = 91] = "Failed", c[c.Rejected = 92] = "Rejected", c[c.RejectedIdent = 93] = "RejectedIdent";
  })(i || (Ge.Socks4Response = i = {}));
  var n;
  (function(c) {
    c[c.NoAuth = 0] = "NoAuth", c[c.GSSApi = 1] = "GSSApi", c[c.UserPass = 2] = "UserPass";
  })(n || (Ge.Socks5Auth = n = {}));
  const s = 128;
  Ge.SOCKS5_CUSTOM_AUTH_START = s;
  const a = 254;
  Ge.SOCKS5_CUSTOM_AUTH_END = a;
  const g = 255;
  Ge.SOCKS5_NO_ACCEPTABLE_AUTH = g;
  var o;
  (function(c) {
    c[c.Granted = 0] = "Granted", c[c.Failure = 1] = "Failure", c[c.NotAllowed = 2] = "NotAllowed", c[c.NetworkUnreachable = 3] = "NetworkUnreachable", c[c.HostUnreachable = 4] = "HostUnreachable", c[c.ConnectionRefused = 5] = "ConnectionRefused", c[c.TTLExpired = 6] = "TTLExpired", c[c.CommandNotSupported = 7] = "CommandNotSupported", c[c.AddressNotSupported = 8] = "AddressNotSupported";
  })(o || (Ge.Socks5Response = o = {}));
  var u;
  (function(c) {
    c[c.IPv4 = 1] = "IPv4", c[c.Hostname = 3] = "Hostname", c[c.IPv6 = 4] = "IPv6";
  })(u || (Ge.Socks5HostType = u = {}));
  var I;
  return function(c) {
    c[c.Created = 0] = "Created", c[c.Connecting = 1] = "Connecting", c[c.Connected = 2] = "Connected", c[c.SentInitialHandshake = 3] = "SentInitialHandshake", c[c.ReceivedInitialHandshakeResponse = 4] = "ReceivedInitialHandshakeResponse", c[c.SentAuthentication = 5] = "SentAuthentication", c[c.ReceivedAuthenticationResponse = 6] = "ReceivedAuthenticationResponse", c[c.SentFinalHandshake = 7] = "SentFinalHandshake", c[c.ReceivedFinalResponse = 8] = "ReceivedFinalResponse", c[c.BoundWaitingForConnection = 9] = "BoundWaitingForConnection", c[c.Established = 10] = "Established", c[c.Disconnected = 11] = "Disconnected", c[c.Error = 99] = "Error";
  }(I || (Ge.SocksClientState = I = {})), Ge;
}
var wr = {}, Ha = {}, kR;
function xT() {
  if (kR) return Ha;
  kR = 1, Object.defineProperty(Ha, "__esModule", { value: !0 }), Ha.shuffleArray = Ha.SocksClientError = void 0;
  class t extends Error {
    constructor(r, i) {
      super(r), this.options = i;
    }
  }
  Ha.SocksClientError = t;
  function A(e) {
    for (let r = e.length - 1; r > 0; r--) {
      const i = Math.floor(Math.random() * (r + 1));
      [e[r], e[i]] = [e[i], e[r]];
    }
  }
  return Ha.shuffleArray = A, Ha;
}
var Jy = {}, vI = {}, Ms = {}, vR;
function GD() {
  if (vR) return Ms;
  vR = 1, Object.defineProperty(Ms, "__esModule", { value: !0 }), Ms.isInSubnet = t, Ms.isCorrect = A, Ms.numberToPaddedHex = e, Ms.stringToPaddedHex = r, Ms.testBit = i;
  function t(n) {
    return this.subnetMask < n.subnetMask ? !1 : this.mask(n.subnetMask) === n.mask();
  }
  function A(n) {
    return function() {
      return this.addressMinusSuffix !== this.correctForm() ? !1 : this.subnetMask === n && !this.parsedSubnet ? !0 : this.parsedSubnet === String(this.subnetMask);
    };
  }
  function e(n) {
    return n.toString(16).padStart(2, "0");
  }
  function r(n) {
    return e(parseInt(n, 10));
  }
  function i(n, s) {
    const { length: a } = n;
    if (s > a)
      return !1;
    const g = a - s;
    return n.substring(g, g + 1) === "1";
  }
  return Ms;
}
var gi = {}, RR;
function GT() {
  return RR || (RR = 1, Object.defineProperty(gi, "__esModule", { value: !0 }), gi.RE_SUBNET_STRING = gi.RE_ADDRESS = gi.GROUPS = gi.BITS = void 0, gi.BITS = 32, gi.GROUPS = 4, gi.RE_ADDRESS = /^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/g, gi.RE_SUBNET_STRING = /\/\d{1,2}$/), gi;
}
var RI = {}, bR;
function TS() {
  if (bR) return RI;
  bR = 1, Object.defineProperty(RI, "__esModule", { value: !0 }), RI.AddressError = void 0;
  class t extends Error {
    constructor(e, r) {
      super(e), this.name = "AddressError", this.parseMessage = r;
    }
  }
  return RI.AddressError = t, RI;
}
var MR;
function UT() {
  if (MR) return vI;
  MR = 1;
  var t = W && W.__createBinding || (Object.create ? function(a, g, o, u) {
    u === void 0 && (u = o);
    var I = Object.getOwnPropertyDescriptor(g, o);
    (!I || ("get" in I ? !g.__esModule : I.writable || I.configurable)) && (I = { enumerable: !0, get: function() {
      return g[o];
    } }), Object.defineProperty(a, u, I);
  } : function(a, g, o, u) {
    u === void 0 && (u = o), a[u] = g[o];
  }), A = W && W.__setModuleDefault || (Object.create ? function(a, g) {
    Object.defineProperty(a, "default", { enumerable: !0, value: g });
  } : function(a, g) {
    a.default = g;
  }), e = W && W.__importStar || function(a) {
    if (a && a.__esModule) return a;
    var g = {};
    if (a != null) for (var o in a) o !== "default" && Object.prototype.hasOwnProperty.call(a, o) && t(g, a, o);
    return A(g, a), g;
  };
  Object.defineProperty(vI, "__esModule", { value: !0 }), vI.Address4 = void 0;
  const r = e(GD()), i = e(GT()), n = TS();
  class s {
    constructor(g) {
      this.groups = i.GROUPS, this.parsedAddress = [], this.parsedSubnet = "", this.subnet = "/32", this.subnetMask = 32, this.v4 = !0, this.isCorrect = r.isCorrect(i.BITS), this.isInSubnet = r.isInSubnet, this.address = g;
      const o = i.RE_SUBNET_STRING.exec(g);
      if (o) {
        if (this.parsedSubnet = o[0].replace("/", ""), this.subnetMask = parseInt(this.parsedSubnet, 10), this.subnet = `/${this.subnetMask}`, this.subnetMask < 0 || this.subnetMask > i.BITS)
          throw new n.AddressError("Invalid subnet mask.");
        g = g.replace(i.RE_SUBNET_STRING, "");
      }
      this.addressMinusSuffix = g, this.parsedAddress = this.parse(g);
    }
    static isValid(g) {
      try {
        return new s(g), !0;
      } catch {
        return !1;
      }
    }
    /*
     * Parses a v4 address
     */
    parse(g) {
      const o = g.split(".");
      if (!g.match(i.RE_ADDRESS))
        throw new n.AddressError("Invalid IPv4 address.");
      return o;
    }
    /**
     * Returns the correct form of an address
     * @memberof Address4
     * @instance
     * @returns {String}
     */
    correctForm() {
      return this.parsedAddress.map((g) => parseInt(g, 10)).join(".");
    }
    /**
     * Converts a hex string to an IPv4 address object
     * @memberof Address4
     * @static
     * @param {string} hex - a hex string to convert
     * @returns {Address4}
     */
    static fromHex(g) {
      const o = g.replace(/:/g, "").padStart(8, "0"), u = [];
      let I;
      for (I = 0; I < 8; I += 2) {
        const c = o.slice(I, I + 2);
        u.push(parseInt(c, 16));
      }
      return new s(u.join("."));
    }
    /**
     * Converts an integer into a IPv4 address object
     * @memberof Address4
     * @static
     * @param {integer} integer - a number to convert
     * @returns {Address4}
     */
    static fromInteger(g) {
      return s.fromHex(g.toString(16));
    }
    /**
     * Return an address from in-addr.arpa form
     * @memberof Address4
     * @static
     * @param {string} arpaFormAddress - an 'in-addr.arpa' form ipv4 address
     * @returns {Adress4}
     * @example
     * var address = Address4.fromArpa(42.2.0.192.in-addr.arpa.)
     * address.correctForm(); // '192.0.2.42'
     */
    static fromArpa(g) {
      const u = g.replace(/(\.in-addr\.arpa)?\.$/, "").split(".").reverse().join(".");
      return new s(u);
    }
    /**
     * Converts an IPv4 address object to a hex string
     * @memberof Address4
     * @instance
     * @returns {String}
     */
    toHex() {
      return this.parsedAddress.map((g) => r.stringToPaddedHex(g)).join(":");
    }
    /**
     * Converts an IPv4 address object to an array of bytes
     * @memberof Address4
     * @instance
     * @returns {Array}
     */
    toArray() {
      return this.parsedAddress.map((g) => parseInt(g, 10));
    }
    /**
     * Converts an IPv4 address object to an IPv6 address group
     * @memberof Address4
     * @instance
     * @returns {String}
     */
    toGroup6() {
      const g = [];
      let o;
      for (o = 0; o < i.GROUPS; o += 2)
        g.push(`${r.stringToPaddedHex(this.parsedAddress[o])}${r.stringToPaddedHex(this.parsedAddress[o + 1])}`);
      return g.join(":");
    }
    /**
     * Returns the address as a `bigint`
     * @memberof Address4
     * @instance
     * @returns {bigint}
     */
    bigInt() {
      return BigInt(`0x${this.parsedAddress.map((g) => r.stringToPaddedHex(g)).join("")}`);
    }
    /**
     * Helper function getting start address.
     * @memberof Address4
     * @instance
     * @returns {bigint}
     */
    _startAddress() {
      return BigInt(`0b${this.mask() + "0".repeat(i.BITS - this.subnetMask)}`);
    }
    /**
     * The first address in the range given by this address' subnet.
     * Often referred to as the Network Address.
     * @memberof Address4
     * @instance
     * @returns {Address4}
     */
    startAddress() {
      return s.fromBigInt(this._startAddress());
    }
    /**
     * The first host address in the range given by this address's subnet ie
     * the first address after the Network Address
     * @memberof Address4
     * @instance
     * @returns {Address4}
     */
    startAddressExclusive() {
      const g = BigInt("1");
      return s.fromBigInt(this._startAddress() + g);
    }
    /**
     * Helper function getting end address.
     * @memberof Address4
     * @instance
     * @returns {bigint}
     */
    _endAddress() {
      return BigInt(`0b${this.mask() + "1".repeat(i.BITS - this.subnetMask)}`);
    }
    /**
     * The last address in the range given by this address' subnet
     * Often referred to as the Broadcast
     * @memberof Address4
     * @instance
     * @returns {Address4}
     */
    endAddress() {
      return s.fromBigInt(this._endAddress());
    }
    /**
     * The last host address in the range given by this address's subnet ie
     * the last address prior to the Broadcast Address
     * @memberof Address4
     * @instance
     * @returns {Address4}
     */
    endAddressExclusive() {
      const g = BigInt("1");
      return s.fromBigInt(this._endAddress() - g);
    }
    /**
     * Converts a BigInt to a v4 address object
     * @memberof Address4
     * @static
     * @param {bigint} bigInt - a BigInt to convert
     * @returns {Address4}
     */
    static fromBigInt(g) {
      return s.fromHex(g.toString(16));
    }
    /**
     * Convert a byte array to an Address4 object
     * @memberof Address4
     * @static
     * @param {Array<number>} bytes - an array of 4 bytes (0-255)
     * @returns {Address4}
     */
    static fromByteArray(g) {
      if (g.length !== 4)
        throw new n.AddressError("IPv4 addresses require exactly 4 bytes");
      for (let o = 0; o < g.length; o++)
        if (!Number.isInteger(g[o]) || g[o] < 0 || g[o] > 255)
          throw new n.AddressError("All bytes must be integers between 0 and 255");
      return this.fromUnsignedByteArray(g);
    }
    /**
     * Convert an unsigned byte array to an Address4 object
     * @memberof Address4
     * @static
     * @param {Array<number>} bytes - an array of 4 unsigned bytes (0-255)
     * @returns {Address4}
     */
    static fromUnsignedByteArray(g) {
      if (g.length !== 4)
        throw new n.AddressError("IPv4 addresses require exactly 4 bytes");
      const o = g.join(".");
      return new s(o);
    }
    /**
     * Returns the first n bits of the address, defaulting to the
     * subnet mask
     * @memberof Address4
     * @instance
     * @returns {String}
     */
    mask(g) {
      return g === void 0 && (g = this.subnetMask), this.getBitsBase2(0, g);
    }
    /**
     * Returns the bits in the given range as a base-2 string
     * @memberof Address4
     * @instance
     * @returns {string}
     */
    getBitsBase2(g, o) {
      return this.binaryZeroPad().slice(g, o);
    }
    /**
     * Return the reversed ip6.arpa form of the address
     * @memberof Address4
     * @param {Object} options
     * @param {boolean} options.omitSuffix - omit the "in-addr.arpa" suffix
     * @instance
     * @returns {String}
     */
    reverseForm(g) {
      g || (g = {});
      const o = this.correctForm().split(".").reverse().join(".");
      return g.omitSuffix ? o : `${o}.in-addr.arpa.`;
    }
    /**
     * Returns true if the given address is a multicast address
     * @memberof Address4
     * @instance
     * @returns {boolean}
     */
    isMulticast() {
      return this.isInSubnet(new s("224.0.0.0/4"));
    }
    /**
     * Returns a zero-padded base-2 string representation of the address
     * @memberof Address4
     * @instance
     * @returns {string}
     */
    binaryZeroPad() {
      return this.bigInt().toString(2).padStart(i.BITS, "0");
    }
    /**
     * Groups an IPv4 address for inclusion at the end of an IPv6 address
     * @returns {String}
     */
    groupForV6() {
      const g = this.parsedAddress;
      return this.address.replace(i.RE_ADDRESS, `<span class="hover-group group-v4 group-6">${g.slice(0, 2).join(".")}</span>.<span class="hover-group group-v4 group-7">${g.slice(2, 4).join(".")}</span>`);
    }
  }
  return vI.Address4 = s, vI;
}
var bI = {}, Xe = {}, _R;
function TT() {
  return _R || (_R = 1, Object.defineProperty(Xe, "__esModule", { value: !0 }), Xe.RE_URL_WITH_PORT = Xe.RE_URL = Xe.RE_ZONE_STRING = Xe.RE_SUBNET_STRING = Xe.RE_BAD_ADDRESS = Xe.RE_BAD_CHARACTERS = Xe.TYPES = Xe.SCOPES = Xe.GROUPS = Xe.BITS = void 0, Xe.BITS = 128, Xe.GROUPS = 8, Xe.SCOPES = {
    0: "Reserved",
    1: "Interface local",
    2: "Link local",
    4: "Admin local",
    5: "Site local",
    8: "Organization local",
    14: "Global",
    15: "Reserved"
  }, Xe.TYPES = {
    "ff01::1/128": "Multicast (All nodes on this interface)",
    "ff01::2/128": "Multicast (All routers on this interface)",
    "ff02::1/128": "Multicast (All nodes on this link)",
    "ff02::2/128": "Multicast (All routers on this link)",
    "ff05::2/128": "Multicast (All routers in this site)",
    "ff02::5/128": "Multicast (OSPFv3 AllSPF routers)",
    "ff02::6/128": "Multicast (OSPFv3 AllDR routers)",
    "ff02::9/128": "Multicast (RIP routers)",
    "ff02::a/128": "Multicast (EIGRP routers)",
    "ff02::d/128": "Multicast (PIM routers)",
    "ff02::16/128": "Multicast (MLDv2 reports)",
    "ff01::fb/128": "Multicast (mDNSv6)",
    "ff02::fb/128": "Multicast (mDNSv6)",
    "ff05::fb/128": "Multicast (mDNSv6)",
    "ff02::1:2/128": "Multicast (All DHCP servers and relay agents on this link)",
    "ff05::1:2/128": "Multicast (All DHCP servers and relay agents in this site)",
    "ff02::1:3/128": "Multicast (All DHCP servers on this link)",
    "ff05::1:3/128": "Multicast (All DHCP servers in this site)",
    "::/128": "Unspecified",
    "::1/128": "Loopback",
    "ff00::/8": "Multicast",
    "fe80::/10": "Link-local unicast"
  }, Xe.RE_BAD_CHARACTERS = /([^0-9a-f:/%])/gi, Xe.RE_BAD_ADDRESS = /([0-9a-f]{5,}|:{3,}|[^:]:$|^:[^:]|\/$)/gi, Xe.RE_SUBNET_STRING = /\/\d{1,3}(?=%|$)/, Xe.RE_ZONE_STRING = /%.*$/, Xe.RE_URL = /^\[{0,1}([0-9a-f:]+)\]{0,1}/, Xe.RE_URL_WITH_PORT = /\[([0-9a-f:]+)\]:([0-9]{1,5})/), Xe;
}
var Pa = {}, NR;
function KT() {
  if (NR) return Pa;
  NR = 1, Object.defineProperty(Pa, "__esModule", { value: !0 }), Pa.spanAllZeroes = t, Pa.spanAll = A, Pa.spanLeadingZeroes = r, Pa.simpleGroup = i;
  function t(n) {
    return n.replace(/(0+)/g, '<span class="zero">$1</span>');
  }
  function A(n, s = 0) {
    return n.split("").map((g, o) => `<span class="digit value-${g} position-${o + s}">${t(g)}</span>`).join("");
  }
  function e(n) {
    return n.replace(/^(0+)/, '<span class="zero">$1</span>');
  }
  function r(n) {
    return n.split(":").map((a) => e(a)).join(":");
  }
  function i(n, s = 0) {
    return n.split(":").map((g, o) => /group-v4/.test(g) ? g : `<span class="hover-group group-${o + s}">${e(g)}</span>`);
  }
  return Pa;
}
var _n = {}, LR;
function ceA() {
  if (LR) return _n;
  LR = 1;
  var t = W && W.__createBinding || (Object.create ? function(g, o, u, I) {
    I === void 0 && (I = u);
    var c = Object.getOwnPropertyDescriptor(o, u);
    (!c || ("get" in c ? !o.__esModule : c.writable || c.configurable)) && (c = { enumerable: !0, get: function() {
      return o[u];
    } }), Object.defineProperty(g, I, c);
  } : function(g, o, u, I) {
    I === void 0 && (I = u), g[I] = o[u];
  }), A = W && W.__setModuleDefault || (Object.create ? function(g, o) {
    Object.defineProperty(g, "default", { enumerable: !0, value: o });
  } : function(g, o) {
    g.default = o;
  }), e = W && W.__importStar || function(g) {
    if (g && g.__esModule) return g;
    var o = {};
    if (g != null) for (var u in g) u !== "default" && Object.prototype.hasOwnProperty.call(g, u) && t(o, g, u);
    return A(o, g), o;
  };
  Object.defineProperty(_n, "__esModule", { value: !0 }), _n.ADDRESS_BOUNDARY = void 0, _n.groupPossibilities = i, _n.padGroup = n, _n.simpleRegularExpression = s, _n.possibleElisions = a;
  const r = e(TT());
  function i(g) {
    return `(${g.join("|")})`;
  }
  function n(g) {
    return g.length < 4 ? `0{0,${4 - g.length}}${g}` : g;
  }
  _n.ADDRESS_BOUNDARY = "[^A-Fa-f0-9:]";
  function s(g) {
    const o = [];
    g.forEach((I, c) => {
      parseInt(I, 16) === 0 && o.push(c);
    });
    const u = o.map((I) => g.map((c, C) => {
      if (C === I) {
        const E = C === 0 || C === r.GROUPS - 1 ? ":" : "";
        return i([n(c), E]);
      }
      return n(c);
    }).join(":"));
    return u.push(g.map(n).join(":")), i(u);
  }
  function a(g, o, u) {
    const I = o ? "" : ":", c = u ? "" : ":", C = [];
    !o && !u && C.push("::"), o && u && C.push(""), (u && !o || !u && o) && C.push(":"), C.push(`${I}(:0{1,4}){1,${g - 1}}`), C.push(`(0{1,4}:){1,${g - 1}}${c}`), C.push(`(0{1,4}:){${g - 1}}0{1,4}`);
    for (let E = 1; E < g - 1; E++)
      for (let l = 1; l < g - E; l++)
        C.push(`(0{1,4}:){${l}}:(0{1,4}:){${g - l - E - 1}}0{1,4}`);
    return i(C);
  }
  return _n;
}
var xR;
function IeA() {
  if (xR) return bI;
  xR = 1;
  var t = W && W.__createBinding || (Object.create ? function(Q, f, p, y) {
    y === void 0 && (y = p);
    var m = Object.getOwnPropertyDescriptor(f, p);
    (!m || ("get" in m ? !f.__esModule : m.writable || m.configurable)) && (m = { enumerable: !0, get: function() {
      return f[p];
    } }), Object.defineProperty(Q, y, m);
  } : function(Q, f, p, y) {
    y === void 0 && (y = p), Q[y] = f[p];
  }), A = W && W.__setModuleDefault || (Object.create ? function(Q, f) {
    Object.defineProperty(Q, "default", { enumerable: !0, value: f });
  } : function(Q, f) {
    Q.default = f;
  }), e = W && W.__importStar || function(Q) {
    if (Q && Q.__esModule) return Q;
    var f = {};
    if (Q != null) for (var p in Q) p !== "default" && Object.prototype.hasOwnProperty.call(Q, p) && t(f, Q, p);
    return A(f, Q), f;
  };
  Object.defineProperty(bI, "__esModule", { value: !0 }), bI.Address6 = void 0;
  const r = e(GD()), i = e(GT()), n = e(TT()), s = e(KT()), a = UT(), g = ceA(), o = TS(), u = GD();
  function I(Q) {
    if (!Q)
      throw new Error("Assertion failed.");
  }
  function c(Q) {
    const f = /(\d+)(\d{3})/;
    for (; f.test(Q); )
      Q = Q.replace(f, "$1,$2");
    return Q;
  }
  function C(Q) {
    return Q = Q.replace(/^(0{1,})([1-9]+)$/, '<span class="parse-error">$1</span>$2'), Q = Q.replace(/^(0{1,})(0)$/, '<span class="parse-error">$1</span>$2'), Q;
  }
  function E(Q, f) {
    const p = [], y = [];
    let m;
    for (m = 0; m < Q.length; m++)
      m < f[0] ? p.push(Q[m]) : m > f[1] && y.push(Q[m]);
    return p.concat(["compact"]).concat(y);
  }
  function l(Q) {
    return parseInt(Q, 16).toString(16).padStart(4, "0");
  }
  function B(Q) {
    return Q & 255;
  }
  class h {
    constructor(f, p) {
      this.addressMinusSuffix = "", this.parsedSubnet = "", this.subnet = "/128", this.subnetMask = 128, this.v4 = !1, this.zone = "", this.isInSubnet = r.isInSubnet, this.isCorrect = r.isCorrect(n.BITS), p === void 0 ? this.groups = n.GROUPS : this.groups = p, this.address = f;
      const y = n.RE_SUBNET_STRING.exec(f);
      if (y) {
        if (this.parsedSubnet = y[0].replace("/", ""), this.subnetMask = parseInt(this.parsedSubnet, 10), this.subnet = `/${this.subnetMask}`, Number.isNaN(this.subnetMask) || this.subnetMask < 0 || this.subnetMask > n.BITS)
          throw new o.AddressError("Invalid subnet mask.");
        f = f.replace(n.RE_SUBNET_STRING, "");
      } else if (/\//.test(f))
        throw new o.AddressError("Invalid subnet mask.");
      const m = n.RE_ZONE_STRING.exec(f);
      m && (this.zone = m[0], f = f.replace(n.RE_ZONE_STRING, "")), this.addressMinusSuffix = f, this.parsedAddress = this.parse(this.addressMinusSuffix);
    }
    static isValid(f) {
      try {
        return new h(f), !0;
      } catch {
        return !1;
      }
    }
    /**
     * Convert a BigInt to a v6 address object
     * @memberof Address6
     * @static
     * @param {bigint} bigInt - a BigInt to convert
     * @returns {Address6}
     * @example
     * var bigInt = BigInt('1000000000000');
     * var address = Address6.fromBigInt(bigInt);
     * address.correctForm(); // '::e8:d4a5:1000'
     */
    static fromBigInt(f) {
      const p = f.toString(16).padStart(32, "0"), y = [];
      let m;
      for (m = 0; m < n.GROUPS; m++)
        y.push(p.slice(m * 4, (m + 1) * 4));
      return new h(y.join(":"));
    }
    /**
     * Convert a URL (with optional port number) to an address object
     * @memberof Address6
     * @static
     * @param {string} url - a URL with optional port number
     * @example
     * var addressAndPort = Address6.fromURL('http://[ffff::]:8080/foo/');
     * addressAndPort.address.correctForm(); // 'ffff::'
     * addressAndPort.port; // 8080
     */
    static fromURL(f) {
      let p, y = null, m;
      if (f.indexOf("[") !== -1 && f.indexOf("]:") !== -1) {
        if (m = n.RE_URL_WITH_PORT.exec(f), m === null)
          return {
            error: "failed to parse address with port",
            address: null,
            port: null
          };
        p = m[1], y = m[2];
      } else if (f.indexOf("/") !== -1) {
        if (f = f.replace(/^[a-z0-9]+:\/\//, ""), m = n.RE_URL.exec(f), m === null)
          return {
            error: "failed to parse address from URL",
            address: null,
            port: null
          };
        p = m[1];
      } else
        p = f;
      return y ? (y = parseInt(y, 10), (y < 0 || y > 65536) && (y = null)) : y = null, {
        address: new h(p),
        port: y
      };
    }
    /**
     * Create an IPv6-mapped address given an IPv4 address
     * @memberof Address6
     * @static
     * @param {string} address - An IPv4 address string
     * @returns {Address6}
     * @example
     * var address = Address6.fromAddress4('192.168.0.1');
     * address.correctForm(); // '::ffff:c0a8:1'
     * address.to4in6(); // '::ffff:192.168.0.1'
     */
    static fromAddress4(f) {
      const p = new a.Address4(f), y = n.BITS - (i.BITS - p.subnetMask);
      return new h(`::ffff:${p.correctForm()}/${y}`);
    }
    /**
     * Return an address from ip6.arpa form
     * @memberof Address6
     * @static
     * @param {string} arpaFormAddress - an 'ip6.arpa' form address
     * @returns {Adress6}
     * @example
     * var address = Address6.fromArpa(e.f.f.f.3.c.2.6.f.f.f.e.6.6.8.e.1.0.6.7.9.4.e.c.0.0.0.0.1.0.0.2.ip6.arpa.)
     * address.correctForm(); // '2001:0:ce49:7601:e866:efff:62c3:fffe'
     */
    static fromArpa(f) {
      let p = f.replace(/(\.ip6\.arpa)?\.$/, "");
      const y = 7;
      if (p.length !== 63)
        throw new o.AddressError("Invalid 'ip6.arpa' form.");
      const m = p.split(".").reverse();
      for (let S = y; S > 0; S--) {
        const w = S * 4;
        m.splice(w, 0, ":");
      }
      return p = m.join(""), new h(p);
    }
    /**
     * Return the Microsoft UNC transcription of the address
     * @memberof Address6
     * @instance
     * @returns {String} the Microsoft UNC transcription of the address
     */
    microsoftTranscription() {
      return `${this.correctForm().replace(/:/g, "-")}.ipv6-literal.net`;
    }
    /**
     * Return the first n bits of the address, defaulting to the subnet mask
     * @memberof Address6
     * @instance
     * @param {number} [mask=subnet] - the number of bits to mask
     * @returns {String} the first n bits of the address as a string
     */
    mask(f = this.subnetMask) {
      return this.getBitsBase2(0, f);
    }
    /**
     * Return the number of possible subnets of a given size in the address
     * @memberof Address6
     * @instance
     * @param {number} [subnetSize=128] - the subnet size
     * @returns {String}
     */
    // TODO: probably useful to have a numeric version of this too
    possibleSubnets(f = 128) {
      const p = n.BITS - this.subnetMask, y = Math.abs(f - n.BITS), m = p - y;
      return m < 0 ? "0" : c((BigInt("2") ** BigInt(m)).toString(10));
    }
    /**
     * Helper function getting start address.
     * @memberof Address6
     * @instance
     * @returns {bigint}
     */
    _startAddress() {
      return BigInt(`0b${this.mask() + "0".repeat(n.BITS - this.subnetMask)}`);
    }
    /**
     * The first address in the range given by this address' subnet
     * Often referred to as the Network Address.
     * @memberof Address6
     * @instance
     * @returns {Address6}
     */
    startAddress() {
      return h.fromBigInt(this._startAddress());
    }
    /**
     * The first host address in the range given by this address's subnet ie
     * the first address after the Network Address
     * @memberof Address6
     * @instance
     * @returns {Address6}
     */
    startAddressExclusive() {
      const f = BigInt("1");
      return h.fromBigInt(this._startAddress() + f);
    }
    /**
     * Helper function getting end address.
     * @memberof Address6
     * @instance
     * @returns {bigint}
     */
    _endAddress() {
      return BigInt(`0b${this.mask() + "1".repeat(n.BITS - this.subnetMask)}`);
    }
    /**
     * The last address in the range given by this address' subnet
     * Often referred to as the Broadcast
     * @memberof Address6
     * @instance
     * @returns {Address6}
     */
    endAddress() {
      return h.fromBigInt(this._endAddress());
    }
    /**
     * The last host address in the range given by this address's subnet ie
     * the last address prior to the Broadcast Address
     * @memberof Address6
     * @instance
     * @returns {Address6}
     */
    endAddressExclusive() {
      const f = BigInt("1");
      return h.fromBigInt(this._endAddress() - f);
    }
    /**
     * Return the scope of the address
     * @memberof Address6
     * @instance
     * @returns {String}
     */
    getScope() {
      let f = n.SCOPES[parseInt(this.getBits(12, 16).toString(10), 10)];
      return this.getType() === "Global unicast" && f !== "Link local" && (f = "Global"), f || "Unknown";
    }
    /**
     * Return the type of the address
     * @memberof Address6
     * @instance
     * @returns {String}
     */
    getType() {
      for (const f of Object.keys(n.TYPES))
        if (this.isInSubnet(new h(f)))
          return n.TYPES[f];
      return "Global unicast";
    }
    /**
     * Return the bits in the given range as a BigInt
     * @memberof Address6
     * @instance
     * @returns {bigint}
     */
    getBits(f, p) {
      return BigInt(`0b${this.getBitsBase2(f, p)}`);
    }
    /**
     * Return the bits in the given range as a base-2 string
     * @memberof Address6
     * @instance
     * @returns {String}
     */
    getBitsBase2(f, p) {
      return this.binaryZeroPad().slice(f, p);
    }
    /**
     * Return the bits in the given range as a base-16 string
     * @memberof Address6
     * @instance
     * @returns {String}
     */
    getBitsBase16(f, p) {
      const y = p - f;
      if (y % 4 !== 0)
        throw new Error("Length of bits to retrieve must be divisible by four");
      return this.getBits(f, p).toString(16).padStart(y / 4, "0");
    }
    /**
     * Return the bits that are set past the subnet mask length
     * @memberof Address6
     * @instance
     * @returns {String}
     */
    getBitsPastSubnet() {
      return this.getBitsBase2(this.subnetMask, n.BITS);
    }
    /**
     * Return the reversed ip6.arpa form of the address
     * @memberof Address6
     * @param {Object} options
     * @param {boolean} options.omitSuffix - omit the "ip6.arpa" suffix
     * @instance
     * @returns {String}
     */
    reverseForm(f) {
      f || (f = {});
      const p = Math.floor(this.subnetMask / 4), y = this.canonicalForm().replace(/:/g, "").split("").slice(0, p).reverse().join(".");
      return p > 0 ? f.omitSuffix ? y : `${y}.ip6.arpa.` : f.omitSuffix ? "" : "ip6.arpa.";
    }
    /**
     * Return the correct form of the address
     * @memberof Address6
     * @instance
     * @returns {String}
     */
    correctForm() {
      let f, p = [], y = 0;
      const m = [];
      for (f = 0; f < this.parsedAddress.length; f++) {
        const F = parseInt(this.parsedAddress[f], 16);
        F === 0 && y++, F !== 0 && y > 0 && (y > 1 && m.push([f - y, f - 1]), y = 0);
      }
      y > 1 && m.push([this.parsedAddress.length - y, this.parsedAddress.length - 1]);
      const S = m.map((F) => F[1] - F[0] + 1);
      if (m.length > 0) {
        const F = S.indexOf(Math.max(...S));
        p = E(this.parsedAddress, m[F]);
      } else
        p = this.parsedAddress;
      for (f = 0; f < p.length; f++)
        p[f] !== "compact" && (p[f] = parseInt(p[f], 16).toString(16));
      let w = p.join(":");
      return w = w.replace(/^compact$/, "::"), w = w.replace(/(^compact)|(compact$)/, ":"), w = w.replace(/compact/, ""), w;
    }
    /**
     * Return a zero-padded base-2 string representation of the address
     * @memberof Address6
     * @instance
     * @returns {String}
     * @example
     * var address = new Address6('2001:4860:4001:803::1011');
     * address.binaryZeroPad();
     * // '0010000000000001010010000110000001000000000000010000100000000011
     * //  0000000000000000000000000000000000000000000000000001000000010001'
     */
    binaryZeroPad() {
      return this.bigInt().toString(2).padStart(n.BITS, "0");
    }
    // TODO: Improve the semantics of this helper function
    parse4in6(f) {
      const p = f.split(":"), m = p.slice(-1)[0].match(i.RE_ADDRESS);
      if (m) {
        this.parsedAddress4 = m[0], this.address4 = new a.Address4(this.parsedAddress4);
        for (let S = 0; S < this.address4.groups; S++)
          if (/^0[0-9]+/.test(this.address4.parsedAddress[S]))
            throw new o.AddressError("IPv4 addresses can't have leading zeroes.", f.replace(i.RE_ADDRESS, this.address4.parsedAddress.map(C).join(".")));
        this.v4 = !0, p[p.length - 1] = this.address4.toGroup6(), f = p.join(":");
      }
      return f;
    }
    // TODO: Make private?
    parse(f) {
      f = this.parse4in6(f);
      const p = f.match(n.RE_BAD_CHARACTERS);
      if (p)
        throw new o.AddressError(`Bad character${p.length > 1 ? "s" : ""} detected in address: ${p.join("")}`, f.replace(n.RE_BAD_CHARACTERS, '<span class="parse-error">$1</span>'));
      const y = f.match(n.RE_BAD_ADDRESS);
      if (y)
        throw new o.AddressError(`Address failed regex: ${y.join("")}`, f.replace(n.RE_BAD_ADDRESS, '<span class="parse-error">$1</span>'));
      let m = [];
      const S = f.split("::");
      if (S.length === 2) {
        let w = S[0].split(":"), F = S[1].split(":");
        w.length === 1 && w[0] === "" && (w = []), F.length === 1 && F[0] === "" && (F = []);
        const b = this.groups - (w.length + F.length);
        if (!b)
          throw new o.AddressError("Error parsing groups");
        this.elidedGroups = b, this.elisionBegin = w.length, this.elisionEnd = w.length + this.elidedGroups, m = m.concat(w);
        for (let G = 0; G < b; G++)
          m.push("0");
        m = m.concat(F);
      } else if (S.length === 1)
        m = f.split(":"), this.elidedGroups = 0;
      else
        throw new o.AddressError("Too many :: groups found");
      if (m = m.map((w) => parseInt(w, 16).toString(16)), m.length !== this.groups)
        throw new o.AddressError("Incorrect number of groups found");
      return m;
    }
    /**
     * Return the canonical form of the address
     * @memberof Address6
     * @instance
     * @returns {String}
     */
    canonicalForm() {
      return this.parsedAddress.map(l).join(":");
    }
    /**
     * Return the decimal form of the address
     * @memberof Address6
     * @instance
     * @returns {String}
     */
    decimal() {
      return this.parsedAddress.map((f) => parseInt(f, 16).toString(10).padStart(5, "0")).join(":");
    }
    /**
     * Return the address as a BigInt
     * @memberof Address6
     * @instance
     * @returns {bigint}
     */
    bigInt() {
      return BigInt(`0x${this.parsedAddress.map(l).join("")}`);
    }
    /**
     * Return the last two groups of this address as an IPv4 address string
     * @memberof Address6
     * @instance
     * @returns {Address4}
     * @example
     * var address = new Address6('2001:4860:4001::1825:bf11');
     * address.to4().correctForm(); // '24.37.191.17'
     */
    to4() {
      const f = this.binaryZeroPad().split("");
      return a.Address4.fromHex(BigInt(`0b${f.slice(96, 128).join("")}`).toString(16));
    }
    /**
     * Return the v4-in-v6 form of the address
     * @memberof Address6
     * @instance
     * @returns {String}
     */
    to4in6() {
      const f = this.to4(), y = new h(this.parsedAddress.slice(0, 6).join(":"), 6).correctForm();
      let m = "";
      return /:$/.test(y) || (m = ":"), y + m + f.address;
    }
    /**
     * Return an object containing the Teredo properties of the address
     * @memberof Address6
     * @instance
     * @returns {Object}
     */
    inspectTeredo() {
      const f = this.getBitsBase16(0, 32), y = (this.getBits(80, 96) ^ BigInt("0xffff")).toString(), m = a.Address4.fromHex(this.getBitsBase16(32, 64)), S = this.getBits(96, 128), w = a.Address4.fromHex((S ^ BigInt("0xffffffff")).toString(16)), F = this.getBitsBase2(64, 80), b = (0, u.testBit)(F, 15), G = (0, u.testBit)(F, 14), T = (0, u.testBit)(F, 8), K = (0, u.testBit)(F, 9), H = BigInt(`0b${F.slice(2, 6) + F.slice(8, 16)}`).toString(10);
      return {
        prefix: `${f.slice(0, 4)}:${f.slice(4, 8)}`,
        server4: m.address,
        client4: w.address,
        flags: F,
        coneNat: b,
        microsoft: {
          reserved: G,
          universalLocal: K,
          groupIndividual: T,
          nonce: H
        },
        udpPort: y
      };
    }
    /**
     * Return an object containing the 6to4 properties of the address
     * @memberof Address6
     * @instance
     * @returns {Object}
     */
    inspect6to4() {
      const f = this.getBitsBase16(0, 16), p = a.Address4.fromHex(this.getBitsBase16(16, 48));
      return {
        prefix: f.slice(0, 4),
        gateway: p.address
      };
    }
    /**
     * Return a v6 6to4 address from a v6 v4inv6 address
     * @memberof Address6
     * @instance
     * @returns {Address6}
     */
    to6to4() {
      if (!this.is4())
        return null;
      const f = [
        "2002",
        this.getBitsBase16(96, 112),
        this.getBitsBase16(112, 128),
        "",
        "/16"
      ].join(":");
      return new h(f);
    }
    /**
     * Return a byte array
     * @memberof Address6
     * @instance
     * @returns {Array}
     */
    toByteArray() {
      const f = this.bigInt().toString(16), y = `${"0".repeat(f.length % 2)}${f}`, m = [];
      for (let S = 0, w = y.length; S < w; S += 2)
        m.push(parseInt(y.substring(S, S + 2), 16));
      return m;
    }
    /**
     * Return an unsigned byte array
     * @memberof Address6
     * @instance
     * @returns {Array}
     */
    toUnsignedByteArray() {
      return this.toByteArray().map(B);
    }
    /**
     * Convert a byte array to an Address6 object
     * @memberof Address6
     * @static
     * @returns {Address6}
     */
    static fromByteArray(f) {
      return this.fromUnsignedByteArray(f.map(B));
    }
    /**
     * Convert an unsigned byte array to an Address6 object
     * @memberof Address6
     * @static
     * @returns {Address6}
     */
    static fromUnsignedByteArray(f) {
      const p = BigInt("256");
      let y = BigInt("0"), m = BigInt("1");
      for (let S = f.length - 1; S >= 0; S--)
        y += m * BigInt(f[S].toString(10)), m *= p;
      return h.fromBigInt(y);
    }
    /**
     * Returns true if the address is in the canonical form, false otherwise
     * @memberof Address6
     * @instance
     * @returns {boolean}
     */
    isCanonical() {
      return this.addressMinusSuffix === this.canonicalForm();
    }
    /**
     * Returns true if the address is a link local address, false otherwise
     * @memberof Address6
     * @instance
     * @returns {boolean}
     */
    isLinkLocal() {
      return this.getBitsBase2(0, 64) === "1111111010000000000000000000000000000000000000000000000000000000";
    }
    /**
     * Returns true if the address is a multicast address, false otherwise
     * @memberof Address6
     * @instance
     * @returns {boolean}
     */
    isMulticast() {
      return this.getType() === "Multicast";
    }
    /**
     * Returns true if the address is a v4-in-v6 address, false otherwise
     * @memberof Address6
     * @instance
     * @returns {boolean}
     */
    is4() {
      return this.v4;
    }
    /**
     * Returns true if the address is a Teredo address, false otherwise
     * @memberof Address6
     * @instance
     * @returns {boolean}
     */
    isTeredo() {
      return this.isInSubnet(new h("2001::/32"));
    }
    /**
     * Returns true if the address is a 6to4 address, false otherwise
     * @memberof Address6
     * @instance
     * @returns {boolean}
     */
    is6to4() {
      return this.isInSubnet(new h("2002::/16"));
    }
    /**
     * Returns true if the address is a loopback address, false otherwise
     * @memberof Address6
     * @instance
     * @returns {boolean}
     */
    isLoopback() {
      return this.getType() === "Loopback";
    }
    // #endregion
    // #region HTML
    /**
     * @returns {String} the address in link form with a default port of 80
     */
    href(f) {
      return f === void 0 ? f = "" : f = `:${f}`, `http://[${this.correctForm()}]${f}/`;
    }
    /**
     * @returns {String} a link suitable for conveying the address via a URL hash
     */
    link(f) {
      f || (f = {}), f.className === void 0 && (f.className = ""), f.prefix === void 0 && (f.prefix = "/#address="), f.v4 === void 0 && (f.v4 = !1);
      let p = this.correctForm;
      f.v4 && (p = this.to4in6);
      const y = p.call(this);
      return f.className ? `<a href="${f.prefix}${y}" class="${f.className}">${y}</a>` : `<a href="${f.prefix}${y}">${y}</a>`;
    }
    /**
     * Groups an address
     * @returns {String}
     */
    group() {
      if (this.elidedGroups === 0)
        return s.simpleGroup(this.address).join(":");
      I(typeof this.elidedGroups == "number"), I(typeof this.elisionBegin == "number");
      const f = [], [p, y] = this.address.split("::");
      p.length ? f.push(...s.simpleGroup(p)) : f.push("");
      const m = ["hover-group"];
      for (let S = this.elisionBegin; S < this.elisionBegin + this.elidedGroups; S++)
        m.push(`group-${S}`);
      return f.push(`<span class="${m.join(" ")}"></span>`), y.length ? f.push(...s.simpleGroup(y, this.elisionEnd)) : f.push(""), this.is4() && (I(this.address4 instanceof a.Address4), f.pop(), f.push(this.address4.groupForV6())), f.join(":");
    }
    // #endregion
    // #region Regular expressions
    /**
     * Generate a regular expression string that can be used to find or validate
     * all variations of this address
     * @memberof Address6
     * @instance
     * @param {boolean} substringSearch
     * @returns {string}
     */
    regularExpressionString(f = !1) {
      let p = [];
      const y = new h(this.correctForm());
      if (y.elidedGroups === 0)
        p.push((0, g.simpleRegularExpression)(y.parsedAddress));
      else if (y.elidedGroups === n.GROUPS)
        p.push((0, g.possibleElisions)(n.GROUPS));
      else {
        const m = y.address.split("::");
        m[0].length && p.push((0, g.simpleRegularExpression)(m[0].split(":"))), I(typeof y.elidedGroups == "number"), p.push((0, g.possibleElisions)(y.elidedGroups, m[0].length !== 0, m[1].length !== 0)), m[1].length && p.push((0, g.simpleRegularExpression)(m[1].split(":"))), p = [p.join(":")];
      }
      return f || (p = [
        "(?=^|",
        g.ADDRESS_BOUNDARY,
        "|[^\\w\\:])(",
        ...p,
        ")(?=[^\\w\\:]|",
        g.ADDRESS_BOUNDARY,
        "|$)"
      ]), p.join("");
    }
    /**
     * Generate a regular expression that can be used to find or validate all
     * variations of this address.
     * @memberof Address6
     * @instance
     * @param {boolean} substringSearch
     * @returns {RegExp}
     */
    regularExpression(f = !1) {
      return new RegExp(this.regularExpressionString(f), "i");
    }
  }
  return bI.Address6 = h, bI;
}
var GR;
function JT() {
  return GR || (GR = 1, function(t) {
    var A = W && W.__createBinding || (Object.create ? function(g, o, u, I) {
      I === void 0 && (I = u);
      var c = Object.getOwnPropertyDescriptor(o, u);
      (!c || ("get" in c ? !o.__esModule : c.writable || c.configurable)) && (c = { enumerable: !0, get: function() {
        return o[u];
      } }), Object.defineProperty(g, I, c);
    } : function(g, o, u, I) {
      I === void 0 && (I = u), g[I] = o[u];
    }), e = W && W.__setModuleDefault || (Object.create ? function(g, o) {
      Object.defineProperty(g, "default", { enumerable: !0, value: o });
    } : function(g, o) {
      g.default = o;
    }), r = W && W.__importStar || function(g) {
      if (g && g.__esModule) return g;
      var o = {};
      if (g != null) for (var u in g) u !== "default" && Object.prototype.hasOwnProperty.call(g, u) && A(o, g, u);
      return e(o, g), o;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.v6 = t.AddressError = t.Address6 = t.Address4 = void 0;
    var i = UT();
    Object.defineProperty(t, "Address4", { enumerable: !0, get: function() {
      return i.Address4;
    } });
    var n = IeA();
    Object.defineProperty(t, "Address6", { enumerable: !0, get: function() {
      return n.Address6;
    } });
    var s = TS();
    Object.defineProperty(t, "AddressError", { enumerable: !0, get: function() {
      return s.AddressError;
    } });
    const a = r(KT());
    t.v6 = { helpers: a };
  }(Jy)), Jy;
}
var UR;
function CeA() {
  if (UR) return wr;
  UR = 1, Object.defineProperty(wr, "__esModule", { value: !0 }), wr.ipToBuffer = wr.int32ToIpv4 = wr.ipv4ToInt32 = wr.validateSocksClientChainOptions = wr.validateSocksClientOptions = void 0;
  const t = xT(), A = LT(), e = Fn, r = JT(), i = yr;
  function n(E, l = ["connect", "bind", "associate"]) {
    if (!A.SocksCommand[E.command])
      throw new t.SocksClientError(A.ERRORS.InvalidSocksCommand, E);
    if (l.indexOf(E.command) === -1)
      throw new t.SocksClientError(A.ERRORS.InvalidSocksCommandForOperation, E);
    if (!g(E.destination))
      throw new t.SocksClientError(A.ERRORS.InvalidSocksClientOptionsDestination, E);
    if (!o(E.proxy))
      throw new t.SocksClientError(A.ERRORS.InvalidSocksClientOptionsProxy, E);
    if (a(E.proxy, E), E.timeout && !u(E.timeout))
      throw new t.SocksClientError(A.ERRORS.InvalidSocksClientOptionsTimeout, E);
    if (E.existing_socket && !(E.existing_socket instanceof e.Duplex))
      throw new t.SocksClientError(A.ERRORS.InvalidSocksClientOptionsExistingSocket, E);
  }
  wr.validateSocksClientOptions = n;
  function s(E) {
    if (E.command !== "connect")
      throw new t.SocksClientError(A.ERRORS.InvalidSocksCommandChain, E);
    if (!g(E.destination))
      throw new t.SocksClientError(A.ERRORS.InvalidSocksClientOptionsDestination, E);
    if (!(E.proxies && Array.isArray(E.proxies) && E.proxies.length >= 2))
      throw new t.SocksClientError(A.ERRORS.InvalidSocksClientOptionsProxiesLength, E);
    if (E.proxies.forEach((l) => {
      if (!o(l))
        throw new t.SocksClientError(A.ERRORS.InvalidSocksClientOptionsProxy, E);
      a(l, E);
    }), E.timeout && !u(E.timeout))
      throw new t.SocksClientError(A.ERRORS.InvalidSocksClientOptionsTimeout, E);
  }
  wr.validateSocksClientChainOptions = s;
  function a(E, l) {
    if (E.custom_auth_method !== void 0) {
      if (E.custom_auth_method < A.SOCKS5_CUSTOM_AUTH_START || E.custom_auth_method > A.SOCKS5_CUSTOM_AUTH_END)
        throw new t.SocksClientError(A.ERRORS.InvalidSocksClientOptionsCustomAuthRange, l);
      if (E.custom_auth_request_handler === void 0 || typeof E.custom_auth_request_handler != "function")
        throw new t.SocksClientError(A.ERRORS.InvalidSocksClientOptionsCustomAuthOptions, l);
      if (E.custom_auth_response_size === void 0)
        throw new t.SocksClientError(A.ERRORS.InvalidSocksClientOptionsCustomAuthOptions, l);
      if (E.custom_auth_response_handler === void 0 || typeof E.custom_auth_response_handler != "function")
        throw new t.SocksClientError(A.ERRORS.InvalidSocksClientOptionsCustomAuthOptions, l);
    }
  }
  function g(E) {
    return E && typeof E.host == "string" && Buffer.byteLength(E.host) < 256 && typeof E.port == "number" && E.port >= 0 && E.port <= 65535;
  }
  function o(E) {
    return E && (typeof E.host == "string" || typeof E.ipaddress == "string") && typeof E.port == "number" && E.port >= 0 && E.port <= 65535 && (E.type === 4 || E.type === 5);
  }
  function u(E) {
    return typeof E == "number" && E > 0;
  }
  function I(E) {
    return new r.Address4(E).toArray().reduce((B, h) => (B << 8) + h, 0) >>> 0;
  }
  wr.ipv4ToInt32 = I;
  function c(E) {
    const l = E >>> 24 & 255, B = E >>> 16 & 255, h = E >>> 8 & 255, Q = E & 255;
    return [l, B, h, Q].join(".");
  }
  wr.int32ToIpv4 = c;
  function C(E) {
    if (i.isIPv4(E)) {
      const l = new r.Address4(E);
      return Buffer.from(l.toArray());
    } else if (i.isIPv6(E)) {
      const l = new r.Address6(E);
      return Buffer.from(l.canonicalForm().split(":").map((B) => B.padStart(4, "0")).join(""), "hex");
    } else
      throw new Error("Invalid IP address format");
  }
  return wr.ipToBuffer = C, wr;
}
var MI = {}, TR;
function leA() {
  if (TR) return MI;
  TR = 1, Object.defineProperty(MI, "__esModule", { value: !0 }), MI.ReceiveBuffer = void 0;
  class t {
    constructor(e = 4096) {
      this.buffer = Buffer.allocUnsafe(e), this.offset = 0, this.originalSize = e;
    }
    get length() {
      return this.offset;
    }
    append(e) {
      if (!Buffer.isBuffer(e))
        throw new Error("Attempted to append a non-buffer instance to ReceiveBuffer.");
      if (this.offset + e.length >= this.buffer.length) {
        const r = this.buffer;
        this.buffer = Buffer.allocUnsafe(Math.max(this.buffer.length + this.originalSize, this.buffer.length + e.length)), r.copy(this.buffer);
      }
      return e.copy(this.buffer, this.offset), this.offset += e.length;
    }
    peek(e) {
      if (e > this.offset)
        throw new Error("Attempted to read beyond the bounds of the managed internal data.");
      return this.buffer.slice(0, e);
    }
    get(e) {
      if (e > this.offset)
        throw new Error("Attempted to read beyond the bounds of the managed internal data.");
      const r = Buffer.allocUnsafe(e);
      return this.buffer.slice(0, e).copy(r), this.buffer.copyWithin(0, e, e + this.offset - e), this.offset -= e, r;
    }
  }
  return MI.ReceiveBuffer = t, MI;
}
var KR;
function BeA() {
  return KR || (KR = 1, function(t) {
    var A = W && W.__awaiter || function(I, c, C, E) {
      function l(B) {
        return B instanceof C ? B : new C(function(h) {
          h(B);
        });
      }
      return new (C || (C = Promise))(function(B, h) {
        function Q(y) {
          try {
            p(E.next(y));
          } catch (m) {
            h(m);
          }
        }
        function f(y) {
          try {
            p(E.throw(y));
          } catch (m) {
            h(m);
          }
        }
        function p(y) {
          y.done ? B(y.value) : l(y.value).then(Q, f);
        }
        p((E = E.apply(I, c || [])).next());
      });
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.SocksClientError = t.SocksClient = void 0;
    const e = rI, r = yr, i = ueA(), n = LT(), s = CeA(), a = leA(), g = xT();
    Object.defineProperty(t, "SocksClientError", { enumerable: !0, get: function() {
      return g.SocksClientError;
    } });
    const o = JT();
    class u extends e.EventEmitter {
      constructor(c) {
        super(), this.options = Object.assign({}, c), (0, s.validateSocksClientOptions)(c), this.setState(n.SocksClientState.Created);
      }
      /**
       * Creates a new SOCKS connection.
       *
       * Note: Supports callbacks and promises. Only supports the connect command.
       * @param options { SocksClientOptions } Options.
       * @param callback { Function } An optional callback function.
       * @returns { Promise }
       */
      static createConnection(c, C) {
        return new Promise((E, l) => {
          try {
            (0, s.validateSocksClientOptions)(c, ["connect"]);
          } catch (h) {
            return typeof C == "function" ? (C(h), E(h)) : l(h);
          }
          const B = new u(c);
          B.connect(c.existing_socket), B.once("established", (h) => {
            B.removeAllListeners(), typeof C == "function" && C(null, h), E(h);
          }), B.once("error", (h) => {
            B.removeAllListeners(), typeof C == "function" ? (C(h), E(h)) : l(h);
          });
        });
      }
      /**
       * Creates a new SOCKS connection chain to a destination host through 2 or more SOCKS proxies.
       *
       * Note: Supports callbacks and promises. Only supports the connect method.
       * Note: Implemented via createConnection() factory function.
       * @param options { SocksClientChainOptions } Options
       * @param callback { Function } An optional callback function.
       * @returns { Promise }
       */
      static createConnectionChain(c, C) {
        return new Promise((E, l) => A(this, void 0, void 0, function* () {
          try {
            (0, s.validateSocksClientChainOptions)(c);
          } catch (B) {
            return typeof C == "function" ? (C(B), E(B)) : l(B);
          }
          c.randomizeChain && (0, g.shuffleArray)(c.proxies);
          try {
            let B;
            for (let h = 0; h < c.proxies.length; h++) {
              const Q = c.proxies[h], f = h === c.proxies.length - 1 ? c.destination : {
                host: c.proxies[h + 1].host || c.proxies[h + 1].ipaddress,
                port: c.proxies[h + 1].port
              }, p = yield u.createConnection({
                command: "connect",
                proxy: Q,
                destination: f,
                existing_socket: B
              });
              B = B || p.socket;
            }
            typeof C == "function" ? (C(null, { socket: B }), E({ socket: B })) : E({ socket: B });
          } catch (B) {
            typeof C == "function" ? (C(B), E(B)) : l(B);
          }
        }));
      }
      /**
       * Creates a SOCKS UDP Frame.
       * @param options
       */
      static createUDPFrame(c) {
        const C = new i.SmartBuffer();
        return C.writeUInt16BE(0), C.writeUInt8(c.frameNumber || 0), r.isIPv4(c.remoteHost.host) ? (C.writeUInt8(n.Socks5HostType.IPv4), C.writeUInt32BE((0, s.ipv4ToInt32)(c.remoteHost.host))) : r.isIPv6(c.remoteHost.host) ? (C.writeUInt8(n.Socks5HostType.IPv6), C.writeBuffer((0, s.ipToBuffer)(c.remoteHost.host))) : (C.writeUInt8(n.Socks5HostType.Hostname), C.writeUInt8(Buffer.byteLength(c.remoteHost.host)), C.writeString(c.remoteHost.host)), C.writeUInt16BE(c.remoteHost.port), C.writeBuffer(c.data), C.toBuffer();
      }
      /**
       * Parses a SOCKS UDP frame.
       * @param data
       */
      static parseUDPFrame(c) {
        const C = i.SmartBuffer.fromBuffer(c);
        C.readOffset = 2;
        const E = C.readUInt8(), l = C.readUInt8();
        let B;
        l === n.Socks5HostType.IPv4 ? B = (0, s.int32ToIpv4)(C.readUInt32BE()) : l === n.Socks5HostType.IPv6 ? B = o.Address6.fromByteArray(Array.from(C.readBuffer(16))).canonicalForm() : B = C.readString(C.readUInt8());
        const h = C.readUInt16BE();
        return {
          frameNumber: E,
          remoteHost: {
            host: B,
            port: h
          },
          data: C.readBuffer()
        };
      }
      /**
       * Internal state setter. If the SocksClient is in an error state, it cannot be changed to a non error state.
       */
      setState(c) {
        this.state !== n.SocksClientState.Error && (this.state = c);
      }
      /**
       * Starts the connection establishment to the proxy and destination.
       * @param existingSocket Connected socket to use instead of creating a new one (internal use).
       */
      connect(c) {
        this.onDataReceived = (E) => this.onDataReceivedHandler(E), this.onClose = () => this.onCloseHandler(), this.onError = (E) => this.onErrorHandler(E), this.onConnect = () => this.onConnectHandler();
        const C = setTimeout(() => this.onEstablishedTimeout(), this.options.timeout || n.DEFAULT_TIMEOUT);
        C.unref && typeof C.unref == "function" && C.unref(), c ? this.socket = c : this.socket = new r.Socket(), this.socket.once("close", this.onClose), this.socket.once("error", this.onError), this.socket.once("connect", this.onConnect), this.socket.on("data", this.onDataReceived), this.setState(n.SocksClientState.Connecting), this.receiveBuffer = new a.ReceiveBuffer(), c ? this.socket.emit("connect") : (this.socket.connect(this.getSocketOptions()), this.options.set_tcp_nodelay !== void 0 && this.options.set_tcp_nodelay !== null && this.socket.setNoDelay(!!this.options.set_tcp_nodelay)), this.prependOnceListener("established", (E) => {
          setImmediate(() => {
            if (this.receiveBuffer.length > 0) {
              const l = this.receiveBuffer.get(this.receiveBuffer.length);
              E.socket.emit("data", l);
            }
            E.socket.resume();
          });
        });
      }
      // Socket options (defaults host/port to options.proxy.host/options.proxy.port)
      getSocketOptions() {
        return Object.assign(Object.assign({}, this.options.socket_options), { host: this.options.proxy.host || this.options.proxy.ipaddress, port: this.options.proxy.port });
      }
      /**
       * Handles internal Socks timeout callback.
       * Note: If the Socks client is not BoundWaitingForConnection or Established, the connection will be closed.
       */
      onEstablishedTimeout() {
        this.state !== n.SocksClientState.Established && this.state !== n.SocksClientState.BoundWaitingForConnection && this.closeSocket(n.ERRORS.ProxyConnectionTimedOut);
      }
      /**
       * Handles Socket connect event.
       */
      onConnectHandler() {
        this.setState(n.SocksClientState.Connected), this.options.proxy.type === 4 ? this.sendSocks4InitialHandshake() : this.sendSocks5InitialHandshake(), this.setState(n.SocksClientState.SentInitialHandshake);
      }
      /**
       * Handles Socket data event.
       * @param data
       */
      onDataReceivedHandler(c) {
        this.receiveBuffer.append(c), this.processData();
      }
      /**
       * Handles processing of the data we have received.
       */
      processData() {
        for (; this.state !== n.SocksClientState.Established && this.state !== n.SocksClientState.Error && this.receiveBuffer.length >= this.nextRequiredPacketBufferSize; )
          if (this.state === n.SocksClientState.SentInitialHandshake)
            this.options.proxy.type === 4 ? this.handleSocks4FinalHandshakeResponse() : this.handleInitialSocks5HandshakeResponse();
          else if (this.state === n.SocksClientState.SentAuthentication)
            this.handleInitialSocks5AuthenticationHandshakeResponse();
          else if (this.state === n.SocksClientState.SentFinalHandshake)
            this.handleSocks5FinalHandshakeResponse();
          else if (this.state === n.SocksClientState.BoundWaitingForConnection)
            this.options.proxy.type === 4 ? this.handleSocks4IncomingConnectionResponse() : this.handleSocks5IncomingConnectionResponse();
          else {
            this.closeSocket(n.ERRORS.InternalError);
            break;
          }
      }
      /**
       * Handles Socket close event.
       * @param had_error
       */
      onCloseHandler() {
        this.closeSocket(n.ERRORS.SocketClosed);
      }
      /**
       * Handles Socket error event.
       * @param err
       */
      onErrorHandler(c) {
        this.closeSocket(c.message);
      }
      /**
       * Removes internal event listeners on the underlying Socket.
       */
      removeInternalSocketHandlers() {
        this.socket.pause(), this.socket.removeListener("data", this.onDataReceived), this.socket.removeListener("close", this.onClose), this.socket.removeListener("error", this.onError), this.socket.removeListener("connect", this.onConnect);
      }
      /**
       * Closes and destroys the underlying Socket. Emits an error event.
       * @param err { String } An error string to include in error event.
       */
      closeSocket(c) {
        this.state !== n.SocksClientState.Error && (this.setState(n.SocksClientState.Error), this.socket.destroy(), this.removeInternalSocketHandlers(), this.emit("error", new g.SocksClientError(c, this.options)));
      }
      /**
       * Sends initial Socks v4 handshake request.
       */
      sendSocks4InitialHandshake() {
        const c = this.options.proxy.userId || "", C = new i.SmartBuffer();
        C.writeUInt8(4), C.writeUInt8(n.SocksCommand[this.options.command]), C.writeUInt16BE(this.options.destination.port), r.isIPv4(this.options.destination.host) ? (C.writeBuffer((0, s.ipToBuffer)(this.options.destination.host)), C.writeStringNT(c)) : (C.writeUInt8(0), C.writeUInt8(0), C.writeUInt8(0), C.writeUInt8(1), C.writeStringNT(c), C.writeStringNT(this.options.destination.host)), this.nextRequiredPacketBufferSize = n.SOCKS_INCOMING_PACKET_SIZES.Socks4Response, this.socket.write(C.toBuffer());
      }
      /**
       * Handles Socks v4 handshake response.
       * @param data
       */
      handleSocks4FinalHandshakeResponse() {
        const c = this.receiveBuffer.get(8);
        if (c[1] !== n.Socks4Response.Granted)
          this.closeSocket(`${n.ERRORS.Socks4ProxyRejectedConnection} - (${n.Socks4Response[c[1]]})`);
        else if (n.SocksCommand[this.options.command] === n.SocksCommand.bind) {
          const C = i.SmartBuffer.fromBuffer(c);
          C.readOffset = 2;
          const E = {
            port: C.readUInt16BE(),
            host: (0, s.int32ToIpv4)(C.readUInt32BE())
          };
          E.host === "0.0.0.0" && (E.host = this.options.proxy.ipaddress), this.setState(n.SocksClientState.BoundWaitingForConnection), this.emit("bound", { remoteHost: E, socket: this.socket });
        } else
          this.setState(n.SocksClientState.Established), this.removeInternalSocketHandlers(), this.emit("established", { socket: this.socket });
      }
      /**
       * Handles Socks v4 incoming connection request (BIND)
       * @param data
       */
      handleSocks4IncomingConnectionResponse() {
        const c = this.receiveBuffer.get(8);
        if (c[1] !== n.Socks4Response.Granted)
          this.closeSocket(`${n.ERRORS.Socks4ProxyRejectedIncomingBoundConnection} - (${n.Socks4Response[c[1]]})`);
        else {
          const C = i.SmartBuffer.fromBuffer(c);
          C.readOffset = 2;
          const E = {
            port: C.readUInt16BE(),
            host: (0, s.int32ToIpv4)(C.readUInt32BE())
          };
          this.setState(n.SocksClientState.Established), this.removeInternalSocketHandlers(), this.emit("established", { remoteHost: E, socket: this.socket });
        }
      }
      /**
       * Sends initial Socks v5 handshake request.
       */
      sendSocks5InitialHandshake() {
        const c = new i.SmartBuffer(), C = [n.Socks5Auth.NoAuth];
        (this.options.proxy.userId || this.options.proxy.password) && C.push(n.Socks5Auth.UserPass), this.options.proxy.custom_auth_method !== void 0 && C.push(this.options.proxy.custom_auth_method), c.writeUInt8(5), c.writeUInt8(C.length);
        for (const E of C)
          c.writeUInt8(E);
        this.nextRequiredPacketBufferSize = n.SOCKS_INCOMING_PACKET_SIZES.Socks5InitialHandshakeResponse, this.socket.write(c.toBuffer()), this.setState(n.SocksClientState.SentInitialHandshake);
      }
      /**
       * Handles initial Socks v5 handshake response.
       * @param data
       */
      handleInitialSocks5HandshakeResponse() {
        const c = this.receiveBuffer.get(2);
        c[0] !== 5 ? this.closeSocket(n.ERRORS.InvalidSocks5IntiailHandshakeSocksVersion) : c[1] === n.SOCKS5_NO_ACCEPTABLE_AUTH ? this.closeSocket(n.ERRORS.InvalidSocks5InitialHandshakeNoAcceptedAuthType) : c[1] === n.Socks5Auth.NoAuth ? (this.socks5ChosenAuthType = n.Socks5Auth.NoAuth, this.sendSocks5CommandRequest()) : c[1] === n.Socks5Auth.UserPass ? (this.socks5ChosenAuthType = n.Socks5Auth.UserPass, this.sendSocks5UserPassAuthentication()) : c[1] === this.options.proxy.custom_auth_method ? (this.socks5ChosenAuthType = this.options.proxy.custom_auth_method, this.sendSocks5CustomAuthentication()) : this.closeSocket(n.ERRORS.InvalidSocks5InitialHandshakeUnknownAuthType);
      }
      /**
       * Sends Socks v5 user & password auth handshake.
       *
       * Note: No auth and user/pass are currently supported.
       */
      sendSocks5UserPassAuthentication() {
        const c = this.options.proxy.userId || "", C = this.options.proxy.password || "", E = new i.SmartBuffer();
        E.writeUInt8(1), E.writeUInt8(Buffer.byteLength(c)), E.writeString(c), E.writeUInt8(Buffer.byteLength(C)), E.writeString(C), this.nextRequiredPacketBufferSize = n.SOCKS_INCOMING_PACKET_SIZES.Socks5UserPassAuthenticationResponse, this.socket.write(E.toBuffer()), this.setState(n.SocksClientState.SentAuthentication);
      }
      sendSocks5CustomAuthentication() {
        return A(this, void 0, void 0, function* () {
          this.nextRequiredPacketBufferSize = this.options.proxy.custom_auth_response_size, this.socket.write(yield this.options.proxy.custom_auth_request_handler()), this.setState(n.SocksClientState.SentAuthentication);
        });
      }
      handleSocks5CustomAuthHandshakeResponse(c) {
        return A(this, void 0, void 0, function* () {
          return yield this.options.proxy.custom_auth_response_handler(c);
        });
      }
      handleSocks5AuthenticationNoAuthHandshakeResponse(c) {
        return A(this, void 0, void 0, function* () {
          return c[1] === 0;
        });
      }
      handleSocks5AuthenticationUserPassHandshakeResponse(c) {
        return A(this, void 0, void 0, function* () {
          return c[1] === 0;
        });
      }
      /**
       * Handles Socks v5 auth handshake response.
       * @param data
       */
      handleInitialSocks5AuthenticationHandshakeResponse() {
        return A(this, void 0, void 0, function* () {
          this.setState(n.SocksClientState.ReceivedAuthenticationResponse);
          let c = !1;
          this.socks5ChosenAuthType === n.Socks5Auth.NoAuth ? c = yield this.handleSocks5AuthenticationNoAuthHandshakeResponse(this.receiveBuffer.get(2)) : this.socks5ChosenAuthType === n.Socks5Auth.UserPass ? c = yield this.handleSocks5AuthenticationUserPassHandshakeResponse(this.receiveBuffer.get(2)) : this.socks5ChosenAuthType === this.options.proxy.custom_auth_method && (c = yield this.handleSocks5CustomAuthHandshakeResponse(this.receiveBuffer.get(this.options.proxy.custom_auth_response_size))), c ? this.sendSocks5CommandRequest() : this.closeSocket(n.ERRORS.Socks5AuthenticationFailed);
        });
      }
      /**
       * Sends Socks v5 final handshake request.
       */
      sendSocks5CommandRequest() {
        const c = new i.SmartBuffer();
        c.writeUInt8(5), c.writeUInt8(n.SocksCommand[this.options.command]), c.writeUInt8(0), r.isIPv4(this.options.destination.host) ? (c.writeUInt8(n.Socks5HostType.IPv4), c.writeBuffer((0, s.ipToBuffer)(this.options.destination.host))) : r.isIPv6(this.options.destination.host) ? (c.writeUInt8(n.Socks5HostType.IPv6), c.writeBuffer((0, s.ipToBuffer)(this.options.destination.host))) : (c.writeUInt8(n.Socks5HostType.Hostname), c.writeUInt8(this.options.destination.host.length), c.writeString(this.options.destination.host)), c.writeUInt16BE(this.options.destination.port), this.nextRequiredPacketBufferSize = n.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseHeader, this.socket.write(c.toBuffer()), this.setState(n.SocksClientState.SentFinalHandshake);
      }
      /**
       * Handles Socks v5 final handshake response.
       * @param data
       */
      handleSocks5FinalHandshakeResponse() {
        const c = this.receiveBuffer.peek(5);
        if (c[0] !== 5 || c[1] !== n.Socks5Response.Granted)
          this.closeSocket(`${n.ERRORS.InvalidSocks5FinalHandshakeRejected} - ${n.Socks5Response[c[1]]}`);
        else {
          const C = c[3];
          let E, l;
          if (C === n.Socks5HostType.IPv4) {
            const B = n.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseIPv4;
            if (this.receiveBuffer.length < B) {
              this.nextRequiredPacketBufferSize = B;
              return;
            }
            l = i.SmartBuffer.fromBuffer(this.receiveBuffer.get(B).slice(4)), E = {
              host: (0, s.int32ToIpv4)(l.readUInt32BE()),
              port: l.readUInt16BE()
            }, E.host === "0.0.0.0" && (E.host = this.options.proxy.ipaddress);
          } else if (C === n.Socks5HostType.Hostname) {
            const B = c[4], h = n.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseHostname(B);
            if (this.receiveBuffer.length < h) {
              this.nextRequiredPacketBufferSize = h;
              return;
            }
            l = i.SmartBuffer.fromBuffer(this.receiveBuffer.get(h).slice(5)), E = {
              host: l.readString(B),
              port: l.readUInt16BE()
            };
          } else if (C === n.Socks5HostType.IPv6) {
            const B = n.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseIPv6;
            if (this.receiveBuffer.length < B) {
              this.nextRequiredPacketBufferSize = B;
              return;
            }
            l = i.SmartBuffer.fromBuffer(this.receiveBuffer.get(B).slice(4)), E = {
              host: o.Address6.fromByteArray(Array.from(l.readBuffer(16))).canonicalForm(),
              port: l.readUInt16BE()
            };
          }
          this.setState(n.SocksClientState.ReceivedFinalResponse), n.SocksCommand[this.options.command] === n.SocksCommand.connect ? (this.setState(n.SocksClientState.Established), this.removeInternalSocketHandlers(), this.emit("established", { remoteHost: E, socket: this.socket })) : n.SocksCommand[this.options.command] === n.SocksCommand.bind ? (this.setState(n.SocksClientState.BoundWaitingForConnection), this.nextRequiredPacketBufferSize = n.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseHeader, this.emit("bound", { remoteHost: E, socket: this.socket })) : n.SocksCommand[this.options.command] === n.SocksCommand.associate && (this.setState(n.SocksClientState.Established), this.removeInternalSocketHandlers(), this.emit("established", {
            remoteHost: E,
            socket: this.socket
          }));
        }
      }
      /**
       * Handles Socks v5 incoming connection request (BIND).
       */
      handleSocks5IncomingConnectionResponse() {
        const c = this.receiveBuffer.peek(5);
        if (c[0] !== 5 || c[1] !== n.Socks5Response.Granted)
          this.closeSocket(`${n.ERRORS.Socks5ProxyRejectedIncomingBoundConnection} - ${n.Socks5Response[c[1]]}`);
        else {
          const C = c[3];
          let E, l;
          if (C === n.Socks5HostType.IPv4) {
            const B = n.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseIPv4;
            if (this.receiveBuffer.length < B) {
              this.nextRequiredPacketBufferSize = B;
              return;
            }
            l = i.SmartBuffer.fromBuffer(this.receiveBuffer.get(B).slice(4)), E = {
              host: (0, s.int32ToIpv4)(l.readUInt32BE()),
              port: l.readUInt16BE()
            }, E.host === "0.0.0.0" && (E.host = this.options.proxy.ipaddress);
          } else if (C === n.Socks5HostType.Hostname) {
            const B = c[4], h = n.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseHostname(B);
            if (this.receiveBuffer.length < h) {
              this.nextRequiredPacketBufferSize = h;
              return;
            }
            l = i.SmartBuffer.fromBuffer(this.receiveBuffer.get(h).slice(5)), E = {
              host: l.readString(B),
              port: l.readUInt16BE()
            };
          } else if (C === n.Socks5HostType.IPv6) {
            const B = n.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseIPv6;
            if (this.receiveBuffer.length < B) {
              this.nextRequiredPacketBufferSize = B;
              return;
            }
            l = i.SmartBuffer.fromBuffer(this.receiveBuffer.get(B).slice(4)), E = {
              host: o.Address6.fromByteArray(Array.from(l.readBuffer(16))).canonicalForm(),
              port: l.readUInt16BE()
            };
          }
          this.setState(n.SocksClientState.Established), this.removeInternalSocketHandlers(), this.emit("established", { remoteHost: E, socket: this.socket });
        }
      }
      get socksClientOptions() {
        return Object.assign({}, this.options);
      }
    }
    t.SocksClient = u;
  }(Ky)), Ky;
}
var JR;
function EeA() {
  return JR || (JR = 1, function(t) {
    var A = W && W.__createBinding || (Object.create ? function(r, i, n, s) {
      s === void 0 && (s = n);
      var a = Object.getOwnPropertyDescriptor(i, n);
      (!a || ("get" in a ? !i.__esModule : a.writable || a.configurable)) && (a = { enumerable: !0, get: function() {
        return i[n];
      } }), Object.defineProperty(r, s, a);
    } : function(r, i, n, s) {
      s === void 0 && (s = n), r[s] = i[n];
    }), e = W && W.__exportStar || function(r, i) {
      for (var n in r) n !== "default" && !Object.prototype.hasOwnProperty.call(i, n) && A(i, r, n);
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), e(BeA(), t);
  }(Ty)), Ty;
}
var Hy = {}, Nn = {}, HR;
function heA() {
  if (HR) return Nn;
  HR = 1;
  var t = W && W.__createBinding || (Object.create ? function(g, o, u, I) {
    I === void 0 && (I = u);
    var c = Object.getOwnPropertyDescriptor(o, u);
    (!c || ("get" in c ? !o.__esModule : c.writable || c.configurable)) && (c = { enumerable: !0, get: function() {
      return o[u];
    } }), Object.defineProperty(g, I, c);
  } : function(g, o, u, I) {
    I === void 0 && (I = u), g[I] = o[u];
  }), A = W && W.__setModuleDefault || (Object.create ? function(g, o) {
    Object.defineProperty(g, "default", { enumerable: !0, value: o });
  } : function(g, o) {
    g.default = o;
  }), e = W && W.__importStar || function(g) {
    if (g && g.__esModule) return g;
    var o = {};
    if (g != null) for (var u in g) u !== "default" && Object.prototype.hasOwnProperty.call(g, u) && t(o, g, u);
    return A(o, g), o;
  };
  Object.defineProperty(Nn, "__esModule", { value: !0 }), Nn.req = Nn.json = Nn.toBuffer = void 0;
  const r = e(wn), i = e(mn);
  async function n(g) {
    let o = 0;
    const u = [];
    for await (const I of g)
      o += I.length, u.push(I);
    return Buffer.concat(u, o);
  }
  Nn.toBuffer = n;
  async function s(g) {
    const u = (await n(g)).toString("utf8");
    try {
      return JSON.parse(u);
    } catch (I) {
      const c = I;
      throw c.message += ` (input: ${u})`, c;
    }
  }
  Nn.json = s;
  function a(g, o = {}) {
    const I = ((typeof g == "string" ? g : g.href).startsWith("https:") ? i : r).request(g, o), c = new Promise((C, E) => {
      I.once("response", C).once("error", E).end();
    });
    return I.then = c.then.bind(c), I;
  }
  return Nn.req = a, Nn;
}
var PR;
function QeA() {
  return PR || (PR = 1, function(t) {
    var A = W && W.__createBinding || (Object.create ? function(u, I, c, C) {
      C === void 0 && (C = c);
      var E = Object.getOwnPropertyDescriptor(I, c);
      (!E || ("get" in E ? !I.__esModule : E.writable || E.configurable)) && (E = { enumerable: !0, get: function() {
        return I[c];
      } }), Object.defineProperty(u, C, E);
    } : function(u, I, c, C) {
      C === void 0 && (C = c), u[C] = I[c];
    }), e = W && W.__setModuleDefault || (Object.create ? function(u, I) {
      Object.defineProperty(u, "default", { enumerable: !0, value: I });
    } : function(u, I) {
      u.default = I;
    }), r = W && W.__importStar || function(u) {
      if (u && u.__esModule) return u;
      var I = {};
      if (u != null) for (var c in u) c !== "default" && Object.prototype.hasOwnProperty.call(u, c) && A(I, u, c);
      return e(I, u), I;
    }, i = W && W.__exportStar || function(u, I) {
      for (var c in u) c !== "default" && !Object.prototype.hasOwnProperty.call(I, c) && A(I, u, c);
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.Agent = void 0;
    const n = r(yr), s = r(wn), a = mn;
    i(heA(), t);
    const g = Symbol("AgentBaseInternalState");
    class o extends s.Agent {
      constructor(I) {
        super(I), this[g] = {};
      }
      /**
       * Determine whether this is an `http` or `https` request.
       */
      isSecureEndpoint(I) {
        if (I) {
          if (typeof I.secureEndpoint == "boolean")
            return I.secureEndpoint;
          if (typeof I.protocol == "string")
            return I.protocol === "https:";
        }
        const { stack: c } = new Error();
        return typeof c != "string" ? !1 : c.split(`
`).some((C) => C.indexOf("(https.js:") !== -1 || C.indexOf("node:https:") !== -1);
      }
      // In order to support async signatures in `connect()` and Node's native
      // connection pooling in `http.Agent`, the array of sockets for each origin
      // has to be updated synchronously. This is so the length of the array is
      // accurate when `addRequest()` is next called. We achieve this by creating a
      // fake socket and adding it to `sockets[origin]` and incrementing
      // `totalSocketCount`.
      incrementSockets(I) {
        if (this.maxSockets === 1 / 0 && this.maxTotalSockets === 1 / 0)
          return null;
        this.sockets[I] || (this.sockets[I] = []);
        const c = new n.Socket({ writable: !1 });
        return this.sockets[I].push(c), this.totalSocketCount++, c;
      }
      decrementSockets(I, c) {
        if (!this.sockets[I] || c === null)
          return;
        const C = this.sockets[I], E = C.indexOf(c);
        E !== -1 && (C.splice(E, 1), this.totalSocketCount--, C.length === 0 && delete this.sockets[I]);
      }
      // In order to properly update the socket pool, we need to call `getName()` on
      // the core `https.Agent` if it is a secureEndpoint.
      getName(I) {
        return this.isSecureEndpoint(I) ? a.Agent.prototype.getName.call(this, I) : super.getName(I);
      }
      createSocket(I, c, C) {
        const E = {
          ...c,
          secureEndpoint: this.isSecureEndpoint(c)
        }, l = this.getName(E), B = this.incrementSockets(l);
        Promise.resolve().then(() => this.connect(I, E)).then((h) => {
          if (this.decrementSockets(l, B), h instanceof s.Agent)
            try {
              return h.addRequest(I, E);
            } catch (Q) {
              return C(Q);
            }
          this[g].currentSocket = h, super.createSocket(I, c, C);
        }, (h) => {
          this.decrementSockets(l, B), C(h);
        });
      }
      createConnection() {
        const I = this[g].currentSocket;
        if (this[g].currentSocket = void 0, !I)
          throw new Error("No socket was returned in the `connect()` function");
        return I;
      }
      get defaultPort() {
        return this[g].defaultPort ?? (this.protocol === "https:" ? 443 : 80);
      }
      set defaultPort(I) {
        this[g] && (this[g].defaultPort = I);
      }
      get protocol() {
        return this[g].protocol ?? (this.isSecureEndpoint() ? "https:" : "http:");
      }
      set protocol(I) {
        this[g] && (this[g].protocol = I);
      }
    }
    t.Agent = o;
  }(Hy)), Hy;
}
var OR;
function UD() {
  if (OR) return kI;
  OR = 1;
  var t = W && W.__createBinding || (Object.create ? function(B, h, Q, f) {
    f === void 0 && (f = Q);
    var p = Object.getOwnPropertyDescriptor(h, Q);
    (!p || ("get" in p ? !h.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {
      return h[Q];
    } }), Object.defineProperty(B, f, p);
  } : function(B, h, Q, f) {
    f === void 0 && (f = Q), B[f] = h[Q];
  }), A = W && W.__setModuleDefault || (Object.create ? function(B, h) {
    Object.defineProperty(B, "default", { enumerable: !0, value: h });
  } : function(B, h) {
    B.default = h;
  }), e = W && W.__importStar || function(B) {
    if (B && B.__esModule) return B;
    var h = {};
    if (B != null) for (var Q in B) Q !== "default" && Object.prototype.hasOwnProperty.call(B, Q) && t(h, B, Q);
    return A(h, B), h;
  }, r = W && W.__importDefault || function(B) {
    return B && B.__esModule ? B : { default: B };
  };
  Object.defineProperty(kI, "__esModule", { value: !0 }), kI.SocksProxyAgent = void 0;
  const i = EeA(), n = QeA(), s = r(Ir), a = e(M_), g = e(yr), o = e(Sn), u = Dn, I = (0, s.default)("socks-proxy-agent"), c = (B) => B.servername === void 0 && B.host && !g.isIP(B.host) ? {
    ...B,
    servername: B.host
  } : B;
  function C(B) {
    let h = !1, Q = 5;
    const f = B.hostname, p = parseInt(B.port, 10) || 1080;
    switch (B.protocol.replace(":", "")) {
      case "socks4":
        h = !0, Q = 4;
        break;
      case "socks4a":
        Q = 4;
        break;
      case "socks5":
        h = !0, Q = 5;
        break;
      case "socks":
        Q = 5;
        break;
      case "socks5h":
        Q = 5;
        break;
      default:
        throw new TypeError(`A "socks" protocol must be specified! Got: ${String(B.protocol)}`);
    }
    const y = {
      host: f,
      port: p,
      type: Q
    };
    return B.username && Object.defineProperty(y, "userId", {
      value: decodeURIComponent(B.username),
      enumerable: !1
    }), B.password != null && Object.defineProperty(y, "password", {
      value: decodeURIComponent(B.password),
      enumerable: !1
    }), { lookup: h, proxy: y };
  }
  class E extends n.Agent {
    constructor(h, Q) {
      super(Q);
      const f = typeof h == "string" ? new u.URL(h) : h, { proxy: p, lookup: y } = C(f);
      this.shouldLookup = y, this.proxy = p, this.timeout = (Q == null ? void 0 : Q.timeout) ?? null, this.socketOptions = (Q == null ? void 0 : Q.socketOptions) ?? null;
    }
    /**
     * Initiates a SOCKS connection to the specified SOCKS proxy server,
     * which in turn connects to the specified remote host and port.
     */
    async connect(h, Q) {
      const { shouldLookup: f, proxy: p, timeout: y } = this;
      if (!Q.host)
        throw new Error("No `host` defined!");
      let { host: m } = Q;
      const { port: S, lookup: w = a.lookup } = Q;
      f && (m = await new Promise((T, K) => {
        w(m, {}, (H, j) => {
          H ? K(H) : T(j);
        });
      }));
      const F = {
        proxy: p,
        destination: {
          host: m,
          port: typeof S == "number" ? S : parseInt(S, 10)
        },
        command: "connect",
        timeout: y ?? void 0,
        // @ts-expect-error the type supplied by socks for socket_options is wider
        // than necessary since socks will always override the host and port
        socket_options: this.socketOptions ?? void 0
      }, b = (T) => {
        h.destroy(), G.destroy(), T && T.destroy();
      };
      I("Creating socks proxy connection: %o", F);
      const { socket: G } = await i.SocksClient.createConnection(F);
      if (I("Successfully created socks proxy connection"), y !== null && (G.setTimeout(y), G.on("timeout", () => b())), Q.secureEndpoint) {
        I("Upgrading socket connection to TLS");
        const T = o.connect({
          ...l(c(Q), "host", "path", "port"),
          socket: G
        });
        return T.once("error", (K) => {
          I("Socket TLS error", K.message), b(T);
        }), T;
      }
      return G;
    }
  }
  E.protocols = [
    "socks",
    "socks4",
    "socks4a",
    "socks5",
    "socks5h"
  ], kI.SocksProxyAgent = E;
  function l(B, ...h) {
    const Q = {};
    let f;
    for (f in B)
      h.includes(f) || (Q[f] = B[f]);
    return Q;
  }
  return kI;
}
var _I = {}, Py = {}, Ln = {}, YR;
function deA() {
  if (YR) return Ln;
  YR = 1;
  var t = W && W.__createBinding || (Object.create ? function(g, o, u, I) {
    I === void 0 && (I = u);
    var c = Object.getOwnPropertyDescriptor(o, u);
    (!c || ("get" in c ? !o.__esModule : c.writable || c.configurable)) && (c = { enumerable: !0, get: function() {
      return o[u];
    } }), Object.defineProperty(g, I, c);
  } : function(g, o, u, I) {
    I === void 0 && (I = u), g[I] = o[u];
  }), A = W && W.__setModuleDefault || (Object.create ? function(g, o) {
    Object.defineProperty(g, "default", { enumerable: !0, value: o });
  } : function(g, o) {
    g.default = o;
  }), e = W && W.__importStar || function(g) {
    if (g && g.__esModule) return g;
    var o = {};
    if (g != null) for (var u in g) u !== "default" && Object.prototype.hasOwnProperty.call(g, u) && t(o, g, u);
    return A(o, g), o;
  };
  Object.defineProperty(Ln, "__esModule", { value: !0 }), Ln.req = Ln.json = Ln.toBuffer = void 0;
  const r = e(wn), i = e(mn);
  async function n(g) {
    let o = 0;
    const u = [];
    for await (const I of g)
      o += I.length, u.push(I);
    return Buffer.concat(u, o);
  }
  Ln.toBuffer = n;
  async function s(g) {
    const u = (await n(g)).toString("utf8");
    try {
      return JSON.parse(u);
    } catch (I) {
      const c = I;
      throw c.message += ` (input: ${u})`, c;
    }
  }
  Ln.json = s;
  function a(g, o = {}) {
    const I = ((typeof g == "string" ? g : g.href).startsWith("https:") ? i : r).request(g, o), c = new Promise((C, E) => {
      I.once("response", C).once("error", E).end();
    });
    return I.then = c.then.bind(c), I;
  }
  return Ln.req = a, Ln;
}
var qR;
function KS() {
  return qR || (qR = 1, function(t) {
    var A = W && W.__createBinding || (Object.create ? function(u, I, c, C) {
      C === void 0 && (C = c);
      var E = Object.getOwnPropertyDescriptor(I, c);
      (!E || ("get" in E ? !I.__esModule : E.writable || E.configurable)) && (E = { enumerable: !0, get: function() {
        return I[c];
      } }), Object.defineProperty(u, C, E);
    } : function(u, I, c, C) {
      C === void 0 && (C = c), u[C] = I[c];
    }), e = W && W.__setModuleDefault || (Object.create ? function(u, I) {
      Object.defineProperty(u, "default", { enumerable: !0, value: I });
    } : function(u, I) {
      u.default = I;
    }), r = W && W.__importStar || function(u) {
      if (u && u.__esModule) return u;
      var I = {};
      if (u != null) for (var c in u) c !== "default" && Object.prototype.hasOwnProperty.call(u, c) && A(I, u, c);
      return e(I, u), I;
    }, i = W && W.__exportStar || function(u, I) {
      for (var c in u) c !== "default" && !Object.prototype.hasOwnProperty.call(I, c) && A(I, u, c);
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.Agent = void 0;
    const n = r(yr), s = r(wn), a = mn;
    i(deA(), t);
    const g = Symbol("AgentBaseInternalState");
    class o extends s.Agent {
      constructor(I) {
        super(I), this[g] = {};
      }
      /**
       * Determine whether this is an `http` or `https` request.
       */
      isSecureEndpoint(I) {
        if (I) {
          if (typeof I.secureEndpoint == "boolean")
            return I.secureEndpoint;
          if (typeof I.protocol == "string")
            return I.protocol === "https:";
        }
        const { stack: c } = new Error();
        return typeof c != "string" ? !1 : c.split(`
`).some((C) => C.indexOf("(https.js:") !== -1 || C.indexOf("node:https:") !== -1);
      }
      // In order to support async signatures in `connect()` and Node's native
      // connection pooling in `http.Agent`, the array of sockets for each origin
      // has to be updated synchronously. This is so the length of the array is
      // accurate when `addRequest()` is next called. We achieve this by creating a
      // fake socket and adding it to `sockets[origin]` and incrementing
      // `totalSocketCount`.
      incrementSockets(I) {
        if (this.maxSockets === 1 / 0 && this.maxTotalSockets === 1 / 0)
          return null;
        this.sockets[I] || (this.sockets[I] = []);
        const c = new n.Socket({ writable: !1 });
        return this.sockets[I].push(c), this.totalSocketCount++, c;
      }
      decrementSockets(I, c) {
        if (!this.sockets[I] || c === null)
          return;
        const C = this.sockets[I], E = C.indexOf(c);
        E !== -1 && (C.splice(E, 1), this.totalSocketCount--, C.length === 0 && delete this.sockets[I]);
      }
      // In order to properly update the socket pool, we need to call `getName()` on
      // the core `https.Agent` if it is a secureEndpoint.
      getName(I) {
        return this.isSecureEndpoint(I) ? a.Agent.prototype.getName.call(this, I) : super.getName(I);
      }
      createSocket(I, c, C) {
        const E = {
          ...c,
          secureEndpoint: this.isSecureEndpoint(c)
        }, l = this.getName(E), B = this.incrementSockets(l);
        Promise.resolve().then(() => this.connect(I, E)).then((h) => {
          if (this.decrementSockets(l, B), h instanceof s.Agent)
            try {
              return h.addRequest(I, E);
            } catch (Q) {
              return C(Q);
            }
          this[g].currentSocket = h, super.createSocket(I, c, C);
        }, (h) => {
          this.decrementSockets(l, B), C(h);
        });
      }
      createConnection() {
        const I = this[g].currentSocket;
        if (this[g].currentSocket = void 0, !I)
          throw new Error("No socket was returned in the `connect()` function");
        return I;
      }
      get defaultPort() {
        return this[g].defaultPort ?? (this.protocol === "https:" ? 443 : 80);
      }
      set defaultPort(I) {
        this[g] && (this[g].defaultPort = I);
      }
      get protocol() {
        return this[g].protocol ?? (this.isSecureEndpoint() ? "https:" : "http:");
      }
      set protocol(I) {
        this[g] && (this[g].protocol = I);
      }
    }
    t.Agent = o;
  }(Py)), Py;
}
var Oy = {}, NI = {}, LI = {}, xI = {}, jR;
function feA() {
  if (jR) return xI;
  jR = 1, Object.defineProperty(xI, "__esModule", { value: !0 }), xI.makeDataUriToBuffer = void 0;
  const t = (A) => (e) => {
    if (e = String(e), !/^data:/i.test(e))
      throw new TypeError('`uri` does not appear to be a Data URI (must begin with "data:")');
    e = e.replace(/\r?\n/g, "");
    const r = e.indexOf(",");
    if (r === -1 || r <= 4)
      throw new TypeError("malformed data: URI");
    const i = e.substring(5, r).split(";");
    let n = "", s = !1;
    const a = i[0] || "text/plain";
    let g = a;
    for (let I = 1; I < i.length; I++)
      i[I] === "base64" ? s = !0 : i[I] && (g += `;${i[I]}`, i[I].indexOf("charset=") === 0 && (n = i[I].substring(8)));
    !i[0] && !n.length && (g += ";charset=US-ASCII", n = "US-ASCII");
    const o = unescape(e.substring(r + 1)), u = s ? A.base64ToArrayBuffer(o) : A.stringToBuffer(o);
    return {
      type: a,
      typeFull: g,
      charset: n,
      buffer: u
    };
  };
  return xI.makeDataUriToBuffer = t, xI;
}
var WR;
function peA() {
  if (WR) return LI;
  WR = 1, Object.defineProperty(LI, "__esModule", { value: !0 }), LI.dataUriToBuffer = void 0;
  const t = feA();
  function A(i) {
    if (i.byteLength === i.buffer.byteLength)
      return i.buffer;
    const n = new ArrayBuffer(i.byteLength);
    return new Uint8Array(n).set(i), n;
  }
  function e(i) {
    return A(Buffer.from(i, "base64"));
  }
  function r(i) {
    return A(Buffer.from(i, "ascii"));
  }
  return LI.dataUriToBuffer = (0, t.makeDataUriToBuffer)({ stringToBuffer: r, base64ToArrayBuffer: e }), LI;
}
var Lh = {}, VR;
function vp() {
  if (VR) return Lh;
  VR = 1, Object.defineProperty(Lh, "__esModule", { value: !0 });
  class t extends Error {
    constructor(e) {
      super(e || 'Source has not been modified since the provied "cache", re-use previous results'), this.code = "ENOTMODIFIED";
    }
  }
  return Lh.default = t, Lh;
}
var ZR;
function yeA() {
  if (ZR) return NI;
  ZR = 1;
  var t = W && W.__importDefault || function(o) {
    return o && o.__esModule ? o : { default: o };
  };
  Object.defineProperty(NI, "__esModule", { value: !0 }), NI.data = void 0;
  const A = t(Ir), e = Fn, r = un, i = peA(), n = t(vp()), s = (0, A.default)("get-uri:data");
  class a extends e.Readable {
    constructor(u, I) {
      super(), this.push(I), this.push(null), this.hash = u;
    }
  }
  const g = async ({ href: o }, { cache: u } = {}) => {
    const I = (0, r.createHash)("sha1");
    I.update(o);
    const c = I.digest("hex");
    if (s('generated SHA1 hash for "data:" URI: %o', c), (u == null ? void 0 : u.hash) === c)
      throw s("got matching cache SHA1 hash: %o", c), new n.default();
    {
      s('creating Readable stream from "data:" URI buffer');
      const { buffer: C } = (0, i.dataUriToBuffer)(o);
      return new a(c, Buffer.from(C));
    }
  };
  return NI.data = g, NI;
}
var GI = {}, xh = {}, XR;
function JS() {
  if (XR) return xh;
  XR = 1, Object.defineProperty(xh, "__esModule", { value: !0 });
  class t extends Error {
    constructor(e) {
      super(e || "File does not exist at the specified endpoint"), this.code = "ENOTFOUND";
    }
  }
  return xh.default = t, xh;
}
var zR;
function weA() {
  if (zR) return GI;
  zR = 1;
  var t = W && W.__importDefault || function(o) {
    return o && o.__esModule ? o : { default: o };
  };
  Object.defineProperty(GI, "__esModule", { value: !0 }), GI.file = void 0;
  const A = t(Ir), e = Rf, r = t(JS()), i = t(vp()), n = Dn, s = (0, A.default)("get-uri:file"), a = async ({ href: o }, u = {}) => {
    const {
      cache: I,
      flags: c = "r",
      mode: C = 438
      // =0666
    } = u;
    try {
      const E = (0, n.fileURLToPath)(o);
      s("Normalized pathname: %o", E);
      const l = await e.promises.open(E, c, C), B = l.fd, h = await l.stat();
      if (I && I.stat && h && g(I.stat, h))
        throw await l.close(), new i.default();
      const Q = (0, e.createReadStream)(E, {
        autoClose: !0,
        ...u,
        fd: B
      });
      return Q.stat = h, Q;
    } catch (E) {
      throw E.code === "ENOENT" ? new r.default() : E;
    }
  };
  GI.file = a;
  function g(o, u) {
    return +o.mtime == +u.mtime;
  }
  return GI;
}
var UI = {}, Yy = {}, TI = {}, Oa = {}, mr = {}, $R;
function HS() {
  if ($R) return mr;
  $R = 1, Object.defineProperty(mr, "__esModule", { value: !0 }), mr.positiveIntermediate = mr.positiveCompletion = mr.isMultiline = mr.isSingleLine = mr.parseControlResponse = void 0;
  const t = `
`;
  function A(a) {
    const g = a.split(/\r?\n/).filter(s), o = [];
    let u = 0, I;
    for (let C = 0; C < g.length; C++) {
      const E = g[C];
      if (I)
        I.test(E) && (I = void 0, o.push(g.slice(u, C + 1).join(t)));
      else if (r(E)) {
        const l = E.substr(0, 3);
        I = new RegExp(`^${l}(?:$| )`), u = C;
      } else e(E) && o.push(E);
    }
    const c = I ? g.slice(u).join(t) + t : "";
    return { messages: o, rest: c };
  }
  mr.parseControlResponse = A;
  function e(a) {
    return /^\d\d\d(?:$| )/.test(a);
  }
  mr.isSingleLine = e;
  function r(a) {
    return /^\d\d\d-/.test(a);
  }
  mr.isMultiline = r;
  function i(a) {
    return a >= 200 && a < 300;
  }
  mr.positiveCompletion = i;
  function n(a) {
    return a >= 300 && a < 400;
  }
  mr.positiveIntermediate = n;
  function s(a) {
    return a.trim() !== "";
  }
  return mr;
}
var Ab;
function HT() {
  if (Ab) return Oa;
  Ab = 1, Object.defineProperty(Oa, "__esModule", { value: !0 }), Oa.FTPContext = Oa.FTPError = void 0;
  const t = yr, A = HS();
  class e extends Error {
    constructor(s) {
      super(s.message), this.name = this.constructor.name, this.code = s.code;
    }
  }
  Oa.FTPError = e;
  function r() {
  }
  class i {
    /**
     * Instantiate an FTP context.
     *
     * @param timeout - Timeout in milliseconds to apply to control and data connections. Use 0 for no timeout.
     * @param encoding - Encoding to use for control connection. UTF-8 by default. Use "latin1" for older servers.
     */
    constructor(s = 0, a = "utf8") {
      this.timeout = s, this.verbose = !1, this.ipFamily = void 0, this.tlsOptions = {}, this._partialResponse = "", this._encoding = a, this._socket = this.socket = this._newSocket(), this._dataSocket = void 0;
    }
    /**
     * Close the context.
     */
    close() {
      const s = this._task ? "User closed client during task" : "User closed client", a = new Error(s);
      this.closeWithError(a);
    }
    /**
     * Close the context with an error.
     */
    closeWithError(s) {
      this._closingError || (this._closingError = s, this._closeControlSocket(), this._closeSocket(this._dataSocket), this._passToHandler(s), this._stopTrackingTask());
    }
    /**
     * Returns true if this context has been closed or hasn't been connected yet. You can reopen it with `access`.
     */
    get closed() {
      return this.socket.remoteAddress === void 0 || this._closingError !== void 0;
    }
    /**
     * Reset this contex and all of its state.
     */
    reset() {
      this.socket = this._newSocket();
    }
    /**
     * Get the FTP control socket.
     */
    get socket() {
      return this._socket;
    }
    /**
     * Set the socket for the control connection. This will only close the current control socket
     * if the new one is not an upgrade to the current one.
     */
    set socket(s) {
      this.dataSocket = void 0, this.tlsOptions = {}, this._partialResponse = "", this._socket && (s.localPort === this._socket.localPort ? this._removeSocketListeners(this.socket) : this._closeControlSocket()), s && (this._closingError = void 0, s.setTimeout(0), s.setEncoding(this._encoding), s.setKeepAlive(!0), s.on("data", (a) => this._onControlSocketData(a)), s.on("end", () => this.closeWithError(new Error("Server sent FIN packet unexpectedly, closing connection."))), s.on("close", (a) => {
        a || this.closeWithError(new Error("Server closed connection unexpectedly."));
      }), this._setupDefaultErrorHandlers(s, "control socket")), this._socket = s;
    }
    /**
     * Get the current FTP data connection if present.
     */
    get dataSocket() {
      return this._dataSocket;
    }
    /**
     * Set the socket for the data connection. This will automatically close the former data socket.
     */
    set dataSocket(s) {
      this._closeSocket(this._dataSocket), s && (s.setTimeout(0), this._setupDefaultErrorHandlers(s, "data socket")), this._dataSocket = s;
    }
    /**
     * Get the currently used encoding.
     */
    get encoding() {
      return this._encoding;
    }
    /**
     * Set the encoding used for the control socket.
     *
     * See https://nodejs.org/api/buffer.html#buffer_buffers_and_character_encodings for what encodings
     * are supported by Node.
     */
    set encoding(s) {
      this._encoding = s, this.socket && this.socket.setEncoding(s);
    }
    /**
     * Send an FTP command without waiting for or handling the result.
     */
    send(s) {
      const g = s.startsWith("PASS") ? "> PASS ###" : `> ${s}`;
      this.log(g), this._socket.write(s + `\r
`, this.encoding);
    }
    /**
     * Send an FTP command and handle the first response. Use this if you have a simple
     * request-response situation.
     */
    request(s) {
      return this.handle(s, (a, g) => {
        a instanceof Error ? g.reject(a) : g.resolve(a);
      });
    }
    /**
     * Send an FTP command and handle any response until you resolve/reject. Use this if you expect multiple responses
     * to a request. This returns a Promise that will hold whatever the response handler passed on when resolving/rejecting its task.
     */
    handle(s, a) {
      if (this._task) {
        const g = new Error("User launched a task while another one is still running. Forgot to use 'await' or '.then()'?");
        g.stack += `
Running task launched at: ${this._task.stack}`, this.closeWithError(g);
      }
      return new Promise((g, o) => {
        if (this._task = {
          stack: new Error().stack || "Unknown call stack",
          responseHandler: a,
          resolver: {
            resolve: (u) => {
              this._stopTrackingTask(), g(u);
            },
            reject: (u) => {
              this._stopTrackingTask(), o(u);
            }
          }
        }, this._closingError) {
          const u = new Error(`Client is closed because ${this._closingError.message}`);
          u.stack += `
Closing reason: ${this._closingError.stack}`, u.code = this._closingError.code !== void 0 ? this._closingError.code : "0", this._passToHandler(u);
          return;
        }
        this.socket.setTimeout(this.timeout), s && this.send(s);
      });
    }
    /**
     * Log message if set to be verbose.
     */
    log(s) {
      this.verbose && console.log(s);
    }
    /**
     * Return true if the control socket is using TLS. This does not mean that a session
     * has already been negotiated.
     */
    get hasTLS() {
      return "encrypted" in this._socket;
    }
    /**
     * Removes reference to current task and handler. This won't resolve or reject the task.
     * @protected
     */
    _stopTrackingTask() {
      this.socket.setTimeout(0), this._task = void 0;
    }
    /**
     * Handle incoming data on the control socket. The chunk is going to be of type `string`
     * because we let `socket` handle encoding with `setEncoding`.
     * @protected
     */
    _onControlSocketData(s) {
      this.log(`< ${s}`);
      const a = this._partialResponse + s, g = (0, A.parseControlResponse)(a);
      this._partialResponse = g.rest;
      for (const o of g.messages) {
        const u = parseInt(o.substr(0, 3), 10), I = { code: u, message: o }, c = u >= 400 ? new e(I) : void 0;
        this._passToHandler(c || I);
      }
    }
    /**
     * Send the current handler a response. This is usually a control socket response
     * or a socket event, like an error or timeout.
     * @protected
     */
    _passToHandler(s) {
      this._task && this._task.responseHandler(s, this._task.resolver);
    }
    /**
     * Setup all error handlers for a socket.
     * @protected
     */
    _setupDefaultErrorHandlers(s, a) {
      s.once("error", (g) => {
        g.message += ` (${a})`, this.closeWithError(g);
      }), s.once("close", (g) => {
        g && this.closeWithError(new Error(`Socket closed due to transmission error (${a})`));
      }), s.once("timeout", () => {
        s.destroy(), this.closeWithError(new Error(`Timeout (${a})`));
      });
    }
    /**
     * Close the control socket. Sends QUIT, then FIN, and ignores any response or error.
     */
    _closeControlSocket() {
      this._removeSocketListeners(this._socket), this._socket.on("error", r), this.send("QUIT"), this._closeSocket(this._socket);
    }
    /**
     * Close a socket, ignores any error.
     * @protected
     */
    _closeSocket(s) {
      s && (this._removeSocketListeners(s), s.on("error", r), s.destroy());
    }
    /**
     * Remove all default listeners for socket.
     * @protected
     */
    _removeSocketListeners(s) {
      s.removeAllListeners(), s.removeAllListeners("timeout"), s.removeAllListeners("data"), s.removeAllListeners("end"), s.removeAllListeners("error"), s.removeAllListeners("close"), s.removeAllListeners("connect");
    }
    /**
     * Provide a new socket instance.
     *
     * Internal use only, replaced for unit tests.
     */
    _newSocket() {
      return new t.Socket();
    }
  }
  return Oa.FTPContext = i, Oa;
}
var KI = {}, xn = {}, Ya = {}, eb;
function Rp() {
  if (eb) return Ya;
  eb = 1, Object.defineProperty(Ya, "__esModule", { value: !0 }), Ya.FileInfo = Ya.FileType = void 0;
  var t;
  (function(e) {
    e[e.Unknown = 0] = "Unknown", e[e.File = 1] = "File", e[e.Directory = 2] = "Directory", e[e.SymbolicLink = 3] = "SymbolicLink";
  })(t || (Ya.FileType = t = {}));
  let A = class {
    constructor(r) {
      this.name = r, this.type = t.Unknown, this.size = 0, this.rawModifiedAt = "", this.modifiedAt = void 0, this.permissions = void 0, this.hardLinkCount = void 0, this.link = void 0, this.group = void 0, this.user = void 0, this.uniqueID = void 0, this.name = r;
    }
    get isDirectory() {
      return this.type === t.Directory;
    }
    get isSymbolicLink() {
      return this.type === t.SymbolicLink;
    }
    get isFile() {
      return this.type === t.File;
    }
    /**
     * Deprecated, legacy API. Use `rawModifiedAt` instead.
     * @deprecated
     */
    get date() {
      return this.rawModifiedAt;
    }
    set date(r) {
      this.rawModifiedAt = r;
    }
  };
  return Ya.FileInfo = A, A.UnixPermission = {
    Read: 4,
    Write: 2,
    Execute: 1
  }, Ya;
}
var tb;
function meA() {
  if (tb) return xn;
  tb = 1, Object.defineProperty(xn, "__esModule", { value: !0 }), xn.transformList = xn.parseLine = xn.testLine = void 0;
  const t = Rp(), A = new RegExp(
    "(\\S+)\\s+(\\S+)\\s+(?:(<DIR>)|([0-9]+))\\s+(\\S.*)"
    // First non-space followed by rest of line (name)
  );
  function e(n) {
    return /^\d{2}/.test(n) && A.test(n);
  }
  xn.testLine = e;
  function r(n) {
    const s = n.match(A);
    if (s === null)
      return;
    const a = s[5];
    if (a === "." || a === "..")
      return;
    const g = new t.FileInfo(a);
    return s[3] === "<DIR>" ? (g.type = t.FileType.Directory, g.size = 0) : (g.type = t.FileType.File, g.size = parseInt(s[4], 10)), g.rawModifiedAt = s[1] + " " + s[2], g;
  }
  xn.parseLine = r;
  function i(n) {
    return n;
  }
  return xn.transformList = i, xn;
}
var Gn = {}, rb;
function DeA() {
  if (rb) return Gn;
  rb = 1, Object.defineProperty(Gn, "__esModule", { value: !0 }), Gn.transformList = Gn.parseLine = Gn.testLine = void 0;
  const t = Rp(), A = "æœˆ", e = "æ—¥", r = "å¹´", i = new RegExp("([bcdelfmpSs-])(((r|-)(w|-)([xsStTL-]))((r|-)(w|-)([xsStTL-]))((r|-)(w|-)([xsStTL-]?)))\\+?\\s*(\\d+)\\s+(?:(\\S+(?:\\s\\S+)*?)\\s+)?(?:(\\S+(?:\\s\\S+)*)\\s+)?(\\d+(?:,\\s*\\d+)?)\\s+((?:\\d+[-/]\\d+[-/]\\d+)|(?:\\S{3}\\s+\\d{1,2})|(?:\\d{1,2}\\s+\\S{3})|(?:\\d{1,2}" + A + "\\s+\\d{1,2}" + e + "))\\s+((?:\\d+(?::\\d+)?)|(?:\\d{4}" + r + "))\\s(.*)");
  function n(o) {
    return i.test(o);
  }
  Gn.testLine = n;
  function s(o) {
    const u = o.match(i);
    if (u === null)
      return;
    const I = u[21];
    if (I === "." || I === "..")
      return;
    const c = new t.FileInfo(I);
    switch (c.size = parseInt(u[18], 10), c.user = u[16], c.group = u[17], c.hardLinkCount = parseInt(u[15], 10), c.rawModifiedAt = u[19] + " " + u[20], c.permissions = {
      user: g(u[4], u[5], u[6]),
      group: g(u[8], u[9], u[10]),
      world: g(u[12], u[13], u[14])
    }, u[1].charAt(0)) {
      case "d":
        c.type = t.FileType.Directory;
        break;
      case "e":
        c.type = t.FileType.SymbolicLink;
        break;
      case "l":
        c.type = t.FileType.SymbolicLink;
        break;
      case "b":
      case "c":
        c.type = t.FileType.File;
        break;
      case "f":
      case "-":
        c.type = t.FileType.File;
        break;
      default:
        c.type = t.FileType.Unknown;
    }
    if (c.isSymbolicLink) {
      const C = I.indexOf(" -> ");
      C !== -1 && (c.name = I.substring(0, C), c.link = I.substring(C + 4));
    }
    return c;
  }
  Gn.parseLine = s;
  function a(o) {
    return o;
  }
  Gn.transformList = a;
  function g(o, u, I) {
    let c = 0;
    o !== "-" && (c += t.FileInfo.UnixPermission.Read), u !== "-" && (c += t.FileInfo.UnixPermission.Write);
    const C = I.charAt(0);
    return C !== "-" && C.toUpperCase() !== C && (c += t.FileInfo.UnixPermission.Execute), c;
  }
  return Gn;
}
var ui = {}, ib;
function PT() {
  if (ib) return ui;
  ib = 1, Object.defineProperty(ui, "__esModule", { value: !0 }), ui.parseMLSxDate = ui.transformList = ui.parseLine = ui.testLine = void 0;
  const t = Rp();
  function A(g, o) {
    o.size = parseInt(g, 10);
  }
  const e = {
    size: A,
    // File size
    sizd: A,
    // Directory size
    unique: (g, o) => {
      o.uniqueID = g;
    },
    modify: (g, o) => {
      o.modifiedAt = a(g), o.rawModifiedAt = o.modifiedAt.toISOString();
    },
    type: (g, o) => {
      if (g.startsWith("OS.unix=slink"))
        return o.type = t.FileType.SymbolicLink, o.link = g.substr(g.indexOf(":") + 1), 1;
      switch (g) {
        case "file":
          o.type = t.FileType.File;
          break;
        case "dir":
          o.type = t.FileType.Directory;
          break;
        case "OS.unix=symlink":
          o.type = t.FileType.SymbolicLink;
          break;
        case "cdir":
        case "pdir":
          return 2;
        default:
          o.type = t.FileType.Unknown;
      }
      return 1;
    },
    "unix.mode": (g, o) => {
      const u = g.substr(-3);
      o.permissions = {
        user: parseInt(u[0], 10),
        group: parseInt(u[1], 10),
        world: parseInt(u[2], 10)
      };
    },
    "unix.ownername": (g, o) => {
      o.user = g;
    },
    "unix.owner": (g, o) => {
      o.user === void 0 && (o.user = g);
    },
    get "unix.uid"() {
      return this["unix.owner"];
    },
    "unix.groupname": (g, o) => {
      o.group = g;
    },
    "unix.group": (g, o) => {
      o.group === void 0 && (o.group = g);
    },
    get "unix.gid"() {
      return this["unix.group"];
    }
    // Regarding the fact "perm":
    // We don't handle permission information stored in "perm" because its information is conceptually
    // different from what users of FTP clients usually associate with "permissions". Those that have
    // some expectations (and probably want to edit them with a SITE command) often unknowingly expect
    // the Unix permission system. The information passed by "perm" describes what FTP commands can be
    // executed with a file/directory. But even this can be either incomplete or just meant as a "guide"
    // as the spec mentions. From https://tools.ietf.org/html/rfc3659#section-7.5.5: "The permissions are
    // described here as they apply to FTP commands. They may not map easily into particular permissions
    // available on the server's operating system." The parser by Apache Commons tries to translate these
    // to Unix permissions â€“ this is misleading users and might not even be correct.
  };
  function r(g, o) {
    const u = g.indexOf(o), I = g.substr(0, u), c = g.substr(u + o.length);
    return [I, c];
  }
  function i(g) {
    return /^\S+=\S+;/.test(g) || g.startsWith(" ");
  }
  ui.testLine = i;
  function n(g) {
    const [o, u] = r(g, " ");
    if (u === "" || u === "." || u === "..")
      return;
    const I = new t.FileInfo(u), c = o.split(";");
    for (const C of c) {
      const [E, l] = r(C, "=");
      if (!l)
        continue;
      const B = e[E.toLowerCase()];
      if (!B)
        continue;
      if (B(l, I) === 2)
        return;
    }
    return I;
  }
  ui.parseLine = n;
  function s(g) {
    const o = /* @__PURE__ */ new Map();
    for (const I of g)
      !I.isSymbolicLink && I.uniqueID !== void 0 && o.set(I.uniqueID, I);
    const u = [];
    for (const I of g) {
      if (I.isSymbolicLink && I.uniqueID !== void 0 && I.link === void 0) {
        const C = o.get(I.uniqueID);
        C !== void 0 && (I.link = C.name);
      }
      !I.name.includes("/") && u.push(I);
    }
    return u;
  }
  ui.transformList = s;
  function a(g) {
    return new Date(Date.UTC(
      +g.slice(0, 4),
      // Year
      +g.slice(4, 6) - 1,
      // Month
      +g.slice(6, 8),
      // Date
      +g.slice(8, 10),
      // Hours
      +g.slice(10, 12),
      // Minutes
      +g.slice(12, 14),
      // Seconds
      +g.slice(15, 18)
      // Milliseconds
    ));
  }
  return ui.parseMLSxDate = a, ui;
}
var nb;
function OT() {
  if (nb) return KI;
  nb = 1;
  var t = W && W.__createBinding || (Object.create ? function(c, C, E, l) {
    l === void 0 && (l = E);
    var B = Object.getOwnPropertyDescriptor(C, E);
    (!B || ("get" in B ? !C.__esModule : B.writable || B.configurable)) && (B = { enumerable: !0, get: function() {
      return C[E];
    } }), Object.defineProperty(c, l, B);
  } : function(c, C, E, l) {
    l === void 0 && (l = E), c[l] = C[E];
  }), A = W && W.__setModuleDefault || (Object.create ? function(c, C) {
    Object.defineProperty(c, "default", { enumerable: !0, value: C });
  } : function(c, C) {
    c.default = C;
  }), e = W && W.__importStar || function(c) {
    if (c && c.__esModule) return c;
    var C = {};
    if (c != null) for (var E in c) E !== "default" && Object.prototype.hasOwnProperty.call(c, E) && t(C, c, E);
    return A(C, c), C;
  };
  Object.defineProperty(KI, "__esModule", { value: !0 }), KI.parseList = void 0;
  const r = e(meA()), i = e(DeA()), n = e(PT()), s = [
    r,
    i,
    n
    // Keep MLSD last, may accept filename only
  ];
  function a(c, C) {
    return C.find((E) => E.testLine(c) === !0);
  }
  function g(c) {
    return c.trim() !== "";
  }
  function o(c) {
    return !c.startsWith("total");
  }
  const u = /\r?\n/;
  function I(c) {
    const C = c.split(u).filter(g).filter(o);
    if (C.length === 0)
      return [];
    const E = C[C.length - 1], l = a(E, s);
    if (!l)
      throw new Error("This library only supports MLSD, Unix- or DOS-style directory listing. Your FTP server seems to be using another format. You can see the transmitted listing when setting `client.ftp.verbose = true`. You can then provide a custom parser to `client.parseList`, see the documentation for details.");
    const B = C.map(l.parseLine).filter((h) => h !== void 0);
    return l.transformList(B);
  }
  return KI.parseList = I, KI;
}
var JI = {}, sb;
function SeA() {
  if (sb) return JI;
  sb = 1, Object.defineProperty(JI, "__esModule", { value: !0 }), JI.ProgressTracker = void 0;
  let t = class {
    constructor() {
      this.bytesOverall = 0, this.intervalMs = 500, this.onStop = e, this.onHandle = e;
    }
    /**
     * Register a new handler for progress info. Use `undefined` to disable reporting.
     */
    reportTo(i = e) {
      this.onHandle = i;
    }
    /**
     * Start tracking transfer progress of a socket.
     *
     * @param socket  The socket to observe.
     * @param name  A name associated with this progress tracking, e.g. a filename.
     * @param type  The type of the transfer, typically "upload" or "download".
     */
    start(i, n, s) {
      let a = 0;
      this.onStop = A(this.intervalMs, () => {
        const g = i.bytesRead + i.bytesWritten;
        this.bytesOverall += g - a, a = g, this.onHandle({
          name: n,
          type: s,
          bytes: g,
          bytesOverall: this.bytesOverall
        });
      });
    }
    /**
     * Stop tracking transfer progress.
     */
    stop() {
      this.onStop(!1);
    }
    /**
     * Call the progress handler one more time, then stop tracking.
     */
    updateAndStop() {
      this.onStop(!0);
    }
  };
  JI.ProgressTracker = t;
  function A(r, i) {
    const n = setInterval(i, r), s = (a) => {
      clearInterval(n), a && i(), i = e;
    };
    return i(), s;
  }
  function e() {
  }
  return JI;
}
var HI = {}, ab;
function FeA() {
  if (ab) return HI;
  ab = 1, Object.defineProperty(HI, "__esModule", { value: !0 }), HI.StringWriter = void 0;
  const t = Fn;
  let A = class extends t.Writable {
    constructor() {
      super(...arguments), this.buf = Buffer.alloc(0);
    }
    _write(r, i, n) {
      r instanceof Buffer ? (this.buf = Buffer.concat([this.buf, r]), n(null)) : n(new Error("StringWriter expects chunks of type 'Buffer'."));
    }
    getText(r) {
      return this.buf.toString(r);
    }
  };
  return HI.StringWriter = A, HI;
}
var ci = {}, ob;
function YT() {
  if (ob) return ci;
  ob = 1, Object.defineProperty(ci, "__esModule", { value: !0 }), ci.ipIsPrivateV4Address = ci.upgradeSocket = ci.describeAddress = ci.describeTLS = void 0;
  const t = Sn;
  function A(n) {
    if (n instanceof t.TLSSocket) {
      const s = n.getProtocol();
      return s || "Server socket or disconnected client socket";
    }
    return "No encryption";
  }
  ci.describeTLS = A;
  function e(n) {
    return n.remoteFamily === "IPv6" ? `[${n.remoteAddress}]:${n.remotePort}` : `${n.remoteAddress}:${n.remotePort}`;
  }
  ci.describeAddress = e;
  function r(n, s) {
    return new Promise((a, g) => {
      const o = Object.assign({}, s, {
        socket: n
      }), u = (0, t.connect)(o, () => {
        o.rejectUnauthorized !== !1 && !u.authorized ? g(u.authorizationError) : (u.removeAllListeners("error"), a(u));
      }).once("error", (I) => {
        g(I);
      });
    });
  }
  ci.upgradeSocket = r;
  function i(n = "") {
    n.startsWith("::ffff:") && (n = n.substr(7));
    const s = n.split(".").map((a) => parseInt(a, 10));
    return s[0] === 10 || s[0] === 172 && s[1] >= 16 && s[1] <= 31 || s[0] === 192 && s[1] === 168 || n === "127.0.0.1";
  }
  return ci.ipIsPrivateV4Address = i, ci;
}
var Lt = {}, gb;
function qT() {
  if (gb) return Lt;
  gb = 1, Object.defineProperty(Lt, "__esModule", { value: !0 }), Lt.downloadTo = Lt.uploadFrom = Lt.connectForPassiveTransfer = Lt.parsePasvResponse = Lt.enterPassiveModeIPv4 = Lt.parseEpsvResponse = Lt.enterPassiveModeIPv6 = void 0;
  const t = YT(), A = Fn, e = Sn, r = HS();
  async function i(C) {
    const E = await C.request("EPSV"), l = n(E.message);
    if (!l)
      throw new Error("Can't parse EPSV response: " + E.message);
    const B = C.socket.remoteAddress;
    if (B === void 0)
      throw new Error("Control socket is disconnected, can't get remote address.");
    return await g(B, l, C), E;
  }
  Lt.enterPassiveModeIPv6 = i;
  function n(C) {
    const E = C.match(/[|!]{3}(.+)[|!]/);
    if (E === null || E[1] === void 0)
      throw new Error(`Can't parse response to 'EPSV': ${C}`);
    const l = parseInt(E[1], 10);
    if (Number.isNaN(l))
      throw new Error(`Can't parse response to 'EPSV', port is not a number: ${C}`);
    return l;
  }
  Lt.parseEpsvResponse = n;
  async function s(C) {
    const E = await C.request("PASV"), l = a(E.message);
    if (!l)
      throw new Error("Can't parse PASV response: " + E.message);
    const B = C.socket.remoteAddress;
    return (0, t.ipIsPrivateV4Address)(l.host) && B && !(0, t.ipIsPrivateV4Address)(B) && (l.host = B), await g(l.host, l.port, C), E;
  }
  Lt.enterPassiveModeIPv4 = s;
  function a(C) {
    const E = C.match(/([-\d]+,[-\d]+,[-\d]+,[-\d]+),([-\d]+),([-\d]+)/);
    if (E === null || E.length !== 4)
      throw new Error(`Can't parse response to 'PASV': ${C}`);
    return {
      host: E[1].replace(/,/g, "."),
      port: (parseInt(E[2], 10) & 255) * 256 + (parseInt(E[3], 10) & 255)
    };
  }
  Lt.parsePasvResponse = a;
  function g(C, E, l) {
    return new Promise((B, h) => {
      let Q = l._newSocket();
      const f = function(y) {
        y.message = "Can't open data connection in passive mode: " + y.message, h(y);
      }, p = function() {
        Q.destroy(), h(new Error(`Timeout when trying to open data connection to ${C}:${E}`));
      };
      Q.setTimeout(l.timeout), Q.on("error", f), Q.on("timeout", p), Q.connect({ port: E, host: C, family: l.ipFamily }, () => {
        l.socket instanceof e.TLSSocket && (Q = (0, e.connect)(Object.assign({}, l.tlsOptions, {
          socket: Q,
          // Reuse the TLS session negotiated earlier when the control connection
          // was upgraded. Servers expect this because it provides additional
          // security: If a completely new session would be negotiated, a hacker
          // could guess the port and connect to the new data connection before we do
          // by just starting his/her own TLS session.
          session: l.socket.getSession()
        }))), Q.removeListener("error", f), Q.removeListener("timeout", p), l.dataSocket = Q, B();
      });
    });
  }
  Lt.connectForPassiveTransfer = g;
  class o {
    /**
     * Instantiate a TransferResolver
     */
    constructor(E, l) {
      this.ftp = E, this.progress = l, this.response = void 0, this.dataTransferDone = !1;
    }
    /**
     * Mark the beginning of a transfer.
     *
     * @param name - Name of the transfer, usually the filename.
     * @param type - Type of transfer, usually "upload" or "download".
     */
    onDataStart(E, l) {
      if (this.ftp.dataSocket === void 0)
        throw new Error("Data transfer should start but there is no data connection.");
      this.ftp.socket.setTimeout(0), this.ftp.dataSocket.setTimeout(this.ftp.timeout), this.progress.start(this.ftp.dataSocket, E, l);
    }
    /**
     * The data connection has finished the transfer.
     */
    onDataDone(E) {
      this.progress.updateAndStop(), this.ftp.socket.setTimeout(this.ftp.timeout), this.ftp.dataSocket && this.ftp.dataSocket.setTimeout(0), this.dataTransferDone = !0, this.tryResolve(E);
    }
    /**
     * The control connection reports the transfer as finished.
     */
    onControlDone(E, l) {
      this.response = l, this.tryResolve(E);
    }
    /**
     * An error has been reported and the task should be rejected.
     */
    onError(E, l) {
      this.progress.updateAndStop(), this.ftp.socket.setTimeout(this.ftp.timeout), this.ftp.dataSocket = void 0, E.reject(l);
    }
    /**
     * Control connection sent an unexpected request requiring a response from our part. We
     * can't provide that (because unknown) and have to close the contrext with an error because
     * the FTP server is now caught up in a state we can't resolve.
     */
    onUnexpectedRequest(E) {
      const l = new Error(`Unexpected FTP response is requesting an answer: ${E.message}`);
      this.ftp.closeWithError(l);
    }
    tryResolve(E) {
      this.dataTransferDone && this.response !== void 0 && (this.ftp.dataSocket = void 0, E.resolve(this.response));
    }
  }
  function u(C, E) {
    const l = new o(E.ftp, E.tracker), B = `${E.command} ${E.remotePath}`;
    return E.ftp.handle(B, (h, Q) => {
      if (h instanceof Error)
        l.onError(Q, h);
      else if (h.code === 150 || h.code === 125) {
        const f = E.ftp.dataSocket;
        if (!f) {
          l.onError(Q, new Error("Upload should begin but no data connection is available."));
          return;
        }
        const p = "getCipher" in f ? f.getCipher() !== void 0 : !0;
        c(p, f, "secureConnect", () => {
          E.ftp.log(`Uploading to ${(0, t.describeAddress)(f)} (${(0, t.describeTLS)(f)})`), l.onDataStart(E.remotePath, E.type), (0, A.pipeline)(C, f, (y) => {
            y ? l.onError(Q, y) : l.onDataDone(Q);
          });
        });
      } else (0, r.positiveCompletion)(h.code) ? l.onControlDone(Q, h) : (0, r.positiveIntermediate)(h.code) && l.onUnexpectedRequest(h);
    });
  }
  Lt.uploadFrom = u;
  function I(C, E) {
    if (!E.ftp.dataSocket)
      throw new Error("Download will be initiated but no data connection is available.");
    const l = new o(E.ftp, E.tracker);
    return E.ftp.handle(E.command, (B, h) => {
      if (B instanceof Error)
        l.onError(h, B);
      else if (B.code === 150 || B.code === 125) {
        const Q = E.ftp.dataSocket;
        if (!Q) {
          l.onError(h, new Error("Download should begin but no data connection is available."));
          return;
        }
        E.ftp.log(`Downloading from ${(0, t.describeAddress)(Q)} (${(0, t.describeTLS)(Q)})`), l.onDataStart(E.remotePath, E.type), (0, A.pipeline)(Q, C, (f) => {
          f ? l.onError(h, f) : l.onDataDone(h);
        });
      } else B.code === 350 ? E.ftp.send("RETR " + E.remotePath) : (0, r.positiveCompletion)(B.code) ? l.onControlDone(h, B) : (0, r.positiveIntermediate)(B.code) && l.onUnexpectedRequest(B);
    });
  }
  Lt.downloadTo = I;
  function c(C, E, l, B) {
    C === !0 ? B() : E.once(l, () => B());
  }
  return Lt;
}
var ub;
function keA() {
  if (ub) return TI;
  ub = 1, Object.defineProperty(TI, "__esModule", { value: !0 }), TI.Client = void 0;
  const t = Rf, A = SE, e = Sn, r = bf, i = HT(), n = OT(), s = SeA(), a = FeA(), g = PT(), o = YT(), u = qT(), I = HS(), c = (0, r.promisify)(t.readdir), C = (0, r.promisify)(t.mkdir), E = (0, r.promisify)(t.stat), l = (0, r.promisify)(t.open), B = (0, r.promisify)(t.close), h = (0, r.promisify)(t.unlink), Q = () => ["LIST -a", "LIST"], f = () => ["MLSD", "LIST -a", "LIST"];
  let p = class {
    /**
     * Instantiate an FTP client.
     *
     * @param timeout  Timeout in milliseconds, use 0 for no timeout. Optional, default is 30 seconds.
     */
    constructor(w = 3e4) {
      this.availableListCommands = Q(), this.ftp = new i.FTPContext(w), this.prepareTransfer = this._enterFirstCompatibleMode([u.enterPassiveModeIPv6, u.enterPassiveModeIPv4]), this.parseList = n.parseList, this._progressTracker = new s.ProgressTracker();
    }
    /**
     * Close the client and all open socket connections.
     *
     * Close the client and all open socket connections. The client canâ€™t be used anymore after calling this method,
     * you have to either reconnect with `access` or `connect` or instantiate a new instance to continue any work.
     * A client is also closed automatically if any timeout or connection error occurs.
     */
    close() {
      this.ftp.close(), this._progressTracker.stop();
    }
    /**
     * Returns true if the client is closed and can't be used anymore.
     */
    get closed() {
      return this.ftp.closed;
    }
    /**
     * Connect (or reconnect) to an FTP server.
     *
     * This is an instance method and thus can be called multiple times during the lifecycle of a `Client`
     * instance. Whenever you do, the client is reset with a new control connection. This also implies that
     * you can reopen a `Client` instance that has been closed due to an error when reconnecting with this
     * method. In fact, reconnecting is the only way to continue using a closed `Client`.
     *
     * @param host  Host the client should connect to. Optional, default is "localhost".
     * @param port  Port the client should connect to. Optional, default is 21.
     */
    connect(w = "localhost", F = 21) {
      return this.ftp.reset(), this.ftp.socket.connect({
        host: w,
        port: F,
        family: this.ftp.ipFamily
      }, () => this.ftp.log(`Connected to ${(0, o.describeAddress)(this.ftp.socket)} (${(0, o.describeTLS)(this.ftp.socket)})`)), this._handleConnectResponse();
    }
    /**
     * As `connect` but using implicit TLS. Implicit TLS is not an FTP standard and has been replaced by
     * explicit TLS. There are still FTP servers that support only implicit TLS, though.
     */
    connectImplicitTLS(w = "localhost", F = 21, b = {}) {
      return this.ftp.reset(), this.ftp.socket = (0, e.connect)(F, w, b, () => this.ftp.log(`Connected to ${(0, o.describeAddress)(this.ftp.socket)} (${(0, o.describeTLS)(this.ftp.socket)})`)), this.ftp.tlsOptions = b, this._handleConnectResponse();
    }
    /**
     * Handles the first reponse by an FTP server after the socket connection has been established.
     */
    _handleConnectResponse() {
      return this.ftp.handle(void 0, (w, F) => {
        w instanceof Error ? F.reject(w) : (0, I.positiveCompletion)(w.code) ? F.resolve(w) : F.reject(new i.FTPError(w));
      });
    }
    /**
     * Send an FTP command and handle the first response.
     */
    send(w, F = !1) {
      return F ? (this.ftp.log("Deprecated call using send(command, flag) with boolean flag to ignore errors. Use sendIgnoringError(command)."), this.sendIgnoringError(w)) : this.ftp.request(w);
    }
    /**
     * Send an FTP command and ignore an FTP error response. Any other kind of error or timeout will still reject the Promise.
     *
     * @param command
     */
    sendIgnoringError(w) {
      return this.ftp.handle(w, (F, b) => {
        F instanceof i.FTPError ? b.resolve({ code: F.code, message: F.message }) : F instanceof Error ? b.reject(F) : b.resolve(F);
      });
    }
    /**
     * Upgrade the current socket connection to TLS.
     *
     * @param options  TLS options as in `tls.connect(options)`, optional.
     * @param command  Set the authentication command. Optional, default is "AUTH TLS".
     */
    async useTLS(w = {}, F = "AUTH TLS") {
      const b = await this.send(F);
      return this.ftp.socket = await (0, o.upgradeSocket)(this.ftp.socket, w), this.ftp.tlsOptions = w, this.ftp.log(`Control socket is using: ${(0, o.describeTLS)(this.ftp.socket)}`), b;
    }
    /**
     * Login a user with a password.
     *
     * @param user  Username to use for login. Optional, default is "anonymous".
     * @param password  Password to use for login. Optional, default is "guest".
     */
    login(w = "anonymous", F = "guest") {
      return this.ftp.log(`Login security: ${(0, o.describeTLS)(this.ftp.socket)}`), this.ftp.handle("USER " + w, (b, G) => {
        b instanceof Error ? G.reject(b) : (0, I.positiveCompletion)(b.code) ? G.resolve(b) : b.code === 331 ? this.ftp.send("PASS " + F) : G.reject(new i.FTPError(b));
      });
    }
    /**
     * Set the usual default settings.
     *
     * Settings used:
     * * Binary mode (TYPE I)
     * * File structure (STRU F)
     * * Additional settings for FTPS (PBSZ 0, PROT P)
     */
    async useDefaultSettings() {
      const F = (await this.features()).has("MLST");
      this.availableListCommands = F ? f() : Q(), await this.send("TYPE I"), await this.sendIgnoringError("STRU F"), await this.sendIgnoringError("OPTS UTF8 ON"), F && await this.sendIgnoringError("OPTS MLST type;size;modify;unique;unix.mode;unix.owner;unix.group;unix.ownername;unix.groupname;"), this.ftp.hasTLS && (await this.sendIgnoringError("PBSZ 0"), await this.sendIgnoringError("PROT P"));
    }
    /**
     * Convenience method that calls `connect`, `useTLS`, `login` and `useDefaultSettings`.
     *
     * This is an instance method and thus can be called multiple times during the lifecycle of a `Client`
     * instance. Whenever you do, the client is reset with a new control connection. This also implies that
     * you can reopen a `Client` instance that has been closed due to an error when reconnecting with this
     * method. In fact, reconnecting is the only way to continue using a closed `Client`.
     */
    async access(w = {}) {
      var F, b;
      const G = w.secure === !0, T = w.secure === "implicit";
      let K;
      if (T ? K = await this.connectImplicitTLS(w.host, w.port, w.secureOptions) : K = await this.connect(w.host, w.port), G) {
        const H = (F = w.secureOptions) !== null && F !== void 0 ? F : {};
        H.host = (b = H.host) !== null && b !== void 0 ? b : w.host, await this.useTLS(H);
      }
      return await this.sendIgnoringError("OPTS UTF8 ON"), await this.login(w.user, w.password), await this.useDefaultSettings(), K;
    }
    /**
     * Get the current working directory.
     */
    async pwd() {
      const w = await this.send("PWD"), F = w.message.match(/"(.+)"/);
      if (F === null || F[1] === void 0)
        throw new Error(`Can't parse response to command 'PWD': ${w.message}`);
      return F[1];
    }
    /**
     * Get a description of supported features.
     *
     * This sends the FEAT command and parses the result into a Map where keys correspond to available commands
     * and values hold further information. Be aware that your FTP servers might not support this
     * command in which case this method will not throw an exception but just return an empty Map.
     */
    async features() {
      const w = await this.sendIgnoringError("FEAT"), F = /* @__PURE__ */ new Map();
      return w.code < 400 && (0, I.isMultiline)(w.message) && w.message.split(`
`).slice(1, -1).forEach((b) => {
        const G = b.trim().split(" ");
        F.set(G[0], G[1] || "");
      }), F;
    }
    /**
     * Set the working directory.
     */
    async cd(w) {
      const F = await this.protectWhitespace(w);
      return this.send("CWD " + F);
    }
    /**
     * Switch to the parent directory of the working directory.
     */
    async cdup() {
      return this.send("CDUP");
    }
    /**
     * Get the last modified time of a file. This is not supported by every FTP server, in which case
     * calling this method will throw an exception.
     */
    async lastMod(w) {
      const F = await this.protectWhitespace(w), G = (await this.send(`MDTM ${F}`)).message.slice(4);
      return (0, g.parseMLSxDate)(G);
    }
    /**
     * Get the size of a file.
     */
    async size(w) {
      const b = `SIZE ${await this.protectWhitespace(w)}`, G = await this.send(b), T = parseInt(G.message.slice(4), 10);
      if (Number.isNaN(T))
        throw new Error(`Can't parse response to command '${b}' as a numerical value: ${G.message}`);
      return T;
    }
    /**
     * Rename a file.
     *
     * Depending on the FTP server this might also be used to move a file from one
     * directory to another by providing full paths.
     */
    async rename(w, F) {
      const b = await this.protectWhitespace(w), G = await this.protectWhitespace(F);
      return await this.send("RNFR " + b), this.send("RNTO " + G);
    }
    /**
     * Remove a file from the current working directory.
     *
     * You can ignore FTP error return codes which won't throw an exception if e.g.
     * the file doesn't exist.
     */
    async remove(w, F = !1) {
      const b = await this.protectWhitespace(w);
      return F ? this.sendIgnoringError(`DELE ${b}`) : this.send(`DELE ${b}`);
    }
    /**
     * Report transfer progress for any upload or download to a given handler.
     *
     * This will also reset the overall transfer counter that can be used for multiple transfers. You can
     * also call the function without a handler to stop reporting to an earlier one.
     *
     * @param handler  Handler function to call on transfer progress.
     */
    trackProgress(w) {
      this._progressTracker.bytesOverall = 0, this._progressTracker.reportTo(w);
    }
    /**
     * Upload data from a readable stream or a local file to a remote file.
     *
     * @param source  Readable stream or path to a local file.
     * @param toRemotePath  Path to a remote file to write to.
     */
    async uploadFrom(w, F, b = {}) {
      return this._uploadWithCommand(w, F, "STOR", b);
    }
    /**
     * Upload data from a readable stream or a local file by appending it to an existing file. If the file doesn't
     * exist the FTP server should create it.
     *
     * @param source  Readable stream or path to a local file.
     * @param toRemotePath  Path to a remote file to write to.
     */
    async appendFrom(w, F, b = {}) {
      return this._uploadWithCommand(w, F, "APPE", b);
    }
    /**
     * @protected
     */
    async _uploadWithCommand(w, F, b, G) {
      return typeof w == "string" ? this._uploadLocalFile(w, F, b, G) : this._uploadFromStream(w, F, b);
    }
    /**
     * @protected
     */
    async _uploadLocalFile(w, F, b, G) {
      const T = await l(w, "r"), K = (0, t.createReadStream)("", {
        fd: T,
        start: G.localStart,
        end: G.localEndInclusive,
        autoClose: !1
      });
      try {
        return await this._uploadFromStream(K, F, b);
      } finally {
        await m(() => B(T));
      }
    }
    /**
     * @protected
     */
    async _uploadFromStream(w, F, b) {
      const G = (T) => this.ftp.closeWithError(T);
      w.once("error", G);
      try {
        const T = await this.protectWhitespace(F);
        return await this.prepareTransfer(this.ftp), await (0, u.uploadFrom)(w, {
          ftp: this.ftp,
          tracker: this._progressTracker,
          command: b,
          remotePath: T,
          type: "upload"
        });
      } finally {
        w.removeListener("error", G);
      }
    }
    /**
     * Download a remote file and pipe its data to a writable stream or to a local file.
     *
     * You can optionally define at which position of the remote file you'd like to start
     * downloading. If the destination you provide is a file, the offset will be applied
     * to it as well. For example: To resume a failed download, you'd request the size of
     * the local, partially downloaded file and use that as the offset. Assuming the size
     * is 23, you'd download the rest using `downloadTo("local.txt", "remote.txt", 23)`.
     *
     * @param destination  Stream or path for a local file to write to.
     * @param fromRemotePath  Path of the remote file to read from.
     * @param startAt  Position within the remote file to start downloading at. If the destination is a file, this offset is also applied to it.
     */
    async downloadTo(w, F, b = 0) {
      return typeof w == "string" ? this._downloadToFile(w, F, b) : this._downloadToStream(w, F, b);
    }
    /**
     * @protected
     */
    async _downloadToFile(w, F, b) {
      const G = b > 0, K = await l(w, G ? "r+" : "w"), H = (0, t.createWriteStream)("", {
        fd: K,
        start: b,
        autoClose: !1
      });
      try {
        return await this._downloadToStream(H, F, b);
      } catch (j) {
        const eA = await m(() => E(w)), sA = eA && eA.size > 0;
        throw !G && !sA && await m(() => h(w)), j;
      } finally {
        await m(() => B(K));
      }
    }
    /**
     * @protected
     */
    async _downloadToStream(w, F, b) {
      const G = (T) => this.ftp.closeWithError(T);
      w.once("error", G);
      try {
        const T = await this.protectWhitespace(F);
        return await this.prepareTransfer(this.ftp), await (0, u.downloadTo)(w, {
          ftp: this.ftp,
          tracker: this._progressTracker,
          command: b > 0 ? `REST ${b}` : `RETR ${T}`,
          remotePath: T,
          type: "download"
        });
      } finally {
        w.removeListener("error", G), w.end();
      }
    }
    /**
     * List files and directories in the current working directory, or from `path` if specified.
     *
     * @param [path]  Path to remote file or directory.
     */
    async list(w = "") {
      const F = await this.protectWhitespace(w);
      let b;
      for (const G of this.availableListCommands) {
        const T = F === "" ? G : `${G} ${F}`;
        await this.prepareTransfer(this.ftp);
        try {
          const K = await this._requestListWithCommand(T);
          return this.availableListCommands = [G], K;
        } catch (K) {
          if (!(K instanceof i.FTPError))
            throw K;
          b = K;
        }
      }
      throw b;
    }
    /**
     * @protected
     */
    async _requestListWithCommand(w) {
      const F = new a.StringWriter();
      await (0, u.downloadTo)(F, {
        ftp: this.ftp,
        tracker: this._progressTracker,
        command: w,
        remotePath: "",
        type: "list"
      });
      const b = F.getText(this.ftp.encoding);
      return this.ftp.log(b), this.parseList(b);
    }
    /**
     * Remove a directory and all of its content.
     *
     * @param remoteDirPath  The path of the remote directory to delete.
     * @example client.removeDir("foo") // Remove directory 'foo' using a relative path.
     * @example client.removeDir("foo/bar") // Remove directory 'bar' using a relative path.
     * @example client.removeDir("/foo/bar") // Remove directory 'bar' using an absolute path.
     * @example client.removeDir("/") // Remove everything.
     */
    async removeDir(w) {
      return this._exitAtCurrentDirectory(async () => {
        await this.cd(w);
        const F = await this.pwd();
        await this.clearWorkingDir(), F === "/" || (await this.cdup(), await this.removeEmptyDir(F));
      });
    }
    /**
     * Remove all files and directories in the working directory without removing
     * the working directory itself.
     */
    async clearWorkingDir() {
      for (const w of await this.list())
        w.isDirectory ? (await this.cd(w.name), await this.clearWorkingDir(), await this.cdup(), await this.removeEmptyDir(w.name)) : await this.remove(w.name);
    }
    /**
     * Upload the contents of a local directory to the remote working directory.
     *
     * This will overwrite existing files with the same names and reuse existing directories.
     * Unrelated files and directories will remain untouched. You can optionally provide a `remoteDirPath`
     * to put the contents inside a directory which will be created if necessary including all
     * intermediate directories. If you did provide a remoteDirPath the working directory will stay
     * the same as before calling this method.
     *
     * @param localDirPath  Local path, e.g. "foo/bar" or "../test"
     * @param [remoteDirPath]  Remote path of a directory to upload to. Working directory if undefined.
     */
    async uploadFromDir(w, F) {
      return this._exitAtCurrentDirectory(async () => (F && await this.ensureDir(F), await this._uploadToWorkingDir(w)));
    }
    /**
     * @protected
     */
    async _uploadToWorkingDir(w) {
      const F = await c(w);
      for (const b of F) {
        const G = (0, A.join)(w, b), T = await E(G);
        T.isFile() ? await this.uploadFrom(G, b) : T.isDirectory() && (await this._openDir(b), await this._uploadToWorkingDir(G), await this.cdup());
      }
    }
    /**
     * Download all files and directories of the working directory to a local directory.
     *
     * @param localDirPath  The local directory to download to.
     * @param remoteDirPath  Remote directory to download. Current working directory if not specified.
     */
    async downloadToDir(w, F) {
      return this._exitAtCurrentDirectory(async () => (F && await this.cd(F), await this._downloadFromWorkingDir(w)));
    }
    /**
     * @protected
     */
    async _downloadFromWorkingDir(w) {
      await y(w);
      for (const F of await this.list()) {
        const b = (0, A.join)(w, F.name);
        F.isDirectory ? (await this.cd(F.name), await this._downloadFromWorkingDir(b), await this.cdup()) : F.isFile && await this.downloadTo(b, F.name);
      }
    }
    /**
     * Make sure a given remote path exists, creating all directories as necessary.
     * This function also changes the current working directory to the given path.
     */
    async ensureDir(w) {
      w.startsWith("/") && await this.cd("/");
      const F = w.split("/").filter((b) => b !== "");
      for (const b of F)
        await this._openDir(b);
    }
    /**
     * Try to create a directory and enter it. This will not raise an exception if the directory
     * couldn't be created if for example it already exists.
     * @protected
     */
    async _openDir(w) {
      await this.sendIgnoringError("MKD " + w), await this.cd(w);
    }
    /**
     * Remove an empty directory, will fail if not empty.
     */
    async removeEmptyDir(w) {
      const F = await this.protectWhitespace(w);
      return this.send(`RMD ${F}`);
    }
    /**
     * FTP servers can't handle filenames that have leading whitespace. This method transforms
     * a given path to fix that issue for most cases.
     */
    async protectWhitespace(w) {
      if (!w.startsWith(" "))
        return w;
      const F = await this.pwd();
      return (F.endsWith("/") ? F : F + "/") + w;
    }
    async _exitAtCurrentDirectory(w) {
      const F = await this.pwd();
      try {
        return await w();
      } finally {
        this.closed || await m(() => this.cd(F));
      }
    }
    /**
     * Try all available transfer strategies and pick the first one that works. Update `client` to
     * use the working strategy for all successive transfer requests.
     *
     * @returns a function that will try the provided strategies.
     */
    _enterFirstCompatibleMode(w) {
      return async (F) => {
        F.log("Trying to find optimal transfer strategy...");
        let b;
        for (const G of w)
          try {
            const T = await G(F);
            return F.log("Optimal transfer strategy found."), this.prepareTransfer = G, T;
          } catch (T) {
            b = T;
          }
        throw new Error(`None of the available transfer strategies work. Last error response was '${b}'.`);
      };
    }
    /**
     * DEPRECATED, use `uploadFrom`.
     * @deprecated
     */
    async upload(w, F, b = {}) {
      return this.ftp.log("Warning: upload() has been deprecated, use uploadFrom()."), this.uploadFrom(w, F, b);
    }
    /**
     * DEPRECATED, use `appendFrom`.
     * @deprecated
     */
    async append(w, F, b = {}) {
      return this.ftp.log("Warning: append() has been deprecated, use appendFrom()."), this.appendFrom(w, F, b);
    }
    /**
     * DEPRECATED, use `downloadTo`.
     * @deprecated
     */
    async download(w, F, b = 0) {
      return this.ftp.log("Warning: download() has been deprecated, use downloadTo()."), this.downloadTo(w, F, b);
    }
    /**
     * DEPRECATED, use `uploadFromDir`.
     * @deprecated
     */
    async uploadDir(w, F) {
      return this.ftp.log("Warning: uploadDir() has been deprecated, use uploadFromDir()."), this.uploadFromDir(w, F);
    }
    /**
     * DEPRECATED, use `downloadToDir`.
     * @deprecated
     */
    async downloadDir(w) {
      return this.ftp.log("Warning: downloadDir() has been deprecated, use downloadToDir()."), this.downloadToDir(w);
    }
  };
  TI.Client = p;
  async function y(S) {
    try {
      await E(S);
    } catch {
      await C(S, { recursive: !0 });
    }
  }
  async function m(S) {
    try {
      return await S();
    } catch {
      return;
    }
  }
  return TI;
}
var qy = {}, cb;
function veA() {
  return cb || (cb = 1, Object.defineProperty(qy, "__esModule", { value: !0 })), qy;
}
var Ib;
function ReA() {
  return Ib || (Ib = 1, function(t) {
    var A = W && W.__createBinding || (Object.create ? function(i, n, s, a) {
      a === void 0 && (a = s);
      var g = Object.getOwnPropertyDescriptor(n, s);
      (!g || ("get" in g ? !n.__esModule : g.writable || g.configurable)) && (g = { enumerable: !0, get: function() {
        return n[s];
      } }), Object.defineProperty(i, a, g);
    } : function(i, n, s, a) {
      a === void 0 && (a = s), i[a] = n[s];
    }), e = W && W.__exportStar || function(i, n) {
      for (var s in i) s !== "default" && !Object.prototype.hasOwnProperty.call(n, s) && A(n, i, s);
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.enterPassiveModeIPv6 = t.enterPassiveModeIPv4 = void 0, e(keA(), t), e(HT(), t), e(Rp(), t), e(OT(), t), e(veA(), t);
    var r = qT();
    Object.defineProperty(t, "enterPassiveModeIPv4", { enumerable: !0, get: function() {
      return r.enterPassiveModeIPv4;
    } }), Object.defineProperty(t, "enterPassiveModeIPv6", { enumerable: !0, get: function() {
      return r.enterPassiveModeIPv6;
    } });
  }(Yy)), Yy;
}
var Cb;
function beA() {
  if (Cb) return UI;
  Cb = 1;
  var t = W && W.__importDefault || function(o) {
    return o && o.__esModule ? o : { default: o };
  };
  Object.defineProperty(UI, "__esModule", { value: !0 }), UI.ftp = void 0;
  const A = ReA(), e = Fn, r = SE, i = t(Ir), n = t(JS()), s = t(vp()), a = (0, i.default)("get-uri:ftp"), g = async (o, u = {}) => {
    const { cache: I } = u, c = decodeURIComponent(o.pathname);
    let C;
    if (!c)
      throw new TypeError('No "pathname"!');
    const E = new A.Client();
    try {
      const B = o.hostname || o.host || "localhost", h = parseInt(o.port || "0", 10) || 21, Q = o.username ? decodeURIComponent(o.username) : void 0, f = o.password ? decodeURIComponent(o.password) : void 0;
      await E.access({
        host: B,
        port: h,
        user: Q,
        password: f,
        ...u
      });
      try {
        C = await E.lastMod(c);
      } catch (m) {
        if (m.code === 550)
          throw new n.default();
      }
      if (!C) {
        const m = await E.list((0, r.dirname)(c)), S = (0, r.basename)(c), w = m.find((F) => F.name === S);
        w && (C = w.modifiedAt);
      }
      if (C) {
        if (l())
          throw new s.default();
      } else
        throw new n.default();
      const p = new e.PassThrough(), y = p;
      return E.downloadTo(p, c).then((m) => {
        a(m.message), E.close();
      }), y.lastModified = C, y;
    } catch (B) {
      throw E.close(), B;
    }
    function l() {
      return I != null && I.lastModified && C ? +I.lastModified == +C : !1;
    }
  };
  return UI.ftp = g, UI;
}
var jy = {}, Gh = {}, lb;
function MeA() {
  if (lb) return Gh;
  lb = 1, Object.defineProperty(Gh, "__esModule", { value: !0 });
  const t = wn;
  class A extends Error {
    constructor(r, i = t.STATUS_CODES[r]) {
      super(i), this.statusCode = r, this.code = `E${String(i).toUpperCase().replace(/\s+/g, "")}`;
    }
  }
  return Gh.default = A, Gh;
}
var Bb;
function jT() {
  return Bb || (Bb = 1, function(t) {
    var A = W && W.__importDefault || function(C) {
      return C && C.__esModule ? C : { default: C };
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.http = void 0;
    const e = A(wn), r = A(mn), i = rI, n = A(Ir), s = A(MeA()), a = A(JS()), g = A(vp()), o = (0, n.default)("get-uri:http"), u = async (C, E = {}) => {
      o("GET %o", C.href);
      const l = c(C, E.cache);
      if (l && I(l) && typeof l.statusCode == "number")
        throw (l.statusCode / 100 | 0) === 3 && l.headers.location ? (o("cached redirect"), new Error("TODO: implement cached redirects!")) : new g.default();
      const B = typeof E.maxRedirects == "number" ? E.maxRedirects : 5;
      o("allowing %o max redirects", B);
      let h;
      E.http ? (h = E.http, o("using secure `https` core module")) : (h = e.default, o("using `http` core module"));
      const Q = { ...E };
      if (l) {
        Q.headers || (Q.headers = {});
        const w = l.headers["last-modified"];
        w && (Q.headers["If-Modified-Since"] = w, o('added "If-Modified-Since" request header: %o', w));
        const F = l.headers.etag;
        F && (Q.headers["If-None-Match"] = F, o('added "If-None-Match" request header: %o', F));
      }
      const f = h.get(C, Q), [p] = await (0, i.once)(f, "response"), y = p.statusCode || 0;
      p.date = Date.now(), p.parsed = C, o("got %o response status code", y);
      const m = y / 100 | 0, S = p.headers.location;
      if (m === 3 && S) {
        E.redirects || (E.redirects = []);
        const w = E.redirects;
        if (w.length < B) {
          o('got a "redirect" status code with Location: %o', S), p.resume(), w.push(p);
          const F = new URL(S, C.href);
          o("resolved redirect URL: %o", F.href);
          const b = B - w.length;
          return o("%o more redirects allowed after this one", b), F.protocol !== C.protocol && (E.http = F.protocol === "https:" ? r.default : void 0), (0, t.http)(F, E);
        }
      }
      if (m !== 2)
        throw p.resume(), y === 304 ? new g.default() : y === 404 ? new a.default() : new s.default(y);
      return E.redirects && (p.redirects = E.redirects), p;
    };
    t.http = u;
    function I(C) {
      let E = !1, l = parseInt(C.headers.expires || "", 10);
      const B = C.headers["cache-control"];
      if (B) {
        o("Cache-Control: %o", B);
        const h = B.split(/,\s*?\b/);
        for (let Q = 0; Q < h.length; Q++) {
          const f = h[Q], p = f.split("="), y = p[0];
          switch (y) {
            case "max-age":
              return l = (C.date || 0) + parseInt(p[1], 10) * 1e3, E = Date.now() < l, E && o('cache is "fresh" due to previous %o Cache-Control param', f), E;
            case "must-revalidate":
              break;
            case "no-cache":
            case "no-store":
              return o('cache is "stale" due to explicit %o Cache-Control param', y), !1;
          }
        }
      } else if (l)
        return o("Expires: %o", l), E = Date.now() < l, E && o('cache is "fresh" due to previous Expires response header'), E;
      return !1;
    }
    function c(C, E) {
      if (E) {
        if (E.parsed && E.parsed.href === C.href)
          return E;
        if (E.redirects)
          for (let l = 0; l < E.redirects.length; l++) {
            const B = c(C, E.redirects[l]);
            if (B)
              return B;
          }
      }
      return null;
    }
  }(jy)), jy;
}
var PI = {}, Eb;
function _eA() {
  if (Eb) return PI;
  Eb = 1;
  var t = W && W.__importDefault || function(i) {
    return i && i.__esModule ? i : { default: i };
  };
  Object.defineProperty(PI, "__esModule", { value: !0 }), PI.https = void 0;
  const A = t(mn), e = jT(), r = (i, n) => (0, e.http)(i, { ...n, http: A.default });
  return PI.https = r, PI;
}
var hb;
function NeA() {
  return hb || (hb = 1, function(t) {
    var A = W && W.__importDefault || function(c) {
      return c && c.__esModule ? c : { default: c };
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.getUri = t.isValidProtocol = t.protocols = void 0;
    const e = A(Ir), r = yeA(), i = weA(), n = beA(), s = jT(), a = _eA(), g = (0, e.default)("get-uri");
    t.protocols = {
      data: r.data,
      file: i.file,
      ftp: n.ftp,
      http: s.http,
      https: a.https
    };
    const o = new Set(Object.keys(t.protocols));
    function u(c) {
      return o.has(c);
    }
    t.isValidProtocol = u;
    async function I(c, C) {
      if (g("getUri(%o)", c), !c)
        throw new TypeError('Must pass in a URI to "getUri()"');
      const E = typeof c == "string" ? new URL(c) : c, l = E.protocol.replace(/:$/, "");
      if (!u(l))
        throw new TypeError(`Unsupported protocol "${l}" specified in URI: "${c}"`);
      const B = t.protocols[l];
      return B(E, C);
    }
    t.getUri = I;
  }(Oy)), Oy;
}
var Wy = {}, Vy = {}, OI = {}, Zy = {}, Xy = {}, Qb;
function LeA() {
  return Qb || (Qb = 1, function(t) {
    (function A(e) {
      var r, i, n, s, a, g;
      function o(y) {
        var m = {}, S, w;
        for (S in y)
          y.hasOwnProperty(S) && (w = y[S], typeof w == "object" && w !== null ? m[S] = o(w) : m[S] = w);
        return m;
      }
      function u(y, m) {
        var S, w, F, b;
        for (w = y.length, F = 0; w; )
          S = w >>> 1, b = F + S, m(y[b]) ? w = S : (F = b + 1, w -= S + 1);
        return F;
      }
      r = {
        AssignmentExpression: "AssignmentExpression",
        AssignmentPattern: "AssignmentPattern",
        ArrayExpression: "ArrayExpression",
        ArrayPattern: "ArrayPattern",
        ArrowFunctionExpression: "ArrowFunctionExpression",
        AwaitExpression: "AwaitExpression",
        // CAUTION: It's deferred to ES7.
        BlockStatement: "BlockStatement",
        BinaryExpression: "BinaryExpression",
        BreakStatement: "BreakStatement",
        CallExpression: "CallExpression",
        CatchClause: "CatchClause",
        ChainExpression: "ChainExpression",
        ClassBody: "ClassBody",
        ClassDeclaration: "ClassDeclaration",
        ClassExpression: "ClassExpression",
        ComprehensionBlock: "ComprehensionBlock",
        // CAUTION: It's deferred to ES7.
        ComprehensionExpression: "ComprehensionExpression",
        // CAUTION: It's deferred to ES7.
        ConditionalExpression: "ConditionalExpression",
        ContinueStatement: "ContinueStatement",
        DebuggerStatement: "DebuggerStatement",
        DirectiveStatement: "DirectiveStatement",
        DoWhileStatement: "DoWhileStatement",
        EmptyStatement: "EmptyStatement",
        ExportAllDeclaration: "ExportAllDeclaration",
        ExportDefaultDeclaration: "ExportDefaultDeclaration",
        ExportNamedDeclaration: "ExportNamedDeclaration",
        ExportSpecifier: "ExportSpecifier",
        ExpressionStatement: "ExpressionStatement",
        ForStatement: "ForStatement",
        ForInStatement: "ForInStatement",
        ForOfStatement: "ForOfStatement",
        FunctionDeclaration: "FunctionDeclaration",
        FunctionExpression: "FunctionExpression",
        GeneratorExpression: "GeneratorExpression",
        // CAUTION: It's deferred to ES7.
        Identifier: "Identifier",
        IfStatement: "IfStatement",
        ImportExpression: "ImportExpression",
        ImportDeclaration: "ImportDeclaration",
        ImportDefaultSpecifier: "ImportDefaultSpecifier",
        ImportNamespaceSpecifier: "ImportNamespaceSpecifier",
        ImportSpecifier: "ImportSpecifier",
        Literal: "Literal",
        LabeledStatement: "LabeledStatement",
        LogicalExpression: "LogicalExpression",
        MemberExpression: "MemberExpression",
        MetaProperty: "MetaProperty",
        MethodDefinition: "MethodDefinition",
        ModuleSpecifier: "ModuleSpecifier",
        NewExpression: "NewExpression",
        ObjectExpression: "ObjectExpression",
        ObjectPattern: "ObjectPattern",
        PrivateIdentifier: "PrivateIdentifier",
        Program: "Program",
        Property: "Property",
        PropertyDefinition: "PropertyDefinition",
        RestElement: "RestElement",
        ReturnStatement: "ReturnStatement",
        SequenceExpression: "SequenceExpression",
        SpreadElement: "SpreadElement",
        Super: "Super",
        SwitchStatement: "SwitchStatement",
        SwitchCase: "SwitchCase",
        TaggedTemplateExpression: "TaggedTemplateExpression",
        TemplateElement: "TemplateElement",
        TemplateLiteral: "TemplateLiteral",
        ThisExpression: "ThisExpression",
        ThrowStatement: "ThrowStatement",
        TryStatement: "TryStatement",
        UnaryExpression: "UnaryExpression",
        UpdateExpression: "UpdateExpression",
        VariableDeclaration: "VariableDeclaration",
        VariableDeclarator: "VariableDeclarator",
        WhileStatement: "WhileStatement",
        WithStatement: "WithStatement",
        YieldExpression: "YieldExpression"
      }, n = {
        AssignmentExpression: ["left", "right"],
        AssignmentPattern: ["left", "right"],
        ArrayExpression: ["elements"],
        ArrayPattern: ["elements"],
        ArrowFunctionExpression: ["params", "body"],
        AwaitExpression: ["argument"],
        // CAUTION: It's deferred to ES7.
        BlockStatement: ["body"],
        BinaryExpression: ["left", "right"],
        BreakStatement: ["label"],
        CallExpression: ["callee", "arguments"],
        CatchClause: ["param", "body"],
        ChainExpression: ["expression"],
        ClassBody: ["body"],
        ClassDeclaration: ["id", "superClass", "body"],
        ClassExpression: ["id", "superClass", "body"],
        ComprehensionBlock: ["left", "right"],
        // CAUTION: It's deferred to ES7.
        ComprehensionExpression: ["blocks", "filter", "body"],
        // CAUTION: It's deferred to ES7.
        ConditionalExpression: ["test", "consequent", "alternate"],
        ContinueStatement: ["label"],
        DebuggerStatement: [],
        DirectiveStatement: [],
        DoWhileStatement: ["body", "test"],
        EmptyStatement: [],
        ExportAllDeclaration: ["source"],
        ExportDefaultDeclaration: ["declaration"],
        ExportNamedDeclaration: ["declaration", "specifiers", "source"],
        ExportSpecifier: ["exported", "local"],
        ExpressionStatement: ["expression"],
        ForStatement: ["init", "test", "update", "body"],
        ForInStatement: ["left", "right", "body"],
        ForOfStatement: ["left", "right", "body"],
        FunctionDeclaration: ["id", "params", "body"],
        FunctionExpression: ["id", "params", "body"],
        GeneratorExpression: ["blocks", "filter", "body"],
        // CAUTION: It's deferred to ES7.
        Identifier: [],
        IfStatement: ["test", "consequent", "alternate"],
        ImportExpression: ["source"],
        ImportDeclaration: ["specifiers", "source"],
        ImportDefaultSpecifier: ["local"],
        ImportNamespaceSpecifier: ["local"],
        ImportSpecifier: ["imported", "local"],
        Literal: [],
        LabeledStatement: ["label", "body"],
        LogicalExpression: ["left", "right"],
        MemberExpression: ["object", "property"],
        MetaProperty: ["meta", "property"],
        MethodDefinition: ["key", "value"],
        ModuleSpecifier: [],
        NewExpression: ["callee", "arguments"],
        ObjectExpression: ["properties"],
        ObjectPattern: ["properties"],
        PrivateIdentifier: [],
        Program: ["body"],
        Property: ["key", "value"],
        PropertyDefinition: ["key", "value"],
        RestElement: ["argument"],
        ReturnStatement: ["argument"],
        SequenceExpression: ["expressions"],
        SpreadElement: ["argument"],
        Super: [],
        SwitchStatement: ["discriminant", "cases"],
        SwitchCase: ["test", "consequent"],
        TaggedTemplateExpression: ["tag", "quasi"],
        TemplateElement: [],
        TemplateLiteral: ["quasis", "expressions"],
        ThisExpression: [],
        ThrowStatement: ["argument"],
        TryStatement: ["block", "handler", "finalizer"],
        UnaryExpression: ["argument"],
        UpdateExpression: ["argument"],
        VariableDeclaration: ["declarations"],
        VariableDeclarator: ["id", "init"],
        WhileStatement: ["test", "body"],
        WithStatement: ["object", "body"],
        YieldExpression: ["argument"]
      }, s = {}, a = {}, g = {}, i = {
        Break: s,
        Skip: a,
        Remove: g
      };
      function I(y, m) {
        this.parent = y, this.key = m;
      }
      I.prototype.replace = function(m) {
        this.parent[this.key] = m;
      }, I.prototype.remove = function() {
        return Array.isArray(this.parent) ? (this.parent.splice(this.key, 1), !0) : (this.replace(null), !1);
      };
      function c(y, m, S, w) {
        this.node = y, this.path = m, this.wrap = S, this.ref = w;
      }
      function C() {
      }
      C.prototype.path = function() {
        var m, S, w, F, b, G;
        function T(K, H) {
          if (Array.isArray(H))
            for (w = 0, F = H.length; w < F; ++w)
              K.push(H[w]);
          else
            K.push(H);
        }
        if (!this.__current.path)
          return null;
        for (b = [], m = 2, S = this.__leavelist.length; m < S; ++m)
          G = this.__leavelist[m], T(b, G.path);
        return T(b, this.__current.path), b;
      }, C.prototype.type = function() {
        var y = this.current();
        return y.type || this.__current.wrap;
      }, C.prototype.parents = function() {
        var m, S, w;
        for (w = [], m = 1, S = this.__leavelist.length; m < S; ++m)
          w.push(this.__leavelist[m].node);
        return w;
      }, C.prototype.current = function() {
        return this.__current.node;
      }, C.prototype.__execute = function(m, S) {
        var w, F;
        return F = void 0, w = this.__current, this.__current = S, this.__state = null, m && (F = m.call(this, S.node, this.__leavelist[this.__leavelist.length - 1].node)), this.__current = w, F;
      }, C.prototype.notify = function(m) {
        this.__state = m;
      }, C.prototype.skip = function() {
        this.notify(a);
      }, C.prototype.break = function() {
        this.notify(s);
      }, C.prototype.remove = function() {
        this.notify(g);
      }, C.prototype.__initialize = function(y, m) {
        this.visitor = m, this.root = y, this.__worklist = [], this.__leavelist = [], this.__current = null, this.__state = null, this.__fallback = null, m.fallback === "iteration" ? this.__fallback = Object.keys : typeof m.fallback == "function" && (this.__fallback = m.fallback), this.__keys = n, m.keys && (this.__keys = Object.assign(Object.create(this.__keys), m.keys));
      };
      function E(y) {
        return y == null ? !1 : typeof y == "object" && typeof y.type == "string";
      }
      function l(y, m) {
        return (y === r.ObjectExpression || y === r.ObjectPattern) && m === "properties";
      }
      function B(y, m) {
        for (var S = y.length - 1; S >= 0; --S)
          if (y[S].node === m)
            return !0;
        return !1;
      }
      C.prototype.traverse = function(m, S) {
        var w, F, b, G, T, K, H, j, eA, sA, uA, rA;
        for (this.__initialize(m, S), rA = {}, w = this.__worklist, F = this.__leavelist, w.push(new c(m, null, null, null)), F.push(new c(null, null, null, null)); w.length; ) {
          if (b = w.pop(), b === rA) {
            if (b = F.pop(), K = this.__execute(S.leave, b), this.__state === s || K === s)
              return;
            continue;
          }
          if (b.node) {
            if (K = this.__execute(S.enter, b), this.__state === s || K === s)
              return;
            if (w.push(rA), F.push(b), this.__state === a || K === a)
              continue;
            if (G = b.node, T = G.type || b.wrap, sA = this.__keys[T], !sA)
              if (this.__fallback)
                sA = this.__fallback(G);
              else
                throw new Error("Unknown node type " + T + ".");
            for (j = sA.length; (j -= 1) >= 0; )
              if (H = sA[j], uA = G[H], !!uA) {
                if (Array.isArray(uA)) {
                  for (eA = uA.length; (eA -= 1) >= 0; )
                    if (uA[eA] && !B(F, uA[eA])) {
                      if (l(T, sA[j]))
                        b = new c(uA[eA], [H, eA], "Property", null);
                      else if (E(uA[eA]))
                        b = new c(uA[eA], [H, eA], null, null);
                      else
                        continue;
                      w.push(b);
                    }
                } else if (E(uA)) {
                  if (B(F, uA))
                    continue;
                  w.push(new c(uA, H, null, null));
                }
              }
          }
        }
      }, C.prototype.replace = function(m, S) {
        var w, F, b, G, T, K, H, j, eA, sA, uA, rA, hA;
        function UA(iA) {
          var wA, Re, zA, U;
          if (iA.ref.remove()) {
            for (Re = iA.ref.key, U = iA.ref.parent, wA = w.length; wA--; )
              if (zA = w[wA], zA.ref && zA.ref.parent === U) {
                if (zA.ref.key < Re)
                  break;
                --zA.ref.key;
              }
          }
        }
        for (this.__initialize(m, S), uA = {}, w = this.__worklist, F = this.__leavelist, rA = {
          root: m
        }, K = new c(m, null, null, new I(rA, "root")), w.push(K), F.push(K); w.length; ) {
          if (K = w.pop(), K === uA) {
            if (K = F.pop(), T = this.__execute(S.leave, K), T !== void 0 && T !== s && T !== a && T !== g && K.ref.replace(T), (this.__state === g || T === g) && UA(K), this.__state === s || T === s)
              return rA.root;
            continue;
          }
          if (T = this.__execute(S.enter, K), T !== void 0 && T !== s && T !== a && T !== g && (K.ref.replace(T), K.node = T), (this.__state === g || T === g) && (UA(K), K.node = null), this.__state === s || T === s)
            return rA.root;
          if (b = K.node, !!b && (w.push(uA), F.push(K), !(this.__state === a || T === a))) {
            if (G = b.type || K.wrap, eA = this.__keys[G], !eA)
              if (this.__fallback)
                eA = this.__fallback(b);
              else
                throw new Error("Unknown node type " + G + ".");
            for (H = eA.length; (H -= 1) >= 0; )
              if (hA = eA[H], sA = b[hA], !!sA)
                if (Array.isArray(sA)) {
                  for (j = sA.length; (j -= 1) >= 0; )
                    if (sA[j]) {
                      if (l(G, eA[H]))
                        K = new c(sA[j], [hA, j], "Property", new I(sA, j));
                      else if (E(sA[j]))
                        K = new c(sA[j], [hA, j], null, new I(sA, j));
                      else
                        continue;
                      w.push(K);
                    }
                } else E(sA) && w.push(new c(sA, hA, null, new I(b, hA)));
          }
        }
        return rA.root;
      };
      function h(y, m) {
        var S = new C();
        return S.traverse(y, m);
      }
      function Q(y, m) {
        var S = new C();
        return S.replace(y, m);
      }
      function f(y, m) {
        var S;
        return S = u(m, function(F) {
          return F.range[0] > y.range[0];
        }), y.extendedRange = [y.range[0], y.range[1]], S !== m.length && (y.extendedRange[1] = m[S].range[0]), S -= 1, S >= 0 && (y.extendedRange[0] = m[S].range[1]), y;
      }
      function p(y, m, S) {
        var w = [], F, b, G, T;
        if (!y.range)
          throw new Error("attachComments needs range information");
        if (!S.length) {
          if (m.length) {
            for (G = 0, b = m.length; G < b; G += 1)
              F = o(m[G]), F.extendedRange = [0, y.range[0]], w.push(F);
            y.leadingComments = w;
          }
          return y;
        }
        for (G = 0, b = m.length; G < b; G += 1)
          w.push(f(o(m[G]), S));
        return T = 0, h(y, {
          enter: function(K) {
            for (var H; T < w.length && (H = w[T], !(H.extendedRange[1] > K.range[0])); )
              H.extendedRange[1] === K.range[0] ? (K.leadingComments || (K.leadingComments = []), K.leadingComments.push(H), w.splice(T, 1)) : T += 1;
            if (T === w.length)
              return i.Break;
            if (w[T].extendedRange[0] > K.range[1])
              return i.Skip;
          }
        }), T = 0, h(y, {
          leave: function(K) {
            for (var H; T < w.length && (H = w[T], !(K.range[1] < H.extendedRange[0])); )
              K.range[1] === H.extendedRange[0] ? (K.trailingComments || (K.trailingComments = []), K.trailingComments.push(H), w.splice(T, 1)) : T += 1;
            if (T === w.length)
              return i.Break;
            if (w[T].extendedRange[0] > K.range[1])
              return i.Skip;
          }
        }), y;
      }
      return e.Syntax = r, e.traverse = h, e.replace = Q, e.attachComments = p, e.VisitorKeys = n, e.VisitorOption = i, e.Controller = C, e.cloneEnvironment = function() {
        return A({});
      }, e;
    })(t);
  }(Xy)), Xy;
}
var YI = {}, zy = { exports: {} }, db;
function xeA() {
  return db || (db = 1, function() {
    function t(s) {
      if (s == null)
        return !1;
      switch (s.type) {
        case "ArrayExpression":
        case "AssignmentExpression":
        case "BinaryExpression":
        case "CallExpression":
        case "ConditionalExpression":
        case "FunctionExpression":
        case "Identifier":
        case "Literal":
        case "LogicalExpression":
        case "MemberExpression":
        case "NewExpression":
        case "ObjectExpression":
        case "SequenceExpression":
        case "ThisExpression":
        case "UnaryExpression":
        case "UpdateExpression":
          return !0;
      }
      return !1;
    }
    function A(s) {
      if (s == null)
        return !1;
      switch (s.type) {
        case "DoWhileStatement":
        case "ForInStatement":
        case "ForStatement":
        case "WhileStatement":
          return !0;
      }
      return !1;
    }
    function e(s) {
      if (s == null)
        return !1;
      switch (s.type) {
        case "BlockStatement":
        case "BreakStatement":
        case "ContinueStatement":
        case "DebuggerStatement":
        case "DoWhileStatement":
        case "EmptyStatement":
        case "ExpressionStatement":
        case "ForInStatement":
        case "ForStatement":
        case "IfStatement":
        case "LabeledStatement":
        case "ReturnStatement":
        case "SwitchStatement":
        case "ThrowStatement":
        case "TryStatement":
        case "VariableDeclaration":
        case "WhileStatement":
        case "WithStatement":
          return !0;
      }
      return !1;
    }
    function r(s) {
      return e(s) || s != null && s.type === "FunctionDeclaration";
    }
    function i(s) {
      switch (s.type) {
        case "IfStatement":
          return s.alternate != null ? s.alternate : s.consequent;
        case "LabeledStatement":
        case "ForStatement":
        case "ForInStatement":
        case "WhileStatement":
        case "WithStatement":
          return s.body;
      }
      return null;
    }
    function n(s) {
      var a;
      if (s.type !== "IfStatement" || s.alternate == null)
        return !1;
      a = s.consequent;
      do {
        if (a.type === "IfStatement" && a.alternate == null)
          return !0;
        a = i(a);
      } while (a);
      return !1;
    }
    zy.exports = {
      isExpression: t,
      isStatement: e,
      isIterationStatement: A,
      isSourceElement: r,
      isProblematicIfStatement: n,
      trailingStatement: i
    };
  }()), zy.exports;
}
var $y = { exports: {} }, fb;
function WT() {
  return fb || (fb = 1, function() {
    var t, A, e, r, i, n;
    A = {
      // ECMAScript 5.1/Unicode v9.0.0 NonAsciiIdentifierStart:
      NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/,
      // ECMAScript 5.1/Unicode v9.0.0 NonAsciiIdentifierPart:
      NonAsciiIdentifierPart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/
    }, t = {
      // ECMAScript 6/Unicode v9.0.0 NonAsciiIdentifierStart:
      NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,
      // ECMAScript 6/Unicode v9.0.0 NonAsciiIdentifierPart:
      NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
    };
    function s(B) {
      return 48 <= B && B <= 57;
    }
    function a(B) {
      return 48 <= B && B <= 57 || // 0..9
      97 <= B && B <= 102 || // a..f
      65 <= B && B <= 70;
    }
    function g(B) {
      return B >= 48 && B <= 55;
    }
    e = [
      5760,
      8192,
      8193,
      8194,
      8195,
      8196,
      8197,
      8198,
      8199,
      8200,
      8201,
      8202,
      8239,
      8287,
      12288,
      65279
    ];
    function o(B) {
      return B === 32 || B === 9 || B === 11 || B === 12 || B === 160 || B >= 5760 && e.indexOf(B) >= 0;
    }
    function u(B) {
      return B === 10 || B === 13 || B === 8232 || B === 8233;
    }
    function I(B) {
      if (B <= 65535)
        return String.fromCharCode(B);
      var h = String.fromCharCode(Math.floor((B - 65536) / 1024) + 55296), Q = String.fromCharCode((B - 65536) % 1024 + 56320);
      return h + Q;
    }
    for (r = new Array(128), n = 0; n < 128; ++n)
      r[n] = n >= 97 && n <= 122 || // a..z
      n >= 65 && n <= 90 || // A..Z
      n === 36 || n === 95;
    for (i = new Array(128), n = 0; n < 128; ++n)
      i[n] = n >= 97 && n <= 122 || // a..z
      n >= 65 && n <= 90 || // A..Z
      n >= 48 && n <= 57 || // 0..9
      n === 36 || n === 95;
    function c(B) {
      return B < 128 ? r[B] : A.NonAsciiIdentifierStart.test(I(B));
    }
    function C(B) {
      return B < 128 ? i[B] : A.NonAsciiIdentifierPart.test(I(B));
    }
    function E(B) {
      return B < 128 ? r[B] : t.NonAsciiIdentifierStart.test(I(B));
    }
    function l(B) {
      return B < 128 ? i[B] : t.NonAsciiIdentifierPart.test(I(B));
    }
    $y.exports = {
      isDecimalDigit: s,
      isHexDigit: a,
      isOctalDigit: g,
      isWhiteSpace: o,
      isLineTerminator: u,
      isIdentifierStartES5: c,
      isIdentifierPartES5: C,
      isIdentifierStartES6: E,
      isIdentifierPartES6: l
    };
  }()), $y.exports;
}
var Aw = { exports: {} }, pb;
function GeA() {
  return pb || (pb = 1, function() {
    var t = WT();
    function A(c) {
      switch (c) {
        case "implements":
        case "interface":
        case "package":
        case "private":
        case "protected":
        case "public":
        case "static":
        case "let":
          return !0;
        default:
          return !1;
      }
    }
    function e(c, C) {
      return !C && c === "yield" ? !1 : r(c, C);
    }
    function r(c, C) {
      if (C && A(c))
        return !0;
      switch (c.length) {
        case 2:
          return c === "if" || c === "in" || c === "do";
        case 3:
          return c === "var" || c === "for" || c === "new" || c === "try";
        case 4:
          return c === "this" || c === "else" || c === "case" || c === "void" || c === "with" || c === "enum";
        case 5:
          return c === "while" || c === "break" || c === "catch" || c === "throw" || c === "const" || c === "yield" || c === "class" || c === "super";
        case 6:
          return c === "return" || c === "typeof" || c === "delete" || c === "switch" || c === "export" || c === "import";
        case 7:
          return c === "default" || c === "finally" || c === "extends";
        case 8:
          return c === "function" || c === "continue" || c === "debugger";
        case 10:
          return c === "instanceof";
        default:
          return !1;
      }
    }
    function i(c, C) {
      return c === "null" || c === "true" || c === "false" || e(c, C);
    }
    function n(c, C) {
      return c === "null" || c === "true" || c === "false" || r(c, C);
    }
    function s(c) {
      return c === "eval" || c === "arguments";
    }
    function a(c) {
      var C, E, l;
      if (c.length === 0 || (l = c.charCodeAt(0), !t.isIdentifierStartES5(l)))
        return !1;
      for (C = 1, E = c.length; C < E; ++C)
        if (l = c.charCodeAt(C), !t.isIdentifierPartES5(l))
          return !1;
      return !0;
    }
    function g(c, C) {
      return (c - 55296) * 1024 + (C - 56320) + 65536;
    }
    function o(c) {
      var C, E, l, B, h;
      if (c.length === 0)
        return !1;
      for (h = t.isIdentifierStartES6, C = 0, E = c.length; C < E; ++C) {
        if (l = c.charCodeAt(C), 55296 <= l && l <= 56319) {
          if (++C, C >= E || (B = c.charCodeAt(C), !(56320 <= B && B <= 57343)))
            return !1;
          l = g(l, B);
        }
        if (!h(l))
          return !1;
        h = t.isIdentifierPartES6;
      }
      return !0;
    }
    function u(c, C) {
      return a(c) && !i(c, C);
    }
    function I(c, C) {
      return o(c) && !n(c, C);
    }
    Aw.exports = {
      isKeywordES5: e,
      isKeywordES6: r,
      isReservedWordES5: i,
      isReservedWordES6: n,
      isRestrictedWord: s,
      isIdentifierNameES5: a,
      isIdentifierNameES6: o,
      isIdentifierES5: u,
      isIdentifierES6: I
    };
  }()), Aw.exports;
}
var yb;
function UeA() {
  return yb || (yb = 1, function() {
    YI.ast = xeA(), YI.code = WT(), YI.keyword = GeA();
  }()), YI;
}
var qI = {}, ew = {}, Uh = {}, Th = {}, wb;
function TeA() {
  if (wb) return Th;
  wb = 1;
  var t = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
  return Th.encode = function(A) {
    if (0 <= A && A < t.length)
      return t[A];
    throw new TypeError("Must be between 0 and 63: " + A);
  }, Th.decode = function(A) {
    var e = 65, r = 90, i = 97, n = 122, s = 48, a = 57, g = 43, o = 47, u = 26, I = 52;
    return e <= A && A <= r ? A - e : i <= A && A <= n ? A - i + u : s <= A && A <= a ? A - s + I : A == g ? 62 : A == o ? 63 : -1;
  }, Th;
}
var mb;
function VT() {
  if (mb) return Uh;
  mb = 1;
  var t = TeA(), A = 5, e = 1 << A, r = e - 1, i = e;
  function n(a) {
    return a < 0 ? (-a << 1) + 1 : (a << 1) + 0;
  }
  function s(a) {
    var g = (a & 1) === 1, o = a >> 1;
    return g ? -o : o;
  }
  return Uh.encode = function(g) {
    var o = "", u, I = n(g);
    do
      u = I & r, I >>>= A, I > 0 && (u |= i), o += t.encode(u);
    while (I > 0);
    return o;
  }, Uh.decode = function(g, o, u) {
    var I = g.length, c = 0, C = 0, E, l;
    do {
      if (o >= I)
        throw new Error("Expected more digits in base 64 VLQ value.");
      if (l = t.decode(g.charCodeAt(o++)), l === -1)
        throw new Error("Invalid base64 digit: " + g.charAt(o - 1));
      E = !!(l & i), l &= r, c = c + (l << C), C += A;
    } while (E);
    u.value = s(c), u.rest = o;
  }, Uh;
}
var tw = {}, Db;
function jE() {
  return Db || (Db = 1, function(t) {
    function A(p, y, m) {
      if (y in p)
        return p[y];
      if (arguments.length === 3)
        return m;
      throw new Error('"' + y + '" is a required argument.');
    }
    t.getArg = A;
    var e = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/, r = /^data:.+\,.+$/;
    function i(p) {
      var y = p.match(e);
      return y ? {
        scheme: y[1],
        auth: y[2],
        host: y[3],
        port: y[4],
        path: y[5]
      } : null;
    }
    t.urlParse = i;
    function n(p) {
      var y = "";
      return p.scheme && (y += p.scheme + ":"), y += "//", p.auth && (y += p.auth + "@"), p.host && (y += p.host), p.port && (y += ":" + p.port), p.path && (y += p.path), y;
    }
    t.urlGenerate = n;
    function s(p) {
      var y = p, m = i(p);
      if (m) {
        if (!m.path)
          return p;
        y = m.path;
      }
      for (var S = t.isAbsolute(y), w = y.split(/\/+/), F, b = 0, G = w.length - 1; G >= 0; G--)
        F = w[G], F === "." ? w.splice(G, 1) : F === ".." ? b++ : b > 0 && (F === "" ? (w.splice(G + 1, b), b = 0) : (w.splice(G, 2), b--));
      return y = w.join("/"), y === "" && (y = S ? "/" : "."), m ? (m.path = y, n(m)) : y;
    }
    t.normalize = s;
    function a(p, y) {
      p === "" && (p = "."), y === "" && (y = ".");
      var m = i(y), S = i(p);
      if (S && (p = S.path || "/"), m && !m.scheme)
        return S && (m.scheme = S.scheme), n(m);
      if (m || y.match(r))
        return y;
      if (S && !S.host && !S.path)
        return S.host = y, n(S);
      var w = y.charAt(0) === "/" ? y : s(p.replace(/\/+$/, "") + "/" + y);
      return S ? (S.path = w, n(S)) : w;
    }
    t.join = a, t.isAbsolute = function(p) {
      return p.charAt(0) === "/" || e.test(p);
    };
    function g(p, y) {
      p === "" && (p = "."), p = p.replace(/\/$/, "");
      for (var m = 0; y.indexOf(p + "/") !== 0; ) {
        var S = p.lastIndexOf("/");
        if (S < 0 || (p = p.slice(0, S), p.match(/^([^\/]+:\/)?\/*$/)))
          return y;
        ++m;
      }
      return Array(m + 1).join("../") + y.substr(p.length + 1);
    }
    t.relative = g;
    var o = function() {
      var p = /* @__PURE__ */ Object.create(null);
      return !("__proto__" in p);
    }();
    function u(p) {
      return p;
    }
    function I(p) {
      return C(p) ? "$" + p : p;
    }
    t.toSetString = o ? u : I;
    function c(p) {
      return C(p) ? p.slice(1) : p;
    }
    t.fromSetString = o ? u : c;
    function C(p) {
      if (!p)
        return !1;
      var y = p.length;
      if (y < 9 || p.charCodeAt(y - 1) !== 95 || p.charCodeAt(y - 2) !== 95 || p.charCodeAt(y - 3) !== 111 || p.charCodeAt(y - 4) !== 116 || p.charCodeAt(y - 5) !== 111 || p.charCodeAt(y - 6) !== 114 || p.charCodeAt(y - 7) !== 112 || p.charCodeAt(y - 8) !== 95 || p.charCodeAt(y - 9) !== 95)
        return !1;
      for (var m = y - 10; m >= 0; m--)
        if (p.charCodeAt(m) !== 36)
          return !1;
      return !0;
    }
    function E(p, y, m) {
      var S = B(p.source, y.source);
      return S !== 0 || (S = p.originalLine - y.originalLine, S !== 0) || (S = p.originalColumn - y.originalColumn, S !== 0 || m) || (S = p.generatedColumn - y.generatedColumn, S !== 0) || (S = p.generatedLine - y.generatedLine, S !== 0) ? S : B(p.name, y.name);
    }
    t.compareByOriginalPositions = E;
    function l(p, y, m) {
      var S = p.generatedLine - y.generatedLine;
      return S !== 0 || (S = p.generatedColumn - y.generatedColumn, S !== 0 || m) || (S = B(p.source, y.source), S !== 0) || (S = p.originalLine - y.originalLine, S !== 0) || (S = p.originalColumn - y.originalColumn, S !== 0) ? S : B(p.name, y.name);
    }
    t.compareByGeneratedPositionsDeflated = l;
    function B(p, y) {
      return p === y ? 0 : p === null ? 1 : y === null ? -1 : p > y ? 1 : -1;
    }
    function h(p, y) {
      var m = p.generatedLine - y.generatedLine;
      return m !== 0 || (m = p.generatedColumn - y.generatedColumn, m !== 0) || (m = B(p.source, y.source), m !== 0) || (m = p.originalLine - y.originalLine, m !== 0) || (m = p.originalColumn - y.originalColumn, m !== 0) ? m : B(p.name, y.name);
    }
    t.compareByGeneratedPositionsInflated = h;
    function Q(p) {
      return JSON.parse(p.replace(/^\)]}'[^\n]*\n/, ""));
    }
    t.parseSourceMapInput = Q;
    function f(p, y, m) {
      if (y = y || "", p && (p[p.length - 1] !== "/" && y[0] !== "/" && (p += "/"), y = p + y), m) {
        var S = i(m);
        if (!S)
          throw new Error("sourceMapURL could not be parsed");
        if (S.path) {
          var w = S.path.lastIndexOf("/");
          w >= 0 && (S.path = S.path.substring(0, w + 1));
        }
        y = a(n(S), y);
      }
      return s(y);
    }
    t.computeSourceURL = f;
  }(tw)), tw;
}
var rw = {}, Sb;
function ZT() {
  if (Sb) return rw;
  Sb = 1;
  var t = jE(), A = Object.prototype.hasOwnProperty, e = typeof Map < "u";
  function r() {
    this._array = [], this._set = e ? /* @__PURE__ */ new Map() : /* @__PURE__ */ Object.create(null);
  }
  return r.fromArray = function(n, s) {
    for (var a = new r(), g = 0, o = n.length; g < o; g++)
      a.add(n[g], s);
    return a;
  }, r.prototype.size = function() {
    return e ? this._set.size : Object.getOwnPropertyNames(this._set).length;
  }, r.prototype.add = function(n, s) {
    var a = e ? n : t.toSetString(n), g = e ? this.has(n) : A.call(this._set, a), o = this._array.length;
    (!g || s) && this._array.push(n), g || (e ? this._set.set(n, o) : this._set[a] = o);
  }, r.prototype.has = function(n) {
    if (e)
      return this._set.has(n);
    var s = t.toSetString(n);
    return A.call(this._set, s);
  }, r.prototype.indexOf = function(n) {
    if (e) {
      var s = this._set.get(n);
      if (s >= 0)
        return s;
    } else {
      var a = t.toSetString(n);
      if (A.call(this._set, a))
        return this._set[a];
    }
    throw new Error('"' + n + '" is not in the set.');
  }, r.prototype.at = function(n) {
    if (n >= 0 && n < this._array.length)
      return this._array[n];
    throw new Error("No element indexed by " + n);
  }, r.prototype.toArray = function() {
    return this._array.slice();
  }, rw.ArraySet = r, rw;
}
var iw = {}, Fb;
function KeA() {
  if (Fb) return iw;
  Fb = 1;
  var t = jE();
  function A(r, i) {
    var n = r.generatedLine, s = i.generatedLine, a = r.generatedColumn, g = i.generatedColumn;
    return s > n || s == n && g >= a || t.compareByGeneratedPositionsInflated(r, i) <= 0;
  }
  function e() {
    this._array = [], this._sorted = !0, this._last = { generatedLine: -1, generatedColumn: 0 };
  }
  return e.prototype.unsortedForEach = function(i, n) {
    this._array.forEach(i, n);
  }, e.prototype.add = function(i) {
    A(this._last, i) ? (this._last = i, this._array.push(i)) : (this._sorted = !1, this._array.push(i));
  }, e.prototype.toArray = function() {
    return this._sorted || (this._array.sort(t.compareByGeneratedPositionsInflated), this._sorted = !0), this._array;
  }, iw.MappingList = e, iw;
}
var kb;
function XT() {
  if (kb) return ew;
  kb = 1;
  var t = VT(), A = jE(), e = ZT().ArraySet, r = KeA().MappingList;
  function i(n) {
    n || (n = {}), this._file = A.getArg(n, "file", null), this._sourceRoot = A.getArg(n, "sourceRoot", null), this._skipValidation = A.getArg(n, "skipValidation", !1), this._sources = new e(), this._names = new e(), this._mappings = new r(), this._sourcesContents = null;
  }
  return i.prototype._version = 3, i.fromSourceMap = function(s) {
    var a = s.sourceRoot, g = new i({
      file: s.file,
      sourceRoot: a
    });
    return s.eachMapping(function(o) {
      var u = {
        generated: {
          line: o.generatedLine,
          column: o.generatedColumn
        }
      };
      o.source != null && (u.source = o.source, a != null && (u.source = A.relative(a, u.source)), u.original = {
        line: o.originalLine,
        column: o.originalColumn
      }, o.name != null && (u.name = o.name)), g.addMapping(u);
    }), s.sources.forEach(function(o) {
      var u = o;
      a !== null && (u = A.relative(a, o)), g._sources.has(u) || g._sources.add(u);
      var I = s.sourceContentFor(o);
      I != null && g.setSourceContent(o, I);
    }), g;
  }, i.prototype.addMapping = function(s) {
    var a = A.getArg(s, "generated"), g = A.getArg(s, "original", null), o = A.getArg(s, "source", null), u = A.getArg(s, "name", null);
    this._skipValidation || this._validateMapping(a, g, o, u), o != null && (o = String(o), this._sources.has(o) || this._sources.add(o)), u != null && (u = String(u), this._names.has(u) || this._names.add(u)), this._mappings.add({
      generatedLine: a.line,
      generatedColumn: a.column,
      originalLine: g != null && g.line,
      originalColumn: g != null && g.column,
      source: o,
      name: u
    });
  }, i.prototype.setSourceContent = function(s, a) {
    var g = s;
    this._sourceRoot != null && (g = A.relative(this._sourceRoot, g)), a != null ? (this._sourcesContents || (this._sourcesContents = /* @__PURE__ */ Object.create(null)), this._sourcesContents[A.toSetString(g)] = a) : this._sourcesContents && (delete this._sourcesContents[A.toSetString(g)], Object.keys(this._sourcesContents).length === 0 && (this._sourcesContents = null));
  }, i.prototype.applySourceMap = function(s, a, g) {
    var o = a;
    if (a == null) {
      if (s.file == null)
        throw new Error(
          `SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map's "file" property. Both were omitted.`
        );
      o = s.file;
    }
    var u = this._sourceRoot;
    u != null && (o = A.relative(u, o));
    var I = new e(), c = new e();
    this._mappings.unsortedForEach(function(C) {
      if (C.source === o && C.originalLine != null) {
        var E = s.originalPositionFor({
          line: C.originalLine,
          column: C.originalColumn
        });
        E.source != null && (C.source = E.source, g != null && (C.source = A.join(g, C.source)), u != null && (C.source = A.relative(u, C.source)), C.originalLine = E.line, C.originalColumn = E.column, E.name != null && (C.name = E.name));
      }
      var l = C.source;
      l != null && !I.has(l) && I.add(l);
      var B = C.name;
      B != null && !c.has(B) && c.add(B);
    }, this), this._sources = I, this._names = c, s.sources.forEach(function(C) {
      var E = s.sourceContentFor(C);
      E != null && (g != null && (C = A.join(g, C)), u != null && (C = A.relative(u, C)), this.setSourceContent(C, E));
    }, this);
  }, i.prototype._validateMapping = function(s, a, g, o) {
    if (a && typeof a.line != "number" && typeof a.column != "number")
      throw new Error(
        "original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values."
      );
    if (!(s && "line" in s && "column" in s && s.line > 0 && s.column >= 0 && !a && !g && !o)) {
      if (s && "line" in s && "column" in s && a && "line" in a && "column" in a && s.line > 0 && s.column >= 0 && a.line > 0 && a.column >= 0 && g)
        return;
      throw new Error("Invalid mapping: " + JSON.stringify({
        generated: s,
        source: g,
        original: a,
        name: o
      }));
    }
  }, i.prototype._serializeMappings = function() {
    for (var s = 0, a = 1, g = 0, o = 0, u = 0, I = 0, c = "", C, E, l, B, h = this._mappings.toArray(), Q = 0, f = h.length; Q < f; Q++) {
      if (E = h[Q], C = "", E.generatedLine !== a)
        for (s = 0; E.generatedLine !== a; )
          C += ";", a++;
      else if (Q > 0) {
        if (!A.compareByGeneratedPositionsInflated(E, h[Q - 1]))
          continue;
        C += ",";
      }
      C += t.encode(E.generatedColumn - s), s = E.generatedColumn, E.source != null && (B = this._sources.indexOf(E.source), C += t.encode(B - I), I = B, C += t.encode(E.originalLine - 1 - o), o = E.originalLine - 1, C += t.encode(E.originalColumn - g), g = E.originalColumn, E.name != null && (l = this._names.indexOf(E.name), C += t.encode(l - u), u = l)), c += C;
    }
    return c;
  }, i.prototype._generateSourcesContent = function(s, a) {
    return s.map(function(g) {
      if (!this._sourcesContents)
        return null;
      a != null && (g = A.relative(a, g));
      var o = A.toSetString(g);
      return Object.prototype.hasOwnProperty.call(this._sourcesContents, o) ? this._sourcesContents[o] : null;
    }, this);
  }, i.prototype.toJSON = function() {
    var s = {
      version: this._version,
      sources: this._sources.toArray(),
      names: this._names.toArray(),
      mappings: this._serializeMappings()
    };
    return this._file != null && (s.file = this._file), this._sourceRoot != null && (s.sourceRoot = this._sourceRoot), this._sourcesContents && (s.sourcesContent = this._generateSourcesContent(s.sources, s.sourceRoot)), s;
  }, i.prototype.toString = function() {
    return JSON.stringify(this.toJSON());
  }, ew.SourceMapGenerator = i, ew;
}
var jI = {}, nw = {}, vb;
function JeA() {
  return vb || (vb = 1, function(t) {
    t.GREATEST_LOWER_BOUND = 1, t.LEAST_UPPER_BOUND = 2;
    function A(e, r, i, n, s, a) {
      var g = Math.floor((r - e) / 2) + e, o = s(i, n[g], !0);
      return o === 0 ? g : o > 0 ? r - g > 1 ? A(g, r, i, n, s, a) : a == t.LEAST_UPPER_BOUND ? r < n.length ? r : -1 : g : g - e > 1 ? A(e, g, i, n, s, a) : a == t.LEAST_UPPER_BOUND ? g : e < 0 ? -1 : e;
    }
    t.search = function(r, i, n, s) {
      if (i.length === 0)
        return -1;
      var a = A(
        -1,
        i.length,
        r,
        i,
        n,
        s || t.GREATEST_LOWER_BOUND
      );
      if (a < 0)
        return -1;
      for (; a - 1 >= 0 && n(i[a], i[a - 1], !0) === 0; )
        --a;
      return a;
    };
  }(nw)), nw;
}
var sw = {}, Rb;
function HeA() {
  if (Rb) return sw;
  Rb = 1;
  function t(r, i, n) {
    var s = r[i];
    r[i] = r[n], r[n] = s;
  }
  function A(r, i) {
    return Math.round(r + Math.random() * (i - r));
  }
  function e(r, i, n, s) {
    if (n < s) {
      var a = A(n, s), g = n - 1;
      t(r, a, s);
      for (var o = r[s], u = n; u < s; u++)
        i(r[u], o) <= 0 && (g += 1, t(r, g, u));
      t(r, g + 1, u);
      var I = g + 1;
      e(r, i, n, I - 1), e(r, i, I + 1, s);
    }
  }
  return sw.quickSort = function(r, i) {
    e(r, i, 0, r.length - 1);
  }, sw;
}
var bb;
function PeA() {
  if (bb) return jI;
  bb = 1;
  var t = jE(), A = JeA(), e = ZT().ArraySet, r = VT(), i = HeA().quickSort;
  function n(o, u) {
    var I = o;
    return typeof o == "string" && (I = t.parseSourceMapInput(o)), I.sections != null ? new g(I, u) : new s(I, u);
  }
  n.fromSourceMap = function(o, u) {
    return s.fromSourceMap(o, u);
  }, n.prototype._version = 3, n.prototype.__generatedMappings = null, Object.defineProperty(n.prototype, "_generatedMappings", {
    configurable: !0,
    enumerable: !0,
    get: function() {
      return this.__generatedMappings || this._parseMappings(this._mappings, this.sourceRoot), this.__generatedMappings;
    }
  }), n.prototype.__originalMappings = null, Object.defineProperty(n.prototype, "_originalMappings", {
    configurable: !0,
    enumerable: !0,
    get: function() {
      return this.__originalMappings || this._parseMappings(this._mappings, this.sourceRoot), this.__originalMappings;
    }
  }), n.prototype._charIsMappingSeparator = function(u, I) {
    var c = u.charAt(I);
    return c === ";" || c === ",";
  }, n.prototype._parseMappings = function(u, I) {
    throw new Error("Subclasses must implement _parseMappings");
  }, n.GENERATED_ORDER = 1, n.ORIGINAL_ORDER = 2, n.GREATEST_LOWER_BOUND = 1, n.LEAST_UPPER_BOUND = 2, n.prototype.eachMapping = function(u, I, c) {
    var C = I || null, E = c || n.GENERATED_ORDER, l;
    switch (E) {
      case n.GENERATED_ORDER:
        l = this._generatedMappings;
        break;
      case n.ORIGINAL_ORDER:
        l = this._originalMappings;
        break;
      default:
        throw new Error("Unknown order of iteration.");
    }
    var B = this.sourceRoot;
    l.map(function(h) {
      var Q = h.source === null ? null : this._sources.at(h.source);
      return Q = t.computeSourceURL(B, Q, this._sourceMapURL), {
        source: Q,
        generatedLine: h.generatedLine,
        generatedColumn: h.generatedColumn,
        originalLine: h.originalLine,
        originalColumn: h.originalColumn,
        name: h.name === null ? null : this._names.at(h.name)
      };
    }, this).forEach(u, C);
  }, n.prototype.allGeneratedPositionsFor = function(u) {
    var I = t.getArg(u, "line"), c = {
      source: t.getArg(u, "source"),
      originalLine: I,
      originalColumn: t.getArg(u, "column", 0)
    };
    if (c.source = this._findSourceIndex(c.source), c.source < 0)
      return [];
    var C = [], E = this._findMapping(
      c,
      this._originalMappings,
      "originalLine",
      "originalColumn",
      t.compareByOriginalPositions,
      A.LEAST_UPPER_BOUND
    );
    if (E >= 0) {
      var l = this._originalMappings[E];
      if (u.column === void 0)
        for (var B = l.originalLine; l && l.originalLine === B; )
          C.push({
            line: t.getArg(l, "generatedLine", null),
            column: t.getArg(l, "generatedColumn", null),
            lastColumn: t.getArg(l, "lastGeneratedColumn", null)
          }), l = this._originalMappings[++E];
      else
        for (var h = l.originalColumn; l && l.originalLine === I && l.originalColumn == h; )
          C.push({
            line: t.getArg(l, "generatedLine", null),
            column: t.getArg(l, "generatedColumn", null),
            lastColumn: t.getArg(l, "lastGeneratedColumn", null)
          }), l = this._originalMappings[++E];
    }
    return C;
  }, jI.SourceMapConsumer = n;
  function s(o, u) {
    var I = o;
    typeof o == "string" && (I = t.parseSourceMapInput(o));
    var c = t.getArg(I, "version"), C = t.getArg(I, "sources"), E = t.getArg(I, "names", []), l = t.getArg(I, "sourceRoot", null), B = t.getArg(I, "sourcesContent", null), h = t.getArg(I, "mappings"), Q = t.getArg(I, "file", null);
    if (c != this._version)
      throw new Error("Unsupported version: " + c);
    l && (l = t.normalize(l)), C = C.map(String).map(t.normalize).map(function(f) {
      return l && t.isAbsolute(l) && t.isAbsolute(f) ? t.relative(l, f) : f;
    }), this._names = e.fromArray(E.map(String), !0), this._sources = e.fromArray(C, !0), this._absoluteSources = this._sources.toArray().map(function(f) {
      return t.computeSourceURL(l, f, u);
    }), this.sourceRoot = l, this.sourcesContent = B, this._mappings = h, this._sourceMapURL = u, this.file = Q;
  }
  s.prototype = Object.create(n.prototype), s.prototype.consumer = n, s.prototype._findSourceIndex = function(o) {
    var u = o;
    if (this.sourceRoot != null && (u = t.relative(this.sourceRoot, u)), this._sources.has(u))
      return this._sources.indexOf(u);
    var I;
    for (I = 0; I < this._absoluteSources.length; ++I)
      if (this._absoluteSources[I] == o)
        return I;
    return -1;
  }, s.fromSourceMap = function(u, I) {
    var c = Object.create(s.prototype), C = c._names = e.fromArray(u._names.toArray(), !0), E = c._sources = e.fromArray(u._sources.toArray(), !0);
    c.sourceRoot = u._sourceRoot, c.sourcesContent = u._generateSourcesContent(
      c._sources.toArray(),
      c.sourceRoot
    ), c.file = u._file, c._sourceMapURL = I, c._absoluteSources = c._sources.toArray().map(function(m) {
      return t.computeSourceURL(c.sourceRoot, m, I);
    });
    for (var l = u._mappings.toArray().slice(), B = c.__generatedMappings = [], h = c.__originalMappings = [], Q = 0, f = l.length; Q < f; Q++) {
      var p = l[Q], y = new a();
      y.generatedLine = p.generatedLine, y.generatedColumn = p.generatedColumn, p.source && (y.source = E.indexOf(p.source), y.originalLine = p.originalLine, y.originalColumn = p.originalColumn, p.name && (y.name = C.indexOf(p.name)), h.push(y)), B.push(y);
    }
    return i(c.__originalMappings, t.compareByOriginalPositions), c;
  }, s.prototype._version = 3, Object.defineProperty(s.prototype, "sources", {
    get: function() {
      return this._absoluteSources.slice();
    }
  });
  function a() {
    this.generatedLine = 0, this.generatedColumn = 0, this.source = null, this.originalLine = null, this.originalColumn = null, this.name = null;
  }
  s.prototype._parseMappings = function(u, I) {
    for (var c = 1, C = 0, E = 0, l = 0, B = 0, h = 0, Q = u.length, f = 0, p = {}, y = {}, m = [], S = [], w, F, b, G, T; f < Q; )
      if (u.charAt(f) === ";")
        c++, f++, C = 0;
      else if (u.charAt(f) === ",")
        f++;
      else {
        for (w = new a(), w.generatedLine = c, G = f; G < Q && !this._charIsMappingSeparator(u, G); G++)
          ;
        if (F = u.slice(f, G), b = p[F], b)
          f += F.length;
        else {
          for (b = []; f < G; )
            r.decode(u, f, y), T = y.value, f = y.rest, b.push(T);
          if (b.length === 2)
            throw new Error("Found a source, but no line and column");
          if (b.length === 3)
            throw new Error("Found a source and line, but no column");
          p[F] = b;
        }
        w.generatedColumn = C + b[0], C = w.generatedColumn, b.length > 1 && (w.source = B + b[1], B += b[1], w.originalLine = E + b[2], E = w.originalLine, w.originalLine += 1, w.originalColumn = l + b[3], l = w.originalColumn, b.length > 4 && (w.name = h + b[4], h += b[4])), S.push(w), typeof w.originalLine == "number" && m.push(w);
      }
    i(S, t.compareByGeneratedPositionsDeflated), this.__generatedMappings = S, i(m, t.compareByOriginalPositions), this.__originalMappings = m;
  }, s.prototype._findMapping = function(u, I, c, C, E, l) {
    if (u[c] <= 0)
      throw new TypeError("Line must be greater than or equal to 1, got " + u[c]);
    if (u[C] < 0)
      throw new TypeError("Column must be greater than or equal to 0, got " + u[C]);
    return A.search(u, I, E, l);
  }, s.prototype.computeColumnSpans = function() {
    for (var u = 0; u < this._generatedMappings.length; ++u) {
      var I = this._generatedMappings[u];
      if (u + 1 < this._generatedMappings.length) {
        var c = this._generatedMappings[u + 1];
        if (I.generatedLine === c.generatedLine) {
          I.lastGeneratedColumn = c.generatedColumn - 1;
          continue;
        }
      }
      I.lastGeneratedColumn = 1 / 0;
    }
  }, s.prototype.originalPositionFor = function(u) {
    var I = {
      generatedLine: t.getArg(u, "line"),
      generatedColumn: t.getArg(u, "column")
    }, c = this._findMapping(
      I,
      this._generatedMappings,
      "generatedLine",
      "generatedColumn",
      t.compareByGeneratedPositionsDeflated,
      t.getArg(u, "bias", n.GREATEST_LOWER_BOUND)
    );
    if (c >= 0) {
      var C = this._generatedMappings[c];
      if (C.generatedLine === I.generatedLine) {
        var E = t.getArg(C, "source", null);
        E !== null && (E = this._sources.at(E), E = t.computeSourceURL(this.sourceRoot, E, this._sourceMapURL));
        var l = t.getArg(C, "name", null);
        return l !== null && (l = this._names.at(l)), {
          source: E,
          line: t.getArg(C, "originalLine", null),
          column: t.getArg(C, "originalColumn", null),
          name: l
        };
      }
    }
    return {
      source: null,
      line: null,
      column: null,
      name: null
    };
  }, s.prototype.hasContentsOfAllSources = function() {
    return this.sourcesContent ? this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function(u) {
      return u == null;
    }) : !1;
  }, s.prototype.sourceContentFor = function(u, I) {
    if (!this.sourcesContent)
      return null;
    var c = this._findSourceIndex(u);
    if (c >= 0)
      return this.sourcesContent[c];
    var C = u;
    this.sourceRoot != null && (C = t.relative(this.sourceRoot, C));
    var E;
    if (this.sourceRoot != null && (E = t.urlParse(this.sourceRoot))) {
      var l = C.replace(/^file:\/\//, "");
      if (E.scheme == "file" && this._sources.has(l))
        return this.sourcesContent[this._sources.indexOf(l)];
      if ((!E.path || E.path == "/") && this._sources.has("/" + C))
        return this.sourcesContent[this._sources.indexOf("/" + C)];
    }
    if (I)
      return null;
    throw new Error('"' + C + '" is not in the SourceMap.');
  }, s.prototype.generatedPositionFor = function(u) {
    var I = t.getArg(u, "source");
    if (I = this._findSourceIndex(I), I < 0)
      return {
        line: null,
        column: null,
        lastColumn: null
      };
    var c = {
      source: I,
      originalLine: t.getArg(u, "line"),
      originalColumn: t.getArg(u, "column")
    }, C = this._findMapping(
      c,
      this._originalMappings,
      "originalLine",
      "originalColumn",
      t.compareByOriginalPositions,
      t.getArg(u, "bias", n.GREATEST_LOWER_BOUND)
    );
    if (C >= 0) {
      var E = this._originalMappings[C];
      if (E.source === c.source)
        return {
          line: t.getArg(E, "generatedLine", null),
          column: t.getArg(E, "generatedColumn", null),
          lastColumn: t.getArg(E, "lastGeneratedColumn", null)
        };
    }
    return {
      line: null,
      column: null,
      lastColumn: null
    };
  }, jI.BasicSourceMapConsumer = s;
  function g(o, u) {
    var I = o;
    typeof o == "string" && (I = t.parseSourceMapInput(o));
    var c = t.getArg(I, "version"), C = t.getArg(I, "sections");
    if (c != this._version)
      throw new Error("Unsupported version: " + c);
    this._sources = new e(), this._names = new e();
    var E = {
      line: -1,
      column: 0
    };
    this._sections = C.map(function(l) {
      if (l.url)
        throw new Error("Support for url field in sections not implemented.");
      var B = t.getArg(l, "offset"), h = t.getArg(B, "line"), Q = t.getArg(B, "column");
      if (h < E.line || h === E.line && Q < E.column)
        throw new Error("Section offsets must be ordered and non-overlapping.");
      return E = B, {
        generatedOffset: {
          // The offset fields are 0-based, but we use 1-based indices when
          // encoding/decoding from VLQ.
          generatedLine: h + 1,
          generatedColumn: Q + 1
        },
        consumer: new n(t.getArg(l, "map"), u)
      };
    });
  }
  return g.prototype = Object.create(n.prototype), g.prototype.constructor = n, g.prototype._version = 3, Object.defineProperty(g.prototype, "sources", {
    get: function() {
      for (var o = [], u = 0; u < this._sections.length; u++)
        for (var I = 0; I < this._sections[u].consumer.sources.length; I++)
          o.push(this._sections[u].consumer.sources[I]);
      return o;
    }
  }), g.prototype.originalPositionFor = function(u) {
    var I = {
      generatedLine: t.getArg(u, "line"),
      generatedColumn: t.getArg(u, "column")
    }, c = A.search(
      I,
      this._sections,
      function(E, l) {
        var B = E.generatedLine - l.generatedOffset.generatedLine;
        return B || E.generatedColumn - l.generatedOffset.generatedColumn;
      }
    ), C = this._sections[c];
    return C ? C.consumer.originalPositionFor({
      line: I.generatedLine - (C.generatedOffset.generatedLine - 1),
      column: I.generatedColumn - (C.generatedOffset.generatedLine === I.generatedLine ? C.generatedOffset.generatedColumn - 1 : 0),
      bias: u.bias
    }) : {
      source: null,
      line: null,
      column: null,
      name: null
    };
  }, g.prototype.hasContentsOfAllSources = function() {
    return this._sections.every(function(u) {
      return u.consumer.hasContentsOfAllSources();
    });
  }, g.prototype.sourceContentFor = function(u, I) {
    for (var c = 0; c < this._sections.length; c++) {
      var C = this._sections[c], E = C.consumer.sourceContentFor(u, !0);
      if (E)
        return E;
    }
    if (I)
      return null;
    throw new Error('"' + u + '" is not in the SourceMap.');
  }, g.prototype.generatedPositionFor = function(u) {
    for (var I = 0; I < this._sections.length; I++) {
      var c = this._sections[I];
      if (c.consumer._findSourceIndex(t.getArg(u, "source")) !== -1) {
        var C = c.consumer.generatedPositionFor(u);
        if (C) {
          var E = {
            line: C.line + (c.generatedOffset.generatedLine - 1),
            column: C.column + (c.generatedOffset.generatedLine === C.line ? c.generatedOffset.generatedColumn - 1 : 0)
          };
          return E;
        }
      }
    }
    return {
      line: null,
      column: null
    };
  }, g.prototype._parseMappings = function(u, I) {
    this.__generatedMappings = [], this.__originalMappings = [];
    for (var c = 0; c < this._sections.length; c++)
      for (var C = this._sections[c], E = C.consumer._generatedMappings, l = 0; l < E.length; l++) {
        var B = E[l], h = C.consumer._sources.at(B.source);
        h = t.computeSourceURL(C.consumer.sourceRoot, h, this._sourceMapURL), this._sources.add(h), h = this._sources.indexOf(h);
        var Q = null;
        B.name && (Q = C.consumer._names.at(B.name), this._names.add(Q), Q = this._names.indexOf(Q));
        var f = {
          source: h,
          generatedLine: B.generatedLine + (C.generatedOffset.generatedLine - 1),
          generatedColumn: B.generatedColumn + (C.generatedOffset.generatedLine === B.generatedLine ? C.generatedOffset.generatedColumn - 1 : 0),
          originalLine: B.originalLine,
          originalColumn: B.originalColumn,
          name: Q
        };
        this.__generatedMappings.push(f), typeof f.originalLine == "number" && this.__originalMappings.push(f);
      }
    i(this.__generatedMappings, t.compareByGeneratedPositionsDeflated), i(this.__originalMappings, t.compareByOriginalPositions);
  }, jI.IndexedSourceMapConsumer = g, jI;
}
var aw = {}, Mb;
function OeA() {
  if (Mb) return aw;
  Mb = 1;
  var t = XT().SourceMapGenerator, A = jE(), e = /(\r?\n)/, r = 10, i = "$$$isSourceNode$$$";
  function n(s, a, g, o, u) {
    this.children = [], this.sourceContents = {}, this.line = s ?? null, this.column = a ?? null, this.source = g ?? null, this.name = u ?? null, this[i] = !0, o != null && this.add(o);
  }
  return n.fromStringWithSourceMap = function(a, g, o) {
    var u = new n(), I = a.split(e), c = 0, C = function() {
      var Q = p(), f = p() || "";
      return Q + f;
      function p() {
        return c < I.length ? I[c++] : void 0;
      }
    }, E = 1, l = 0, B = null;
    return g.eachMapping(function(Q) {
      if (B !== null)
        if (E < Q.generatedLine)
          h(B, C()), E++, l = 0;
        else {
          var f = I[c] || "", p = f.substr(0, Q.generatedColumn - l);
          I[c] = f.substr(Q.generatedColumn - l), l = Q.generatedColumn, h(B, p), B = Q;
          return;
        }
      for (; E < Q.generatedLine; )
        u.add(C()), E++;
      if (l < Q.generatedColumn) {
        var f = I[c] || "";
        u.add(f.substr(0, Q.generatedColumn)), I[c] = f.substr(Q.generatedColumn), l = Q.generatedColumn;
      }
      B = Q;
    }, this), c < I.length && (B && h(B, C()), u.add(I.splice(c).join(""))), g.sources.forEach(function(Q) {
      var f = g.sourceContentFor(Q);
      f != null && (o != null && (Q = A.join(o, Q)), u.setSourceContent(Q, f));
    }), u;
    function h(Q, f) {
      if (Q === null || Q.source === void 0)
        u.add(f);
      else {
        var p = o ? A.join(o, Q.source) : Q.source;
        u.add(new n(
          Q.originalLine,
          Q.originalColumn,
          p,
          f,
          Q.name
        ));
      }
    }
  }, n.prototype.add = function(a) {
    if (Array.isArray(a))
      a.forEach(function(g) {
        this.add(g);
      }, this);
    else if (a[i] || typeof a == "string")
      a && this.children.push(a);
    else
      throw new TypeError(
        "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + a
      );
    return this;
  }, n.prototype.prepend = function(a) {
    if (Array.isArray(a))
      for (var g = a.length - 1; g >= 0; g--)
        this.prepend(a[g]);
    else if (a[i] || typeof a == "string")
      this.children.unshift(a);
    else
      throw new TypeError(
        "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + a
      );
    return this;
  }, n.prototype.walk = function(a) {
    for (var g, o = 0, u = this.children.length; o < u; o++)
      g = this.children[o], g[i] ? g.walk(a) : g !== "" && a(g, {
        source: this.source,
        line: this.line,
        column: this.column,
        name: this.name
      });
  }, n.prototype.join = function(a) {
    var g, o, u = this.children.length;
    if (u > 0) {
      for (g = [], o = 0; o < u - 1; o++)
        g.push(this.children[o]), g.push(a);
      g.push(this.children[o]), this.children = g;
    }
    return this;
  }, n.prototype.replaceRight = function(a, g) {
    var o = this.children[this.children.length - 1];
    return o[i] ? o.replaceRight(a, g) : typeof o == "string" ? this.children[this.children.length - 1] = o.replace(a, g) : this.children.push("".replace(a, g)), this;
  }, n.prototype.setSourceContent = function(a, g) {
    this.sourceContents[A.toSetString(a)] = g;
  }, n.prototype.walkSourceContents = function(a) {
    for (var g = 0, o = this.children.length; g < o; g++)
      this.children[g][i] && this.children[g].walkSourceContents(a);
    for (var u = Object.keys(this.sourceContents), g = 0, o = u.length; g < o; g++)
      a(A.fromSetString(u[g]), this.sourceContents[u[g]]);
  }, n.prototype.toString = function() {
    var a = "";
    return this.walk(function(g) {
      a += g;
    }), a;
  }, n.prototype.toStringWithSourceMap = function(a) {
    var g = {
      code: "",
      line: 1,
      column: 0
    }, o = new t(a), u = !1, I = null, c = null, C = null, E = null;
    return this.walk(function(l, B) {
      g.code += l, B.source !== null && B.line !== null && B.column !== null ? ((I !== B.source || c !== B.line || C !== B.column || E !== B.name) && o.addMapping({
        source: B.source,
        original: {
          line: B.line,
          column: B.column
        },
        generated: {
          line: g.line,
          column: g.column
        },
        name: B.name
      }), I = B.source, c = B.line, C = B.column, E = B.name, u = !0) : u && (o.addMapping({
        generated: {
          line: g.line,
          column: g.column
        }
      }), I = null, u = !1);
      for (var h = 0, Q = l.length; h < Q; h++)
        l.charCodeAt(h) === r ? (g.line++, g.column = 0, h + 1 === Q ? (I = null, u = !1) : u && o.addMapping({
          source: B.source,
          original: {
            line: B.line,
            column: B.column
          },
          generated: {
            line: g.line,
            column: g.column
          },
          name: B.name
        })) : g.column++;
    }), this.walkSourceContents(function(l, B) {
      o.setSourceContent(l, B);
    }), { code: g.code, map: o };
  }, aw.SourceNode = n, aw;
}
var _b;
function YeA() {
  return _b || (_b = 1, qI.SourceMapGenerator = XT().SourceMapGenerator, qI.SourceMapConsumer = PeA().SourceMapConsumer, qI.SourceNode = OeA().SourceNode), qI;
}
const qeA = "2.1.0", jeA = {
  version: qeA
};
var Nb;
function WeA() {
  return Nb || (Nb = 1, function(t) {
    (function() {
      var A, e, r, i, n, s, a, g, o, u, I, c, C, E, l, B, h, Q, f, p, y, m, S, w, F, b;
      n = LeA(), s = UeA(), A = n.Syntax;
      function G(D) {
        return Qe.Expression.hasOwnProperty(D.type);
      }
      function T(D) {
        return Qe.Statement.hasOwnProperty(D.type);
      }
      e = {
        Sequence: 0,
        Yield: 1,
        Assignment: 1,
        Conditional: 2,
        ArrowFunction: 2,
        Coalesce: 3,
        LogicalOR: 4,
        LogicalAND: 5,
        BitwiseOR: 6,
        BitwiseXOR: 7,
        BitwiseAND: 8,
        Equality: 9,
        Relational: 10,
        BitwiseSHIFT: 11,
        Additive: 12,
        Multiplicative: 13,
        Exponentiation: 14,
        Await: 15,
        Unary: 15,
        Postfix: 16,
        OptionalChaining: 17,
        Call: 18,
        New: 19,
        TaggedTemplate: 20,
        Member: 21,
        Primary: 22
      }, r = {
        "??": e.Coalesce,
        "||": e.LogicalOR,
        "&&": e.LogicalAND,
        "|": e.BitwiseOR,
        "^": e.BitwiseXOR,
        "&": e.BitwiseAND,
        "==": e.Equality,
        "!=": e.Equality,
        "===": e.Equality,
        "!==": e.Equality,
        is: e.Equality,
        isnt: e.Equality,
        "<": e.Relational,
        ">": e.Relational,
        "<=": e.Relational,
        ">=": e.Relational,
        in: e.Relational,
        instanceof: e.Relational,
        "<<": e.BitwiseSHIFT,
        ">>": e.BitwiseSHIFT,
        ">>>": e.BitwiseSHIFT,
        "+": e.Additive,
        "-": e.Additive,
        "*": e.Multiplicative,
        "%": e.Multiplicative,
        "/": e.Multiplicative,
        "**": e.Exponentiation
      };
      var K = 1, H = 2, j = 4, eA = 8, sA = 16, uA = 32, rA = 64, hA = H | j, UA = K | H, iA = K | H | j, wA = K, Re = j, zA = K | j, U = K, N = K | uA, CA = 0, P = K | sA, XA = K | eA;
      function ue() {
        return {
          indent: null,
          base: null,
          parse: null,
          comment: !1,
          format: {
            indent: {
              style: "    ",
              base: 0,
              adjustMultilineComment: !1
            },
            newline: `
`,
            space: " ",
            json: !1,
            renumber: !1,
            hexadecimal: !1,
            quotes: "single",
            escapeless: !1,
            compact: !1,
            parentheses: !0,
            semicolons: !0,
            safeConcatenation: !1,
            preserveBlankLines: !1
          },
          moz: {
            comprehensionExpressionStartsWithAssignment: !1,
            starlessGenerator: !1
          },
          sourceMap: null,
          sourceMapRoot: null,
          sourceMapWithCode: !1,
          directive: !1,
          raw: !0,
          verbatim: null,
          sourceCode: null
        };
      }
      function Y(D, M) {
        var v = "";
        for (M |= 0; M > 0; M >>>= 1, D += D)
          M & 1 && (v += D);
        return v;
      }
      function L(D) {
        return /[\r\n]/g.test(D);
      }
      function V(D) {
        var M = D.length;
        return M && s.code.isLineTerminator(D.charCodeAt(M - 1));
      }
      function Z(D, M) {
        var v;
        for (v in M)
          M.hasOwnProperty(v) && (D[v] = M[v]);
        return D;
      }
      function cA(D, M) {
        var v, _;
        function J(oA) {
          return typeof oA == "object" && oA instanceof Object && !(oA instanceof RegExp);
        }
        for (v in M)
          M.hasOwnProperty(v) && (_ = M[v], J(_) ? J(D[v]) ? cA(D[v], _) : D[v] = cA({}, _) : D[v] = _);
        return D;
      }
      function X(D) {
        var M, v, _, J, oA;
        if (D !== D)
          throw new Error("Numeric literal whose value is NaN");
        if (D < 0 || D === 0 && 1 / D < 0)
          throw new Error("Numeric literal whose value is negative");
        if (D === 1 / 0)
          return o ? "null" : u ? "1e400" : "1e+400";
        if (M = "" + D, !u || M.length < 3)
          return M;
        for (v = M.indexOf("."), !o && M.charCodeAt(0) === 48 && v === 1 && (v = 0, M = M.slice(1)), _ = M, M = M.replace("e+", "e"), J = 0, (oA = _.indexOf("e")) > 0 && (J = +_.slice(oA + 1), _ = _.slice(0, oA)), v >= 0 && (J -= _.length - v - 1, _ = +(_.slice(0, v) + _.slice(v + 1)) + ""), oA = 0; _.charCodeAt(_.length + oA - 1) === 48; )
          --oA;
        return oA !== 0 && (J -= oA, _ = _.slice(0, oA)), J !== 0 && (_ += "e" + J), (_.length < M.length || I && D > 1e12 && Math.floor(D) === D && (_ = "0x" + D.toString(16)).length < M.length) && +_ === D && (M = _), M;
      }
      function z(D, M) {
        return (D & -2) === 8232 ? (M ? "u" : "\\u") + (D === 8232 ? "2028" : "2029") : D === 10 || D === 13 ? (M ? "" : "\\") + (D === 10 ? "n" : "r") : String.fromCharCode(D);
      }
      function SA(D) {
        var M, v, _, J, oA, lA, mA, xA;
        if (v = D.toString(), D.source) {
          if (M = v.match(/\/([^/]*)$/), !M)
            return v;
          for (_ = M[1], v = "", mA = !1, xA = !1, J = 0, oA = D.source.length; J < oA; ++J)
            lA = D.source.charCodeAt(J), xA ? (v += z(lA, xA), xA = !1) : (mA ? lA === 93 && (mA = !1) : lA === 47 ? v += "\\" : lA === 91 && (mA = !0), v += z(lA, xA), xA = lA === 92);
          return "/" + v + "/" + _;
        }
        return v;
      }
      function aA(D, M) {
        var v;
        return D === 8 ? "\\b" : D === 12 ? "\\f" : D === 9 ? "\\t" : (v = D.toString(16).toUpperCase(), o || D > 255 ? "\\u" + "0000".slice(v.length) + v : D === 0 && !s.code.isDecimalDigit(M) ? "\\0" : D === 11 ? "\\x0B" : "\\x" + "00".slice(v.length) + v);
      }
      function Ae(D) {
        if (D === 92)
          return "\\\\";
        if (D === 10)
          return "\\n";
        if (D === 13)
          return "\\r";
        if (D === 8232)
          return "\\u2028";
        if (D === 8233)
          return "\\u2029";
        throw new Error("Incorrectly classified character");
      }
      function vA(D) {
        var M, v, _, J;
        for (J = c === "double" ? '"' : "'", M = 0, v = D.length; M < v; ++M)
          if (_ = D.charCodeAt(M), _ === 39) {
            J = '"';
            break;
          } else if (_ === 34) {
            J = "'";
            break;
          } else _ === 92 && ++M;
        return J + D + J;
      }
      function RA(D) {
        var M = "", v, _, J, oA = 0, lA = 0, mA, xA;
        for (v = 0, _ = D.length; v < _; ++v) {
          if (J = D.charCodeAt(v), J === 39)
            ++oA;
          else if (J === 34)
            ++lA;
          else if (J === 47 && o)
            M += "\\";
          else if (s.code.isLineTerminator(J) || J === 92) {
            M += Ae(J);
            continue;
          } else if (!s.code.isIdentifierPartES5(J) && (o && J < 32 || !o && !C && (J < 32 || J > 126))) {
            M += aA(J, D.charCodeAt(v + 1));
            continue;
          }
          M += String.fromCharCode(J);
        }
        if (mA = !(c === "double" || c === "auto" && lA < oA), xA = mA ? "'" : '"', !(mA ? oA : lA))
          return xA + M + xA;
        for (D = M, M = xA, v = 0, _ = D.length; v < _; ++v)
          J = D.charCodeAt(v), (J === 39 && mA || J === 34 && !mA) && (M += "\\"), M += String.fromCharCode(J);
        return M + xA;
      }
      function MA(D) {
        var M, v, _, J = "";
        for (M = 0, v = D.length; M < v; ++M)
          _ = D[M], J += Array.isArray(_) ? MA(_) : _;
        return J;
      }
      function BA(D, M) {
        if (!m)
          return Array.isArray(D) ? MA(D) : D;
        if (M == null) {
          if (D instanceof i)
            return D;
          M = {};
        }
        return M.loc == null ? new i(null, null, m, D, M.name || null) : new i(M.loc.start.line, M.loc.start.column, m === !0 ? M.loc.source || null : m, D, M.name || null);
      }
      function pA() {
        return l || " ";
      }
      function EA(D, M) {
        var v, _, J, oA;
        return v = BA(D).toString(), v.length === 0 ? [M] : (_ = BA(M).toString(), _.length === 0 ? [D] : (J = v.charCodeAt(v.length - 1), oA = _.charCodeAt(0), (J === 43 || J === 45) && J === oA || s.code.isIdentifierPartES5(J) && s.code.isIdentifierPartES5(oA) || J === 47 && oA === 105 ? [D, pA(), M] : s.code.isWhiteSpace(J) || s.code.isLineTerminator(J) || s.code.isWhiteSpace(oA) || s.code.isLineTerminator(oA) ? [D, M] : [D, l, M]));
      }
      function _A(D) {
        return [a, D];
      }
      function oe(D) {
        var M;
        M = a, a += g, D(a), a = M;
      }
      function q(D) {
        var M;
        for (M = D.length - 1; M >= 0 && !s.code.isLineTerminator(D.charCodeAt(M)); --M)
          ;
        return D.length - 1 - M;
      }
      function AA(D, M) {
        var v, _, J, oA, lA, mA, xA, Ee;
        for (v = D.split(/\r\n|[\r\n]/), mA = Number.MAX_VALUE, _ = 1, J = v.length; _ < J; ++_) {
          for (oA = v[_], lA = 0; lA < oA.length && s.code.isWhiteSpace(oA.charCodeAt(lA)); )
            ++lA;
          mA > lA && (mA = lA);
        }
        for (typeof M < "u" ? (xA = a, v[1][mA] === "*" && (M += " "), a = M) : (mA & 1 && --mA, xA = a), _ = 1, J = v.length; _ < J; ++_)
          Ee = BA(_A(v[_].slice(mA))), v[_] = m ? Ee.join("") : Ee;
        return a = xA, v.join(`
`);
      }
      function gA(D, M) {
        if (D.type === "Line") {
          if (V(D.value))
            return "//" + D.value;
          var v = "//" + D.value;
          return w || (v += `
`), v;
        }
        return p.format.indent.adjustMultilineComment && /[\n\r]/.test(D.value) ? AA("/*" + D.value + "*/", M) : "/*" + D.value + "*/";
      }
      function fA(D, M) {
        var v, _, J, oA, lA, mA, xA, Ee, lt, Ta, bg, sF, aF, Gi;
        if (D.leadingComments && D.leadingComments.length > 0) {
          if (oA = M, w) {
            for (J = D.leadingComments[0], M = [], Ee = J.extendedRange, lt = J.range, bg = S.substring(Ee[0], lt[0]), Gi = (bg.match(/\n/g) || []).length, Gi > 0 ? (M.push(Y(`
`, Gi)), M.push(_A(gA(J)))) : (M.push(bg), M.push(gA(J))), Ta = lt, v = 1, _ = D.leadingComments.length; v < _; v++)
              J = D.leadingComments[v], lt = J.range, sF = S.substring(Ta[1], lt[0]), Gi = (sF.match(/\n/g) || []).length, M.push(Y(`
`, Gi)), M.push(_A(gA(J))), Ta = lt;
            aF = S.substring(lt[1], Ee[1]), Gi = (aF.match(/\n/g) || []).length, M.push(Y(`
`, Gi));
          } else
            for (J = D.leadingComments[0], M = [], Q && D.type === A.Program && D.body.length === 0 && M.push(`
`), M.push(gA(J)), V(BA(M).toString()) || M.push(`
`), v = 1, _ = D.leadingComments.length; v < _; ++v)
              J = D.leadingComments[v], xA = [gA(J)], V(BA(xA).toString()) || xA.push(`
`), M.push(_A(xA));
          M.push(_A(oA));
        }
        if (D.trailingComments)
          if (w)
            J = D.trailingComments[0], Ee = J.extendedRange, lt = J.range, bg = S.substring(Ee[0], lt[0]), Gi = (bg.match(/\n/g) || []).length, Gi > 0 ? (M.push(Y(`
`, Gi)), M.push(_A(gA(J)))) : (M.push(bg), M.push(gA(J)));
          else
            for (lA = !V(BA(M).toString()), mA = Y(" ", q(BA([a, M, g]).toString())), v = 0, _ = D.trailingComments.length; v < _; ++v)
              J = D.trailingComments[v], lA ? (v === 0 ? M = [M, g] : M = [M, mA], M.push(gA(J, mA))) : M = [M, _A(gA(J))], v !== _ - 1 && !V(BA(M).toString()) && (M = [M, `
`]);
        return M;
      }
      function LA(D, M, v) {
        var _, J = 0;
        for (_ = D; _ < M; _++)
          S[_] === `
` && J++;
        for (_ = 1; _ < J; _++)
          v.push(E);
      }
      function YA(D, M, v) {
        return M < v ? ["(", D, ")"] : D;
      }
      function le(D) {
        var M, v, _;
        for (_ = D.split(/\r\n|\n/), M = 1, v = _.length; M < v; M++)
          _[M] = E + a + _[M];
        return _;
      }
      function Oe(D, M) {
        var v, _, J;
        return v = D[p.verbatim], typeof v == "string" ? _ = YA(le(v), e.Sequence, M) : (_ = le(v.content), J = v.precedence != null ? v.precedence : e.Sequence, _ = YA(_, J, M)), BA(_, D);
      }
      function Qe() {
      }
      Qe.prototype.maybeBlock = function(D, M) {
        var v, _, J = this;
        return _ = !p.comment || !D.leadingComments, D.type === A.BlockStatement && _ ? [l, this.generateStatement(D, M)] : D.type === A.EmptyStatement && _ ? ";" : (oe(function() {
          v = [
            E,
            _A(J.generateStatement(D, M))
          ];
        }), v);
      }, Qe.prototype.maybeBlockSuffix = function(D, M) {
        var v = V(BA(M).toString());
        return D.type === A.BlockStatement && (!p.comment || !D.leadingComments) && !v ? [M, l] : v ? [M, a] : [M, E, a];
      };
      function we(D) {
        return BA(D.name, D);
      }
      function nt(D, M) {
        return D.async ? "async" + (M ? pA() : l) : "";
      }
      function bn(D) {
        var M = D.generator && !p.moz.starlessGenerator;
        return M ? "*" + l : "";
      }
      function tA(D) {
        var M = D.value, v = "";
        return M.async && (v += nt(M, !D.computed)), M.generator && (v += bn(M) ? "*" : ""), v;
      }
      Qe.prototype.generatePattern = function(D, M, v) {
        return D.type === A.Identifier ? we(D) : this.generateExpression(D, M, v);
      }, Qe.prototype.generateFunctionParams = function(D) {
        var M, v, _, J;
        if (J = !1, D.type === A.ArrowFunctionExpression && !D.rest && (!D.defaults || D.defaults.length === 0) && D.params.length === 1 && D.params[0].type === A.Identifier)
          _ = [nt(D, !0), we(D.params[0])];
        else {
          for (_ = D.type === A.ArrowFunctionExpression ? [nt(D, !1)] : [], _.push("("), D.defaults && (J = !0), M = 0, v = D.params.length; M < v; ++M)
            J && D.defaults[M] ? _.push(this.generateAssignment(D.params[M], D.defaults[M], "=", e.Assignment, iA)) : _.push(this.generatePattern(D.params[M], e.Assignment, iA)), M + 1 < v && _.push("," + l);
          D.rest && (D.params.length && _.push("," + l), _.push("..."), _.push(we(D.rest))), _.push(")");
        }
        return _;
      }, Qe.prototype.generateFunctionBody = function(D) {
        var M, v;
        return M = this.generateFunctionParams(D), D.type === A.ArrowFunctionExpression && (M.push(l), M.push("=>")), D.expression ? (M.push(l), v = this.generateExpression(D.body, e.Assignment, iA), v.toString().charAt(0) === "{" && (v = ["(", v, ")"]), M.push(v)) : M.push(this.maybeBlock(D.body, XA)), M;
      }, Qe.prototype.generateIterationForStatement = function(D, M, v) {
        var _ = ["for" + (M.await ? pA() + "await" : "") + l + "("], J = this;
        return oe(function() {
          M.left.type === A.VariableDeclaration ? oe(function() {
            _.push(M.left.kind + pA()), _.push(J.generateStatement(M.left.declarations[0], CA));
          }) : _.push(J.generateExpression(M.left, e.Call, iA)), _ = EA(_, D), _ = [EA(
            _,
            J.generateExpression(M.right, e.Assignment, iA)
          ), ")"];
        }), _.push(this.maybeBlock(M.body, v)), _;
      }, Qe.prototype.generatePropertyKey = function(D, M) {
        var v = [];
        return M && v.push("["), v.push(this.generateExpression(D, e.Assignment, iA)), M && v.push("]"), v;
      }, Qe.prototype.generateAssignment = function(D, M, v, _, J) {
        return e.Assignment < _ && (J |= K), YA(
          [
            this.generateExpression(D, e.Call, J),
            l + v + l,
            this.generateExpression(M, e.Assignment, J)
          ],
          e.Assignment,
          _
        );
      }, Qe.prototype.semicolon = function(D) {
        return !h && D & uA ? "" : ";";
      }, Qe.Statement = {
        BlockStatement: function(D, M) {
          var v, _, J = ["{", E], oA = this;
          return oe(function() {
            D.body.length === 0 && w && (v = D.range, v[1] - v[0] > 2 && (_ = S.substring(v[0] + 1, v[1] - 1), _[0] === `
` && (J = ["{"]), J.push(_)));
            var lA, mA, xA, Ee;
            for (Ee = U, M & eA && (Ee |= sA), lA = 0, mA = D.body.length; lA < mA; ++lA)
              w && (lA === 0 && (D.body[0].leadingComments && (v = D.body[0].leadingComments[0].extendedRange, _ = S.substring(v[0], v[1]), _[0] === `
` && (J = ["{"])), D.body[0].leadingComments || LA(D.range[0], D.body[0].range[0], J)), lA > 0 && !D.body[lA - 1].trailingComments && !D.body[lA].leadingComments && LA(D.body[lA - 1].range[1], D.body[lA].range[0], J)), lA === mA - 1 && (Ee |= uA), D.body[lA].leadingComments && w ? xA = oA.generateStatement(D.body[lA], Ee) : xA = _A(oA.generateStatement(D.body[lA], Ee)), J.push(xA), V(BA(xA).toString()) || w && lA < mA - 1 && D.body[lA + 1].leadingComments || J.push(E), w && lA === mA - 1 && (D.body[lA].trailingComments || LA(D.body[lA].range[1], D.range[1], J));
          }), J.push(_A("}")), J;
        },
        BreakStatement: function(D, M) {
          return D.label ? "break " + D.label.name + this.semicolon(M) : "break" + this.semicolon(M);
        },
        ContinueStatement: function(D, M) {
          return D.label ? "continue " + D.label.name + this.semicolon(M) : "continue" + this.semicolon(M);
        },
        ClassBody: function(D, M) {
          var v = ["{", E], _ = this;
          return oe(function(J) {
            var oA, lA;
            for (oA = 0, lA = D.body.length; oA < lA; ++oA)
              v.push(J), v.push(_.generateExpression(D.body[oA], e.Sequence, iA)), oA + 1 < lA && v.push(E);
          }), V(BA(v).toString()) || v.push(E), v.push(a), v.push("}"), v;
        },
        ClassDeclaration: function(D, M) {
          var v, _;
          return v = ["class"], D.id && (v = EA(v, this.generateExpression(D.id, e.Sequence, iA))), D.superClass && (_ = EA("extends", this.generateExpression(D.superClass, e.Unary, iA)), v = EA(v, _)), v.push(l), v.push(this.generateStatement(D.body, N)), v;
        },
        DirectiveStatement: function(D, M) {
          return p.raw && D.raw ? D.raw + this.semicolon(M) : vA(D.directive) + this.semicolon(M);
        },
        DoWhileStatement: function(D, M) {
          var v = EA("do", this.maybeBlock(D.body, U));
          return v = this.maybeBlockSuffix(D.body, v), EA(v, [
            "while" + l + "(",
            this.generateExpression(D.test, e.Sequence, iA),
            ")" + this.semicolon(M)
          ]);
        },
        CatchClause: function(D, M) {
          var v, _ = this;
          return oe(function() {
            var J;
            D.param ? (v = [
              "catch" + l + "(",
              _.generateExpression(D.param, e.Sequence, iA),
              ")"
            ], D.guard && (J = _.generateExpression(D.guard, e.Sequence, iA), v.splice(2, 0, " if ", J))) : v = ["catch"];
          }), v.push(this.maybeBlock(D.body, U)), v;
        },
        DebuggerStatement: function(D, M) {
          return "debugger" + this.semicolon(M);
        },
        EmptyStatement: function(D, M) {
          return ";";
        },
        ExportDefaultDeclaration: function(D, M) {
          var v = ["export"], _;
          return _ = M & uA ? N : U, v = EA(v, "default"), T(D.declaration) ? v = EA(v, this.generateStatement(D.declaration, _)) : v = EA(v, this.generateExpression(D.declaration, e.Assignment, iA) + this.semicolon(M)), v;
        },
        ExportNamedDeclaration: function(D, M) {
          var v = ["export"], _, J = this;
          return _ = M & uA ? N : U, D.declaration ? EA(v, this.generateStatement(D.declaration, _)) : (D.specifiers && (D.specifiers.length === 0 ? v = EA(v, "{" + l + "}") : D.specifiers[0].type === A.ExportBatchSpecifier ? v = EA(v, this.generateExpression(D.specifiers[0], e.Sequence, iA)) : (v = EA(v, "{"), oe(function(oA) {
            var lA, mA;
            for (v.push(E), lA = 0, mA = D.specifiers.length; lA < mA; ++lA)
              v.push(oA), v.push(J.generateExpression(D.specifiers[lA], e.Sequence, iA)), lA + 1 < mA && v.push("," + E);
          }), V(BA(v).toString()) || v.push(E), v.push(a + "}")), D.source ? v = EA(v, [
            "from" + l,
            // ModuleSpecifier
            this.generateExpression(D.source, e.Sequence, iA),
            this.semicolon(M)
          ]) : v.push(this.semicolon(M))), v);
        },
        ExportAllDeclaration: function(D, M) {
          return [
            "export" + l,
            "*" + l,
            "from" + l,
            // ModuleSpecifier
            this.generateExpression(D.source, e.Sequence, iA),
            this.semicolon(M)
          ];
        },
        ExpressionStatement: function(D, M) {
          var v, _;
          function J(mA) {
            var xA;
            return mA.slice(0, 5) !== "class" ? !1 : (xA = mA.charCodeAt(5), xA === 123 || s.code.isWhiteSpace(xA) || s.code.isLineTerminator(xA));
          }
          function oA(mA) {
            var xA;
            return mA.slice(0, 8) !== "function" ? !1 : (xA = mA.charCodeAt(8), xA === 40 || s.code.isWhiteSpace(xA) || xA === 42 || s.code.isLineTerminator(xA));
          }
          function lA(mA) {
            var xA, Ee, lt;
            if (mA.slice(0, 5) !== "async" || !s.code.isWhiteSpace(mA.charCodeAt(5)))
              return !1;
            for (Ee = 6, lt = mA.length; Ee < lt && s.code.isWhiteSpace(mA.charCodeAt(Ee)); ++Ee)
              ;
            return Ee === lt || mA.slice(Ee, Ee + 8) !== "function" ? !1 : (xA = mA.charCodeAt(Ee + 8), xA === 40 || s.code.isWhiteSpace(xA) || xA === 42 || s.code.isLineTerminator(xA));
          }
          return v = [this.generateExpression(D.expression, e.Sequence, iA)], _ = BA(v).toString(), _.charCodeAt(0) === 123 || // ObjectExpression
          J(_) || oA(_) || lA(_) || f && M & sA && D.expression.type === A.Literal && typeof D.expression.value == "string" ? v = ["(", v, ")" + this.semicolon(M)] : v.push(this.semicolon(M)), v;
        },
        ImportDeclaration: function(D, M) {
          var v, _, J = this;
          return D.specifiers.length === 0 ? [
            "import",
            l,
            // ModuleSpecifier
            this.generateExpression(D.source, e.Sequence, iA),
            this.semicolon(M)
          ] : (v = [
            "import"
          ], _ = 0, D.specifiers[_].type === A.ImportDefaultSpecifier && (v = EA(v, [
            this.generateExpression(D.specifiers[_], e.Sequence, iA)
          ]), ++_), D.specifiers[_] && (_ !== 0 && v.push(","), D.specifiers[_].type === A.ImportNamespaceSpecifier ? v = EA(v, [
            l,
            this.generateExpression(D.specifiers[_], e.Sequence, iA)
          ]) : (v.push(l + "{"), D.specifiers.length - _ === 1 ? (v.push(l), v.push(this.generateExpression(D.specifiers[_], e.Sequence, iA)), v.push(l + "}" + l)) : (oe(function(oA) {
            var lA, mA;
            for (v.push(E), lA = _, mA = D.specifiers.length; lA < mA; ++lA)
              v.push(oA), v.push(J.generateExpression(D.specifiers[lA], e.Sequence, iA)), lA + 1 < mA && v.push("," + E);
          }), V(BA(v).toString()) || v.push(E), v.push(a + "}" + l)))), v = EA(v, [
            "from" + l,
            // ModuleSpecifier
            this.generateExpression(D.source, e.Sequence, iA),
            this.semicolon(M)
          ]), v);
        },
        VariableDeclarator: function(D, M) {
          var v = M & K ? iA : hA;
          return D.init ? [
            this.generateExpression(D.id, e.Assignment, v),
            l,
            "=",
            l,
            this.generateExpression(D.init, e.Assignment, v)
          ] : this.generatePattern(D.id, e.Assignment, v);
        },
        VariableDeclaration: function(D, M) {
          var v, _, J, oA, lA, mA = this;
          v = [D.kind], lA = M & K ? U : CA;
          function xA() {
            for (oA = D.declarations[0], p.comment && oA.leadingComments ? (v.push(`
`), v.push(_A(mA.generateStatement(oA, lA)))) : (v.push(pA()), v.push(mA.generateStatement(oA, lA))), _ = 1, J = D.declarations.length; _ < J; ++_)
              oA = D.declarations[_], p.comment && oA.leadingComments ? (v.push("," + E), v.push(_A(mA.generateStatement(oA, lA)))) : (v.push("," + l), v.push(mA.generateStatement(oA, lA)));
          }
          return D.declarations.length > 1 ? oe(xA) : xA(), v.push(this.semicolon(M)), v;
        },
        ThrowStatement: function(D, M) {
          return [EA(
            "throw",
            this.generateExpression(D.argument, e.Sequence, iA)
          ), this.semicolon(M)];
        },
        TryStatement: function(D, M) {
          var v, _, J, oA;
          if (v = ["try", this.maybeBlock(D.block, U)], v = this.maybeBlockSuffix(D.block, v), D.handlers)
            for (_ = 0, J = D.handlers.length; _ < J; ++_)
              v = EA(v, this.generateStatement(D.handlers[_], U)), (D.finalizer || _ + 1 !== J) && (v = this.maybeBlockSuffix(D.handlers[_].body, v));
          else {
            for (oA = D.guardedHandlers || [], _ = 0, J = oA.length; _ < J; ++_)
              v = EA(v, this.generateStatement(oA[_], U)), (D.finalizer || _ + 1 !== J) && (v = this.maybeBlockSuffix(oA[_].body, v));
            if (D.handler)
              if (Array.isArray(D.handler))
                for (_ = 0, J = D.handler.length; _ < J; ++_)
                  v = EA(v, this.generateStatement(D.handler[_], U)), (D.finalizer || _ + 1 !== J) && (v = this.maybeBlockSuffix(D.handler[_].body, v));
              else
                v = EA(v, this.generateStatement(D.handler, U)), D.finalizer && (v = this.maybeBlockSuffix(D.handler.body, v));
          }
          return D.finalizer && (v = EA(v, ["finally", this.maybeBlock(D.finalizer, U)])), v;
        },
        SwitchStatement: function(D, M) {
          var v, _, J, oA, lA, mA = this;
          if (oe(function() {
            v = [
              "switch" + l + "(",
              mA.generateExpression(D.discriminant, e.Sequence, iA),
              ")" + l + "{" + E
            ];
          }), D.cases)
            for (lA = U, J = 0, oA = D.cases.length; J < oA; ++J)
              J === oA - 1 && (lA |= uA), _ = _A(this.generateStatement(D.cases[J], lA)), v.push(_), V(BA(_).toString()) || v.push(E);
          return v.push(_A("}")), v;
        },
        SwitchCase: function(D, M) {
          var v, _, J, oA, lA, mA = this;
          return oe(function() {
            for (D.test ? v = [
              EA("case", mA.generateExpression(D.test, e.Sequence, iA)),
              ":"
            ] : v = ["default:"], J = 0, oA = D.consequent.length, oA && D.consequent[0].type === A.BlockStatement && (_ = mA.maybeBlock(D.consequent[0], U), v.push(_), J = 1), J !== oA && !V(BA(v).toString()) && v.push(E), lA = U; J < oA; ++J)
              J === oA - 1 && M & uA && (lA |= uA), _ = _A(mA.generateStatement(D.consequent[J], lA)), v.push(_), J + 1 !== oA && !V(BA(_).toString()) && v.push(E);
          }), v;
        },
        IfStatement: function(D, M) {
          var v, _, J, oA = this;
          return oe(function() {
            v = [
              "if" + l + "(",
              oA.generateExpression(D.test, e.Sequence, iA),
              ")"
            ];
          }), J = M & uA, _ = U, J && (_ |= uA), D.alternate ? (v.push(this.maybeBlock(D.consequent, U)), v = this.maybeBlockSuffix(D.consequent, v), D.alternate.type === A.IfStatement ? v = EA(v, ["else ", this.generateStatement(D.alternate, _)]) : v = EA(v, EA("else", this.maybeBlock(D.alternate, _)))) : v.push(this.maybeBlock(D.consequent, _)), v;
        },
        ForStatement: function(D, M) {
          var v, _ = this;
          return oe(function() {
            v = ["for" + l + "("], D.init ? D.init.type === A.VariableDeclaration ? v.push(_.generateStatement(D.init, CA)) : (v.push(_.generateExpression(D.init, e.Sequence, hA)), v.push(";")) : v.push(";"), D.test && (v.push(l), v.push(_.generateExpression(D.test, e.Sequence, iA))), v.push(";"), D.update && (v.push(l), v.push(_.generateExpression(D.update, e.Sequence, iA))), v.push(")");
          }), v.push(this.maybeBlock(D.body, M & uA ? N : U)), v;
        },
        ForInStatement: function(D, M) {
          return this.generateIterationForStatement("in", D, M & uA ? N : U);
        },
        ForOfStatement: function(D, M) {
          return this.generateIterationForStatement("of", D, M & uA ? N : U);
        },
        LabeledStatement: function(D, M) {
          return [D.label.name + ":", this.maybeBlock(D.body, M & uA ? N : U)];
        },
        Program: function(D, M) {
          var v, _, J, oA, lA;
          for (oA = D.body.length, v = [Q && oA > 0 ? `
` : ""], lA = P, J = 0; J < oA; ++J)
            !Q && J === oA - 1 && (lA |= uA), w && (J === 0 && (D.body[0].leadingComments || LA(D.range[0], D.body[J].range[0], v)), J > 0 && !D.body[J - 1].trailingComments && !D.body[J].leadingComments && LA(D.body[J - 1].range[1], D.body[J].range[0], v)), _ = _A(this.generateStatement(D.body[J], lA)), v.push(_), J + 1 < oA && !V(BA(_).toString()) && (w && D.body[J + 1].leadingComments || v.push(E)), w && J === oA - 1 && (D.body[J].trailingComments || LA(D.body[J].range[1], D.range[1], v));
          return v;
        },
        FunctionDeclaration: function(D, M) {
          return [
            nt(D, !0),
            "function",
            bn(D) || pA(),
            D.id ? we(D.id) : "",
            this.generateFunctionBody(D)
          ];
        },
        ReturnStatement: function(D, M) {
          return D.argument ? [EA(
            "return",
            this.generateExpression(D.argument, e.Sequence, iA)
          ), this.semicolon(M)] : ["return" + this.semicolon(M)];
        },
        WhileStatement: function(D, M) {
          var v, _ = this;
          return oe(function() {
            v = [
              "while" + l + "(",
              _.generateExpression(D.test, e.Sequence, iA),
              ")"
            ];
          }), v.push(this.maybeBlock(D.body, M & uA ? N : U)), v;
        },
        WithStatement: function(D, M) {
          var v, _ = this;
          return oe(function() {
            v = [
              "with" + l + "(",
              _.generateExpression(D.object, e.Sequence, iA),
              ")"
            ];
          }), v.push(this.maybeBlock(D.body, M & uA ? N : U)), v;
        }
      }, Z(Qe.prototype, Qe.Statement), Qe.Expression = {
        SequenceExpression: function(D, M, v) {
          var _, J, oA;
          for (e.Sequence < M && (v |= K), _ = [], J = 0, oA = D.expressions.length; J < oA; ++J)
            _.push(this.generateExpression(D.expressions[J], e.Assignment, v)), J + 1 < oA && _.push("," + l);
          return YA(_, e.Sequence, M);
        },
        AssignmentExpression: function(D, M, v) {
          return this.generateAssignment(D.left, D.right, D.operator, M, v);
        },
        ArrowFunctionExpression: function(D, M, v) {
          return YA(this.generateFunctionBody(D), e.ArrowFunction, M);
        },
        ConditionalExpression: function(D, M, v) {
          return e.Conditional < M && (v |= K), YA(
            [
              this.generateExpression(D.test, e.Coalesce, v),
              l + "?" + l,
              this.generateExpression(D.consequent, e.Assignment, v),
              l + ":" + l,
              this.generateExpression(D.alternate, e.Assignment, v)
            ],
            e.Conditional,
            M
          );
        },
        LogicalExpression: function(D, M, v) {
          return D.operator === "??" && (v |= rA), this.BinaryExpression(D, M, v);
        },
        BinaryExpression: function(D, M, v) {
          var _, J, oA, lA, mA, xA;
          return lA = r[D.operator], J = D.operator === "**" ? e.Postfix : lA, oA = D.operator === "**" ? lA : lA + 1, lA < M && (v |= K), mA = this.generateExpression(D.left, J, v), xA = mA.toString(), xA.charCodeAt(xA.length - 1) === 47 && s.code.isIdentifierPartES5(D.operator.charCodeAt(0)) ? _ = [mA, pA(), D.operator] : _ = EA(mA, D.operator), mA = this.generateExpression(D.right, oA, v), D.operator === "/" && mA.toString().charAt(0) === "/" || D.operator.slice(-1) === "<" && mA.toString().slice(0, 3) === "!--" ? (_.push(pA()), _.push(mA)) : _ = EA(_, mA), D.operator === "in" && !(v & K) ? ["(", _, ")"] : (D.operator === "||" || D.operator === "&&") && v & rA ? ["(", _, ")"] : YA(_, lA, M);
        },
        CallExpression: function(D, M, v) {
          var _, J, oA;
          for (_ = [this.generateExpression(D.callee, e.Call, UA)], D.optional && _.push("?."), _.push("("), J = 0, oA = D.arguments.length; J < oA; ++J)
            _.push(this.generateExpression(D.arguments[J], e.Assignment, iA)), J + 1 < oA && _.push("," + l);
          return _.push(")"), v & H ? YA(_, e.Call, M) : ["(", _, ")"];
        },
        ChainExpression: function(D, M, v) {
          e.OptionalChaining < M && (v |= H);
          var _ = this.generateExpression(D.expression, e.OptionalChaining, v);
          return YA(_, e.OptionalChaining, M);
        },
        NewExpression: function(D, M, v) {
          var _, J, oA, lA, mA;
          if (J = D.arguments.length, mA = v & j && !B && J === 0 ? zA : wA, _ = EA(
            "new",
            this.generateExpression(D.callee, e.New, mA)
          ), !(v & j) || B || J > 0) {
            for (_.push("("), oA = 0, lA = J; oA < lA; ++oA)
              _.push(this.generateExpression(D.arguments[oA], e.Assignment, iA)), oA + 1 < lA && _.push("," + l);
            _.push(")");
          }
          return YA(_, e.New, M);
        },
        MemberExpression: function(D, M, v) {
          var _, J;
          return _ = [this.generateExpression(D.object, e.Call, v & H ? UA : wA)], D.computed ? (D.optional && _.push("?."), _.push("["), _.push(this.generateExpression(D.property, e.Sequence, v & H ? iA : zA)), _.push("]")) : (!D.optional && D.object.type === A.Literal && typeof D.object.value == "number" && (J = BA(_).toString(), J.indexOf(".") < 0 && !/[eExX]/.test(J) && s.code.isDecimalDigit(J.charCodeAt(J.length - 1)) && !(J.length >= 2 && J.charCodeAt(0) === 48) && _.push(" ")), _.push(D.optional ? "?." : "."), _.push(we(D.property))), YA(_, e.Member, M);
        },
        MetaProperty: function(D, M, v) {
          var _;
          return _ = [], _.push(typeof D.meta == "string" ? D.meta : we(D.meta)), _.push("."), _.push(typeof D.property == "string" ? D.property : we(D.property)), YA(_, e.Member, M);
        },
        UnaryExpression: function(D, M, v) {
          var _, J, oA, lA, mA;
          return J = this.generateExpression(D.argument, e.Unary, iA), l === "" ? _ = EA(D.operator, J) : (_ = [D.operator], D.operator.length > 2 ? _ = EA(_, J) : (lA = BA(_).toString(), mA = lA.charCodeAt(lA.length - 1), oA = J.toString().charCodeAt(0), ((mA === 43 || mA === 45) && mA === oA || s.code.isIdentifierPartES5(mA) && s.code.isIdentifierPartES5(oA)) && _.push(pA()), _.push(J))), YA(_, e.Unary, M);
        },
        YieldExpression: function(D, M, v) {
          var _;
          return D.delegate ? _ = "yield*" : _ = "yield", D.argument && (_ = EA(
            _,
            this.generateExpression(D.argument, e.Yield, iA)
          )), YA(_, e.Yield, M);
        },
        AwaitExpression: function(D, M, v) {
          var _ = EA(
            D.all ? "await*" : "await",
            this.generateExpression(D.argument, e.Await, iA)
          );
          return YA(_, e.Await, M);
        },
        UpdateExpression: function(D, M, v) {
          return D.prefix ? YA(
            [
              D.operator,
              this.generateExpression(D.argument, e.Unary, iA)
            ],
            e.Unary,
            M
          ) : YA(
            [
              this.generateExpression(D.argument, e.Postfix, iA),
              D.operator
            ],
            e.Postfix,
            M
          );
        },
        FunctionExpression: function(D, M, v) {
          var _ = [
            nt(D, !0),
            "function"
          ];
          return D.id ? (_.push(bn(D) || pA()), _.push(we(D.id))) : _.push(bn(D) || l), _.push(this.generateFunctionBody(D)), _;
        },
        ArrayPattern: function(D, M, v) {
          return this.ArrayExpression(D, M, v, !0);
        },
        ArrayExpression: function(D, M, v, _) {
          var J, oA, lA = this;
          return D.elements.length ? (oA = _ ? !1 : D.elements.length > 1, J = ["[", oA ? E : ""], oe(function(mA) {
            var xA, Ee;
            for (xA = 0, Ee = D.elements.length; xA < Ee; ++xA)
              D.elements[xA] ? (J.push(oA ? mA : ""), J.push(lA.generateExpression(D.elements[xA], e.Assignment, iA))) : (oA && J.push(mA), xA + 1 === Ee && J.push(",")), xA + 1 < Ee && J.push("," + (oA ? E : l));
          }), oA && !V(BA(J).toString()) && J.push(E), J.push(oA ? a : ""), J.push("]"), J) : "[]";
        },
        RestElement: function(D, M, v) {
          return "..." + this.generatePattern(D.argument);
        },
        ClassExpression: function(D, M, v) {
          var _, J;
          return _ = ["class"], D.id && (_ = EA(_, this.generateExpression(D.id, e.Sequence, iA))), D.superClass && (J = EA("extends", this.generateExpression(D.superClass, e.Unary, iA)), _ = EA(_, J)), _.push(l), _.push(this.generateStatement(D.body, N)), _;
        },
        MethodDefinition: function(D, M, v) {
          var _, J;
          return D.static ? _ = ["static" + l] : _ = [], D.kind === "get" || D.kind === "set" ? J = [
            EA(D.kind, this.generatePropertyKey(D.key, D.computed)),
            this.generateFunctionBody(D.value)
          ] : J = [
            tA(D),
            this.generatePropertyKey(D.key, D.computed),
            this.generateFunctionBody(D.value)
          ], EA(_, J);
        },
        Property: function(D, M, v) {
          return D.kind === "get" || D.kind === "set" ? [
            D.kind,
            pA(),
            this.generatePropertyKey(D.key, D.computed),
            this.generateFunctionBody(D.value)
          ] : D.shorthand ? D.value.type === "AssignmentPattern" ? this.AssignmentPattern(D.value, e.Sequence, iA) : this.generatePropertyKey(D.key, D.computed) : D.method ? [
            tA(D),
            this.generatePropertyKey(D.key, D.computed),
            this.generateFunctionBody(D.value)
          ] : [
            this.generatePropertyKey(D.key, D.computed),
            ":" + l,
            this.generateExpression(D.value, e.Assignment, iA)
          ];
        },
        ObjectExpression: function(D, M, v) {
          var _, J, oA, lA = this;
          return D.properties.length ? (_ = D.properties.length > 1, oe(function() {
            oA = lA.generateExpression(D.properties[0], e.Sequence, iA);
          }), !_ && !L(BA(oA).toString()) ? ["{", l, oA, l, "}"] : (oe(function(mA) {
            var xA, Ee;
            if (J = ["{", E, mA, oA], _)
              for (J.push("," + E), xA = 1, Ee = D.properties.length; xA < Ee; ++xA)
                J.push(mA), J.push(lA.generateExpression(D.properties[xA], e.Sequence, iA)), xA + 1 < Ee && J.push("," + E);
          }), V(BA(J).toString()) || J.push(E), J.push(a), J.push("}"), J)) : "{}";
        },
        AssignmentPattern: function(D, M, v) {
          return this.generateAssignment(D.left, D.right, "=", M, v);
        },
        ObjectPattern: function(D, M, v) {
          var _, J, oA, lA, mA, xA = this;
          if (!D.properties.length)
            return "{}";
          if (lA = !1, D.properties.length === 1)
            mA = D.properties[0], mA.type === A.Property && mA.value.type !== A.Identifier && (lA = !0);
          else
            for (J = 0, oA = D.properties.length; J < oA; ++J)
              if (mA = D.properties[J], mA.type === A.Property && !mA.shorthand) {
                lA = !0;
                break;
              }
          return _ = ["{", lA ? E : ""], oe(function(Ee) {
            var lt, Ta;
            for (lt = 0, Ta = D.properties.length; lt < Ta; ++lt)
              _.push(lA ? Ee : ""), _.push(xA.generateExpression(D.properties[lt], e.Sequence, iA)), lt + 1 < Ta && _.push("," + (lA ? E : l));
          }), lA && !V(BA(_).toString()) && _.push(E), _.push(lA ? a : ""), _.push("}"), _;
        },
        ThisExpression: function(D, M, v) {
          return "this";
        },
        Super: function(D, M, v) {
          return "super";
        },
        Identifier: function(D, M, v) {
          return we(D);
        },
        ImportDefaultSpecifier: function(D, M, v) {
          return we(D.id || D.local);
        },
        ImportNamespaceSpecifier: function(D, M, v) {
          var _ = ["*"], J = D.id || D.local;
          return J && _.push(l + "as" + pA() + we(J)), _;
        },
        ImportSpecifier: function(D, M, v) {
          var _ = D.imported, J = [_.name], oA = D.local;
          return oA && oA.name !== _.name && J.push(pA() + "as" + pA() + we(oA)), J;
        },
        ExportSpecifier: function(D, M, v) {
          var _ = D.local, J = [_.name], oA = D.exported;
          return oA && oA.name !== _.name && J.push(pA() + "as" + pA() + we(oA)), J;
        },
        Literal: function(D, M, v) {
          var _;
          if (D.hasOwnProperty("raw") && y && p.raw)
            try {
              if (_ = y(D.raw).body[0].expression, _.type === A.Literal && _.value === D.value)
                return D.raw;
            } catch {
            }
          return D.regex ? "/" + D.regex.pattern + "/" + D.regex.flags : typeof D.value == "bigint" ? D.value.toString() + "n" : D.bigint ? D.bigint + "n" : D.value === null ? "null" : typeof D.value == "string" ? RA(D.value) : typeof D.value == "number" ? X(D.value) : typeof D.value == "boolean" ? D.value ? "true" : "false" : SA(D.value);
        },
        GeneratorExpression: function(D, M, v) {
          return this.ComprehensionExpression(D, M, v);
        },
        ComprehensionExpression: function(D, M, v) {
          var _, J, oA, lA, mA = this;
          return _ = D.type === A.GeneratorExpression ? ["("] : ["["], p.moz.comprehensionExpressionStartsWithAssignment && (lA = this.generateExpression(D.body, e.Assignment, iA), _.push(lA)), D.blocks && oe(function() {
            for (J = 0, oA = D.blocks.length; J < oA; ++J)
              lA = mA.generateExpression(D.blocks[J], e.Sequence, iA), J > 0 || p.moz.comprehensionExpressionStartsWithAssignment ? _ = EA(_, lA) : _.push(lA);
          }), D.filter && (_ = EA(_, "if" + l), lA = this.generateExpression(D.filter, e.Sequence, iA), _ = EA(_, ["(", lA, ")"])), p.moz.comprehensionExpressionStartsWithAssignment || (lA = this.generateExpression(D.body, e.Assignment, iA), _ = EA(_, lA)), _.push(D.type === A.GeneratorExpression ? ")" : "]"), _;
        },
        ComprehensionBlock: function(D, M, v) {
          var _;
          return D.left.type === A.VariableDeclaration ? _ = [
            D.left.kind,
            pA(),
            this.generateStatement(D.left.declarations[0], CA)
          ] : _ = this.generateExpression(D.left, e.Call, iA), _ = EA(_, D.of ? "of" : "in"), _ = EA(_, this.generateExpression(D.right, e.Sequence, iA)), ["for" + l + "(", _, ")"];
        },
        SpreadElement: function(D, M, v) {
          return [
            "...",
            this.generateExpression(D.argument, e.Assignment, iA)
          ];
        },
        TaggedTemplateExpression: function(D, M, v) {
          var _ = UA;
          v & H || (_ = wA);
          var J = [
            this.generateExpression(D.tag, e.Call, _),
            this.generateExpression(D.quasi, e.Primary, Re)
          ];
          return YA(J, e.TaggedTemplate, M);
        },
        TemplateElement: function(D, M, v) {
          return D.value.raw;
        },
        TemplateLiteral: function(D, M, v) {
          var _, J, oA;
          for (_ = ["`"], J = 0, oA = D.quasis.length; J < oA; ++J)
            _.push(this.generateExpression(D.quasis[J], e.Primary, iA)), J + 1 < oA && (_.push("${" + l), _.push(this.generateExpression(D.expressions[J], e.Sequence, iA)), _.push(l + "}"));
          return _.push("`"), _;
        },
        ModuleSpecifier: function(D, M, v) {
          return this.Literal(D, M, v);
        },
        ImportExpression: function(D, M, v) {
          return YA([
            "import(",
            this.generateExpression(D.source, e.Assignment, iA),
            ")"
          ], e.Call, M);
        }
      }, Z(Qe.prototype, Qe.Expression), Qe.prototype.generateExpression = function(D, M, v) {
        var _, J;
        return J = D.type || A.Property, p.verbatim && D.hasOwnProperty(p.verbatim) ? Oe(D, M) : (_ = this[J](D, M, v), p.comment && (_ = fA(D, _)), BA(_, D));
      }, Qe.prototype.generateStatement = function(D, M) {
        var v, _;
        return v = this[D.type](D, M), p.comment && (v = fA(D, v)), _ = BA(v).toString(), D.type === A.Program && !Q && E === "" && _.charAt(_.length - 1) === `
` && (v = m ? BA(v).replaceRight(/\s+$/, "") : _.replace(/\s+$/, "")), BA(v, D);
      };
      function nA(D) {
        var M;
        if (M = new Qe(), T(D))
          return M.generateStatement(D, U);
        if (G(D))
          return M.generateExpression(D, e.Sequence, iA);
        throw new Error("Unknown node type: " + D.type);
      }
      function DA(D, M) {
        var v = ue(), _, J;
        return M != null ? (typeof M.indent == "string" && (v.format.indent.style = M.indent), typeof M.base == "number" && (v.format.indent.base = M.base), M = cA(v, M), g = M.format.indent.style, typeof M.base == "string" ? a = M.base : a = Y(g, M.format.indent.base)) : (M = v, g = M.format.indent.style, a = Y(g, M.format.indent.base)), o = M.format.json, u = M.format.renumber, I = o ? !1 : M.format.hexadecimal, c = o ? "double" : M.format.quotes, C = M.format.escapeless, E = M.format.newline, l = M.format.space, M.format.compact && (E = l = g = a = ""), B = M.format.parentheses, h = M.format.semicolons, Q = M.format.safeConcatenation, f = M.directive, y = o ? null : M.parse, m = M.sourceMap, S = M.sourceCode, w = M.format.preserveBlankLines && S !== null, p = M, m && (t.browser ? i = W.sourceMap.SourceNode : i = YeA().SourceNode), _ = nA(D), m ? (J = _.toStringWithSourceMap({
          file: M.file,
          sourceRoot: M.sourceMapRoot
        }), M.sourceContent && J.map.setSourceContent(
          M.sourceMap,
          M.sourceContent
        ), M.sourceMapWithCode ? J : J.map.toString()) : (J = { code: _.toString(), map: null }, M.sourceMapWithCode ? J : J.code);
      }
      F = {
        indent: {
          style: "",
          base: 0
        },
        renumber: !0,
        hexadecimal: !0,
        quotes: "auto",
        escapeless: !0,
        compact: !0,
        parentheses: !1,
        semicolons: !1
      }, b = ue().format, t.version = jeA.version, t.generate = DA, t.attachComments = n.attachComments, t.Precedence = cA({}, e), t.browser = !1, t.FORMAT_MINIFY = F, t.FORMAT_DEFAULTS = b;
    })();
  }(Zy)), Zy;
}
var ow = { exports: {} }, Lb;
function VeA() {
  return Lb || (Lb = 1, function(t, A) {
    (function(r, i) {
      t.exports = i();
    })(W, function() {
      return (
        /******/
        function(e) {
          var r = {};
          function i(n) {
            if (r[n])
              return r[n].exports;
            var s = r[n] = {
              /******/
              exports: {},
              /******/
              id: n,
              /******/
              loaded: !1
              /******/
            };
            return e[n].call(s.exports, s, s.exports, i), s.loaded = !0, s.exports;
          }
          return i.m = e, i.c = r, i.p = "", i(0);
        }([
          /* 0 */
          /***/
          function(e, r, i) {
            Object.defineProperty(r, "__esModule", { value: !0 });
            var n = i(1), s = i(3), a = i(8), g = i(15);
            function o(E, l, B) {
              var h = null, Q = function(b, G) {
                B && B(b, G), h && h.visit(b, G);
              }, f = typeof B == "function" ? Q : null, p = !1;
              if (l) {
                p = typeof l.comment == "boolean" && l.comment;
                var y = typeof l.attachComment == "boolean" && l.attachComment;
                (p || y) && (h = new n.CommentHandler(), h.attach = y, l.comment = !0, f = Q);
              }
              var m = !1;
              l && typeof l.sourceType == "string" && (m = l.sourceType === "module");
              var S;
              l && typeof l.jsx == "boolean" && l.jsx ? S = new s.JSXParser(E, l, f) : S = new a.Parser(E, l, f);
              var w = m ? S.parseModule() : S.parseScript(), F = w;
              return p && h && (F.comments = h.comments), S.config.tokens && (F.tokens = S.tokens), S.config.tolerant && (F.errors = S.errorHandler.errors), F;
            }
            r.parse = o;
            function u(E, l, B) {
              var h = l || {};
              return h.sourceType = "module", o(E, h, B);
            }
            r.parseModule = u;
            function I(E, l, B) {
              var h = l || {};
              return h.sourceType = "script", o(E, h, B);
            }
            r.parseScript = I;
            function c(E, l, B) {
              var h = new g.Tokenizer(E, l), Q;
              Q = [];
              try {
                for (; ; ) {
                  var f = h.getNextToken();
                  if (!f)
                    break;
                  B && (f = B(f)), Q.push(f);
                }
              } catch (p) {
                h.errorHandler.tolerate(p);
              }
              return h.errorHandler.tolerant && (Q.errors = h.errors()), Q;
            }
            r.tokenize = c;
            var C = i(2);
            r.Syntax = C.Syntax, r.version = "4.0.1";
          },
          /* 1 */
          /***/
          function(e, r, i) {
            Object.defineProperty(r, "__esModule", { value: !0 });
            var n = i(2), s = function() {
              function a() {
                this.attach = !1, this.comments = [], this.stack = [], this.leading = [], this.trailing = [];
              }
              return a.prototype.insertInnerComments = function(g, o) {
                if (g.type === n.Syntax.BlockStatement && g.body.length === 0) {
                  for (var u = [], I = this.leading.length - 1; I >= 0; --I) {
                    var c = this.leading[I];
                    o.end.offset >= c.start && (u.unshift(c.comment), this.leading.splice(I, 1), this.trailing.splice(I, 1));
                  }
                  u.length && (g.innerComments = u);
                }
              }, a.prototype.findTrailingComments = function(g) {
                var o = [];
                if (this.trailing.length > 0) {
                  for (var u = this.trailing.length - 1; u >= 0; --u) {
                    var I = this.trailing[u];
                    I.start >= g.end.offset && o.unshift(I.comment);
                  }
                  return this.trailing.length = 0, o;
                }
                var c = this.stack[this.stack.length - 1];
                if (c && c.node.trailingComments) {
                  var C = c.node.trailingComments[0];
                  C && C.range[0] >= g.end.offset && (o = c.node.trailingComments, delete c.node.trailingComments);
                }
                return o;
              }, a.prototype.findLeadingComments = function(g) {
                for (var o = [], u; this.stack.length > 0; ) {
                  var I = this.stack[this.stack.length - 1];
                  if (I && I.start >= g.start.offset)
                    u = I.node, this.stack.pop();
                  else
                    break;
                }
                if (u) {
                  for (var c = u.leadingComments ? u.leadingComments.length : 0, C = c - 1; C >= 0; --C) {
                    var E = u.leadingComments[C];
                    E.range[1] <= g.start.offset && (o.unshift(E), u.leadingComments.splice(C, 1));
                  }
                  return u.leadingComments && u.leadingComments.length === 0 && delete u.leadingComments, o;
                }
                for (var C = this.leading.length - 1; C >= 0; --C) {
                  var I = this.leading[C];
                  I.start <= g.start.offset && (o.unshift(I.comment), this.leading.splice(C, 1));
                }
                return o;
              }, a.prototype.visitNode = function(g, o) {
                if (!(g.type === n.Syntax.Program && g.body.length > 0)) {
                  this.insertInnerComments(g, o);
                  var u = this.findTrailingComments(o), I = this.findLeadingComments(o);
                  I.length > 0 && (g.leadingComments = I), u.length > 0 && (g.trailingComments = u), this.stack.push({
                    node: g,
                    start: o.start.offset
                  });
                }
              }, a.prototype.visitComment = function(g, o) {
                var u = g.type[0] === "L" ? "Line" : "Block", I = {
                  type: u,
                  value: g.value
                };
                if (g.range && (I.range = g.range), g.loc && (I.loc = g.loc), this.comments.push(I), this.attach) {
                  var c = {
                    comment: {
                      type: u,
                      value: g.value,
                      range: [o.start.offset, o.end.offset]
                    },
                    start: o.start.offset
                  };
                  g.loc && (c.comment.loc = g.loc), g.type = u, this.leading.push(c), this.trailing.push(c);
                }
              }, a.prototype.visit = function(g, o) {
                g.type === "LineComment" ? this.visitComment(g, o) : g.type === "BlockComment" ? this.visitComment(g, o) : this.attach && this.visitNode(g, o);
              }, a;
            }();
            r.CommentHandler = s;
          },
          /* 2 */
          /***/
          function(e, r) {
            Object.defineProperty(r, "__esModule", { value: !0 }), r.Syntax = {
              AssignmentExpression: "AssignmentExpression",
              AssignmentPattern: "AssignmentPattern",
              ArrayExpression: "ArrayExpression",
              ArrayPattern: "ArrayPattern",
              ArrowFunctionExpression: "ArrowFunctionExpression",
              AwaitExpression: "AwaitExpression",
              BlockStatement: "BlockStatement",
              BinaryExpression: "BinaryExpression",
              BreakStatement: "BreakStatement",
              CallExpression: "CallExpression",
              CatchClause: "CatchClause",
              ClassBody: "ClassBody",
              ClassDeclaration: "ClassDeclaration",
              ClassExpression: "ClassExpression",
              ConditionalExpression: "ConditionalExpression",
              ContinueStatement: "ContinueStatement",
              DoWhileStatement: "DoWhileStatement",
              DebuggerStatement: "DebuggerStatement",
              EmptyStatement: "EmptyStatement",
              ExportAllDeclaration: "ExportAllDeclaration",
              ExportDefaultDeclaration: "ExportDefaultDeclaration",
              ExportNamedDeclaration: "ExportNamedDeclaration",
              ExportSpecifier: "ExportSpecifier",
              ExpressionStatement: "ExpressionStatement",
              ForStatement: "ForStatement",
              ForOfStatement: "ForOfStatement",
              ForInStatement: "ForInStatement",
              FunctionDeclaration: "FunctionDeclaration",
              FunctionExpression: "FunctionExpression",
              Identifier: "Identifier",
              IfStatement: "IfStatement",
              ImportDeclaration: "ImportDeclaration",
              ImportDefaultSpecifier: "ImportDefaultSpecifier",
              ImportNamespaceSpecifier: "ImportNamespaceSpecifier",
              ImportSpecifier: "ImportSpecifier",
              Literal: "Literal",
              LabeledStatement: "LabeledStatement",
              LogicalExpression: "LogicalExpression",
              MemberExpression: "MemberExpression",
              MetaProperty: "MetaProperty",
              MethodDefinition: "MethodDefinition",
              NewExpression: "NewExpression",
              ObjectExpression: "ObjectExpression",
              ObjectPattern: "ObjectPattern",
              Program: "Program",
              Property: "Property",
              RestElement: "RestElement",
              ReturnStatement: "ReturnStatement",
              SequenceExpression: "SequenceExpression",
              SpreadElement: "SpreadElement",
              Super: "Super",
              SwitchCase: "SwitchCase",
              SwitchStatement: "SwitchStatement",
              TaggedTemplateExpression: "TaggedTemplateExpression",
              TemplateElement: "TemplateElement",
              TemplateLiteral: "TemplateLiteral",
              ThisExpression: "ThisExpression",
              ThrowStatement: "ThrowStatement",
              TryStatement: "TryStatement",
              UnaryExpression: "UnaryExpression",
              UpdateExpression: "UpdateExpression",
              VariableDeclaration: "VariableDeclaration",
              VariableDeclarator: "VariableDeclarator",
              WhileStatement: "WhileStatement",
              WithStatement: "WithStatement",
              YieldExpression: "YieldExpression"
            };
          },
          /* 3 */
          /***/
          function(e, r, i) {
            var n = this && this.__extends || function() {
              var l = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(B, h) {
                B.__proto__ = h;
              } || function(B, h) {
                for (var Q in h) h.hasOwnProperty(Q) && (B[Q] = h[Q]);
              };
              return function(B, h) {
                l(B, h);
                function Q() {
                  this.constructor = B;
                }
                B.prototype = h === null ? Object.create(h) : (Q.prototype = h.prototype, new Q());
              };
            }();
            Object.defineProperty(r, "__esModule", { value: !0 });
            var s = i(4), a = i(5), g = i(6), o = i(7), u = i(8), I = i(13), c = i(14);
            I.TokenName[
              100
              /* Identifier */
            ] = "JSXIdentifier", I.TokenName[
              101
              /* Text */
            ] = "JSXText";
            function C(l) {
              var B;
              switch (l.type) {
                case g.JSXSyntax.JSXIdentifier:
                  var h = l;
                  B = h.name;
                  break;
                case g.JSXSyntax.JSXNamespacedName:
                  var Q = l;
                  B = C(Q.namespace) + ":" + C(Q.name);
                  break;
                case g.JSXSyntax.JSXMemberExpression:
                  var f = l;
                  B = C(f.object) + "." + C(f.property);
                  break;
              }
              return B;
            }
            var E = function(l) {
              n(B, l);
              function B(h, Q, f) {
                return l.call(this, h, Q, f) || this;
              }
              return B.prototype.parsePrimaryExpression = function() {
                return this.match("<") ? this.parseJSXRoot() : l.prototype.parsePrimaryExpression.call(this);
              }, B.prototype.startJSX = function() {
                this.scanner.index = this.startMarker.index, this.scanner.lineNumber = this.startMarker.line, this.scanner.lineStart = this.startMarker.index - this.startMarker.column;
              }, B.prototype.finishJSX = function() {
                this.nextToken();
              }, B.prototype.reenterJSX = function() {
                this.startJSX(), this.expectJSX("}"), this.config.tokens && this.tokens.pop();
              }, B.prototype.createJSXNode = function() {
                return this.collectComments(), {
                  index: this.scanner.index,
                  line: this.scanner.lineNumber,
                  column: this.scanner.index - this.scanner.lineStart
                };
              }, B.prototype.createJSXChildNode = function() {
                return {
                  index: this.scanner.index,
                  line: this.scanner.lineNumber,
                  column: this.scanner.index - this.scanner.lineStart
                };
              }, B.prototype.scanXHTMLEntity = function(h) {
                for (var Q = "&", f = !0, p = !1, y = !1, m = !1; !this.scanner.eof() && f && !p; ) {
                  var S = this.scanner.source[this.scanner.index];
                  if (S === h)
                    break;
                  if (p = S === ";", Q += S, ++this.scanner.index, !p)
                    switch (Q.length) {
                      case 2:
                        y = S === "#";
                        break;
                      case 3:
                        y && (m = S === "x", f = m || s.Character.isDecimalDigit(S.charCodeAt(0)), y = y && !m);
                        break;
                      default:
                        f = f && !(y && !s.Character.isDecimalDigit(S.charCodeAt(0))), f = f && !(m && !s.Character.isHexDigit(S.charCodeAt(0)));
                        break;
                    }
                }
                if (f && p && Q.length > 2) {
                  var w = Q.substr(1, Q.length - 2);
                  y && w.length > 1 ? Q = String.fromCharCode(parseInt(w.substr(1), 10)) : m && w.length > 2 ? Q = String.fromCharCode(parseInt("0" + w.substr(1), 16)) : !y && !m && c.XHTMLEntities[w] && (Q = c.XHTMLEntities[w]);
                }
                return Q;
              }, B.prototype.lexJSX = function() {
                var h = this.scanner.source.charCodeAt(this.scanner.index);
                if (h === 60 || h === 62 || h === 47 || h === 58 || h === 61 || h === 123 || h === 125) {
                  var Q = this.scanner.source[this.scanner.index++];
                  return {
                    type: 7,
                    value: Q,
                    lineNumber: this.scanner.lineNumber,
                    lineStart: this.scanner.lineStart,
                    start: this.scanner.index - 1,
                    end: this.scanner.index
                  };
                }
                if (h === 34 || h === 39) {
                  for (var f = this.scanner.index, p = this.scanner.source[this.scanner.index++], y = ""; !this.scanner.eof(); ) {
                    var m = this.scanner.source[this.scanner.index++];
                    if (m === p)
                      break;
                    m === "&" ? y += this.scanXHTMLEntity(p) : y += m;
                  }
                  return {
                    type: 8,
                    value: y,
                    lineNumber: this.scanner.lineNumber,
                    lineStart: this.scanner.lineStart,
                    start: f,
                    end: this.scanner.index
                  };
                }
                if (h === 46) {
                  var S = this.scanner.source.charCodeAt(this.scanner.index + 1), w = this.scanner.source.charCodeAt(this.scanner.index + 2), Q = S === 46 && w === 46 ? "..." : ".", f = this.scanner.index;
                  return this.scanner.index += Q.length, {
                    type: 7,
                    value: Q,
                    lineNumber: this.scanner.lineNumber,
                    lineStart: this.scanner.lineStart,
                    start: f,
                    end: this.scanner.index
                  };
                }
                if (h === 96)
                  return {
                    type: 10,
                    value: "",
                    lineNumber: this.scanner.lineNumber,
                    lineStart: this.scanner.lineStart,
                    start: this.scanner.index,
                    end: this.scanner.index
                  };
                if (s.Character.isIdentifierStart(h) && h !== 92) {
                  var f = this.scanner.index;
                  for (++this.scanner.index; !this.scanner.eof(); ) {
                    var m = this.scanner.source.charCodeAt(this.scanner.index);
                    if (s.Character.isIdentifierPart(m) && m !== 92)
                      ++this.scanner.index;
                    else if (m === 45)
                      ++this.scanner.index;
                    else
                      break;
                  }
                  var F = this.scanner.source.slice(f, this.scanner.index);
                  return {
                    type: 100,
                    value: F,
                    lineNumber: this.scanner.lineNumber,
                    lineStart: this.scanner.lineStart,
                    start: f,
                    end: this.scanner.index
                  };
                }
                return this.scanner.lex();
              }, B.prototype.nextJSXToken = function() {
                this.collectComments(), this.startMarker.index = this.scanner.index, this.startMarker.line = this.scanner.lineNumber, this.startMarker.column = this.scanner.index - this.scanner.lineStart;
                var h = this.lexJSX();
                return this.lastMarker.index = this.scanner.index, this.lastMarker.line = this.scanner.lineNumber, this.lastMarker.column = this.scanner.index - this.scanner.lineStart, this.config.tokens && this.tokens.push(this.convertToken(h)), h;
              }, B.prototype.nextJSXText = function() {
                this.startMarker.index = this.scanner.index, this.startMarker.line = this.scanner.lineNumber, this.startMarker.column = this.scanner.index - this.scanner.lineStart;
                for (var h = this.scanner.index, Q = ""; !this.scanner.eof(); ) {
                  var f = this.scanner.source[this.scanner.index];
                  if (f === "{" || f === "<")
                    break;
                  ++this.scanner.index, Q += f, s.Character.isLineTerminator(f.charCodeAt(0)) && (++this.scanner.lineNumber, f === "\r" && this.scanner.source[this.scanner.index] === `
` && ++this.scanner.index, this.scanner.lineStart = this.scanner.index);
                }
                this.lastMarker.index = this.scanner.index, this.lastMarker.line = this.scanner.lineNumber, this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
                var p = {
                  type: 101,
                  value: Q,
                  lineNumber: this.scanner.lineNumber,
                  lineStart: this.scanner.lineStart,
                  start: h,
                  end: this.scanner.index
                };
                return Q.length > 0 && this.config.tokens && this.tokens.push(this.convertToken(p)), p;
              }, B.prototype.peekJSXToken = function() {
                var h = this.scanner.saveState();
                this.scanner.scanComments();
                var Q = this.lexJSX();
                return this.scanner.restoreState(h), Q;
              }, B.prototype.expectJSX = function(h) {
                var Q = this.nextJSXToken();
                (Q.type !== 7 || Q.value !== h) && this.throwUnexpectedToken(Q);
              }, B.prototype.matchJSX = function(h) {
                var Q = this.peekJSXToken();
                return Q.type === 7 && Q.value === h;
              }, B.prototype.parseJSXIdentifier = function() {
                var h = this.createJSXNode(), Q = this.nextJSXToken();
                return Q.type !== 100 && this.throwUnexpectedToken(Q), this.finalize(h, new a.JSXIdentifier(Q.value));
              }, B.prototype.parseJSXElementName = function() {
                var h = this.createJSXNode(), Q = this.parseJSXIdentifier();
                if (this.matchJSX(":")) {
                  var f = Q;
                  this.expectJSX(":");
                  var p = this.parseJSXIdentifier();
                  Q = this.finalize(h, new a.JSXNamespacedName(f, p));
                } else if (this.matchJSX("."))
                  for (; this.matchJSX("."); ) {
                    var y = Q;
                    this.expectJSX(".");
                    var m = this.parseJSXIdentifier();
                    Q = this.finalize(h, new a.JSXMemberExpression(y, m));
                  }
                return Q;
              }, B.prototype.parseJSXAttributeName = function() {
                var h = this.createJSXNode(), Q, f = this.parseJSXIdentifier();
                if (this.matchJSX(":")) {
                  var p = f;
                  this.expectJSX(":");
                  var y = this.parseJSXIdentifier();
                  Q = this.finalize(h, new a.JSXNamespacedName(p, y));
                } else
                  Q = f;
                return Q;
              }, B.prototype.parseJSXStringLiteralAttribute = function() {
                var h = this.createJSXNode(), Q = this.nextJSXToken();
                Q.type !== 8 && this.throwUnexpectedToken(Q);
                var f = this.getTokenRaw(Q);
                return this.finalize(h, new o.Literal(Q.value, f));
              }, B.prototype.parseJSXExpressionAttribute = function() {
                var h = this.createJSXNode();
                this.expectJSX("{"), this.finishJSX(), this.match("}") && this.tolerateError("JSX attributes must only be assigned a non-empty expression");
                var Q = this.parseAssignmentExpression();
                return this.reenterJSX(), this.finalize(h, new a.JSXExpressionContainer(Q));
              }, B.prototype.parseJSXAttributeValue = function() {
                return this.matchJSX("{") ? this.parseJSXExpressionAttribute() : this.matchJSX("<") ? this.parseJSXElement() : this.parseJSXStringLiteralAttribute();
              }, B.prototype.parseJSXNameValueAttribute = function() {
                var h = this.createJSXNode(), Q = this.parseJSXAttributeName(), f = null;
                return this.matchJSX("=") && (this.expectJSX("="), f = this.parseJSXAttributeValue()), this.finalize(h, new a.JSXAttribute(Q, f));
              }, B.prototype.parseJSXSpreadAttribute = function() {
                var h = this.createJSXNode();
                this.expectJSX("{"), this.expectJSX("..."), this.finishJSX();
                var Q = this.parseAssignmentExpression();
                return this.reenterJSX(), this.finalize(h, new a.JSXSpreadAttribute(Q));
              }, B.prototype.parseJSXAttributes = function() {
                for (var h = []; !this.matchJSX("/") && !this.matchJSX(">"); ) {
                  var Q = this.matchJSX("{") ? this.parseJSXSpreadAttribute() : this.parseJSXNameValueAttribute();
                  h.push(Q);
                }
                return h;
              }, B.prototype.parseJSXOpeningElement = function() {
                var h = this.createJSXNode();
                this.expectJSX("<");
                var Q = this.parseJSXElementName(), f = this.parseJSXAttributes(), p = this.matchJSX("/");
                return p && this.expectJSX("/"), this.expectJSX(">"), this.finalize(h, new a.JSXOpeningElement(Q, p, f));
              }, B.prototype.parseJSXBoundaryElement = function() {
                var h = this.createJSXNode();
                if (this.expectJSX("<"), this.matchJSX("/")) {
                  this.expectJSX("/");
                  var Q = this.parseJSXElementName();
                  return this.expectJSX(">"), this.finalize(h, new a.JSXClosingElement(Q));
                }
                var f = this.parseJSXElementName(), p = this.parseJSXAttributes(), y = this.matchJSX("/");
                return y && this.expectJSX("/"), this.expectJSX(">"), this.finalize(h, new a.JSXOpeningElement(f, y, p));
              }, B.prototype.parseJSXEmptyExpression = function() {
                var h = this.createJSXChildNode();
                return this.collectComments(), this.lastMarker.index = this.scanner.index, this.lastMarker.line = this.scanner.lineNumber, this.lastMarker.column = this.scanner.index - this.scanner.lineStart, this.finalize(h, new a.JSXEmptyExpression());
              }, B.prototype.parseJSXExpressionContainer = function() {
                var h = this.createJSXNode();
                this.expectJSX("{");
                var Q;
                return this.matchJSX("}") ? (Q = this.parseJSXEmptyExpression(), this.expectJSX("}")) : (this.finishJSX(), Q = this.parseAssignmentExpression(), this.reenterJSX()), this.finalize(h, new a.JSXExpressionContainer(Q));
              }, B.prototype.parseJSXChildren = function() {
                for (var h = []; !this.scanner.eof(); ) {
                  var Q = this.createJSXChildNode(), f = this.nextJSXText();
                  if (f.start < f.end) {
                    var p = this.getTokenRaw(f), y = this.finalize(Q, new a.JSXText(f.value, p));
                    h.push(y);
                  }
                  if (this.scanner.source[this.scanner.index] === "{") {
                    var m = this.parseJSXExpressionContainer();
                    h.push(m);
                  } else
                    break;
                }
                return h;
              }, B.prototype.parseComplexJSXElement = function(h) {
                for (var Q = []; !this.scanner.eof(); ) {
                  h.children = h.children.concat(this.parseJSXChildren());
                  var f = this.createJSXChildNode(), p = this.parseJSXBoundaryElement();
                  if (p.type === g.JSXSyntax.JSXOpeningElement) {
                    var y = p;
                    if (y.selfClosing) {
                      var m = this.finalize(f, new a.JSXElement(y, [], null));
                      h.children.push(m);
                    } else
                      Q.push(h), h = { node: f, opening: y, closing: null, children: [] };
                  }
                  if (p.type === g.JSXSyntax.JSXClosingElement) {
                    h.closing = p;
                    var S = C(h.opening.name), w = C(h.closing.name);
                    if (S !== w && this.tolerateError("Expected corresponding JSX closing tag for %0", S), Q.length > 0) {
                      var m = this.finalize(h.node, new a.JSXElement(h.opening, h.children, h.closing));
                      h = Q[Q.length - 1], h.children.push(m), Q.pop();
                    } else
                      break;
                  }
                }
                return h;
              }, B.prototype.parseJSXElement = function() {
                var h = this.createJSXNode(), Q = this.parseJSXOpeningElement(), f = [], p = null;
                if (!Q.selfClosing) {
                  var y = this.parseComplexJSXElement({ node: h, opening: Q, closing: p, children: f });
                  f = y.children, p = y.closing;
                }
                return this.finalize(h, new a.JSXElement(Q, f, p));
              }, B.prototype.parseJSXRoot = function() {
                this.config.tokens && this.tokens.pop(), this.startJSX();
                var h = this.parseJSXElement();
                return this.finishJSX(), h;
              }, B.prototype.isStartOfExpression = function() {
                return l.prototype.isStartOfExpression.call(this) || this.match("<");
              }, B;
            }(u.Parser);
            r.JSXParser = E;
          },
          /* 4 */
          /***/
          function(e, r) {
            Object.defineProperty(r, "__esModule", { value: !0 });
            var i = {
              // Unicode v8.0.0 NonAsciiIdentifierStart:
              NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,
              // Unicode v8.0.0 NonAsciiIdentifierPart:
              NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
            };
            r.Character = {
              /* tslint:disable:no-bitwise */
              fromCodePoint: function(n) {
                return n < 65536 ? String.fromCharCode(n) : String.fromCharCode(55296 + (n - 65536 >> 10)) + String.fromCharCode(56320 + (n - 65536 & 1023));
              },
              // https://tc39.github.io/ecma262/#sec-white-space
              isWhiteSpace: function(n) {
                return n === 32 || n === 9 || n === 11 || n === 12 || n === 160 || n >= 5760 && [5760, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288, 65279].indexOf(n) >= 0;
              },
              // https://tc39.github.io/ecma262/#sec-line-terminators
              isLineTerminator: function(n) {
                return n === 10 || n === 13 || n === 8232 || n === 8233;
              },
              // https://tc39.github.io/ecma262/#sec-names-and-keywords
              isIdentifierStart: function(n) {
                return n === 36 || n === 95 || n >= 65 && n <= 90 || n >= 97 && n <= 122 || n === 92 || n >= 128 && i.NonAsciiIdentifierStart.test(r.Character.fromCodePoint(n));
              },
              isIdentifierPart: function(n) {
                return n === 36 || n === 95 || n >= 65 && n <= 90 || n >= 97 && n <= 122 || n >= 48 && n <= 57 || n === 92 || n >= 128 && i.NonAsciiIdentifierPart.test(r.Character.fromCodePoint(n));
              },
              // https://tc39.github.io/ecma262/#sec-literals-numeric-literals
              isDecimalDigit: function(n) {
                return n >= 48 && n <= 57;
              },
              isHexDigit: function(n) {
                return n >= 48 && n <= 57 || n >= 65 && n <= 70 || n >= 97 && n <= 102;
              },
              isOctalDigit: function(n) {
                return n >= 48 && n <= 55;
              }
            };
          },
          /* 5 */
          /***/
          function(e, r, i) {
            Object.defineProperty(r, "__esModule", { value: !0 });
            var n = i(6), s = /* @__PURE__ */ function() {
              function h(Q) {
                this.type = n.JSXSyntax.JSXClosingElement, this.name = Q;
              }
              return h;
            }();
            r.JSXClosingElement = s;
            var a = /* @__PURE__ */ function() {
              function h(Q, f, p) {
                this.type = n.JSXSyntax.JSXElement, this.openingElement = Q, this.children = f, this.closingElement = p;
              }
              return h;
            }();
            r.JSXElement = a;
            var g = /* @__PURE__ */ function() {
              function h() {
                this.type = n.JSXSyntax.JSXEmptyExpression;
              }
              return h;
            }();
            r.JSXEmptyExpression = g;
            var o = /* @__PURE__ */ function() {
              function h(Q) {
                this.type = n.JSXSyntax.JSXExpressionContainer, this.expression = Q;
              }
              return h;
            }();
            r.JSXExpressionContainer = o;
            var u = /* @__PURE__ */ function() {
              function h(Q) {
                this.type = n.JSXSyntax.JSXIdentifier, this.name = Q;
              }
              return h;
            }();
            r.JSXIdentifier = u;
            var I = /* @__PURE__ */ function() {
              function h(Q, f) {
                this.type = n.JSXSyntax.JSXMemberExpression, this.object = Q, this.property = f;
              }
              return h;
            }();
            r.JSXMemberExpression = I;
            var c = /* @__PURE__ */ function() {
              function h(Q, f) {
                this.type = n.JSXSyntax.JSXAttribute, this.name = Q, this.value = f;
              }
              return h;
            }();
            r.JSXAttribute = c;
            var C = /* @__PURE__ */ function() {
              function h(Q, f) {
                this.type = n.JSXSyntax.JSXNamespacedName, this.namespace = Q, this.name = f;
              }
              return h;
            }();
            r.JSXNamespacedName = C;
            var E = /* @__PURE__ */ function() {
              function h(Q, f, p) {
                this.type = n.JSXSyntax.JSXOpeningElement, this.name = Q, this.selfClosing = f, this.attributes = p;
              }
              return h;
            }();
            r.JSXOpeningElement = E;
            var l = /* @__PURE__ */ function() {
              function h(Q) {
                this.type = n.JSXSyntax.JSXSpreadAttribute, this.argument = Q;
              }
              return h;
            }();
            r.JSXSpreadAttribute = l;
            var B = /* @__PURE__ */ function() {
              function h(Q, f) {
                this.type = n.JSXSyntax.JSXText, this.value = Q, this.raw = f;
              }
              return h;
            }();
            r.JSXText = B;
          },
          /* 6 */
          /***/
          function(e, r) {
            Object.defineProperty(r, "__esModule", { value: !0 }), r.JSXSyntax = {
              JSXAttribute: "JSXAttribute",
              JSXClosingElement: "JSXClosingElement",
              JSXElement: "JSXElement",
              JSXEmptyExpression: "JSXEmptyExpression",
              JSXExpressionContainer: "JSXExpressionContainer",
              JSXIdentifier: "JSXIdentifier",
              JSXMemberExpression: "JSXMemberExpression",
              JSXNamespacedName: "JSXNamespacedName",
              JSXOpeningElement: "JSXOpeningElement",
              JSXSpreadAttribute: "JSXSpreadAttribute",
              JSXText: "JSXText"
            };
          },
          /* 7 */
          /***/
          function(e, r, i) {
            Object.defineProperty(r, "__esModule", { value: !0 });
            var n = i(2), s = /* @__PURE__ */ function() {
              function tA(nA) {
                this.type = n.Syntax.ArrayExpression, this.elements = nA;
              }
              return tA;
            }();
            r.ArrayExpression = s;
            var a = /* @__PURE__ */ function() {
              function tA(nA) {
                this.type = n.Syntax.ArrayPattern, this.elements = nA;
              }
              return tA;
            }();
            r.ArrayPattern = a;
            var g = /* @__PURE__ */ function() {
              function tA(nA, DA, D) {
                this.type = n.Syntax.ArrowFunctionExpression, this.id = null, this.params = nA, this.body = DA, this.generator = !1, this.expression = D, this.async = !1;
              }
              return tA;
            }();
            r.ArrowFunctionExpression = g;
            var o = /* @__PURE__ */ function() {
              function tA(nA, DA, D) {
                this.type = n.Syntax.AssignmentExpression, this.operator = nA, this.left = DA, this.right = D;
              }
              return tA;
            }();
            r.AssignmentExpression = o;
            var u = /* @__PURE__ */ function() {
              function tA(nA, DA) {
                this.type = n.Syntax.AssignmentPattern, this.left = nA, this.right = DA;
              }
              return tA;
            }();
            r.AssignmentPattern = u;
            var I = /* @__PURE__ */ function() {
              function tA(nA, DA, D) {
                this.type = n.Syntax.ArrowFunctionExpression, this.id = null, this.params = nA, this.body = DA, this.generator = !1, this.expression = D, this.async = !0;
              }
              return tA;
            }();
            r.AsyncArrowFunctionExpression = I;
            var c = /* @__PURE__ */ function() {
              function tA(nA, DA, D) {
                this.type = n.Syntax.FunctionDeclaration, this.id = nA, this.params = DA, this.body = D, this.generator = !1, this.expression = !1, this.async = !0;
              }
              return tA;
            }();
            r.AsyncFunctionDeclaration = c;
            var C = /* @__PURE__ */ function() {
              function tA(nA, DA, D) {
                this.type = n.Syntax.FunctionExpression, this.id = nA, this.params = DA, this.body = D, this.generator = !1, this.expression = !1, this.async = !0;
              }
              return tA;
            }();
            r.AsyncFunctionExpression = C;
            var E = /* @__PURE__ */ function() {
              function tA(nA) {
                this.type = n.Syntax.AwaitExpression, this.argument = nA;
              }
              return tA;
            }();
            r.AwaitExpression = E;
            var l = /* @__PURE__ */ function() {
              function tA(nA, DA, D) {
                var M = nA === "||" || nA === "&&";
                this.type = M ? n.Syntax.LogicalExpression : n.Syntax.BinaryExpression, this.operator = nA, this.left = DA, this.right = D;
              }
              return tA;
            }();
            r.BinaryExpression = l;
            var B = /* @__PURE__ */ function() {
              function tA(nA) {
                this.type = n.Syntax.BlockStatement, this.body = nA;
              }
              return tA;
            }();
            r.BlockStatement = B;
            var h = /* @__PURE__ */ function() {
              function tA(nA) {
                this.type = n.Syntax.BreakStatement, this.label = nA;
              }
              return tA;
            }();
            r.BreakStatement = h;
            var Q = /* @__PURE__ */ function() {
              function tA(nA, DA) {
                this.type = n.Syntax.CallExpression, this.callee = nA, this.arguments = DA;
              }
              return tA;
            }();
            r.CallExpression = Q;
            var f = /* @__PURE__ */ function() {
              function tA(nA, DA) {
                this.type = n.Syntax.CatchClause, this.param = nA, this.body = DA;
              }
              return tA;
            }();
            r.CatchClause = f;
            var p = /* @__PURE__ */ function() {
              function tA(nA) {
                this.type = n.Syntax.ClassBody, this.body = nA;
              }
              return tA;
            }();
            r.ClassBody = p;
            var y = /* @__PURE__ */ function() {
              function tA(nA, DA, D) {
                this.type = n.Syntax.ClassDeclaration, this.id = nA, this.superClass = DA, this.body = D;
              }
              return tA;
            }();
            r.ClassDeclaration = y;
            var m = /* @__PURE__ */ function() {
              function tA(nA, DA, D) {
                this.type = n.Syntax.ClassExpression, this.id = nA, this.superClass = DA, this.body = D;
              }
              return tA;
            }();
            r.ClassExpression = m;
            var S = /* @__PURE__ */ function() {
              function tA(nA, DA) {
                this.type = n.Syntax.MemberExpression, this.computed = !0, this.object = nA, this.property = DA;
              }
              return tA;
            }();
            r.ComputedMemberExpression = S;
            var w = /* @__PURE__ */ function() {
              function tA(nA, DA, D) {
                this.type = n.Syntax.ConditionalExpression, this.test = nA, this.consequent = DA, this.alternate = D;
              }
              return tA;
            }();
            r.ConditionalExpression = w;
            var F = /* @__PURE__ */ function() {
              function tA(nA) {
                this.type = n.Syntax.ContinueStatement, this.label = nA;
              }
              return tA;
            }();
            r.ContinueStatement = F;
            var b = /* @__PURE__ */ function() {
              function tA() {
                this.type = n.Syntax.DebuggerStatement;
              }
              return tA;
            }();
            r.DebuggerStatement = b;
            var G = /* @__PURE__ */ function() {
              function tA(nA, DA) {
                this.type = n.Syntax.ExpressionStatement, this.expression = nA, this.directive = DA;
              }
              return tA;
            }();
            r.Directive = G;
            var T = /* @__PURE__ */ function() {
              function tA(nA, DA) {
                this.type = n.Syntax.DoWhileStatement, this.body = nA, this.test = DA;
              }
              return tA;
            }();
            r.DoWhileStatement = T;
            var K = /* @__PURE__ */ function() {
              function tA() {
                this.type = n.Syntax.EmptyStatement;
              }
              return tA;
            }();
            r.EmptyStatement = K;
            var H = /* @__PURE__ */ function() {
              function tA(nA) {
                this.type = n.Syntax.ExportAllDeclaration, this.source = nA;
              }
              return tA;
            }();
            r.ExportAllDeclaration = H;
            var j = /* @__PURE__ */ function() {
              function tA(nA) {
                this.type = n.Syntax.ExportDefaultDeclaration, this.declaration = nA;
              }
              return tA;
            }();
            r.ExportDefaultDeclaration = j;
            var eA = /* @__PURE__ */ function() {
              function tA(nA, DA, D) {
                this.type = n.Syntax.ExportNamedDeclaration, this.declaration = nA, this.specifiers = DA, this.source = D;
              }
              return tA;
            }();
            r.ExportNamedDeclaration = eA;
            var sA = /* @__PURE__ */ function() {
              function tA(nA, DA) {
                this.type = n.Syntax.ExportSpecifier, this.exported = DA, this.local = nA;
              }
              return tA;
            }();
            r.ExportSpecifier = sA;
            var uA = /* @__PURE__ */ function() {
              function tA(nA) {
                this.type = n.Syntax.ExpressionStatement, this.expression = nA;
              }
              return tA;
            }();
            r.ExpressionStatement = uA;
            var rA = /* @__PURE__ */ function() {
              function tA(nA, DA, D) {
                this.type = n.Syntax.ForInStatement, this.left = nA, this.right = DA, this.body = D, this.each = !1;
              }
              return tA;
            }();
            r.ForInStatement = rA;
            var hA = /* @__PURE__ */ function() {
              function tA(nA, DA, D) {
                this.type = n.Syntax.ForOfStatement, this.left = nA, this.right = DA, this.body = D;
              }
              return tA;
            }();
            r.ForOfStatement = hA;
            var UA = /* @__PURE__ */ function() {
              function tA(nA, DA, D, M) {
                this.type = n.Syntax.ForStatement, this.init = nA, this.test = DA, this.update = D, this.body = M;
              }
              return tA;
            }();
            r.ForStatement = UA;
            var iA = /* @__PURE__ */ function() {
              function tA(nA, DA, D, M) {
                this.type = n.Syntax.FunctionDeclaration, this.id = nA, this.params = DA, this.body = D, this.generator = M, this.expression = !1, this.async = !1;
              }
              return tA;
            }();
            r.FunctionDeclaration = iA;
            var wA = /* @__PURE__ */ function() {
              function tA(nA, DA, D, M) {
                this.type = n.Syntax.FunctionExpression, this.id = nA, this.params = DA, this.body = D, this.generator = M, this.expression = !1, this.async = !1;
              }
              return tA;
            }();
            r.FunctionExpression = wA;
            var Re = /* @__PURE__ */ function() {
              function tA(nA) {
                this.type = n.Syntax.Identifier, this.name = nA;
              }
              return tA;
            }();
            r.Identifier = Re;
            var zA = /* @__PURE__ */ function() {
              function tA(nA, DA, D) {
                this.type = n.Syntax.IfStatement, this.test = nA, this.consequent = DA, this.alternate = D;
              }
              return tA;
            }();
            r.IfStatement = zA;
            var U = /* @__PURE__ */ function() {
              function tA(nA, DA) {
                this.type = n.Syntax.ImportDeclaration, this.specifiers = nA, this.source = DA;
              }
              return tA;
            }();
            r.ImportDeclaration = U;
            var N = /* @__PURE__ */ function() {
              function tA(nA) {
                this.type = n.Syntax.ImportDefaultSpecifier, this.local = nA;
              }
              return tA;
            }();
            r.ImportDefaultSpecifier = N;
            var CA = /* @__PURE__ */ function() {
              function tA(nA) {
                this.type = n.Syntax.ImportNamespaceSpecifier, this.local = nA;
              }
              return tA;
            }();
            r.ImportNamespaceSpecifier = CA;
            var P = /* @__PURE__ */ function() {
              function tA(nA, DA) {
                this.type = n.Syntax.ImportSpecifier, this.local = nA, this.imported = DA;
              }
              return tA;
            }();
            r.ImportSpecifier = P;
            var XA = /* @__PURE__ */ function() {
              function tA(nA, DA) {
                this.type = n.Syntax.LabeledStatement, this.label = nA, this.body = DA;
              }
              return tA;
            }();
            r.LabeledStatement = XA;
            var ue = /* @__PURE__ */ function() {
              function tA(nA, DA) {
                this.type = n.Syntax.Literal, this.value = nA, this.raw = DA;
              }
              return tA;
            }();
            r.Literal = ue;
            var Y = /* @__PURE__ */ function() {
              function tA(nA, DA) {
                this.type = n.Syntax.MetaProperty, this.meta = nA, this.property = DA;
              }
              return tA;
            }();
            r.MetaProperty = Y;
            var L = /* @__PURE__ */ function() {
              function tA(nA, DA, D, M, v) {
                this.type = n.Syntax.MethodDefinition, this.key = nA, this.computed = DA, this.value = D, this.kind = M, this.static = v;
              }
              return tA;
            }();
            r.MethodDefinition = L;
            var V = /* @__PURE__ */ function() {
              function tA(nA) {
                this.type = n.Syntax.Program, this.body = nA, this.sourceType = "module";
              }
              return tA;
            }();
            r.Module = V;
            var Z = /* @__PURE__ */ function() {
              function tA(nA, DA) {
                this.type = n.Syntax.NewExpression, this.callee = nA, this.arguments = DA;
              }
              return tA;
            }();
            r.NewExpression = Z;
            var cA = /* @__PURE__ */ function() {
              function tA(nA) {
                this.type = n.Syntax.ObjectExpression, this.properties = nA;
              }
              return tA;
            }();
            r.ObjectExpression = cA;
            var X = /* @__PURE__ */ function() {
              function tA(nA) {
                this.type = n.Syntax.ObjectPattern, this.properties = nA;
              }
              return tA;
            }();
            r.ObjectPattern = X;
            var z = /* @__PURE__ */ function() {
              function tA(nA, DA, D, M, v, _) {
                this.type = n.Syntax.Property, this.key = DA, this.computed = D, this.value = M, this.kind = nA, this.method = v, this.shorthand = _;
              }
              return tA;
            }();
            r.Property = z;
            var SA = /* @__PURE__ */ function() {
              function tA(nA, DA, D, M) {
                this.type = n.Syntax.Literal, this.value = nA, this.raw = DA, this.regex = { pattern: D, flags: M };
              }
              return tA;
            }();
            r.RegexLiteral = SA;
            var aA = /* @__PURE__ */ function() {
              function tA(nA) {
                this.type = n.Syntax.RestElement, this.argument = nA;
              }
              return tA;
            }();
            r.RestElement = aA;
            var Ae = /* @__PURE__ */ function() {
              function tA(nA) {
                this.type = n.Syntax.ReturnStatement, this.argument = nA;
              }
              return tA;
            }();
            r.ReturnStatement = Ae;
            var vA = /* @__PURE__ */ function() {
              function tA(nA) {
                this.type = n.Syntax.Program, this.body = nA, this.sourceType = "script";
              }
              return tA;
            }();
            r.Script = vA;
            var RA = /* @__PURE__ */ function() {
              function tA(nA) {
                this.type = n.Syntax.SequenceExpression, this.expressions = nA;
              }
              return tA;
            }();
            r.SequenceExpression = RA;
            var MA = /* @__PURE__ */ function() {
              function tA(nA) {
                this.type = n.Syntax.SpreadElement, this.argument = nA;
              }
              return tA;
            }();
            r.SpreadElement = MA;
            var BA = /* @__PURE__ */ function() {
              function tA(nA, DA) {
                this.type = n.Syntax.MemberExpression, this.computed = !1, this.object = nA, this.property = DA;
              }
              return tA;
            }();
            r.StaticMemberExpression = BA;
            var pA = /* @__PURE__ */ function() {
              function tA() {
                this.type = n.Syntax.Super;
              }
              return tA;
            }();
            r.Super = pA;
            var EA = /* @__PURE__ */ function() {
              function tA(nA, DA) {
                this.type = n.Syntax.SwitchCase, this.test = nA, this.consequent = DA;
              }
              return tA;
            }();
            r.SwitchCase = EA;
            var _A = /* @__PURE__ */ function() {
              function tA(nA, DA) {
                this.type = n.Syntax.SwitchStatement, this.discriminant = nA, this.cases = DA;
              }
              return tA;
            }();
            r.SwitchStatement = _A;
            var oe = /* @__PURE__ */ function() {
              function tA(nA, DA) {
                this.type = n.Syntax.TaggedTemplateExpression, this.tag = nA, this.quasi = DA;
              }
              return tA;
            }();
            r.TaggedTemplateExpression = oe;
            var q = /* @__PURE__ */ function() {
              function tA(nA, DA) {
                this.type = n.Syntax.TemplateElement, this.value = nA, this.tail = DA;
              }
              return tA;
            }();
            r.TemplateElement = q;
            var AA = /* @__PURE__ */ function() {
              function tA(nA, DA) {
                this.type = n.Syntax.TemplateLiteral, this.quasis = nA, this.expressions = DA;
              }
              return tA;
            }();
            r.TemplateLiteral = AA;
            var gA = /* @__PURE__ */ function() {
              function tA() {
                this.type = n.Syntax.ThisExpression;
              }
              return tA;
            }();
            r.ThisExpression = gA;
            var fA = /* @__PURE__ */ function() {
              function tA(nA) {
                this.type = n.Syntax.ThrowStatement, this.argument = nA;
              }
              return tA;
            }();
            r.ThrowStatement = fA;
            var LA = /* @__PURE__ */ function() {
              function tA(nA, DA, D) {
                this.type = n.Syntax.TryStatement, this.block = nA, this.handler = DA, this.finalizer = D;
              }
              return tA;
            }();
            r.TryStatement = LA;
            var YA = /* @__PURE__ */ function() {
              function tA(nA, DA) {
                this.type = n.Syntax.UnaryExpression, this.operator = nA, this.argument = DA, this.prefix = !0;
              }
              return tA;
            }();
            r.UnaryExpression = YA;
            var le = /* @__PURE__ */ function() {
              function tA(nA, DA, D) {
                this.type = n.Syntax.UpdateExpression, this.operator = nA, this.argument = DA, this.prefix = D;
              }
              return tA;
            }();
            r.UpdateExpression = le;
            var Oe = /* @__PURE__ */ function() {
              function tA(nA, DA) {
                this.type = n.Syntax.VariableDeclaration, this.declarations = nA, this.kind = DA;
              }
              return tA;
            }();
            r.VariableDeclaration = Oe;
            var Qe = /* @__PURE__ */ function() {
              function tA(nA, DA) {
                this.type = n.Syntax.VariableDeclarator, this.id = nA, this.init = DA;
              }
              return tA;
            }();
            r.VariableDeclarator = Qe;
            var we = /* @__PURE__ */ function() {
              function tA(nA, DA) {
                this.type = n.Syntax.WhileStatement, this.test = nA, this.body = DA;
              }
              return tA;
            }();
            r.WhileStatement = we;
            var nt = /* @__PURE__ */ function() {
              function tA(nA, DA) {
                this.type = n.Syntax.WithStatement, this.object = nA, this.body = DA;
              }
              return tA;
            }();
            r.WithStatement = nt;
            var bn = /* @__PURE__ */ function() {
              function tA(nA, DA) {
                this.type = n.Syntax.YieldExpression, this.argument = nA, this.delegate = DA;
              }
              return tA;
            }();
            r.YieldExpression = bn;
          },
          /* 8 */
          /***/
          function(e, r, i) {
            Object.defineProperty(r, "__esModule", { value: !0 });
            var n = i(9), s = i(10), a = i(11), g = i(7), o = i(12), u = i(2), I = i(13), c = "ArrowParameterPlaceHolder", C = function() {
              function E(l, B, h) {
                B === void 0 && (B = {}), this.config = {
                  range: typeof B.range == "boolean" && B.range,
                  loc: typeof B.loc == "boolean" && B.loc,
                  source: null,
                  tokens: typeof B.tokens == "boolean" && B.tokens,
                  comment: typeof B.comment == "boolean" && B.comment,
                  tolerant: typeof B.tolerant == "boolean" && B.tolerant
                }, this.config.loc && B.source && B.source !== null && (this.config.source = String(B.source)), this.delegate = h, this.errorHandler = new s.ErrorHandler(), this.errorHandler.tolerant = this.config.tolerant, this.scanner = new o.Scanner(l, this.errorHandler), this.scanner.trackComment = this.config.comment, this.operatorPrecedence = {
                  ")": 0,
                  ";": 0,
                  ",": 0,
                  "=": 0,
                  "]": 0,
                  "||": 1,
                  "&&": 2,
                  "|": 3,
                  "^": 4,
                  "&": 5,
                  "==": 6,
                  "!=": 6,
                  "===": 6,
                  "!==": 6,
                  "<": 7,
                  ">": 7,
                  "<=": 7,
                  ">=": 7,
                  "<<": 8,
                  ">>": 8,
                  ">>>": 8,
                  "+": 9,
                  "-": 9,
                  "*": 11,
                  "/": 11,
                  "%": 11
                }, this.lookahead = {
                  type: 2,
                  value: "",
                  lineNumber: this.scanner.lineNumber,
                  lineStart: 0,
                  start: 0,
                  end: 0
                }, this.hasLineTerminator = !1, this.context = {
                  isModule: !1,
                  await: !1,
                  allowIn: !0,
                  allowStrictDirective: !0,
                  allowYield: !0,
                  firstCoverInitializedNameError: null,
                  isAssignmentTarget: !1,
                  isBindingElement: !1,
                  inFunctionBody: !1,
                  inIteration: !1,
                  inSwitch: !1,
                  labelSet: {},
                  strict: !1
                }, this.tokens = [], this.startMarker = {
                  index: 0,
                  line: this.scanner.lineNumber,
                  column: 0
                }, this.lastMarker = {
                  index: 0,
                  line: this.scanner.lineNumber,
                  column: 0
                }, this.nextToken(), this.lastMarker = {
                  index: this.scanner.index,
                  line: this.scanner.lineNumber,
                  column: this.scanner.index - this.scanner.lineStart
                };
              }
              return E.prototype.throwError = function(l) {
                var B = Array.prototype.slice.call(arguments, 1), h = l.replace(/%(\d)/g, function(y, m) {
                  return n.assert(m < B.length, "Message reference must be in range"), B[m];
                }), Q = this.lastMarker.index, f = this.lastMarker.line, p = this.lastMarker.column + 1;
                throw this.errorHandler.createError(Q, f, p, h);
              }, E.prototype.tolerateError = function(l) {
                var B = Array.prototype.slice.call(arguments, 1), h = l.replace(/%(\d)/g, function(y, m) {
                  return n.assert(m < B.length, "Message reference must be in range"), B[m];
                }), Q = this.lastMarker.index, f = this.scanner.lineNumber, p = this.lastMarker.column + 1;
                this.errorHandler.tolerateError(Q, f, p, h);
              }, E.prototype.unexpectedTokenError = function(l, B) {
                var h = B || a.Messages.UnexpectedToken, Q;
                if (l ? (B || (h = l.type === 2 ? a.Messages.UnexpectedEOS : l.type === 3 ? a.Messages.UnexpectedIdentifier : l.type === 6 ? a.Messages.UnexpectedNumber : l.type === 8 ? a.Messages.UnexpectedString : l.type === 10 ? a.Messages.UnexpectedTemplate : a.Messages.UnexpectedToken, l.type === 4 && (this.scanner.isFutureReservedWord(l.value) ? h = a.Messages.UnexpectedReserved : this.context.strict && this.scanner.isStrictModeReservedWord(l.value) && (h = a.Messages.StrictReservedWord))), Q = l.value) : Q = "ILLEGAL", h = h.replace("%0", Q), l && typeof l.lineNumber == "number") {
                  var f = l.start, p = l.lineNumber, y = this.lastMarker.index - this.lastMarker.column, m = l.start - y + 1;
                  return this.errorHandler.createError(f, p, m, h);
                } else {
                  var f = this.lastMarker.index, p = this.lastMarker.line, m = this.lastMarker.column + 1;
                  return this.errorHandler.createError(f, p, m, h);
                }
              }, E.prototype.throwUnexpectedToken = function(l, B) {
                throw this.unexpectedTokenError(l, B);
              }, E.prototype.tolerateUnexpectedToken = function(l, B) {
                this.errorHandler.tolerate(this.unexpectedTokenError(l, B));
              }, E.prototype.collectComments = function() {
                if (!this.config.comment)
                  this.scanner.scanComments();
                else {
                  var l = this.scanner.scanComments();
                  if (l.length > 0 && this.delegate)
                    for (var B = 0; B < l.length; ++B) {
                      var h = l[B], Q = void 0;
                      Q = {
                        type: h.multiLine ? "BlockComment" : "LineComment",
                        value: this.scanner.source.slice(h.slice[0], h.slice[1])
                      }, this.config.range && (Q.range = h.range), this.config.loc && (Q.loc = h.loc);
                      var f = {
                        start: {
                          line: h.loc.start.line,
                          column: h.loc.start.column,
                          offset: h.range[0]
                        },
                        end: {
                          line: h.loc.end.line,
                          column: h.loc.end.column,
                          offset: h.range[1]
                        }
                      };
                      this.delegate(Q, f);
                    }
                }
              }, E.prototype.getTokenRaw = function(l) {
                return this.scanner.source.slice(l.start, l.end);
              }, E.prototype.convertToken = function(l) {
                var B = {
                  type: I.TokenName[l.type],
                  value: this.getTokenRaw(l)
                };
                if (this.config.range && (B.range = [l.start, l.end]), this.config.loc && (B.loc = {
                  start: {
                    line: this.startMarker.line,
                    column: this.startMarker.column
                  },
                  end: {
                    line: this.scanner.lineNumber,
                    column: this.scanner.index - this.scanner.lineStart
                  }
                }), l.type === 9) {
                  var h = l.pattern, Q = l.flags;
                  B.regex = { pattern: h, flags: Q };
                }
                return B;
              }, E.prototype.nextToken = function() {
                var l = this.lookahead;
                this.lastMarker.index = this.scanner.index, this.lastMarker.line = this.scanner.lineNumber, this.lastMarker.column = this.scanner.index - this.scanner.lineStart, this.collectComments(), this.scanner.index !== this.startMarker.index && (this.startMarker.index = this.scanner.index, this.startMarker.line = this.scanner.lineNumber, this.startMarker.column = this.scanner.index - this.scanner.lineStart);
                var B = this.scanner.lex();
                return this.hasLineTerminator = l.lineNumber !== B.lineNumber, B && this.context.strict && B.type === 3 && this.scanner.isStrictModeReservedWord(B.value) && (B.type = 4), this.lookahead = B, this.config.tokens && B.type !== 2 && this.tokens.push(this.convertToken(B)), l;
              }, E.prototype.nextRegexToken = function() {
                this.collectComments();
                var l = this.scanner.scanRegExp();
                return this.config.tokens && (this.tokens.pop(), this.tokens.push(this.convertToken(l))), this.lookahead = l, this.nextToken(), l;
              }, E.prototype.createNode = function() {
                return {
                  index: this.startMarker.index,
                  line: this.startMarker.line,
                  column: this.startMarker.column
                };
              }, E.prototype.startNode = function(l, B) {
                B === void 0 && (B = 0);
                var h = l.start - l.lineStart, Q = l.lineNumber;
                return h < 0 && (h += B, Q--), {
                  index: l.start,
                  line: Q,
                  column: h
                };
              }, E.prototype.finalize = function(l, B) {
                if (this.config.range && (B.range = [l.index, this.lastMarker.index]), this.config.loc && (B.loc = {
                  start: {
                    line: l.line,
                    column: l.column
                  },
                  end: {
                    line: this.lastMarker.line,
                    column: this.lastMarker.column
                  }
                }, this.config.source && (B.loc.source = this.config.source)), this.delegate) {
                  var h = {
                    start: {
                      line: l.line,
                      column: l.column,
                      offset: l.index
                    },
                    end: {
                      line: this.lastMarker.line,
                      column: this.lastMarker.column,
                      offset: this.lastMarker.index
                    }
                  };
                  this.delegate(B, h);
                }
                return B;
              }, E.prototype.expect = function(l) {
                var B = this.nextToken();
                (B.type !== 7 || B.value !== l) && this.throwUnexpectedToken(B);
              }, E.prototype.expectCommaSeparator = function() {
                if (this.config.tolerant) {
                  var l = this.lookahead;
                  l.type === 7 && l.value === "," ? this.nextToken() : l.type === 7 && l.value === ";" ? (this.nextToken(), this.tolerateUnexpectedToken(l)) : this.tolerateUnexpectedToken(l, a.Messages.UnexpectedToken);
                } else
                  this.expect(",");
              }, E.prototype.expectKeyword = function(l) {
                var B = this.nextToken();
                (B.type !== 4 || B.value !== l) && this.throwUnexpectedToken(B);
              }, E.prototype.match = function(l) {
                return this.lookahead.type === 7 && this.lookahead.value === l;
              }, E.prototype.matchKeyword = function(l) {
                return this.lookahead.type === 4 && this.lookahead.value === l;
              }, E.prototype.matchContextualKeyword = function(l) {
                return this.lookahead.type === 3 && this.lookahead.value === l;
              }, E.prototype.matchAssign = function() {
                if (this.lookahead.type !== 7)
                  return !1;
                var l = this.lookahead.value;
                return l === "=" || l === "*=" || l === "**=" || l === "/=" || l === "%=" || l === "+=" || l === "-=" || l === "<<=" || l === ">>=" || l === ">>>=" || l === "&=" || l === "^=" || l === "|=";
              }, E.prototype.isolateCoverGrammar = function(l) {
                var B = this.context.isBindingElement, h = this.context.isAssignmentTarget, Q = this.context.firstCoverInitializedNameError;
                this.context.isBindingElement = !0, this.context.isAssignmentTarget = !0, this.context.firstCoverInitializedNameError = null;
                var f = l.call(this);
                return this.context.firstCoverInitializedNameError !== null && this.throwUnexpectedToken(this.context.firstCoverInitializedNameError), this.context.isBindingElement = B, this.context.isAssignmentTarget = h, this.context.firstCoverInitializedNameError = Q, f;
              }, E.prototype.inheritCoverGrammar = function(l) {
                var B = this.context.isBindingElement, h = this.context.isAssignmentTarget, Q = this.context.firstCoverInitializedNameError;
                this.context.isBindingElement = !0, this.context.isAssignmentTarget = !0, this.context.firstCoverInitializedNameError = null;
                var f = l.call(this);
                return this.context.isBindingElement = this.context.isBindingElement && B, this.context.isAssignmentTarget = this.context.isAssignmentTarget && h, this.context.firstCoverInitializedNameError = Q || this.context.firstCoverInitializedNameError, f;
              }, E.prototype.consumeSemicolon = function() {
                this.match(";") ? this.nextToken() : this.hasLineTerminator || (this.lookahead.type !== 2 && !this.match("}") && this.throwUnexpectedToken(this.lookahead), this.lastMarker.index = this.startMarker.index, this.lastMarker.line = this.startMarker.line, this.lastMarker.column = this.startMarker.column);
              }, E.prototype.parsePrimaryExpression = function() {
                var l = this.createNode(), B, h, Q;
                switch (this.lookahead.type) {
                  case 3:
                    (this.context.isModule || this.context.await) && this.lookahead.value === "await" && this.tolerateUnexpectedToken(this.lookahead), B = this.matchAsyncFunction() ? this.parseFunctionExpression() : this.finalize(l, new g.Identifier(this.nextToken().value));
                    break;
                  case 6:
                  case 8:
                    this.context.strict && this.lookahead.octal && this.tolerateUnexpectedToken(this.lookahead, a.Messages.StrictOctalLiteral), this.context.isAssignmentTarget = !1, this.context.isBindingElement = !1, h = this.nextToken(), Q = this.getTokenRaw(h), B = this.finalize(l, new g.Literal(h.value, Q));
                    break;
                  case 1:
                    this.context.isAssignmentTarget = !1, this.context.isBindingElement = !1, h = this.nextToken(), Q = this.getTokenRaw(h), B = this.finalize(l, new g.Literal(h.value === "true", Q));
                    break;
                  case 5:
                    this.context.isAssignmentTarget = !1, this.context.isBindingElement = !1, h = this.nextToken(), Q = this.getTokenRaw(h), B = this.finalize(l, new g.Literal(null, Q));
                    break;
                  case 10:
                    B = this.parseTemplateLiteral();
                    break;
                  case 7:
                    switch (this.lookahead.value) {
                      case "(":
                        this.context.isBindingElement = !1, B = this.inheritCoverGrammar(this.parseGroupExpression);
                        break;
                      case "[":
                        B = this.inheritCoverGrammar(this.parseArrayInitializer);
                        break;
                      case "{":
                        B = this.inheritCoverGrammar(this.parseObjectInitializer);
                        break;
                      case "/":
                      case "/=":
                        this.context.isAssignmentTarget = !1, this.context.isBindingElement = !1, this.scanner.index = this.startMarker.index, h = this.nextRegexToken(), Q = this.getTokenRaw(h), B = this.finalize(l, new g.RegexLiteral(h.regex, Q, h.pattern, h.flags));
                        break;
                      default:
                        B = this.throwUnexpectedToken(this.nextToken());
                    }
                    break;
                  case 4:
                    !this.context.strict && this.context.allowYield && this.matchKeyword("yield") ? B = this.parseIdentifierName() : !this.context.strict && this.matchKeyword("let") ? B = this.finalize(l, new g.Identifier(this.nextToken().value)) : (this.context.isAssignmentTarget = !1, this.context.isBindingElement = !1, this.matchKeyword("function") ? B = this.parseFunctionExpression() : this.matchKeyword("this") ? (this.nextToken(), B = this.finalize(l, new g.ThisExpression())) : this.matchKeyword("class") ? B = this.parseClassExpression() : B = this.throwUnexpectedToken(this.nextToken()));
                    break;
                  default:
                    B = this.throwUnexpectedToken(this.nextToken());
                }
                return B;
              }, E.prototype.parseSpreadElement = function() {
                var l = this.createNode();
                this.expect("...");
                var B = this.inheritCoverGrammar(this.parseAssignmentExpression);
                return this.finalize(l, new g.SpreadElement(B));
              }, E.prototype.parseArrayInitializer = function() {
                var l = this.createNode(), B = [];
                for (this.expect("["); !this.match("]"); )
                  if (this.match(","))
                    this.nextToken(), B.push(null);
                  else if (this.match("...")) {
                    var h = this.parseSpreadElement();
                    this.match("]") || (this.context.isAssignmentTarget = !1, this.context.isBindingElement = !1, this.expect(",")), B.push(h);
                  } else
                    B.push(this.inheritCoverGrammar(this.parseAssignmentExpression)), this.match("]") || this.expect(",");
                return this.expect("]"), this.finalize(l, new g.ArrayExpression(B));
              }, E.prototype.parsePropertyMethod = function(l) {
                this.context.isAssignmentTarget = !1, this.context.isBindingElement = !1;
                var B = this.context.strict, h = this.context.allowStrictDirective;
                this.context.allowStrictDirective = l.simple;
                var Q = this.isolateCoverGrammar(this.parseFunctionSourceElements);
                return this.context.strict && l.firstRestricted && this.tolerateUnexpectedToken(l.firstRestricted, l.message), this.context.strict && l.stricted && this.tolerateUnexpectedToken(l.stricted, l.message), this.context.strict = B, this.context.allowStrictDirective = h, Q;
              }, E.prototype.parsePropertyMethodFunction = function() {
                var l = !1, B = this.createNode(), h = this.context.allowYield;
                this.context.allowYield = !0;
                var Q = this.parseFormalParameters(), f = this.parsePropertyMethod(Q);
                return this.context.allowYield = h, this.finalize(B, new g.FunctionExpression(null, Q.params, f, l));
              }, E.prototype.parsePropertyMethodAsyncFunction = function() {
                var l = this.createNode(), B = this.context.allowYield, h = this.context.await;
                this.context.allowYield = !1, this.context.await = !0;
                var Q = this.parseFormalParameters(), f = this.parsePropertyMethod(Q);
                return this.context.allowYield = B, this.context.await = h, this.finalize(l, new g.AsyncFunctionExpression(null, Q.params, f));
              }, E.prototype.parseObjectPropertyKey = function() {
                var l = this.createNode(), B = this.nextToken(), h;
                switch (B.type) {
                  case 8:
                  case 6:
                    this.context.strict && B.octal && this.tolerateUnexpectedToken(B, a.Messages.StrictOctalLiteral);
                    var Q = this.getTokenRaw(B);
                    h = this.finalize(l, new g.Literal(B.value, Q));
                    break;
                  case 3:
                  case 1:
                  case 5:
                  case 4:
                    h = this.finalize(l, new g.Identifier(B.value));
                    break;
                  case 7:
                    B.value === "[" ? (h = this.isolateCoverGrammar(this.parseAssignmentExpression), this.expect("]")) : h = this.throwUnexpectedToken(B);
                    break;
                  default:
                    h = this.throwUnexpectedToken(B);
                }
                return h;
              }, E.prototype.isPropertyKey = function(l, B) {
                return l.type === u.Syntax.Identifier && l.name === B || l.type === u.Syntax.Literal && l.value === B;
              }, E.prototype.parseObjectProperty = function(l) {
                var B = this.createNode(), h = this.lookahead, Q, f = null, p = null, y = !1, m = !1, S = !1, w = !1;
                if (h.type === 3) {
                  var F = h.value;
                  this.nextToken(), y = this.match("["), w = !this.hasLineTerminator && F === "async" && !this.match(":") && !this.match("(") && !this.match("*") && !this.match(","), f = w ? this.parseObjectPropertyKey() : this.finalize(B, new g.Identifier(F));
                } else this.match("*") ? this.nextToken() : (y = this.match("["), f = this.parseObjectPropertyKey());
                var b = this.qualifiedPropertyName(this.lookahead);
                if (h.type === 3 && !w && h.value === "get" && b)
                  Q = "get", y = this.match("["), f = this.parseObjectPropertyKey(), this.context.allowYield = !1, p = this.parseGetterMethod();
                else if (h.type === 3 && !w && h.value === "set" && b)
                  Q = "set", y = this.match("["), f = this.parseObjectPropertyKey(), p = this.parseSetterMethod();
                else if (h.type === 7 && h.value === "*" && b)
                  Q = "init", y = this.match("["), f = this.parseObjectPropertyKey(), p = this.parseGeneratorMethod(), m = !0;
                else if (f || this.throwUnexpectedToken(this.lookahead), Q = "init", this.match(":") && !w)
                  !y && this.isPropertyKey(f, "__proto__") && (l.value && this.tolerateError(a.Messages.DuplicateProtoProperty), l.value = !0), this.nextToken(), p = this.inheritCoverGrammar(this.parseAssignmentExpression);
                else if (this.match("("))
                  p = w ? this.parsePropertyMethodAsyncFunction() : this.parsePropertyMethodFunction(), m = !0;
                else if (h.type === 3) {
                  var F = this.finalize(B, new g.Identifier(h.value));
                  if (this.match("=")) {
                    this.context.firstCoverInitializedNameError = this.lookahead, this.nextToken(), S = !0;
                    var G = this.isolateCoverGrammar(this.parseAssignmentExpression);
                    p = this.finalize(B, new g.AssignmentPattern(F, G));
                  } else
                    S = !0, p = F;
                } else
                  this.throwUnexpectedToken(this.nextToken());
                return this.finalize(B, new g.Property(Q, f, y, p, m, S));
              }, E.prototype.parseObjectInitializer = function() {
                var l = this.createNode();
                this.expect("{");
                for (var B = [], h = { value: !1 }; !this.match("}"); )
                  B.push(this.parseObjectProperty(h)), this.match("}") || this.expectCommaSeparator();
                return this.expect("}"), this.finalize(l, new g.ObjectExpression(B));
              }, E.prototype.parseTemplateHead = function() {
                n.assert(this.lookahead.head, "Template literal must start with a template head");
                var l = this.createNode(), B = this.nextToken(), h = B.value, Q = B.cooked;
                return this.finalize(l, new g.TemplateElement({ raw: h, cooked: Q }, B.tail));
              }, E.prototype.parseTemplateElement = function() {
                this.lookahead.type !== 10 && this.throwUnexpectedToken();
                var l = this.createNode(), B = this.nextToken(), h = B.value, Q = B.cooked;
                return this.finalize(l, new g.TemplateElement({ raw: h, cooked: Q }, B.tail));
              }, E.prototype.parseTemplateLiteral = function() {
                var l = this.createNode(), B = [], h = [], Q = this.parseTemplateHead();
                for (h.push(Q); !Q.tail; )
                  B.push(this.parseExpression()), Q = this.parseTemplateElement(), h.push(Q);
                return this.finalize(l, new g.TemplateLiteral(h, B));
              }, E.prototype.reinterpretExpressionAsPattern = function(l) {
                switch (l.type) {
                  case u.Syntax.Identifier:
                  case u.Syntax.MemberExpression:
                  case u.Syntax.RestElement:
                  case u.Syntax.AssignmentPattern:
                    break;
                  case u.Syntax.SpreadElement:
                    l.type = u.Syntax.RestElement, this.reinterpretExpressionAsPattern(l.argument);
                    break;
                  case u.Syntax.ArrayExpression:
                    l.type = u.Syntax.ArrayPattern;
                    for (var B = 0; B < l.elements.length; B++)
                      l.elements[B] !== null && this.reinterpretExpressionAsPattern(l.elements[B]);
                    break;
                  case u.Syntax.ObjectExpression:
                    l.type = u.Syntax.ObjectPattern;
                    for (var B = 0; B < l.properties.length; B++)
                      this.reinterpretExpressionAsPattern(l.properties[B].value);
                    break;
                  case u.Syntax.AssignmentExpression:
                    l.type = u.Syntax.AssignmentPattern, delete l.operator, this.reinterpretExpressionAsPattern(l.left);
                    break;
                }
              }, E.prototype.parseGroupExpression = function() {
                var l;
                if (this.expect("("), this.match(")"))
                  this.nextToken(), this.match("=>") || this.expect("=>"), l = {
                    type: c,
                    params: [],
                    async: !1
                  };
                else {
                  var B = this.lookahead, h = [];
                  if (this.match("..."))
                    l = this.parseRestElement(h), this.expect(")"), this.match("=>") || this.expect("=>"), l = {
                      type: c,
                      params: [l],
                      async: !1
                    };
                  else {
                    var Q = !1;
                    if (this.context.isBindingElement = !0, l = this.inheritCoverGrammar(this.parseAssignmentExpression), this.match(",")) {
                      var f = [];
                      for (this.context.isAssignmentTarget = !1, f.push(l); this.lookahead.type !== 2 && this.match(","); ) {
                        if (this.nextToken(), this.match(")")) {
                          this.nextToken();
                          for (var p = 0; p < f.length; p++)
                            this.reinterpretExpressionAsPattern(f[p]);
                          Q = !0, l = {
                            type: c,
                            params: f,
                            async: !1
                          };
                        } else if (this.match("...")) {
                          this.context.isBindingElement || this.throwUnexpectedToken(this.lookahead), f.push(this.parseRestElement(h)), this.expect(")"), this.match("=>") || this.expect("=>"), this.context.isBindingElement = !1;
                          for (var p = 0; p < f.length; p++)
                            this.reinterpretExpressionAsPattern(f[p]);
                          Q = !0, l = {
                            type: c,
                            params: f,
                            async: !1
                          };
                        } else
                          f.push(this.inheritCoverGrammar(this.parseAssignmentExpression));
                        if (Q)
                          break;
                      }
                      Q || (l = this.finalize(this.startNode(B), new g.SequenceExpression(f)));
                    }
                    if (!Q) {
                      if (this.expect(")"), this.match("=>") && (l.type === u.Syntax.Identifier && l.name === "yield" && (Q = !0, l = {
                        type: c,
                        params: [l],
                        async: !1
                      }), !Q)) {
                        if (this.context.isBindingElement || this.throwUnexpectedToken(this.lookahead), l.type === u.Syntax.SequenceExpression)
                          for (var p = 0; p < l.expressions.length; p++)
                            this.reinterpretExpressionAsPattern(l.expressions[p]);
                        else
                          this.reinterpretExpressionAsPattern(l);
                        var y = l.type === u.Syntax.SequenceExpression ? l.expressions : [l];
                        l = {
                          type: c,
                          params: y,
                          async: !1
                        };
                      }
                      this.context.isBindingElement = !1;
                    }
                  }
                }
                return l;
              }, E.prototype.parseArguments = function() {
                this.expect("(");
                var l = [];
                if (!this.match(")"))
                  for (; ; ) {
                    var B = this.match("...") ? this.parseSpreadElement() : this.isolateCoverGrammar(this.parseAssignmentExpression);
                    if (l.push(B), this.match(")") || (this.expectCommaSeparator(), this.match(")")))
                      break;
                  }
                return this.expect(")"), l;
              }, E.prototype.isIdentifierName = function(l) {
                return l.type === 3 || l.type === 4 || l.type === 1 || l.type === 5;
              }, E.prototype.parseIdentifierName = function() {
                var l = this.createNode(), B = this.nextToken();
                return this.isIdentifierName(B) || this.throwUnexpectedToken(B), this.finalize(l, new g.Identifier(B.value));
              }, E.prototype.parseNewExpression = function() {
                var l = this.createNode(), B = this.parseIdentifierName();
                n.assert(B.name === "new", "New expression must start with `new`");
                var h;
                if (this.match("."))
                  if (this.nextToken(), this.lookahead.type === 3 && this.context.inFunctionBody && this.lookahead.value === "target") {
                    var Q = this.parseIdentifierName();
                    h = new g.MetaProperty(B, Q);
                  } else
                    this.throwUnexpectedToken(this.lookahead);
                else {
                  var f = this.isolateCoverGrammar(this.parseLeftHandSideExpression), p = this.match("(") ? this.parseArguments() : [];
                  h = new g.NewExpression(f, p), this.context.isAssignmentTarget = !1, this.context.isBindingElement = !1;
                }
                return this.finalize(l, h);
              }, E.prototype.parseAsyncArgument = function() {
                var l = this.parseAssignmentExpression();
                return this.context.firstCoverInitializedNameError = null, l;
              }, E.prototype.parseAsyncArguments = function() {
                this.expect("(");
                var l = [];
                if (!this.match(")"))
                  for (; ; ) {
                    var B = this.match("...") ? this.parseSpreadElement() : this.isolateCoverGrammar(this.parseAsyncArgument);
                    if (l.push(B), this.match(")") || (this.expectCommaSeparator(), this.match(")")))
                      break;
                  }
                return this.expect(")"), l;
              }, E.prototype.parseLeftHandSideExpressionAllowCall = function() {
                var l = this.lookahead, B = this.matchContextualKeyword("async"), h = this.context.allowIn;
                this.context.allowIn = !0;
                var Q;
                for (this.matchKeyword("super") && this.context.inFunctionBody ? (Q = this.createNode(), this.nextToken(), Q = this.finalize(Q, new g.Super()), !this.match("(") && !this.match(".") && !this.match("[") && this.throwUnexpectedToken(this.lookahead)) : Q = this.inheritCoverGrammar(this.matchKeyword("new") ? this.parseNewExpression : this.parsePrimaryExpression); ; )
                  if (this.match(".")) {
                    this.context.isBindingElement = !1, this.context.isAssignmentTarget = !0, this.expect(".");
                    var f = this.parseIdentifierName();
                    Q = this.finalize(this.startNode(l), new g.StaticMemberExpression(Q, f));
                  } else if (this.match("(")) {
                    var p = B && l.lineNumber === this.lookahead.lineNumber;
                    this.context.isBindingElement = !1, this.context.isAssignmentTarget = !1;
                    var y = p ? this.parseAsyncArguments() : this.parseArguments();
                    if (Q = this.finalize(this.startNode(l), new g.CallExpression(Q, y)), p && this.match("=>")) {
                      for (var m = 0; m < y.length; ++m)
                        this.reinterpretExpressionAsPattern(y[m]);
                      Q = {
                        type: c,
                        params: y,
                        async: !0
                      };
                    }
                  } else if (this.match("[")) {
                    this.context.isBindingElement = !1, this.context.isAssignmentTarget = !0, this.expect("[");
                    var f = this.isolateCoverGrammar(this.parseExpression);
                    this.expect("]"), Q = this.finalize(this.startNode(l), new g.ComputedMemberExpression(Q, f));
                  } else if (this.lookahead.type === 10 && this.lookahead.head) {
                    var S = this.parseTemplateLiteral();
                    Q = this.finalize(this.startNode(l), new g.TaggedTemplateExpression(Q, S));
                  } else
                    break;
                return this.context.allowIn = h, Q;
              }, E.prototype.parseSuper = function() {
                var l = this.createNode();
                return this.expectKeyword("super"), !this.match("[") && !this.match(".") && this.throwUnexpectedToken(this.lookahead), this.finalize(l, new g.Super());
              }, E.prototype.parseLeftHandSideExpression = function() {
                n.assert(this.context.allowIn, "callee of new expression always allow in keyword.");
                for (var l = this.startNode(this.lookahead), B = this.matchKeyword("super") && this.context.inFunctionBody ? this.parseSuper() : this.inheritCoverGrammar(this.matchKeyword("new") ? this.parseNewExpression : this.parsePrimaryExpression); ; )
                  if (this.match("[")) {
                    this.context.isBindingElement = !1, this.context.isAssignmentTarget = !0, this.expect("[");
                    var h = this.isolateCoverGrammar(this.parseExpression);
                    this.expect("]"), B = this.finalize(l, new g.ComputedMemberExpression(B, h));
                  } else if (this.match(".")) {
                    this.context.isBindingElement = !1, this.context.isAssignmentTarget = !0, this.expect(".");
                    var h = this.parseIdentifierName();
                    B = this.finalize(l, new g.StaticMemberExpression(B, h));
                  } else if (this.lookahead.type === 10 && this.lookahead.head) {
                    var Q = this.parseTemplateLiteral();
                    B = this.finalize(l, new g.TaggedTemplateExpression(B, Q));
                  } else
                    break;
                return B;
              }, E.prototype.parseUpdateExpression = function() {
                var l, B = this.lookahead;
                if (this.match("++") || this.match("--")) {
                  var h = this.startNode(B), Q = this.nextToken();
                  l = this.inheritCoverGrammar(this.parseUnaryExpression), this.context.strict && l.type === u.Syntax.Identifier && this.scanner.isRestrictedWord(l.name) && this.tolerateError(a.Messages.StrictLHSPrefix), this.context.isAssignmentTarget || this.tolerateError(a.Messages.InvalidLHSInAssignment);
                  var f = !0;
                  l = this.finalize(h, new g.UpdateExpression(Q.value, l, f)), this.context.isAssignmentTarget = !1, this.context.isBindingElement = !1;
                } else if (l = this.inheritCoverGrammar(this.parseLeftHandSideExpressionAllowCall), !this.hasLineTerminator && this.lookahead.type === 7 && (this.match("++") || this.match("--"))) {
                  this.context.strict && l.type === u.Syntax.Identifier && this.scanner.isRestrictedWord(l.name) && this.tolerateError(a.Messages.StrictLHSPostfix), this.context.isAssignmentTarget || this.tolerateError(a.Messages.InvalidLHSInAssignment), this.context.isAssignmentTarget = !1, this.context.isBindingElement = !1;
                  var p = this.nextToken().value, f = !1;
                  l = this.finalize(this.startNode(B), new g.UpdateExpression(p, l, f));
                }
                return l;
              }, E.prototype.parseAwaitExpression = function() {
                var l = this.createNode();
                this.nextToken();
                var B = this.parseUnaryExpression();
                return this.finalize(l, new g.AwaitExpression(B));
              }, E.prototype.parseUnaryExpression = function() {
                var l;
                if (this.match("+") || this.match("-") || this.match("~") || this.match("!") || this.matchKeyword("delete") || this.matchKeyword("void") || this.matchKeyword("typeof")) {
                  var B = this.startNode(this.lookahead), h = this.nextToken();
                  l = this.inheritCoverGrammar(this.parseUnaryExpression), l = this.finalize(B, new g.UnaryExpression(h.value, l)), this.context.strict && l.operator === "delete" && l.argument.type === u.Syntax.Identifier && this.tolerateError(a.Messages.StrictDelete), this.context.isAssignmentTarget = !1, this.context.isBindingElement = !1;
                } else this.context.await && this.matchContextualKeyword("await") ? l = this.parseAwaitExpression() : l = this.parseUpdateExpression();
                return l;
              }, E.prototype.parseExponentiationExpression = function() {
                var l = this.lookahead, B = this.inheritCoverGrammar(this.parseUnaryExpression);
                if (B.type !== u.Syntax.UnaryExpression && this.match("**")) {
                  this.nextToken(), this.context.isAssignmentTarget = !1, this.context.isBindingElement = !1;
                  var h = B, Q = this.isolateCoverGrammar(this.parseExponentiationExpression);
                  B = this.finalize(this.startNode(l), new g.BinaryExpression("**", h, Q));
                }
                return B;
              }, E.prototype.binaryPrecedence = function(l) {
                var B = l.value, h;
                return l.type === 7 ? h = this.operatorPrecedence[B] || 0 : l.type === 4 ? h = B === "instanceof" || this.context.allowIn && B === "in" ? 7 : 0 : h = 0, h;
              }, E.prototype.parseBinaryExpression = function() {
                var l = this.lookahead, B = this.inheritCoverGrammar(this.parseExponentiationExpression), h = this.lookahead, Q = this.binaryPrecedence(h);
                if (Q > 0) {
                  this.nextToken(), this.context.isAssignmentTarget = !1, this.context.isBindingElement = !1;
                  for (var f = [l, this.lookahead], p = B, y = this.isolateCoverGrammar(this.parseExponentiationExpression), m = [p, h.value, y], S = [Q]; Q = this.binaryPrecedence(this.lookahead), !(Q <= 0); ) {
                    for (; m.length > 2 && Q <= S[S.length - 1]; ) {
                      y = m.pop();
                      var w = m.pop();
                      S.pop(), p = m.pop(), f.pop();
                      var F = this.startNode(f[f.length - 1]);
                      m.push(this.finalize(F, new g.BinaryExpression(w, p, y)));
                    }
                    m.push(this.nextToken().value), S.push(Q), f.push(this.lookahead), m.push(this.isolateCoverGrammar(this.parseExponentiationExpression));
                  }
                  var b = m.length - 1;
                  B = m[b];
                  for (var G = f.pop(); b > 1; ) {
                    var T = f.pop(), K = G && G.lineStart, F = this.startNode(T, K), w = m[b - 1];
                    B = this.finalize(F, new g.BinaryExpression(w, m[b - 2], B)), b -= 2, G = T;
                  }
                }
                return B;
              }, E.prototype.parseConditionalExpression = function() {
                var l = this.lookahead, B = this.inheritCoverGrammar(this.parseBinaryExpression);
                if (this.match("?")) {
                  this.nextToken();
                  var h = this.context.allowIn;
                  this.context.allowIn = !0;
                  var Q = this.isolateCoverGrammar(this.parseAssignmentExpression);
                  this.context.allowIn = h, this.expect(":");
                  var f = this.isolateCoverGrammar(this.parseAssignmentExpression);
                  B = this.finalize(this.startNode(l), new g.ConditionalExpression(B, Q, f)), this.context.isAssignmentTarget = !1, this.context.isBindingElement = !1;
                }
                return B;
              }, E.prototype.checkPatternParam = function(l, B) {
                switch (B.type) {
                  case u.Syntax.Identifier:
                    this.validateParam(l, B, B.name);
                    break;
                  case u.Syntax.RestElement:
                    this.checkPatternParam(l, B.argument);
                    break;
                  case u.Syntax.AssignmentPattern:
                    this.checkPatternParam(l, B.left);
                    break;
                  case u.Syntax.ArrayPattern:
                    for (var h = 0; h < B.elements.length; h++)
                      B.elements[h] !== null && this.checkPatternParam(l, B.elements[h]);
                    break;
                  case u.Syntax.ObjectPattern:
                    for (var h = 0; h < B.properties.length; h++)
                      this.checkPatternParam(l, B.properties[h].value);
                    break;
                }
                l.simple = l.simple && B instanceof g.Identifier;
              }, E.prototype.reinterpretAsCoverFormalsList = function(l) {
                var B = [l], h, Q = !1;
                switch (l.type) {
                  case u.Syntax.Identifier:
                    break;
                  case c:
                    B = l.params, Q = l.async;
                    break;
                  default:
                    return null;
                }
                h = {
                  simple: !0,
                  paramSet: {}
                };
                for (var f = 0; f < B.length; ++f) {
                  var p = B[f];
                  p.type === u.Syntax.AssignmentPattern ? p.right.type === u.Syntax.YieldExpression && (p.right.argument && this.throwUnexpectedToken(this.lookahead), p.right.type = u.Syntax.Identifier, p.right.name = "yield", delete p.right.argument, delete p.right.delegate) : Q && p.type === u.Syntax.Identifier && p.name === "await" && this.throwUnexpectedToken(this.lookahead), this.checkPatternParam(h, p), B[f] = p;
                }
                if (this.context.strict || !this.context.allowYield)
                  for (var f = 0; f < B.length; ++f) {
                    var p = B[f];
                    p.type === u.Syntax.YieldExpression && this.throwUnexpectedToken(this.lookahead);
                  }
                if (h.message === a.Messages.StrictParamDupe) {
                  var y = this.context.strict ? h.stricted : h.firstRestricted;
                  this.throwUnexpectedToken(y, h.message);
                }
                return {
                  simple: h.simple,
                  params: B,
                  stricted: h.stricted,
                  firstRestricted: h.firstRestricted,
                  message: h.message
                };
              }, E.prototype.parseAssignmentExpression = function() {
                var l;
                if (!this.context.allowYield && this.matchKeyword("yield"))
                  l = this.parseYieldExpression();
                else {
                  var B = this.lookahead, h = B;
                  if (l = this.parseConditionalExpression(), h.type === 3 && h.lineNumber === this.lookahead.lineNumber && h.value === "async" && (this.lookahead.type === 3 || this.matchKeyword("yield"))) {
                    var Q = this.parsePrimaryExpression();
                    this.reinterpretExpressionAsPattern(Q), l = {
                      type: c,
                      params: [Q],
                      async: !0
                    };
                  }
                  if (l.type === c || this.match("=>")) {
                    this.context.isAssignmentTarget = !1, this.context.isBindingElement = !1;
                    var f = l.async, p = this.reinterpretAsCoverFormalsList(l);
                    if (p) {
                      this.hasLineTerminator && this.tolerateUnexpectedToken(this.lookahead), this.context.firstCoverInitializedNameError = null;
                      var y = this.context.strict, m = this.context.allowStrictDirective;
                      this.context.allowStrictDirective = p.simple;
                      var S = this.context.allowYield, w = this.context.await;
                      this.context.allowYield = !0, this.context.await = f;
                      var F = this.startNode(B);
                      this.expect("=>");
                      var b = void 0;
                      if (this.match("{")) {
                        var G = this.context.allowIn;
                        this.context.allowIn = !0, b = this.parseFunctionSourceElements(), this.context.allowIn = G;
                      } else
                        b = this.isolateCoverGrammar(this.parseAssignmentExpression);
                      var T = b.type !== u.Syntax.BlockStatement;
                      this.context.strict && p.firstRestricted && this.throwUnexpectedToken(p.firstRestricted, p.message), this.context.strict && p.stricted && this.tolerateUnexpectedToken(p.stricted, p.message), l = f ? this.finalize(F, new g.AsyncArrowFunctionExpression(p.params, b, T)) : this.finalize(F, new g.ArrowFunctionExpression(p.params, b, T)), this.context.strict = y, this.context.allowStrictDirective = m, this.context.allowYield = S, this.context.await = w;
                    }
                  } else if (this.matchAssign()) {
                    if (this.context.isAssignmentTarget || this.tolerateError(a.Messages.InvalidLHSInAssignment), this.context.strict && l.type === u.Syntax.Identifier) {
                      var K = l;
                      this.scanner.isRestrictedWord(K.name) && this.tolerateUnexpectedToken(h, a.Messages.StrictLHSAssignment), this.scanner.isStrictModeReservedWord(K.name) && this.tolerateUnexpectedToken(h, a.Messages.StrictReservedWord);
                    }
                    this.match("=") ? this.reinterpretExpressionAsPattern(l) : (this.context.isAssignmentTarget = !1, this.context.isBindingElement = !1), h = this.nextToken();
                    var H = h.value, j = this.isolateCoverGrammar(this.parseAssignmentExpression);
                    l = this.finalize(this.startNode(B), new g.AssignmentExpression(H, l, j)), this.context.firstCoverInitializedNameError = null;
                  }
                }
                return l;
              }, E.prototype.parseExpression = function() {
                var l = this.lookahead, B = this.isolateCoverGrammar(this.parseAssignmentExpression);
                if (this.match(",")) {
                  var h = [];
                  for (h.push(B); this.lookahead.type !== 2 && this.match(","); )
                    this.nextToken(), h.push(this.isolateCoverGrammar(this.parseAssignmentExpression));
                  B = this.finalize(this.startNode(l), new g.SequenceExpression(h));
                }
                return B;
              }, E.prototype.parseStatementListItem = function() {
                var l;
                if (this.context.isAssignmentTarget = !0, this.context.isBindingElement = !0, this.lookahead.type === 4)
                  switch (this.lookahead.value) {
                    case "export":
                      this.context.isModule || this.tolerateUnexpectedToken(this.lookahead, a.Messages.IllegalExportDeclaration), l = this.parseExportDeclaration();
                      break;
                    case "import":
                      this.context.isModule || this.tolerateUnexpectedToken(this.lookahead, a.Messages.IllegalImportDeclaration), l = this.parseImportDeclaration();
                      break;
                    case "const":
                      l = this.parseLexicalDeclaration({ inFor: !1 });
                      break;
                    case "function":
                      l = this.parseFunctionDeclaration();
                      break;
                    case "class":
                      l = this.parseClassDeclaration();
                      break;
                    case "let":
                      l = this.isLexicalDeclaration() ? this.parseLexicalDeclaration({ inFor: !1 }) : this.parseStatement();
                      break;
                    default:
                      l = this.parseStatement();
                      break;
                  }
                else
                  l = this.parseStatement();
                return l;
              }, E.prototype.parseBlock = function() {
                var l = this.createNode();
                this.expect("{");
                for (var B = []; !this.match("}"); )
                  B.push(this.parseStatementListItem());
                return this.expect("}"), this.finalize(l, new g.BlockStatement(B));
              }, E.prototype.parseLexicalBinding = function(l, B) {
                var h = this.createNode(), Q = [], f = this.parsePattern(Q, l);
                this.context.strict && f.type === u.Syntax.Identifier && this.scanner.isRestrictedWord(f.name) && this.tolerateError(a.Messages.StrictVarName);
                var p = null;
                return l === "const" ? !this.matchKeyword("in") && !this.matchContextualKeyword("of") && (this.match("=") ? (this.nextToken(), p = this.isolateCoverGrammar(this.parseAssignmentExpression)) : this.throwError(a.Messages.DeclarationMissingInitializer, "const")) : (!B.inFor && f.type !== u.Syntax.Identifier || this.match("=")) && (this.expect("="), p = this.isolateCoverGrammar(this.parseAssignmentExpression)), this.finalize(h, new g.VariableDeclarator(f, p));
              }, E.prototype.parseBindingList = function(l, B) {
                for (var h = [this.parseLexicalBinding(l, B)]; this.match(","); )
                  this.nextToken(), h.push(this.parseLexicalBinding(l, B));
                return h;
              }, E.prototype.isLexicalDeclaration = function() {
                var l = this.scanner.saveState();
                this.scanner.scanComments();
                var B = this.scanner.lex();
                return this.scanner.restoreState(l), B.type === 3 || B.type === 7 && B.value === "[" || B.type === 7 && B.value === "{" || B.type === 4 && B.value === "let" || B.type === 4 && B.value === "yield";
              }, E.prototype.parseLexicalDeclaration = function(l) {
                var B = this.createNode(), h = this.nextToken().value;
                n.assert(h === "let" || h === "const", "Lexical declaration must be either let or const");
                var Q = this.parseBindingList(h, l);
                return this.consumeSemicolon(), this.finalize(B, new g.VariableDeclaration(Q, h));
              }, E.prototype.parseBindingRestElement = function(l, B) {
                var h = this.createNode();
                this.expect("...");
                var Q = this.parsePattern(l, B);
                return this.finalize(h, new g.RestElement(Q));
              }, E.prototype.parseArrayPattern = function(l, B) {
                var h = this.createNode();
                this.expect("[");
                for (var Q = []; !this.match("]"); )
                  if (this.match(","))
                    this.nextToken(), Q.push(null);
                  else {
                    if (this.match("...")) {
                      Q.push(this.parseBindingRestElement(l, B));
                      break;
                    } else
                      Q.push(this.parsePatternWithDefault(l, B));
                    this.match("]") || this.expect(",");
                  }
                return this.expect("]"), this.finalize(h, new g.ArrayPattern(Q));
              }, E.prototype.parsePropertyPattern = function(l, B) {
                var h = this.createNode(), Q = !1, f = !1, p = !1, y, m;
                if (this.lookahead.type === 3) {
                  var S = this.lookahead;
                  y = this.parseVariableIdentifier();
                  var w = this.finalize(h, new g.Identifier(S.value));
                  if (this.match("=")) {
                    l.push(S), f = !0, this.nextToken();
                    var F = this.parseAssignmentExpression();
                    m = this.finalize(this.startNode(S), new g.AssignmentPattern(w, F));
                  } else this.match(":") ? (this.expect(":"), m = this.parsePatternWithDefault(l, B)) : (l.push(S), f = !0, m = w);
                } else
                  Q = this.match("["), y = this.parseObjectPropertyKey(), this.expect(":"), m = this.parsePatternWithDefault(l, B);
                return this.finalize(h, new g.Property("init", y, Q, m, p, f));
              }, E.prototype.parseObjectPattern = function(l, B) {
                var h = this.createNode(), Q = [];
                for (this.expect("{"); !this.match("}"); )
                  Q.push(this.parsePropertyPattern(l, B)), this.match("}") || this.expect(",");
                return this.expect("}"), this.finalize(h, new g.ObjectPattern(Q));
              }, E.prototype.parsePattern = function(l, B) {
                var h;
                return this.match("[") ? h = this.parseArrayPattern(l, B) : this.match("{") ? h = this.parseObjectPattern(l, B) : (this.matchKeyword("let") && (B === "const" || B === "let") && this.tolerateUnexpectedToken(this.lookahead, a.Messages.LetInLexicalBinding), l.push(this.lookahead), h = this.parseVariableIdentifier(B)), h;
              }, E.prototype.parsePatternWithDefault = function(l, B) {
                var h = this.lookahead, Q = this.parsePattern(l, B);
                if (this.match("=")) {
                  this.nextToken();
                  var f = this.context.allowYield;
                  this.context.allowYield = !0;
                  var p = this.isolateCoverGrammar(this.parseAssignmentExpression);
                  this.context.allowYield = f, Q = this.finalize(this.startNode(h), new g.AssignmentPattern(Q, p));
                }
                return Q;
              }, E.prototype.parseVariableIdentifier = function(l) {
                var B = this.createNode(), h = this.nextToken();
                return h.type === 4 && h.value === "yield" ? this.context.strict ? this.tolerateUnexpectedToken(h, a.Messages.StrictReservedWord) : this.context.allowYield || this.throwUnexpectedToken(h) : h.type !== 3 ? this.context.strict && h.type === 4 && this.scanner.isStrictModeReservedWord(h.value) ? this.tolerateUnexpectedToken(h, a.Messages.StrictReservedWord) : (this.context.strict || h.value !== "let" || l !== "var") && this.throwUnexpectedToken(h) : (this.context.isModule || this.context.await) && h.type === 3 && h.value === "await" && this.tolerateUnexpectedToken(h), this.finalize(B, new g.Identifier(h.value));
              }, E.prototype.parseVariableDeclaration = function(l) {
                var B = this.createNode(), h = [], Q = this.parsePattern(h, "var");
                this.context.strict && Q.type === u.Syntax.Identifier && this.scanner.isRestrictedWord(Q.name) && this.tolerateError(a.Messages.StrictVarName);
                var f = null;
                return this.match("=") ? (this.nextToken(), f = this.isolateCoverGrammar(this.parseAssignmentExpression)) : Q.type !== u.Syntax.Identifier && !l.inFor && this.expect("="), this.finalize(B, new g.VariableDeclarator(Q, f));
              }, E.prototype.parseVariableDeclarationList = function(l) {
                var B = { inFor: l.inFor }, h = [];
                for (h.push(this.parseVariableDeclaration(B)); this.match(","); )
                  this.nextToken(), h.push(this.parseVariableDeclaration(B));
                return h;
              }, E.prototype.parseVariableStatement = function() {
                var l = this.createNode();
                this.expectKeyword("var");
                var B = this.parseVariableDeclarationList({ inFor: !1 });
                return this.consumeSemicolon(), this.finalize(l, new g.VariableDeclaration(B, "var"));
              }, E.prototype.parseEmptyStatement = function() {
                var l = this.createNode();
                return this.expect(";"), this.finalize(l, new g.EmptyStatement());
              }, E.prototype.parseExpressionStatement = function() {
                var l = this.createNode(), B = this.parseExpression();
                return this.consumeSemicolon(), this.finalize(l, new g.ExpressionStatement(B));
              }, E.prototype.parseIfClause = function() {
                return this.context.strict && this.matchKeyword("function") && this.tolerateError(a.Messages.StrictFunction), this.parseStatement();
              }, E.prototype.parseIfStatement = function() {
                var l = this.createNode(), B, h = null;
                this.expectKeyword("if"), this.expect("(");
                var Q = this.parseExpression();
                return !this.match(")") && this.config.tolerant ? (this.tolerateUnexpectedToken(this.nextToken()), B = this.finalize(this.createNode(), new g.EmptyStatement())) : (this.expect(")"), B = this.parseIfClause(), this.matchKeyword("else") && (this.nextToken(), h = this.parseIfClause())), this.finalize(l, new g.IfStatement(Q, B, h));
              }, E.prototype.parseDoWhileStatement = function() {
                var l = this.createNode();
                this.expectKeyword("do");
                var B = this.context.inIteration;
                this.context.inIteration = !0;
                var h = this.parseStatement();
                this.context.inIteration = B, this.expectKeyword("while"), this.expect("(");
                var Q = this.parseExpression();
                return !this.match(")") && this.config.tolerant ? this.tolerateUnexpectedToken(this.nextToken()) : (this.expect(")"), this.match(";") && this.nextToken()), this.finalize(l, new g.DoWhileStatement(h, Q));
              }, E.prototype.parseWhileStatement = function() {
                var l = this.createNode(), B;
                this.expectKeyword("while"), this.expect("(");
                var h = this.parseExpression();
                if (!this.match(")") && this.config.tolerant)
                  this.tolerateUnexpectedToken(this.nextToken()), B = this.finalize(this.createNode(), new g.EmptyStatement());
                else {
                  this.expect(")");
                  var Q = this.context.inIteration;
                  this.context.inIteration = !0, B = this.parseStatement(), this.context.inIteration = Q;
                }
                return this.finalize(l, new g.WhileStatement(h, B));
              }, E.prototype.parseForStatement = function() {
                var l = null, B = null, h = null, Q = !0, f, p, y = this.createNode();
                if (this.expectKeyword("for"), this.expect("("), this.match(";"))
                  this.nextToken();
                else if (this.matchKeyword("var")) {
                  l = this.createNode(), this.nextToken();
                  var m = this.context.allowIn;
                  this.context.allowIn = !1;
                  var S = this.parseVariableDeclarationList({ inFor: !0 });
                  if (this.context.allowIn = m, S.length === 1 && this.matchKeyword("in")) {
                    var w = S[0];
                    w.init && (w.id.type === u.Syntax.ArrayPattern || w.id.type === u.Syntax.ObjectPattern || this.context.strict) && this.tolerateError(a.Messages.ForInOfLoopInitializer, "for-in"), l = this.finalize(l, new g.VariableDeclaration(S, "var")), this.nextToken(), f = l, p = this.parseExpression(), l = null;
                  } else S.length === 1 && S[0].init === null && this.matchContextualKeyword("of") ? (l = this.finalize(l, new g.VariableDeclaration(S, "var")), this.nextToken(), f = l, p = this.parseAssignmentExpression(), l = null, Q = !1) : (l = this.finalize(l, new g.VariableDeclaration(S, "var")), this.expect(";"));
                } else if (this.matchKeyword("const") || this.matchKeyword("let")) {
                  l = this.createNode();
                  var F = this.nextToken().value;
                  if (!this.context.strict && this.lookahead.value === "in")
                    l = this.finalize(l, new g.Identifier(F)), this.nextToken(), f = l, p = this.parseExpression(), l = null;
                  else {
                    var m = this.context.allowIn;
                    this.context.allowIn = !1;
                    var S = this.parseBindingList(F, { inFor: !0 });
                    this.context.allowIn = m, S.length === 1 && S[0].init === null && this.matchKeyword("in") ? (l = this.finalize(l, new g.VariableDeclaration(S, F)), this.nextToken(), f = l, p = this.parseExpression(), l = null) : S.length === 1 && S[0].init === null && this.matchContextualKeyword("of") ? (l = this.finalize(l, new g.VariableDeclaration(S, F)), this.nextToken(), f = l, p = this.parseAssignmentExpression(), l = null, Q = !1) : (this.consumeSemicolon(), l = this.finalize(l, new g.VariableDeclaration(S, F)));
                  }
                } else {
                  var b = this.lookahead, m = this.context.allowIn;
                  if (this.context.allowIn = !1, l = this.inheritCoverGrammar(this.parseAssignmentExpression), this.context.allowIn = m, this.matchKeyword("in"))
                    (!this.context.isAssignmentTarget || l.type === u.Syntax.AssignmentExpression) && this.tolerateError(a.Messages.InvalidLHSInForIn), this.nextToken(), this.reinterpretExpressionAsPattern(l), f = l, p = this.parseExpression(), l = null;
                  else if (this.matchContextualKeyword("of"))
                    (!this.context.isAssignmentTarget || l.type === u.Syntax.AssignmentExpression) && this.tolerateError(a.Messages.InvalidLHSInForLoop), this.nextToken(), this.reinterpretExpressionAsPattern(l), f = l, p = this.parseAssignmentExpression(), l = null, Q = !1;
                  else {
                    if (this.match(",")) {
                      for (var G = [l]; this.match(","); )
                        this.nextToken(), G.push(this.isolateCoverGrammar(this.parseAssignmentExpression));
                      l = this.finalize(this.startNode(b), new g.SequenceExpression(G));
                    }
                    this.expect(";");
                  }
                }
                typeof f > "u" && (this.match(";") || (B = this.parseExpression()), this.expect(";"), this.match(")") || (h = this.parseExpression()));
                var T;
                if (!this.match(")") && this.config.tolerant)
                  this.tolerateUnexpectedToken(this.nextToken()), T = this.finalize(this.createNode(), new g.EmptyStatement());
                else {
                  this.expect(")");
                  var K = this.context.inIteration;
                  this.context.inIteration = !0, T = this.isolateCoverGrammar(this.parseStatement), this.context.inIteration = K;
                }
                return typeof f > "u" ? this.finalize(y, new g.ForStatement(l, B, h, T)) : Q ? this.finalize(y, new g.ForInStatement(f, p, T)) : this.finalize(y, new g.ForOfStatement(f, p, T));
              }, E.prototype.parseContinueStatement = function() {
                var l = this.createNode();
                this.expectKeyword("continue");
                var B = null;
                if (this.lookahead.type === 3 && !this.hasLineTerminator) {
                  var h = this.parseVariableIdentifier();
                  B = h;
                  var Q = "$" + h.name;
                  Object.prototype.hasOwnProperty.call(this.context.labelSet, Q) || this.throwError(a.Messages.UnknownLabel, h.name);
                }
                return this.consumeSemicolon(), B === null && !this.context.inIteration && this.throwError(a.Messages.IllegalContinue), this.finalize(l, new g.ContinueStatement(B));
              }, E.prototype.parseBreakStatement = function() {
                var l = this.createNode();
                this.expectKeyword("break");
                var B = null;
                if (this.lookahead.type === 3 && !this.hasLineTerminator) {
                  var h = this.parseVariableIdentifier(), Q = "$" + h.name;
                  Object.prototype.hasOwnProperty.call(this.context.labelSet, Q) || this.throwError(a.Messages.UnknownLabel, h.name), B = h;
                }
                return this.consumeSemicolon(), B === null && !this.context.inIteration && !this.context.inSwitch && this.throwError(a.Messages.IllegalBreak), this.finalize(l, new g.BreakStatement(B));
              }, E.prototype.parseReturnStatement = function() {
                this.context.inFunctionBody || this.tolerateError(a.Messages.IllegalReturn);
                var l = this.createNode();
                this.expectKeyword("return");
                var B = !this.match(";") && !this.match("}") && !this.hasLineTerminator && this.lookahead.type !== 2 || this.lookahead.type === 8 || this.lookahead.type === 10, h = B ? this.parseExpression() : null;
                return this.consumeSemicolon(), this.finalize(l, new g.ReturnStatement(h));
              }, E.prototype.parseWithStatement = function() {
                this.context.strict && this.tolerateError(a.Messages.StrictModeWith);
                var l = this.createNode(), B;
                this.expectKeyword("with"), this.expect("(");
                var h = this.parseExpression();
                return !this.match(")") && this.config.tolerant ? (this.tolerateUnexpectedToken(this.nextToken()), B = this.finalize(this.createNode(), new g.EmptyStatement())) : (this.expect(")"), B = this.parseStatement()), this.finalize(l, new g.WithStatement(h, B));
              }, E.prototype.parseSwitchCase = function() {
                var l = this.createNode(), B;
                this.matchKeyword("default") ? (this.nextToken(), B = null) : (this.expectKeyword("case"), B = this.parseExpression()), this.expect(":");
                for (var h = []; !(this.match("}") || this.matchKeyword("default") || this.matchKeyword("case")); )
                  h.push(this.parseStatementListItem());
                return this.finalize(l, new g.SwitchCase(B, h));
              }, E.prototype.parseSwitchStatement = function() {
                var l = this.createNode();
                this.expectKeyword("switch"), this.expect("(");
                var B = this.parseExpression();
                this.expect(")");
                var h = this.context.inSwitch;
                this.context.inSwitch = !0;
                var Q = [], f = !1;
                for (this.expect("{"); !this.match("}"); ) {
                  var p = this.parseSwitchCase();
                  p.test === null && (f && this.throwError(a.Messages.MultipleDefaultsInSwitch), f = !0), Q.push(p);
                }
                return this.expect("}"), this.context.inSwitch = h, this.finalize(l, new g.SwitchStatement(B, Q));
              }, E.prototype.parseLabelledStatement = function() {
                var l = this.createNode(), B = this.parseExpression(), h;
                if (B.type === u.Syntax.Identifier && this.match(":")) {
                  this.nextToken();
                  var Q = B, f = "$" + Q.name;
                  Object.prototype.hasOwnProperty.call(this.context.labelSet, f) && this.throwError(a.Messages.Redeclaration, "Label", Q.name), this.context.labelSet[f] = !0;
                  var p = void 0;
                  if (this.matchKeyword("class"))
                    this.tolerateUnexpectedToken(this.lookahead), p = this.parseClassDeclaration();
                  else if (this.matchKeyword("function")) {
                    var y = this.lookahead, m = this.parseFunctionDeclaration();
                    this.context.strict ? this.tolerateUnexpectedToken(y, a.Messages.StrictFunction) : m.generator && this.tolerateUnexpectedToken(y, a.Messages.GeneratorInLegacyContext), p = m;
                  } else
                    p = this.parseStatement();
                  delete this.context.labelSet[f], h = new g.LabeledStatement(Q, p);
                } else
                  this.consumeSemicolon(), h = new g.ExpressionStatement(B);
                return this.finalize(l, h);
              }, E.prototype.parseThrowStatement = function() {
                var l = this.createNode();
                this.expectKeyword("throw"), this.hasLineTerminator && this.throwError(a.Messages.NewlineAfterThrow);
                var B = this.parseExpression();
                return this.consumeSemicolon(), this.finalize(l, new g.ThrowStatement(B));
              }, E.prototype.parseCatchClause = function() {
                var l = this.createNode();
                this.expectKeyword("catch"), this.expect("("), this.match(")") && this.throwUnexpectedToken(this.lookahead);
                for (var B = [], h = this.parsePattern(B), Q = {}, f = 0; f < B.length; f++) {
                  var p = "$" + B[f].value;
                  Object.prototype.hasOwnProperty.call(Q, p) && this.tolerateError(a.Messages.DuplicateBinding, B[f].value), Q[p] = !0;
                }
                this.context.strict && h.type === u.Syntax.Identifier && this.scanner.isRestrictedWord(h.name) && this.tolerateError(a.Messages.StrictCatchVariable), this.expect(")");
                var y = this.parseBlock();
                return this.finalize(l, new g.CatchClause(h, y));
              }, E.prototype.parseFinallyClause = function() {
                return this.expectKeyword("finally"), this.parseBlock();
              }, E.prototype.parseTryStatement = function() {
                var l = this.createNode();
                this.expectKeyword("try");
                var B = this.parseBlock(), h = this.matchKeyword("catch") ? this.parseCatchClause() : null, Q = this.matchKeyword("finally") ? this.parseFinallyClause() : null;
                return !h && !Q && this.throwError(a.Messages.NoCatchOrFinally), this.finalize(l, new g.TryStatement(B, h, Q));
              }, E.prototype.parseDebuggerStatement = function() {
                var l = this.createNode();
                return this.expectKeyword("debugger"), this.consumeSemicolon(), this.finalize(l, new g.DebuggerStatement());
              }, E.prototype.parseStatement = function() {
                var l;
                switch (this.lookahead.type) {
                  case 1:
                  case 5:
                  case 6:
                  case 8:
                  case 10:
                  case 9:
                    l = this.parseExpressionStatement();
                    break;
                  case 7:
                    var B = this.lookahead.value;
                    B === "{" ? l = this.parseBlock() : B === "(" ? l = this.parseExpressionStatement() : B === ";" ? l = this.parseEmptyStatement() : l = this.parseExpressionStatement();
                    break;
                  case 3:
                    l = this.matchAsyncFunction() ? this.parseFunctionDeclaration() : this.parseLabelledStatement();
                    break;
                  case 4:
                    switch (this.lookahead.value) {
                      case "break":
                        l = this.parseBreakStatement();
                        break;
                      case "continue":
                        l = this.parseContinueStatement();
                        break;
                      case "debugger":
                        l = this.parseDebuggerStatement();
                        break;
                      case "do":
                        l = this.parseDoWhileStatement();
                        break;
                      case "for":
                        l = this.parseForStatement();
                        break;
                      case "function":
                        l = this.parseFunctionDeclaration();
                        break;
                      case "if":
                        l = this.parseIfStatement();
                        break;
                      case "return":
                        l = this.parseReturnStatement();
                        break;
                      case "switch":
                        l = this.parseSwitchStatement();
                        break;
                      case "throw":
                        l = this.parseThrowStatement();
                        break;
                      case "try":
                        l = this.parseTryStatement();
                        break;
                      case "var":
                        l = this.parseVariableStatement();
                        break;
                      case "while":
                        l = this.parseWhileStatement();
                        break;
                      case "with":
                        l = this.parseWithStatement();
                        break;
                      default:
                        l = this.parseExpressionStatement();
                        break;
                    }
                    break;
                  default:
                    l = this.throwUnexpectedToken(this.lookahead);
                }
                return l;
              }, E.prototype.parseFunctionSourceElements = function() {
                var l = this.createNode();
                this.expect("{");
                var B = this.parseDirectivePrologues(), h = this.context.labelSet, Q = this.context.inIteration, f = this.context.inSwitch, p = this.context.inFunctionBody;
                for (this.context.labelSet = {}, this.context.inIteration = !1, this.context.inSwitch = !1, this.context.inFunctionBody = !0; this.lookahead.type !== 2 && !this.match("}"); )
                  B.push(this.parseStatementListItem());
                return this.expect("}"), this.context.labelSet = h, this.context.inIteration = Q, this.context.inSwitch = f, this.context.inFunctionBody = p, this.finalize(l, new g.BlockStatement(B));
              }, E.prototype.validateParam = function(l, B, h) {
                var Q = "$" + h;
                this.context.strict ? (this.scanner.isRestrictedWord(h) && (l.stricted = B, l.message = a.Messages.StrictParamName), Object.prototype.hasOwnProperty.call(l.paramSet, Q) && (l.stricted = B, l.message = a.Messages.StrictParamDupe)) : l.firstRestricted || (this.scanner.isRestrictedWord(h) ? (l.firstRestricted = B, l.message = a.Messages.StrictParamName) : this.scanner.isStrictModeReservedWord(h) ? (l.firstRestricted = B, l.message = a.Messages.StrictReservedWord) : Object.prototype.hasOwnProperty.call(l.paramSet, Q) && (l.stricted = B, l.message = a.Messages.StrictParamDupe)), typeof Object.defineProperty == "function" ? Object.defineProperty(l.paramSet, Q, { value: !0, enumerable: !0, writable: !0, configurable: !0 }) : l.paramSet[Q] = !0;
              }, E.prototype.parseRestElement = function(l) {
                var B = this.createNode();
                this.expect("...");
                var h = this.parsePattern(l);
                return this.match("=") && this.throwError(a.Messages.DefaultRestParameter), this.match(")") || this.throwError(a.Messages.ParameterAfterRestParameter), this.finalize(B, new g.RestElement(h));
              }, E.prototype.parseFormalParameter = function(l) {
                for (var B = [], h = this.match("...") ? this.parseRestElement(B) : this.parsePatternWithDefault(B), Q = 0; Q < B.length; Q++)
                  this.validateParam(l, B[Q], B[Q].value);
                l.simple = l.simple && h instanceof g.Identifier, l.params.push(h);
              }, E.prototype.parseFormalParameters = function(l) {
                var B;
                if (B = {
                  simple: !0,
                  params: [],
                  firstRestricted: l
                }, this.expect("("), !this.match(")"))
                  for (B.paramSet = {}; this.lookahead.type !== 2 && (this.parseFormalParameter(B), !(this.match(")") || (this.expect(","), this.match(")")))); )
                    ;
                return this.expect(")"), {
                  simple: B.simple,
                  params: B.params,
                  stricted: B.stricted,
                  firstRestricted: B.firstRestricted,
                  message: B.message
                };
              }, E.prototype.matchAsyncFunction = function() {
                var l = this.matchContextualKeyword("async");
                if (l) {
                  var B = this.scanner.saveState();
                  this.scanner.scanComments();
                  var h = this.scanner.lex();
                  this.scanner.restoreState(B), l = B.lineNumber === h.lineNumber && h.type === 4 && h.value === "function";
                }
                return l;
              }, E.prototype.parseFunctionDeclaration = function(l) {
                var B = this.createNode(), h = this.matchContextualKeyword("async");
                h && this.nextToken(), this.expectKeyword("function");
                var Q = h ? !1 : this.match("*");
                Q && this.nextToken();
                var f, p = null, y = null;
                if (!l || !this.match("(")) {
                  var m = this.lookahead;
                  p = this.parseVariableIdentifier(), this.context.strict ? this.scanner.isRestrictedWord(m.value) && this.tolerateUnexpectedToken(m, a.Messages.StrictFunctionName) : this.scanner.isRestrictedWord(m.value) ? (y = m, f = a.Messages.StrictFunctionName) : this.scanner.isStrictModeReservedWord(m.value) && (y = m, f = a.Messages.StrictReservedWord);
                }
                var S = this.context.await, w = this.context.allowYield;
                this.context.await = h, this.context.allowYield = !Q;
                var F = this.parseFormalParameters(y), b = F.params, G = F.stricted;
                y = F.firstRestricted, F.message && (f = F.message);
                var T = this.context.strict, K = this.context.allowStrictDirective;
                this.context.allowStrictDirective = F.simple;
                var H = this.parseFunctionSourceElements();
                return this.context.strict && y && this.throwUnexpectedToken(y, f), this.context.strict && G && this.tolerateUnexpectedToken(G, f), this.context.strict = T, this.context.allowStrictDirective = K, this.context.await = S, this.context.allowYield = w, h ? this.finalize(B, new g.AsyncFunctionDeclaration(p, b, H)) : this.finalize(B, new g.FunctionDeclaration(p, b, H, Q));
              }, E.prototype.parseFunctionExpression = function() {
                var l = this.createNode(), B = this.matchContextualKeyword("async");
                B && this.nextToken(), this.expectKeyword("function");
                var h = B ? !1 : this.match("*");
                h && this.nextToken();
                var Q, f = null, p, y = this.context.await, m = this.context.allowYield;
                if (this.context.await = B, this.context.allowYield = !h, !this.match("(")) {
                  var S = this.lookahead;
                  f = !this.context.strict && !h && this.matchKeyword("yield") ? this.parseIdentifierName() : this.parseVariableIdentifier(), this.context.strict ? this.scanner.isRestrictedWord(S.value) && this.tolerateUnexpectedToken(S, a.Messages.StrictFunctionName) : this.scanner.isRestrictedWord(S.value) ? (p = S, Q = a.Messages.StrictFunctionName) : this.scanner.isStrictModeReservedWord(S.value) && (p = S, Q = a.Messages.StrictReservedWord);
                }
                var w = this.parseFormalParameters(p), F = w.params, b = w.stricted;
                p = w.firstRestricted, w.message && (Q = w.message);
                var G = this.context.strict, T = this.context.allowStrictDirective;
                this.context.allowStrictDirective = w.simple;
                var K = this.parseFunctionSourceElements();
                return this.context.strict && p && this.throwUnexpectedToken(p, Q), this.context.strict && b && this.tolerateUnexpectedToken(b, Q), this.context.strict = G, this.context.allowStrictDirective = T, this.context.await = y, this.context.allowYield = m, B ? this.finalize(l, new g.AsyncFunctionExpression(f, F, K)) : this.finalize(l, new g.FunctionExpression(f, F, K, h));
              }, E.prototype.parseDirective = function() {
                var l = this.lookahead, B = this.createNode(), h = this.parseExpression(), Q = h.type === u.Syntax.Literal ? this.getTokenRaw(l).slice(1, -1) : null;
                return this.consumeSemicolon(), this.finalize(B, Q ? new g.Directive(h, Q) : new g.ExpressionStatement(h));
              }, E.prototype.parseDirectivePrologues = function() {
                for (var l = null, B = []; ; ) {
                  var h = this.lookahead;
                  if (h.type !== 8)
                    break;
                  var Q = this.parseDirective();
                  B.push(Q);
                  var f = Q.directive;
                  if (typeof f != "string")
                    break;
                  f === "use strict" ? (this.context.strict = !0, l && this.tolerateUnexpectedToken(l, a.Messages.StrictOctalLiteral), this.context.allowStrictDirective || this.tolerateUnexpectedToken(h, a.Messages.IllegalLanguageModeDirective)) : !l && h.octal && (l = h);
                }
                return B;
              }, E.prototype.qualifiedPropertyName = function(l) {
                switch (l.type) {
                  case 3:
                  case 8:
                  case 1:
                  case 5:
                  case 6:
                  case 4:
                    return !0;
                  case 7:
                    return l.value === "[";
                }
                return !1;
              }, E.prototype.parseGetterMethod = function() {
                var l = this.createNode(), B = !1, h = this.context.allowYield;
                this.context.allowYield = !B;
                var Q = this.parseFormalParameters();
                Q.params.length > 0 && this.tolerateError(a.Messages.BadGetterArity);
                var f = this.parsePropertyMethod(Q);
                return this.context.allowYield = h, this.finalize(l, new g.FunctionExpression(null, Q.params, f, B));
              }, E.prototype.parseSetterMethod = function() {
                var l = this.createNode(), B = !1, h = this.context.allowYield;
                this.context.allowYield = !B;
                var Q = this.parseFormalParameters();
                Q.params.length !== 1 ? this.tolerateError(a.Messages.BadSetterArity) : Q.params[0] instanceof g.RestElement && this.tolerateError(a.Messages.BadSetterRestParameter);
                var f = this.parsePropertyMethod(Q);
                return this.context.allowYield = h, this.finalize(l, new g.FunctionExpression(null, Q.params, f, B));
              }, E.prototype.parseGeneratorMethod = function() {
                var l = this.createNode(), B = !0, h = this.context.allowYield;
                this.context.allowYield = !0;
                var Q = this.parseFormalParameters();
                this.context.allowYield = !1;
                var f = this.parsePropertyMethod(Q);
                return this.context.allowYield = h, this.finalize(l, new g.FunctionExpression(null, Q.params, f, B));
              }, E.prototype.isStartOfExpression = function() {
                var l = !0, B = this.lookahead.value;
                switch (this.lookahead.type) {
                  case 7:
                    l = B === "[" || B === "(" || B === "{" || B === "+" || B === "-" || B === "!" || B === "~" || B === "++" || B === "--" || B === "/" || B === "/=";
                    break;
                  case 4:
                    l = B === "class" || B === "delete" || B === "function" || B === "let" || B === "new" || B === "super" || B === "this" || B === "typeof" || B === "void" || B === "yield";
                    break;
                }
                return l;
              }, E.prototype.parseYieldExpression = function() {
                var l = this.createNode();
                this.expectKeyword("yield");
                var B = null, h = !1;
                if (!this.hasLineTerminator) {
                  var Q = this.context.allowYield;
                  this.context.allowYield = !1, h = this.match("*"), h ? (this.nextToken(), B = this.parseAssignmentExpression()) : this.isStartOfExpression() && (B = this.parseAssignmentExpression()), this.context.allowYield = Q;
                }
                return this.finalize(l, new g.YieldExpression(B, h));
              }, E.prototype.parseClassElement = function(l) {
                var B = this.lookahead, h = this.createNode(), Q = "", f = null, p = null, y = !1, m = !1, S = !1, w = !1;
                if (this.match("*"))
                  this.nextToken();
                else {
                  y = this.match("["), f = this.parseObjectPropertyKey();
                  var F = f;
                  if (F.name === "static" && (this.qualifiedPropertyName(this.lookahead) || this.match("*")) && (B = this.lookahead, S = !0, y = this.match("["), this.match("*") ? this.nextToken() : f = this.parseObjectPropertyKey()), B.type === 3 && !this.hasLineTerminator && B.value === "async") {
                    var b = this.lookahead.value;
                    b !== ":" && b !== "(" && b !== "*" && (w = !0, B = this.lookahead, f = this.parseObjectPropertyKey(), B.type === 3 && B.value === "constructor" && this.tolerateUnexpectedToken(B, a.Messages.ConstructorIsAsync));
                  }
                }
                var G = this.qualifiedPropertyName(this.lookahead);
                return B.type === 3 ? B.value === "get" && G ? (Q = "get", y = this.match("["), f = this.parseObjectPropertyKey(), this.context.allowYield = !1, p = this.parseGetterMethod()) : B.value === "set" && G && (Q = "set", y = this.match("["), f = this.parseObjectPropertyKey(), p = this.parseSetterMethod()) : B.type === 7 && B.value === "*" && G && (Q = "init", y = this.match("["), f = this.parseObjectPropertyKey(), p = this.parseGeneratorMethod(), m = !0), !Q && f && this.match("(") && (Q = "init", p = w ? this.parsePropertyMethodAsyncFunction() : this.parsePropertyMethodFunction(), m = !0), Q || this.throwUnexpectedToken(this.lookahead), Q === "init" && (Q = "method"), y || (S && this.isPropertyKey(f, "prototype") && this.throwUnexpectedToken(B, a.Messages.StaticPrototype), !S && this.isPropertyKey(f, "constructor") && ((Q !== "method" || !m || p && p.generator) && this.throwUnexpectedToken(B, a.Messages.ConstructorSpecialMethod), l.value ? this.throwUnexpectedToken(B, a.Messages.DuplicateConstructor) : l.value = !0, Q = "constructor")), this.finalize(h, new g.MethodDefinition(f, y, p, Q, S));
              }, E.prototype.parseClassElementList = function() {
                var l = [], B = { value: !1 };
                for (this.expect("{"); !this.match("}"); )
                  this.match(";") ? this.nextToken() : l.push(this.parseClassElement(B));
                return this.expect("}"), l;
              }, E.prototype.parseClassBody = function() {
                var l = this.createNode(), B = this.parseClassElementList();
                return this.finalize(l, new g.ClassBody(B));
              }, E.prototype.parseClassDeclaration = function(l) {
                var B = this.createNode(), h = this.context.strict;
                this.context.strict = !0, this.expectKeyword("class");
                var Q = l && this.lookahead.type !== 3 ? null : this.parseVariableIdentifier(), f = null;
                this.matchKeyword("extends") && (this.nextToken(), f = this.isolateCoverGrammar(this.parseLeftHandSideExpressionAllowCall));
                var p = this.parseClassBody();
                return this.context.strict = h, this.finalize(B, new g.ClassDeclaration(Q, f, p));
              }, E.prototype.parseClassExpression = function() {
                var l = this.createNode(), B = this.context.strict;
                this.context.strict = !0, this.expectKeyword("class");
                var h = this.lookahead.type === 3 ? this.parseVariableIdentifier() : null, Q = null;
                this.matchKeyword("extends") && (this.nextToken(), Q = this.isolateCoverGrammar(this.parseLeftHandSideExpressionAllowCall));
                var f = this.parseClassBody();
                return this.context.strict = B, this.finalize(l, new g.ClassExpression(h, Q, f));
              }, E.prototype.parseModule = function() {
                this.context.strict = !0, this.context.isModule = !0, this.scanner.isModule = !0;
                for (var l = this.createNode(), B = this.parseDirectivePrologues(); this.lookahead.type !== 2; )
                  B.push(this.parseStatementListItem());
                return this.finalize(l, new g.Module(B));
              }, E.prototype.parseScript = function() {
                for (var l = this.createNode(), B = this.parseDirectivePrologues(); this.lookahead.type !== 2; )
                  B.push(this.parseStatementListItem());
                return this.finalize(l, new g.Script(B));
              }, E.prototype.parseModuleSpecifier = function() {
                var l = this.createNode();
                this.lookahead.type !== 8 && this.throwError(a.Messages.InvalidModuleSpecifier);
                var B = this.nextToken(), h = this.getTokenRaw(B);
                return this.finalize(l, new g.Literal(B.value, h));
              }, E.prototype.parseImportSpecifier = function() {
                var l = this.createNode(), B, h;
                return this.lookahead.type === 3 ? (B = this.parseVariableIdentifier(), h = B, this.matchContextualKeyword("as") && (this.nextToken(), h = this.parseVariableIdentifier())) : (B = this.parseIdentifierName(), h = B, this.matchContextualKeyword("as") ? (this.nextToken(), h = this.parseVariableIdentifier()) : this.throwUnexpectedToken(this.nextToken())), this.finalize(l, new g.ImportSpecifier(h, B));
              }, E.prototype.parseNamedImports = function() {
                this.expect("{");
                for (var l = []; !this.match("}"); )
                  l.push(this.parseImportSpecifier()), this.match("}") || this.expect(",");
                return this.expect("}"), l;
              }, E.prototype.parseImportDefaultSpecifier = function() {
                var l = this.createNode(), B = this.parseIdentifierName();
                return this.finalize(l, new g.ImportDefaultSpecifier(B));
              }, E.prototype.parseImportNamespaceSpecifier = function() {
                var l = this.createNode();
                this.expect("*"), this.matchContextualKeyword("as") || this.throwError(a.Messages.NoAsAfterImportNamespace), this.nextToken();
                var B = this.parseIdentifierName();
                return this.finalize(l, new g.ImportNamespaceSpecifier(B));
              }, E.prototype.parseImportDeclaration = function() {
                this.context.inFunctionBody && this.throwError(a.Messages.IllegalImportDeclaration);
                var l = this.createNode();
                this.expectKeyword("import");
                var B, h = [];
                if (this.lookahead.type === 8)
                  B = this.parseModuleSpecifier();
                else {
                  if (this.match("{") ? h = h.concat(this.parseNamedImports()) : this.match("*") ? h.push(this.parseImportNamespaceSpecifier()) : this.isIdentifierName(this.lookahead) && !this.matchKeyword("default") ? (h.push(this.parseImportDefaultSpecifier()), this.match(",") && (this.nextToken(), this.match("*") ? h.push(this.parseImportNamespaceSpecifier()) : this.match("{") ? h = h.concat(this.parseNamedImports()) : this.throwUnexpectedToken(this.lookahead))) : this.throwUnexpectedToken(this.nextToken()), !this.matchContextualKeyword("from")) {
                    var Q = this.lookahead.value ? a.Messages.UnexpectedToken : a.Messages.MissingFromClause;
                    this.throwError(Q, this.lookahead.value);
                  }
                  this.nextToken(), B = this.parseModuleSpecifier();
                }
                return this.consumeSemicolon(), this.finalize(l, new g.ImportDeclaration(h, B));
              }, E.prototype.parseExportSpecifier = function() {
                var l = this.createNode(), B = this.parseIdentifierName(), h = B;
                return this.matchContextualKeyword("as") && (this.nextToken(), h = this.parseIdentifierName()), this.finalize(l, new g.ExportSpecifier(B, h));
              }, E.prototype.parseExportDeclaration = function() {
                this.context.inFunctionBody && this.throwError(a.Messages.IllegalExportDeclaration);
                var l = this.createNode();
                this.expectKeyword("export");
                var B;
                if (this.matchKeyword("default"))
                  if (this.nextToken(), this.matchKeyword("function")) {
                    var h = this.parseFunctionDeclaration(!0);
                    B = this.finalize(l, new g.ExportDefaultDeclaration(h));
                  } else if (this.matchKeyword("class")) {
                    var h = this.parseClassDeclaration(!0);
                    B = this.finalize(l, new g.ExportDefaultDeclaration(h));
                  } else if (this.matchContextualKeyword("async")) {
                    var h = this.matchAsyncFunction() ? this.parseFunctionDeclaration(!0) : this.parseAssignmentExpression();
                    B = this.finalize(l, new g.ExportDefaultDeclaration(h));
                  } else {
                    this.matchContextualKeyword("from") && this.throwError(a.Messages.UnexpectedToken, this.lookahead.value);
                    var h = this.match("{") ? this.parseObjectInitializer() : this.match("[") ? this.parseArrayInitializer() : this.parseAssignmentExpression();
                    this.consumeSemicolon(), B = this.finalize(l, new g.ExportDefaultDeclaration(h));
                  }
                else if (this.match("*")) {
                  if (this.nextToken(), !this.matchContextualKeyword("from")) {
                    var Q = this.lookahead.value ? a.Messages.UnexpectedToken : a.Messages.MissingFromClause;
                    this.throwError(Q, this.lookahead.value);
                  }
                  this.nextToken();
                  var f = this.parseModuleSpecifier();
                  this.consumeSemicolon(), B = this.finalize(l, new g.ExportAllDeclaration(f));
                } else if (this.lookahead.type === 4) {
                  var h = void 0;
                  switch (this.lookahead.value) {
                    case "let":
                    case "const":
                      h = this.parseLexicalDeclaration({ inFor: !1 });
                      break;
                    case "var":
                    case "class":
                    case "function":
                      h = this.parseStatementListItem();
                      break;
                    default:
                      this.throwUnexpectedToken(this.lookahead);
                  }
                  B = this.finalize(l, new g.ExportNamedDeclaration(h, [], null));
                } else if (this.matchAsyncFunction()) {
                  var h = this.parseFunctionDeclaration();
                  B = this.finalize(l, new g.ExportNamedDeclaration(h, [], null));
                } else {
                  var p = [], y = null, m = !1;
                  for (this.expect("{"); !this.match("}"); )
                    m = m || this.matchKeyword("default"), p.push(this.parseExportSpecifier()), this.match("}") || this.expect(",");
                  if (this.expect("}"), this.matchContextualKeyword("from"))
                    this.nextToken(), y = this.parseModuleSpecifier(), this.consumeSemicolon();
                  else if (m) {
                    var Q = this.lookahead.value ? a.Messages.UnexpectedToken : a.Messages.MissingFromClause;
                    this.throwError(Q, this.lookahead.value);
                  } else
                    this.consumeSemicolon();
                  B = this.finalize(l, new g.ExportNamedDeclaration(null, p, y));
                }
                return B;
              }, E;
            }();
            r.Parser = C;
          },
          /* 9 */
          /***/
          function(e, r) {
            Object.defineProperty(r, "__esModule", { value: !0 });
            function i(n, s) {
              if (!n)
                throw new Error("ASSERT: " + s);
            }
            r.assert = i;
          },
          /* 10 */
          /***/
          function(e, r) {
            Object.defineProperty(r, "__esModule", { value: !0 });
            var i = function() {
              function n() {
                this.errors = [], this.tolerant = !1;
              }
              return n.prototype.recordError = function(s) {
                this.errors.push(s);
              }, n.prototype.tolerate = function(s) {
                if (this.tolerant)
                  this.recordError(s);
                else
                  throw s;
              }, n.prototype.constructError = function(s, a) {
                var g = new Error(s);
                try {
                  throw g;
                } catch (o) {
                  Object.create && Object.defineProperty && (g = Object.create(o), Object.defineProperty(g, "column", { value: a }));
                }
                return g;
              }, n.prototype.createError = function(s, a, g, o) {
                var u = "Line " + a + ": " + o, I = this.constructError(u, g);
                return I.index = s, I.lineNumber = a, I.description = o, I;
              }, n.prototype.throwError = function(s, a, g, o) {
                throw this.createError(s, a, g, o);
              }, n.prototype.tolerateError = function(s, a, g, o) {
                var u = this.createError(s, a, g, o);
                if (this.tolerant)
                  this.recordError(u);
                else
                  throw u;
              }, n;
            }();
            r.ErrorHandler = i;
          },
          /* 11 */
          /***/
          function(e, r) {
            Object.defineProperty(r, "__esModule", { value: !0 }), r.Messages = {
              BadGetterArity: "Getter must not have any formal parameters",
              BadSetterArity: "Setter must have exactly one formal parameter",
              BadSetterRestParameter: "Setter function argument must not be a rest parameter",
              ConstructorIsAsync: "Class constructor may not be an async method",
              ConstructorSpecialMethod: "Class constructor may not be an accessor",
              DeclarationMissingInitializer: "Missing initializer in %0 declaration",
              DefaultRestParameter: "Unexpected token =",
              DuplicateBinding: "Duplicate binding %0",
              DuplicateConstructor: "A class may only have one constructor",
              DuplicateProtoProperty: "Duplicate __proto__ fields are not allowed in object literals",
              ForInOfLoopInitializer: "%0 loop variable declaration may not have an initializer",
              GeneratorInLegacyContext: "Generator declarations are not allowed in legacy contexts",
              IllegalBreak: "Illegal break statement",
              IllegalContinue: "Illegal continue statement",
              IllegalExportDeclaration: "Unexpected token",
              IllegalImportDeclaration: "Unexpected token",
              IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list",
              IllegalReturn: "Illegal return statement",
              InvalidEscapedReservedWord: "Keyword must not contain escaped characters",
              InvalidHexEscapeSequence: "Invalid hexadecimal escape sequence",
              InvalidLHSInAssignment: "Invalid left-hand side in assignment",
              InvalidLHSInForIn: "Invalid left-hand side in for-in",
              InvalidLHSInForLoop: "Invalid left-hand side in for-loop",
              InvalidModuleSpecifier: "Unexpected token",
              InvalidRegExp: "Invalid regular expression",
              LetInLexicalBinding: "let is disallowed as a lexically bound name",
              MissingFromClause: "Unexpected token",
              MultipleDefaultsInSwitch: "More than one default clause in switch statement",
              NewlineAfterThrow: "Illegal newline after throw",
              NoAsAfterImportNamespace: "Unexpected token",
              NoCatchOrFinally: "Missing catch or finally after try",
              ParameterAfterRestParameter: "Rest parameter must be last formal parameter",
              Redeclaration: "%0 '%1' has already been declared",
              StaticPrototype: "Classes may not have static property named prototype",
              StrictCatchVariable: "Catch variable may not be eval or arguments in strict mode",
              StrictDelete: "Delete of an unqualified identifier in strict mode.",
              StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block",
              StrictFunctionName: "Function name may not be eval or arguments in strict mode",
              StrictLHSAssignment: "Assignment to eval or arguments is not allowed in strict mode",
              StrictLHSPostfix: "Postfix increment/decrement may not have eval or arguments operand in strict mode",
              StrictLHSPrefix: "Prefix increment/decrement may not have eval or arguments operand in strict mode",
              StrictModeWith: "Strict mode code may not include a with statement",
              StrictOctalLiteral: "Octal literals are not allowed in strict mode.",
              StrictParamDupe: "Strict mode function may not have duplicate parameter names",
              StrictParamName: "Parameter name eval or arguments is not allowed in strict mode",
              StrictReservedWord: "Use of future reserved word in strict mode",
              StrictVarName: "Variable name may not be eval or arguments in strict mode",
              TemplateOctalLiteral: "Octal literals are not allowed in template strings.",
              UnexpectedEOS: "Unexpected end of input",
              UnexpectedIdentifier: "Unexpected identifier",
              UnexpectedNumber: "Unexpected number",
              UnexpectedReserved: "Unexpected reserved word",
              UnexpectedString: "Unexpected string",
              UnexpectedTemplate: "Unexpected quasi %0",
              UnexpectedToken: "Unexpected token %0",
              UnexpectedTokenIllegal: "Unexpected token ILLEGAL",
              UnknownLabel: "Undefined label '%0'",
              UnterminatedRegExp: "Invalid regular expression: missing /"
            };
          },
          /* 12 */
          /***/
          function(e, r, i) {
            Object.defineProperty(r, "__esModule", { value: !0 });
            var n = i(9), s = i(4), a = i(11);
            function g(I) {
              return "0123456789abcdef".indexOf(I.toLowerCase());
            }
            function o(I) {
              return "01234567".indexOf(I);
            }
            var u = function() {
              function I(c, C) {
                this.source = c, this.errorHandler = C, this.trackComment = !1, this.isModule = !1, this.length = c.length, this.index = 0, this.lineNumber = c.length > 0 ? 1 : 0, this.lineStart = 0, this.curlyStack = [];
              }
              return I.prototype.saveState = function() {
                return {
                  index: this.index,
                  lineNumber: this.lineNumber,
                  lineStart: this.lineStart
                };
              }, I.prototype.restoreState = function(c) {
                this.index = c.index, this.lineNumber = c.lineNumber, this.lineStart = c.lineStart;
              }, I.prototype.eof = function() {
                return this.index >= this.length;
              }, I.prototype.throwUnexpectedToken = function(c) {
                return c === void 0 && (c = a.Messages.UnexpectedTokenIllegal), this.errorHandler.throwError(this.index, this.lineNumber, this.index - this.lineStart + 1, c);
              }, I.prototype.tolerateUnexpectedToken = function(c) {
                c === void 0 && (c = a.Messages.UnexpectedTokenIllegal), this.errorHandler.tolerateError(this.index, this.lineNumber, this.index - this.lineStart + 1, c);
              }, I.prototype.skipSingleLineComment = function(c) {
                var C = [], E, l;
                for (this.trackComment && (C = [], E = this.index - c, l = {
                  start: {
                    line: this.lineNumber,
                    column: this.index - this.lineStart - c
                  },
                  end: {}
                }); !this.eof(); ) {
                  var B = this.source.charCodeAt(this.index);
                  if (++this.index, s.Character.isLineTerminator(B)) {
                    if (this.trackComment) {
                      l.end = {
                        line: this.lineNumber,
                        column: this.index - this.lineStart - 1
                      };
                      var h = {
                        multiLine: !1,
                        slice: [E + c, this.index - 1],
                        range: [E, this.index - 1],
                        loc: l
                      };
                      C.push(h);
                    }
                    return B === 13 && this.source.charCodeAt(this.index) === 10 && ++this.index, ++this.lineNumber, this.lineStart = this.index, C;
                  }
                }
                if (this.trackComment) {
                  l.end = {
                    line: this.lineNumber,
                    column: this.index - this.lineStart
                  };
                  var h = {
                    multiLine: !1,
                    slice: [E + c, this.index],
                    range: [E, this.index],
                    loc: l
                  };
                  C.push(h);
                }
                return C;
              }, I.prototype.skipMultiLineComment = function() {
                var c = [], C, E;
                for (this.trackComment && (c = [], C = this.index - 2, E = {
                  start: {
                    line: this.lineNumber,
                    column: this.index - this.lineStart - 2
                  },
                  end: {}
                }); !this.eof(); ) {
                  var l = this.source.charCodeAt(this.index);
                  if (s.Character.isLineTerminator(l))
                    l === 13 && this.source.charCodeAt(this.index + 1) === 10 && ++this.index, ++this.lineNumber, ++this.index, this.lineStart = this.index;
                  else if (l === 42) {
                    if (this.source.charCodeAt(this.index + 1) === 47) {
                      if (this.index += 2, this.trackComment) {
                        E.end = {
                          line: this.lineNumber,
                          column: this.index - this.lineStart
                        };
                        var B = {
                          multiLine: !0,
                          slice: [C + 2, this.index - 2],
                          range: [C, this.index],
                          loc: E
                        };
                        c.push(B);
                      }
                      return c;
                    }
                    ++this.index;
                  } else
                    ++this.index;
                }
                if (this.trackComment) {
                  E.end = {
                    line: this.lineNumber,
                    column: this.index - this.lineStart
                  };
                  var B = {
                    multiLine: !0,
                    slice: [C + 2, this.index],
                    range: [C, this.index],
                    loc: E
                  };
                  c.push(B);
                }
                return this.tolerateUnexpectedToken(), c;
              }, I.prototype.scanComments = function() {
                var c;
                this.trackComment && (c = []);
                for (var C = this.index === 0; !this.eof(); ) {
                  var E = this.source.charCodeAt(this.index);
                  if (s.Character.isWhiteSpace(E))
                    ++this.index;
                  else if (s.Character.isLineTerminator(E))
                    ++this.index, E === 13 && this.source.charCodeAt(this.index) === 10 && ++this.index, ++this.lineNumber, this.lineStart = this.index, C = !0;
                  else if (E === 47)
                    if (E = this.source.charCodeAt(this.index + 1), E === 47) {
                      this.index += 2;
                      var l = this.skipSingleLineComment(2);
                      this.trackComment && (c = c.concat(l)), C = !0;
                    } else if (E === 42) {
                      this.index += 2;
                      var l = this.skipMultiLineComment();
                      this.trackComment && (c = c.concat(l));
                    } else
                      break;
                  else if (C && E === 45)
                    if (this.source.charCodeAt(this.index + 1) === 45 && this.source.charCodeAt(this.index + 2) === 62) {
                      this.index += 3;
                      var l = this.skipSingleLineComment(3);
                      this.trackComment && (c = c.concat(l));
                    } else
                      break;
                  else if (E === 60 && !this.isModule)
                    if (this.source.slice(this.index + 1, this.index + 4) === "!--") {
                      this.index += 4;
                      var l = this.skipSingleLineComment(4);
                      this.trackComment && (c = c.concat(l));
                    } else
                      break;
                  else
                    break;
                }
                return c;
              }, I.prototype.isFutureReservedWord = function(c) {
                switch (c) {
                  case "enum":
                  case "export":
                  case "import":
                  case "super":
                    return !0;
                  default:
                    return !1;
                }
              }, I.prototype.isStrictModeReservedWord = function(c) {
                switch (c) {
                  case "implements":
                  case "interface":
                  case "package":
                  case "private":
                  case "protected":
                  case "public":
                  case "static":
                  case "yield":
                  case "let":
                    return !0;
                  default:
                    return !1;
                }
              }, I.prototype.isRestrictedWord = function(c) {
                return c === "eval" || c === "arguments";
              }, I.prototype.isKeyword = function(c) {
                switch (c.length) {
                  case 2:
                    return c === "if" || c === "in" || c === "do";
                  case 3:
                    return c === "var" || c === "for" || c === "new" || c === "try" || c === "let";
                  case 4:
                    return c === "this" || c === "else" || c === "case" || c === "void" || c === "with" || c === "enum";
                  case 5:
                    return c === "while" || c === "break" || c === "catch" || c === "throw" || c === "const" || c === "yield" || c === "class" || c === "super";
                  case 6:
                    return c === "return" || c === "typeof" || c === "delete" || c === "switch" || c === "export" || c === "import";
                  case 7:
                    return c === "default" || c === "finally" || c === "extends";
                  case 8:
                    return c === "function" || c === "continue" || c === "debugger";
                  case 10:
                    return c === "instanceof";
                  default:
                    return !1;
                }
              }, I.prototype.codePointAt = function(c) {
                var C = this.source.charCodeAt(c);
                if (C >= 55296 && C <= 56319) {
                  var E = this.source.charCodeAt(c + 1);
                  if (E >= 56320 && E <= 57343) {
                    var l = C;
                    C = (l - 55296) * 1024 + E - 56320 + 65536;
                  }
                }
                return C;
              }, I.prototype.scanHexEscape = function(c) {
                for (var C = c === "u" ? 4 : 2, E = 0, l = 0; l < C; ++l)
                  if (!this.eof() && s.Character.isHexDigit(this.source.charCodeAt(this.index)))
                    E = E * 16 + g(this.source[this.index++]);
                  else
                    return null;
                return String.fromCharCode(E);
              }, I.prototype.scanUnicodeCodePointEscape = function() {
                var c = this.source[this.index], C = 0;
                for (c === "}" && this.throwUnexpectedToken(); !this.eof() && (c = this.source[this.index++], !!s.Character.isHexDigit(c.charCodeAt(0))); )
                  C = C * 16 + g(c);
                return (C > 1114111 || c !== "}") && this.throwUnexpectedToken(), s.Character.fromCodePoint(C);
              }, I.prototype.getIdentifier = function() {
                for (var c = this.index++; !this.eof(); ) {
                  var C = this.source.charCodeAt(this.index);
                  if (C === 92)
                    return this.index = c, this.getComplexIdentifier();
                  if (C >= 55296 && C < 57343)
                    return this.index = c, this.getComplexIdentifier();
                  if (s.Character.isIdentifierPart(C))
                    ++this.index;
                  else
                    break;
                }
                return this.source.slice(c, this.index);
              }, I.prototype.getComplexIdentifier = function() {
                var c = this.codePointAt(this.index), C = s.Character.fromCodePoint(c);
                this.index += C.length;
                var E;
                for (c === 92 && (this.source.charCodeAt(this.index) !== 117 && this.throwUnexpectedToken(), ++this.index, this.source[this.index] === "{" ? (++this.index, E = this.scanUnicodeCodePointEscape()) : (E = this.scanHexEscape("u"), (E === null || E === "\\" || !s.Character.isIdentifierStart(E.charCodeAt(0))) && this.throwUnexpectedToken()), C = E); !this.eof() && (c = this.codePointAt(this.index), !!s.Character.isIdentifierPart(c)); )
                  E = s.Character.fromCodePoint(c), C += E, this.index += E.length, c === 92 && (C = C.substr(0, C.length - 1), this.source.charCodeAt(this.index) !== 117 && this.throwUnexpectedToken(), ++this.index, this.source[this.index] === "{" ? (++this.index, E = this.scanUnicodeCodePointEscape()) : (E = this.scanHexEscape("u"), (E === null || E === "\\" || !s.Character.isIdentifierPart(E.charCodeAt(0))) && this.throwUnexpectedToken()), C += E);
                return C;
              }, I.prototype.octalToDecimal = function(c) {
                var C = c !== "0", E = o(c);
                return !this.eof() && s.Character.isOctalDigit(this.source.charCodeAt(this.index)) && (C = !0, E = E * 8 + o(this.source[this.index++]), "0123".indexOf(c) >= 0 && !this.eof() && s.Character.isOctalDigit(this.source.charCodeAt(this.index)) && (E = E * 8 + o(this.source[this.index++]))), {
                  code: E,
                  octal: C
                };
              }, I.prototype.scanIdentifier = function() {
                var c, C = this.index, E = this.source.charCodeAt(C) === 92 ? this.getComplexIdentifier() : this.getIdentifier();
                if (E.length === 1 ? c = 3 : this.isKeyword(E) ? c = 4 : E === "null" ? c = 5 : E === "true" || E === "false" ? c = 1 : c = 3, c !== 3 && C + E.length !== this.index) {
                  var l = this.index;
                  this.index = C, this.tolerateUnexpectedToken(a.Messages.InvalidEscapedReservedWord), this.index = l;
                }
                return {
                  type: c,
                  value: E,
                  lineNumber: this.lineNumber,
                  lineStart: this.lineStart,
                  start: C,
                  end: this.index
                };
              }, I.prototype.scanPunctuator = function() {
                var c = this.index, C = this.source[this.index];
                switch (C) {
                  case "(":
                  case "{":
                    C === "{" && this.curlyStack.push("{"), ++this.index;
                    break;
                  case ".":
                    ++this.index, this.source[this.index] === "." && this.source[this.index + 1] === "." && (this.index += 2, C = "...");
                    break;
                  case "}":
                    ++this.index, this.curlyStack.pop();
                    break;
                  case ")":
                  case ";":
                  case ",":
                  case "[":
                  case "]":
                  case ":":
                  case "?":
                  case "~":
                    ++this.index;
                    break;
                  default:
                    C = this.source.substr(this.index, 4), C === ">>>=" ? this.index += 4 : (C = C.substr(0, 3), C === "===" || C === "!==" || C === ">>>" || C === "<<=" || C === ">>=" || C === "**=" ? this.index += 3 : (C = C.substr(0, 2), C === "&&" || C === "||" || C === "==" || C === "!=" || C === "+=" || C === "-=" || C === "*=" || C === "/=" || C === "++" || C === "--" || C === "<<" || C === ">>" || C === "&=" || C === "|=" || C === "^=" || C === "%=" || C === "<=" || C === ">=" || C === "=>" || C === "**" ? this.index += 2 : (C = this.source[this.index], "<>=!+-*%&|^/".indexOf(C) >= 0 && ++this.index)));
                }
                return this.index === c && this.throwUnexpectedToken(), {
                  type: 7,
                  value: C,
                  lineNumber: this.lineNumber,
                  lineStart: this.lineStart,
                  start: c,
                  end: this.index
                };
              }, I.prototype.scanHexLiteral = function(c) {
                for (var C = ""; !this.eof() && s.Character.isHexDigit(this.source.charCodeAt(this.index)); )
                  C += this.source[this.index++];
                return C.length === 0 && this.throwUnexpectedToken(), s.Character.isIdentifierStart(this.source.charCodeAt(this.index)) && this.throwUnexpectedToken(), {
                  type: 6,
                  value: parseInt("0x" + C, 16),
                  lineNumber: this.lineNumber,
                  lineStart: this.lineStart,
                  start: c,
                  end: this.index
                };
              }, I.prototype.scanBinaryLiteral = function(c) {
                for (var C = "", E; !this.eof() && (E = this.source[this.index], !(E !== "0" && E !== "1")); )
                  C += this.source[this.index++];
                return C.length === 0 && this.throwUnexpectedToken(), this.eof() || (E = this.source.charCodeAt(this.index), (s.Character.isIdentifierStart(E) || s.Character.isDecimalDigit(E)) && this.throwUnexpectedToken()), {
                  type: 6,
                  value: parseInt(C, 2),
                  lineNumber: this.lineNumber,
                  lineStart: this.lineStart,
                  start: c,
                  end: this.index
                };
              }, I.prototype.scanOctalLiteral = function(c, C) {
                var E = "", l = !1;
                for (s.Character.isOctalDigit(c.charCodeAt(0)) ? (l = !0, E = "0" + this.source[this.index++]) : ++this.index; !this.eof() && s.Character.isOctalDigit(this.source.charCodeAt(this.index)); )
                  E += this.source[this.index++];
                return !l && E.length === 0 && this.throwUnexpectedToken(), (s.Character.isIdentifierStart(this.source.charCodeAt(this.index)) || s.Character.isDecimalDigit(this.source.charCodeAt(this.index))) && this.throwUnexpectedToken(), {
                  type: 6,
                  value: parseInt(E, 8),
                  octal: l,
                  lineNumber: this.lineNumber,
                  lineStart: this.lineStart,
                  start: C,
                  end: this.index
                };
              }, I.prototype.isImplicitOctalLiteral = function() {
                for (var c = this.index + 1; c < this.length; ++c) {
                  var C = this.source[c];
                  if (C === "8" || C === "9")
                    return !1;
                  if (!s.Character.isOctalDigit(C.charCodeAt(0)))
                    return !0;
                }
                return !0;
              }, I.prototype.scanNumericLiteral = function() {
                var c = this.index, C = this.source[c];
                n.assert(s.Character.isDecimalDigit(C.charCodeAt(0)) || C === ".", "Numeric literal must start with a decimal digit or a decimal point");
                var E = "";
                if (C !== ".") {
                  if (E = this.source[this.index++], C = this.source[this.index], E === "0") {
                    if (C === "x" || C === "X")
                      return ++this.index, this.scanHexLiteral(c);
                    if (C === "b" || C === "B")
                      return ++this.index, this.scanBinaryLiteral(c);
                    if (C === "o" || C === "O")
                      return this.scanOctalLiteral(C, c);
                    if (C && s.Character.isOctalDigit(C.charCodeAt(0)) && this.isImplicitOctalLiteral())
                      return this.scanOctalLiteral(C, c);
                  }
                  for (; s.Character.isDecimalDigit(this.source.charCodeAt(this.index)); )
                    E += this.source[this.index++];
                  C = this.source[this.index];
                }
                if (C === ".") {
                  for (E += this.source[this.index++]; s.Character.isDecimalDigit(this.source.charCodeAt(this.index)); )
                    E += this.source[this.index++];
                  C = this.source[this.index];
                }
                if (C === "e" || C === "E")
                  if (E += this.source[this.index++], C = this.source[this.index], (C === "+" || C === "-") && (E += this.source[this.index++]), s.Character.isDecimalDigit(this.source.charCodeAt(this.index)))
                    for (; s.Character.isDecimalDigit(this.source.charCodeAt(this.index)); )
                      E += this.source[this.index++];
                  else
                    this.throwUnexpectedToken();
                return s.Character.isIdentifierStart(this.source.charCodeAt(this.index)) && this.throwUnexpectedToken(), {
                  type: 6,
                  value: parseFloat(E),
                  lineNumber: this.lineNumber,
                  lineStart: this.lineStart,
                  start: c,
                  end: this.index
                };
              }, I.prototype.scanStringLiteral = function() {
                var c = this.index, C = this.source[c];
                n.assert(C === "'" || C === '"', "String literal must starts with a quote"), ++this.index;
                for (var E = !1, l = ""; !this.eof(); ) {
                  var B = this.source[this.index++];
                  if (B === C) {
                    C = "";
                    break;
                  } else if (B === "\\")
                    if (B = this.source[this.index++], !B || !s.Character.isLineTerminator(B.charCodeAt(0)))
                      switch (B) {
                        case "u":
                          if (this.source[this.index] === "{")
                            ++this.index, l += this.scanUnicodeCodePointEscape();
                          else {
                            var h = this.scanHexEscape(B);
                            h === null && this.throwUnexpectedToken(), l += h;
                          }
                          break;
                        case "x":
                          var Q = this.scanHexEscape(B);
                          Q === null && this.throwUnexpectedToken(a.Messages.InvalidHexEscapeSequence), l += Q;
                          break;
                        case "n":
                          l += `
`;
                          break;
                        case "r":
                          l += "\r";
                          break;
                        case "t":
                          l += "	";
                          break;
                        case "b":
                          l += "\b";
                          break;
                        case "f":
                          l += "\f";
                          break;
                        case "v":
                          l += "\v";
                          break;
                        case "8":
                        case "9":
                          l += B, this.tolerateUnexpectedToken();
                          break;
                        default:
                          if (B && s.Character.isOctalDigit(B.charCodeAt(0))) {
                            var f = this.octalToDecimal(B);
                            E = f.octal || E, l += String.fromCharCode(f.code);
                          } else
                            l += B;
                          break;
                      }
                    else
                      ++this.lineNumber, B === "\r" && this.source[this.index] === `
` && ++this.index, this.lineStart = this.index;
                  else {
                    if (s.Character.isLineTerminator(B.charCodeAt(0)))
                      break;
                    l += B;
                  }
                }
                return C !== "" && (this.index = c, this.throwUnexpectedToken()), {
                  type: 8,
                  value: l,
                  octal: E,
                  lineNumber: this.lineNumber,
                  lineStart: this.lineStart,
                  start: c,
                  end: this.index
                };
              }, I.prototype.scanTemplate = function() {
                var c = "", C = !1, E = this.index, l = this.source[E] === "`", B = !1, h = 2;
                for (++this.index; !this.eof(); ) {
                  var Q = this.source[this.index++];
                  if (Q === "`") {
                    h = 1, B = !0, C = !0;
                    break;
                  } else if (Q === "$") {
                    if (this.source[this.index] === "{") {
                      this.curlyStack.push("${"), ++this.index, C = !0;
                      break;
                    }
                    c += Q;
                  } else if (Q === "\\")
                    if (Q = this.source[this.index++], s.Character.isLineTerminator(Q.charCodeAt(0)))
                      ++this.lineNumber, Q === "\r" && this.source[this.index] === `
` && ++this.index, this.lineStart = this.index;
                    else
                      switch (Q) {
                        case "n":
                          c += `
`;
                          break;
                        case "r":
                          c += "\r";
                          break;
                        case "t":
                          c += "	";
                          break;
                        case "u":
                          if (this.source[this.index] === "{")
                            ++this.index, c += this.scanUnicodeCodePointEscape();
                          else {
                            var f = this.index, p = this.scanHexEscape(Q);
                            p !== null ? c += p : (this.index = f, c += Q);
                          }
                          break;
                        case "x":
                          var y = this.scanHexEscape(Q);
                          y === null && this.throwUnexpectedToken(a.Messages.InvalidHexEscapeSequence), c += y;
                          break;
                        case "b":
                          c += "\b";
                          break;
                        case "f":
                          c += "\f";
                          break;
                        case "v":
                          c += "\v";
                          break;
                        default:
                          Q === "0" ? (s.Character.isDecimalDigit(this.source.charCodeAt(this.index)) && this.throwUnexpectedToken(a.Messages.TemplateOctalLiteral), c += "\0") : s.Character.isOctalDigit(Q.charCodeAt(0)) ? this.throwUnexpectedToken(a.Messages.TemplateOctalLiteral) : c += Q;
                          break;
                      }
                  else s.Character.isLineTerminator(Q.charCodeAt(0)) ? (++this.lineNumber, Q === "\r" && this.source[this.index] === `
` && ++this.index, this.lineStart = this.index, c += `
`) : c += Q;
                }
                return C || this.throwUnexpectedToken(), l || this.curlyStack.pop(), {
                  type: 10,
                  value: this.source.slice(E + 1, this.index - h),
                  cooked: c,
                  head: l,
                  tail: B,
                  lineNumber: this.lineNumber,
                  lineStart: this.lineStart,
                  start: E,
                  end: this.index
                };
              }, I.prototype.testRegExp = function(c, C) {
                var E = "ï¿¿", l = c, B = this;
                C.indexOf("u") >= 0 && (l = l.replace(/\\u\{([0-9a-fA-F]+)\}|\\u([a-fA-F0-9]{4})/g, function(h, Q, f) {
                  var p = parseInt(Q || f, 16);
                  return p > 1114111 && B.throwUnexpectedToken(a.Messages.InvalidRegExp), p <= 65535 ? String.fromCharCode(p) : E;
                }).replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, E));
                try {
                  RegExp(l);
                } catch {
                  this.throwUnexpectedToken(a.Messages.InvalidRegExp);
                }
                try {
                  return new RegExp(c, C);
                } catch {
                  return null;
                }
              }, I.prototype.scanRegExpBody = function() {
                var c = this.source[this.index];
                n.assert(c === "/", "Regular expression literal must start with a slash");
                for (var C = this.source[this.index++], E = !1, l = !1; !this.eof(); )
                  if (c = this.source[this.index++], C += c, c === "\\")
                    c = this.source[this.index++], s.Character.isLineTerminator(c.charCodeAt(0)) && this.throwUnexpectedToken(a.Messages.UnterminatedRegExp), C += c;
                  else if (s.Character.isLineTerminator(c.charCodeAt(0)))
                    this.throwUnexpectedToken(a.Messages.UnterminatedRegExp);
                  else if (E)
                    c === "]" && (E = !1);
                  else if (c === "/") {
                    l = !0;
                    break;
                  } else c === "[" && (E = !0);
                return l || this.throwUnexpectedToken(a.Messages.UnterminatedRegExp), C.substr(1, C.length - 2);
              }, I.prototype.scanRegExpFlags = function() {
                for (var c = "", C = ""; !this.eof(); ) {
                  var E = this.source[this.index];
                  if (!s.Character.isIdentifierPart(E.charCodeAt(0)))
                    break;
                  if (++this.index, E === "\\" && !this.eof())
                    if (E = this.source[this.index], E === "u") {
                      ++this.index;
                      var l = this.index, B = this.scanHexEscape("u");
                      if (B !== null)
                        for (C += B, c += "\\u"; l < this.index; ++l)
                          c += this.source[l];
                      else
                        this.index = l, C += "u", c += "\\u";
                      this.tolerateUnexpectedToken();
                    } else
                      c += "\\", this.tolerateUnexpectedToken();
                  else
                    C += E, c += E;
                }
                return C;
              }, I.prototype.scanRegExp = function() {
                var c = this.index, C = this.scanRegExpBody(), E = this.scanRegExpFlags(), l = this.testRegExp(C, E);
                return {
                  type: 9,
                  value: "",
                  pattern: C,
                  flags: E,
                  regex: l,
                  lineNumber: this.lineNumber,
                  lineStart: this.lineStart,
                  start: c,
                  end: this.index
                };
              }, I.prototype.lex = function() {
                if (this.eof())
                  return {
                    type: 2,
                    value: "",
                    lineNumber: this.lineNumber,
                    lineStart: this.lineStart,
                    start: this.index,
                    end: this.index
                  };
                var c = this.source.charCodeAt(this.index);
                return s.Character.isIdentifierStart(c) ? this.scanIdentifier() : c === 40 || c === 41 || c === 59 ? this.scanPunctuator() : c === 39 || c === 34 ? this.scanStringLiteral() : c === 46 ? s.Character.isDecimalDigit(this.source.charCodeAt(this.index + 1)) ? this.scanNumericLiteral() : this.scanPunctuator() : s.Character.isDecimalDigit(c) ? this.scanNumericLiteral() : c === 96 || c === 125 && this.curlyStack[this.curlyStack.length - 1] === "${" ? this.scanTemplate() : c >= 55296 && c < 57343 && s.Character.isIdentifierStart(this.codePointAt(this.index)) ? this.scanIdentifier() : this.scanPunctuator();
              }, I;
            }();
            r.Scanner = u;
          },
          /* 13 */
          /***/
          function(e, r) {
            Object.defineProperty(r, "__esModule", { value: !0 }), r.TokenName = {}, r.TokenName[
              1
              /* BooleanLiteral */
            ] = "Boolean", r.TokenName[
              2
              /* EOF */
            ] = "<end>", r.TokenName[
              3
              /* Identifier */
            ] = "Identifier", r.TokenName[
              4
              /* Keyword */
            ] = "Keyword", r.TokenName[
              5
              /* NullLiteral */
            ] = "Null", r.TokenName[
              6
              /* NumericLiteral */
            ] = "Numeric", r.TokenName[
              7
              /* Punctuator */
            ] = "Punctuator", r.TokenName[
              8
              /* StringLiteral */
            ] = "String", r.TokenName[
              9
              /* RegularExpression */
            ] = "RegularExpression", r.TokenName[
              10
              /* Template */
            ] = "Template";
          },
          /* 14 */
          /***/
          function(e, r) {
            Object.defineProperty(r, "__esModule", { value: !0 }), r.XHTMLEntities = {
              quot: '"',
              amp: "&",
              apos: "'",
              gt: ">",
              nbsp: "Â ",
              iexcl: "Â¡",
              cent: "Â¢",
              pound: "Â£",
              curren: "Â¤",
              yen: "Â¥",
              brvbar: "Â¦",
              sect: "Â§",
              uml: "Â¨",
              copy: "Â©",
              ordf: "Âª",
              laquo: "Â«",
              not: "Â¬",
              shy: "Â­",
              reg: "Â®",
              macr: "Â¯",
              deg: "Â°",
              plusmn: "Â±",
              sup2: "Â²",
              sup3: "Â³",
              acute: "Â´",
              micro: "Âµ",
              para: "Â¶",
              middot: "Â·",
              cedil: "Â¸",
              sup1: "Â¹",
              ordm: "Âº",
              raquo: "Â»",
              frac14: "Â¼",
              frac12: "Â½",
              frac34: "Â¾",
              iquest: "Â¿",
              Agrave: "Ã€",
              Aacute: "Ã",
              Acirc: "Ã‚",
              Atilde: "Ãƒ",
              Auml: "Ã„",
              Aring: "Ã…",
              AElig: "Ã†",
              Ccedil: "Ã‡",
              Egrave: "Ãˆ",
              Eacute: "Ã‰",
              Ecirc: "ÃŠ",
              Euml: "Ã‹",
              Igrave: "ÃŒ",
              Iacute: "Ã",
              Icirc: "ÃŽ",
              Iuml: "Ã",
              ETH: "Ã",
              Ntilde: "Ã‘",
              Ograve: "Ã’",
              Oacute: "Ã“",
              Ocirc: "Ã”",
              Otilde: "Ã•",
              Ouml: "Ã–",
              times: "Ã—",
              Oslash: "Ã˜",
              Ugrave: "Ã™",
              Uacute: "Ãš",
              Ucirc: "Ã›",
              Uuml: "Ãœ",
              Yacute: "Ã",
              THORN: "Ãž",
              szlig: "ÃŸ",
              agrave: "Ã ",
              aacute: "Ã¡",
              acirc: "Ã¢",
              atilde: "Ã£",
              auml: "Ã¤",
              aring: "Ã¥",
              aelig: "Ã¦",
              ccedil: "Ã§",
              egrave: "Ã¨",
              eacute: "Ã©",
              ecirc: "Ãª",
              euml: "Ã«",
              igrave: "Ã¬",
              iacute: "Ã­",
              icirc: "Ã®",
              iuml: "Ã¯",
              eth: "Ã°",
              ntilde: "Ã±",
              ograve: "Ã²",
              oacute: "Ã³",
              ocirc: "Ã´",
              otilde: "Ãµ",
              ouml: "Ã¶",
              divide: "Ã·",
              oslash: "Ã¸",
              ugrave: "Ã¹",
              uacute: "Ãº",
              ucirc: "Ã»",
              uuml: "Ã¼",
              yacute: "Ã½",
              thorn: "Ã¾",
              yuml: "Ã¿",
              OElig: "Å’",
              oelig: "Å“",
              Scaron: "Å ",
              scaron: "Å¡",
              Yuml: "Å¸",
              fnof: "Æ’",
              circ: "Ë†",
              tilde: "Ëœ",
              Alpha: "Î‘",
              Beta: "Î’",
              Gamma: "Î“",
              Delta: "Î”",
              Epsilon: "Î•",
              Zeta: "Î–",
              Eta: "Î—",
              Theta: "Î˜",
              Iota: "Î™",
              Kappa: "Îš",
              Lambda: "Î›",
              Mu: "Îœ",
              Nu: "Î",
              Xi: "Îž",
              Omicron: "ÎŸ",
              Pi: "Î ",
              Rho: "Î¡",
              Sigma: "Î£",
              Tau: "Î¤",
              Upsilon: "Î¥",
              Phi: "Î¦",
              Chi: "Î§",
              Psi: "Î¨",
              Omega: "Î©",
              alpha: "Î±",
              beta: "Î²",
              gamma: "Î³",
              delta: "Î´",
              epsilon: "Îµ",
              zeta: "Î¶",
              eta: "Î·",
              theta: "Î¸",
              iota: "Î¹",
              kappa: "Îº",
              lambda: "Î»",
              mu: "Î¼",
              nu: "Î½",
              xi: "Î¾",
              omicron: "Î¿",
              pi: "Ï€",
              rho: "Ï",
              sigmaf: "Ï‚",
              sigma: "Ïƒ",
              tau: "Ï„",
              upsilon: "Ï…",
              phi: "Ï†",
              chi: "Ï‡",
              psi: "Ïˆ",
              omega: "Ï‰",
              thetasym: "Ï‘",
              upsih: "Ï’",
              piv: "Ï–",
              ensp: "â€‚",
              emsp: "â€ƒ",
              thinsp: "â€‰",
              zwnj: "â€Œ",
              zwj: "â€",
              lrm: "â€Ž",
              rlm: "â€",
              ndash: "â€“",
              mdash: "â€”",
              lsquo: "â€˜",
              rsquo: "â€™",
              sbquo: "â€š",
              ldquo: "â€œ",
              rdquo: "â€",
              bdquo: "â€ž",
              dagger: "â€ ",
              Dagger: "â€¡",
              bull: "â€¢",
              hellip: "â€¦",
              permil: "â€°",
              prime: "â€²",
              Prime: "â€³",
              lsaquo: "â€¹",
              rsaquo: "â€º",
              oline: "â€¾",
              frasl: "â„",
              euro: "â‚¬",
              image: "â„‘",
              weierp: "â„˜",
              real: "â„œ",
              trade: "â„¢",
              alefsym: "â„µ",
              larr: "â†",
              uarr: "â†‘",
              rarr: "â†’",
              darr: "â†“",
              harr: "â†”",
              crarr: "â†µ",
              lArr: "â‡",
              uArr: "â‡‘",
              rArr: "â‡’",
              dArr: "â‡“",
              hArr: "â‡”",
              forall: "âˆ€",
              part: "âˆ‚",
              exist: "âˆƒ",
              empty: "âˆ…",
              nabla: "âˆ‡",
              isin: "âˆˆ",
              notin: "âˆ‰",
              ni: "âˆ‹",
              prod: "âˆ",
              sum: "âˆ‘",
              minus: "âˆ’",
              lowast: "âˆ—",
              radic: "âˆš",
              prop: "âˆ",
              infin: "âˆž",
              ang: "âˆ ",
              and: "âˆ§",
              or: "âˆ¨",
              cap: "âˆ©",
              cup: "âˆª",
              int: "âˆ«",
              there4: "âˆ´",
              sim: "âˆ¼",
              cong: "â‰…",
              asymp: "â‰ˆ",
              ne: "â‰ ",
              equiv: "â‰¡",
              le: "â‰¤",
              ge: "â‰¥",
              sub: "âŠ‚",
              sup: "âŠƒ",
              nsub: "âŠ„",
              sube: "âŠ†",
              supe: "âŠ‡",
              oplus: "âŠ•",
              otimes: "âŠ—",
              perp: "âŠ¥",
              sdot: "â‹…",
              lceil: "âŒˆ",
              rceil: "âŒ‰",
              lfloor: "âŒŠ",
              rfloor: "âŒ‹",
              loz: "â—Š",
              spades: "â™ ",
              clubs: "â™£",
              hearts: "â™¥",
              diams: "â™¦",
              lang: "âŸ¨",
              rang: "âŸ©"
            };
          },
          /* 15 */
          /***/
          function(e, r, i) {
            Object.defineProperty(r, "__esModule", { value: !0 });
            var n = i(10), s = i(12), a = i(13), g = function() {
              function u() {
                this.values = [], this.curly = this.paren = -1;
              }
              return u.prototype.beforeFunctionExpression = function(I) {
                return [
                  "(",
                  "{",
                  "[",
                  "in",
                  "typeof",
                  "instanceof",
                  "new",
                  "return",
                  "case",
                  "delete",
                  "throw",
                  "void",
                  // assignment operators
                  "=",
                  "+=",
                  "-=",
                  "*=",
                  "**=",
                  "/=",
                  "%=",
                  "<<=",
                  ">>=",
                  ">>>=",
                  "&=",
                  "|=",
                  "^=",
                  ",",
                  // binary/unary operators
                  "+",
                  "-",
                  "*",
                  "**",
                  "/",
                  "%",
                  "++",
                  "--",
                  "<<",
                  ">>",
                  ">>>",
                  "&",
                  "|",
                  "^",
                  "!",
                  "~",
                  "&&",
                  "||",
                  "?",
                  ":",
                  "===",
                  "==",
                  ">=",
                  "<=",
                  "<",
                  ">",
                  "!=",
                  "!=="
                ].indexOf(I) >= 0;
              }, u.prototype.isRegexStart = function() {
                var I = this.values[this.values.length - 1], c = I !== null;
                switch (I) {
                  case "this":
                  case "]":
                    c = !1;
                    break;
                  case ")":
                    var C = this.values[this.paren - 1];
                    c = C === "if" || C === "while" || C === "for" || C === "with";
                    break;
                  case "}":
                    if (c = !1, this.values[this.curly - 3] === "function") {
                      var E = this.values[this.curly - 4];
                      c = E ? !this.beforeFunctionExpression(E) : !1;
                    } else if (this.values[this.curly - 4] === "function") {
                      var E = this.values[this.curly - 5];
                      c = E ? !this.beforeFunctionExpression(E) : !0;
                    }
                    break;
                }
                return c;
              }, u.prototype.push = function(I) {
                I.type === 7 || I.type === 4 ? (I.value === "{" ? this.curly = this.values.length : I.value === "(" && (this.paren = this.values.length), this.values.push(I.value)) : this.values.push(null);
              }, u;
            }(), o = function() {
              function u(I, c) {
                this.errorHandler = new n.ErrorHandler(), this.errorHandler.tolerant = c ? typeof c.tolerant == "boolean" && c.tolerant : !1, this.scanner = new s.Scanner(I, this.errorHandler), this.scanner.trackComment = c ? typeof c.comment == "boolean" && c.comment : !1, this.trackRange = c ? typeof c.range == "boolean" && c.range : !1, this.trackLoc = c ? typeof c.loc == "boolean" && c.loc : !1, this.buffer = [], this.reader = new g();
              }
              return u.prototype.errors = function() {
                return this.errorHandler.errors;
              }, u.prototype.getNextToken = function() {
                if (this.buffer.length === 0) {
                  var I = this.scanner.scanComments();
                  if (this.scanner.trackComment)
                    for (var c = 0; c < I.length; ++c) {
                      var C = I[c], E = this.scanner.source.slice(C.slice[0], C.slice[1]), l = {
                        type: C.multiLine ? "BlockComment" : "LineComment",
                        value: E
                      };
                      this.trackRange && (l.range = C.range), this.trackLoc && (l.loc = C.loc), this.buffer.push(l);
                    }
                  if (!this.scanner.eof()) {
                    var B = void 0;
                    this.trackLoc && (B = {
                      start: {
                        line: this.scanner.lineNumber,
                        column: this.scanner.index - this.scanner.lineStart
                      },
                      end: {}
                    });
                    var h = this.scanner.source[this.scanner.index] === "/" && this.reader.isRegexStart(), Q = h ? this.scanner.scanRegExp() : this.scanner.lex();
                    this.reader.push(Q);
                    var f = {
                      type: a.TokenName[Q.type],
                      value: this.scanner.source.slice(Q.start, Q.end)
                    };
                    if (this.trackRange && (f.range = [Q.start, Q.end]), this.trackLoc && (B.end = {
                      line: this.scanner.lineNumber,
                      column: this.scanner.index - this.scanner.lineStart
                    }, f.loc = B), Q.type === 9) {
                      var p = Q.pattern, y = Q.flags;
                      f.regex = { pattern: p, flags: y };
                    }
                    this.buffer.push(f);
                  }
                }
                return this.buffer.shift();
              }, u;
            }();
            r.Tokenizer = o;
          }
          /******/
        ])
      );
    });
  }(ow)), ow.exports;
}
var gw = {}, TD = function(t, A) {
  return TD = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {
    e.__proto__ = r;
  } || function(e, r) {
    for (var i in r) Object.prototype.hasOwnProperty.call(r, i) && (e[i] = r[i]);
  }, TD(t, A);
};
function zT(t, A) {
  if (typeof A != "function" && A !== null)
    throw new TypeError("Class extends value " + String(A) + " is not a constructor or null");
  TD(t, A);
  function e() {
    this.constructor = t;
  }
  t.prototype = A === null ? Object.create(A) : (e.prototype = A.prototype, new e());
}
var sf = function() {
  return sf = Object.assign || function(A) {
    for (var e, r = 1, i = arguments.length; r < i; r++) {
      e = arguments[r];
      for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && (A[n] = e[n]);
    }
    return A;
  }, sf.apply(this, arguments);
};
function $T(t, A) {
  var e = {};
  for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && A.indexOf(r) < 0 && (e[r] = t[r]);
  if (t != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
      A.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(t, r[i]) && (e[r[i]] = t[r[i]]);
  return e;
}
function AK(t, A, e, r) {
  var i = arguments.length, n = i < 3 ? A : r === null ? r = Object.getOwnPropertyDescriptor(A, e) : r, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") n = Reflect.decorate(t, A, e, r);
  else for (var a = t.length - 1; a >= 0; a--) (s = t[a]) && (n = (i < 3 ? s(n) : i > 3 ? s(A, e, n) : s(A, e)) || n);
  return i > 3 && n && Object.defineProperty(A, e, n), n;
}
function eK(t, A) {
  return function(e, r) {
    A(e, r, t);
  };
}
function tK(t, A, e, r, i, n) {
  function s(h) {
    if (h !== void 0 && typeof h != "function") throw new TypeError("Function expected");
    return h;
  }
  for (var a = r.kind, g = a === "getter" ? "get" : a === "setter" ? "set" : "value", o = !A && t ? r.static ? t : t.prototype : null, u = A || (o ? Object.getOwnPropertyDescriptor(o, r.name) : {}), I, c = !1, C = e.length - 1; C >= 0; C--) {
    var E = {};
    for (var l in r) E[l] = l === "access" ? {} : r[l];
    for (var l in r.access) E.access[l] = r.access[l];
    E.addInitializer = function(h) {
      if (c) throw new TypeError("Cannot add initializers after decoration has completed");
      n.push(s(h || null));
    };
    var B = (0, e[C])(a === "accessor" ? { get: u.get, set: u.set } : u[g], E);
    if (a === "accessor") {
      if (B === void 0) continue;
      if (B === null || typeof B != "object") throw new TypeError("Object expected");
      (I = s(B.get)) && (u.get = I), (I = s(B.set)) && (u.set = I), (I = s(B.init)) && i.unshift(I);
    } else (I = s(B)) && (a === "field" ? i.unshift(I) : u[g] = I);
  }
  o && Object.defineProperty(o, r.name, u), c = !0;
}
function rK(t, A, e) {
  for (var r = arguments.length > 2, i = 0; i < A.length; i++)
    e = r ? A[i].call(t, e) : A[i].call(t);
  return r ? e : void 0;
}
function iK(t) {
  return typeof t == "symbol" ? t : "".concat(t);
}
function nK(t, A, e) {
  return typeof A == "symbol" && (A = A.description ? "[".concat(A.description, "]") : ""), Object.defineProperty(t, "name", { configurable: !0, value: e ? "".concat(e, " ", A) : A });
}
function sK(t, A) {
  if (typeof Reflect == "object" && typeof Reflect.metadata == "function") return Reflect.metadata(t, A);
}
function aK(t, A, e, r) {
  function i(n) {
    return n instanceof e ? n : new e(function(s) {
      s(n);
    });
  }
  return new (e || (e = Promise))(function(n, s) {
    function a(u) {
      try {
        o(r.next(u));
      } catch (I) {
        s(I);
      }
    }
    function g(u) {
      try {
        o(r.throw(u));
      } catch (I) {
        s(I);
      }
    }
    function o(u) {
      u.done ? n(u.value) : i(u.value).then(a, g);
    }
    o((r = r.apply(t, A || [])).next());
  });
}
function oK(t, A) {
  var e = { label: 0, sent: function() {
    if (n[0] & 1) throw n[1];
    return n[1];
  }, trys: [], ops: [] }, r, i, n, s = Object.create((typeof Iterator == "function" ? Iterator : Object).prototype);
  return s.next = a(0), s.throw = a(1), s.return = a(2), typeof Symbol == "function" && (s[Symbol.iterator] = function() {
    return this;
  }), s;
  function a(o) {
    return function(u) {
      return g([o, u]);
    };
  }
  function g(o) {
    if (r) throw new TypeError("Generator is already executing.");
    for (; s && (s = 0, o[0] && (e = 0)), e; ) try {
      if (r = 1, i && (n = o[0] & 2 ? i.return : o[0] ? i.throw || ((n = i.return) && n.call(i), 0) : i.next) && !(n = n.call(i, o[1])).done) return n;
      switch (i = 0, n && (o = [o[0] & 2, n.value]), o[0]) {
        case 0:
        case 1:
          n = o;
          break;
        case 4:
          return e.label++, { value: o[1], done: !1 };
        case 5:
          e.label++, i = o[1], o = [0];
          continue;
        case 7:
          o = e.ops.pop(), e.trys.pop();
          continue;
        default:
          if (n = e.trys, !(n = n.length > 0 && n[n.length - 1]) && (o[0] === 6 || o[0] === 2)) {
            e = 0;
            continue;
          }
          if (o[0] === 3 && (!n || o[1] > n[0] && o[1] < n[3])) {
            e.label = o[1];
            break;
          }
          if (o[0] === 6 && e.label < n[1]) {
            e.label = n[1], n = o;
            break;
          }
          if (n && e.label < n[2]) {
            e.label = n[2], e.ops.push(o);
            break;
          }
          n[2] && e.ops.pop(), e.trys.pop();
          continue;
      }
      o = A.call(t, e);
    } catch (u) {
      o = [6, u], i = 0;
    } finally {
      r = n = 0;
    }
    if (o[0] & 5) throw o[1];
    return { value: o[0] ? o[1] : void 0, done: !0 };
  }
}
var bp = Object.create ? function(t, A, e, r) {
  r === void 0 && (r = e);
  var i = Object.getOwnPropertyDescriptor(A, e);
  (!i || ("get" in i ? !A.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
    return A[e];
  } }), Object.defineProperty(t, r, i);
} : function(t, A, e, r) {
  r === void 0 && (r = e), t[r] = A[e];
};
function gK(t, A) {
  for (var e in t) e !== "default" && !Object.prototype.hasOwnProperty.call(A, e) && bp(A, t, e);
}
function af(t) {
  var A = typeof Symbol == "function" && Symbol.iterator, e = A && t[A], r = 0;
  if (e) return e.call(t);
  if (t && typeof t.length == "number") return {
    next: function() {
      return t && r >= t.length && (t = void 0), { value: t && t[r++], done: !t };
    }
  };
  throw new TypeError(A ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function PS(t, A) {
  var e = typeof Symbol == "function" && t[Symbol.iterator];
  if (!e) return t;
  var r = e.call(t), i, n = [], s;
  try {
    for (; (A === void 0 || A-- > 0) && !(i = r.next()).done; ) n.push(i.value);
  } catch (a) {
    s = { error: a };
  } finally {
    try {
      i && !i.done && (e = r.return) && e.call(r);
    } finally {
      if (s) throw s.error;
    }
  }
  return n;
}
function uK() {
  for (var t = [], A = 0; A < arguments.length; A++)
    t = t.concat(PS(arguments[A]));
  return t;
}
function cK() {
  for (var t = 0, A = 0, e = arguments.length; A < e; A++) t += arguments[A].length;
  for (var r = Array(t), i = 0, A = 0; A < e; A++)
    for (var n = arguments[A], s = 0, a = n.length; s < a; s++, i++)
      r[i] = n[s];
  return r;
}
function IK(t, A, e) {
  if (e || arguments.length === 2) for (var r = 0, i = A.length, n; r < i; r++)
    (n || !(r in A)) && (n || (n = Array.prototype.slice.call(A, 0, r)), n[r] = A[r]);
  return t.concat(n || Array.prototype.slice.call(A));
}
function AI(t) {
  return this instanceof AI ? (this.v = t, this) : new AI(t);
}
function CK(t, A, e) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var r = e.apply(t, A || []), i, n = [];
  return i = Object.create((typeof AsyncIterator == "function" ? AsyncIterator : Object).prototype), a("next"), a("throw"), a("return", s), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function s(C) {
    return function(E) {
      return Promise.resolve(E).then(C, I);
    };
  }
  function a(C, E) {
    r[C] && (i[C] = function(l) {
      return new Promise(function(B, h) {
        n.push([C, l, B, h]) > 1 || g(C, l);
      });
    }, E && (i[C] = E(i[C])));
  }
  function g(C, E) {
    try {
      o(r[C](E));
    } catch (l) {
      c(n[0][3], l);
    }
  }
  function o(C) {
    C.value instanceof AI ? Promise.resolve(C.value.v).then(u, I) : c(n[0][2], C);
  }
  function u(C) {
    g("next", C);
  }
  function I(C) {
    g("throw", C);
  }
  function c(C, E) {
    C(E), n.shift(), n.length && g(n[0][0], n[0][1]);
  }
}
function lK(t) {
  var A, e;
  return A = {}, r("next"), r("throw", function(i) {
    throw i;
  }), r("return"), A[Symbol.iterator] = function() {
    return this;
  }, A;
  function r(i, n) {
    A[i] = t[i] ? function(s) {
      return (e = !e) ? { value: AI(t[i](s)), done: !1 } : n ? n(s) : s;
    } : n;
  }
}
function BK(t) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var A = t[Symbol.asyncIterator], e;
  return A ? A.call(t) : (t = typeof af == "function" ? af(t) : t[Symbol.iterator](), e = {}, r("next"), r("throw"), r("return"), e[Symbol.asyncIterator] = function() {
    return this;
  }, e);
  function r(n) {
    e[n] = t[n] && function(s) {
      return new Promise(function(a, g) {
        s = t[n](s), i(a, g, s.done, s.value);
      });
    };
  }
  function i(n, s, a, g) {
    Promise.resolve(g).then(function(o) {
      n({ value: o, done: a });
    }, s);
  }
}
function EK(t, A) {
  return Object.defineProperty ? Object.defineProperty(t, "raw", { value: A }) : t.raw = A, t;
}
var ZeA = Object.create ? function(t, A) {
  Object.defineProperty(t, "default", { enumerable: !0, value: A });
} : function(t, A) {
  t.default = A;
}, KD = function(t) {
  return KD = Object.getOwnPropertyNames || function(A) {
    var e = [];
    for (var r in A) Object.prototype.hasOwnProperty.call(A, r) && (e[e.length] = r);
    return e;
  }, KD(t);
};
function hK(t) {
  if (t && t.__esModule) return t;
  var A = {};
  if (t != null) for (var e = KD(t), r = 0; r < e.length; r++) e[r] !== "default" && bp(A, t, e[r]);
  return ZeA(A, t), A;
}
function QK(t) {
  return t && t.__esModule ? t : { default: t };
}
function dK(t, A, e, r) {
  if (e === "a" && !r) throw new TypeError("Private accessor was defined without a getter");
  if (typeof A == "function" ? t !== A || !r : !A.has(t)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return e === "m" ? r : e === "a" ? r.call(t) : r ? r.value : A.get(t);
}
function fK(t, A, e, r, i) {
  if (r === "m") throw new TypeError("Private method is not writable");
  if (r === "a" && !i) throw new TypeError("Private accessor was defined without a setter");
  if (typeof A == "function" ? t !== A || !i : !A.has(t)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return r === "a" ? i.call(t, e) : i ? i.value = e : A.set(t, e), e;
}
function pK(t, A) {
  if (A === null || typeof A != "object" && typeof A != "function") throw new TypeError("Cannot use 'in' operator on non-object");
  return typeof t == "function" ? A === t : t.has(A);
}
function yK(t, A, e) {
  if (A != null) {
    if (typeof A != "object" && typeof A != "function") throw new TypeError("Object expected.");
    var r, i;
    if (e) {
      if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
      r = A[Symbol.asyncDispose];
    }
    if (r === void 0) {
      if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
      r = A[Symbol.dispose], e && (i = r);
    }
    if (typeof r != "function") throw new TypeError("Object not disposable.");
    i && (r = function() {
      try {
        i.call(this);
      } catch (n) {
        return Promise.reject(n);
      }
    }), t.stack.push({ value: A, dispose: r, async: e });
  } else e && t.stack.push({ async: !0 });
  return A;
}
var XeA = typeof SuppressedError == "function" ? SuppressedError : function(t, A, e) {
  var r = new Error(e);
  return r.name = "SuppressedError", r.error = t, r.suppressed = A, r;
};
function wK(t) {
  function A(n) {
    t.error = t.hasError ? new XeA(n, t.error, "An error was suppressed during disposal.") : n, t.hasError = !0;
  }
  var e, r = 0;
  function i() {
    for (; e = t.stack.pop(); )
      try {
        if (!e.async && r === 1) return r = 0, t.stack.push(e), Promise.resolve().then(i);
        if (e.dispose) {
          var n = e.dispose.call(e.value);
          if (e.async) return r |= 2, Promise.resolve(n).then(i, function(s) {
            return A(s), i();
          });
        } else r |= 1;
      } catch (s) {
        A(s);
      }
    if (r === 1) return t.hasError ? Promise.reject(t.error) : Promise.resolve();
    if (t.hasError) throw t.error;
  }
  return i();
}
function mK(t, A) {
  return typeof t == "string" && /^\.\.?\//.test(t) ? t.replace(/\.(tsx)$|((?:\.d)?)((?:\.[^./]+?)?)\.([cm]?)ts$/i, function(e, r, i, n, s) {
    return r ? A ? ".jsx" : ".js" : i && (!n || !s) ? e : i + n + "." + s.toLowerCase() + "js";
  }) : t;
}
const zeA = {
  __extends: zT,
  __assign: sf,
  __rest: $T,
  __decorate: AK,
  __param: eK,
  __esDecorate: tK,
  __runInitializers: rK,
  __propKey: iK,
  __setFunctionName: nK,
  __metadata: sK,
  __awaiter: aK,
  __generator: oK,
  __createBinding: bp,
  __exportStar: gK,
  __values: af,
  __read: PS,
  __spread: uK,
  __spreadArrays: cK,
  __spreadArray: IK,
  __await: AI,
  __asyncGenerator: CK,
  __asyncDelegator: lK,
  __asyncValues: BK,
  __makeTemplateObject: EK,
  __importStar: hK,
  __importDefault: QK,
  __classPrivateFieldGet: dK,
  __classPrivateFieldSet: fK,
  __classPrivateFieldIn: pK,
  __addDisposableResource: yK,
  __disposeResources: wK,
  __rewriteRelativeImportExtension: mK
}, $eA = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  __addDisposableResource: yK,
  get __assign() {
    return sf;
  },
  __asyncDelegator: lK,
  __asyncGenerator: CK,
  __asyncValues: BK,
  __await: AI,
  __awaiter: aK,
  __classPrivateFieldGet: dK,
  __classPrivateFieldIn: pK,
  __classPrivateFieldSet: fK,
  __createBinding: bp,
  __decorate: AK,
  __disposeResources: wK,
  __esDecorate: tK,
  __exportStar: gK,
  __extends: zT,
  __generator: oK,
  __importDefault: QK,
  __importStar: hK,
  __makeTemplateObject: EK,
  __metadata: sK,
  __param: eK,
  __propKey: iK,
  __read: PS,
  __rest: $T,
  __rewriteRelativeImportExtension: mK,
  __runInitializers: rK,
  __setFunctionName: nK,
  __spread: uK,
  __spreadArray: IK,
  __spreadArrays: cK,
  __values: af,
  default: zeA
}, Symbol.toStringTag, { value: "Module" })), it = /* @__PURE__ */ y0($eA);
var Kh = { exports: {} }, Ug = {}, xb;
function Nt() {
  if (xb) return Ug;
  xb = 1, Object.defineProperty(Ug, "__esModule", { value: !0 }), Ug.Def = void 0;
  var t = it, A = Object.prototype, e = A.toString, r = A.hasOwnProperty, i = (
    /** @class */
    function() {
      function E() {
      }
      return E.prototype.assert = function(l, B) {
        if (!this.check(l, B)) {
          var h = c(l);
          throw new Error(h + " does not match type " + this);
        }
        return !0;
      }, E.prototype.arrayOf = function() {
        var l = this;
        return new n(l);
      }, E;
    }()
  ), n = (
    /** @class */
    function(E) {
      t.__extends(l, E);
      function l(B) {
        var h = E.call(this) || this;
        return h.elemType = B, h.kind = "ArrayType", h;
      }
      return l.prototype.toString = function() {
        return "[" + this.elemType + "]";
      }, l.prototype.check = function(B, h) {
        var Q = this;
        return Array.isArray(B) && B.every(function(f) {
          return Q.elemType.check(f, h);
        });
      }, l;
    }(i)
  ), s = (
    /** @class */
    function(E) {
      t.__extends(l, E);
      function l(B) {
        var h = E.call(this) || this;
        return h.value = B, h.kind = "IdentityType", h;
      }
      return l.prototype.toString = function() {
        return String(this.value);
      }, l.prototype.check = function(B, h) {
        var Q = B === this.value;
        return !Q && typeof h == "function" && h(this, B), Q;
      }, l;
    }(i)
  ), a = (
    /** @class */
    function(E) {
      t.__extends(l, E);
      function l(B) {
        var h = E.call(this) || this;
        return h.fields = B, h.kind = "ObjectType", h;
      }
      return l.prototype.toString = function() {
        return "{ " + this.fields.join(", ") + " }";
      }, l.prototype.check = function(B, h) {
        return e.call(B) === e.call({}) && this.fields.every(function(Q) {
          return Q.type.check(B[Q.name], h);
        });
      }, l;
    }(i)
  ), g = (
    /** @class */
    function(E) {
      t.__extends(l, E);
      function l(B) {
        var h = E.call(this) || this;
        return h.types = B, h.kind = "OrType", h;
      }
      return l.prototype.toString = function() {
        return this.types.join(" | ");
      }, l.prototype.check = function(B, h) {
        return this.types.some(function(Q) {
          return Q.check(B, h);
        });
      }, l;
    }(i)
  ), o = (
    /** @class */
    function(E) {
      t.__extends(l, E);
      function l(B, h) {
        var Q = E.call(this) || this;
        return Q.name = B, Q.predicate = h, Q.kind = "PredicateType", Q;
      }
      return l.prototype.toString = function() {
        return this.name;
      }, l.prototype.check = function(B, h) {
        var Q = this.predicate(B, h);
        return !Q && typeof h == "function" && h(this, B), Q;
      }, l;
    }(i)
  ), u = (
    /** @class */
    function() {
      function E(l, B) {
        this.type = l, this.typeName = B, this.baseNames = [], this.ownFields = /* @__PURE__ */ Object.create(null), this.allSupertypes = /* @__PURE__ */ Object.create(null), this.supertypeList = [], this.allFields = /* @__PURE__ */ Object.create(null), this.fieldNames = [], this.finalized = !1, this.buildable = !1, this.buildParams = [];
      }
      return E.prototype.isSupertypeOf = function(l) {
        if (l instanceof E) {
          if (this.finalized !== !0 || l.finalized !== !0)
            throw new Error("");
          return r.call(l.allSupertypes, this.typeName);
        } else
          throw new Error(l + " is not a Def");
      }, E.prototype.checkAllFields = function(l, B) {
        var h = this.allFields;
        if (this.finalized !== !0)
          throw new Error("" + this.typeName);
        function Q(f) {
          var p = h[f], y = p.type, m = p.getValue(l);
          return y.check(m, B);
        }
        return l !== null && typeof l == "object" && Object.keys(h).every(Q);
      }, E.prototype.bases = function() {
        for (var l = [], B = 0; B < arguments.length; B++)
          l[B] = arguments[B];
        var h = this.baseNames;
        if (this.finalized) {
          if (l.length !== h.length)
            throw new Error("");
          for (var Q = 0; Q < l.length; Q++)
            if (l[Q] !== h[Q])
              throw new Error("");
          return this;
        }
        return l.forEach(function(f) {
          h.indexOf(f) < 0 && h.push(f);
        }), this;
      }, E;
    }()
  );
  Ug.Def = u;
  var I = (
    /** @class */
    function() {
      function E(l, B, h, Q) {
        this.name = l, this.type = B, this.defaultFn = h, this.hidden = !!Q;
      }
      return E.prototype.toString = function() {
        return JSON.stringify(this.name) + ": " + this.type;
      }, E.prototype.getValue = function(l) {
        var B = l[this.name];
        return typeof B < "u" || typeof this.defaultFn == "function" && (B = this.defaultFn.call(l)), B;
      }, E;
    }()
  );
  function c(E) {
    return Array.isArray(E) ? "[" + E.map(c).join(", ") + "]" : E && typeof E == "object" ? "{ " + Object.keys(E).map(function(l) {
      return l + ": " + E[l];
    }).join(", ") + " }" : JSON.stringify(E);
  }
  function C(E) {
    var l = {
      or: function() {
        for (var L = [], V = 0; V < arguments.length; V++)
          L[V] = arguments[V];
        return new g(L.map(function(Z) {
          return l.from(Z);
        }));
      },
      from: function(L, V) {
        if (L instanceof n || L instanceof s || L instanceof a || L instanceof g || L instanceof o)
          return L;
        if (L instanceof u)
          return L.type;
        if (y.check(L)) {
          if (L.length !== 1)
            throw new Error("only one element type is permitted for typed arrays");
          return new n(l.from(L[0]));
        }
        if (m.check(L))
          return new a(Object.keys(L).map(function(cA) {
            return new I(cA, l.from(L[cA], cA));
          }));
        if (typeof L == "function") {
          var Z = B.indexOf(L);
          if (Z >= 0)
            return h[Z];
          if (typeof V != "string")
            throw new Error("missing name");
          return new o(V, L);
        }
        return new s(L);
      },
      // Define a type whose name is registered in a namespace (the defCache) so
      // that future definitions will return the same type given the same name.
      // In particular, this system allows for circular and forward definitions.
      // The Def object d returned from Type.def may be used to configure the
      // type d.type by calling methods such as d.bases, d.build, and d.field.
      def: function(L) {
        return r.call(H, L) ? H[L] : H[L] = new eA(L);
      },
      hasDef: function(L) {
        return r.call(H, L);
      }
    }, B = [], h = [];
    function Q(L, V) {
      var Z = e.call(V), cA = new o(L, function(X) {
        return e.call(X) === Z;
      });
      return V && typeof V.constructor == "function" && (B.push(V.constructor), h.push(cA)), cA;
    }
    var f = Q("string", "truthy"), p = Q("function", function() {
    }), y = Q("array", []), m = Q("object", {}), S = Q("RegExp", /./), w = Q("Date", /* @__PURE__ */ new Date()), F = Q("number", 3), b = Q("boolean", !0), G = Q("null", null), T = Q("undefined", void 0), K = {
      string: f,
      function: p,
      array: y,
      object: m,
      RegExp: S,
      Date: w,
      number: F,
      boolean: b,
      null: G,
      undefined: T
    }, H = /* @__PURE__ */ Object.create(null);
    function j(L) {
      if (L && typeof L == "object") {
        var V = L.type;
        if (typeof V == "string" && r.call(H, V)) {
          var Z = H[V];
          if (Z.finalized)
            return Z;
        }
      }
      return null;
    }
    var eA = (
      /** @class */
      function(L) {
        t.__extends(V, L);
        function V(Z) {
          var cA = L.call(this, new o(Z, function(X, z) {
            return cA.check(X, z);
          }), Z) || this;
          return cA;
        }
        return V.prototype.check = function(Z, cA) {
          if (this.finalized !== !0)
            throw new Error("prematurely checking unfinalized type " + this.typeName);
          if (Z === null || typeof Z != "object")
            return !1;
          var X = j(Z);
          return X ? cA && X === this ? this.checkAllFields(Z, cA) : this.isSupertypeOf(X) ? cA ? X.checkAllFields(Z, cA) && this.checkAllFields(Z, !1) : !0 : !1 : this.typeName === "SourceLocation" || this.typeName === "Position" ? this.checkAllFields(Z, cA) : !1;
        }, V.prototype.build = function() {
          for (var Z = this, cA = [], X = 0; X < arguments.length; X++)
            cA[X] = arguments[X];
          if (this.buildParams = cA, this.buildable)
            return this;
          this.field("type", String, function() {
            return Z.typeName;
          }), this.buildable = !0;
          var z = function(aA, Ae, vA, RA) {
            if (!r.call(aA, Ae)) {
              var MA = Z.allFields;
              if (!r.call(MA, Ae))
                throw new Error("" + Ae);
              var BA = MA[Ae], pA = BA.type, EA;
              if (RA)
                EA = vA;
              else if (BA.defaultFn)
                EA = BA.defaultFn.call(aA);
              else {
                var _A = "no value or default function given for field " + JSON.stringify(Ae) + " of " + Z.typeName + "(" + Z.buildParams.map(function(oe) {
                  return MA[oe];
                }).join(", ") + ")";
                throw new Error(_A);
              }
              if (!pA.check(EA))
                throw new Error(c(EA) + " does not match field " + BA + " of type " + Z.typeName);
              aA[Ae] = EA;
            }
          }, SA = function() {
            for (var aA = [], Ae = 0; Ae < arguments.length; Ae++)
              aA[Ae] = arguments[Ae];
            var vA = aA.length;
            if (!Z.finalized)
              throw new Error("attempting to instantiate unfinalized type " + Z.typeName);
            var RA = Object.create(hA);
            if (Z.buildParams.forEach(function(MA, BA) {
              BA < vA ? z(RA, MA, aA[BA], !0) : z(RA, MA, null, !1);
            }), Object.keys(Z.allFields).forEach(function(MA) {
              z(RA, MA, null, !1);
            }), RA.type !== Z.typeName)
              throw new Error("");
            return RA;
          };
          return SA.from = function(aA) {
            if (!Z.finalized)
              throw new Error("attempting to instantiate unfinalized type " + Z.typeName);
            var Ae = Object.create(hA);
            if (Object.keys(Z.allFields).forEach(function(vA) {
              r.call(aA, vA) ? z(Ae, vA, aA[vA], !0) : z(Ae, vA, null, !1);
            }), Ae.type !== Z.typeName)
              throw new Error("");
            return Ae;
          }, Object.defineProperty(rA, iA(this.typeName), {
            enumerable: !0,
            value: SA
          }), this;
        }, V.prototype.field = function(Z, cA, X, z) {
          return this.finalized ? (console.error("Ignoring attempt to redefine field " + JSON.stringify(Z) + " of finalized type " + JSON.stringify(this.typeName)), this) : (this.ownFields[Z] = new I(Z, l.from(cA), X, z), this);
        }, V.prototype.finalize = function() {
          var Z = this;
          if (!this.finalized) {
            var cA = this.allFields, X = this.allSupertypes;
            this.baseNames.forEach(function(SA) {
              var aA = H[SA];
              if (aA instanceof u)
                aA.finalize(), ue(cA, aA.allFields), ue(X, aA.allSupertypes);
              else {
                var Ae = "unknown supertype name " + JSON.stringify(SA) + " for subtype " + JSON.stringify(Z.typeName);
                throw new Error(Ae);
              }
            }), ue(cA, this.ownFields), X[this.typeName] = this, this.fieldNames.length = 0;
            for (var z in cA)
              r.call(cA, z) && !cA[z].hidden && this.fieldNames.push(z);
            Object.defineProperty(Re, this.typeName, {
              enumerable: !0,
              value: this.type
            }), this.finalized = !0, XA(this.typeName, this.supertypeList), this.buildable && this.supertypeList.lastIndexOf("Expression") >= 0 && P(this.typeName);
          }
        }, V;
      }(u)
    );
    function sA(L) {
      if (!r.call(H, L))
        throw new Error("");
      var V = H[L];
      if (V.finalized !== !0)
        throw new Error("");
      return V.supertypeList.slice(1);
    }
    function uA(L) {
      for (var V = {}, Z = Object.keys(H), cA = Z.length, X = 0; X < cA; ++X) {
        var z = Z[X], SA = H[z];
        if (SA.finalized !== !0)
          throw new Error("" + z);
        for (var aA = 0; aA < SA.supertypeList.length; ++aA) {
          var Ae = SA.supertypeList[aA];
          if (r.call(L, Ae)) {
            V[z] = Ae;
            break;
          }
        }
      }
      return V;
    }
    var rA = /* @__PURE__ */ Object.create(null), hA = {};
    function UA(L, V) {
      var Z = hA[L];
      return T.check(V) ? delete hA[L] : (p.assert(V), Object.defineProperty(hA, L, {
        enumerable: !0,
        configurable: !0,
        value: V
      })), Z;
    }
    function iA(L) {
      return L.replace(/^[A-Z]+/, function(V) {
        var Z = V.length;
        switch (Z) {
          case 0:
            return "";
          case 1:
            return V.toLowerCase();
          default:
            return V.slice(0, Z - 1).toLowerCase() + V.charAt(Z - 1);
        }
      });
    }
    function wA(L) {
      return L = iA(L), L.replace(/(Expression)?$/, "Statement");
    }
    var Re = {};
    function zA(L) {
      var V = j(L);
      if (V)
        return V.fieldNames.slice(0);
      if ("type" in L)
        throw new Error("did not recognize object of type " + JSON.stringify(L.type));
      return Object.keys(L);
    }
    function U(L, V) {
      var Z = j(L);
      if (Z) {
        var cA = Z.allFields[V];
        if (cA)
          return cA.getValue(L);
      }
      return L && L[V];
    }
    function N(L, V, Z) {
      zA(L).forEach(function(cA) {
        V.call(this, cA, U(L, cA));
      }, Z);
    }
    function CA(L, V, Z) {
      return zA(L).some(function(cA) {
        return V.call(this, cA, U(L, cA));
      }, Z);
    }
    function P(L) {
      var V = wA(L);
      if (!rA[V]) {
        var Z = rA[iA(L)];
        if (Z) {
          var cA = function() {
            for (var X = [], z = 0; z < arguments.length; z++)
              X[z] = arguments[z];
            return rA.expressionStatement(Z.apply(rA, X));
          };
          cA.from = function() {
            for (var X = [], z = 0; z < arguments.length; z++)
              X[z] = arguments[z];
            return rA.expressionStatement(Z.from.apply(rA, X));
          }, rA[V] = cA;
        }
      }
    }
    function XA(L, V) {
      V.length = 0, V.push(L);
      for (var Z = /* @__PURE__ */ Object.create(null), cA = 0; cA < V.length; ++cA) {
        L = V[cA];
        var X = H[L];
        if (X.finalized !== !0)
          throw new Error("");
        r.call(Z, L) && delete V[Z[L]], Z[L] = cA, V.push.apply(V, X.baseNames);
      }
      for (var z = 0, SA = z, aA = V.length; SA < aA; ++SA)
        r.call(V, SA) && (V[z++] = V[SA]);
      V.length = z;
    }
    function ue(L, V) {
      return Object.keys(V).forEach(function(Z) {
        L[Z] = V[Z];
      }), L;
    }
    function Y() {
      Object.keys(H).forEach(function(L) {
        H[L].finalize();
      });
    }
    return {
      Type: l,
      builtInTypes: K,
      getSupertypeNames: sA,
      computeSupertypeLookupTable: uA,
      builders: rA,
      defineMethod: UA,
      getBuilderName: iA,
      getStatementBuilderName: wA,
      namedTypes: Re,
      getFieldNames: zA,
      getFieldValue: U,
      eachField: N,
      someField: CA,
      finalize: Y
    };
  }
  return Ug.default = C, Ug;
}
var Jh = { exports: {} }, Hh = { exports: {} }, Ph = { exports: {} }, Gb;
function DK() {
  return Gb || (Gb = 1, function(t, A) {
    Object.defineProperty(A, "__esModule", { value: !0 });
    var e = it, r = e.__importDefault(Nt()), i = Object.prototype, n = i.hasOwnProperty;
    function s(a) {
      var g = a.use(r.default), o = g.builtInTypes.array, u = g.builtInTypes.number, I = function Q(f, p, y) {
        if (!(this instanceof Q))
          throw new Error("Path constructor cannot be invoked without 'new'");
        if (p) {
          if (!(p instanceof Q))
            throw new Error("");
        } else
          p = null, y = null;
        this.value = f, this.parentPath = p, this.name = y, this.__childCache = null;
      }, c = I.prototype;
      function C(Q) {
        return Q.__childCache || (Q.__childCache = /* @__PURE__ */ Object.create(null));
      }
      function E(Q, f) {
        var p = C(Q), y = Q.getValueProperty(f), m = p[f];
        return (!n.call(p, f) || // Ensure consistency between cache and reality.
        m.value !== y) && (m = p[f] = new Q.constructor(y, Q, f)), m;
      }
      c.getValueProperty = function(f) {
        return this.value[f];
      }, c.get = function() {
        for (var f = [], p = 0; p < arguments.length; p++)
          f[p] = arguments[p];
        for (var y = this, m = f.length, S = 0; S < m; ++S)
          y = E(y, f[S]);
        return y;
      }, c.each = function(f, p) {
        for (var y = [], m = this.value.length, S = 0, S = 0; S < m; ++S)
          n.call(this.value, S) && (y[S] = this.get(S));
        for (p = p || this, S = 0; S < m; ++S)
          n.call(y, S) && f.call(p, y[S]);
      }, c.map = function(f, p) {
        var y = [];
        return this.each(function(m) {
          y.push(f.call(this, m));
        }, p), y;
      }, c.filter = function(f, p) {
        var y = [];
        return this.each(function(m) {
          f.call(this, m) && y.push(m);
        }, p), y;
      };
      function l() {
      }
      function B(Q, f, p, y) {
        if (o.assert(Q.value), f === 0)
          return l;
        var m = Q.value.length;
        if (m < 1)
          return l;
        var S = arguments.length;
        S === 2 ? (p = 0, y = m) : S === 3 ? (p = Math.max(p, 0), y = m) : (p = Math.max(p, 0), y = Math.min(y, m)), u.assert(p), u.assert(y);
        for (var w = /* @__PURE__ */ Object.create(null), F = C(Q), b = p; b < y; ++b)
          if (n.call(Q.value, b)) {
            var G = Q.get(b);
            if (G.name !== b)
              throw new Error("");
            var T = b + f;
            G.name = T, w[T] = G, delete F[b];
          }
        return delete F.length, function() {
          for (var K in w) {
            var H = w[K];
            if (H.name !== +K)
              throw new Error("");
            F[K] = H, Q.value[K] = H.value;
          }
        };
      }
      c.shift = function() {
        var f = B(this, -1), p = this.value.shift();
        return f(), p;
      }, c.unshift = function() {
        for (var f = [], p = 0; p < arguments.length; p++)
          f[p] = arguments[p];
        var y = B(this, f.length), m = this.value.unshift.apply(this.value, f);
        return y(), m;
      }, c.push = function() {
        for (var f = [], p = 0; p < arguments.length; p++)
          f[p] = arguments[p];
        return o.assert(this.value), delete C(this).length, this.value.push.apply(this.value, f);
      }, c.pop = function() {
        o.assert(this.value);
        var f = C(this);
        return delete f[this.value.length - 1], delete f.length, this.value.pop();
      }, c.insertAt = function(f) {
        var p = arguments.length, y = B(this, p - 1, f);
        if (y === l && p <= 1)
          return this;
        f = Math.max(f, 0);
        for (var m = 1; m < p; ++m)
          this.value[f + m - 1] = arguments[m];
        return y(), this;
      }, c.insertBefore = function() {
        for (var f = [], p = 0; p < arguments.length; p++)
          f[p] = arguments[p];
        for (var y = this.parentPath, m = f.length, S = [this.name], w = 0; w < m; ++w)
          S.push(f[w]);
        return y.insertAt.apply(y, S);
      }, c.insertAfter = function() {
        for (var f = [], p = 0; p < arguments.length; p++)
          f[p] = arguments[p];
        for (var y = this.parentPath, m = f.length, S = [this.name + 1], w = 0; w < m; ++w)
          S.push(f[w]);
        return y.insertAt.apply(y, S);
      };
      function h(Q) {
        if (!(Q instanceof I))
          throw new Error("");
        var f = Q.parentPath;
        if (!f)
          return Q;
        var p = f.value, y = C(f);
        if (p[Q.name] === Q.value)
          y[Q.name] = Q;
        else if (o.check(p)) {
          var m = p.indexOf(Q.value);
          m >= 0 && (y[Q.name = m] = Q);
        } else
          p[Q.name] = Q.value, y[Q.name] = Q;
        if (p[Q.name] !== Q.value)
          throw new Error("");
        if (Q.parentPath.get(Q.name) !== Q)
          throw new Error("");
        return Q;
      }
      return c.replace = function(f) {
        var p = [], y = this.parentPath.value, m = C(this.parentPath), S = arguments.length;
        if (h(this), o.check(y)) {
          for (var w = y.length, F = B(this.parentPath, S - 1, this.name + 1), b = [this.name, 1], G = 0; G < S; ++G)
            b.push(arguments[G]);
          var T = y.splice.apply(y, b);
          if (T[0] !== this.value)
            throw new Error("");
          if (y.length !== w - 1 + S)
            throw new Error("");
          if (F(), S === 0)
            delete this.value, delete m[this.name], this.__childCache = null;
          else {
            if (y[this.name] !== f)
              throw new Error("");
            for (this.value !== f && (this.value = f, this.__childCache = null), G = 0; G < S; ++G)
              p.push(this.parentPath.get(this.name + G));
            if (p[0] !== this)
              throw new Error("");
          }
        } else if (S === 1)
          this.value !== f && (this.__childCache = null), this.value = y[this.name] = f, p.push(this);
        else if (S === 0)
          delete y[this.name], delete this.value, this.__childCache = null;
        else
          throw new Error("Could not replace path");
        return p;
      }, I;
    }
    A.default = s, t.exports = A.default;
  }(Ph, Ph.exports)), Ph.exports;
}
var Oh = { exports: {} }, Ub;
function AtA() {
  return Ub || (Ub = 1, function(t, A) {
    Object.defineProperty(A, "__esModule", { value: !0 });
    var e = it, r = e.__importDefault(Nt()), i = Object.prototype.hasOwnProperty;
    function n(s) {
      var a = s.use(r.default), g = a.Type, o = a.namedTypes, u = o.Node, I = o.Expression, c = a.builtInTypes.array, C = a.builders, E = function w(F, b) {
        if (!(this instanceof w))
          throw new Error("Scope constructor cannot be invoked without 'new'");
        B.assert(F.value);
        var G;
        if (b) {
          if (!(b instanceof w))
            throw new Error("");
          G = b.depth + 1;
        } else
          b = null, G = 0;
        Object.defineProperties(this, {
          path: { value: F },
          node: { value: F.value },
          isGlobal: { value: !b, enumerable: !0 },
          depth: { value: G },
          parent: { value: b },
          bindings: { value: {} },
          types: { value: {} }
        });
      }, l = [
        // Program nodes introduce global scopes.
        o.Program,
        // Function is the supertype of FunctionExpression,
        // FunctionDeclaration, ArrowExpression, etc.
        o.Function,
        // In case you didn't know, the caught parameter shadows any variable
        // of the same name in an outer scope.
        o.CatchClause
      ], B = g.or.apply(g, l);
      E.isEstablishedBy = function(w) {
        return B.check(w);
      };
      var h = E.prototype;
      h.didScan = !1, h.declares = function(w) {
        return this.scan(), i.call(this.bindings, w);
      }, h.declaresType = function(w) {
        return this.scan(), i.call(this.types, w);
      }, h.declareTemporary = function(w) {
        if (w) {
          if (!/^[a-z$_]/i.test(w))
            throw new Error("");
        } else
          w = "t$";
        w += this.depth.toString(36) + "$", this.scan();
        for (var F = 0; this.declares(w + F); )
          ++F;
        var b = w + F;
        return this.bindings[b] = a.builders.identifier(b);
      }, h.injectTemporary = function(w, F) {
        w || (w = this.declareTemporary());
        var b = this.path.get("body");
        return o.BlockStatement.check(b.value) && (b = b.get("body")), b.unshift(C.variableDeclaration("var", [C.variableDeclarator(w, F || null)])), w;
      }, h.scan = function(w) {
        if (w || !this.didScan) {
          for (var F in this.bindings)
            delete this.bindings[F];
          Q(this.path, this.bindings, this.types), this.didScan = !0;
        }
      }, h.getBindings = function() {
        return this.scan(), this.bindings;
      }, h.getTypes = function() {
        return this.scan(), this.types;
      };
      function Q(w, F, b) {
        var G = w.value;
        if (B.assert(G), o.CatchClause.check(G)) {
          var T = w.get("param");
          T.value && m(T, F);
        } else
          f(w, F, b);
      }
      function f(w, F, b) {
        var G = w.value;
        w.parent && o.FunctionExpression.check(w.parent.node) && w.parent.node.id && m(w.parent.get("id"), F), G && (c.check(G) ? w.each(function(T) {
          y(T, F, b);
        }) : o.Function.check(G) ? (w.get("params").each(function(T) {
          m(T, F);
        }), y(w.get("body"), F, b)) : o.TypeAlias && o.TypeAlias.check(G) || o.InterfaceDeclaration && o.InterfaceDeclaration.check(G) || o.TSTypeAliasDeclaration && o.TSTypeAliasDeclaration.check(G) || o.TSInterfaceDeclaration && o.TSInterfaceDeclaration.check(G) ? S(w.get("id"), b) : o.VariableDeclarator.check(G) ? (m(w.get("id"), F), y(w.get("init"), F, b)) : G.type === "ImportSpecifier" || G.type === "ImportNamespaceSpecifier" || G.type === "ImportDefaultSpecifier" ? m(
          // Esprima used to use the .name field to refer to the local
          // binding identifier for ImportSpecifier nodes, but .id for
          // ImportNamespaceSpecifier and ImportDefaultSpecifier nodes.
          // ESTree/Acorn/ESpree use .local for all three node types.
          w.get(G.local ? "local" : G.name ? "name" : "id"),
          F
        ) : u.check(G) && !I.check(G) && a.eachField(G, function(T, K) {
          var H = w.get(T);
          if (!p(H, K))
            throw new Error("");
          y(H, F, b);
        }));
      }
      function p(w, F) {
        return !!(w.value === F || Array.isArray(w.value) && w.value.length === 0 && Array.isArray(F) && F.length === 0);
      }
      function y(w, F, b) {
        var G = w.value;
        if (!(!G || I.check(G))) if (o.FunctionDeclaration.check(G) && G.id !== null)
          m(w.get("id"), F);
        else if (o.ClassDeclaration && o.ClassDeclaration.check(G))
          m(w.get("id"), F);
        else if (B.check(G)) {
          if (o.CatchClause.check(G) && // TODO Broaden this to accept any pattern.
          o.Identifier.check(G.param)) {
            var T = G.param.name, K = i.call(F, T);
            f(w.get("body"), F, b), K || delete F[T];
          }
        } else
          f(w, F, b);
      }
      function m(w, F) {
        var b = w.value;
        o.Pattern.assert(b), o.Identifier.check(b) ? i.call(F, b.name) ? F[b.name].push(w) : F[b.name] = [w] : o.AssignmentPattern && o.AssignmentPattern.check(b) ? m(w.get("left"), F) : o.ObjectPattern && o.ObjectPattern.check(b) ? w.get("properties").each(function(G) {
          var T = G.value;
          o.Pattern.check(T) ? m(G, F) : o.Property.check(T) ? m(G.get("value"), F) : o.SpreadProperty && o.SpreadProperty.check(T) && m(G.get("argument"), F);
        }) : o.ArrayPattern && o.ArrayPattern.check(b) ? w.get("elements").each(function(G) {
          var T = G.value;
          o.Pattern.check(T) ? m(G, F) : o.SpreadElement && o.SpreadElement.check(T) && m(G.get("argument"), F);
        }) : o.PropertyPattern && o.PropertyPattern.check(b) ? m(w.get("pattern"), F) : (o.SpreadElementPattern && o.SpreadElementPattern.check(b) || o.SpreadPropertyPattern && o.SpreadPropertyPattern.check(b)) && m(w.get("argument"), F);
      }
      function S(w, F) {
        var b = w.value;
        o.Pattern.assert(b), o.Identifier.check(b) && (i.call(F, b.name) ? F[b.name].push(w) : F[b.name] = [w]);
      }
      return h.lookup = function(w) {
        for (var F = this; F && !F.declares(w); F = F.parent)
          ;
        return F;
      }, h.lookupType = function(w) {
        for (var F = this; F && !F.declaresType(w); F = F.parent)
          ;
        return F;
      }, h.getGlobalScope = function() {
        for (var w = this; !w.isGlobal; )
          w = w.parent;
        return w;
      }, E;
    }
    A.default = n, t.exports = A.default;
  }(Oh, Oh.exports)), Oh.exports;
}
var Tb;
function SK() {
  return Tb || (Tb = 1, function(t, A) {
    Object.defineProperty(A, "__esModule", { value: !0 });
    var e = it, r = e.__importDefault(Nt()), i = e.__importDefault(DK()), n = e.__importDefault(AtA());
    function s(a) {
      var g = a.use(r.default), o = g.namedTypes, u = g.builders, I = g.builtInTypes.number, c = g.builtInTypes.array, C = a.use(i.default), E = a.use(n.default), l = function S(w, F, b) {
        if (!(this instanceof S))
          throw new Error("NodePath constructor cannot be invoked without 'new'");
        C.call(this, w, F, b);
      }, B = l.prototype = Object.create(C.prototype, {
        constructor: {
          value: l,
          enumerable: !1,
          writable: !0,
          configurable: !0
        }
      });
      Object.defineProperties(B, {
        node: {
          get: function() {
            return Object.defineProperty(this, "node", {
              configurable: !0,
              value: this._computeNode()
            }), this.node;
          }
        },
        parent: {
          get: function() {
            return Object.defineProperty(this, "parent", {
              configurable: !0,
              value: this._computeParent()
            }), this.parent;
          }
        },
        scope: {
          get: function() {
            return Object.defineProperty(this, "scope", {
              configurable: !0,
              value: this._computeScope()
            }), this.scope;
          }
        }
      }), B.replace = function() {
        return delete this.node, delete this.parent, delete this.scope, C.prototype.replace.apply(this, arguments);
      }, B.prune = function() {
        var S = this.parent;
        return this.replace(), y(S);
      }, B._computeNode = function() {
        var S = this.value;
        if (o.Node.check(S))
          return S;
        var w = this.parentPath;
        return w && w.node || null;
      }, B._computeParent = function() {
        var S = this.value, w = this.parentPath;
        if (!o.Node.check(S)) {
          for (; w && !o.Node.check(w.value); )
            w = w.parentPath;
          w && (w = w.parentPath);
        }
        for (; w && !o.Node.check(w.value); )
          w = w.parentPath;
        return w || null;
      }, B._computeScope = function() {
        var S = this.value, w = this.parentPath, F = w && w.scope;
        return o.Node.check(S) && E.isEstablishedBy(S) && (F = new E(this, F)), F || null;
      }, B.getValueProperty = function(S) {
        return g.getFieldValue(this.value, S);
      }, B.needsParens = function(S) {
        var w = this.parentPath;
        if (!w)
          return !1;
        var F = this.value;
        if (!o.Expression.check(F) || F.type === "Identifier")
          return !1;
        for (; !o.Node.check(w.value); )
          if (w = w.parentPath, !w)
            return !1;
        var b = w.value;
        switch (F.type) {
          case "UnaryExpression":
          case "SpreadElement":
          case "SpreadProperty":
            return b.type === "MemberExpression" && this.name === "object" && b.object === F;
          case "BinaryExpression":
          case "LogicalExpression":
            switch (b.type) {
              case "CallExpression":
                return this.name === "callee" && b.callee === F;
              case "UnaryExpression":
              case "SpreadElement":
              case "SpreadProperty":
                return !0;
              case "MemberExpression":
                return this.name === "object" && b.object === F;
              case "BinaryExpression":
              case "LogicalExpression": {
                var G = F, T = b.operator, K = Q[T], H = G.operator, j = Q[H];
                if (K > j)
                  return !0;
                if (K === j && this.name === "right") {
                  if (b.right !== G)
                    throw new Error("Nodes must be equal");
                  return !0;
                }
              }
              default:
                return !1;
            }
          case "SequenceExpression":
            switch (b.type) {
              case "ForStatement":
                return !1;
              case "ExpressionStatement":
                return this.name !== "expression";
              default:
                return !0;
            }
          case "YieldExpression":
            switch (b.type) {
              case "BinaryExpression":
              case "LogicalExpression":
              case "UnaryExpression":
              case "SpreadElement":
              case "SpreadProperty":
              case "CallExpression":
              case "MemberExpression":
              case "NewExpression":
              case "ConditionalExpression":
              case "YieldExpression":
                return !0;
              default:
                return !1;
            }
          case "Literal":
            return b.type === "MemberExpression" && I.check(F.value) && this.name === "object" && b.object === F;
          case "AssignmentExpression":
          case "ConditionalExpression":
            switch (b.type) {
              case "UnaryExpression":
              case "SpreadElement":
              case "SpreadProperty":
              case "BinaryExpression":
              case "LogicalExpression":
                return !0;
              case "CallExpression":
                return this.name === "callee" && b.callee === F;
              case "ConditionalExpression":
                return this.name === "test" && b.test === F;
              case "MemberExpression":
                return this.name === "object" && b.object === F;
              default:
                return !1;
            }
          default:
            if (b.type === "NewExpression" && this.name === "callee" && b.callee === F)
              return f(F);
        }
        return !!(S !== !0 && !this.canBeFirstInStatement() && this.firstInStatement());
      };
      function h(S) {
        return o.BinaryExpression.check(S) || o.LogicalExpression.check(S);
      }
      var Q = {};
      [
        ["||"],
        ["&&"],
        ["|"],
        ["^"],
        ["&"],
        ["==", "===", "!=", "!=="],
        ["<", ">", "<=", ">=", "in", "instanceof"],
        [">>", "<<", ">>>"],
        ["+", "-"],
        ["*", "/", "%"]
      ].forEach(function(S, w) {
        S.forEach(function(F) {
          Q[F] = w;
        });
      });
      function f(S) {
        return o.CallExpression.check(S) ? !0 : c.check(S) ? S.some(f) : o.Node.check(S) ? g.someField(S, function(w, F) {
          return f(F);
        }) : !1;
      }
      B.canBeFirstInStatement = function() {
        var S = this.node;
        return !o.FunctionExpression.check(S) && !o.ObjectExpression.check(S);
      }, B.firstInStatement = function() {
        return p(this);
      };
      function p(S) {
        for (var w, F; S.parent; S = S.parent) {
          if (w = S.node, F = S.parent.node, o.BlockStatement.check(F) && S.parent.name === "body" && S.name === 0) {
            if (F.body[0] !== w)
              throw new Error("Nodes must be equal");
            return !0;
          }
          if (o.ExpressionStatement.check(F) && S.name === "expression") {
            if (F.expression !== w)
              throw new Error("Nodes must be equal");
            return !0;
          }
          if (o.SequenceExpression.check(F) && S.parent.name === "expressions" && S.name === 0) {
            if (F.expressions[0] !== w)
              throw new Error("Nodes must be equal");
            continue;
          }
          if (o.CallExpression.check(F) && S.name === "callee") {
            if (F.callee !== w)
              throw new Error("Nodes must be equal");
            continue;
          }
          if (o.MemberExpression.check(F) && S.name === "object") {
            if (F.object !== w)
              throw new Error("Nodes must be equal");
            continue;
          }
          if (o.ConditionalExpression.check(F) && S.name === "test") {
            if (F.test !== w)
              throw new Error("Nodes must be equal");
            continue;
          }
          if (h(F) && S.name === "left") {
            if (F.left !== w)
              throw new Error("Nodes must be equal");
            continue;
          }
          if (o.UnaryExpression.check(F) && !F.prefix && S.name === "argument") {
            if (F.argument !== w)
              throw new Error("Nodes must be equal");
            continue;
          }
          return !1;
        }
        return !0;
      }
      function y(S) {
        if (o.VariableDeclaration.check(S.node)) {
          var w = S.get("declarations").value;
          if (!w || w.length === 0)
            return S.prune();
        } else if (o.ExpressionStatement.check(S.node)) {
          if (!S.get("expression").value)
            return S.prune();
        } else o.IfStatement.check(S.node) && m(S);
        return S;
      }
      function m(S) {
        var w = S.get("test").value, F = S.get("alternate").value, b = S.get("consequent").value;
        if (!b && !F) {
          var G = u.expressionStatement(w);
          S.replace(G);
        } else if (!b && F) {
          var T = u.unaryExpression("!", w, !0);
          o.UnaryExpression.check(w) && w.operator === "!" && (T = w.argument), S.get("test").replace(T), S.get("consequent").replace(F), S.get("alternate").replace();
        }
      }
      return l;
    }
    A.default = s, t.exports = A.default;
  }(Hh, Hh.exports)), Hh.exports;
}
var Kb;
function etA() {
  return Kb || (Kb = 1, function(t, A) {
    Object.defineProperty(A, "__esModule", { value: !0 });
    var e = it, r = e.__importDefault(Nt()), i = e.__importDefault(SK()), n = Object.prototype.hasOwnProperty;
    function s(a) {
      var g = a.use(r.default), o = a.use(i.default), u = g.builtInTypes.array, I = g.builtInTypes.object, c = g.builtInTypes.function, C, E = function y() {
        if (!(this instanceof y))
          throw new Error("PathVisitor constructor cannot be invoked without 'new'");
        this._reusableContextStack = [], this._methodNameTable = l(this), this._shouldVisitComments = n.call(this._methodNameTable, "Block") || n.call(this._methodNameTable, "Line"), this.Context = f(this), this._visiting = !1, this._changeReported = !1;
      };
      function l(y) {
        var m = /* @__PURE__ */ Object.create(null);
        for (var S in y)
          /^visit[A-Z]/.test(S) && (m[S.slice(5)] = !0);
        for (var w = g.computeSupertypeLookupTable(m), F = /* @__PURE__ */ Object.create(null), b = Object.keys(w), G = b.length, T = 0; T < G; ++T) {
          var K = b[T];
          S = "visit" + w[K], c.check(y[S]) && (F[K] = S);
        }
        return F;
      }
      E.fromMethodsObject = function(m) {
        if (m instanceof E)
          return m;
        if (!I.check(m))
          return new E();
        var S = function F() {
          if (!(this instanceof F))
            throw new Error("Visitor constructor cannot be invoked without 'new'");
          E.call(this);
        }, w = S.prototype = Object.create(h);
        return w.constructor = S, B(w, m), B(S, E), c.assert(S.fromMethodsObject), c.assert(S.visit), new S();
      };
      function B(y, m) {
        for (var S in m)
          n.call(m, S) && (y[S] = m[S]);
        return y;
      }
      E.visit = function(m, S) {
        return E.fromMethodsObject(S).visit(m);
      };
      var h = E.prototype;
      h.visit = function() {
        if (this._visiting)
          throw new Error("Recursively calling visitor.visit(path) resets visitor state. Try this.visit(path) or this.traverse(path) instead.");
        this._visiting = !0, this._changeReported = !1, this._abortRequested = !1;
        for (var y = arguments.length, m = new Array(y), S = 0; S < y; ++S)
          m[S] = arguments[S];
        m[0] instanceof o || (m[0] = new o({ root: m[0] }).get("root")), this.reset.apply(this, m);
        var w;
        try {
          var F = this.visitWithoutReset(m[0]);
          w = !0;
        } finally {
          if (this._visiting = !1, !w && this._abortRequested)
            return m[0].value;
        }
        return F;
      }, h.AbortRequest = function() {
      }, h.abort = function() {
        var y = this;
        y._abortRequested = !0;
        var m = new y.AbortRequest();
        throw m.cancel = function() {
          y._abortRequested = !1;
        }, m;
      }, h.reset = function(y) {
      }, h.visitWithoutReset = function(y) {
        if (this instanceof this.Context)
          return this.visitor.visitWithoutReset(y);
        if (!(y instanceof o))
          throw new Error("");
        var m = y.value, S = m && typeof m == "object" && typeof m.type == "string" && this._methodNameTable[m.type];
        if (S) {
          var w = this.acquireContext(y);
          try {
            return w.invokeVisitorMethod(S);
          } finally {
            this.releaseContext(w);
          }
        } else
          return Q(y, this);
      };
      function Q(y, m) {
        if (!(y instanceof o))
          throw new Error("");
        if (!(m instanceof E))
          throw new Error("");
        var S = y.value;
        if (u.check(S))
          y.each(m.visitWithoutReset, m);
        else if (I.check(S)) {
          var w = g.getFieldNames(S);
          m._shouldVisitComments && S.comments && w.indexOf("comments") < 0 && w.push("comments");
          for (var F = w.length, b = [], G = 0; G < F; ++G) {
            var T = w[G];
            n.call(S, T) || (S[T] = g.getFieldValue(S, T)), b.push(y.get(T));
          }
          for (var G = 0; G < F; ++G)
            m.visitWithoutReset(b[G]);
        }
        return y.value;
      }
      h.acquireContext = function(y) {
        return this._reusableContextStack.length === 0 ? new this.Context(y) : this._reusableContextStack.pop().reset(y);
      }, h.releaseContext = function(y) {
        if (!(y instanceof this.Context))
          throw new Error("");
        this._reusableContextStack.push(y), y.currentPath = null;
      }, h.reportChanged = function() {
        this._changeReported = !0;
      }, h.wasChangeReported = function() {
        return this._changeReported;
      };
      function f(y) {
        function m(w) {
          if (!(this instanceof m))
            throw new Error("");
          if (!(this instanceof E))
            throw new Error("");
          if (!(w instanceof o))
            throw new Error("");
          Object.defineProperty(this, "visitor", {
            value: y,
            writable: !1,
            enumerable: !0,
            configurable: !1
          }), this.currentPath = w, this.needToCallTraverse = !0, Object.seal(this);
        }
        if (!(y instanceof E))
          throw new Error("");
        var S = m.prototype = Object.create(y);
        return S.constructor = m, B(S, p), m;
      }
      var p = /* @__PURE__ */ Object.create(null);
      return p.reset = function(m) {
        if (!(this instanceof this.Context))
          throw new Error("");
        if (!(m instanceof o))
          throw new Error("");
        return this.currentPath = m, this.needToCallTraverse = !0, this;
      }, p.invokeVisitorMethod = function(m) {
        if (!(this instanceof this.Context))
          throw new Error("");
        if (!(this.currentPath instanceof o))
          throw new Error("");
        var S = this.visitor[m].call(this, this.currentPath);
        if (S === !1 ? this.needToCallTraverse = !1 : S !== C && (this.currentPath = this.currentPath.replace(S)[0], this.needToCallTraverse && this.traverse(this.currentPath)), this.needToCallTraverse !== !1)
          throw new Error("Must either call this.traverse or return false in " + m);
        var w = this.currentPath;
        return w && w.value;
      }, p.traverse = function(m, S) {
        if (!(this instanceof this.Context))
          throw new Error("");
        if (!(m instanceof o))
          throw new Error("");
        if (!(this.currentPath instanceof o))
          throw new Error("");
        return this.needToCallTraverse = !1, Q(m, E.fromMethodsObject(S || this.visitor));
      }, p.visit = function(m, S) {
        if (!(this instanceof this.Context))
          throw new Error("");
        if (!(m instanceof o))
          throw new Error("");
        if (!(this.currentPath instanceof o))
          throw new Error("");
        return this.needToCallTraverse = !1, E.fromMethodsObject(S || this.visitor).visitWithoutReset(m);
      }, p.reportChanged = function() {
        this.visitor.reportChanged();
      }, p.abort = function() {
        this.needToCallTraverse = !1, this.visitor.abort();
      }, E;
    }
    A.default = s, t.exports = A.default;
  }(Jh, Jh.exports)), Jh.exports;
}
var Yh = { exports: {} }, Jb;
function ttA() {
  return Jb || (Jb = 1, function(t, A) {
    Object.defineProperty(A, "__esModule", { value: !0 });
    var e = it, r = e.__importDefault(Nt());
    function i(n) {
      var s = n.use(r.default), a = s.getFieldNames, g = s.getFieldValue, o = s.builtInTypes.array, u = s.builtInTypes.object, I = s.builtInTypes.Date, c = s.builtInTypes.RegExp, C = Object.prototype.hasOwnProperty;
      function E(f, p, y) {
        return o.check(y) ? y.length = 0 : y = null, B(f, p, y);
      }
      E.assert = function(f, p) {
        var y = [];
        if (!E(f, p, y))
          if (y.length === 0) {
            if (f !== p)
              throw new Error("Nodes must be equal");
          } else
            throw new Error("Nodes differ in the following path: " + y.map(l).join(""));
      };
      function l(f) {
        return /[_$a-z][_$a-z0-9]*/i.test(f) ? "." + f : "[" + JSON.stringify(f) + "]";
      }
      function B(f, p, y) {
        return f === p ? !0 : o.check(f) ? h(f, p, y) : u.check(f) ? Q(f, p, y) : I.check(f) ? I.check(p) && +f == +p : c.check(f) ? c.check(p) && f.source === p.source && f.global === p.global && f.multiline === p.multiline && f.ignoreCase === p.ignoreCase : f == p;
      }
      function h(f, p, y) {
        o.assert(f);
        var m = f.length;
        if (!o.check(p) || p.length !== m)
          return y && y.push("length"), !1;
        for (var S = 0; S < m; ++S) {
          if (y && y.push(S), S in f != S in p || !B(f[S], p[S], y))
            return !1;
          if (y) {
            var w = y.pop();
            if (w !== S)
              throw new Error("" + w);
          }
        }
        return !0;
      }
      function Q(f, p, y) {
        if (u.assert(f), !u.check(p))
          return !1;
        if (f.type !== p.type)
          return y && y.push("type"), !1;
        var m = a(f), S = m.length, w = a(p), F = w.length;
        if (S === F) {
          for (var b = 0; b < S; ++b) {
            var G = m[b], T = g(f, G), K = g(p, G);
            if (y && y.push(G), !B(T, K, y))
              return !1;
            if (y) {
              var H = y.pop();
              if (H !== G)
                throw new Error("" + H);
            }
          }
          return !0;
        }
        if (!y)
          return !1;
        var j = /* @__PURE__ */ Object.create(null);
        for (b = 0; b < S; ++b)
          j[m[b]] = !0;
        for (b = 0; b < F; ++b) {
          if (G = w[b], !C.call(j, G))
            return y.push(G), !1;
          delete j[G];
        }
        for (G in j) {
          y.push(G);
          break;
        }
        return !1;
      }
      return E;
    }
    A.default = i, t.exports = A.default;
  }(Yh, Yh.exports)), Yh.exports;
}
var Hb;
function rtA() {
  return Hb || (Hb = 1, function(t, A) {
    Object.defineProperty(A, "__esModule", { value: !0 });
    var e = it, r = e.__importDefault(Nt()), i = e.__importDefault(etA()), n = e.__importDefault(ttA()), s = e.__importDefault(DK()), a = e.__importDefault(SK());
    function g(u) {
      var I = o(), c = I.use(r.default);
      u.forEach(I.use), c.finalize();
      var C = I.use(i.default);
      return {
        Type: c.Type,
        builtInTypes: c.builtInTypes,
        namedTypes: c.namedTypes,
        builders: c.builders,
        defineMethod: c.defineMethod,
        getFieldNames: c.getFieldNames,
        getFieldValue: c.getFieldValue,
        eachField: c.eachField,
        someField: c.someField,
        getSupertypeNames: c.getSupertypeNames,
        getBuilderName: c.getBuilderName,
        astNodesAreEquivalent: I.use(n.default),
        finalize: c.finalize,
        Path: I.use(s.default),
        NodePath: I.use(a.default),
        PathVisitor: C,
        use: I.use,
        visit: C.visit
      };
    }
    A.default = g;
    function o() {
      var u = [], I = [];
      function c(E) {
        var l = u.indexOf(E);
        return l === -1 && (l = u.length, u.push(E), I[l] = E(C)), I[l];
      }
      var C = { use: c };
      return C;
    }
    t.exports = A.default;
  }(Kh, Kh.exports)), Kh.exports;
}
var qh = { exports: {} }, jh = { exports: {} }, Pb;
function Rn() {
  return Pb || (Pb = 1, function(t, A) {
    Object.defineProperty(A, "__esModule", { value: !0 });
    var e = it, r = e.__importDefault(Nt());
    function i(n) {
      var s = n.use(r.default), a = s.Type, g = s.builtInTypes, o = g.number;
      function u(E) {
        return a.from(function(l) {
          return o.check(l) && l >= E;
        }, o + " >= " + E);
      }
      var I = {
        // Functions were used because (among other reasons) that's the most
        // elegant way to allow for the emptyArray one always to give a new
        // array instance.
        null: function() {
          return null;
        },
        emptyArray: function() {
          return [];
        },
        false: function() {
          return !1;
        },
        true: function() {
          return !0;
        },
        undefined: function() {
        },
        "use strict": function() {
          return "use strict";
        }
      }, c = a.or(g.string, g.number, g.boolean, g.null, g.undefined), C = a.from(function(E) {
        if (E === null)
          return !0;
        var l = typeof E;
        return !(l === "object" || l === "function");
      }, c.toString());
      return {
        geq: u,
        defaults: I,
        isPrimitive: C
      };
    }
    A.default = i, t.exports = A.default;
  }(jh, jh.exports)), jh.exports;
}
var Ob;
function OS() {
  return Ob || (Ob = 1, function(t, A) {
    Object.defineProperty(A, "__esModule", { value: !0 });
    var e = it, r = e.__importDefault(Nt()), i = e.__importDefault(Rn());
    function n(s) {
      var a = s.use(r.default), g = a.Type, o = g.def, u = g.or, I = s.use(i.default), c = I.defaults, C = I.geq;
      o("Printable").field("loc", u(o("SourceLocation"), null), c.null, !0), o("Node").bases("Printable").field("type", String).field("comments", u([o("Comment")], null), c.null, !0), o("SourceLocation").field("start", o("Position")).field("end", o("Position")).field("source", u(String, null), c.null), o("Position").field("line", C(1)).field("column", C(0)), o("File").bases("Node").build("program", "name").field("program", o("Program")).field("name", u(String, null), c.null), o("Program").bases("Node").build("body").field("body", [o("Statement")]), o("Function").bases("Node").field("id", u(o("Identifier"), null), c.null).field("params", [o("Pattern")]).field("body", o("BlockStatement")).field("generator", Boolean, c.false).field("async", Boolean, c.false), o("Statement").bases("Node"), o("EmptyStatement").bases("Statement").build(), o("BlockStatement").bases("Statement").build("body").field("body", [o("Statement")]), o("ExpressionStatement").bases("Statement").build("expression").field("expression", o("Expression")), o("IfStatement").bases("Statement").build("test", "consequent", "alternate").field("test", o("Expression")).field("consequent", o("Statement")).field("alternate", u(o("Statement"), null), c.null), o("LabeledStatement").bases("Statement").build("label", "body").field("label", o("Identifier")).field("body", o("Statement")), o("BreakStatement").bases("Statement").build("label").field("label", u(o("Identifier"), null), c.null), o("ContinueStatement").bases("Statement").build("label").field("label", u(o("Identifier"), null), c.null), o("WithStatement").bases("Statement").build("object", "body").field("object", o("Expression")).field("body", o("Statement")), o("SwitchStatement").bases("Statement").build("discriminant", "cases", "lexical").field("discriminant", o("Expression")).field("cases", [o("SwitchCase")]).field("lexical", Boolean, c.false), o("ReturnStatement").bases("Statement").build("argument").field("argument", u(o("Expression"), null)), o("ThrowStatement").bases("Statement").build("argument").field("argument", o("Expression")), o("TryStatement").bases("Statement").build("block", "handler", "finalizer").field("block", o("BlockStatement")).field("handler", u(o("CatchClause"), null), function() {
        return this.handlers && this.handlers[0] || null;
      }).field("handlers", [o("CatchClause")], function() {
        return this.handler ? [this.handler] : [];
      }, !0).field("guardedHandlers", [o("CatchClause")], c.emptyArray).field("finalizer", u(o("BlockStatement"), null), c.null), o("CatchClause").bases("Node").build("param", "guard", "body").field("param", u(o("Pattern"), null), c.null).field("guard", u(o("Expression"), null), c.null).field("body", o("BlockStatement")), o("WhileStatement").bases("Statement").build("test", "body").field("test", o("Expression")).field("body", o("Statement")), o("DoWhileStatement").bases("Statement").build("body", "test").field("body", o("Statement")).field("test", o("Expression")), o("ForStatement").bases("Statement").build("init", "test", "update", "body").field("init", u(o("VariableDeclaration"), o("Expression"), null)).field("test", u(o("Expression"), null)).field("update", u(o("Expression"), null)).field("body", o("Statement")), o("ForInStatement").bases("Statement").build("left", "right", "body").field("left", u(o("VariableDeclaration"), o("Expression"))).field("right", o("Expression")).field("body", o("Statement")), o("DebuggerStatement").bases("Statement").build(), o("Declaration").bases("Statement"), o("FunctionDeclaration").bases("Function", "Declaration").build("id", "params", "body").field("id", o("Identifier")), o("FunctionExpression").bases("Function", "Expression").build("id", "params", "body"), o("VariableDeclaration").bases("Declaration").build("kind", "declarations").field("kind", u("var", "let", "const")).field("declarations", [o("VariableDeclarator")]), o("VariableDeclarator").bases("Node").build("id", "init").field("id", o("Pattern")).field("init", u(o("Expression"), null), c.null), o("Expression").bases("Node"), o("ThisExpression").bases("Expression").build(), o("ArrayExpression").bases("Expression").build("elements").field("elements", [u(o("Expression"), null)]), o("ObjectExpression").bases("Expression").build("properties").field("properties", [o("Property")]), o("Property").bases("Node").build("kind", "key", "value").field("kind", u("init", "get", "set")).field("key", u(o("Literal"), o("Identifier"))).field("value", o("Expression")), o("SequenceExpression").bases("Expression").build("expressions").field("expressions", [o("Expression")]);
      var E = u("-", "+", "!", "~", "typeof", "void", "delete");
      o("UnaryExpression").bases("Expression").build("operator", "argument", "prefix").field("operator", E).field("argument", o("Expression")).field("prefix", Boolean, c.true);
      var l = u(
        "==",
        "!=",
        "===",
        "!==",
        "<",
        "<=",
        ">",
        ">=",
        "<<",
        ">>",
        ">>>",
        "+",
        "-",
        "*",
        "/",
        "%",
        "**",
        "&",
        // TODO Missing from the Parser API.
        "|",
        "^",
        "in",
        "instanceof"
      );
      o("BinaryExpression").bases("Expression").build("operator", "left", "right").field("operator", l).field("left", o("Expression")).field("right", o("Expression"));
      var B = u("=", "+=", "-=", "*=", "/=", "%=", "<<=", ">>=", ">>>=", "|=", "^=", "&=");
      o("AssignmentExpression").bases("Expression").build("operator", "left", "right").field("operator", B).field("left", u(o("Pattern"), o("MemberExpression"))).field("right", o("Expression"));
      var h = u("++", "--");
      o("UpdateExpression").bases("Expression").build("operator", "argument", "prefix").field("operator", h).field("argument", o("Expression")).field("prefix", Boolean);
      var Q = u("||", "&&");
      o("LogicalExpression").bases("Expression").build("operator", "left", "right").field("operator", Q).field("left", o("Expression")).field("right", o("Expression")), o("ConditionalExpression").bases("Expression").build("test", "consequent", "alternate").field("test", o("Expression")).field("consequent", o("Expression")).field("alternate", o("Expression")), o("NewExpression").bases("Expression").build("callee", "arguments").field("callee", o("Expression")).field("arguments", [o("Expression")]), o("CallExpression").bases("Expression").build("callee", "arguments").field("callee", o("Expression")).field("arguments", [o("Expression")]), o("MemberExpression").bases("Expression").build("object", "property", "computed").field("object", o("Expression")).field("property", u(o("Identifier"), o("Expression"))).field("computed", Boolean, function() {
        var f = this.property.type;
        return f === "Literal" || f === "MemberExpression" || f === "BinaryExpression";
      }), o("Pattern").bases("Node"), o("SwitchCase").bases("Node").build("test", "consequent").field("test", u(o("Expression"), null)).field("consequent", [o("Statement")]), o("Identifier").bases("Expression", "Pattern").build("name").field("name", String).field("optional", Boolean, c.false), o("Literal").bases("Expression").build("value").field("value", u(String, Boolean, null, Number, RegExp)).field("regex", u({
        pattern: String,
        flags: String
      }, null), function() {
        if (this.value instanceof RegExp) {
          var f = "";
          return this.value.ignoreCase && (f += "i"), this.value.multiline && (f += "m"), this.value.global && (f += "g"), {
            pattern: this.value.source,
            flags: f
          };
        }
        return null;
      }), o("Comment").bases("Printable").field("value", String).field("leading", Boolean, c.true).field("trailing", Boolean, c.false);
    }
    A.default = n, t.exports = A.default;
  }(qh, qh.exports)), qh.exports;
}
var Wh = { exports: {} }, Yb;
function FK() {
  return Yb || (Yb = 1, function(t, A) {
    Object.defineProperty(A, "__esModule", { value: !0 });
    var e = it, r = e.__importDefault(OS()), i = e.__importDefault(Nt()), n = e.__importDefault(Rn());
    function s(a) {
      a.use(r.default);
      var g = a.use(i.default), o = g.Type.def, u = g.Type.or, I = a.use(n.default).defaults;
      o("Function").field("generator", Boolean, I.false).field("expression", Boolean, I.false).field("defaults", [u(o("Expression"), null)], I.emptyArray).field("rest", u(o("Identifier"), null), I.null), o("RestElement").bases("Pattern").build("argument").field("argument", o("Pattern")).field(
        "typeAnnotation",
        // for Babylon. Flow parser puts it on the identifier
        u(o("TypeAnnotation"), o("TSTypeAnnotation"), null),
        I.null
      ), o("SpreadElementPattern").bases("Pattern").build("argument").field("argument", o("Pattern")), o("FunctionDeclaration").build("id", "params", "body", "generator", "expression"), o("FunctionExpression").build("id", "params", "body", "generator", "expression"), o("ArrowFunctionExpression").bases("Function", "Expression").build("params", "body", "expression").field("id", null, I.null).field("body", u(o("BlockStatement"), o("Expression"))).field("generator", !1, I.false), o("ForOfStatement").bases("Statement").build("left", "right", "body").field("left", u(o("VariableDeclaration"), o("Pattern"))).field("right", o("Expression")).field("body", o("Statement")), o("YieldExpression").bases("Expression").build("argument", "delegate").field("argument", u(o("Expression"), null)).field("delegate", Boolean, I.false), o("GeneratorExpression").bases("Expression").build("body", "blocks", "filter").field("body", o("Expression")).field("blocks", [o("ComprehensionBlock")]).field("filter", u(o("Expression"), null)), o("ComprehensionExpression").bases("Expression").build("body", "blocks", "filter").field("body", o("Expression")).field("blocks", [o("ComprehensionBlock")]).field("filter", u(o("Expression"), null)), o("ComprehensionBlock").bases("Node").build("left", "right", "each").field("left", o("Pattern")).field("right", o("Expression")).field("each", Boolean), o("Property").field("key", u(o("Literal"), o("Identifier"), o("Expression"))).field("value", u(o("Expression"), o("Pattern"))).field("method", Boolean, I.false).field("shorthand", Boolean, I.false).field("computed", Boolean, I.false), o("ObjectProperty").field("shorthand", Boolean, I.false), o("PropertyPattern").bases("Pattern").build("key", "pattern").field("key", u(o("Literal"), o("Identifier"), o("Expression"))).field("pattern", o("Pattern")).field("computed", Boolean, I.false), o("ObjectPattern").bases("Pattern").build("properties").field("properties", [u(o("PropertyPattern"), o("Property"))]), o("ArrayPattern").bases("Pattern").build("elements").field("elements", [u(o("Pattern"), null)]), o("MethodDefinition").bases("Declaration").build("kind", "key", "value", "static").field("kind", u("constructor", "method", "get", "set")).field("key", o("Expression")).field("value", o("Function")).field("computed", Boolean, I.false).field("static", Boolean, I.false), o("SpreadElement").bases("Node").build("argument").field("argument", o("Expression")), o("ArrayExpression").field("elements", [u(o("Expression"), o("SpreadElement"), o("RestElement"), null)]), o("NewExpression").field("arguments", [u(o("Expression"), o("SpreadElement"))]), o("CallExpression").field("arguments", [u(o("Expression"), o("SpreadElement"))]), o("AssignmentPattern").bases("Pattern").build("left", "right").field("left", o("Pattern")).field("right", o("Expression"));
      var c = u(o("MethodDefinition"), o("VariableDeclarator"), o("ClassPropertyDefinition"), o("ClassProperty"));
      o("ClassProperty").bases("Declaration").build("key").field("key", u(o("Literal"), o("Identifier"), o("Expression"))).field("computed", Boolean, I.false), o("ClassPropertyDefinition").bases("Declaration").build("definition").field("definition", c), o("ClassBody").bases("Declaration").build("body").field("body", [c]), o("ClassDeclaration").bases("Declaration").build("id", "body", "superClass").field("id", u(o("Identifier"), null)).field("body", o("ClassBody")).field("superClass", u(o("Expression"), null), I.null), o("ClassExpression").bases("Expression").build("id", "body", "superClass").field("id", u(o("Identifier"), null), I.null).field("body", o("ClassBody")).field("superClass", u(o("Expression"), null), I.null), o("Specifier").bases("Node"), o("ModuleSpecifier").bases("Specifier").field("local", u(o("Identifier"), null), I.null).field("id", u(o("Identifier"), null), I.null).field("name", u(o("Identifier"), null), I.null), o("ImportSpecifier").bases("ModuleSpecifier").build("id", "name"), o("ImportNamespaceSpecifier").bases("ModuleSpecifier").build("id"), o("ImportDefaultSpecifier").bases("ModuleSpecifier").build("id"), o("ImportDeclaration").bases("Declaration").build("specifiers", "source", "importKind").field("specifiers", [u(o("ImportSpecifier"), o("ImportNamespaceSpecifier"), o("ImportDefaultSpecifier"))], I.emptyArray).field("source", o("Literal")).field("importKind", u("value", "type"), function() {
        return "value";
      }), o("TaggedTemplateExpression").bases("Expression").build("tag", "quasi").field("tag", o("Expression")).field("quasi", o("TemplateLiteral")), o("TemplateLiteral").bases("Expression").build("quasis", "expressions").field("quasis", [o("TemplateElement")]).field("expressions", [o("Expression")]), o("TemplateElement").bases("Node").build("value", "tail").field("value", { cooked: String, raw: String }).field("tail", Boolean);
    }
    A.default = s, t.exports = A.default;
  }(Wh, Wh.exports)), Wh.exports;
}
var Vh = { exports: {} }, qb;
function CI() {
  return qb || (qb = 1, function(t, A) {
    Object.defineProperty(A, "__esModule", { value: !0 });
    var e = it, r = e.__importDefault(FK()), i = e.__importDefault(Nt()), n = e.__importDefault(Rn());
    function s(a) {
      a.use(r.default);
      var g = a.use(i.default), o = g.Type.def, u = g.Type.or, I = a.use(n.default).defaults;
      o("Function").field("async", Boolean, I.false), o("SpreadProperty").bases("Node").build("argument").field("argument", o("Expression")), o("ObjectExpression").field("properties", [u(o("Property"), o("SpreadProperty"), o("SpreadElement"))]), o("SpreadPropertyPattern").bases("Pattern").build("argument").field("argument", o("Pattern")), o("ObjectPattern").field("properties", [u(o("Property"), o("PropertyPattern"), o("SpreadPropertyPattern"))]), o("AwaitExpression").bases("Expression").build("argument", "all").field("argument", u(o("Expression"), null)).field("all", Boolean, I.false);
    }
    A.default = s, t.exports = A.default;
  }(Vh, Vh.exports)), Vh.exports;
}
var Zh = { exports: {} }, jb;
function itA() {
  return jb || (jb = 1, function(t, A) {
    Object.defineProperty(A, "__esModule", { value: !0 });
    var e = it, r = e.__importDefault(CI()), i = e.__importDefault(Nt());
    function n(s) {
      s.use(r.default);
      var a = s.use(i.default), g = a.Type.def;
      g("ImportExpression").bases("Expression").build("source").field("source", g("Expression"));
    }
    A.default = n, t.exports = A.default;
  }(Zh, Zh.exports)), Zh.exports;
}
var Xh = { exports: {} }, Wb;
function ntA() {
  return Wb || (Wb = 1, function(t, A) {
    Object.defineProperty(A, "__esModule", { value: !0 });
    var e = it, r = e.__importDefault(CI()), i = e.__importDefault(Nt()), n = e.__importDefault(Rn());
    function s(a) {
      a.use(r.default);
      var g = a.use(i.default), o = g.Type.def, u = g.Type.or, I = a.use(n.default).defaults;
      o("JSXAttribute").bases("Node").build("name", "value").field("name", u(o("JSXIdentifier"), o("JSXNamespacedName"))).field("value", u(
        o("Literal"),
        // attr="value"
        o("JSXExpressionContainer"),
        // attr={value}
        null
        // attr= or just attr
      ), I.null), o("JSXIdentifier").bases("Identifier").build("name").field("name", String), o("JSXNamespacedName").bases("Node").build("namespace", "name").field("namespace", o("JSXIdentifier")).field("name", o("JSXIdentifier")), o("JSXMemberExpression").bases("MemberExpression").build("object", "property").field("object", u(o("JSXIdentifier"), o("JSXMemberExpression"))).field("property", o("JSXIdentifier")).field("computed", Boolean, I.false);
      var c = u(o("JSXIdentifier"), o("JSXNamespacedName"), o("JSXMemberExpression"));
      o("JSXSpreadAttribute").bases("Node").build("argument").field("argument", o("Expression"));
      var C = [u(o("JSXAttribute"), o("JSXSpreadAttribute"))];
      o("JSXExpressionContainer").bases("Expression").build("expression").field("expression", o("Expression")), o("JSXElement").bases("Expression").build("openingElement", "closingElement", "children").field("openingElement", o("JSXOpeningElement")).field("closingElement", u(o("JSXClosingElement"), null), I.null).field("children", [u(
        o("JSXElement"),
        o("JSXExpressionContainer"),
        o("JSXFragment"),
        o("JSXText"),
        o("Literal")
        // TODO Esprima should return JSXText instead.
      )], I.emptyArray).field("name", c, function() {
        return this.openingElement.name;
      }, !0).field("selfClosing", Boolean, function() {
        return this.openingElement.selfClosing;
      }, !0).field("attributes", C, function() {
        return this.openingElement.attributes;
      }, !0), o("JSXOpeningElement").bases("Node").build("name", "attributes", "selfClosing").field("name", c).field("attributes", C, I.emptyArray).field("selfClosing", Boolean, I.false), o("JSXClosingElement").bases("Node").build("name").field("name", c), o("JSXFragment").bases("Expression").build("openingElement", "closingElement", "children").field("openingElement", o("JSXOpeningFragment")).field("closingElement", o("JSXClosingFragment")).field("children", [u(
        o("JSXElement"),
        o("JSXExpressionContainer"),
        o("JSXFragment"),
        o("JSXText"),
        o("Literal")
        // TODO Esprima should return JSXText instead.
      )], I.emptyArray), o("JSXOpeningFragment").bases("Node").build(), o("JSXClosingFragment").bases("Node").build(), o("JSXText").bases("Literal").build("value").field("value", String), o("JSXEmptyExpression").bases("Expression").build(), o("JSXSpreadChild").bases("Expression").build("expression").field("expression", o("Expression"));
    }
    A.default = s, t.exports = A.default;
  }(Xh, Xh.exports)), Xh.exports;
}
var zh = { exports: {} }, $h = { exports: {} }, Vb;
function kK() {
  return Vb || (Vb = 1, function(t, A) {
    Object.defineProperty(A, "__esModule", { value: !0 });
    var e = it, r = e.__importDefault(Nt()), i = e.__importDefault(Rn());
    function n(s) {
      var a = s.use(r.default), g = a.Type.def, o = a.Type.or, u = s.use(i.default).defaults, I = o(g("TypeAnnotation"), g("TSTypeAnnotation"), null), c = o(g("TypeParameterDeclaration"), g("TSTypeParameterDeclaration"), null);
      g("Identifier").field("typeAnnotation", I, u.null), g("ObjectPattern").field("typeAnnotation", I, u.null), g("Function").field("returnType", I, u.null).field("typeParameters", c, u.null), g("ClassProperty").build("key", "value", "typeAnnotation", "static").field("value", o(g("Expression"), null)).field("static", Boolean, u.false).field("typeAnnotation", I, u.null), [
        "ClassDeclaration",
        "ClassExpression"
      ].forEach(function(C) {
        g(C).field("typeParameters", c, u.null).field("superTypeParameters", o(g("TypeParameterInstantiation"), g("TSTypeParameterInstantiation"), null), u.null).field("implements", o([g("ClassImplements")], [g("TSExpressionWithTypeArguments")]), u.emptyArray);
      });
    }
    A.default = n, t.exports = A.default;
  }($h, $h.exports)), $h.exports;
}
var Zb;
function vK() {
  return Zb || (Zb = 1, function(t, A) {
    Object.defineProperty(A, "__esModule", { value: !0 });
    var e = it, r = e.__importDefault(CI()), i = e.__importDefault(kK()), n = e.__importDefault(Nt()), s = e.__importDefault(Rn());
    function a(g) {
      g.use(r.default), g.use(i.default);
      var o = g.use(n.default), u = o.Type.def, I = o.Type.or, c = g.use(s.default).defaults;
      u("Flow").bases("Node"), u("FlowType").bases("Flow"), u("AnyTypeAnnotation").bases("FlowType").build(), u("EmptyTypeAnnotation").bases("FlowType").build(), u("MixedTypeAnnotation").bases("FlowType").build(), u("VoidTypeAnnotation").bases("FlowType").build(), u("NumberTypeAnnotation").bases("FlowType").build(), u("NumberLiteralTypeAnnotation").bases("FlowType").build("value", "raw").field("value", Number).field("raw", String), u("NumericLiteralTypeAnnotation").bases("FlowType").build("value", "raw").field("value", Number).field("raw", String), u("StringTypeAnnotation").bases("FlowType").build(), u("StringLiteralTypeAnnotation").bases("FlowType").build("value", "raw").field("value", String).field("raw", String), u("BooleanTypeAnnotation").bases("FlowType").build(), u("BooleanLiteralTypeAnnotation").bases("FlowType").build("value", "raw").field("value", Boolean).field("raw", String), u("TypeAnnotation").bases("Node").build("typeAnnotation").field("typeAnnotation", u("FlowType")), u("NullableTypeAnnotation").bases("FlowType").build("typeAnnotation").field("typeAnnotation", u("FlowType")), u("NullLiteralTypeAnnotation").bases("FlowType").build(), u("NullTypeAnnotation").bases("FlowType").build(), u("ThisTypeAnnotation").bases("FlowType").build(), u("ExistsTypeAnnotation").bases("FlowType").build(), u("ExistentialTypeParam").bases("FlowType").build(), u("FunctionTypeAnnotation").bases("FlowType").build("params", "returnType", "rest", "typeParameters").field("params", [u("FunctionTypeParam")]).field("returnType", u("FlowType")).field("rest", I(u("FunctionTypeParam"), null)).field("typeParameters", I(u("TypeParameterDeclaration"), null)), u("FunctionTypeParam").bases("Node").build("name", "typeAnnotation", "optional").field("name", u("Identifier")).field("typeAnnotation", u("FlowType")).field("optional", Boolean), u("ArrayTypeAnnotation").bases("FlowType").build("elementType").field("elementType", u("FlowType")), u("ObjectTypeAnnotation").bases("FlowType").build("properties", "indexers", "callProperties").field("properties", [
        I(u("ObjectTypeProperty"), u("ObjectTypeSpreadProperty"))
      ]).field("indexers", [u("ObjectTypeIndexer")], c.emptyArray).field("callProperties", [u("ObjectTypeCallProperty")], c.emptyArray).field("inexact", I(Boolean, void 0), c.undefined).field("exact", Boolean, c.false).field("internalSlots", [u("ObjectTypeInternalSlot")], c.emptyArray), u("Variance").bases("Node").build("kind").field("kind", I("plus", "minus"));
      var C = I(u("Variance"), "plus", "minus", null);
      u("ObjectTypeProperty").bases("Node").build("key", "value", "optional").field("key", I(u("Literal"), u("Identifier"))).field("value", u("FlowType")).field("optional", Boolean).field("variance", C, c.null), u("ObjectTypeIndexer").bases("Node").build("id", "key", "value").field("id", u("Identifier")).field("key", u("FlowType")).field("value", u("FlowType")).field("variance", C, c.null), u("ObjectTypeCallProperty").bases("Node").build("value").field("value", u("FunctionTypeAnnotation")).field("static", Boolean, c.false), u("QualifiedTypeIdentifier").bases("Node").build("qualification", "id").field("qualification", I(u("Identifier"), u("QualifiedTypeIdentifier"))).field("id", u("Identifier")), u("GenericTypeAnnotation").bases("FlowType").build("id", "typeParameters").field("id", I(u("Identifier"), u("QualifiedTypeIdentifier"))).field("typeParameters", I(u("TypeParameterInstantiation"), null)), u("MemberTypeAnnotation").bases("FlowType").build("object", "property").field("object", u("Identifier")).field("property", I(u("MemberTypeAnnotation"), u("GenericTypeAnnotation"))), u("UnionTypeAnnotation").bases("FlowType").build("types").field("types", [u("FlowType")]), u("IntersectionTypeAnnotation").bases("FlowType").build("types").field("types", [u("FlowType")]), u("TypeofTypeAnnotation").bases("FlowType").build("argument").field("argument", u("FlowType")), u("ObjectTypeSpreadProperty").bases("Node").build("argument").field("argument", u("FlowType")), u("ObjectTypeInternalSlot").bases("Node").build("id", "value", "optional", "static", "method").field("id", u("Identifier")).field("value", u("FlowType")).field("optional", Boolean).field("static", Boolean).field("method", Boolean), u("TypeParameterDeclaration").bases("Node").build("params").field("params", [u("TypeParameter")]), u("TypeParameterInstantiation").bases("Node").build("params").field("params", [u("FlowType")]), u("TypeParameter").bases("FlowType").build("name", "variance", "bound").field("name", String).field("variance", C, c.null).field("bound", I(u("TypeAnnotation"), null), c.null), u("ClassProperty").field("variance", C, c.null), u("ClassImplements").bases("Node").build("id").field("id", u("Identifier")).field("superClass", I(u("Expression"), null), c.null).field("typeParameters", I(u("TypeParameterInstantiation"), null), c.null), u("InterfaceTypeAnnotation").bases("FlowType").build("body", "extends").field("body", u("ObjectTypeAnnotation")).field("extends", I([u("InterfaceExtends")], null), c.null), u("InterfaceDeclaration").bases("Declaration").build("id", "body", "extends").field("id", u("Identifier")).field("typeParameters", I(u("TypeParameterDeclaration"), null), c.null).field("body", u("ObjectTypeAnnotation")).field("extends", [u("InterfaceExtends")]), u("DeclareInterface").bases("InterfaceDeclaration").build("id", "body", "extends"), u("InterfaceExtends").bases("Node").build("id").field("id", u("Identifier")).field("typeParameters", I(u("TypeParameterInstantiation"), null), c.null), u("TypeAlias").bases("Declaration").build("id", "typeParameters", "right").field("id", u("Identifier")).field("typeParameters", I(u("TypeParameterDeclaration"), null)).field("right", u("FlowType")), u("OpaqueType").bases("Declaration").build("id", "typeParameters", "impltype", "supertype").field("id", u("Identifier")).field("typeParameters", I(u("TypeParameterDeclaration"), null)).field("impltype", u("FlowType")).field("supertype", u("FlowType")), u("DeclareTypeAlias").bases("TypeAlias").build("id", "typeParameters", "right"), u("DeclareOpaqueType").bases("TypeAlias").build("id", "typeParameters", "supertype"), u("TypeCastExpression").bases("Expression").build("expression", "typeAnnotation").field("expression", u("Expression")).field("typeAnnotation", u("TypeAnnotation")), u("TupleTypeAnnotation").bases("FlowType").build("types").field("types", [u("FlowType")]), u("DeclareVariable").bases("Statement").build("id").field("id", u("Identifier")), u("DeclareFunction").bases("Statement").build("id").field("id", u("Identifier")), u("DeclareClass").bases("InterfaceDeclaration").build("id"), u("DeclareModule").bases("Statement").build("id", "body").field("id", I(u("Identifier"), u("Literal"))).field("body", u("BlockStatement")), u("DeclareModuleExports").bases("Statement").build("typeAnnotation").field("typeAnnotation", u("TypeAnnotation")), u("DeclareExportDeclaration").bases("Declaration").build("default", "declaration", "specifiers", "source").field("default", Boolean).field("declaration", I(
        u("DeclareVariable"),
        u("DeclareFunction"),
        u("DeclareClass"),
        u("FlowType"),
        // Implies default.
        null
      )).field("specifiers", [I(u("ExportSpecifier"), u("ExportBatchSpecifier"))], c.emptyArray).field("source", I(u("Literal"), null), c.null), u("DeclareExportAllDeclaration").bases("Declaration").build("source").field("source", I(u("Literal"), null), c.null), u("FlowPredicate").bases("Flow"), u("InferredPredicate").bases("FlowPredicate").build(), u("DeclaredPredicate").bases("FlowPredicate").build("value").field("value", u("Expression")), u("CallExpression").field("typeArguments", I(null, u("TypeParameterInstantiation")), c.null), u("NewExpression").field("typeArguments", I(null, u("TypeParameterInstantiation")), c.null);
    }
    A.default = a, t.exports = A.default;
  }(zh, zh.exports)), zh.exports;
}
var AQ = { exports: {} }, Xb;
function stA() {
  return Xb || (Xb = 1, function(t, A) {
    Object.defineProperty(A, "__esModule", { value: !0 });
    var e = it, r = e.__importDefault(CI()), i = e.__importDefault(Nt()), n = e.__importDefault(Rn());
    function s(a) {
      a.use(r.default);
      var g = a.use(i.default), o = a.use(n.default).defaults, u = g.Type.def, I = g.Type.or;
      u("VariableDeclaration").field("declarations", [I(
        u("VariableDeclarator"),
        u("Identifier")
        // Esprima deviation.
      )]), u("Property").field("value", I(
        u("Expression"),
        u("Pattern")
        // Esprima deviation.
      )), u("ArrayPattern").field("elements", [I(u("Pattern"), u("SpreadElement"), null)]), u("ObjectPattern").field("properties", [I(
        u("Property"),
        u("PropertyPattern"),
        u("SpreadPropertyPattern"),
        u("SpreadProperty")
        // Used by Esprima.
      )]), u("ExportSpecifier").bases("ModuleSpecifier").build("id", "name"), u("ExportBatchSpecifier").bases("Specifier").build(), u("ExportDeclaration").bases("Declaration").build("default", "declaration", "specifiers", "source").field("default", Boolean).field("declaration", I(
        u("Declaration"),
        u("Expression"),
        // Implies default.
        null
      )).field("specifiers", [I(u("ExportSpecifier"), u("ExportBatchSpecifier"))], o.emptyArray).field("source", I(u("Literal"), null), o.null), u("Block").bases("Comment").build(
        "value",
        /*optional:*/
        "leading",
        "trailing"
      ), u("Line").bases("Comment").build(
        "value",
        /*optional:*/
        "leading",
        "trailing"
      );
    }
    A.default = s, t.exports = A.default;
  }(AQ, AQ.exports)), AQ.exports;
}
var eQ = { exports: {} }, tQ = { exports: {} }, zb;
function RK() {
  return zb || (zb = 1, function(t, A) {
    Object.defineProperty(A, "__esModule", { value: !0 });
    var e = it, r = e.__importDefault(Nt()), i = e.__importDefault(Rn()), n = e.__importDefault(CI());
    function s(a) {
      a.use(n.default);
      var g = a.use(r.default), o = a.use(i.default).defaults, u = g.Type.def, I = g.Type.or;
      u("Noop").bases("Statement").build(), u("DoExpression").bases("Expression").build("body").field("body", [u("Statement")]), u("Super").bases("Expression").build(), u("BindExpression").bases("Expression").build("object", "callee").field("object", I(u("Expression"), null)).field("callee", u("Expression")), u("Decorator").bases("Node").build("expression").field("expression", u("Expression")), u("Property").field("decorators", I([u("Decorator")], null), o.null), u("MethodDefinition").field("decorators", I([u("Decorator")], null), o.null), u("MetaProperty").bases("Expression").build("meta", "property").field("meta", u("Identifier")).field("property", u("Identifier")), u("ParenthesizedExpression").bases("Expression").build("expression").field("expression", u("Expression")), u("ImportSpecifier").bases("ModuleSpecifier").build("imported", "local").field("imported", u("Identifier")), u("ImportDefaultSpecifier").bases("ModuleSpecifier").build("local"), u("ImportNamespaceSpecifier").bases("ModuleSpecifier").build("local"), u("ExportDefaultDeclaration").bases("Declaration").build("declaration").field("declaration", I(u("Declaration"), u("Expression"))), u("ExportNamedDeclaration").bases("Declaration").build("declaration", "specifiers", "source").field("declaration", I(u("Declaration"), null)).field("specifiers", [u("ExportSpecifier")], o.emptyArray).field("source", I(u("Literal"), null), o.null), u("ExportSpecifier").bases("ModuleSpecifier").build("local", "exported").field("exported", u("Identifier")), u("ExportNamespaceSpecifier").bases("Specifier").build("exported").field("exported", u("Identifier")), u("ExportDefaultSpecifier").bases("Specifier").build("exported").field("exported", u("Identifier")), u("ExportAllDeclaration").bases("Declaration").build("exported", "source").field("exported", I(u("Identifier"), null)).field("source", u("Literal")), u("CommentBlock").bases("Comment").build(
        "value",
        /*optional:*/
        "leading",
        "trailing"
      ), u("CommentLine").bases("Comment").build(
        "value",
        /*optional:*/
        "leading",
        "trailing"
      ), u("Directive").bases("Node").build("value").field("value", u("DirectiveLiteral")), u("DirectiveLiteral").bases("Node", "Expression").build("value").field("value", String, o["use strict"]), u("InterpreterDirective").bases("Node").build("value").field("value", String), u("BlockStatement").bases("Statement").build("body").field("body", [u("Statement")]).field("directives", [u("Directive")], o.emptyArray), u("Program").bases("Node").build("body").field("body", [u("Statement")]).field("directives", [u("Directive")], o.emptyArray).field("interpreter", I(u("InterpreterDirective"), null), o.null), u("StringLiteral").bases("Literal").build("value").field("value", String), u("NumericLiteral").bases("Literal").build("value").field("value", Number).field("raw", I(String, null), o.null).field("extra", {
        rawValue: Number,
        raw: String
      }, function() {
        return {
          rawValue: this.value,
          raw: this.value + ""
        };
      }), u("BigIntLiteral").bases("Literal").build("value").field("value", I(String, Number)).field("extra", {
        rawValue: String,
        raw: String
      }, function() {
        return {
          rawValue: String(this.value),
          raw: this.value + "n"
        };
      }), u("NullLiteral").bases("Literal").build().field("value", null, o.null), u("BooleanLiteral").bases("Literal").build("value").field("value", Boolean), u("RegExpLiteral").bases("Literal").build("pattern", "flags").field("pattern", String).field("flags", String).field("value", RegExp, function() {
        return new RegExp(this.pattern, this.flags);
      });
      var c = I(u("Property"), u("ObjectMethod"), u("ObjectProperty"), u("SpreadProperty"), u("SpreadElement"));
      u("ObjectExpression").bases("Expression").build("properties").field("properties", [c]), u("ObjectMethod").bases("Node", "Function").build("kind", "key", "params", "body", "computed").field("kind", I("method", "get", "set")).field("key", I(u("Literal"), u("Identifier"), u("Expression"))).field("params", [u("Pattern")]).field("body", u("BlockStatement")).field("computed", Boolean, o.false).field("generator", Boolean, o.false).field("async", Boolean, o.false).field(
        "accessibility",
        // TypeScript
        I(u("Literal"), null),
        o.null
      ).field("decorators", I([u("Decorator")], null), o.null), u("ObjectProperty").bases("Node").build("key", "value").field("key", I(u("Literal"), u("Identifier"), u("Expression"))).field("value", I(u("Expression"), u("Pattern"))).field(
        "accessibility",
        // TypeScript
        I(u("Literal"), null),
        o.null
      ).field("computed", Boolean, o.false);
      var C = I(u("MethodDefinition"), u("VariableDeclarator"), u("ClassPropertyDefinition"), u("ClassProperty"), u("ClassPrivateProperty"), u("ClassMethod"), u("ClassPrivateMethod"));
      u("ClassBody").bases("Declaration").build("body").field("body", [C]), u("ClassMethod").bases("Declaration", "Function").build("kind", "key", "params", "body", "computed", "static").field("key", I(u("Literal"), u("Identifier"), u("Expression"))), u("ClassPrivateMethod").bases("Declaration", "Function").build("key", "params", "body", "kind", "computed", "static").field("key", u("PrivateName")), [
        "ClassMethod",
        "ClassPrivateMethod"
      ].forEach(function(l) {
        u(l).field("kind", I("get", "set", "method", "constructor"), function() {
          return "method";
        }).field("body", u("BlockStatement")).field("computed", Boolean, o.false).field("static", I(Boolean, null), o.null).field("abstract", I(Boolean, null), o.null).field("access", I("public", "private", "protected", null), o.null).field("accessibility", I("public", "private", "protected", null), o.null).field("decorators", I([u("Decorator")], null), o.null).field("optional", I(Boolean, null), o.null);
      }), u("ClassPrivateProperty").bases("ClassProperty").build("key", "value").field("key", u("PrivateName")).field("value", I(u("Expression"), null), o.null), u("PrivateName").bases("Expression", "Pattern").build("id").field("id", u("Identifier"));
      var E = I(
        u("Property"),
        u("PropertyPattern"),
        u("SpreadPropertyPattern"),
        u("SpreadProperty"),
        // Used by Esprima
        u("ObjectProperty"),
        // Babel 6
        u("RestProperty")
        // Babel 6
      );
      u("ObjectPattern").bases("Pattern").build("properties").field("properties", [E]).field("decorators", I([u("Decorator")], null), o.null), u("SpreadProperty").bases("Node").build("argument").field("argument", u("Expression")), u("RestProperty").bases("Node").build("argument").field("argument", u("Expression")), u("ForAwaitStatement").bases("Statement").build("left", "right", "body").field("left", I(u("VariableDeclaration"), u("Expression"))).field("right", u("Expression")).field("body", u("Statement")), u("Import").bases("Expression").build();
    }
    A.default = s, t.exports = A.default;
  }(tQ, tQ.exports)), tQ.exports;
}
var $b;
function atA() {
  return $b || ($b = 1, function(t, A) {
    Object.defineProperty(A, "__esModule", { value: !0 });
    var e = it, r = e.__importDefault(RK()), i = e.__importDefault(vK());
    function n(s) {
      s.use(r.default), s.use(i.default);
    }
    A.default = n, t.exports = A.default;
  }(eQ, eQ.exports)), eQ.exports;
}
var rQ = { exports: {} }, AM;
function otA() {
  return AM || (AM = 1, function(t, A) {
    Object.defineProperty(A, "__esModule", { value: !0 });
    var e = it, r = e.__importDefault(RK()), i = e.__importDefault(kK()), n = e.__importDefault(Nt()), s = e.__importDefault(Rn());
    function a(g) {
      g.use(r.default), g.use(i.default);
      var o = g.use(n.default), u = o.namedTypes, I = o.Type.def, c = o.Type.or, C = g.use(s.default).defaults, E = o.Type.from(function(Q, f) {
        return !!(u.StringLiteral && u.StringLiteral.check(Q, f) || u.Literal && u.Literal.check(Q, f) && typeof Q.value == "string");
      }, "StringLiteral");
      I("TSType").bases("Node");
      var l = c(I("Identifier"), I("TSQualifiedName"));
      I("TSTypeReference").bases("TSType", "TSHasOptionalTypeParameterInstantiation").build("typeName", "typeParameters").field("typeName", l), I("TSHasOptionalTypeParameterInstantiation").field("typeParameters", c(I("TSTypeParameterInstantiation"), null), C.null), I("TSHasOptionalTypeParameters").field("typeParameters", c(I("TSTypeParameterDeclaration"), null, void 0), C.null), I("TSHasOptionalTypeAnnotation").field("typeAnnotation", c(I("TSTypeAnnotation"), null), C.null), I("TSQualifiedName").bases("Node").build("left", "right").field("left", l).field("right", l), I("TSAsExpression").bases("Expression", "Pattern").build("expression", "typeAnnotation").field("expression", I("Expression")).field("typeAnnotation", I("TSType")).field("extra", c({ parenthesized: Boolean }, null), C.null), I("TSNonNullExpression").bases("Expression", "Pattern").build("expression").field("expression", I("Expression")), [
        "TSAnyKeyword",
        "TSBigIntKeyword",
        "TSBooleanKeyword",
        "TSNeverKeyword",
        "TSNullKeyword",
        "TSNumberKeyword",
        "TSObjectKeyword",
        "TSStringKeyword",
        "TSSymbolKeyword",
        "TSUndefinedKeyword",
        "TSUnknownKeyword",
        "TSVoidKeyword",
        "TSThisType"
      ].forEach(function(Q) {
        I(Q).bases("TSType").build();
      }), I("TSArrayType").bases("TSType").build("elementType").field("elementType", I("TSType")), I("TSLiteralType").bases("TSType").build("literal").field("literal", c(I("NumericLiteral"), I("StringLiteral"), I("BooleanLiteral"), I("TemplateLiteral"), I("UnaryExpression"))), [
        "TSUnionType",
        "TSIntersectionType"
      ].forEach(function(Q) {
        I(Q).bases("TSType").build("types").field("types", [I("TSType")]);
      }), I("TSConditionalType").bases("TSType").build("checkType", "extendsType", "trueType", "falseType").field("checkType", I("TSType")).field("extendsType", I("TSType")).field("trueType", I("TSType")).field("falseType", I("TSType")), I("TSInferType").bases("TSType").build("typeParameter").field("typeParameter", I("TSTypeParameter")), I("TSParenthesizedType").bases("TSType").build("typeAnnotation").field("typeAnnotation", I("TSType"));
      var B = [c(I("Identifier"), I("RestElement"), I("ArrayPattern"), I("ObjectPattern"))];
      [
        "TSFunctionType",
        "TSConstructorType"
      ].forEach(function(Q) {
        I(Q).bases("TSType", "TSHasOptionalTypeParameters", "TSHasOptionalTypeAnnotation").build("parameters").field("parameters", B);
      }), I("TSDeclareFunction").bases("Declaration", "TSHasOptionalTypeParameters").build("id", "params", "returnType").field("declare", Boolean, C.false).field("async", Boolean, C.false).field("generator", Boolean, C.false).field("id", c(I("Identifier"), null), C.null).field("params", [I("Pattern")]).field("returnType", c(
        I("TSTypeAnnotation"),
        I("Noop"),
        // Still used?
        null
      ), C.null), I("TSDeclareMethod").bases("Declaration", "TSHasOptionalTypeParameters").build("key", "params", "returnType").field("async", Boolean, C.false).field("generator", Boolean, C.false).field("params", [I("Pattern")]).field("abstract", Boolean, C.false).field("accessibility", c("public", "private", "protected", void 0), C.undefined).field("static", Boolean, C.false).field("computed", Boolean, C.false).field("optional", Boolean, C.false).field("key", c(
        I("Identifier"),
        I("StringLiteral"),
        I("NumericLiteral"),
        // Only allowed if .computed is true.
        I("Expression")
      )).field("kind", c("get", "set", "method", "constructor"), function() {
        return "method";
      }).field(
        "access",
        // Not "accessibility"?
        c("public", "private", "protected", void 0),
        C.undefined
      ).field("decorators", c([I("Decorator")], null), C.null).field("returnType", c(
        I("TSTypeAnnotation"),
        I("Noop"),
        // Still used?
        null
      ), C.null), I("TSMappedType").bases("TSType").build("typeParameter", "typeAnnotation").field("readonly", c(Boolean, "+", "-"), C.false).field("typeParameter", I("TSTypeParameter")).field("optional", c(Boolean, "+", "-"), C.false).field("typeAnnotation", c(I("TSType"), null), C.null), I("TSTupleType").bases("TSType").build("elementTypes").field("elementTypes", [c(I("TSType"), I("TSNamedTupleMember"))]), I("TSNamedTupleMember").bases("TSType").build("label", "elementType", "optional").field("label", I("Identifier")).field("optional", Boolean, C.false).field("elementType", I("TSType")), I("TSRestType").bases("TSType").build("typeAnnotation").field("typeAnnotation", I("TSType")), I("TSOptionalType").bases("TSType").build("typeAnnotation").field("typeAnnotation", I("TSType")), I("TSIndexedAccessType").bases("TSType").build("objectType", "indexType").field("objectType", I("TSType")).field("indexType", I("TSType")), I("TSTypeOperator").bases("TSType").build("operator").field("operator", String).field("typeAnnotation", I("TSType")), I("TSTypeAnnotation").bases("Node").build("typeAnnotation").field("typeAnnotation", c(I("TSType"), I("TSTypeAnnotation"))), I("TSIndexSignature").bases("Declaration", "TSHasOptionalTypeAnnotation").build("parameters", "typeAnnotation").field("parameters", [I("Identifier")]).field("readonly", Boolean, C.false), I("TSPropertySignature").bases("Declaration", "TSHasOptionalTypeAnnotation").build("key", "typeAnnotation", "optional").field("key", I("Expression")).field("computed", Boolean, C.false).field("readonly", Boolean, C.false).field("optional", Boolean, C.false).field("initializer", c(I("Expression"), null), C.null), I("TSMethodSignature").bases("Declaration", "TSHasOptionalTypeParameters", "TSHasOptionalTypeAnnotation").build("key", "parameters", "typeAnnotation").field("key", I("Expression")).field("computed", Boolean, C.false).field("optional", Boolean, C.false).field("parameters", B), I("TSTypePredicate").bases("TSTypeAnnotation", "TSType").build("parameterName", "typeAnnotation", "asserts").field("parameterName", c(I("Identifier"), I("TSThisType"))).field("typeAnnotation", c(I("TSTypeAnnotation"), null), C.null).field("asserts", Boolean, C.false), [
        "TSCallSignatureDeclaration",
        "TSConstructSignatureDeclaration"
      ].forEach(function(Q) {
        I(Q).bases("Declaration", "TSHasOptionalTypeParameters", "TSHasOptionalTypeAnnotation").build("parameters", "typeAnnotation").field("parameters", B);
      }), I("TSEnumMember").bases("Node").build("id", "initializer").field("id", c(I("Identifier"), E)).field("initializer", c(I("Expression"), null), C.null), I("TSTypeQuery").bases("TSType").build("exprName").field("exprName", c(l, I("TSImportType")));
      var h = c(I("TSCallSignatureDeclaration"), I("TSConstructSignatureDeclaration"), I("TSIndexSignature"), I("TSMethodSignature"), I("TSPropertySignature"));
      I("TSTypeLiteral").bases("TSType").build("members").field("members", [h]), I("TSTypeParameter").bases("Identifier").build("name", "constraint", "default").field("name", String).field("constraint", c(I("TSType"), void 0), C.undefined).field("default", c(I("TSType"), void 0), C.undefined), I("TSTypeAssertion").bases("Expression", "Pattern").build("typeAnnotation", "expression").field("typeAnnotation", I("TSType")).field("expression", I("Expression")).field("extra", c({ parenthesized: Boolean }, null), C.null), I("TSTypeParameterDeclaration").bases("Declaration").build("params").field("params", [I("TSTypeParameter")]), I("TSTypeParameterInstantiation").bases("Node").build("params").field("params", [I("TSType")]), I("TSEnumDeclaration").bases("Declaration").build("id", "members").field("id", I("Identifier")).field("const", Boolean, C.false).field("declare", Boolean, C.false).field("members", [I("TSEnumMember")]).field("initializer", c(I("Expression"), null), C.null), I("TSTypeAliasDeclaration").bases("Declaration", "TSHasOptionalTypeParameters").build("id", "typeAnnotation").field("id", I("Identifier")).field("declare", Boolean, C.false).field("typeAnnotation", I("TSType")), I("TSModuleBlock").bases("Node").build("body").field("body", [I("Statement")]), I("TSModuleDeclaration").bases("Declaration").build("id", "body").field("id", c(E, l)).field("declare", Boolean, C.false).field("global", Boolean, C.false).field("body", c(I("TSModuleBlock"), I("TSModuleDeclaration"), null), C.null), I("TSImportType").bases("TSType", "TSHasOptionalTypeParameterInstantiation").build("argument", "qualifier", "typeParameters").field("argument", E).field("qualifier", c(l, void 0), C.undefined), I("TSImportEqualsDeclaration").bases("Declaration").build("id", "moduleReference").field("id", I("Identifier")).field("isExport", Boolean, C.false).field("moduleReference", c(l, I("TSExternalModuleReference"))), I("TSExternalModuleReference").bases("Declaration").build("expression").field("expression", E), I("TSExportAssignment").bases("Statement").build("expression").field("expression", I("Expression")), I("TSNamespaceExportDeclaration").bases("Declaration").build("id").field("id", I("Identifier")), I("TSInterfaceBody").bases("Node").build("body").field("body", [h]), I("TSExpressionWithTypeArguments").bases("TSType", "TSHasOptionalTypeParameterInstantiation").build("expression", "typeParameters").field("expression", l), I("TSInterfaceDeclaration").bases("Declaration", "TSHasOptionalTypeParameters").build("id", "body").field("id", l).field("declare", Boolean, C.false).field("extends", c([I("TSExpressionWithTypeArguments")], null), C.null).field("body", I("TSInterfaceBody")), I("TSParameterProperty").bases("Pattern").build("parameter").field("accessibility", c("public", "private", "protected", void 0), C.undefined).field("readonly", Boolean, C.false).field("parameter", c(I("Identifier"), I("AssignmentPattern"))), I("ClassProperty").field(
        "access",
        // Not "accessibility"?
        c("public", "private", "protected", void 0),
        C.undefined
      ), I("ClassBody").field("body", [c(
        I("MethodDefinition"),
        I("VariableDeclarator"),
        I("ClassPropertyDefinition"),
        I("ClassProperty"),
        I("ClassPrivateProperty"),
        I("ClassMethod"),
        I("ClassPrivateMethod"),
        // Just need to add these types:
        I("TSDeclareMethod"),
        h
      )]);
    }
    A.default = a, t.exports = A.default;
  }(rQ, rQ.exports)), rQ.exports;
}
var iQ = { exports: {} }, eM;
function gtA() {
  return eM || (eM = 1, function(t, A) {
    Object.defineProperty(A, "__esModule", { value: !0 });
    var e = it, r = e.__importDefault(Nt()), i = e.__importDefault(Rn()), n = e.__importDefault(OS());
    function s(a) {
      a.use(n.default);
      var g = a.use(r.default), o = g.Type, u = g.Type.def, I = o.or, c = a.use(i.default), C = c.defaults;
      u("OptionalMemberExpression").bases("MemberExpression").build("object", "property", "computed", "optional").field("optional", Boolean, C.true), u("OptionalCallExpression").bases("CallExpression").build("callee", "arguments", "optional").field("optional", Boolean, C.true);
      var E = I("||", "&&", "??");
      u("LogicalExpression").field("operator", E);
    }
    A.default = s, t.exports = A.default;
  }(iQ, iQ.exports)), iQ.exports;
}
var uw = {}, tM;
function utA() {
  return tM || (tM = 1, function(t) {
    Object.defineProperty(t, "__esModule", { value: !0 }), t.namedTypes = void 0, t.namedTypes || (t.namedTypes = {});
  }(uw)), uw;
}
var rM;
function ctA() {
  return rM || (rM = 1, function(t) {
    Object.defineProperty(t, "__esModule", { value: !0 }), t.visit = t.use = t.Type = t.someField = t.PathVisitor = t.Path = t.NodePath = t.namedTypes = t.getSupertypeNames = t.getFieldValue = t.getFieldNames = t.getBuilderName = t.finalize = t.eachField = t.defineMethod = t.builtInTypes = t.builders = t.astNodesAreEquivalent = void 0;
    var A = it, e = A.__importDefault(rtA()), r = A.__importDefault(OS()), i = A.__importDefault(FK()), n = A.__importDefault(CI()), s = A.__importDefault(itA()), a = A.__importDefault(ntA()), g = A.__importDefault(vK()), o = A.__importDefault(stA()), u = A.__importDefault(atA()), I = A.__importDefault(otA()), c = A.__importDefault(gtA()), C = utA();
    Object.defineProperty(t, "namedTypes", { enumerable: !0, get: function() {
      return C.namedTypes;
    } });
    var E = e.default([
      // This core module of AST types captures ES5 as it is parsed today by
      // git://github.com/ariya/esprima.git#master.
      r.default,
      // Feel free to add to or remove from this list of extension modules to
      // configure the precise type hierarchy that you need.
      i.default,
      n.default,
      s.default,
      a.default,
      g.default,
      o.default,
      u.default,
      I.default,
      c.default
    ]), l = E.astNodesAreEquivalent, B = E.builders, h = E.builtInTypes, Q = E.defineMethod, f = E.eachField, p = E.finalize, y = E.getBuilderName, m = E.getFieldNames, S = E.getFieldValue, w = E.getSupertypeNames, F = E.namedTypes, b = E.NodePath, G = E.Path, T = E.PathVisitor, K = E.someField, H = E.Type, j = E.use, eA = E.visit;
    t.astNodesAreEquivalent = l, t.builders = B, t.builtInTypes = h, t.defineMethod = Q, t.eachField = f, t.finalize = p, t.getBuilderName = y, t.getFieldNames = m, t.getFieldValue = S, t.getSupertypeNames = w, t.NodePath = b, t.Path = G, t.PathVisitor = T, t.someField = K, t.Type = H, t.use = j, t.visit = eA, Object.assign(C.namedTypes, F);
  }(gw)), gw;
}
var iM;
function bK() {
  if (iM) return OI;
  iM = 1, Object.defineProperty(OI, "__esModule", { value: !0 }), OI.degenerator = void 0;
  const t = bf, A = WeA(), e = VeA(), r = ctA();
  function i(a, g) {
    if (!Array.isArray(g))
      throw new TypeError('an array of async function "names" is required');
    const o = g.slice(0), u = (0, e.parseScript)(a);
    let I = 0;
    do
      I = o.length, (0, r.visit)(u, {
        visitVariableDeclaration(c) {
          if (c.node.declarations)
            for (let C = 0; C < c.node.declarations.length; C++) {
              const E = c.node.declarations[C];
              r.namedTypes.VariableDeclarator.check(E) && r.namedTypes.Identifier.check(E.init) && r.namedTypes.Identifier.check(E.id) && s(E.init.name, o) && !s(E.id.name, o) && o.push(E.id.name);
            }
          return !1;
        },
        visitAssignmentExpression(c) {
          return r.namedTypes.Identifier.check(c.node.left) && r.namedTypes.Identifier.check(c.node.right) && s(c.node.right.name, o) && !s(c.node.left.name, o) && o.push(c.node.left.name), !1;
        },
        visitFunction(c) {
          if (c.node.id) {
            let C = !1;
            if ((0, r.visit)(c.node, {
              visitCallExpression(E) {
                return n(E.node, o) && (C = !0), !1;
              }
            }), !C)
              return !1;
            c.node.async = !0, s(c.node.id.name, o) || o.push(c.node.id.name);
          }
          this.traverse(c);
        }
      });
    while (I !== o.length);
    return (0, r.visit)(u, {
      visitCallExpression(c) {
        if (n(c.node, o)) {
          const { name: E, parent: { node: l } } = c, B = r.builders.awaitExpression(c.node, !1);
          r.namedTypes.CallExpression.check(l) ? l.arguments[E] = B : l[E] = B;
        }
        this.traverse(c);
      }
    }), (0, A.generate)(u);
  }
  OI.degenerator = i;
  function n({ callee: a }, g) {
    let o;
    if (r.namedTypes.Identifier.check(a))
      o = a.name;
    else if (r.namedTypes.MemberExpression.check(a))
      if (r.namedTypes.Identifier.check(a.object) && r.namedTypes.Identifier.check(a.property))
        o = `${a.object.name}.${a.property.name}`;
      else
        return !1;
    else if (r.namedTypes.FunctionExpression.check(a))
      if (a.id)
        o = a.id.name;
      else
        return !1;
    else
      throw new Error(`Don't know how to get name for: ${a.type}`);
    return s(o, g);
  }
  function s(a, g) {
    for (let o = 0; o < g.length; o++) {
      const u = g[o];
      if (t.types.isRegExp(u)) {
        if (u.test(a))
          return !0;
      } else if (a === u)
        return !0;
    }
    return !1;
  }
  return OI;
}
var WI = {}, nM;
function ItA() {
  if (nM) return WI;
  nM = 1, Object.defineProperty(WI, "__esModule", { value: !0 }), WI.compile = void 0;
  const t = bf, A = bK();
  function e(n, s, a, g = {}) {
    const o = (0, A.degenerator)(s, g.names ?? []), u = n.newContext();
    if (g.sandbox)
      for (const [l, B] of Object.entries(g.sandbox)) {
        if (typeof B != "function")
          throw new Error(`Expected a "function" for sandbox property \`${l}\`, but got "${typeof B}"`);
        u.newFunction(l, (...Q) => {
          const f = B(...Q.map((p) => r(u, p)));
          return u.runtime.executePendingJobs(), i(u, f);
        }).consume((Q) => u.setProp(u.global, l, Q));
      }
    const I = u.evalCode(`${o};${a}`, g.filename), c = u.unwrapResult(I), C = u.typeof(c);
    if (C !== "function")
      throw new Error(`Expected a "function" named \`${a}\` to be defined, but got "${C}"`);
    const E = async function(...l) {
      let B, h;
      try {
        const Q = u.callFunction(c, u.undefined, ...l.map((y) => i(u, y)));
        B = u.unwrapResult(Q);
        const f = u.resolvePromise(B);
        u.runtime.executePendingJobs();
        const p = await f;
        return h = u.unwrapResult(p), r(u, h);
      } catch (Q) {
        throw Q && typeof Q == "object" && "cause" in Q && Q.cause ? (typeof Q.cause == "object" && "stack" in Q.cause && "name" in Q.cause && "message" in Q.cause && typeof Q.cause.stack == "string" && typeof Q.cause.name == "string" && typeof Q.cause.message == "string" && (Q.cause.stack = `${Q.cause.name}: ${Q.cause.message}
${Q.cause.stack}`), Q.cause) : Q;
      } finally {
        B == null || B.dispose(), h == null || h.dispose();
      }
    };
    return Object.defineProperty(E, "toString", {
      value: () => o,
      enumerable: !1
    }), E;
  }
  WI.compile = e;
  function r(n, s) {
    return n.dump(s);
  }
  function i(n, s) {
    if (typeof s > "u")
      return n.undefined;
    if (s === null)
      return n.null;
    if (typeof s == "string")
      return n.newString(s);
    if (typeof s == "number")
      return n.newNumber(s);
    if (typeof s == "bigint")
      return n.newBigInt(s);
    if (typeof s == "boolean")
      return s ? n.true : n.false;
    if (t.types.isPromise(s)) {
      const a = n.newPromise();
      return a.settled.then(n.runtime.executePendingJobs), s.then((g) => {
        a.resolve(i(n, g));
      }, (g) => {
        a.reject(i(n, g));
      }), a.handle;
    } else if (t.types.isNativeError(s))
      return n.newError(s);
    throw new Error(`Unsupported value: ${s}`);
  }
  return WI;
}
var sM;
function CtA() {
  return sM || (sM = 1, function(t) {
    var A = W && W.__createBinding || (Object.create ? function(r, i, n, s) {
      s === void 0 && (s = n);
      var a = Object.getOwnPropertyDescriptor(i, n);
      (!a || ("get" in a ? !i.__esModule : a.writable || a.configurable)) && (a = { enumerable: !0, get: function() {
        return i[n];
      } }), Object.defineProperty(r, s, a);
    } : function(r, i, n, s) {
      s === void 0 && (s = n), r[s] = i[n];
    }), e = W && W.__exportStar || function(r, i) {
      for (var n in r) n !== "default" && !Object.prototype.hasOwnProperty.call(i, n) && A(i, r, n);
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), e(bK(), t), e(ItA(), t);
  }(Vy)), Vy;
}
var nQ = {}, aM;
function ltA() {
  if (aM) return nQ;
  aM = 1, Object.defineProperty(nQ, "__esModule", { value: !0 });
  function t() {
    return !1;
  }
  return nQ.default = t, nQ;
}
var sQ = {}, oM;
function BtA() {
  if (oM) return sQ;
  oM = 1, Object.defineProperty(sQ, "__esModule", { value: !0 });
  function t(A, e) {
    return A = String(A), e = String(e), A.substr(e.length * -1) === e;
  }
  return sQ.default = t, sQ;
}
var aQ = {}, gM;
function EtA() {
  if (gM) return aQ;
  gM = 1, Object.defineProperty(aQ, "__esModule", { value: !0 });
  function t(A) {
    const e = String(A).match(/\./g);
    let r = 0;
    return e && (r = e.length), r;
  }
  return aQ.default = t, aQ;
}
var oQ = {}, qa = {}, uM;
function Mp() {
  if (uM) return qa;
  uM = 1, Object.defineProperty(qa, "__esModule", { value: !0 }), qa.isGMT = qa.dnsLookup = void 0;
  const t = M_;
  function A(r, i) {
    return new Promise((n, s) => {
      (0, t.lookup)(r, i, (a, g) => {
        a ? s(a) : n(g);
      });
    });
  }
  qa.dnsLookup = A;
  function e(r) {
    return r === "GMT";
  }
  return qa.isGMT = e, qa;
}
var cM;
function htA() {
  if (cM) return oQ;
  cM = 1, Object.defineProperty(oQ, "__esModule", { value: !0 });
  const t = Mp();
  async function A(e) {
    try {
      const i = await (0, t.dnsLookup)(e, { family: 4 });
      if (typeof i == "string")
        return i;
    } catch {
    }
    return null;
  }
  return oQ.default = A, oQ;
}
var gQ = {}, VI = {}, IM;
function QtA() {
  return IM || (IM = 1, (function() {
    var t, A, e, r, i, n, s, a;
    a = function(g) {
      var o, u, I, c;
      return o = (g & 255 << 24) >>> 24, u = (g & 255 << 16) >>> 16, I = (g & 65280) >>> 8, c = g & 255, [o, u, I, c].join(".");
    }, s = function(g) {
      var o, u, I, c, C, E;
      for (o = [], I = c = 0; c <= 3 && g.length !== 0; I = ++c) {
        if (I > 0) {
          if (g[0] !== ".")
            throw new Error("Invalid IP");
          g = g.substring(1);
        }
        E = A(g), C = E[0], u = E[1], g = g.substring(u), o.push(C);
      }
      if (g.length !== 0)
        throw new Error("Invalid IP");
      switch (o.length) {
        case 1:
          if (o[0] > 4294967295)
            throw new Error("Invalid IP");
          return o[0] >>> 0;
        case 2:
          if (o[0] > 255 || o[1] > 16777215)
            throw new Error("Invalid IP");
          return (o[0] << 24 | o[1]) >>> 0;
        case 3:
          if (o[0] > 255 || o[1] > 255 || o[2] > 65535)
            throw new Error("Invalid IP");
          return (o[0] << 24 | o[1] << 16 | o[2]) >>> 0;
        case 4:
          if (o[0] > 255 || o[1] > 255 || o[2] > 255 || o[3] > 255)
            throw new Error("Invalid IP");
          return (o[0] << 24 | o[1] << 16 | o[2] << 8 | o[3]) >>> 0;
        default:
          throw new Error("Invalid IP");
      }
    }, e = function(g) {
      return g.charCodeAt(0);
    }, r = e("0"), n = e("a"), i = e("A"), A = function(g) {
      var o, u, I, c, C;
      for (c = 0, o = 10, u = "9", I = 0, g.length > 1 && g[I] === "0" && (g[I + 1] === "x" || g[I + 1] === "X" ? (I += 2, o = 16) : "0" <= g[I + 1] && g[I + 1] <= "9" && (I++, o = 8, u = "7")), C = I; I < g.length; ) {
        if ("0" <= g[I] && g[I] <= u)
          c = c * o + (e(g[I]) - r) >>> 0;
        else if (o === 16)
          if ("a" <= g[I] && g[I] <= "f")
            c = c * o + (10 + e(g[I]) - n) >>> 0;
          else if ("A" <= g[I] && g[I] <= "F")
            c = c * o + (10 + e(g[I]) - i) >>> 0;
          else
            break;
        else
          break;
        if (c > 4294967295)
          throw new Error("too large");
        I++;
      }
      if (I === C)
        throw new Error("empty octet");
      return [c, I];
    }, t = function() {
      function g(o, u) {
        var I, c, C;
        if (typeof o != "string")
          throw new Error("Missing `net' parameter");
        if (u || (C = o.split("/", 2), o = C[0], u = C[1]), u || (u = 32), typeof u == "string" && u.indexOf(".") > -1) {
          try {
            this.maskLong = s(u);
          } catch {
            throw new Error("Invalid mask: " + u);
          }
          for (I = c = 32; c >= 0; I = --c)
            if (this.maskLong === 4294967295 << 32 - I >>> 0) {
              this.bitmask = I;
              break;
            }
        } else if (u || u === 0)
          this.bitmask = parseInt(u, 10), this.maskLong = 0, this.bitmask > 0 && (this.maskLong = 4294967295 << 32 - this.bitmask >>> 0);
        else
          throw new Error("Invalid mask: empty");
        try {
          this.netLong = (s(o) & this.maskLong) >>> 0;
        } catch {
          throw new Error("Invalid net address: " + o);
        }
        if (!(this.bitmask <= 32))
          throw new Error("Invalid mask for ip4: " + u);
        this.size = Math.pow(2, 32 - this.bitmask), this.base = a(this.netLong), this.mask = a(this.maskLong), this.hostmask = a(~this.maskLong), this.first = this.bitmask <= 30 ? a(this.netLong + 1) : this.base, this.last = this.bitmask <= 30 ? a(this.netLong + this.size - 2) : a(this.netLong + this.size - 1), this.broadcast = this.bitmask <= 30 ? a(this.netLong + this.size - 1) : void 0;
      }
      return g.prototype.contains = function(o) {
        return typeof o == "string" && (o.indexOf("/") > 0 || o.split(".").length !== 4) && (o = new g(o)), o instanceof g ? this.contains(o.base) && this.contains(o.broadcast || o.last) : (s(o) & this.maskLong) >>> 0 === (this.netLong & this.maskLong) >>> 0;
      }, g.prototype.next = function(o) {
        return o == null && (o = 1), new g(a(this.netLong + this.size * o), this.mask);
      }, g.prototype.forEach = function(o) {
        var u, I, c;
        for (c = s(this.first), I = s(this.last), u = 0; c <= I; )
          o(a(c), c, u), u++, c++;
      }, g.prototype.toString = function() {
        return this.base + "/" + this.bitmask;
      }, g;
    }(), VI.ip2long = s, VI.long2ip = a, VI.Netmask = t;
  }).call(W)), VI;
}
var CM;
function dtA() {
  if (CM) return gQ;
  CM = 1, Object.defineProperty(gQ, "__esModule", { value: !0 });
  const t = QtA(), A = Mp();
  async function e(r, i, n) {
    try {
      const a = await (0, A.dnsLookup)(r, { family: 4 });
      if (typeof a == "string")
        return new t.Netmask(i, n).contains(a);
    } catch {
    }
    return !1;
  }
  return gQ.default = e, gQ;
}
var uQ = {}, lM;
function ftA() {
  if (lM) return uQ;
  lM = 1, Object.defineProperty(uQ, "__esModule", { value: !0 });
  function t(A) {
    return !/\./.test(A);
  }
  return uQ.default = t, uQ;
}
var cQ = {}, BM;
function ptA() {
  if (BM) return cQ;
  BM = 1, Object.defineProperty(cQ, "__esModule", { value: !0 });
  const t = Mp();
  async function A(e) {
    try {
      if (await (0, t.dnsLookup)(e, { family: 4 }))
        return !0;
    } catch {
    }
    return !1;
  }
  return cQ.default = A, cQ;
}
var IQ = {}, EM;
function ytA() {
  if (EM) return IQ;
  EM = 1, Object.defineProperty(IQ, "__esModule", { value: !0 });
  function t(A, e) {
    const r = A.split("."), i = e.split(".");
    let n = !0;
    for (let s = 0; s < r.length; s++)
      if (r[s] !== i[s]) {
        n = !1;
        break;
      }
    return n;
  }
  return IQ.default = t, IQ;
}
var CQ = {}, cw = {}, hM;
function wtA() {
  return hM || (hM = 1, function(t) {
    var A = W && W.__importDefault || function(i) {
      return i && i.__esModule ? i : { default: i };
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.ip = void 0;
    const e = A(ZD);
    t.ip = {
      address() {
        const i = e.default.networkInterfaces(), n = r(), s = Object.values(i).map((a = []) => {
          const g = a.filter((o) => !(r(o.family) !== n || t.ip.isLoopback(o.address)));
          return g.length ? g[0].address : void 0;
        }).filter(Boolean);
        return s.length ? s[0] : t.ip.loopback(n);
      },
      isLoopback(i) {
        return /^(::f{4}:)?127\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})/.test(i) || /^fe80::1$/.test(i) || /^::1$/.test(i) || /^::$/.test(i);
      },
      loopback(i) {
        if (i = r(i), i !== "ipv4" && i !== "ipv6")
          throw new Error("family must be ipv4 or ipv6");
        return i === "ipv4" ? "127.0.0.1" : "fe80::1";
      }
    };
    function r(i) {
      return i === 4 ? "ipv4" : i === 6 ? "ipv6" : i ? i.toLowerCase() : "ipv4";
    }
  }(cw)), cw;
}
var QM;
function mtA() {
  if (QM) return CQ;
  QM = 1;
  var t = W && W.__importDefault || function(i) {
    return i && i.__esModule ? i : { default: i };
  };
  Object.defineProperty(CQ, "__esModule", { value: !0 });
  const A = wtA(), e = t(yr);
  async function r() {
    return new Promise((i, n) => {
      const s = e.default.connect({ host: "8.8.8.8", port: 53 }), a = () => {
        i(A.ip.address());
      };
      s.once("error", a), s.once("connect", () => {
        s.removeListener("error", a);
        const g = s.address();
        s.destroy(), typeof g == "string" ? i(g) : g.address ? i(g.address) : n(new Error("Expected a `string`"));
      });
    });
  }
  return CQ.default = r, CQ;
}
var lQ = {}, dM;
function DtA() {
  if (dM) return lQ;
  dM = 1, Object.defineProperty(lQ, "__esModule", { value: !0 });
  function t(e, r) {
    return A(r).test(e);
  }
  lQ.default = t;
  function A(e) {
    return e = String(e).replace(/\./g, "\\.").replace(/\?/g, ".").replace(/\*/g, ".*"), new RegExp(`^${e}$`);
  }
  return lQ;
}
var BQ = {}, fM;
function StA() {
  if (fM) return BQ;
  fM = 1, Object.defineProperty(BQ, "__esModule", { value: !0 });
  function t() {
    const s = Array.prototype.slice.call(arguments), a = s.pop(), g = a === "GMT", o = /* @__PURE__ */ new Date();
    g || s.push(a);
    let u = !1;
    const I = s.length, c = s.map((C) => parseInt(C, 10));
    if (I === 1)
      u = e(g, o) === c[0];
    else if (I === 2) {
      const C = e(g, o);
      u = c[0] <= C && C < c[1];
    } else I === 4 ? u = n(A(c[0], c[1], 0), A(e(g, o), r(g, o), 0), A(c[2], c[3], 59)) : I === 6 && (u = n(A(c[0], c[1], c[2]), A(e(g, o), r(g, o), i(g, o)), A(c[3], c[4], c[5])));
    return u;
  }
  BQ.default = t;
  function A(s, a, g) {
    return s * 3600 + a * 60 + g;
  }
  function e(s, a) {
    return s ? a.getUTCHours() : a.getHours();
  }
  function r(s, a) {
    return s ? a.getUTCMinutes() : a.getMinutes();
  }
  function i(s, a) {
    return s ? a.getUTCSeconds() : a.getSeconds();
  }
  function n(s, a, g) {
    return s <= a && a <= g;
  }
  return BQ;
}
var EQ = {}, pM;
function FtA() {
  if (pM) return EQ;
  pM = 1, Object.defineProperty(EQ, "__esModule", { value: !0 });
  const t = Mp(), A = ["SUN", "MON", "TUE", "WED", "THU", "FRI", "SAT"];
  function e(s, a, g) {
    let o = !1, u = -1, I = -1, c = !1;
    (0, t.isGMT)(g) ? o = !0 : (0, t.isGMT)(a) && (o = !0, c = !0), u = A.indexOf(s), !c && n(a) && (I = A.indexOf(a));
    const C = r(o);
    let E;
    return I < 0 ? E = C === u : u <= I ? E = i(u, C, I) : E = i(u, C, 6) || i(0, C, I), E;
  }
  EQ.default = e;
  function r(s) {
    return s ? (/* @__PURE__ */ new Date()).getUTCDay() : (/* @__PURE__ */ new Date()).getDay();
  }
  function i(s, a, g) {
    return s <= a && a <= g;
  }
  function n(s) {
    return s ? A.includes(s) : !1;
  }
  return EQ;
}
var yM;
function ktA() {
  return yM || (yM = 1, function(t) {
    var A = W && W.__importDefault || function(h) {
      return h && h.__esModule ? h : { default: h };
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.sandbox = t.createPacResolver = void 0;
    const e = CtA(), r = A(ltA()), i = A(BtA()), n = A(EtA()), s = A(htA()), a = A(dtA()), g = A(ftA()), o = A(ptA()), u = A(ytA()), I = A(mtA()), c = A(DtA()), C = A(StA()), E = A(FtA());
    function l(h, Q, f = {}) {
      const p = Buffer.isBuffer(Q) ? Q.toString("utf8") : Q, y = {
        ...t.sandbox,
        ...f.sandbox
      }, S = {
        filename: "proxy.pac",
        names: Object.keys(y).filter((b) => B(y[b])),
        ...f,
        sandbox: y
      }, w = (0, e.compile)(h, p, "FindProxyForURL", S);
      function F(b, G) {
        const T = typeof b == "string" ? new URL(b) : b, K = G || T.hostname;
        if (!K)
          throw new TypeError("Could not determine `host`");
        return w(T.href, K);
      }
      return Object.defineProperty(F, "toString", {
        value: () => w.toString(),
        enumerable: !1
      }), F;
    }
    t.createPacResolver = l, t.sandbox = Object.freeze({
      alert: (h = "") => console.log("%s", h),
      dateRange: r.default,
      dnsDomainIs: i.default,
      dnsDomainLevels: n.default,
      dnsResolve: s.default,
      isInNet: a.default,
      isPlainHostName: g.default,
      isResolvable: o.default,
      localHostOrDomainIs: u.default,
      myIpAddress: I.default,
      shExpMatch: c.default,
      timeRange: C.default,
      weekdayRange: E.default
    });
    function B(h) {
      return typeof h != "function" ? !1 : h.constructor.name === "AsyncFunction" || String(h).indexOf("__awaiter(") !== -1 ? !0 : !!h.async;
    }
  }(Wy)), Wy;
}
var Iw = {}, Cw = {}, ja = {}, wM;
function vtA() {
  if (wM) return ja;
  wM = 1, Object.defineProperty(ja, "__esModule", { value: !0 }), ja.unwrapJavascript = ja.unwrapTypescript = void 0;
  function t(e) {
    return e.default;
  }
  function A(e) {
    return e.default ?? e;
  }
  return ja.unwrapTypescript = A, ja.unwrapJavascript = t, ja;
}
var Ii = {}, lw = {}, mM;
function WE() {
  return mM || (mM = 1, function(t) {
    Object.defineProperty(t, "__esModule", { value: !0 }), t.debugLog = t.QTS_DEBUG = void 0, t.QTS_DEBUG = !!(typeof process == "object" && process.env.QTS_DEBUG), t.debugLog = t.QTS_DEBUG ? console.log.bind(console) : () => {
    };
  }(lw)), lw;
}
var xt = {}, DM;
function vg() {
  if (DM) return xt;
  DM = 1, Object.defineProperty(xt, "__esModule", { value: !0 }), xt.QuickJSMemoryLeakDetected = xt.QuickJSAsyncifySuspended = xt.QuickJSAsyncifyError = xt.QuickJSNotImplemented = xt.QuickJSUseAfterFree = xt.QuickJSWrongOwner = xt.QuickJSUnwrapError = void 0;
  class t extends Error {
    constructor(g, o) {
      super(String(g)), this.cause = g, this.context = o, this.name = "QuickJSUnwrapError";
    }
  }
  xt.QuickJSUnwrapError = t;
  class A extends Error {
    constructor() {
      super(...arguments), this.name = "QuickJSWrongOwner";
    }
  }
  xt.QuickJSWrongOwner = A;
  class e extends Error {
    constructor() {
      super(...arguments), this.name = "QuickJSUseAfterFree";
    }
  }
  xt.QuickJSUseAfterFree = e;
  class r extends Error {
    constructor() {
      super(...arguments), this.name = "QuickJSNotImplemented";
    }
  }
  xt.QuickJSNotImplemented = r;
  class i extends Error {
    constructor() {
      super(...arguments), this.name = "QuickJSAsyncifyError";
    }
  }
  xt.QuickJSAsyncifyError = i;
  class n extends Error {
    constructor() {
      super(...arguments), this.name = "QuickJSAsyncifySuspended";
    }
  }
  xt.QuickJSAsyncifySuspended = n;
  class s extends Error {
    constructor() {
      super(...arguments), this.name = "QuickJSMemoryLeakDetected";
    }
  }
  return xt.QuickJSMemoryLeakDetected = s, xt;
}
var Ci = {}, Un = {}, SM;
function MK() {
  if (SM) return Un;
  SM = 1, Object.defineProperty(Un, "__esModule", { value: !0 }), Un.awaitEachYieldedPromise = Un.maybeAsync = Un.maybeAsyncFn = void 0;
  function* t(s) {
    return yield s;
  }
  function A(s) {
    return t(n(s));
  }
  const e = t;
  e.of = A;
  function r(s, a) {
    return (...g) => {
      const o = a.call(s, e, ...g);
      return n(o);
    };
  }
  Un.maybeAsyncFn = r;
  function i(s, a) {
    const g = a.call(s, e);
    return n(g);
  }
  Un.maybeAsync = i;
  function n(s) {
    function a(g) {
      return g.done ? g.value : g.value instanceof Promise ? g.value.then((o) => a(s.next(o)), (o) => a(s.throw(o))) : a(s.next(g.value));
    }
    return a(s.next());
  }
  return Un.awaitEachYieldedPromise = n, Un;
}
var FM;
function Rg() {
  if (FM) return Ci;
  FM = 1, Object.defineProperty(Ci, "__esModule", { value: !0 }), Ci.Scope = Ci.WeakLifetime = Ci.StaticLifetime = Ci.Lifetime = void 0;
  const t = MK(), A = WE(), e = vg();
  class r {
    /**
     * When the Lifetime is disposed, it will call `disposer(_value)`. Use the
     * disposer function to implement whatever cleanup needs to happen at the end
     * of `value`'s lifetime.
     *
     * `_owner` is not used or controlled by the lifetime. It's just metadata for
     * the creator.
     */
    constructor(o, u, I, c) {
      this._value = o, this.copier = u, this.disposer = I, this._owner = c, this._alive = !0, this._constructorStack = A.QTS_DEBUG ? new Error("Lifetime constructed").stack : void 0;
    }
    get alive() {
      return this._alive;
    }
    /**
     * The value this Lifetime protects. You must never retain the value - it
     * may become invalid, leading to memory errors.
     *
     * @throws If the lifetime has been [[dispose]]d already.
     */
    get value() {
      return this.assertAlive(), this._value;
    }
    get owner() {
      return this._owner;
    }
    get dupable() {
      return !!this.copier;
    }
    /**
     * Create a new handle pointing to the same [[value]].
     */
    dup() {
      if (this.assertAlive(), !this.copier)
        throw new Error("Non-dupable lifetime");
      return new r(this.copier(this._value), this.copier, this.disposer, this._owner);
    }
    consume(o) {
      this.assertAlive();
      const u = o(this);
      return this.dispose(), u;
    }
    /**
     * Dispose of [[value]] and perform cleanup.
     */
    dispose() {
      this.assertAlive(), this.disposer && this.disposer(this._value), this._alive = !1;
    }
    assertAlive() {
      if (!this.alive)
        throw this._constructorStack ? new e.QuickJSUseAfterFree(`Lifetime not alive
${this._constructorStack}
Lifetime used`) : new e.QuickJSUseAfterFree("Lifetime not alive");
    }
  }
  Ci.Lifetime = r;
  class i extends r {
    constructor(o, u) {
      super(o, void 0, void 0, u);
    }
    // Static lifetime doesn't need a copier to be copiable
    get dupable() {
      return !0;
    }
    // Copy returns the same instance.
    dup() {
      return this;
    }
    // Dispose does nothing.
    dispose() {
    }
  }
  Ci.StaticLifetime = i;
  class n extends r {
    constructor(o, u, I, c) {
      super(o, u, I, c);
    }
    dispose() {
      this._alive = !1;
    }
  }
  Ci.WeakLifetime = n;
  function s(g, o) {
    let u;
    try {
      g.dispose();
    } catch (I) {
      u = I;
    }
    if (o && u)
      throw Object.assign(o, {
        message: `${o.message}
 Then, failed to dispose scope: ${u.message}`,
        disposeError: u
      }), o;
    if (o || u)
      throw o || u;
  }
  class a {
    constructor() {
      this._disposables = new r(/* @__PURE__ */ new Set());
    }
    /**
     * Run `block` with a new Scope instance that will be disposed after the block returns.
     * Inside `block`, call `scope.manage` on each lifetime you create to have the lifetime
     * automatically disposed after the block returns.
     *
     * @warning Do not use with async functions. Instead, use [[withScopeAsync]].
     */
    static withScope(o) {
      const u = new a();
      let I;
      try {
        return o(u);
      } catch (c) {
        throw I = c, c;
      } finally {
        s(u, I);
      }
    }
    static withScopeMaybeAsync(o, u) {
      return (0, t.maybeAsync)(void 0, function* (I) {
        const c = new a();
        let C;
        try {
          return yield* I.of(u.call(o, I, c));
        } catch (E) {
          throw C = E, E;
        } finally {
          s(c, C);
        }
      });
    }
    /**
     * Run `block` with a new Scope instance that will be disposed after the
     * block's returned promise settles. Inside `block`, call `scope.manage` on each
     * lifetime you create to have the lifetime automatically disposed after the
     * block returns.
     */
    static async withScopeAsync(o) {
      const u = new a();
      let I;
      try {
        return await o(u);
      } catch (c) {
        throw I = c, c;
      } finally {
        s(u, I);
      }
    }
    /**
     * Track `lifetime` so that it is disposed when this scope is disposed.
     */
    manage(o) {
      return this._disposables.value.add(o), o;
    }
    get alive() {
      return this._disposables.alive;
    }
    dispose() {
      const o = Array.from(this._disposables.value.values()).reverse();
      for (const u of o)
        u.alive && u.dispose();
      this._disposables.dispose();
    }
  }
  return Ci.Scope = a, Ci;
}
var ZI = {}, XI = {}, zI = {}, kM;
function _K() {
  if (kM) return zI;
  kM = 1, Object.defineProperty(zI, "__esModule", { value: !0 }), zI.QuickJSDeferredPromise = void 0;
  class t {
    /**
     * Use [[QuickJSContext.newPromise]] to create a new promise instead of calling
     * this constructor directly.
     * @unstable
     */
    constructor(e) {
      this.resolve = (r) => {
        this.resolveHandle.alive && (this.context.unwrapResult(this.context.callFunction(this.resolveHandle, this.context.undefined, r || this.context.undefined)).dispose(), this.disposeResolvers(), this.onSettled());
      }, this.reject = (r) => {
        this.rejectHandle.alive && (this.context.unwrapResult(this.context.callFunction(this.rejectHandle, this.context.undefined, r || this.context.undefined)).dispose(), this.disposeResolvers(), this.onSettled());
      }, this.dispose = () => {
        this.handle.alive && this.handle.dispose(), this.disposeResolvers();
      }, this.context = e.context, this.owner = e.context.runtime, this.handle = e.promiseHandle, this.settled = new Promise((r) => {
        this.onSettled = r;
      }), this.resolveHandle = e.resolveHandle, this.rejectHandle = e.rejectHandle;
    }
    get alive() {
      return this.handle.alive || this.resolveHandle.alive || this.rejectHandle.alive;
    }
    disposeResolvers() {
      this.resolveHandle.alive && this.resolveHandle.dispose(), this.rejectHandle.alive && this.rejectHandle.dispose();
    }
  }
  return zI.QuickJSDeferredPromise = t, zI;
}
var $I = {}, vM;
function NK() {
  if (vM) return $I;
  vM = 1, Object.defineProperty($I, "__esModule", { value: !0 }), $I.ModuleMemory = void 0;
  const t = Rg();
  class A {
    constructor(r) {
      this.module = r;
    }
    toPointerArray(r) {
      const i = new Int32Array(r.map((g) => g.value)), n = i.length * i.BYTES_PER_ELEMENT, s = this.module._malloc(n);
      var a = new Uint8Array(this.module.HEAPU8.buffer, s, n);
      return a.set(new Uint8Array(i.buffer)), new t.Lifetime(s, void 0, (g) => this.module._free(g));
    }
    newMutablePointerArray(r) {
      const i = new Int32Array(new Array(r).fill(0)), n = i.length * i.BYTES_PER_ELEMENT, s = this.module._malloc(n), a = new Int32Array(this.module.HEAPU8.buffer, s, r);
      return a.set(i), new t.Lifetime({ typedArray: a, ptr: s }, void 0, (g) => this.module._free(g.ptr));
    }
    newHeapCharPointer(r) {
      const i = this.module.lengthBytesUTF8(r) + 1, n = this.module._malloc(i);
      return this.module.stringToUTF8(r, n, i), new t.Lifetime(n, void 0, (s) => this.module._free(s));
    }
    consumeHeapCharPointer(r) {
      const i = this.module.UTF8ToString(r);
      return this.module._free(r), i;
    }
  }
  return $I.ModuleMemory = A, $I;
}
var Tn = {}, Wa = {}, RM;
function RtA() {
  if (RM) return Wa;
  RM = 1, Object.defineProperty(Wa, "__esModule", { value: !0 }), Wa.EvalFlags = Wa.assertSync = void 0;
  function t(A) {
    return function(...r) {
      const i = A(...r);
      if (i && typeof i == "object" && i instanceof Promise)
        throw new Error("Function unexpectedly returned a Promise");
      return i;
    };
  }
  return Wa.assertSync = t, Wa.EvalFlags = {
    /** global code (default) */
    JS_EVAL_TYPE_GLOBAL: 0,
    /** module code */
    JS_EVAL_TYPE_MODULE: 1,
    /** direct call (internal use) */
    JS_EVAL_TYPE_DIRECT: 2,
    /** indirect call (internal use) */
    JS_EVAL_TYPE_INDIRECT: 3,
    JS_EVAL_TYPE_MASK: 3,
    /** force 'strict' mode */
    JS_EVAL_FLAG_STRICT: 8,
    /** force 'strip' mode */
    JS_EVAL_FLAG_STRIP: 16,
    /**
     * compile but do not run. The result is an object with a
     * JS_TAG_FUNCTION_BYTECODE or JS_TAG_MODULE tag. It can be executed
     * with JS_EvalFunction().
     */
    JS_EVAL_FLAG_COMPILE_ONLY: 32,
    /** don't include the stack frames before this eval in the Error() backtraces */
    JS_EVAL_FLAG_BACKTRACE_BARRIER: 64
  }, Wa;
}
var bM;
function VE() {
  if (bM) return Tn;
  bM = 1, Object.defineProperty(Tn, "__esModule", { value: !0 }), Tn.concat = Tn.evalOptionsToFlags = Tn.DefaultIntrinsics = void 0;
  const t = RtA();
  Tn.DefaultIntrinsics = Symbol("DefaultIntrinsics");
  function A(r) {
    if (typeof r == "number")
      return r;
    if (r === void 0)
      return 0;
    const { type: i, strict: n, strip: s, compileOnly: a, backtraceBarrier: g } = r;
    let o = 0;
    return i === "global" && (o |= t.EvalFlags.JS_EVAL_TYPE_GLOBAL), i === "module" && (o |= t.EvalFlags.JS_EVAL_TYPE_MODULE), n && (o |= t.EvalFlags.JS_EVAL_FLAG_STRICT), s && (o |= t.EvalFlags.JS_EVAL_FLAG_STRIP), a && (o |= t.EvalFlags.JS_EVAL_FLAG_COMPILE_ONLY), g && (o |= t.EvalFlags.JS_EVAL_FLAG_BACKTRACE_BARRIER), o;
  }
  Tn.evalOptionsToFlags = A;
  function e(...r) {
    let i = [];
    for (const n of r)
      n !== void 0 && (i = i.concat(n));
    return i;
  }
  return Tn.concat = e, Tn;
}
var MM;
function LK() {
  if (MM) return XI;
  MM = 1, Object.defineProperty(XI, "__esModule", { value: !0 }), XI.QuickJSContext = void 0;
  const t = WE(), A = _K(), e = vg(), r = Rg(), i = NK(), n = VE();
  class s extends i.ModuleMemory {
    /** @private */
    constructor(o) {
      var u;
      super(o.module), this.scope = new r.Scope(), this.copyJSValue = (I) => this.ffi.QTS_DupValuePointer(this.ctx.value, I), this.freeJSValue = (I) => {
        this.ffi.QTS_FreeValuePointer(this.ctx.value, I);
      }, (u = o.ownedLifetimes) == null || u.forEach((I) => this.scope.manage(I)), this.owner = o.owner, this.module = o.module, this.ffi = o.ffi, this.rt = o.rt, this.ctx = this.scope.manage(o.ctx);
    }
    get alive() {
      return this.scope.alive;
    }
    dispose() {
      return this.scope.dispose();
    }
    /**
     * Track `lifetime` so that it is disposed when this scope is disposed.
     */
    manage(o) {
      return this.scope.manage(o);
    }
    consumeJSCharPointer(o) {
      const u = this.module.UTF8ToString(o);
      return this.ffi.QTS_FreeCString(this.ctx.value, o), u;
    }
    heapValueHandle(o) {
      return new r.Lifetime(o, this.copyJSValue, this.freeJSValue, this.owner);
    }
  }
  class a {
    /**
     * Use {@link QuickJS.createVm} to create a QuickJSContext instance.
     */
    constructor(o) {
      this._undefined = void 0, this._null = void 0, this._false = void 0, this._true = void 0, this._global = void 0, this._BigInt = void 0, this.fnNextId = -32768, this.fnMaps = /* @__PURE__ */ new Map(), this.cToHostCallbacks = {
        callFunction: (u, I, c, C, E) => {
          if (u !== this.ctx.value)
            throw new Error("QuickJSContext instance received C -> JS call with mismatched ctx");
          const l = this.getFunction(E);
          if (!l)
            throw new Error(`QuickJSContext had no callback with id ${E}`);
          return r.Scope.withScopeMaybeAsync(this, function* (B, h) {
            const Q = h.manage(new r.WeakLifetime(I, this.memory.copyJSValue, this.memory.freeJSValue, this.runtime)), f = new Array(c);
            for (let p = 0; p < c; p++) {
              const y = this.ffi.QTS_ArgvGetJSValueConstPointer(C, p);
              f[p] = h.manage(new r.WeakLifetime(y, this.memory.copyJSValue, this.memory.freeJSValue, this.runtime));
            }
            try {
              const p = yield* B(l.apply(Q, f));
              if (p) {
                if ("error" in p && p.error)
                  throw (0, t.debugLog)("throw error", p.error), p.error;
                const y = h.manage(p instanceof r.Lifetime ? p : p.value);
                return this.ffi.QTS_DupValuePointer(this.ctx.value, y.value);
              }
              return 0;
            } catch (p) {
              return this.errorToHandle(p).consume((y) => this.ffi.QTS_Throw(this.ctx.value, y.value));
            }
          });
        }
      }, this.runtime = o.runtime, this.module = o.module, this.ffi = o.ffi, this.rt = o.rt, this.ctx = o.ctx, this.memory = new s({
        ...o,
        owner: this.runtime
      }), o.callbacks.setContextCallbacks(this.ctx.value, this.cToHostCallbacks), this.dump = this.dump.bind(this), this.getString = this.getString.bind(this), this.getNumber = this.getNumber.bind(this), this.resolvePromise = this.resolvePromise.bind(this);
    }
    // @implement Disposable ----------------------------------------------------
    get alive() {
      return this.memory.alive;
    }
    /**
     * Dispose of this VM's underlying resources.
     *
     * @throws Calling this method without disposing of all created handles
     * will result in an error.
     */
    dispose() {
      this.memory.dispose();
    }
    // Globals ------------------------------------------------------------------
    /**
     * [`undefined`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined).
     */
    get undefined() {
      if (this._undefined)
        return this._undefined;
      const o = this.ffi.QTS_GetUndefined();
      return this._undefined = new r.StaticLifetime(o);
    }
    /**
     * [`null`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/null).
     */
    get null() {
      if (this._null)
        return this._null;
      const o = this.ffi.QTS_GetNull();
      return this._null = new r.StaticLifetime(o);
    }
    /**
     * [`true`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/true).
     */
    get true() {
      if (this._true)
        return this._true;
      const o = this.ffi.QTS_GetTrue();
      return this._true = new r.StaticLifetime(o);
    }
    /**
     * [`false`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/false).
     */
    get false() {
      if (this._false)
        return this._false;
      const o = this.ffi.QTS_GetFalse();
      return this._false = new r.StaticLifetime(o);
    }
    /**
     * [`global`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects).
     * A handle to the global object inside the interpreter.
     * You can set properties to create global variables.
     */
    get global() {
      if (this._global)
        return this._global;
      const o = this.ffi.QTS_GetGlobalObject(this.ctx.value);
      return this.memory.manage(this.memory.heapValueHandle(o)), this._global = new r.StaticLifetime(o, this.runtime), this._global;
    }
    // New values ---------------------------------------------------------------
    /**
     * Converts a Javascript number into a QuickJS value.
     */
    newNumber(o) {
      return this.memory.heapValueHandle(this.ffi.QTS_NewFloat64(this.ctx.value, o));
    }
    /**
     * Create a QuickJS [string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String) value.
     */
    newString(o) {
      const u = this.memory.newHeapCharPointer(o).consume((I) => this.ffi.QTS_NewString(this.ctx.value, I.value));
      return this.memory.heapValueHandle(u);
    }
    /**
     * Create a QuickJS [symbol](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol) value.
     * No two symbols created with this function will be the same value.
     */
    newUniqueSymbol(o) {
      const u = (typeof o == "symbol" ? o.description : o) ?? "", I = this.memory.newHeapCharPointer(u).consume((c) => this.ffi.QTS_NewSymbol(this.ctx.value, c.value, 0));
      return this.memory.heapValueHandle(I);
    }
    /**
     * Get a symbol from the [global registry](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol#shared_symbols_in_the_global_symbol_registry) for the given key.
     * All symbols created with the same key will be the same value.
     */
    newSymbolFor(o) {
      const u = (typeof o == "symbol" ? o.description : o) ?? "", I = this.memory.newHeapCharPointer(u).consume((c) => this.ffi.QTS_NewSymbol(this.ctx.value, c.value, 1));
      return this.memory.heapValueHandle(I);
    }
    /**
     * Create a QuickJS [bigint](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt) value.
     */
    newBigInt(o) {
      if (!this._BigInt) {
        const c = this.getProp(this.global, "BigInt");
        this.memory.manage(c), this._BigInt = new r.StaticLifetime(c.value, this.runtime);
      }
      const u = this._BigInt, I = String(o);
      return this.newString(I).consume((c) => this.unwrapResult(this.callFunction(u, this.undefined, c)));
    }
    /**
     * `{}`.
     * Create a new QuickJS [object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer).
     *
     * @param prototype - Like [`Object.create`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create).
     */
    newObject(o) {
      o && this.runtime.assertOwned(o);
      const u = o ? this.ffi.QTS_NewObjectProto(this.ctx.value, o.value) : this.ffi.QTS_NewObject(this.ctx.value);
      return this.memory.heapValueHandle(u);
    }
    /**
     * `[]`.
     * Create a new QuickJS [array](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array).
     */
    newArray() {
      const o = this.ffi.QTS_NewArray(this.ctx.value);
      return this.memory.heapValueHandle(o);
    }
    newPromise(o) {
      const u = r.Scope.withScope((I) => {
        const c = I.manage(this.memory.newMutablePointerArray(2)), C = this.ffi.QTS_NewPromiseCapability(this.ctx.value, c.value.ptr), E = this.memory.heapValueHandle(C), [l, B] = Array.from(c.value.typedArray).map((h) => this.memory.heapValueHandle(h));
        return new A.QuickJSDeferredPromise({
          context: this,
          promiseHandle: E,
          resolveHandle: l,
          rejectHandle: B
        });
      });
      return o && typeof o == "function" && (o = new Promise(o)), o && Promise.resolve(o).then(u.resolve, (I) => I instanceof r.Lifetime ? u.reject(I) : this.newError(I).consume(u.reject)), u;
    }
    /**
     * Convert a Javascript function into a QuickJS function value.
     * See [[VmFunctionImplementation]] for more details.
     *
     * A [[VmFunctionImplementation]] should not free its arguments or its return
     * value. A VmFunctionImplementation should also not retain any references to
     * its return value.
     *
     * To implement an async function, create a promise with [[newPromise]], then
     * return the deferred promise handle from `deferred.handle` from your
     * function implementation:
     *
     * ```
     * const deferred = vm.newPromise()
     * someNativeAsyncFunction().then(deferred.resolve)
     * return deferred.handle
     * ```
     */
    newFunction(o, u) {
      const I = ++this.fnNextId;
      return this.setFunction(I, u), this.memory.heapValueHandle(this.ffi.QTS_NewFunction(this.ctx.value, I, o));
    }
    newError(o) {
      const u = this.memory.heapValueHandle(this.ffi.QTS_NewError(this.ctx.value));
      return o && typeof o == "object" ? (o.name !== void 0 && this.newString(o.name).consume((I) => this.setProp(u, "name", I)), o.message !== void 0 && this.newString(o.message).consume((I) => this.setProp(u, "message", I))) : typeof o == "string" ? this.newString(o).consume((I) => this.setProp(u, "message", I)) : o !== void 0 && this.newString(String(o)).consume((I) => this.setProp(u, "message", I)), u;
    }
    // Read values --------------------------------------------------------------
    /**
     * `typeof` operator. **Not** [standards compliant](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof).
     *
     * @remarks
     * Does not support BigInt values correctly.
     */
    typeof(o) {
      return this.runtime.assertOwned(o), this.memory.consumeHeapCharPointer(this.ffi.QTS_Typeof(this.ctx.value, o.value));
    }
    /**
     * Converts `handle` into a Javascript number.
     * @returns `NaN` on error, otherwise a `number`.
     */
    getNumber(o) {
      return this.runtime.assertOwned(o), this.ffi.QTS_GetFloat64(this.ctx.value, o.value);
    }
    /**
     * Converts `handle` to a Javascript string.
     */
    getString(o) {
      return this.runtime.assertOwned(o), this.memory.consumeJSCharPointer(this.ffi.QTS_GetString(this.ctx.value, o.value));
    }
    /**
     * Converts `handle` into a Javascript symbol. If the symbol is in the global
     * registry in the guest, it will be created with Symbol.for on the host.
     */
    getSymbol(o) {
      this.runtime.assertOwned(o);
      const u = this.memory.consumeJSCharPointer(this.ffi.QTS_GetSymbolDescriptionOrKey(this.ctx.value, o.value));
      return this.ffi.QTS_IsGlobalSymbol(this.ctx.value, o.value) ? Symbol.for(u) : Symbol(u);
    }
    /**
     * Converts `handle` to a Javascript bigint.
     */
    getBigInt(o) {
      this.runtime.assertOwned(o);
      const u = this.getString(o);
      return BigInt(u);
    }
    /**
     * `Promise.resolve(value)`.
     * Convert a handle containing a Promise-like value inside the VM into an
     * actual promise on the host.
     *
     * @remarks
     * You may need to call [[executePendingJobs]] to ensure that the promise is resolved.
     *
     * @param promiseLikeHandle - A handle to a Promise-like value with a `.then(onSuccess, onError)` method.
     */
    resolvePromise(o) {
      this.runtime.assertOwned(o);
      const u = r.Scope.withScope((I) => {
        const c = I.manage(this.getProp(this.global, "Promise")), C = I.manage(this.getProp(c, "resolve"));
        return this.callFunction(C, c, o);
      });
      return u.error ? Promise.resolve(u) : new Promise((I) => {
        r.Scope.withScope((c) => {
          const C = c.manage(this.newFunction("resolve", (h) => {
            I({ value: h && h.dup() });
          })), E = c.manage(this.newFunction("reject", (h) => {
            I({ error: h && h.dup() });
          })), l = c.manage(u.value), B = c.manage(this.getProp(l, "then"));
          this.unwrapResult(this.callFunction(B, l, C, E)).dispose();
        });
      });
    }
    // Properties ---------------------------------------------------------------
    /**
     * `handle[key]`.
     * Get a property from a JSValue.
     *
     * @param key - The property may be specified as a JSValue handle, or as a
     * Javascript string (which will be converted automatically).
     */
    getProp(o, u) {
      this.runtime.assertOwned(o);
      const I = this.borrowPropertyKey(u).consume((C) => this.ffi.QTS_GetProp(this.ctx.value, o.value, C.value));
      return this.memory.heapValueHandle(I);
    }
    /**
     * `handle[key] = value`.
     * Set a property on a JSValue.
     *
     * @remarks
     * Note that the QuickJS authors recommend using [[defineProp]] to define new
     * properties.
     *
     * @param key - The property may be specified as a JSValue handle, or as a
     * Javascript string or number (which will be converted automatically to a JSValue).
     */
    setProp(o, u, I) {
      this.runtime.assertOwned(o), this.borrowPropertyKey(u).consume((c) => this.ffi.QTS_SetProp(this.ctx.value, o.value, c.value, I.value));
    }
    /**
     * [`Object.defineProperty(handle, key, descriptor)`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty).
     *
     * @param key - The property may be specified as a JSValue handle, or as a
     * Javascript string or number (which will be converted automatically to a JSValue).
     */
    defineProp(o, u, I) {
      this.runtime.assertOwned(o), r.Scope.withScope((c) => {
        const C = c.manage(this.borrowPropertyKey(u)), E = I.value || this.undefined, l = !!I.configurable, B = !!I.enumerable, h = !!I.value, Q = I.get ? c.manage(this.newFunction(I.get.name, I.get)) : this.undefined, f = I.set ? c.manage(this.newFunction(I.set.name, I.set)) : this.undefined;
        this.ffi.QTS_DefineProp(this.ctx.value, o.value, C.value, E.value, Q.value, f.value, l, B, h);
      });
    }
    // Evaluation ---------------------------------------------------------------
    /**
     * [`func.call(thisVal, ...args)`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call).
     * Call a JSValue as a function.
     *
     * See [[unwrapResult]], which will throw if the function returned an error, or
     * return the result handle directly. If evaluation returned a handle containing
     * a promise, use [[resolvePromise]] to convert it to a native promise and
     * [[executePendingJobs]] to finish evaluating the promise.
     *
     * @returns A result. If the function threw synchronously, `result.error` be a
     * handle to the exception. Otherwise `result.value` will be a handle to the
     * value.
     */
    callFunction(o, u, ...I) {
      this.runtime.assertOwned(o);
      const c = this.memory.toPointerArray(I).consume((E) => this.ffi.QTS_Call(this.ctx.value, o.value, u.value, I.length, E.value)), C = this.ffi.QTS_ResolveException(this.ctx.value, c);
      return C ? (this.ffi.QTS_FreeValuePointer(this.ctx.value, c), { error: this.memory.heapValueHandle(C) }) : { value: this.memory.heapValueHandle(c) };
    }
    /**
     * Like [`eval(code)`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval#Description).
     * Evaluates the Javascript source `code` in the global scope of this VM.
     * When working with async code, you many need to call [[executePendingJobs]]
     * to execute callbacks pending after synchronous evaluation returns.
     *
     * See [[unwrapResult]], which will throw if the function returned an error, or
     * return the result handle directly. If evaluation returned a handle containing
     * a promise, use [[resolvePromise]] to convert it to a native promise and
     * [[executePendingJobs]] to finish evaluating the promise.
     *
     * *Note*: to protect against infinite loops, provide an interrupt handler to
     * [[setInterruptHandler]]. You can use [[shouldInterruptAfterDeadline]] to
     * create a time-based deadline.
     *
     * @returns The last statement's value. If the code threw synchronously,
     * `result.error` will be a handle to the exception. If execution was
     * interrupted, the error will have name `InternalError` and message
     * `interrupted`.
     */
    evalCode(o, u = "eval.js", I) {
      const c = I === void 0 ? 1 : 0, C = (0, n.evalOptionsToFlags)(I), E = this.memory.newHeapCharPointer(o).consume((B) => this.ffi.QTS_Eval(this.ctx.value, B.value, u, c, C)), l = this.ffi.QTS_ResolveException(this.ctx.value, E);
      return l ? (this.ffi.QTS_FreeValuePointer(this.ctx.value, E), { error: this.memory.heapValueHandle(l) }) : { value: this.memory.heapValueHandle(E) };
    }
    /**
     * Throw an error in the VM, interrupted whatever current execution is in progress when execution resumes.
     * @experimental
     */
    throw(o) {
      return this.errorToHandle(o).consume((u) => this.ffi.QTS_Throw(this.ctx.value, u.value));
    }
    /**
     * @private
     */
    borrowPropertyKey(o) {
      return typeof o == "number" ? this.newNumber(o) : typeof o == "string" ? this.newString(o) : new r.StaticLifetime(o.value, this.runtime);
    }
    /**
     * @private
     */
    getMemory(o) {
      if (o === this.rt.value)
        return this.memory;
      throw new Error("Private API. Cannot get memory from a different runtime");
    }
    // Utilities ----------------------------------------------------------------
    /**
     * Dump a JSValue to Javascript in a best-effort fashion.
     * Returns `handle.toString()` if it cannot be serialized to JSON.
     */
    dump(o) {
      this.runtime.assertOwned(o);
      const u = this.typeof(o);
      if (u === "string")
        return this.getString(o);
      if (u === "number")
        return this.getNumber(o);
      if (u === "bigint")
        return this.getBigInt(o);
      if (u === "undefined")
        return;
      if (u === "symbol")
        return this.getSymbol(o);
      const I = this.memory.consumeJSCharPointer(this.ffi.QTS_Dump(this.ctx.value, o.value));
      try {
        return JSON.parse(I);
      } catch {
        return I;
      }
    }
    /**
     * Unwrap a SuccessOrFail result such as a [[VmCallResult]] or a
     * [[ExecutePendingJobsResult]], where the fail branch contains a handle to a QuickJS error value.
     * If the result is a success, returns the value.
     * If the result is an error, converts the error to a native object and throws the error.
     */
    unwrapResult(o) {
      if (o.error) {
        const u = "context" in o.error ? o.error.context : this, I = o.error.consume((c) => this.dump(c));
        if (I && typeof I == "object" && typeof I.message == "string") {
          const { message: c, name: C, stack: E } = I, l = new e.QuickJSUnwrapError(""), B = l.stack;
          throw typeof C == "string" && (l.name = I.name), typeof E == "string" && (l.stack = `${C}: ${c}
${I.stack}Host: ${B}`), Object.assign(l, { cause: I, context: u, message: c }), l;
        }
        throw new e.QuickJSUnwrapError(I, u);
      }
      return o.value;
    }
    /** @private */
    getFunction(o) {
      const u = o >> 8, I = this.fnMaps.get(u);
      if (I)
        return I.get(o);
    }
    /** @private */
    setFunction(o, u) {
      const I = o >> 8;
      let c = this.fnMaps.get(I);
      return c || (c = /* @__PURE__ */ new Map(), this.fnMaps.set(I, c)), c.set(o, u);
    }
    errorToHandle(o) {
      return o instanceof r.Lifetime ? o : this.newError(o);
    }
  }
  return XI.QuickJSContext = a, XI;
}
var _M;
function xK() {
  if (_M) return ZI;
  _M = 1, Object.defineProperty(ZI, "__esModule", { value: !0 }), ZI.QuickJSRuntime = void 0;
  const t = MK(), A = LK(), e = WE(), r = vg(), i = Rg(), n = NK(), s = VE();
  class a {
    /** @private */
    constructor(o) {
      var u;
      this.scope = new i.Scope(), this.contextMap = /* @__PURE__ */ new Map(), this.cToHostCallbacks = {
        shouldInterrupt: (I) => {
          if (I !== this.rt.value)
            throw new Error("QuickJSContext instance received C -> JS interrupt with mismatched rt");
          const c = this.interruptHandler;
          if (!c)
            throw new Error("QuickJSContext had no interrupt handler");
          return c(this) ? 1 : 0;
        },
        loadModuleSource: (0, t.maybeAsyncFn)(this, function* (I, c, C, E) {
          const l = this.moduleLoader;
          if (!l)
            throw new Error("Runtime has no module loader");
          if (c !== this.rt.value)
            throw new Error("Runtime pointer mismatch");
          const B = this.contextMap.get(C) ?? this.newContext({
            contextPointer: C
          });
          try {
            const h = yield* I(l(E, B));
            if (typeof h == "object" && "error" in h && h.error)
              throw (0, e.debugLog)("cToHostLoadModule: loader returned error", h.error), h.error;
            const Q = typeof h == "string" ? h : "value" in h ? h.value : h;
            return this.memory.newHeapCharPointer(Q).value;
          } catch (h) {
            return (0, e.debugLog)("cToHostLoadModule: caught error", h), B.throw(h), 0;
          }
        }),
        normalizeModule: (0, t.maybeAsyncFn)(this, function* (I, c, C, E, l) {
          const B = this.moduleNormalizer;
          if (!B)
            throw new Error("Runtime has no module normalizer");
          if (c !== this.rt.value)
            throw new Error("Runtime pointer mismatch");
          const h = this.contextMap.get(C) ?? this.newContext({
            /* TODO: Does this happen? Are we responsible for disposing? I don't think so */
            contextPointer: C
          });
          try {
            const Q = yield* I(B(E, l, h));
            if (typeof Q == "object" && "error" in Q && Q.error)
              throw (0, e.debugLog)("cToHostNormalizeModule: normalizer returned error", Q.error), Q.error;
            const f = typeof Q == "string" ? Q : Q.value;
            return h.getMemory(this.rt.value).newHeapCharPointer(f).value;
          } catch (Q) {
            return (0, e.debugLog)("normalizeModule: caught error", Q), h.throw(Q), 0;
          }
        })
      }, (u = o.ownedLifetimes) == null || u.forEach((I) => this.scope.manage(I)), this.module = o.module, this.memory = new n.ModuleMemory(this.module), this.ffi = o.ffi, this.rt = o.rt, this.callbacks = o.callbacks, this.scope.manage(this.rt), this.callbacks.setRuntimeCallbacks(this.rt.value, this.cToHostCallbacks), this.executePendingJobs = this.executePendingJobs.bind(this);
    }
    get alive() {
      return this.scope.alive;
    }
    dispose() {
      return this.scope.dispose();
    }
    newContext(o = {}) {
      if (o.intrinsics && o.intrinsics !== s.DefaultIntrinsics)
        throw new Error("TODO: Custom intrinsics are not supported yet");
      const u = new i.Lifetime(o.contextPointer || this.ffi.QTS_NewContext(this.rt.value), void 0, (c) => {
        this.contextMap.delete(c), this.callbacks.deleteContext(c), this.ffi.QTS_FreeContext(c);
      }), I = new A.QuickJSContext({
        module: this.module,
        ctx: u,
        ffi: this.ffi,
        rt: this.rt,
        ownedLifetimes: o.ownedLifetimes,
        runtime: this,
        callbacks: this.callbacks
      });
      return this.contextMap.set(u.value, I), I;
    }
    /**
     * Set the loader for EcmaScript modules requested by any context in this
     * runtime.
     *
     * The loader can be removed with [[removeModuleLoader]].
     */
    setModuleLoader(o, u) {
      this.moduleLoader = o, this.moduleNormalizer = u, this.ffi.QTS_RuntimeEnableModuleLoader(this.rt.value, this.moduleNormalizer ? 1 : 0);
    }
    /**
     * Remove the the loader set by [[setModuleLoader]]. This disables module loading.
     */
    removeModuleLoader() {
      this.moduleLoader = void 0, this.ffi.QTS_RuntimeDisableModuleLoader(this.rt.value);
    }
    // Runtime management -------------------------------------------------------
    /**
     * In QuickJS, promises and async functions create pendingJobs. These do not execute
     * immediately and need to be run by calling [[executePendingJobs]].
     *
     * @return true if there is at least one pendingJob queued up.
     */
    hasPendingJob() {
      return !!this.ffi.QTS_IsJobPending(this.rt.value);
    }
    /**
     * Set a callback which is regularly called by the QuickJS engine when it is
     * executing code. This callback can be used to implement an execution
     * timeout.
     *
     * The interrupt handler can be removed with [[removeInterruptHandler]].
     */
    setInterruptHandler(o) {
      const u = this.interruptHandler;
      this.interruptHandler = o, u || this.ffi.QTS_RuntimeEnableInterruptHandler(this.rt.value);
    }
    /**
     * Remove the interrupt handler, if any.
     * See [[setInterruptHandler]].
     */
    removeInterruptHandler() {
      this.interruptHandler && (this.ffi.QTS_RuntimeDisableInterruptHandler(this.rt.value), this.interruptHandler = void 0);
    }
    /**
     * Execute pendingJobs on the runtime until `maxJobsToExecute` jobs are
     * executed (default all pendingJobs), the queue is exhausted, or the runtime
     * encounters an exception.
     *
     * In QuickJS, promises and async functions *inside the runtime* create
     * pendingJobs. These do not execute immediately and need to triggered to run.
     *
     * @param maxJobsToExecute - When negative, run all pending jobs. Otherwise execute
     * at most `maxJobsToExecute` before returning.
     *
     * @return On success, the number of executed jobs. On error, the exception
     * that stopped execution, and the context it occurred in. Note that
     * executePendingJobs will not normally return errors thrown inside async
     * functions or rejected promises. Those errors are available by calling
     * [[resolvePromise]] on the promise handle returned by the async function.
     */
    executePendingJobs(o = -1) {
      const u = this.memory.newMutablePointerArray(1), I = this.ffi.QTS_ExecutePendingJob(this.rt.value, o ?? -1, u.value.ptr), c = u.value.typedArray[0];
      if (u.dispose(), c === 0)
        return this.ffi.QTS_FreeValuePointerRuntime(this.rt.value, I), { value: 0 };
      const C = this.contextMap.get(c) ?? this.newContext({
        contextPointer: c
      }), E = C.getMemory(this.rt.value).heapValueHandle(I);
      if (C.typeof(E) === "number") {
        const B = C.getNumber(E);
        return E.dispose(), { value: B };
      } else
        return {
          error: Object.assign(E, { context: C })
        };
    }
    /**
     * Set the max memory this runtime can allocate.
     * To remove the limit, set to `-1`.
     */
    setMemoryLimit(o) {
      if (o < 0 && o !== -1)
        throw new Error("Cannot set memory limit to negative number. To unset, pass -1");
      this.ffi.QTS_RuntimeSetMemoryLimit(this.rt.value, o);
    }
    /**
     * Compute memory usage for this runtime. Returns the result as a handle to a
     * JSValue object. Use [[QuickJSContext.dump]] to convert to a native object.
     * Calling this method will allocate more memory inside the runtime. The information
     * is accurate as of just before the call to `computeMemoryUsage`.
     * For a human-digestible representation, see [[dumpMemoryUsage]].
     */
    computeMemoryUsage() {
      const o = this.getSystemContext().getMemory(this.rt.value);
      return o.heapValueHandle(this.ffi.QTS_RuntimeComputeMemoryUsage(this.rt.value, o.ctx.value));
    }
    /**
     * @returns a human-readable description of memory usage in this runtime.
     * For programmatic access to this information, see [[computeMemoryUsage]].
     */
    dumpMemoryUsage() {
      return this.memory.consumeHeapCharPointer(this.ffi.QTS_RuntimeDumpMemoryUsage(this.rt.value));
    }
    /**
     * Set the max stack size for this runtime, in bytes.
     * To remove the limit, set to `0`.
     */
    setMaxStackSize(o) {
      if (o < 0)
        throw new Error("Cannot set memory limit to negative number. To unset, pass 0.");
      this.ffi.QTS_RuntimeSetMaxStackSize(this.rt.value, o);
    }
    /**
     * Assert that `handle` is owned by this runtime.
     * @throws QuickJSWrongOwner if owned by a different runtime.
     */
    assertOwned(o) {
      if (o.owner && o.owner.rt !== this.rt)
        throw new r.QuickJSWrongOwner(`Handle is not owned by this runtime: ${o.owner.rt.value} != ${this.rt.value}`);
    }
    getSystemContext() {
      return this.context || (this.context = this.scope.manage(this.newContext())), this.context;
    }
  }
  return ZI.QuickJSRuntime = a, ZI;
}
var NM;
function GK() {
  if (NM) return Ii;
  NM = 1, Object.defineProperty(Ii, "__esModule", { value: !0 }), Ii.QuickJSWASMModule = Ii.applyModuleEvalRuntimeOptions = Ii.applyBaseRuntimeOptions = Ii.QuickJSModuleCallbacks = void 0;
  const t = WE(), A = vg(), e = Rg(), r = xK(), i = VE();
  class n {
    constructor(I) {
      this.callFunction = I.callFunction, this.shouldInterrupt = I.shouldInterrupt, this.loadModuleSource = I.loadModuleSource, this.normalizeModule = I.normalizeModule;
    }
  }
  class s {
    constructor(I) {
      this.contextCallbacks = /* @__PURE__ */ new Map(), this.runtimeCallbacks = /* @__PURE__ */ new Map(), this.suspendedCount = 0, this.cToHostCallbacks = new n({
        callFunction: (c, C, E, l, B, h) => this.handleAsyncify(c, () => {
          try {
            const Q = this.contextCallbacks.get(C);
            if (!Q)
              throw new Error(`QuickJSContext(ctx = ${C}) not found for C function call "${h}"`);
            return Q.callFunction(C, E, l, B, h);
          } catch (Q) {
            return console.error("[C to host error: returning null]", Q), 0;
          }
        }),
        shouldInterrupt: (c, C) => this.handleAsyncify(c, () => {
          try {
            const E = this.runtimeCallbacks.get(C);
            if (!E)
              throw new Error(`QuickJSRuntime(rt = ${C}) not found for C interrupt`);
            return E.shouldInterrupt(C);
          } catch (E) {
            return console.error("[C to host interrupt: returning error]", E), 1;
          }
        }),
        loadModuleSource: (c, C, E, l) => this.handleAsyncify(c, () => {
          try {
            const B = this.runtimeCallbacks.get(C);
            if (!B)
              throw new Error(`QuickJSRuntime(rt = ${C}) not found for C module loader`);
            const h = B.loadModuleSource;
            if (!h)
              throw new Error(`QuickJSRuntime(rt = ${C}) does not support module loading`);
            return h(C, E, l);
          } catch (B) {
            return console.error("[C to host module loader error: returning null]", B), 0;
          }
        }),
        normalizeModule: (c, C, E, l, B) => this.handleAsyncify(c, () => {
          try {
            const h = this.runtimeCallbacks.get(C);
            if (!h)
              throw new Error(`QuickJSRuntime(rt = ${C}) not found for C module loader`);
            const Q = h.normalizeModule;
            if (!Q)
              throw new Error(`QuickJSRuntime(rt = ${C}) does not support module loading`);
            return Q(C, E, l, B);
          } catch (h) {
            return console.error("[C to host module loader error: returning null]", h), 0;
          }
        })
      }), this.module = I, this.module.callbacks = this.cToHostCallbacks;
    }
    setRuntimeCallbacks(I, c) {
      this.runtimeCallbacks.set(I, c);
    }
    deleteRuntime(I) {
      this.runtimeCallbacks.delete(I);
    }
    setContextCallbacks(I, c) {
      this.contextCallbacks.set(I, c);
    }
    deleteContext(I) {
      this.contextCallbacks.delete(I);
    }
    handleAsyncify(I, c) {
      if (I)
        return I.handleSleep((E) => {
          try {
            const l = c();
            if (!(l instanceof Promise)) {
              (0, t.debugLog)("asyncify.handleSleep: not suspending:", l), E(l);
              return;
            }
            if (this.suspended)
              throw new A.QuickJSAsyncifyError(`Already suspended at: ${this.suspended.stack}
Attempted to suspend at:`);
            this.suspended = new A.QuickJSAsyncifySuspended(`(${this.suspendedCount++})`), (0, t.debugLog)("asyncify.handleSleep: suspending:", this.suspended), l.then((B) => {
              this.suspended = void 0, (0, t.debugLog)("asyncify.handleSleep: resolved:", B), E(B);
            }, (B) => {
              (0, t.debugLog)("asyncify.handleSleep: rejected:", B), console.error("QuickJS: cannot handle error in suspended function", B), this.suspended = void 0;
            });
          } catch (l) {
            throw (0, t.debugLog)("asyncify.handleSleep: error:", l), this.suspended = void 0, l;
          }
        });
      const C = c();
      if (C instanceof Promise)
        throw new Error("Promise return value not supported in non-asyncify context.");
      return C;
    }
  }
  Ii.QuickJSModuleCallbacks = s;
  function a(u, I) {
    I.interruptHandler && u.setInterruptHandler(I.interruptHandler), I.maxStackSizeBytes !== void 0 && u.setMaxStackSize(I.maxStackSizeBytes), I.memoryLimitBytes !== void 0 && u.setMemoryLimit(I.memoryLimitBytes);
  }
  Ii.applyBaseRuntimeOptions = a;
  function g(u, I) {
    I.moduleLoader && u.setModuleLoader(I.moduleLoader), I.shouldInterrupt && u.setInterruptHandler(I.shouldInterrupt), I.memoryLimitBytes !== void 0 && u.setMemoryLimit(I.memoryLimitBytes), I.maxStackSizeBytes !== void 0 && u.setMaxStackSize(I.maxStackSizeBytes);
  }
  Ii.applyModuleEvalRuntimeOptions = g;
  class o {
    /** @private */
    constructor(I, c) {
      this.module = I, this.ffi = c, this.callbacks = new s(I);
    }
    /**
     * Create a runtime.
     * Use the runtime to set limits on CPU and memory usage and configure module
     * loading for one or more [[QuickJSContext]]s inside the runtime.
     */
    newRuntime(I = {}) {
      const c = new e.Lifetime(this.ffi.QTS_NewRuntime(), void 0, (E) => {
        this.callbacks.deleteRuntime(E), this.ffi.QTS_FreeRuntime(E);
      }), C = new r.QuickJSRuntime({
        module: this.module,
        callbacks: this.callbacks,
        ffi: this.ffi,
        rt: c
      });
      return a(C, I), I.moduleLoader && C.setModuleLoader(I.moduleLoader), C;
    }
    /**
     * A simplified API to create a new [[QuickJSRuntime]] and a
     * [[QuickJSContext]] inside that runtime at the same time. The runtime will
     * be disposed when the context is disposed.
     */
    newContext(I = {}) {
      const c = this.newRuntime(), C = c.newContext({
        ...I,
        ownedLifetimes: (0, i.concat)(c, I.ownedLifetimes)
      });
      return c.context = C, C;
    }
    /**
     * One-off evaluate code without needing to create a [[QuickJSRuntime]] or
     * [[QuickJSContext]] explicitly.
     *
     * To protect against infinite loops, use the `shouldInterrupt` option. The
     * [[shouldInterruptAfterDeadline]] function will create a time-based deadline.
     *
     * If you need more control over how the code executes, create a
     * [[QuickJSRuntime]] (with [[newRuntime]]) or a [[QuickJSContext]] (with
     * [[newContext]] or [[QuickJSRuntime.newContext]]), and use its
     * [[QuickJSContext.evalCode]] method.
     *
     * Asynchronous callbacks may not run during the first call to `evalCode`. If
     * you need to work with async code inside QuickJS, create a runtime and use
     * [[QuickJSRuntime.executePendingJobs]].
     *
     * @returns The result is coerced to a native Javascript value using JSON
     * serialization, so properties and values unsupported by JSON will be dropped.
     *
     * @throws If `code` throws during evaluation, the exception will be
     * converted into a native Javascript value and thrown.
     *
     * @throws if `options.shouldInterrupt` interrupted execution, will throw a Error
     * with name `"InternalError"` and  message `"interrupted"`.
     */
    evalCode(I, c = {}) {
      return e.Scope.withScope((C) => {
        const E = C.manage(this.newContext());
        g(E.runtime, c);
        const l = E.evalCode(I, "eval.js");
        if (c.memoryLimitBytes !== void 0 && E.runtime.setMemoryLimit(-1), l.error)
          throw E.dump(C.manage(l.error));
        return E.dump(C.manage(l.value));
      });
    }
    /**
     * Get a low-level interface to the QuickJS functions in this WebAssembly
     * module.
     * @experimental
     * @unstable No warranty is provided with this API. It could change at any time.
     * @private
     */
    getFFI() {
      return this.ffi;
    }
  }
  return Ii.QuickJSWASMModule = o, Ii;
}
var AC = {}, eC = {}, tC = {}, LM;
function btA() {
  if (LM) return tC;
  LM = 1, Object.defineProperty(tC, "__esModule", { value: !0 }), tC.QuickJSAsyncContext = void 0;
  const t = LK(), A = WE(), e = VE();
  class r extends t.QuickJSContext {
    /**
     * Asyncified version of [[evalCode]].
     */
    async evalCodeAsync(n, s = "eval.js", a) {
      const g = a === void 0 ? 1 : 0, o = (0, e.evalOptionsToFlags)(a);
      let u = 0;
      try {
        u = await this.memory.newHeapCharPointer(n).consume((c) => this.ffi.QTS_Eval_MaybeAsync(this.ctx.value, c.value, s, g, o));
      } catch (c) {
        throw (0, A.debugLog)("QTS_Eval_MaybeAsync threw", c), c;
      }
      const I = this.ffi.QTS_ResolveException(this.ctx.value, u);
      return I ? (this.ffi.QTS_FreeValuePointer(this.ctx.value, u), { error: this.memory.heapValueHandle(I) }) : { value: this.memory.heapValueHandle(u) };
    }
    /**
     * Similar to [[newFunction]].
     * Convert an async host Javascript function into a synchronous QuickJS function value.
     *
     * Whenever QuickJS calls this function, the VM's stack will be unwound while
     * waiting the async function to complete, and then restored when the returned
     * promise resolves.
     *
     * Asyncified functions must never call other asyncified functions or
     * `import`, even indirectly, because the stack cannot be unwound twice.
     *
     * See [Emscripten's docs on Asyncify](https://emscripten.org/docs/porting/asyncify.html).
     */
    newAsyncifiedFunction(n, s) {
      return this.newFunction(n, s);
    }
  }
  return tC.QuickJSAsyncContext = r, tC;
}
var xM;
function MtA() {
  if (xM) return eC;
  xM = 1, Object.defineProperty(eC, "__esModule", { value: !0 }), eC.QuickJSAsyncRuntime = void 0;
  const t = UK(), A = btA(), e = xK(), r = VE();
  class i extends e.QuickJSRuntime {
    /** @private */
    constructor(s) {
      super(s);
    }
    newContext(s = {}) {
      if (s.intrinsics && s.intrinsics !== r.DefaultIntrinsics)
        throw new Error("TODO: Custom intrinsics are not supported yet");
      const a = new t.Lifetime(this.ffi.QTS_NewContext(this.rt.value), void 0, (o) => {
        this.contextMap.delete(o), this.callbacks.deleteContext(o), this.ffi.QTS_FreeContext(o);
      }), g = new A.QuickJSAsyncContext({
        module: this.module,
        ctx: a,
        ffi: this.ffi,
        rt: this.rt,
        ownedLifetimes: [],
        runtime: this,
        callbacks: this.callbacks
      });
      return this.contextMap.set(a.value, g), g;
    }
    setModuleLoader(s, a) {
      super.setModuleLoader(s, a);
    }
    /**
     * Set the max stack size for this runtime in bytes.
     * To remove the limit, set to `0`.
     *
     * Setting this limit also adjusts the global `ASYNCIFY_STACK_SIZE` for the entire {@link QuickJSAsyncWASMModule}.
     * See the [pull request](https://github.com/justjake/quickjs-emscripten/pull/114) for more details.
     */
    setMaxStackSize(s) {
      return super.setMaxStackSize(s);
    }
  }
  return eC.QuickJSAsyncRuntime = i, eC;
}
var GM;
function _tA() {
  if (GM) return AC;
  GM = 1, Object.defineProperty(AC, "__esModule", { value: !0 }), AC.QuickJSAsyncWASMModule = void 0;
  const t = vg(), A = Rg(), e = GK(), r = MtA();
  class i extends e.QuickJSWASMModule {
    /** @private */
    constructor(s, a) {
      super(s, a), this.ffi = a, this.module = s;
    }
    /**
     * Create a new async runtime inside this WebAssembly module. All runtimes inside a
     * module are limited to a single async call at a time. For multiple
     * concurrent async actions, create multiple WebAssembly modules.
     */
    newRuntime(s = {}) {
      const a = new A.Lifetime(this.ffi.QTS_NewRuntime(), void 0, (o) => {
        this.callbacks.deleteRuntime(o), this.ffi.QTS_FreeRuntime(o);
      }), g = new r.QuickJSAsyncRuntime({
        module: this.module,
        ffi: this.ffi,
        rt: a,
        callbacks: this.callbacks
      });
      return (0, e.applyBaseRuntimeOptions)(g, s), s.moduleLoader && g.setModuleLoader(s.moduleLoader), g;
    }
    /**
     * A simplified API to create a new [[QuickJSRuntime]] and a
     * [[QuickJSContext]] inside that runtime at the same time. The runtime will
     * be disposed when the context is disposed.
     */
    newContext(s = {}) {
      const a = this.newRuntime(), g = s.ownedLifetimes ? s.ownedLifetimes.concat([a]) : [a], o = a.newContext({ ...s, ownedLifetimes: g });
      return a.context = o, o;
    }
    /** Synchronous evalCode is not supported. */
    evalCode() {
      throw new t.QuickJSNotImplemented("QuickJSWASMModuleAsyncify.evalCode: use evalCodeAsync instead");
    }
    /**
     * One-off evaluate code without needing to create a [[QuickJSRuntimeAsync]] or
     * [[QuickJSContextSync]] explicitly.
     *
     * This version allows for asynchronous Ecmascript module loading.
     *
     * Note that only a single async action can occur at a time inside the entire WebAssembly module.
     * **Multiple concurrent async actions is an error.**
     *
     * See the documentation for [[QuickJSWASMModule.evalCode]] for more details.
     */
    evalCodeAsync(s, a) {
      return A.Scope.withScopeAsync(async (g) => {
        const o = g.manage(this.newContext());
        (0, e.applyModuleEvalRuntimeOptions)(o.runtime, a);
        const u = await o.evalCodeAsync(s, "eval.js");
        if (a.memoryLimitBytes !== void 0 && o.runtime.setMemoryLimit(-1), u.error)
          throw o.dump(g.manage(u.error));
        return o.dump(g.manage(u.value));
      });
    }
  }
  return AC.QuickJSAsyncWASMModule = i, AC;
}
var rC = {}, UM;
function NtA() {
  if (UM) return rC;
  UM = 1, Object.defineProperty(rC, "__esModule", { value: !0 }), rC.QuickJSFFI = void 0;
  class t {
    constructor(e) {
      this.module = e, this.DEBUG = !1, this.QTS_Throw = this.module.cwrap("QTS_Throw", "number", ["number", "number"]), this.QTS_NewError = this.module.cwrap("QTS_NewError", "number", ["number"]), this.QTS_RuntimeSetMemoryLimit = this.module.cwrap("QTS_RuntimeSetMemoryLimit", null, ["number", "number"]), this.QTS_RuntimeComputeMemoryUsage = this.module.cwrap("QTS_RuntimeComputeMemoryUsage", "number", ["number", "number"]), this.QTS_RuntimeDumpMemoryUsage = this.module.cwrap("QTS_RuntimeDumpMemoryUsage", "number", ["number"]), this.QTS_RecoverableLeakCheck = this.module.cwrap("QTS_RecoverableLeakCheck", "number", []), this.QTS_BuildIsSanitizeLeak = this.module.cwrap("QTS_BuildIsSanitizeLeak", "number", []), this.QTS_RuntimeSetMaxStackSize = this.module.cwrap("QTS_RuntimeSetMaxStackSize", null, ["number", "number"]), this.QTS_GetUndefined = this.module.cwrap("QTS_GetUndefined", "number", []), this.QTS_GetNull = this.module.cwrap("QTS_GetNull", "number", []), this.QTS_GetFalse = this.module.cwrap("QTS_GetFalse", "number", []), this.QTS_GetTrue = this.module.cwrap("QTS_GetTrue", "number", []), this.QTS_NewRuntime = this.module.cwrap("QTS_NewRuntime", "number", []), this.QTS_FreeRuntime = this.module.cwrap("QTS_FreeRuntime", null, ["number"]), this.QTS_NewContext = this.module.cwrap("QTS_NewContext", "number", ["number"]), this.QTS_FreeContext = this.module.cwrap("QTS_FreeContext", null, ["number"]), this.QTS_FreeValuePointer = this.module.cwrap("QTS_FreeValuePointer", null, ["number", "number"]), this.QTS_FreeValuePointerRuntime = this.module.cwrap("QTS_FreeValuePointerRuntime", null, ["number", "number"]), this.QTS_FreeVoidPointer = this.module.cwrap("QTS_FreeVoidPointer", null, ["number", "number"]), this.QTS_FreeCString = this.module.cwrap("QTS_FreeCString", null, ["number", "number"]), this.QTS_DupValuePointer = this.module.cwrap("QTS_DupValuePointer", "number", ["number", "number"]), this.QTS_NewObject = this.module.cwrap("QTS_NewObject", "number", ["number"]), this.QTS_NewObjectProto = this.module.cwrap("QTS_NewObjectProto", "number", ["number", "number"]), this.QTS_NewArray = this.module.cwrap("QTS_NewArray", "number", ["number"]), this.QTS_NewFloat64 = this.module.cwrap("QTS_NewFloat64", "number", ["number", "number"]), this.QTS_GetFloat64 = this.module.cwrap("QTS_GetFloat64", "number", ["number", "number"]), this.QTS_NewString = this.module.cwrap("QTS_NewString", "number", ["number", "number"]), this.QTS_GetString = this.module.cwrap("QTS_GetString", "number", ["number", "number"]), this.QTS_NewSymbol = this.module.cwrap("QTS_NewSymbol", "number", ["number", "number", "number"]), this.QTS_GetSymbolDescriptionOrKey = this.module.cwrap("QTS_GetSymbolDescriptionOrKey", "number", ["number", "number"]), this.QTS_IsGlobalSymbol = this.module.cwrap("QTS_IsGlobalSymbol", "number", ["number", "number"]), this.QTS_IsJobPending = this.module.cwrap("QTS_IsJobPending", "number", ["number"]), this.QTS_ExecutePendingJob = this.module.cwrap("QTS_ExecutePendingJob", "number", ["number", "number", "number"]), this.QTS_GetProp = this.module.cwrap("QTS_GetProp", "number", ["number", "number", "number"]), this.QTS_SetProp = this.module.cwrap("QTS_SetProp", null, ["number", "number", "number", "number"]), this.QTS_DefineProp = this.module.cwrap("QTS_DefineProp", null, ["number", "number", "number", "number", "number", "number", "boolean", "boolean", "boolean"]), this.QTS_Call = this.module.cwrap("QTS_Call", "number", ["number", "number", "number", "number", "number"]), this.QTS_ResolveException = this.module.cwrap("QTS_ResolveException", "number", ["number", "number"]), this.QTS_Dump = this.module.cwrap("QTS_Dump", "number", ["number", "number"]), this.QTS_Eval = this.module.cwrap("QTS_Eval", "number", ["number", "number", "string", "number", "number"]), this.QTS_Typeof = this.module.cwrap("QTS_Typeof", "number", ["number", "number"]), this.QTS_GetGlobalObject = this.module.cwrap("QTS_GetGlobalObject", "number", ["number"]), this.QTS_NewPromiseCapability = this.module.cwrap("QTS_NewPromiseCapability", "number", ["number", "number"]), this.QTS_TestStringArg = this.module.cwrap("QTS_TestStringArg", null, ["string"]), this.QTS_BuildIsDebug = this.module.cwrap("QTS_BuildIsDebug", "number", []), this.QTS_BuildIsAsyncify = this.module.cwrap("QTS_BuildIsAsyncify", "number", []), this.QTS_NewFunction = this.module.cwrap("QTS_NewFunction", "number", ["number", "number", "string"]), this.QTS_ArgvGetJSValueConstPointer = this.module.cwrap("QTS_ArgvGetJSValueConstPointer", "number", ["number", "number"]), this.QTS_RuntimeEnableInterruptHandler = this.module.cwrap("QTS_RuntimeEnableInterruptHandler", null, ["number"]), this.QTS_RuntimeDisableInterruptHandler = this.module.cwrap("QTS_RuntimeDisableInterruptHandler", null, ["number"]), this.QTS_RuntimeEnableModuleLoader = this.module.cwrap("QTS_RuntimeEnableModuleLoader", null, ["number", "number"]), this.QTS_RuntimeDisableModuleLoader = this.module.cwrap("QTS_RuntimeDisableModuleLoader", null, ["number"]);
    }
  }
  return rC.QuickJSFFI = t, rC;
}
var Bw = { exports: {} }, TM;
function LtA() {
  return TM || (TM = 1, function(t, A) {
    var e = (() => {
      var r = typeof document < "u" && document.currentScript ? document.currentScript.src : void 0;
      return typeof __filename < "u" && (r = r || __filename), function(i = {}) {
        var n;
        n || (n = typeof i < "u" ? i : {});
        var s, a;
        n.ready = new Promise(function(q, AA) {
          s = q, a = AA;
        });
        var g = Object.assign({}, n), o = "./this.program", u = typeof window == "object", I = typeof importScripts == "function", c = typeof process == "object" && typeof process.versions == "object" && typeof process.versions.node == "string", C = "", E, l, B;
        if (c) {
          var h = Rf, Q = SE;
          C = I ? Q.dirname(C) + "/" : __dirname + "/", E = (q, AA) => {
            var gA = vA(q);
            return gA ? AA ? gA : gA.toString() : (q = q.startsWith("file://") ? new URL(q) : Q.normalize(q), h.readFileSync(q, AA ? void 0 : "utf8"));
          }, B = (q) => (q = E(q, !0), q.buffer || (q = new Uint8Array(q)), q), l = (q, AA, gA) => {
            var fA = vA(q);
            fA && AA(fA), q = q.startsWith("file://") ? new URL(q) : Q.normalize(q), h.readFile(q, function(LA, YA) {
              LA ? gA(LA) : AA(YA.buffer);
            });
          }, !n.thisProgram && 1 < process.argv.length && (o = process.argv[1].replace(/\\/g, "/")), process.argv.slice(2), n.inspect = function() {
            return "[Emscripten Module object]";
          };
        } else (u || I) && (I ? C = self.location.href : typeof document < "u" && document.currentScript && (C = document.currentScript.src), r && (C = r), C.indexOf("blob:") !== 0 ? C = C.substr(0, C.replace(/[?#].*/, "").lastIndexOf("/") + 1) : C = "", E = (q) => {
          try {
            var AA = new XMLHttpRequest();
            return AA.open("GET", q, !1), AA.send(null), AA.responseText;
          } catch (LA) {
            if (q = vA(q)) {
              AA = [];
              for (var gA = 0; gA < q.length; gA++) {
                var fA = q[gA];
                255 < fA && (fA &= 255), AA.push(String.fromCharCode(fA));
              }
              return AA.join("");
            }
            throw LA;
          }
        }, I && (B = (q) => {
          try {
            var AA = new XMLHttpRequest();
            return AA.open("GET", q, !1), AA.responseType = "arraybuffer", AA.send(null), new Uint8Array(AA.response);
          } catch (gA) {
            if (q = vA(q))
              return q;
            throw gA;
          }
        }), l = (q, AA, gA) => {
          var fA = new XMLHttpRequest();
          fA.open("GET", q, !0), fA.responseType = "arraybuffer", fA.onload = () => {
            if (fA.status == 200 || fA.status == 0 && fA.response)
              AA(fA.response);
            else {
              var LA = vA(q);
              LA ? AA(LA.buffer) : gA();
            }
          }, fA.onerror = gA, fA.send(null);
        });
        var f = n.print || console.log.bind(console), p = n.printErr || console.warn.bind(console);
        Object.assign(n, g), g = null, n.thisProgram && (o = n.thisProgram);
        var y;
        n.wasmBinary && (y = n.wasmBinary), n.noExitRuntime, typeof WebAssembly != "object" && rA("no native wasm support detected");
        var m, S = !1, w, F, b, G;
        function T() {
          var q = m.buffer;
          n.HEAP8 = w = new Int8Array(q), n.HEAP16 = new Int16Array(q), n.HEAP32 = b = new Int32Array(q), n.HEAPU8 = F = new Uint8Array(q), n.HEAPU16 = new Uint16Array(q), n.HEAPU32 = G = new Uint32Array(q), n.HEAPF32 = new Float32Array(q), n.HEAPF64 = new Float64Array(q);
        }
        var K = [], H = [], j = [];
        function eA() {
          var q = n.preRun.shift();
          K.unshift(q);
        }
        var sA = 0, uA = null;
        function rA(q) {
          throw n.onAbort && n.onAbort(q), q = "Aborted(" + q + ")", p(q), S = !0, q = new WebAssembly.RuntimeError(q + ". Build with -sASSERTIONS for more info."), a(q), q;
        }
        var hA = "data:application/octet-stream;base64,", UA;
        if (UA = "data:application/octet-stream;base64,AGFzbQEAAAAB9QZxYAJ/fwBgA39/fwF/YAR/fn9/AX5gAn9/AX9gAX8Bf2AFf35/f38BfmADf39/AGAEf39/fwF/YAJ/fgF+YAF/AGAFf39/f38Bf2ABfAF8YAJ/fgBgAn9/AX5gAn9+AX9gA39/fgF/YAN/fn8BfmADf35/AGAGf35/f39/AX5gBn9/f39/fwF/YAR/f39/AGADf35/AX9gBn9+fn9/fwF+YAR/f35/AX9gA39+fgF+YAN/f38BfmAFf39/fn4Bf2AEf39/fgF/YAR/f35+AX9gBX9+fn5+AGABfwF+YAN/fn4Bf2AEf39/fwF+YAd/f39/f39/AX9gBX9/f39/AX5gAnx8AXxgAAF/YAV/f39/fwBgBX9+f35/AX9gBX9+fn9/AX5gAX4Bf2AEf35+fwBgB39+f35+fn8Bf2AIf39/f39/f38Bf2AFf35+fn8Bf2AGf35/fn5/AX9gBH9+f34BfmAEf35/fwBgBH9+f34AYAZ/f39/f38BfmAEf35+fwF/YAl/f39/f39/f38Bf2AEf35+fwF+YAR/fn9/AX9gA39+fgBgA35/fwF/YAV/fn5/fwBgA39/fgF+YAd/fn9/f39/AX5gAABgA39/fgBgBH9+f34Bf2AFf39+f38Bf2AEf35+fgF/YAd/f39/f39/AGACfH8BfGABfAF/YAN8fH8BfGACf38BfGAEf39+fwBgBH9+fn4BfmABfgF+YAJ/fAF/YAZ/fH9/f38Bf2AAAXxgBX9+f35/AX5gBn9/fn5+fgF/YAJ+fwBgAn98AGAEf39+fwF+YAV/f39/fgF+YAd/fn5+f39/AX5gBH5+fn4Bf2AHf39/f39/fgF+YAp/f39/f39/f39/AX9gB39/fn5/f38Bf2AFf3x/f38BfmACfn8Bf2AGfH9/f39/AGAFf35/f38AYAV/f35/fwBgBn9+fn5+fwF/YAV/f35+fwF/YAZ/fn9/f38Bf2ADf3x/AX9gBX9+f39/AX9gBX9/fn5+AX5gBX9+fn5+AX9gBn9/fn5/fwF/YAd/f39+fn5/AX9gBH9/f34BfmACfH8Bf2AGf39/f39/AGAIf39/f39/f38AYAN/fnwBfmAAAX5gAnx8AX9gAn5+AXxgAX8BfGADfn5+AX9gA39/fABgCH9+fn5+f35+AX5gCX9/f39/f39/fwACWw8B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rgitCKcIqAimCKUIpAj0B44JjQmKCYgJjAnwB/EH7gfrB+QH4gfhB9MHwQeaB/EEvAmbCZoJmQmYCZcJlgmVCZQJkwmSCZEJiwntCOwInQicCJsImgiZCKAFmAiXCJYIlQiUCJMIkQiQCI8IjgiNCIwIiwiKCIkIiAiHCIYI6QOFCOkDhAiDCIIIgQieCKEIoAifCKII2QP/B/4HkQeQB5kHmAeWB5UHlAeTB5IH4AffB94H6QPdB6AF3AfbB9oH2AerCKoIqQj/BooHiQeIB4cHhgeFB4QHgweCB4EHgAfoB4sHjweOB5sHpAehB6MHogefB54HnQecB6UH5wfmB+UH/gHsB+kH7QfvB/IH9QbPBPQG8wbyBvEGyATwBu8G9wbRBPYG9gf1B/sH+gf5B/gH/QeoCeMGpwnmBqYJpQmkCaMJ4QbfBsYEogmhCaAJsQafCZ4JnQmwBrIJsQmwCa8JrgmtCawJqwmqCbgJnQO3CbYJtQm0CbMJxgnJB8gHxQnECcMJwgnWA8EJwAn3BPgEvwm+CbsJugm5CckJyAnHCdAJzwm9BLwEzgnNCcwJywnKCbQG1AnTCdIJ0Qm4BrcGtga1BroGuQa9BrwGuwbSBtEG0AbPBs4GzQbMBssGygbJBsgGxwbGBsUGxAbDBsEGwAa/Br4G0wbcBoAJ+gj7CNsGgwmECYEJnQT+CPkI6wPMAtoG9QjxCO8I2Qb4CPQI8AiCCf8I/QiXAqcD1gnyCPwI2AbXBtYG1QbUBugG5wblBuQG4gbgBt4G3QbrBuoG6QbtBuwG7gapB6cHpgfPB4EF1weABc4HzQfMB8sHxwfGB8UHxAfDB8IHwAe/B9IH0AfWB9QHtAezB7EHsAevB64HrQesB6sHqge+B70HvAe7B7oHuQe4B7cHtge1B4cJhQmGCdgD8wgK15YXyAk1AQF/AkAgAUIgiKdBdUkNACABpyICIAIoAgAiAkEBazYCACACQQFKDQAgACgCECABEJYECwtNAQJ/IAAoAkAiAkGAAmohAyACKAKcAiAAKAIERwRAIANBwgEQESADIAAoAgQQHSACIAAoAgQ2ApwCCyACIAIoAoQCNgKYAiADIAEQEQsmAQF/IwBBEGsiAiQAIAIgAToADyAAIAJBD2pBARByIAJBEGokAAv/FwIGfwJ+IwBBEGsiAiQAAn8CQCAAKAIA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NwMgIABBgH82AhAMAwsgACACQQxqIAJBCGogBkEAEOoEIgFFDQAgACABNgIgIAIoAgghBSAAQQA2AiggACAFNgIkAkAgAUElSQ0AIAFBLU0EQCAAKAJAIgMtAG5BAXENASABQS1HDQMgAy8BbCIGQQFxDQEgBkGA/gNxQYAGRw0DIAMoAmQNAyADKAIEIgNFDQMgAy0AbEEBcQ0BDAMLIAFBLkcNAiAAKAJEDQAgACgCQCIDLwFsIgZBAnENACAGQYD+A3FBgAZHDQIgAygCZA0CIAMoAgQiA0UNAiADLQBsQQJxRQ0CCyAFBEAgAEGDfzYCECAAQQE2AigMAwsgBCABQdQAazYCAAwCCyAEQap/NgIADAULIARBg382AgALIAAgAigCDDYCOEEADAQLIABBATYCMCAAIANBAWo2AggLIAIoAgwhAQwACwALQX8LIQEgAkEQaiQAIAELFQAgAUHeAU4EQCAAKAIQIAEQ6AULC7oHAgZ/AX4jAEEgayIHJABCgICAgOAAIQsCQAJAAkACQAJAAkACQAJAAkACQCABQiCIpyIGQQFqDggDBQUAAQUFCQILIAAgAkGH1AAQjwEMBgsgACACQff4ABCPAQwFCyAGQXlGDQEMAgsgAachBgwCCyABpyEGIAJBAEgEQCACQf////8HcSIFIAYpAgQiC6dB/////wdxTw0BIAZBEGohAiAAAn8gC0KAgICACINQRQRAIAIgBUEBdGovAQAMAQsgAiAFai0AAAtB//8DcRCfAyELDAULIAJBMEcNACAGKQIEQv////8HgyELDAQLIAAgARCNBKciBkUNAgsgAkH/////B3EhCQNAIAYoAhAiBUEwaiEKIAUgBSgCGCACcUF/c0ECdGooAgAhBQJAA0AgBUUNASACIAogBUEBa0EDdCIFaiIIKAIERwRAIAgoAgBB////H3EhBQwBCwsgBigCFCAFaiEFAkACQAJAAkAgCCgCAEEedkEBaw4DAAECAwsgBSgCACICRQ0GIAIgAigCAEEBajYCACAAIAKtQoCAgIBwhCADQQBBABAvIQsMBwsgBSgCACgCECkDACILQoCAgIBwg0KAgICAwABRBEAgACACENkBDAULIAtCIIinQXVJDQYgC6ciACAAKAIAQQFqNgIADAYLIAAgBiACIAUgCBDIAkUNAgwDCyAFKQMAIgtCIIinQXVJDQQgC6ciACAAKAIAQQFqNgIADAQLAkAgBi0ABSIFQQRxRQ0AIAVBCHEEQCACQQBIBEAgBigCKCAJSwRAIAAgBq1CgICAgHCEIAkQsAEhCwwHCyAGLwEGQSBrQf//A3FB9f8DTw0FDAILIAYvAQZBFWtB//8DcUEKSw0BIAAgAhCeAyIFRQ0BQoCAgIDgAEKAgICAMCAFQQBIGyELDAULIAAoAhAoAkQgBi8BBkEYbGooAhQiBUUNACAFKAIUIggEQCAGIAYoAgBBAWo2AgAgACAGrUKAgICAcIQiASACIAMgCBEuACELIAAgARAPDAULIAUoAgAiBUUNACAGIAYoAgBBAWo2AgAgACAHIAatQoCAgIBwhCIBIAIgBREXACEFIAAgARAPIAVBAEgNAiAFRQ0AIActAABBEHEEQCAAIAcpAxgQDyAAIAcpAxAgA0EAQQAQLyELDAULIAcpAwghCwwECyAGKAIQKAIsIgYNAAtCgICAgDAhCyAERQ0CIAAgAhDHAgtCgICAgOAAIQsMAQtCgICAgDAhCwsgB0EgaiQAIAsLDQAgACABIAJBBBDOAgtfAQN/IwBBEGsiBCQAIAAoAgAhAyAEIAI2AgwgA0EDIAEgAkEAEPAFIAMgAygCECkDgAEgACgCDCAAKAIIIAAoAkAiAQR/IAEoAmhBAEdBAXQFQQALEMoCIARBEGokAAsMACAAQYACaiABECoLKwAgAUHeAU4EQCAAKAIQKAI4IAFBAnRqKAIAIgAgACgCAEEBajYCAAsgAQspACAAIAEgAiADQoCAgIAwQoCAgIAwIARBgM4AchBtIQIgACADEA8gAgsZACAAKAIAIAEQGCEBIABBQGsoAgAgARA5Cy0BAX8CQCAAKAIAIgFFDQAgACgCECIARQ0AIAEoAgAgAEEAIAEoAgQRAQAaCwtcAQF/IABBQGsoAgAiAxDmAkUEQEF/DwsgAkEASARAIAMQMiECCyAAIAFB/wFxEBAgAEFAayIAKAIAIAIQOSAAKAIAKAKkAiACQRRsaiIAIAAoAgBBAWo2AgAgAgsmAQF/IwBBEGsiAiQAIAIgATYCDCAAIAJBDGpBBBByIAJBEGokAAs5ACABQQBOBEAgAEG2ARAQIABBQGsiACgCACABEDkgACgCACIAKAKkAiABQRRsaiAAKAKEAjYCBAsLMwEBfyACBEAgACEDA0AgAyABLQAAOgAAIANBAWohAyABQQFqIQEgAkEBayICDQALCyAACxgBAX4gASkDACEDIAEgAjcDACAAIAMQDwsXACAAIAEgAkKAgICAMCADIARBAhDYAQvABQICfgZ/IwBB4ABrIgkkACADQQAgA0EAShshCwNAIAogC0ZFBEAgACACIApBBHRqIgMoAgAQtAUhBiADLQAEIQdCgICAgDAhBAJAAkACQAJAAkACQAJAAkACQAJAIAMtAAUOCgECAgUHAwQIBQAGCyAAIAMoAggQtAUhCAJ+AkACQAJAIAMoAgxBAWoOAwIAAQkLIAAgACkDwAEiBCAIIARBABAUDAILIAAgACgCKCkDECIEIAggBEEAEBQMAQsgACABIAggAUEAEBQLIQQgACAIEBMgBkHQAUYEQEEBIQcMCAsgBkHZAUcNB0EAIQcMBwsCQCAGQdABRgRAQQEhBwwBCyAGQdkBRw0AQQAhBwsgACABIAZBAiADIAcQlQMaDAcLQoCAgIAwIQUgAygCCARAIAkgAygCADYCECAJQSBqIghBwABBzDwgCUEQahBOGiAAIAMoAgggCEEAQQpBCCADLQAFQQJGGyADLgEGEIIBIQULIAMoAgwEQCAJIAMoAgA2AgAgCUEgaiIIQcAAQcU8IAkQThogACADKAIMIAhBAUELQQkgAy0ABUECRhsgAy4BBhCCASEECyAAIAEgBkKAgICAMCAFIAQgB0GAOnIQbRogACAFEA8gACAEEA8MBgsgAykDCCIEQoCAgIAIfEL/////D1gEQCAEQv////8PgyEEDAULQoCAgIDAfiAEub0iBEKAgICAwIGA/P8AfSAEQv///////////wCDQoCAgICAgID4/wBWGyEEDAQLQoCAgIDAfiADKQMIIgRCgICAgMCBgPz/AH0gBEL///////////8Ag0KAgICAgICA+P8AVhshBAwDCyAAIAEgBkECIAMgBxCVAxoMAwsQAQALIAM1AgghBAsgACABIAYgBCAHEBkaCyAAIAYQEyAKQQFqIQoMAQsLIAlB4ABqJAALMgEBfwJAIAFCIIinQXVJDQAgAaciAiACKAIAIgJBAWs2AgAgAkEBSg0AIAAgARCWBAsLCwAgAEGAMUEAEBULogICAn4BfwJAAkACQAJAAkACQAJAAkACQAJAAkBBByABQiCIpyIEIARBB2tBbkkbQQtqDhMEAgMIBgAAAAAAAQUHAAAAAAEFAAsgAEGVMEEAEBVCgICAgOAADwsgBEF1SQ0IIAGnIgAgACgCAEEBajYCAAwICyAAQSEQdiECDAYLIABBIhB2IQIMBQsgAEEkEHYhAgwECyAAQQQQdiECDAMLIAAgAEEFEHYiAkEwIAGnKQIEQv////8Hg0EAEBkaDAILIABBBhB2IQIMAQsgAEEHEHYhAgtCgICAgOAAIQMgAkKAgICAcINCgICAgOAAUgR+IARBdU8EQCABpyIEIAQoAgBBAWo2AgALIAAgAiABENsBIAIFQoCAgIDgAAsPCyABC9kBAgJ/AX5BfyECAkACQAJAAkACQAJAAkACQCABQiCIpyIDQQtqDhIHBwcFAgUFBQUFBAABAQEFBQYFCyABp0EARw8LIAGnDwsgAacpAgQhBCAAIAEQDyAEQv////8Hg0IAUg8LAAsgAacsAAUhAiAAIAEQDyACQQBODwsgA0EHa0FtTQRAIAFCgICAgMCBgPz/AHxC////////////AINCAX1CgICAgICAgPj/AFQPCyAAIAEQD0EBIQILIAIPCyABpygCDCECIAAgARAPIAJB/////wdqQX5JC6gEAQt/IAAoAgAhBSMAQRBrIgggAjYCDEF/IQkCQANAAkAgCCACIgNBBGoiAjYCDCADKAIAIgdBf0YNACAAKAIEIQoDQCABIgQgCk4NAyAEIAQgBWoiDC0AACIGQQJ0Ig1BgLgBai0AAGoiASAKSg0DIAZBwgFGBEAgDCgAASEJDAELCyAGIAdHBEAgBiAHQf8BcUYgBiAHQQh2Qf8BcUZyIAYgB0EQdkH/AXFGckUgB0EYdiAGR3EgBkUgB0GAAklycg0DIAAgBjYCEAsgBEEBaiEEAkACQAJAAkACQAJAAkACQCANQYO4AWotAABBBWsOGAAJAAkJAQkJAQkJAQEBAgICAgQFBgcJAwkLIAQgBWotAAAhBCAIIANBCGoiAjYCDCADKAIEIgNBf0YEQCAAIAQ2AhQMCQsgAyAERg0IDAkLIAQgBWovAAAhBCAIIANBCGoiAjYCDCADKAIEIgNBf0YEQCAAIAQ2AhQMCAsgAyAERg0HDAgLIAAgBCAFaigAADYCGAwGCyAAIAQgBWoiAygAADYCGCAAIAMvAAQ2AhwMBQsgACAEIAVqKAAANgIgDAQLIAAgBCAFaiIDKAAANgIgIAAgAy0ABDYCHAwDCyAAIAQgBWoiAygAADYCICAAIAMvAAQ2AhwMAgsgACAEIAVqIgMoAAA2AiAgACADKAAENgIYIAAgAy0ACDYCHAwBCwsgACAJNgIMIAAgATYCCEEBIQsLIAsLCwAgACABQQAQjgQLJAEBfyAAKAIQIgJBEGogASACKAIAEQMAIgFFBEAgABB8CyABCyYBAX8jAEEQayICJAAgAiABOwEOIAAgAkEOakECEHIgAkEQaiQACykBAX8gAgRAIAAhAwNAIAMgAToAACADQQFqIQMgAkEBayICDQALCyAACz8BAX8jAEEQayICJAACfyABIAAoAhBHBEAgAiABNgIAIABBoJgBIAIQFkF/DAELIAAQEgshACACQRBqJAAgAAsLACAAIAFBARDmBQvDCgIFfw9+IwBB4ABrIgUkACAEQv///////z+DIQwgAiAEhUKAgICAgICAgIB/gyEKIAJC////////P4MiDUIgiCEOIARCMIinQf//AXEhBwJAAkAgAkIwiKdB//8BcSIJQf//AWtBgoB+TwRAIAdB//8Ba0GBgH5LDQELIAFQIAJC////////////AIMiC0KAgICAgIDA//8AVCALQoCAgICAgMD//wBRG0UEQCACQoCAgICAgCCEIQoMAgsgA1AgBEL///////////8AgyICQoCAgICAgMD//wBUIAJCgICAgICAwP//AFEbRQRAIARCgICAgICAIIQhCiADIQEMAgsgASALQoCAgICAgMD//wCFhFAEQCACIAOEUARAQoCAgICAgOD//wAhCkIAIQEMAwsgCkKAgICAgIDA//8AhCEKQgAhAQwCCyADIAJCgICAgICAwP//AIWEUARAIAEgC4QhAkIAIQEgAlAEQEKAgICAgIDg//8AIQoMAwsgCkKAgICAgIDA//8AhCEKDAILIAEgC4RQBEBCACEBDAILIAIgA4RQBEBCACEBDAILIAtC////////P1gEQCAFQdAAaiABIA0gASANIA1QIgYbeSAGQQZ0rXynIgZBD2sQZ0EQIAZrIQYgBSkDWCINQiCIIQ4gBSkDUCEBCyACQv///////z9WDQAgBUFAayADIAwgAyAMIAxQIggbeSAIQQZ0rXynIghBD2sQZyAGIAhrQRBqIQYgBSkDSCEMIAUpA0AhAwsgA0IPhiILQoCA/v8PgyICIAFCIIgiBH4iECALQiCIIhMgAUL/////D4MiAX58Ig9CIIYiESABIAJ+fCILIBFUrSACIA1C/////w+DIg1+IhUgBCATfnwiESAMQg+GIhIgA0IxiIRC/////w+DIgMgAX58IhQgDyAQVK1CIIYgD0IgiIR8Ig8gAiAOQoCABIQiDH4iFiANIBN+fCIOIBJCIIhCgICAgAiEIgIgAX58IhAgAyAEfnwiEkIghnwiF3whASAHIAlqIAZqQf//AGshBgJAIAIgBH4iGCAMIBN+fCIEIBhUrSAEIAQgAyANfnwiBFatfCACIAx+fCAEIAQgESAVVK0gESAUVq18fCIEVq18IAMgDH4iAyACIA1+fCICIANUrUIghiACQiCIhHwgBCACQiCGfCICIARUrXwgAiACIBAgElatIA4gFlStIA4gEFatfHxCIIYgEkIgiIR8IgJWrXwgAiACIA8gFFStIA8gF1atfHwiAlatfCIEQoCAgICAgMAAg1BFBEAgBkEBaiEGDAELIAtCP4ghAyAEQgGGIAJCP4iEIQQgAkIBhiABQj+IhCECIAtCAYYhCyADIAFCAYaEIQELIAZB//8BTgRAIApCgICAgICAwP//AIQhCkIAIQEMAQsCfiAGQQBMBEBBASAGayIHQf8ATQRAIAVBMGogCyABIAZB/wBqIgYQZyAFQSBqIAIgBCAGEGcgBUEQaiALIAEgBxCOAiAFIAIgBCAHEI4CIAUpAzAgBSkDOIRCAFKtIAUpAyAgBSkDEISEIQsgBSkDKCAFKQMYhCEBIAUpAwAhAiAFKQMIDAILQgAhAQwCCyAEQv///////z+DIAatQjCGhAsgCoQhCiALUCABQgBZIAFCgICAgICAgICAf1EbRQRAIAogAkIBfCIBUK18IQoMAQsgCyABQoCAgICAgICAgH+FhFBFBEAgAiEBDAELIAogAiACQgGDfCIBIAJUrXwhCgsgACABNwMAIAAgCjcDCCAFQeAAaiQACyEAIAAgASACQoCAgIAwIAMgBEECENgBIQIgACABEA8gAgumAQEEfyAAQQA2AgQgAVAEQCAAQYCAgIB4NgIIIABBABBBGkEADwsCQCABQv////8PWARAIABBARBBDQEgACgCECABIAGnZyICrYY+AgAg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IAMQ2QEMAgtBACEEIAItAAUiBUEEcUUNACAFQQhxBEAgA0EATg0BIANB/////wdxIgMgAigCKCIFSSEEIAFFIAMgBU9yDQEgAUKAgICAMDcDGCABQoCAgIAwNwMQIAFBBzYCACABIAAgAq1CgICAgHCEIAMQsAE3AwgMAwsgACgCECgCRCACLwEGQRhsaigCFCIFRQ0AIAUoAgAiBUUNACAAIAEgAq1CgICAgHCEIAMgBREXACEECyAEDwtBfw8LQQELoQQBAn8CQAJAIAFCgICAgHBUIAJC/////w9Wcg0AIAKnIgQgAaciAygCKE8NAAJAAkACQAJAAkACQAJAAkACQAJAAkAgAy8BBkECaw4eAAsLCwsLAAsLCwsLCwsLCwsLCwIBAgMEBQYHCAkKCwsgAygCJCAEQQN0aikDACIBQiCIp0F1SQ0LIAGnIgAgACgCAEEBajYCACABDwsgAygCJCAEajAAAEL/////D4MPCyADKAIkIARqMQAADwsgAygCJCAEQQF0ajIBAEL/////D4MPCyADKAIkIARBAXRqMwEADwsgAygCJCAEQQJ0ajUCAA8LIAMoAiQgBEECdGooAgAiAEEATgRAIACtDwtCgICAgMB+IAC4vSIBQoCAgIDAgYD8/wB9IAFC////////////AINCgICAgICAgPj/AFYbDwsgACADKAIkIARBA3RqKQMAEIcCDwsgACADKAIkIARBA3RqKQMAEPsDDwtCgICAgMB+IAMoAiQgBEECdGoqAgC7vSIBQoCAgIDAgYD8/wB9IAFC////////////AINCgICAgICAgPj/AFYbDwtCgICAgMB+IAMoAiQgBEEDdGopAwAiAUKAgICAwIGA/P8AfSABQv///////////wCDQoCAgICAgID4/wBWGw8LIAAgAhAxIQMgACACEA8gA0UEQEKAgICA4AAPCyAAIAEgAyABQQAQFCEBIAAgAxATCyABCyoBAX8jAEEQayIEJAAgBCADNgIMIAAgASACIAMQywIhACAEQRBqJAAgAAuMAQECfyABKAJ8IgRBgIAETgRAIABBjTpBABBGQX8PC0F/IQMgACABQfQAakEQIAFB+ABqIARBAWoQeAR/QX8FIAEgASgCfCIDQQFqNgJ8IAEoAnQgA0EEdGoiA0IANwIAIANCADcCCCADIAAgAhAYNgIA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AwsNACAAIAEgARA/EJMCC20BAX8jAEGAAmsiBSQAIARBgMAEcSACIANMckUEQCAFIAFB/wFxIAIgA2siA0GAAiADQYACSSIBGxArGiABRQRAA0AgACAFQYACEFsgA0GAAmsiA0H/AUsNAAsLIAAgBSADEFsLIAVBgAJqJAALDAAgAEGAAmogARARC74BAgF+AX8CQAJAIAFCgICAgHCDQoCAgIAwUQRAIAAoAiggAkEDdGopAwAiA0IgiKdBdEsNAQwCCyAAIAFBOyABQQAQFCIDQoCAgIBwg0KAgICA4ABRBEAgAw8LIANC/////29WDQEgACADEA8gACABEIADIgRFBEBCgICAgOAADwsgBCgCKCACQQN0aikDACIDQiCIp0F1SQ0BCyADpyIEIAQoAgBBAWo2AgALIAAgAyACEEkhASAAIAMQDyABC3UBAX4gACABIAR+IAIgA358IANCIIgiAiABQiCIIgR+fCADQv////8PgyIDIAFC/////w+DIgF+IgVCIIggAyAEfnwiA0IgiHwgASACfiADQv////8Pg3wiAUIgiHw3AwggACAFQv////8PgyABQiCGhDcDAAtQAQF+AkAgA0HAAHEEQCABIANBQGqthiECQgAhAQwBCyADRQ0AIAIgA60iBIYgAUHAACADa62IhCECIAEgBIYhAQsgACABNwMAIAAgAjcDCAtVAQN/IAEgAkEFdSIESwRAIAAgBEECdGooAgAhAwsgAkEfcSICBH8gASAEQQFqIgRLBH8gACAEQQJ0aigCAAVBAAtBAXQgAkEfc3QgAyACdnIFIAMLC2QAAkACQCABQQBIDQAgACgCrAIgAUwNACAAKAKkAiABQRRsaiIAIAAoAgAgAmoiADYCACAAQQBIDQEgAA8LQYUpQa78AEHIqAFBlNUAEAAAC0GmjgFBrvwAQcuoAUGU1QAQAAALYAAgACABIAJCgICAgAh8Qv////8PWAR+IAJC/////w+DBUKAgICAwH4gArm9IgJCgICAgMCBgPz/AH0gAkL///////////8Ag0KAgICAgICA+P8AVhsLIANBh4ABEL0BCwwAIABBhvsAQQAQFQsLACAAIAFBARDBBQvSEAIMfwF+IwBBEGsiCiQAAkACQCABQv////9vWARAIAAQJAwBCyAGQYAwcSIORSAGIAZBCHYiEHEgEEF/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A6ciAiACKAIAQQFqNgIACyAAIAkgAyAGEMsFIQILIAZBggRxQYAERgRAIAogCSgCECIGQTBqNgIMQX8hByAAIAkgCkEMaiAGKAIwQRp2QT1xEJEDDQULIAIhBwwECyAMBEAgACAIKQMAEA8gA0IgiKdBdU8EQCADpyICIAIoAgBBAWo2AgALIAggAzcDAAsgBkGABHFFDQBBfyEHIAAgCSAKQQxqIAooAgwoAgBBGnZBPXEgBkECcXIQkQMNAwtBf0EBIAAgCSAKQQxqIBBBBXEiAEF/cyAKKAIMKAIAQRp2cSAAIAZxchCRAxshBwwCCyAAIAZB4ekAEG8hBwwBC0F/IQcLIApBEGokACAHC/8BAgJ/AXwjAEEQayIEJAACQCACQiCIpyIDQQJNBEAgASACp7c5AwBBACEADAELIANBB2tBbU0EQCABIAJCgICAgMCBgPz/AHw3AwBBACEADAELAn8gACACEI0BIgJCgICAgHCDQoCAgIDgAFEEQEQAAAAAAAD4fyEFQX8MAQsCfAJAAkBBByACQiCIpyIDIANBB2tBbkkbIgNBCmpBAk8EQCADQQdGDQIgAw0BIAKntwwDCyACp0EEaiAEQQhqELUFIAAgAhAPIAQrAwghBUEADAMLEAEACyACQoCAgIDAgYD8/wB8vwshBUEACyEAIAEgBTkDAAsgBEEQaiQAIAALXQECfyMAQRBrIgMkAAJAIAFBgIABcUUEQCABQYCAAnFFDQEgACgCECgCjAEiAUUNASABLQAoQQFxRQ0BCyADQQA2AgwgAEEEIAJBABCSBEF/IQQLIANBEGokACAEC8YJAgR/BX4jAEHwAGsiBiQAIARC////////////AIMhCQJAAkAgAVAiBSACQv///////////wCDIgpCgICAgICAwP//AH1CgICAgICAwICAf1QgClAbRQRAIANCAFIgCUKAgICAgIDA//8AfSILQoCAgICAgMCAgH9WIAtCgICAgICAwICAf1EbDQELIAUgCkKAgICAgIDA//8AVCAKQoCAgICAgMD//wBRG0UEQCACQoCAgICAgCCEIQQgASEDDAILIANQIAlCgICAgICAwP//AFQgCUKAgICAgIDA//8AURtFBEAgBEKAgICAgIAghCEEDAILIAEgCkKAgICAgIDA//8AhYRQBEBCgICAgICA4P//ACAC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IAAgAaciAkEAIAIoAgRB/////wdxEFEhAiAAKAIAIAEQDyACC7UCAQd/IwBBEGsiBSQAAkAgAEFAaygCACIBRQRADAELAkAgAQJ/IAEoAsgBIgQgASgCxAEiAkgEQCABKALMASEDIAQMAQsgBEEBaiIDIAJBA2xBAm0iAiACIANIGyIGQQN0IQIgACgCACEDAkAgASgCzAEiByABQdABakYEQCADQQAgAiAFQQxqEKgBIgNFDQMgAyABKALMASABKALIAUEDdBAfGgwBCyADIAcgAiAFQQxqEKgBIgNFDQILIAUoAgwhAiABIAM2AswBIAEgAkEDdiAGajYCxAEgASgCyAELQQFqNgLIASADIARBA3RqIgIgASgCvAE2AgAgAiABKALAATYCBCAAQbQBEBAgAEFAaygCACAEQf//A3EQFyABIAQ2ArwBDAELQX8hBAsgBUEQaiQAIAQLoQECA38BfiMAIQYCQCACQoCAgIBwVA0AIAKnIgUvAQZBMEcNACAFKAIgIQQLAn8gBiAAKAIQKAJ4SQRAIAAQ6QFBAAwBCyAELQARBEAgABC2AkEADAELQQAgACAEKQMIIgIgAyACQQAQFCIHQoCAgIBwgyICQoCAgIDgAFENABogAUKAgICAMCAHIAJCgICAgCBRGzcDACAECyEFIAYkACAFCxYAIAAgASACIAMgBCAFIAApAzAQ8QELKQEBfyMAQRBrIgIkACACIAA2AgwgAkEMaiABEJMEIQAgAkEQaiQAIAALngICA38BfiACIAEpAgQiB6dB/////wdxIANHckUEQCABIAEoAgBBAWo2AgAgAa1CgICAgJB/hA8LIAFBEGohBSAHQoCAgIAIg1AgAyACayIEQQBMckUEQCADIAIgAiADSBshBkEAIQMgAiEBA0AgASAGRkUEQCAFIAFBAXRqLwEAIANyIQMgAUEBaiEBDAELCyADQf//A3FBgAJPBEAgACAFIAJBAXRqIAQQ7gMPC0EAIQEgACAEQQAQ6gEiAEUEQEKAgICA4AAPCyAAQRBqIQMDQCABIARGRQRAIAEgA2ogBSABIAJqQQF0ai0AADoAACABQQFqIQEMAQsLIAMgBGpBADoAACAArUKAgICAkH+EDwsgACACIAVqIAQQhAMLugEBAn8CQAJAIAJC/////wdYBEAgACABIAKnQYCAgIB4chBx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IANBCGogAhDiA0UEQEEAIQQgASADKQMIIgJCgICAgICAgBBaBH4gAEGAIEEAEFBBfyEEQgAFIAILNwMACyADQRBqJAAgBAsRACAAIAEgASACIANBAhCKBAtTAQF/IAAoAhAiBEEQaiABIAIgBCgCCBEBACIBIAJFckUEQCAAEHwgAQ8LIAMEQCADIAEgACgCECgCDBEEACIAIAJrIgJBACAAIAJPGzYCAAsgAQvAAQAgAAJ/IAEoAggiAEH+////B04EQEEAIAJBAXENARpB/////wcgAEH+////B0cNARogASgCBEH/////B2oMAQtBACAAQQBMDQAaIABBH00EQEEAIAEoAhAgASgCDEECdGpBBGsoAgBBICAAa3YiAmsgAiABKAIEGwwBCyACQQFxRQRAQYCAgIB4Qf////8HIAEoAgQbDAELQQAgASgCECABKAIMIgIgAkEFdCAAaxBoIgJrIAIgASgCBBsLNgIACw0AIAAgASABED8QhQML+QECA34CfyMAQRBrIgUkAAJ+IAG9IgNC////////////AIMiAkKAgICAgICACH1C/////////+//AFgEQCACQjyGIQQgAkIEiEKAgICAgICAgDx8DAELIAJCgICAgICAgPj/AFoEQCADQjyGIQQgA0IEiEKAgICAgIDA//8AhAwBCyACUARAQgAMAQsgBSACQgAgA6dnQSBqIAJCIIinZyACQoCAgIAQVBsiBkExahBnIAUpAwAhBCAFKQMIQoCAgICAgMAAhUGM+AAgBmutQjCGhAshAiAAIAQ3AwAgACACIANCgICAgICAgICAf4OENwMIIAVBEGokAAu2AQEBfyMAQRBrIgMkAAJAAkAgAkEASARAIAEgAkH/////B3E2AgBBASECDAELIAAoAhAiACgCLCACTQ0BAn8CQCAAKAI4IAJBAnRqKAIAIgApAgRCgICAgICAgIBAg0KAgICAgICAgMAAUg0AIANBDGogABC9BUUNAEEBIAMoAgwiAEF/Rw0BGgtBACEAQQALIQIgASAANgIACyADQRBqJAAgAg8LQe/fAEGu/ABBvxhBryAQAAAL1QECAn8DfgJ/IAJFBEBCgICAgDAhBUEADAELIAAoAhAiAykDgAEhBSADQoCAgIAgNwOAAUF/CyEDAkAgACABQQYgAUEAEBQiB0KAgICAcIMiBkKA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BUEgahBGQX8MAQsCQCABKAIEIARODQAgASAENgIEIARB//8DSA0AIAUgAjYCBCAFIAM2AgAgAEGjkwEgBRBGQX8MAQsgASgCCCACQQF0aiIDLwEAIgZB//8DRwRAQQAgBCAGRg0BGiAFIAI2AhggBSAENgIUIAUgBjYCECAAQdSSASAFQRBqEEZBfwwBCyADIAQ7AQBBfyAAIAFBDGpBBCABQRRqIAEoAhBBAWoQeA0AGiABIAEoAhAiAEEBajYCECABKAIMIABBAnRqIAI2AgBBAAshAyAFQTBqJAAgAwsTACAAIAEgAiADIARBAEEAEPgBCzkAIABB/wBNBEAgAEEDdkH8////AXFBoIECaigCACAAdkEBcQ8LIABBfnFBjMAARiAAENIEQQBHcgtmAQF/An9BACAAKAIIIgIgAU8NABpBfyAAKAIMDQAaIAAoAhQgACgCACACQQNsQQF2IgIgASABIAJJGyIBIAAoAhARAQAiAkUEQCAAQQE2AgxBfw8LIAAgATYCCCAAIAI2AgBBAAsLrAECAX8BfiAAKQIEIgSnQf////8HcSEDAkACQCAEQoCAgIAIg1BFBEAgAiADIAIgA0obIQMgAEEQaiEAA0AgAiADRg0CIAAgAkEBdGovAQAgAUYNAyACQQFqIQIMAAsACyABQf8BSw0AIAIgAyACIANKGyEDIABBEGohACABQf8BcSEBA0AgAiADRg0BIAAgAmotAAAgAUYNAiACQQFqIQIMAAsAC0F/IQILIAILpgEBAX8jAEEQayIDJAAgAyACNwMIAkAgACABQYYBIAFBABAUIgJCgICAgHCDQoCAgIDgAFENACAAIAIQOARAIAAgAiABQQEgA0EIahAvIgJC/////29WIAJCgICAgLB/g0KAgICAIFFyDQEgACACEA8gAEGK0wBBABAVQoCAgIDgACECDAELIAAgAhAPIAAgASADIANBCGoQ8QQhAgsgA0EQaiQAIAILowECA38BfiAAQRBqIQIgASgCACIEQQFqIQMCQCAAKQIEIgVCgICAgAiDUEUEQCACIARBAXRqLwEAIgBBgPgDcUGAsANHIAMgBadB/////wdxTnINASACIANBAXRqLwEAIgJBgPgDcUGAuANHDQEgAEEKdEGA+D9xIAJB/wdxckGAgARqIQAgBEECaiEDDAELIAIgBGotAAAh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OCAaKAIkIRQgCCAVQQ9qQfD//wFxayIXJAAgBSEVIAYEQCAHIAQgByAEIAdIGyIIQQAgCEEAShsiCGsiFUEAIAcgFU8bIREDQAJAIAggCUYEQANAIAggEUYNAiAXIAhBA3RqQoCAgIAwNwMAIAhBAWohCAwACwALIAUgCUEDdCIVaikDACIBQiCIp0F1TwRAIAGnIgogCigCAEEBajYCAAsgFSAXaiABNwMAIBFBAWohESAJQQFqIQkMAQsLIA4gBzYCVCAXIRULIA4gFTYCQCAOIBcgBkEDdGoiETYCREEAIQgDQCAIIAtHBEAgESAIQQN0akKAgICAMDcDACAIQQFqIQgMAQsLIBMoAhQhCiAOIBYoAowBNgIwIBYgDkEwaiISNgKMASATKAIwIQYgESALQQN0aiIIIRwLQQAMAQtBAQshBwNAAkACQAJAAkAgB0UEQCAEQQN0IScgA0KAgICAcIMhMyARQQhqIR0gEUEQaiEeIBFBGGohHyAVQQhqISAgFUEQaiEhIBVBGGohIiASQRhqISggBkHIAWohGyAcQRhqISkgBkHAAWohGSACQiCIpyIkQX5xISogA0IgiKchKyAErSEyIAOnISUgDkEwaiEsIA5B6ABqISYgCCEHAkADQAJAIApBAWohDUIBIS5CgICAgDAhAQJ/AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAC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ajYCAAsgCCABNwMIIAhBCGspAwAiAUIgiKdBdU8EQCABpyIHIAcoAgBBAWo2AgALIAggATcDECAIQRhqIQcM2wELIAggCEEIayIHKQMANwMAIAhBEGspAwAiAUIgiKdBdU8EQCABpyIKIAooAgBBAWo2AgALIAcgATcDACAIQQhqIQcM2gELIAggCEEIayIHKQMAIgE3AwAgByAIQRBrIgcpAwA3AwAgAUIgiKdBdU8EQCABpyIKIAooAgBBAWo2AgALIAcgATcDACAIQQhqIQcM2QELIAggCEEIayIHKQMAIgE3AwAgCEEQayIKKQMAIS0gCiAIQRhrIgopAwA3AwAgByAtNwMAIAFCIIinQXVPBEAgAaciByAHKAIAQQFqNgIACyAKIAE3AwAgCEEIaiEHDNgBCyAIIAhBCGsiBykDACIBNwMAIAhBEGsiCikDACEtIAogCEEYayIKKQMANwMAIAcgLTcDACAKIAhBIGsiBykDADcDACABQiCIp0F1TwRAIAGnIgogCigCAEEBajYCAAsgByABNwMAIAhBCGohBwzXAQsgCEEQayIHKQMAIQEgByAIQRhrIgcpAwA3AwAgByABNwMADNABCyAIQRhrIgcpAwAhASAHIAhBEGsiBykDADcDACAIQQhrIgopAwAhLSAKIAE3AwAgByAtNwMADM8BCyAIQSBrIgcpAwAhASAHIAhBGGsiBykDADcDACAIQRBrIgopAwAhLSAKIAhBCGsiCikDADcDACAHIC03AwAgCiABNwMADM4BCyAIQShrIgcpAwAhASAHIAhBIGsiBykDADcDACAIQRhrIgopAwAhLSAKIAhBEGsiCikDADcDACAHIC03AwAgCiAIQQhrIgcpAwA3AwAgByABNwMADM0BCyAIQQhrIgcpAwAhASAHIAhBEGsiBykDADcDACAIQRhrIgopAwAhLSAKIAE3AwAgByAtNwMADMwBCyAIQRBrIgcpAwAhASAHIAhBGGsiBykDADcDACAIQSBrIgopAwAhLSAKIAE3AwAgByAtNwMADMsBCyAIQRBrIgcpAwAhASAHIAhBGGsiBykDADcDACAIQSBrIgopAwAhLSAKIAhBKGsiCikDADcDACAHIC03AwAgCiABNwMADMoBCyAIQQhrIgcpAwAhASAHIAhBEGsiBykDADcDACAHIAE3AwAMyQEL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ayIHKQMAIgFC/////z9YBEAgAacMAQsgBiABECYLBH8gCQUgDSgAACAJakEEawshDSAGEHtFDXUMJwsgCkECaiEJAn8gCEEIayIHKQMAIgFC/////z9YBEAgAacMAQsgBiABECYLBH8gDSwAACAJakEBawUgCQshDSAGEHtFDXQMJgsgCkECaiEJAn8gCEEIayIHKQMAIgFC/////z9YBEAgAacMAQsgBiABECYLBH8gCQUgDSwAACAJakEBawshDSAGEHtFDXMMJQsgCCANIAooAAFqIBMoAhRrrUKAgICA0ACENwMAIApBBWohDSAIQQhqIQcMcgsgCigAASEHIAggCiATKAIUa0EFaq03AwAgByANaiENIAhBCGohBwxxCwJAIAhBCGsiBykDACIBQv////8PVg0AIAGnIgkgEygCGE8NACATKAIUIAlqIQ0McQsgBkH14QBBABBGDHQLIAhBCGsiDykDACItQiCIpyIHQQFqIglBBE1BAEEBIAl0QRlxG0UEQCAGIC0Q3AUhLQsCQCAGQRgQKSIJBEAgBkKAgICAIEEREEkiLkKAgICAcINCgICAgOAAUg0BIAYoAhAiB0EQaiAJIAcoAgQRAAALIC0hLgxlCyAJQQA2AhAgCSAtNwMAIAlBADYCCCAupyAJNgIgIAdBfnFBAkYNZSAtIgFCIIinIgdBdU8EQCAtpyILIAsoAgBBAWo2AgALA0AgBiABEIwCIgFCgICAgHCDIi9CgICAgCBSBEAgL0KAgICA4ABRDWYgBiAOQeAAaiAOQYABaiABp0EREI4BDWUgBiAOKAJgIA4oAoABIgsQWiALBEAgBiABEA8gB0F1SQ1lIC2nIgcgBygCAEEBajYCAAxlCyAGEHtFDQEMZQsLAkACQCAtpyIMLQAFQQhxRQ0AQQAhByAMKAIQIgsoAiAiEEEAIBBBAEobIRAgC0EwaiELA0AgByAQRg0CIAstAANBEHENASALQQhqIQsgB0EBaiEHDAALAAsgBiAOQeAAaiAOQYABaiAMQREQjgENZUEAIQcgDigCYCEKIA4oAoABIQkDQCAHIAlHBEAgBiAuIAogB0EDdGooAgRCgICAgCBBABDQARogB0EBaiEHDAELCyAGIAogCRBaDGYLIAlBATYCCCAJIAwoAig2AgwMZQtCgYCAgBAhLgJAIAhBCGspAwAi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/wB8v6G9IgFCgICAgMCBgPz/AH0gAUL///////////8Ag0KAgICAgICA+P8AVhs3AwAMSAsCfCAIQQhrIgcpAwAiLUIgiKciDCAIQRBrIgspAwAiLkIgiKciD3JFBEAgLcQgLsR+IgFCgICAgAh8QoCAgIAQWgRAIBItAChBBHFBACABQoCAgICAgIAQfUKBgICAgICAYFQbDQUgAbkMAgtEAAAAAAAAAIAgLSAuhEKAgICACINQIAFCAFJyRQ0BGiALIAFC/////w+DNwMADEkLIA9BB2tBbUsgDEEHa0FtS3INAyASLQAoQQRxDQMgLkKAgICAwIGA/P8AfL8gLUKAgICAwIGA/P8AfL+iCyE0IAtCgICAgMB+IDS9IgFCgICAgMCBgPz/AH0gAUL///////////8Ag0KAgICAgICA+P8AVhs3AwAMRwsgCEEIayIHKQMAIgEgCEEQayILKQMAIi2EQv////8PVg0BIBItAChBBHENASALAn4gLae3IAGnt6MiNL0iAQJ/IDSZRAAAAAAAAOBBYwRAIDSqDAELQYCAgIB4CyIIt71RBEAgCK0MAQtCgICAgMB+IAFCgICAgMCBgPz/AH0gAUL///////////8Ag0KAgICAgICA+P8AVhsLNwMADEYLIAhBCGsiBykDACIBIAhBEGsiCykDACIthEL/////D1YNACAtpyIMQQBIDQAgAaciD0EATA0AIAsgDCAPcK03AwAMRQsjAEEgayIHJAACfwJAAkACQAJAAn4CQAJAAkACQAJAAkACQEEHIAhBEGsiCykDACIBQiCIpyIMIAxBB2tBbkkbIgxBB0dBByAIQQhrIiMpAwAiLkIgiKciDyAPQQdrQW5JGyIPQQdHckUEQCAHIC5CgICAgMCBgPz/AHw3AwggByABQoCAgIDAgYD8/wB8NwMQDAELAkAgDEF/RiAPQX5xQQJHcUUgDEF+cUECRiAPQX9HcnENACAGIAdBGGogASAuIAlBAUEAEIUCIgxFDQAgBiABEA8gBiAuEA8gDEEASA0MIAsgBykDGDcDAAwJCyAGIAEQbCIBQoCAgIBwg0KAgICA4ABRDQogBiAuEGwiLkKAgICAcINCgICAgOAAUQRAIAYgARAPDAwLQQcgAUIgiKciDCAMQQdrQW5JGyIMQQcgLkIgiKciDyAPQQdrQW5JGyIPckUEQCAupyEMIAGnIQ8CQAJAAkACQAJAAkAgCUGaAWsOBgABAgkFAwQLIC7EIAHEfiEtAkAgBigCECIQKAKMASIYRQ0AIBgtAChBBHFFDQAgLUKAgICAgICAEH1CgYCAgICAgGBUDQgLQgAhASAtQgBSDQogDCAPckEATg0LIAtCgICAgMD+/wM3AwAMDgsgBigCECIQKAKMASIYBEAgGC0AKEEEcQ0HCyALQoCAgIDAfiAPtyAMt6O9IgFCgICAgMCBgPz/AH0gAUL///////////8Ag0KAgICAgICA+P8AVhs3AwAMDQsgDEEASiAPQQBOcUUEQCALAn4gD7cgDLcQjgMiNL0iAQJ/IDSZRAAAAAAAAOBBYwRAIDSqDAELQYCAgIB4CyIJt71RBEAgCa0MAQtCgICAgMB+IAFCgICAgMCBgPz/AH0gAUL///////////8Ag0KAgICAgICA+P8AVhsLNwMADA0LIA8gDHCtIS0MCAsgBigCECIQKAKMASIYBEAgGC0AKEEEcQ0FCyAPtyE0IAsCfgJ8IAy3IjW9QoCAgICAgID4/wCDQoCAgICAgID4/wBRBEBEAAAAAAAA+H8gNJlEAAAAAAAA8D9hDQEaCyA0IDUQjwMLIjS9IgECfyA0mUQAAAAAAADgQWMEQCA0qgwBC0GAgICAeAsiCbe9UQRAIAmtDAELQoCAgIDAfiABQoCAgIDAgYD8/wB9IAFC////////////AINCgICAgICAgPj/AFYbCzcDAAwLCyAJQbIBRg0FDAQLIAHEIC7EfSEtDAULIAxBdUcgD0F1R3FFBEAgBiAJIAsgASAuIAYoAhAoAtgCERoADQwMCQsgDEF3RyAPQXdHcUUEQCAGIAkgCyABIC4gBigCECgCvAIRGgBFDQkMDAsgDEF2RyAPQXZHcUUEQCAGKAIQIRAMAgsgBiAHQRBqIAEQbg0KIAYgB0EIaiAuEG4NCwsCQCAGKAIQIhAoAowBIgxFDQAgDC0AKEEEcUUNACAHKwMQEL0CRQ0AIAcrAwgQvQINAQsCQAJAAkACQAJAAkACQCAJQZoBaw4GAAECCAUEAwsgBysDECAHKwMIoiE0DAULIAcrAxAgBysDCKMhNAwECyAHKwMQIAcrAwgQjgMhNAwDCyAJQbIBRw0EIAcrAxAgBysDCJkiNRCOAyI0RAAAAAAAAAAAY0UNAiA1IDSgITQMAgsgBysDECE1IAcrAwgiNr1CgICAgICAgPj/AINCgICAgICAgPj/AFEEQEQAAAAAAAD4fyE0IDWZRAAAAAAAAPA/YQ0CCyA1IDYQjwMhNAwBCyAHKwMQIAcrAwihITQLIAtCgICAgMB+IDS9IgFCgICAgMCBgPz/AH0gAUL///////////8Ag0KAgICAgICA+P8AVhs3AwAMBwsgBiAJIAsgASAuIBAoAqACERoARQ0GDAkLEAEACyAMRQ0FIAHEIC7EIgGBIi1CAFkNACAMQQBIBEAgLSABfSEtDAELIAEgLXwhLQsgLUKAgICACHxC/////w9WDQEgLSEBCyABQv////8PgwwBC0KAgICAwH4gLbm9IgFCgICAgMCBgPz/AH0gAUL///////////8Ag0KAgICAgICA+P8AVhsLIQEgCyABNwMAC0EADAMLIAZBAhCEAgwBCyAGIC4QDwsgC0KAgICAMDcDACAjQoCAgIAwNwMAQX8LIQkgB0EgaiQAIAkNSCAIQQhrIQcMRAsgCEEEaygCACIHRSAHQQdrQW5Jcg09IAghByAGIAhBjQEQ5gFFDUMMRwsCQAJ8IAhBCGsiBykDACIBQiCIpyIJRQRARAAAAAAAAACAIAGnIgpFDQEaRAAAAAAAAOBBIApBgICAgHhGDQEaIAdCACABfUL/////D4M3AwAMPwsgCUEHa0FtSw0BIAFCgICAgMD+/wN9vwshNCAHQoCAgIDAfiA0vSIBQoCAgIDAgYD8/wB9IAFC////////////AINCgICAgICAgPj/AFYbNwMADD0LIAghByAGIAhBjAEQ5gFFDUIMRgsgCEEIayIHKQMAIgFC/////w9WIAFC/////w+DQv////8HUXJFBEAgByABQgF8Qv////8PgzcDAAw8CyAIIQcgBiAIQY8BEOYBRQ1BDEULIAhBCGsiBykDACIBQv////8PViABQv////8Pg0KAgICACFFyRQRAIAcgAUIBfUL/////D4M3AwAMOwsgCCEHIAYgCEGOARDmAUUNQAxECyAGIAhBCGsiBykDABBsIgFCgICAgHCDQoCAgIDgAFEEQCAHQoCAgIAwNwMADEQLIAcgATcDACABQiCIp0F1TwRAIAGnIgcgBygCAEEBajYCAAsgCCABNwMAIAYgCEEIaiIHIAlBAmsQ5gFFDT8MQwsgCkECaiENIBEgCi0AAUEDdGoiBykDACIBQv////8PViABQv////8Pg0L/////B1FyRQRAIAcgAUIBfEL/////D4M3AwAMOQsgAUIgiKdBdU8EQCABpyIJIAkoAgBBAWo2AgALIA4gATcDYCAGICZBjwEQ5gENQiAGIAcgDikDYBAgDDgLIApBAmohDSARIAotAAFBA3RqIgcpAwAiAUL/////D1YgAUL/////D4NCgICAgAhRckUEQCAHIAFCAX1C/////w+DNwMADDgLIAFCIIinQXVPBEAgAaciCSAJKAIAQQFqNgIACyAOIAE3A2AgBiAmQY4BEOYBDUEgBiAHIA4pA2AQIAw3CyAIQQhrIgcpAwAiAUL/////D1gEQCAHIAFC/////w+FNwMADDcLIAghByMAQRBrIgkkAAJ/AkACQAJAIAhBCGsiCykDACIBQoCAgIBwVA0AIAYgCUEIaiABQZUBEMIFIgxBAEgNASAMRQ0AIAYgARAPIAsgCSkDCDcDAAwCCwJAIAYgARBsIgFCgICAgHCDIi1CgICAgOAAUQ0AIAYoAhAiDCgCjAEiDwR/IA8tAChBBHFBAnYFQQALRSAtQoCAgIDgflJxRQRAIAYgC0GVASABIAwoApwCERsADQEMAwsgBiAJQQRqIAEQmAENACALIAk1AgRC/////w+FNwMADAILIAtCgICAgDA3AwALQX8MAQtBAAshCyAJQRBqJAAgC0UNPAxACwJAAkACQCAIQQhrIgcpAwAiASAIQRBrIgspAwAiLYRC/////w9WDQAgAachCSASLQAoQQRxRQ0BIAlBH0sNACAtIAGGQoCAgIAIfEKAgICAEFQNAgsgBiAIQaABEMMCRQ09DEELIAlBH3EhCQsgCyAtpyAJdK03AwAMOwsgCEEIayIHKQMAIgEgCEEQayIJKQMAIi2EQv////8PWARAIAkCfiAtpyABp3YiCEEATgRAIAitDAELQoCAgIDAfiAIuL0iAUKAgICAwIGA/P8AfSABQv///////////wCDQoCAgICAgID4/wBWGws3AwAMOwsjAEEQayIJJAAgCEEIayIMKQMAIS0CfwJAAkAgBiAIQRBrIgspAwAQbCIBQoCAgIBwgyIuQoCAgIDgAFEEQCAGIC0QDwwBCyAGIC0QbCItQoCAgIBwgyIvQoCAgIDgAFEEQCAGIAEQDwwBCyAGKAIQKAKMASIPBEAgDy0AKEEEcQ0CCyAuQoCAgIDgflIgL0KAgICA4H5ScQ0BIAZB+ogBQQAQFSAGIAEQDyAGIC0QDwsgC0KAgICAMDcDACAMQoCAgIAwNwMAQX8MAQsgBiAJQQxqIAEQmAEaIAYgCUEIaiAtEJgBGiALAn4gCSgCDCAJKAIIdiILQQBOBEAgC60MAQtCgICAgMB+IAu4vSIBQoCAgIDAgYD8/wB9IAFC////////////AINCgICAgICAgPj/AFYbCzcDAEEACyELIAlBEGokACALRQ06DD4LAkAgCEEIayIHKQMAIgEgCEEQayIJKQMAIi2EQv////8PVg0AIAkgLacgAaciCUEgTwR/IBItAChBBHENASAJQR9xBSAJC3WtNwMADDoLIAYgCEGhARDDAkUNOQw9CyAIQQhrIgcpAwAiASAIQRBrIgkpAwAiLYRC/////w9YBEAgCSABIC2DNwMADDkLIAYgCEGtARDDAkUNOAw8CyAIQQhrIgcpAwAgCEEQayIJKQMAhCIBQv////8PWARAIAkgATcDAAw4CyAGIAhBrwEQwwJFDTcMOwsgCEEIayIHKQMAIgEgCEEQayIJKQMAIi2EQv////8PWARAIAkgASAthTcDAAw3CyAGIAhBrgEQwwJFDTYMOgsgCEEIayIHKQMAIgEgCEEQayIJKQMAIi2EQv////8PWARAIAkgLacgAadIrUKAgICAEIQ3AwAMNgsgBiAIQaMBEJcDRQ01DDkLIAhBCGsiBykDACIBIAhBEGsiCSkDACIthEL/////D1gEQCAJIC2nIAGnTK1CgICAgBCENwMADDULIAYgCEGkARCXA0UNNAw4CyAIQQhrIgcpAwAiASAIQRBrIgkpAwAiLYRC/////w9YBEAgCSAtpyABp0qtQoCAgIAQhDcDAAw0CyAGIAhBpQEQlwNFDTMMNwsgCEEIayIHKQMAIgEgCEEQayIJKQMAIi2EQv////8PWARAIAkgLacgAadOrUKAgICAEIQ3AwAMMwsgBiAIQaYBEJcDRQ0yDDYLIAhBCGsiBykDACIBIAhBEGsiCSkDACIthEL/////D1gEQCAJIC2nIAGnRq1CgICAgBCENwMADDILIAYgCEEAENIFRQ0xDDULIAhBCGsiBykDACIBIAhBEGsiCSkDACIthEL/////D1gEQCAJIC2nIAGnR61CgICAgBCENwMADDELIAYgCEEBENIFRQ0wDDQLIAhBCGsiBykDACIBIAhBEGsiCikDACIthEL/////D1gEQCAKIC2nIAGnRq1CgICAgBCENwMADDALIAYgCEEAENEFDC8LIAhBCGsiBykDACIBIAhBEGsiCikDACIthEL/////D1gEQCAKIC2nIAGnR61CgICAgBCENwMADC8LIAYgCEEBENEFDC4LIAYgCCAWKALIAhEDAA0xIAhBCGshBwwtCyAIQQhrIgcpAwAiAUL/////b1gEQCAGQaH0AEEAEBUMMQsgBiAIQRBrIgwpAwAiLRAxIglFDTAgBiABIAkQcSELIAYgCRATIAtBAEgNMCAGIC0QDyAGIAEQDyAMIAtBAEetQoCAgIAQhDcDAAwsCyAGIAhBEGsiCSkDACIBIAhBCGsiBykDACItENAFIgtBAEgNLyAGIAEQDyAGIC0QDyAJIAtBAEetQoCAgIAQhDcDAAwrCyAGIAhBCGsiBykDACIBEIQEIQogBiABEA8gByAGIAoQLTcDAAwkCyAIQRBrIgwpAwAhASAGIAhBCGsiBykDACItEDEiCUUNLSAGIAEgCUGAgAIQ1QEhCyAGIAkQEyALQQBIDS0gBiABEA8gBiAtEA8gDCALQQBHrUKAgICAEIQ3AwAMKQsgCkEFaiENIAYgBikDwAEgCigAAUEAENUBIgdBAEgNLCAIIAdBAEetQoCAgIAQhDcDACAIQQhqIQcMKAsgCEEIayIHKQMAIgFC/////29WDSEgBiABECUiAUKAgICAcINCgICAgOAAUQ0rIAYgBykDABAPIAcgATcDAAwhCyAIQQhrIgcpAwAiAUIgiKdBCGoiCUEITUEAQQEgCXRBgwJxGw0gIAYgARCDBCIBQoCAgIBwg0KAgICA4ABRDSogBiAHKQMAEA8gByABNwMADCALIAhBEGspAwBCgICAgBCEQoCAgIBwg0KAgICAMFEEQCAGQZYbQQAQFQwqCyAIQQhrIgcpAwAiAUIgiKdBCGoiCUEITUEAQQEgCXRBgwJxGw0fIAYgARCDBCIBQoCAgIBwg0KAgICA4ABRDSkgBiAHKQMAEA8gByABNwMADB8LIApBCmohDSAKLQAJIQsgCigABSEPIAYgCEEIayIHKQMAIgEgCigAASIMEHEiEEEASA0oAkAgEEUNACALBEBBACELIAYgAUHbASABQQAQFCItQoCAgIBwg0KAgICA4ABRDSogLUKAgICAcFoEQCAGIAYgLSAMIC1BABAUECYhCwsgBiAtEA8gC0EASA0qIAsNAQsCQAJAAkACQAJAAkACQCAJQfIAaw4GAAECAwQFBgsgBiABIAwgAUEAEBQiAUKAgICAcINCgICAgOAAUQ0vIAYgByABECAMBQsgBiABIAwgCEEQayIIKQMAQYCAAhDQASEJIAYgBykDABAPIAlBAE4NBAwuCyAGIAEgDEEAENUBIglBAEgNLSAGIAcpAwAQDyAHIAlBAEetQoCAgIAQhDcDAAwDCyAIIAYgDBBcNwMAIAhBCGohCAwCCyAGIAEgDCABQQAQFCIBQoCAgIBwg0KAgICA4ABRDSsgCCABNwMAIAhBCGohCAwBCyAGIAEgDCABQQAQFCIBQoCAgIBwg0KAgICA4ABRDSogBiAHKQMAEA8gB0KAgICAMDcDACAIIAE3AwAgCEEIaiEICyANIA9qQQVrIQ0MHwsgBiAHKQMAEA8MJAsgCEEIaykDACIuQoCAgIBwg0KAgICAMFENDQwFCyAIQQhrKQMAIi5CgICAgHCDQoCAgIAgUQ0MDAQLIAYgCEEIaykDACIuEIQEQcUARg0BDAMLIAYgCEEIaykDACIuEIQEQRtHDQILIAYgLhAPDAkLIAhBCGspAwAiLkKAgICAYINCgICAgCBRDQgLIAYgLhAPIAhBCGtCgICAgBA3AwAMFwsgEygCFCEHIA4gCTYCBCAOIAdBf3MgDWo2AgAgBkGIISAOEEYMIAsgCkEDaiENDBULQgIhLgwgC0KAgICAMCEuDB8LQgAhLgweCyAIQQhrIggpAwAhAQweC0HIhAFBrvwAQaj8AEHKNBAAAAsgCEEIa0KBgICAEDcDAAwPCyAGIAFBARCtARogBiABEA8gBiAtEA8MGAsgASEvDAMLQoCAgIAwIS0LIAYgB0EAEBULQoCAgIAwIS4LIAYgMBAPIAYgLRAPIAYgMRAPIAYgLxAPIAYgLhAPIAtCgICAgDA3AwAgDEKAgICAMDcDAAwTCyAGIAspAwAQDyALQoCAgIAwNwMAIAdBAEgNEiAGIC4QD0KAgICAMCEuCyAIIC43AwAgCCAHQQBHrUKAgICAEIQ3AwggCEEQaiEHDA0LIC0hAQNAIAYgDkHgAGogDkGAAWogAadBIRCOAQ0BQQAhByAOKAJgIQkgDigCgAEhCwNAIAcgC0cEQCAGIC4gCSAHQQN0aiIMKAIEQoCAgIAgIAwoAgBBAEdBAnQQGRogB0EBaiEHDAELCyAGIAkgCxBaIAYgARCMAiIBQoCAgIBwgyItQoCAgIAgUQ0DIC1CgICAgOAAUQ0CIAYQe0UNAAsLIAYgARAPCyAGIC4QDyAPQoCAgIDgADcDAAwOCyAPIC43AwAMAwsgDC0ABUEBcQ0BCyAGIAdBhZcBEI8BDAsLIBsoAgAoAhAiCUEwaiELIAkgCSgCGCAHcUF/c0ECdGooAgAhCQNAIAlFDQEgCyAJQQFrQQN0aiIJKAIEIAdGDQIgCSgCAEH///8fcSEJDAALAAsgCCEHDAULIAYgBxDfBQwICyAGECQMBwsgBiABEA8LIAhCgICAgOAANwMAIAhBCGohCAwFCyALIAk2AiQgCyAENgIoIAYpA6gBIi1CIIinQXVPBEAgLaciByAHKAIAQQFqNgIACyAGIAFB0QEgLUEDEBkaIAYgAUHOAEKAgICAMCAGKQOwASItIC1BgDAQbRogCCABNwMAIAhBCGohBwtBAAshCSAHIQggDSEKIAlFDQELCyAHIQgLQQEhBwwFCwJAAkAgFikDgAEiLkKAgICAcFQNACAupyIHLwEGQQNHDQAgBygCECIHQTBqIQogByAHKAIYQX9zQQJ0Qah+cmooAgAhBwJAA0AgBwRAIAogB0EBa0EDdGoiBygCBEE1Rg0CIAcoAgBB////H3EhBwwBCwsgEiANNgIgIAYgLkEAQQBBABDKAiAWKQOAASEuCyAuQoCAgIBwVA0AIC6nIgcvAQZBA0cNACAHLQAFQSBxDQELA0AgHCAIIgdPDQEgBiAHQQhrIggpAwAiARAPIAFCgICAgHCDQoCAgIDQAFINACABpyIKDQUgBiAHQRBrIggpAwAQDyAGIAdBGGspAwBBARCtARoMAAsAC0KAgICA4AAhLkKAgICA4AAhASATLQARQTBxRQ0BCyASIAg2AiwgEiANNgIgDAELIBIoAhwgEkEYakcEQCAWIBIQzwULA34gCCAXTQR+IAEFIAYgFykDABAPIBdBCGohFwwBCwshLgsgFiASKAIANgKMAQwCCyAIIBYpA4ABNwMAIBZCgICAgCA3A4ABIBMoAhQgCmohCiAHIQhBACEHDAALAAsgDkGgAWokACAuCz8BAX8jAEHQAGsiAiQAIAIgAQR/IAAoAhAgAkEQaiABEJABBUHQ6gALNgIAIABBv/UAIAIQxgIgAkHQAGokAAuoAQACQCABQYAITgRAIABEAAAAAAAA4H+iIQAgAUH/D0kEQCABQf8HayEBDAILIABEAAAAAAAA4H+iIQBB/RcgASABQf0XThtB/g9rIQEMAQsgAUGBeEoNACAARAAAAAAAAGADoiEAIAFBuHBLBEAgAUHJB2ohAQwBCyAARAAAAAAAAGADoiEAQfBoIAEgAUHwaEwbQZIPaiEBCyAAIAFB/wdqrUI0hr+iC3UBA38CQAJAIAFCgICAgHBaBEAgAaciAy8BBiIEQQprIgVBGk1BAEEBIAV0QYGAgCxxGyAEQQRrQQRJcg0BCyAAIAIQDyABQoCAgIBwg0KAgICA4ABRDQEgAEHH5ABBABAVDwsgACADKQMgEA8gAyACNwMgCwsbACAAIAFB/wFxEBEgACACIAAoAgRrQQRrEB0LjgEBAn8jAEEQayICJAACfyABBEAgAEEgaiAAIABBwQBrQRpJGyAAQf8ATQ0BGiACQQRqIABBAhCyAxogAigCBAwBCyAAQSBrIAAgAEHhAGtBGkkbIABB/wBNDQAaIAJBBGogAEEAELIDIQEgAigCBCIDIAAgA0H/AEsbIAAgAUEBRhsLIQAgAkEQaiQAIAALRwIBfgF/IAApA8ABIQQgAUIgiKdBdU8EQCABpyIFIAUoAgBBAWo2AgALIAAgBCACIAFBAxDvARogACABIAMQ+wUgACABEA8LiAgCBX8BfiMAQRBrIgMkAAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAAKAIQIgJBywBqDgMEAQMACyACQesAakECSQ0BAkAgAkEraw4DAQYBAAsgAkFaRg0EIAJB/gBGDQAgAkEhRw0FC0F/IQQgABASDQkgAEEQEN8BDQkCQAJAAkACQAJAAkAgAkEraw4DAgUBAAsgAkG2f0YNAyACQSFGDQIgAkH+AEcNBCAAQZUBEBAMDQsgAEGMARAQDAwLIABBjQEQEAwLCyAAQZYBEBAMCgsgAEEOEBAgAEEGEBAMCQsQAQALIAAQEg0FIABBABDfAQ0FIAAgA0EMaiADQQhqIAMgA0EEakEAQQEgAhC1AQ0FIAAgAkEHa0H/AXEQECAAIAMoAgwgAygCCCADKAIAIAMoAgRBAkEAEMEBDAQLQX8hBCAAEBINByAAQRAQ3wENB0EAIQQCQCAAKAJAIgEoApgCIgJBAEgNACABKAKAAiACaiIBLQAAQbgBRw0AIAFBtwE6AAALIABBlwEQEAwHCyAAQUBrKAIAIQFBfyEEIAAQEg0GIABBEBDfAQ0GQQAhBAJAIAEoApgCIgJBAEgNAAJAAkACQAJAAkACQCABKAKAAiACaiIFLQAAIgZBxwBrDgQBBgYFAAsgBkG+AUYNAyAGQbgBRg0CIAZBwQBHDQUgBSgAASEFQX8hBCABQX82ApgCIAEgAjYChAIgACAAKAIAIAUQXCIHQQEQtAEhASAAKAIAIAcQDyAAKAIAIAUQEyABRQ0BDAwLIAFBfzYCmAIgASACNgKEAgsgAEGYARAQDAkLIAUoAAEiAkEIRiACQfEARnINAiABLQBuQQFxBEAgAEGV7ABBABAWDAcLIAVBugE6AAAMCAsgAEH79ABBABAWDAULIABBMBAQIABBABAaIABBQGsoAgBBAxBkDAcLIABBDhAQIABBChAQDAYLIAAoAkAiAS0AbEECcUUEQCAAQf7wAEEAEBYMAwsgASgCZEUEQCAAQZDNAEEAEBYMAwtBfyEEIAAQEg0FIABBEBDfAQ0FIABBiwEQEAwEC0F/IQQgACABQQRxQQJyELsDDQQgACgCMA0AIAAoAhAiAkHrAGpBAUsNACAAIANBDGogA0EIaiADIANBBGpBAEEBIAIQtQENBCAAIAJBBWtB/wFxEBAgACADKAIMIAMoAgggAygCACADKAIEQQNBABDBASAAEBINBAtBACEEIAFBGHFFDQMgACgCEEF+cUGkf0cNAyABQRBxRQ0BIAAoAkAtAG5BBHENASAAKAIAQa+YAUEAEIACC0F/IQQMAgtBfyEEIAAQEg0BIABBCBDfAQ0BIABBnwEQEAtBACEECyADQRBqJAAgBAtgACAEQfIAIANBxgBrIANBtwFGG0H/AXEQESAEIAAgAhAYEB0gBSABIAUoAgAQyAMiADYCACAEIAAQHSAEIAZB/wFxEBEgASAFKAIAQQEQaRogASABKALQAkEBajYC0AIL8isBEX8jAEGQAWsiAyQAIAAoAgAhDgJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAAKAIQIgRBg39HDQAgACgCKA0CIAAoAjhBABCDAUE6Rw0BIA4gACgCIBAYIQkgAEFAaygCAEGwAmohAgJAA0AgAigCACICRQ0BIAIoAgQgCUcNAAsgAEGv5wBBABAWDBsLIAAQEg0aIABBOhAsDRogACgCECIEQcUAakEDSQ0AIABBQGsiBSgCABAyIQcgAyAFKAIAIgQoArACNgJQIAQgA0HQAGo2ArACIANBfzYCZCADQv////8PNwJcIAMgBzYCWCADIAk2AlQgAyAEKAK8ATYCaEEAIQIgA0EANgJsIAAgAUEedEEfdUEAQQMgBC0AbkEBcRtxEOEBDRogACAHEB4gBSgCACIAIAAoArACKAIANgKwAgwcCwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIARB0ABqDiQDFAElFBQUFBQUFAUEBgcHCBQUAgkUFAwSCxEkExMTFBQUFCQACyAEQYN/Rg0MIARBO0YNCSAEQfsARw0TIAAQ4gINJQwmCyAAKAJAKAIgBEAgAEGqzABBABAWDCULIAAQEg0kQQAhAiAAAn9BACAAKAIQIgRBO0YNABpBACAEQf0ARg0AGkEAIAAoAjANABogABCRAQ0lQQELEOUCIAAQtwENJAwmCyAAEBINIyAAKAIwBEAgAEHJIUEAEBYMJAsgABCRAQ0jIABBLxAQIAAQtwFFDSQMIwsgABASDSIgABCAARogABDAASAAEPIBDSIgAEHpAEF/EBwhASAAIAAoAkAtAG5BAXFFIgIQ4QENIgJAIAAoAhBBsX9HBEAgASEEDAELIABB6wBBfxAcIQQgABASDSMgACABEB4gACACEOEBDSMLIAAgBBAeDB8LIABBQGsiBCgCABAyIQEgBCgCABAyIQIgAyAEKAIAIgQoArACNgJQIAQgA0HQAGo2ArACIANCgICAgHA3AmAgAyABNgJcIAMgAjYCWCADIAk2AlQgBCgCvAEhBCADQQA2AmwgAyAENgJoIAAQEg0hIAAQwAEgACABEB4gABDyAQ0hIABB6QAgAhAcGiAAEKACDSEgAEHrACABEBwaIAAgAhAeIABBQGsoAgAiACAAKAKwAigCADYCsAIMIgsgAEFAayIBKAIAEDIhAiABKAIAEDIhBCABKAIAEDIhBSADIAEoAgAiASgCsAI2AlAgASADQdAAajYCsAIgA0KAgICAcDcCYCADIAI2AlwgAyAENgJYIAMgCTYCVCABKAK8ASEBIANBADYCbCADIAE2AmggABASDSAgACAFEB4gABDAASAAEKACDSAgACACEB4gAEG8fxAsDSAgABDyAQ0gIAAoAhBBO0YEQCAAEBINIQsgAEHqACAFEBwaIAAgBBAeIABBQGsoAgAiACAAKAKwAigCADYCsAIMIQsgABASDR8gABDAASADQQA2AhgCQCAAKAIQIgJBWkcEQEEBIQEgAkEoRw0BIAAgA0EYakEAEJ4BGgwBCyAAKAJALQBsQQJxRQRAIABBmTZBABAWDCELIAAQEg0gQQAhAQsgAEEoECwNH0EBIQQgAy0AGEEBcUUEQCAAKAIAIQogAEFAayICKAIAIggoArwBIQ8gCBAyIQcgAigCABAyIRAgAigCABAyIREgAigCABAyIRIgABCAARogAyACKAIAIgUoArACNgJQIAUgA0HQAGo2ArACIANBADYCbCADQoGAgIBwNwJgIAMgBzYCXCADIBE2AlggAyAJNgJUIAMgDzYCaCAAQesAQX8QHCEMIAIoAgAoAoQCIQsgACASEB4gACgCECECQVMhBQJAAkACQAJAIABBBBC9Aw4CAAEkCyACQUtGIQ0gAkFTRiEEIAQgAkGzf0ZyRSACQUtHcQ0BIAIhBQsgABASDSIgACgCECICQfsARiACQdsARnINEgJAIAJBg39GBEAgACgCKEUNAQsgAEHJ9wBBABAWDCMLIAogACgCIBAYIQYgABASBEAgACgCACAGEBMMIwsgACAGIAUQoQIEQCAAKAIAIAYQEwwjCyAAQb0BQb0BQbkBIAQbIA0bEBAgACAGEBogAEFAaygCACAILwG8ARAXDAELAkACQCAAKAIQQSByQfsARw0AIAAgA0FAa0EAEJ4BIgRBW0cgBEG5f0dxDQAgAEEAQQBBASADKAJAQQJxQQEQwgFBAE4NAQwjCyAAEKMCDSIgACADQcgAaiADQcQAaiADQcwAaiADQTxqQQBBAEG9fxC1AQ0iIAAgAygCSCADKAJEIAMoAkwgAygCPEEEQQAQwQELIAIhBQtBACECDBwLIABBQGsoAgAoArwBIQYgABCAARogACgCECIBQTtGDRpBUyEEAkAgAEEEEL0DDgIAGSALIAFBs39GIAFBU0ZyDRcgASIEQUtGDRggAEEAENkEDR8gAEEOEBAMGQsgABASDR4CQCAAKAIwDQAgACgCEEGDf0cNACAAKAIoDQAgACgCICEHCyAAKAJAIgJBsAJqIQEgAigCvAEhBSAEQb5/RiEGAkADQCABKAIAIgEEQCAAIAUgASgCGBCfAiABKAIYIQUCQCAGRQRAIAEoAgwiAkF/Rg0BIAdFDQQgASgCBCAHRw0BDBkLIAEoAggiAkF/Rg0AIAdFDQMgASgCBCAHRg0YCyABKAIcBH8gAEGDARAQQQMFQQALIQIDQCACIAEoAhBORQRAIABBDhAQIAJBAWohAgwBCwsgASgCFEF/Rg0BIABBBhAQIABB7QAgASgCFBAcGiAAQQ4QEAwBCwsgB0UEQCAEQb5/Rg0PIABB08kAQQAQFgwgCyAAQcDyAEEAEBYMHwsgAEHrACACEBwaDBULIAAQEg0dIAAQwAEgABDyAQ0dIAAQgAEaIABBQGsiBCgCABAyIQUgAyAEKAIAIgIoArACNgJQIAIgA0HQAGo2ArACQX8hASADQX82AmQgA0L/////HzcCXCADIAU2AlggAyAJNgJUIAIoArwBIQIgA0EANgJsIAMgAjYCaCAAQfsAECwNHUF/IQcDQAJAAkACQCAAKAIQIgJBP2oOAgABAgsgAUEASAR/QX8FIABB6wBBfxAcCyECIAAgARAeA0AgABASDSEgAEEREBAgABCRAQ0hIABBOhAsDSEgAEGrARAQIAAoAhBBQUYEQCAAQeoAIAIQHCECDAELCyAAQekAQX8QHCEBIAAgAhAeDAILIAAQEg0fIABBOhAsDR8gB0EATgRAQZgtIQIMFQsgAUEASARAIABB6wBBfxAcIQELIABBtgEQECAEKAIAQQAQOSAEKAIAKAKEAkEEayEHDAELIAJB/QBHBEAgAUEASARAQe8sIQIMFQsgAEEHEOEBRQ0BDB8LCyAAQf0AECwNHQJAIAdBAE4EQCAAQUBrKAIAIgIoAoACIAdqIAE2AAAgAigCpAIgAUEUbGogB0EEajYCBAwBCyAAIAEQHgsgACAFEB4gAEEOEBAgAEFAaygCACIBIAEoArACKAIANgKwAgwaCyAAEMABIAAQEg0cIABBQGsiBCgCABAyIQUgBCgCABAyIQEgBCgCABAyIQIgBCgCABAyIQcgAEHsACAFEBwaIAMgBCgCACIGKAKwAjYCUCAGIANB0ABqNgKwAiADQv////8fNwJcIANCgICAgHA3AlQgBigCvAEhBiADQQA2AmwgAyAGNgJoIAMgAjYCZCAAEOICDRwgBCgCACIEIAQoArACKAIANgKwAiAEEOYCBEAgAEEOEBAgAEEGEBAgAEHtACACEBwaIABBDhAQIABB6wAgBxAcGgsCQAJAAkAgACgCEEE7ag4CABMBCyAAEBINHiAAEIABGiAAIAUQHiAAKAIQQfsARgRAIABBDhAQDBILIABBKBAsDR4gACgCECIEQfsARiAEQdsARnINAQJAIARBg39GBEAgACgCKEUNAQsgAEHe9gBBABAWDB8LIA4gACgCIBAYIQQCQCAAEBJFBEAgACAEQUUQoQJBAE4NAQsgDiAEEBMMHwsgAEG5ARAQIABBQGsiBSgCACAEEDkgBSgCACIEIAQvAbwBEBcMEAsgAEHgHUEAEBYMHQsgAEFTQQBBAUF/QQEQwgFBAE4NDgwcCyAAEBJFDRwMGwsgAEFAaygCAC0AbkEBcQRAIABBoNgAQQAQFgwbCyAAEBINGiAAEPIBDRogABCAARogACAAQUBrIgEoAgBB1ABBABCgASICQQBIDRogAEHvABAQIABB2QAQECABKAIAIAJB//8DcRAXIAAQwAEgABCgAg0aDBcLIAFBAXFFDQMgAUEEcQ0KIAAoAjhBABCDAUEqRg0DDAoLIAAoAihFDQELIAAQ4gEMFwtBUyEEAkAgACABEL0DDgIAFRcLIABBhQEQSkUNBCAAKAI4QQEQgwFBR0cNBCABQQRxDQcLIABBmyNBABAWDBULIAFBBHFFBEAgAEHfIkEAEBYMFQtBfyEBQQAhAiAAQQBBABDtAkUNFgwXCyAAEBINEyAAELcBRQ0UDBMLIAMgACgCACgCECADQdAAaiAAKAIgEJABNgIQIABBgD0gA0EQahAWDBILIAAQkQENEQJAIABBQGsiASgCACgCpAFBAE4EQCAAQdkAEBAgASgCACIBIAEvAaQBEBcMAQsgAEEOEBALIAAQtwFFDRIMEQsgAEHr2QBBABAWDBALQQEhAiAAIAVBAEEBQX9BABDCAUEATg0LDA8LQQAhAiAAQQFBACAAKAIYIAAoAhQQxAENDgwQCyAAQSkQLA0NCyAAQewAIAEQHBogABCAARogAyAAQUBrIgQoAgAiBSgCsAI2AlAgBSADQdAAajYCsAIgA0L/////HzcCXCADQoCAgIBwNwJUIAUoArwBIQUgA0EANgJsIAMgBTYCaCADIAI2AmQgABDiAg0MIAQoAgAiBSAFKAKwAigCADYCsAIgABDzASAAEPMBIAQoAgAQ5gIEQCAAQQ4QECAAQQYQECAAQe0AIAIQHBogAEEOEBAgAEHrACAHEBwaCyABIQULIAAgBRAeIABB7QAgAhAcGiAAQS8QECAAIAIQHiAAKAIQQUZGBEAgABASDQwgAyAAQUBrKAIAIgIoArACNgJQIAIgA0HQAGo2ArACIANBfzYCZCADQv////8vNwJcIANCgICAgHA3AlQgAigCvAEhBEEAIQEgA0EANgJsIAMgBDYCaCACKAKkAUEATgRAIAAoAgAgAkHRABBPIgFBAEgNDSAAQdgAEBAgAEFAayICKAIAIgQgBC8BpAEQFyAAQdkAEBAgAigCACABQf//A3EQFyAAEMABCyAAEOICDQwgAEFAayIEKAIAIgIoAqQBQQBOBEAgAEHYABAQIAQoAgAgAUH//wNxEBcgAEHZABAQIAQoAgAiASABLwGkARAXIAQoAgAhAgsgAiACKAKwAigCADYCsAILIABB7gAQECAAIAcQHgwMCyAAIAJBABAWDAoLIABB6wAgAhAcGiAAEBINCQsgABC3AUUNCQwICyABIQQLIAAQEg0GIABBACAEQQAQzAMNBgsgACAAQUBrKAIAKAK8ASAGEJ8CCyAAQTsQLA0EIABBQGsiAigCABAyIQUgAigCABAyIQQgAigCABAyIQEgAigCABAyIQcgAyACKAIAIgIoArACNgIcIAIgA0EcajYCsAIgA0KAgICAcDcCLCADIAQ2AiggAyAHNgIkIAMgCTYCICACKAK8ASECIANBADYCOCADIAI2AjQgASECIAAoAhBBO0cEQCAAIAUQHiAAEJEBDQUgAEHpACAHEBwaIAUhAgsgAEE7ECwNBAJAIAAoAhBBKUYEQCADIAI2AihBACEFIAIhBAwBCyAAQesAIAEQHBogAEFAaygCACgChAIhBSAAIAQQHiAAEJEBDQUgAEEOEBAgASACRg0AIABB6wAgAhAcGgsgAEEpECwNBCAAQUBrIggoAgAoAoQCIQsgACABEB4gABCgAg0EIAAgCCgCACgCvAEgBhCfAgJAIAEgAkYgAiAERnJFBEAgAEFAayIGKAIAIgFBgAJqIgggASgChAIiCiALIAVrIgJqEMYBGiAIIAEoAoACIAVqIAIQciABKAKAAiAFakGzASACECsaIAYoAgAiAiABKAKEAkEFazYCmAIgBCACKAKsAiIBIAEgBEgbIQYgCiAFayEIA0AgBCAGRg0CIAIoAqQCIARBFGxqIgooAgQiASAFSCABIAtOckUEQCAKIAEgCGo2AgQLIARBAWohBAwACwALIABB6wAgBBAcGgsgACAHEB4gAEFAaygCACIBIAEoArACKAIANgKwAgwBCyAAQesAIBAQHBogAEFAaygCACgChAIhDSAAIAwQHgJAIAAoAhAiDEE9Rw0AAkAgABASRQRAIABBABC2AUUNAQsgCiAGEBMMBQsgBkUNACAAQbkBEBAgACAGEBogAEFAaygCACAILwG8ARAXCyAKIAYQEwJAAkACQCAAQcMAEEoiBARAIANBATYCbCADIAMoAmBBAmo2AmBBqd0AIQYgDEE9Rg0BDAMLIAAoAhBBuX9HDQEgAUUEQCAAQfaXAUEAEBYMBwsgDEE9Rw0CQcTQACEGIAVBs39HDQAgCC0AbkEBcUUgAkF/c3ENAgsgAyAGNgIAIABB/cAAIAMQFgwFCyAAQdXOAEEAEBYMBAsgABASDQMCQCAEBEAgABBWRQ0BDAULIAAQkQENBAsgACAAQUBrIgUoAgAoArwBIA8QnwIgAEH9AEH+ACABG0H8ACAEGxAQIABB6wAgBxAcGiAAQSkQLA0DIAUoAgAiAkGAAmoiCCACKAKEAiIKIA0gC2siBmoQxgEaIAggAigCgAIgC2ogBhByIAIoAoACIAtqQbMBIAYQKxogBSgCACIFIAIoAoQCQQVrNgKYAiAHIAUoAqwCIgIgAiAHSBshCCAKIAtrIQogByECA0AgAiAIRwRAIAUoAqQCIAJBFGxqIgwoAgQiBiALSCAGIA1OckUEQCAMIAYgCmo2AgQLIAJBAWohAgwBCwsgACAQEB4gABCgAg0DIAAgAEFAaygCACgCvAEgDxCfAiAAIAcQHgJ/IAQEQCABRQRAIABBFBAQIABBDhAQIABBJBAQIABBQGsoAgBBABAXIABBiwEQECAAQYIBEBBBgwEMAgsgAEGAARAQIABBQGsoAgBBABBkQYMBDAELIABB/wAQEEEOCyECIABB6QAgEhAcGiAAQQ4QECAAIBEQHiAAIAIQECAAQUBrKAIAIgEgASgCsAIoAgA2ArACCyAAEPMBDAMLIAFBBHENACAAQdojQQAQFgwBCyAAEBINAEEAIQIgAEEBIARBABDMAw0AIAAQtwFFDQILQX8hAgwBC0EAIQILIA4gCRATIAIhAQsgA0GQAWokACABCzoBAX8jAEHQAGsiASQAIAEgACgCACgCECABQRBqIAAoAiAQkAE2AgAgAEGsxQAgARAWIAFB0ABqJAALjgIBAX4CQAJAAkACQCABQv////9vWA0AIAAgAUE8IAFBABAUIgFCgICAgHCDIgNCgICAgOAAUQRAIAEPCyADQoCAgIAwUQRAIAJCIIinQXVJDQMMBAsgAUL/////b1gEQCAAIAEQDwwBCyAAIAFB2gEgAUEAEBQhAyAAIAEQDwJAAkAgA0KAgICAcIMiAUKAgICAIFIEQCABQoCAgIDgAFENAiABQoCAgIAwUg0BCyACQiCIp0F1SQ0EDAULIANCgICAgHBaBEAgA6ctAAVBEHENAQsgACADEA8gAEGiPkEAEBUMAgsgAw8LIAAQJAtCgICAgOAAIQILIAIPCyACpyIAIAAoAgBBAWo2AgAgAgsSACAAIAEgAiADIARBxwAQpAQLDQAgACABIAJBABCVBAvsBAMCfgF8A38jAEEQayIHJAACQAJAAkACQAJ+AkACQAJAAkAgAUEIayIGKQMAIgRCIIinQQdrQW5JDQACQCAEQoCAgIBwVA0AIAAgB0EIaiAEIAIQwgUiAUEASARAQX8hAQwKCyABRQ0AIAAgBBAPQQAhASAHKQMIIQMMCAtBfyEBQoCAgIAwIQMgACAEEGwiBEKAgICAcINCgICAgOAAUQ0HAkACQAJAAkAgBEIgiKciCEELag4DAwECAAsgCA0DIATEIQMCQAJAAkAgAkGMAWsOBAACAQEHCyAEQiCGUARAQQAhAUKAgICAwP7/AyEDDA0LQgAgA30hAwwBCyADIAJBAXRBnQJrrHwhAwsgA0L/////D4MgA0KAgICACHxC/////w9YDQcaQoCAgIDAfiADub0iA0KAgICAwIGA/P8AfSADQv///////////wCDQoCAgICAgID4/wBWGwwHCyAAKAIQIQEMBwsgACAGIAIgBCAAKAIQKAK4AhEbAEUNBwwICyAAIAYgAiAEIAAoAhAoAtQCERsADQcMBgsgACgCECIBKAKMASIIBEAgCC0AKEEEcQ0FCyAEQoCAgIDAgYD8/wB8vyEFAkAgAkGMAWsOBAADAgIBCyAFmiEFDAILEAEACyACQQF0QZ0Ca7cgBaAhBQtCgICAgMB+IAW9IgNCgICAgMCBgPz/AH0gA0L///////////8Ag0KAgICAgICA+P8AVhsLIQNBACEBDAILIAAgBiACIAQgASgCnAIRGwBFDQBBfyEBQoCAgIAwIQMMAQtBACEBDAELIAYgAzcDAAsgB0EQaiQAIAELngMCA34BfwJAAkAgAgRAIAAgAUHcASABQQAQFCIDQoCAgIBwgyIEQoCAgIAgUgRAIARCgICAgOAAUQ0DIARCgICAgDBSDQILIAAgAUHRASABQQAQFCIDQoCAgIBwg0KAgICA4ABRDQIgACABIAMQ+gMhBCAAIAMQDyAEQoCAgIBwg0KAgICA4ABRBEAgBA8LQoCAgIDgACEDAkAgACAEQeoAIARBABAUIgVCgICAgHCDQoCAgIDgAFENACAAQTcQdiIBQoCAgIBwg0KAgICA4ABRBEAgACAFEA8MAQsgAEEQEF8iAkUEQCAAIAEQDyAAIAUQDwwBCyAEQiCIp0F1TwRAIASnIgYgBigCAEEBajYCAAsgAiAFNwMIIAIgBDcDACABQoCAgIBwWgRAIAGnIAI2AiALIAEhAwsgACAEEA8gAw8LIAAgAUHRASABQQAQFCIDQoCAgIBwg0KAgICA4ABRDQELIAAgAxA4RQRAIAAgAxAPIABB/ukAQQAQFUKAgICA4AAPCyAAIAEgAxD6AyEBIAAgAxAPIAEhAwsgAwv/AgIDfwJ+IwBBEGsiAyQAAkACQCABQoCAgIBwWgRAIAGnIgIvAQZBMEYEQAJAIAAgA0EIaiABQd8AEIEBIgJFDQAgAykDCCIBQoCAgIBwg0KAgICAMFEEQCAAIAIpAwAQ6AEhAQwFCyAAIAEgAikDCEEBIAIQLyIFQoCAgIBwg0KAgICA4ABRDQMCQAJAIAVCIIinQQFqDgQAAQEAAQsgACACKQMAEJkBIgRBAEgEQCAAIAUQDwwCCyAEDQRCgICAgOAAIQEgACACKQMAEOgBIgZCgICAgHCDQoCAgIDgAFEEQCAAIAUQDwwGCyAAIAYQDyAGpyAFp0YNBAsgACAFEA8gAEGE5ABBABAVC0KAgICA4AAhAQwDCyACKAIQKAIsIgBFBEBCgICAgCAhAQwDCyAAIAAoAgBBAWo2AgAgAK1CgICAgHCEIQEMAgsgACABEI0EIgFCIIinQXVJDQEgAaciACAAKAIAQQFqNgIADAELIAUhAQsgA0EQaiQAIAELCwAgAEGNIkEAEEYLGgAgACgCECABIAIQ7wQiAUUEQCAAEHwLIAELgAEBAn8CQAJAIAFFDQAgASgCACICQQBMDQEgASACQQFrIgI2AgAgAg0AIAEtAAVBAXEEQCAAIAEpAxgQIwsgASgCCCICIAEoAgwiAzYCBCADIAI2AgAgAUIANwIIIABBEGogASAAKAIEEQAACw8LQdaNAUGu/ABB9ChB6t0AEAAACxIAIAFB3gFOBEAgACABEOgFCwvbAQIBfwJ+QQEhBAJAIABCAFIgAUL///////////8AgyIFQoCAgICAgMD//wBWIAVCgICAgICAwP//AFEbDQAgAkIAUiADQv///////////wCDIgZCgICAgICAwP//AFYgBkKAgICAgIDA//8AURsNACAAIAKEIAUgBoSEUARAQQAPCyABIAODQgBZBEBBfyEEIAAgAlQgASADUyABIANRGw0BIAAgAoUgASADhYRCAFIPC0F/IQQgACACViABIANVIAEgA1EbDQAgACAChSABIAOFhEIAUiEECyAECy0BAX9BASEBAkACQAJAIABBDWsOBAIBAQIACyAAQTRGDQELIABBOEYhAQsgAQsfACAAIAEgACACEKoBIgIgAyAEEBkhBCAAIAIQEyAEC0QBAX9BfyEDIAAgACgCBCACahDGAQR/QX8FIAAoAgAgAWoiAyACaiADIAAoAgQgAWsQnAEgACAAKAIEIAJqNgIEQQALC44BAQF/IAAgBkEMEEkiBkKAgICAcINCgICAgOAAUgRAIAAgACgCAEEBajYCACAGpyIHIAU7ASogByAEOgApIAcgAzoAKCAHIAE2AiQgByAANgIgIAcgBy0ABUHvAXEgBEECa0EESUEEdHI6AAUgACAGIAAgAkHMngEgAhsQqgEiASADEJYDIAAgARATCyAGCykBAX9B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IAAgD0ElEEsiCEUNACAAIANB3QEgA0EAEBQiDkKAgICAcIMiDUKAgICA4ABRDQAgDUKAgICAMFEEQCAAIA8QD0EADAILIAAgDkElEEsiC0UNAAJAIAgoAgRFDQAgCygCBEUNACAAIA8QDyAAIA4QD0EADAILIAQQ9wMhBwJ/IAgoAgAiCiALKAIAIgxGBEAgCCAHQQJ0aigCCAwBCyAKIAxLBEAgCEHUAGogDCAHELgFDAELIAtB3ABqIAogBxC4BQsiCkUEQCAJIAdBAnRBwMABajYCACAAQZL6ACAJEBUMAQsCQCAIKAIEBEACfiAFBEAgACACELkCDAELIAAgAiAGEJACCyICQoCAgIBwg0KAgICA4ABSDQEMAgsgAkIgiKdBdUkNACACpyIIIAgoAgBBAWo2AgALAkAgCygCBARAAn4gBQRAIAAgAxC5AgwBCyAAIAMgBhCQAgsiA0KAgICAcINCgICAgOAAUg0BIAAgAhAPDAILIANCIIinQXVJDQAgA6ciBSAFKAIAQQFqNgIACyAKIAooAgBBAWo2AgAgCSACIAMgBEF+cUGkAUYgB0ENRnEiBRs3AxggCSADIAIgBRs3AxAgACAKrUKAgICAcIRCgICAgDBBAiAJQRBqEC8hDSAAIAIQDyAAIAMQDyANQoCAgIBwgyICQoCAgIDgAFENAAJ+IAdBDEYEQCAAIA0QJiAEQaoBRketQoCAgIAQhAwBCyANIAdBDUcNABpCgICAgBAgAkKAgICAMFENABogACANECYgBEF9cUGkAUZHrUKAgICAEIQLIQMgACAPEA8gACAOEA8gASADNwMAQQEMAQsgACAPEA8gACAOEA8gAUKAgICAMDcDAEF/CyEHIAlBIGokACAHC2MCAX8BfiMAQRBrIgIkACAAAn4gAUUEQEIADAELIAIgAa1CACABZyIBQdEAahBnIAIpAwhCgICAgICAwACFQZ6AASABa61CMIZ8IQMgAikDAAs3AwAgACADNwMIIAJBEGokAAvHAQIBfgF/AkAgACgCECgCjAEiA0UgAUL/////////D3xC/v///////x9Wcg0AIAMoAihBBHFFDQAgAUKAgICACHxC/////w9YBEAgAUL/////D4MPC0KAgICAwH4gAbm9IgFCgICAgMCBgPz/AH0gAUL///////////8Ag0KAgICAgICA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ACAAIAEQiANBH3YLvgEBB38gACgCDCIFIQMCQANAIAMiBEUNASAAKAIQIgkgBEEBayIDQQJ0aiIGKAIARQ0ACyAAIAAoAgggBCAFa0EFdGo2AgggBigCAGciBwRAQSAgB2shBUEAIQMDQCADIARGRQRAIAkgA0ECdGoiBiAIIAV2IAYoAgAiCCAHdHI2AgAgA0EBaiEDDAELCyAAIAAoAgggB2s2AggLIAAgASACIARBABCqAw8LIABBgICAgHg2AgggAEEAEEEaQQALTgIBfwF+An4jACICIAAoAhAoAnhJBEAgABDpAUKAgICA4AAMAQsgACABrSABKQMAQoCAgIAwIAEoAgggASgCIEEEENgBCyEDIAIkACADCwwAIABB+swAQQAQFQsLACAAQcMaQQAQFQvVAQEDfyMAQRBrIgUkAEF/IQMCQCAAKAIUDQACQAJAIAFBgICAgAROBEAgACgCAEHA2gBBABBGDAELIAEgACgCDEEDbEECbSIEIAEgBEobIQEgACgCECIEIAJBgAJIckUEQCAAIAEQ9QMhAwwDCyAAKAIAIAAoAgQgASAEdCAEa0ERaiAFQQxqEKgBIgINAQsgABCDAwwBCyAFKAIMIQMgACACNgIEIABB/////wMgAyAAKAIQdiABaiIAIABB/////wNOGzYCDEEAIQMLIAVBEGokACADCxEAIAAgASACIAMgBEEAELcFCyYBAX8gAUIgiKdBdU8EQCABpyICIAIoAgBBAWo2AgALIAAgARBsCycBAX8gAUIAUwRAIABCACABfRAwIQIgAEEBNgIEIAIPCyAAIAEQMAvsAQEBfwJAAkACQAJAAkACQAJAQQcgAkIgiKciAyADQQdrQW5JGyIDDggAAAAEBAQEAQMLIAAoAtgBIQAgAUIANwIMIAFCgICAgICAgICAfzcCBCABIAA2AgAgASACxBC6Ag0BDAQLIAAoAtgBIQAgAUIANwIMIAFCgICAgICAgICAfzcCBCABIAA2AgAgASACQoCAgIDAgYD8/wB8vxC6BUUNAwsgARAbQQAPCyADQQpqQQJJDQILIAAoAtgBIQAgAUIANwIMIAFCgICAgICAgICAfzcCBCABIAA2AgAgARA1CyABDwsgAqdBBGoL5AEBBH8jAEEQayICJAAgACACQQhqIAEQ5QEhAyAAIAEQDwJAIANFBEBC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IAMoAgAgAygCBHEMBAsgAygCACADKAIEcgwDCyADKAIAIAMoAgRzDAILEAEACyADKAIEIAMoAgB0C603AwAMAQsgAUKAgICAMDcDACAGQoCAgIAwNwMAQX8MAQtBAAshACADQRBqJAAgAAuGBQIHfwJ+AkAgAUKAgICAcINCgICAgJB/UgRAQoCAgIDgACEKIAAgARA3IgFCgICAgHCDQoCAgIDgAFENAQsCQCACQoCAgIBwg0KAgICAkH9RDQBCgICAgOAAIQogACACEDciAkKAgICAcINCgICAgOAAUg0AIAEhAgwBCwJAIAKnIgUpAgQiCkL/////B4NQDQAgAaciAykCBCELAkAgAygCAEEBRyAKIAuFQoCAgIAIg0IAUnINACADIAAoAhAoAgwRBAAgBSkCBCIKpyIEQf////8HcSIHIAMpAgQiC6ciBkH/////B3EiCGogBEEfdnQgBkEfdiIJQRFzakkNACAFQRBqIQYgA0EQaiEEIAkEQCAEIAhBAXRqIAYgB0EBdBAfGiADIAMpAgQiCiAFKQIEfEL/////B4MgCkKAgICAeIOENwIEDAILIAQgCGogBiAHEB8aIAMgAykCBCIKIAUpAgR8Qv////8HgyILIApCgICAgHiDhDcCBCAEIAunakEAOgAADAELAn4CQAJAIAunQf////8HcSAKp0H/////B3FqIgdBgICAgARPBEAgAEHA2gBBABBGDAELIAAgByAKIAuEpyIGQR92EOoBIggNAQtCgICAgOAADAELIAhBEGohBAJAIAZBAE4EQCAEIANBEGogAygCBEH/////B3EQHyIEIAMoAgRB/////wdxaiAFQRBqIAUoAgRB/////wdxEB8aIAQgB2pBADoAAAwBCyAEIAMgAygCBEH/////B3EQwwUgBCADKAIEQQF0aiAFIAUoAgRB/////wdxEMMFCyAIrUKAgICAkH+ECyEKIAAgARAPDAELIAEhCgsgACACEA8gCgtAACAAAn8CfyADBEAgASgCJCACQQN0akEEagwBC0EAIAEoAiAiA0UNARogAyABLwEoIAJqQQR0agsoAgALENkBCw0AIAAgASACQQIQzgILNQEBfyMAQdAAayICJAAgAiAAKAIQIAJBEGogARCQATYCACAAQef5ACACEMYCIAJB0ABqJAALowECAX8BfiMAQRBr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AiAAKAIQQf0ARw0ACyAAEPMBC0F/QQAgABASGyEBCyABC2gAIAAgASACEE8iAEEATgRAIAEoAnQgAEEEdGoiAiACKAIMQYd/cSADQQN0QfgAcXI2AgwgAiABKAK8ASIDNgIEIAIgASgCwAE2AgggASgCzAEgA0EDdGogADYCBCABIAA2AsABCyAAC20BAX8gACABQfwBakEQIAFB+AFqIAEoAvQBQQFqEHhFBEAgASABKAL0ASIDQQFqNgL0ASABKAL8ASADQQR0aiIDQX82AgAgAyADLQAEQfgBcToABCADIAEoArwBNgIIIAMgACACEBg2AgwLIAMLxgMBBH8gAEFAayIFKAIAQbACaiEDA0BBACECAkADQCADKAIAIgNFDQEgAygCHARAIAFFBEAgAEEGEBALIABBhAEQEEGDASECIAAgBSgCAC0AbEEDRgR/IABBDhAQIABBDhAQIABBwgAQECAAQQYQGiAAQREQECAAQbABEBAgAEHqAEF/EBwhASAAQSQQECAFKAIAQQAQFyAAQYEBEBAgAEGLARAQIABB6wBBfxAcIQQgACABEB4gAEEOEBAgACAEEB5BDgVBgwELEBBBfSECQQEhAQsgAygCECACaiECIAMoAhRBf0YNAAtBD0EOIAEbIQQDQCACBEAgACAEEBAgAkEBayECDAELCyABRQRAIABBBhAQCyAAQe0AIAMoAhQQHBpBASEBDAELCwJAIABBQGsoAgAiAigCYARAAkAgAUUEQEF/IQIMAQsgAEEqEBAgAEHpAEF/EBwhAiAAQQ4QEAsgAEG4ARAQIABBCBAaIABBQGsoAgBBABAXIAAgAhAeQSghAgwBCyACLQBsIgMEQCABRQRAIABBBhAQQS4hAgwCC0EuIQIgA0EDRw0BIABBiwEQEAwBC0EoQSkgARshAgsgACACEBALXQECfwJAAkAgACgCmAIiAUEASA0AIAAoAoACIAFqLQAAIgBBI2siAUENTUEAQQEgAXRB5fAAcRsNAQJAIABB6wBrDgQCAQECAAsgAEHsAWtBAkkNAQtBASECCyACCy8AIAAgASACIAMQ4wIiAEEATgRAIAEoAnQgAEEEdGoiASABKAIMQQNyNgIMCyAACy4AIABBDBApIgAEQCAAIAM2AgggACACNgIEIAAgASgCEDYCACABIAA2AhALIAALawEBfwJA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CyAAKAIQIgJBEGogAyACKAIEEQAAQQAhAgNAIAEoAvwBIQMgAiABKAL0AU5FBEAgACADIAJBBHRqKAIMEBMgAkEBaiECDAELCyAAKAIQIgJBEGogAyACKAIEEQAAQQAhAgNAIAEoAsgCIQMgAiABKALAAk5FBEAgACADIAJBA3RqKAIEEBMgAkEBaiECDAELCyAAKAIQIgJBEGogAyACKAIEEQAAIAEoAswBIgIgAUHQAWpHBEAgACgCECIDQRBqIAIgAygCBBEAAAsgACABKALsAhATIAFB9AJqEPYBIAAoAhAiAkEQaiABKAKMAyACKAIEEQAAIAEoAgQEQCABKAIYIgIgASgCHCIDNgIEIAMgAjYCACABQgA3AhgLIAAoAhAiAEEQaiABIAAoAgQRAAALggEBAn8gACABQRBqEM8FAkAgASgCICICBEAgASgCPCIDRQ0BA0AgAiADT0UEQCAAIAIpAwAQIyACQQhqIQIgASgCPCEDDAELCyAAQRBqIAEoAiAgACgCBBEAAAsgACABKQMYECMgACABKQMAECMPC0GEhAFBrvwAQYmUAUHC6wAQAAALaAEBfgJAAkAgABA0IgNCgICAgHCDQoCAgIDgAFEEQCABIQMMAQsgACADQcAAIAFBBxAZQQBIDQAgACADQekAIAJBAEetQoCAgIAQhEEHEBlBAE4NAQsgACADEA9CgICAgOAAIQMLIAMLjAEBAn8CQANAIAFCgICAgHBUDQECQAJAAkACQAJAAkAgAaciAi8BBiIDQQxrDgUFAQMHAQALIANBMEYNASADQTRrDgUABgYGAAYLIAIoAiAoAjAPCyACKAIgIgJFDQQgAi0AEUUNASAAELYCQQAPCyACKAIgIQILIAIpAwAhAQwBCwsgAigCICEACyAACyIAIAAgAkEBahApIgAEQCAAIAEgAhAfIAJqQQA6AAALIAALjQMCA34EfwJAIAEoAggiBkH+////B04EQEEBIQcgAkEBcQ0BQv///////////wAhAyAGQf7///8HRw0BIAE0AgRC////////////AHwhAwwBCyAGQQBMBEAMAQsgBkE/TQRAIAEoAhAiCSABKAIMIgJBAnRqQQRrKAIAIQhCACAGQSBNBH4gCEEgIAZrdq0FIAJBAk8EfiACQQJ0IAlqQQhrNQIABUIACyAIrUIghoRBwAAg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LQAFQf4BcToABSABIAs3A0ALIAtCIIinQXVPBEAgC6ciACAAKAIAQQFqNgIACyALIQwLIANBIGokACAMC4kEAgR+An8CQAJAIAG9IgRCAYYiA1ANACABvSECIAC9IgVCNIinQf8PcSIGQf8PRg0AIAJC////////////AINCgYCAgICAgPj/AFQNAQsgACABoiIAIACjDwsgAyAFQgGGIgJaBEAgAEQAAAAAAAAAAKIgACACIANRGw8LIARCNIinQf8PcSEHAn4gBkUEQEEAIQYgBUIMhiICQgBZBEADQCAGQQFrIQYgAkIBhiICQgBZDQALCyAFQQEgBmuthgwBCyAFQv////////8Hg0KAgICAgICACIQLIQICfiAHRQRAQQAhByAEQgyGIgNCAFkEQANAIAdBAWshByADQgGGIgNCAFkNAAsLIARBASAHa62GDAELIARC/////////weDQoCAgICAgIAIhAshBCAGIAdKBEADQAJAIAIgBH0iA0IAUw0AIAMiAkIAUg0AIABEAAAAAAAAAACiDwsgAkIBhiECIAZBAWsiBiAHSg0ACyAHIQYLAkAgAiAEfSIDQgBTDQAgAyICQgBSDQAgAEQAAAAAAAAAAKIPCwJAIAJC/////////wdWBEAgAiEDDAELA0AgBkEBayEGIAJCgICAgICAgARUIQcgAkIBhiIDIQIgBw0ACwsgBUKAgICAgICAgIB/gyADQoCAgICAgIAIfSAGrUI0hoQgA0EBIAZrrYggBkEAShuEvwvoDwMHfAh/An5EAAAAAAAA8D8hAwJAAkACQCABvSIRQiCIpyIPQf////8HcSIJIBGnIgxyRQ0AIAC9IhJCIIinIQogEqciEEUgCkGAgMD/A0ZxDQAgCkH/////B3EiC0GAgMD/B0sgC0GAgMD/B0YgEEEAR3FyIAlBgIDA/wdLckUgDEUgCUGAgMD/B0dycUUEQCAAIAGgDwsCQAJAAkACQAJAAn9BACASQgBZDQAaQQIgCUH///+ZBEsNABpBACAJQYCAwP8DSQ0AGiAJQRR2IQ0gCUGAgICKBEkNAUEAIAxBswggDWsiDnYiDSAOdCAMRw0AGkECIA1BAXFrCyEOIAwNAiAJQYCAwP8HRw0BIAtBgIDA/wNrIBByRQ0FIAtBgIDA/wNJDQMgAUQAAAAAAAAAACARQgBZGw8L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A38jAEFAaiIGJAACQCAEIANrIghBAUYEQAJAIANFBEAgAUIDEDAaDAELIAEgA60QMBogAUEBNgIECyACIANBAXRBAXKtEDAaIAIgAigCCEECajYCCCAAIAEQRBoMAQsgACgCACEHIAAgASACIAMgCEEBdiADaiIDQQEQoAQgBkIANwI4IAZCgICAgICAgICAfzcCMCAGIAc2AiwgBkIANwIkIAZCgICAgICAgICAfzcCHCAGIAc2AhggBkIANwIQIAZCgICAgICAgICAfzcCCCAGIAc2AgQgBkEsaiIHIAZBGGogBkEEaiIIIAMgBCAFEKAEIAAgACAIQf////8DQQEQQxogByAHIAFB/////wNBARBDGiAAIAAgB0H/////A0EBEMsBGiAFBEAgASABIAZBGGpB/////wNBARBDGgsgAiACIAZBBGoiAEH/////A0EBEEMaIAZBLGoQGyAGQRhqEBsgABAbCyAGQUBrJAALzgUCB38DfiMAQTBrIggkAAJ/AkACQAJAAkACQCADDgMAAQIDC0HcjAFB1PwAQbUaQZb8ABAAAAsgASACKAIQIAIoAgwiACAAQQV0IAIoAghrEGg2AgAMAgsgAigCECIDIAIoAgwiACAAQQV0IAIoAghrIgJBIGoQaK1CIIYgAyAAIAIQaK2EIQ8gBkGAlOvcA0YEQCABIA9CgJTr3AOAIhA+AgQgASAQQoDslKMMfiAPfD4CAAwCCyABIA8gBq0iEIAiET4CBCABIA8gECARfn0+AgAMAQsgAigCACEKIAhCADcCKCAIQoCAgICAgICAgH83AiAgCCAKNgIcIAhCADcCFCAIQoCAgICAgICAgH83AgwgCCAKNgIIIAMgBUEBdCAEQQFqIgt2QQFqQQF2IgprIQwgACAEQQF0QQFyQRRsaiENQQAhAyAAIARBKGxqIgQoAgxFBEAgBCAGIApB/////wNBARD8AiAIQQhqIglCARAwciANIAkgBCAKQQFqIAdsQQJqQQAQlQFyIQkLAkACQCAIQRxqIg4gAiANIAcgDGxBABBDIAlyIA5BARDRAXIgCEEIaiIJIA4gBEH/////A0EBEENyIAkgAiAJQf////8DQQEQ5AFyQSBxDQADQAJAIAgoAgxFDQAgCCgCFEUNACAIQQhqIgIgAiAEQf////8DQQEQywENAiADQQFrIQMM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3gQBCX8jAEEQayIGJAAgACAAKQOAARAjIABBEGohAyAAQaABaiEEIAAoAqQBIQEDQCABIARGRQRAIAEoAgQhBUEAIQIDQCACIAEoAhBORQRAIAAgASACQQN0aikDGBAjIAJBAWohAgwBCwsgAyABIAAoAgQRAAAgBSEBDAELCyAAIAQ2AqQBIAAgAEGgAWo2AqABIAAQogUgACgCVCAAQdAAakYEQEEAIQIDQAJAIAAoAkQhASACIAAoAkBODQAgASACQRhsaiIBKAIABEAgACABKAIEEOwBCyACQQFqIQIMAQsLIAMgASAAKAIEEQAAIAAoApACIgQEQEEAIQEDQEEAIQUgAUEFRkUEQANAQQAhAiAFQQJGRQRAA0AgAkEURwRAIAQgAUGgAWxqIAVB0ABsaiACQQJ0akGoDWoiBygCACIIBEAgBCgCACIJKAIAIAhBACAJKAIEEQEAGiAHQQA2AgALIAJBAWohAgwBCwsgBUEBaiEFDAELCyABQQFqIQEMAQsLIAAoAtgBIARBACAAKALcAREBABogAEEANgKQAgsgAEHgAWoQoQUgAEH4AWoQoQVBACECA0ACQCAAKAI4IQEgAiAAKAIsTg0AIAEgAkECdGooAgAiAUEBcUUEQCADIAEgACgCBBEAAAsgAkEBaiECDAELCyADIAEgACgCBBEAACADIAAoAjQgACgCBBEAACADIAAoAtQBIAAoAgQRAAAgBiADKQIINwMIIAYgAykCADcDACAGIAAgACgCBBEAACAGQRBqJAAPC0GNkQFBrvwAQb8PQaTlABAAAAtDAQJ/IAAoAogBIQJBfyEDAkADQCACQQBMDQEgACgCgAEgAkEBayICQQR0aigCACABRw0ACyACQYCAgIACciEDCyADC8YBAgR/AX4jAEEQayIDJAAgACABEC0iB0KAgICAcINCgICAgOAAUgRAAkAgACADQQxqIAcQ5QEiBkUEQAwBCwJAIAAgAhA/IgEgAygCDGpBAWoQKSIERQRAQQAhBAwBCyAEIAYgAygCDBAfIgUgAygCDGogAiABEB8aIAUgAygCDCABampBADoAACAAIAUgAygCDCABahCFAyEEIAAoAhAiAUEQaiAFIAEoAgQRAAALIAAgBhBUCyAAIAcQDwsgA0EQaiQAIAQLvwEBAX8gASADai0AAEE8RgRAIAAgBEH/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BEAgCygCJCIEIAJBA3RqIAQgAadBA3QQnAFBAAwBCyABpwshDUEAIQQgAkEAIAJBAEobIQIDQCACIARHBEAgAyAEQQN0aikDACIBQiCIp0F1TwRAIAGnIg4gDigCAEEBajYCAAsgCygCJCAEIA1qQQN0aiABNwMAIARBAWohBAwBCwsgCyAFPgIoIAsoAhQgBUL/////D4M3AwAgBUKAgICACHwhAQwBCyAAIAxBCGogBhA8DQEgDCkDCCIBIAKsIgh8IgVCgICAgICAgBBZBEAgAEHQ2gBBABAVDAILAkAgBEUgAkEATHJFBEBCACEHIAAgBiAIQgAgAUF/EPQCDQMMAQsgASEHCyACQQAgAkEAShutIQlCACEBA0AgASAJUgRAIAMgAadBA3RqKQMAIghCIIinQXVPBEAgCKciAiACKAIAQQFqNgIACyABIAd8IQogAUIBfCEBIAAgBiAKIAgQhgFBAE4NAQwDCwsgACAGQTAgBUKAgICACHwiAUL/////D1gEfiAFQv////8PgwVCgICAgMB+IAW5vSIHQoCAgIDAgYD8/wB9IAdC////////////AINCgICAgICAgPj/AFYbCxBFQQBIDQELIAAgBhAPIAVC/////w+DIAFC/////w9YDQEaQoCAgIDAfiAFub0iAUKAgICAwIGA/P8AfSABQv///////////wCDQoCAgICAgID4/wBWGwwBCyAAIAYQD0KAgICA4AALIQEgDEEQaiQAIAEL0gMCB38DfiMAQSBrIgQkACAEQQA2AgwgBEEANgIIAkACQCAEIAAoAhAoAnhJBEAgABDpAQwBCyAAIAEgAiABQQAQFCILQoCAgIBwg0KAgICA4ABRBEAgCyEBDAILAkACQCALQoCAgIBwVA0AIAAgCxDKASIKQQBIDQECQCAKBEAgACAEQQxqIAsQ1gFFDQEMAwsgACAEQQhqIARBDGogC6dBERCOASEJIAQoAgghBSAJQQBIDQILIAQoAgwhCANAIAcgCEYNAQJAIAoEQCAAIAcQqQUiBkUNBAwBCyAAIAUgB0EDdGooAgQQGCEGCwJ/AkAgACALIAYgAxD5BCINQoCAgIBwgyIMQoCAgIAwUgRAIAxCgICAgOAAUg0BIAAgBhATDAULIAAgCyAGQQAQ1QEMAQsgACALIAYgDUEHEBkLIQkgACAGEBMgB0EBaiEHIAlBAE4NAAsMAQsgACAFIAgQWkEAIQUgACACEFwiDEKAgICAcINCgICAgOAAUQ0AIAQgCzcDGCAEIAw3AxAgACADIAFBAiAEQRBqECEhASAAIAwQDyAAIAsQDwwCCyAAIAUgBCgCDBBaIAAgCxAPC0KAgICA4AAhAQsgBEEgaiQAIAELPwEBfyABQQAgAUEAShshAQNAAkAgASADRgRAQX8hAwwBCyAAIANBA3RqKAIEIAJGDQAgA0EBaiEDDAELCyADC/8EAgJ/BH4CQCACQv////9vWARAIAAQJAwBCwJAIAAgAkE9EHEEf0KAgICAMCEFQoCAgIAwIQZCgICAgDAhCCAAIAJBPSACQQAQFCIHQoCAgIBwg0KAgICA4ABRDQFBgQJBgAIgACAHECYbBUEACyEDIAAgAkE+EHEEQEKAgICAMCEFQoCAgIAwIQZCgICAgDAhCCAAIAJBPiACQQAQFCIHQoCAgIBwg0KAgICA4ABRDQFBggRBgAQgACAHECYbIANyIQMLIAAgAkE/EHEEQEKAgICAMCEFQoCAgIAwIQZCgICAgDAhCCAAIAJBPyACQQAQFCIHQoCAgIBwg0KAgICA4ABRDQFBhAhBgAggACAHECYbIANyIQMLQoCAgIAwIQYCQCAAIAJBwAAQcUUEQEKAgICAMCEIDAELQoCAgIAwIQUgACACQcAAIAJBABAUIghCgICAgHCDQoCAgIDgAFEEQAwCCyADQYDAAHIhAwsCQAJAIAAgAkHBABBxRQ0AQoCAgIAwIQUgA0GAEHIhAyAAIAJBwQAgAkEAEBQiBkKAgICAcIMiB0KAgICAMFENAEHDwgAhBCAHQoCAgIDgAFENASAAIAYQOEUNAQsCQCAAIAJBwgAQcUUEQEKAgICAMCEFDAELIANBgCByIQMgACACQcIAIAJBABAUIgVCgICAgHCDIgJCgICAgDBRDQBBtMIAIQQgAkKAgICA4ABRDQEgACAFEDhFDQELIANBgDBxBEBBsekAIQQgA0GAxABxDQELIAEgBTcDGCABIAY3AxAgASAINwMIIAEgAzYCAEEADwsgACAEQQAQFQsgACAIEA8gACAGEA8gACAFEA8LQX8LwgEBAn8gAigCBEUEQCACKAIYIgMgAigCHCIENgIEIAQgAzYCACACQgA3AhgCQCABKAIABEAgAhCfBQwBCyAAIAIpAyAQIwsgACACKQMoECMgAiACKAIAQQFrIgM2AgACQCADRQRAIAIoAhAiAyACKAIUIgQ2AgQgBCADNgIAIAJCADcCECAAQRBqIAIgACgCBBEAAAwBCyACQoCAgIAwNwMoIAJCgICAgDA3AyAgAkEBNgIECyABIAEoAgxBAWs2AgwLC5UBAQN+IAG9IgJC////////////AIMhAyAAvSIEQv///////////wCDQoGAgICAgID4/wBaBEAgA0KBgICAgICA+P8AVA8LAn9BfyADQoCAgICAgID4/wBWIAAgAWNyDQAaQQEgACABZA0AGkEAIABEAAAAAAAAAABiDQAaIARCAFMEQCACQj+Hp0F/cw8LIAJCP4inCwswACABQoCAgIAQhEKAgICAcINCgICAgDBRBEAgACABEDcPCyAAIAFBOEEAQQAQrQILKQEBfyACQiCIp0F1TwRAIAKnIgMgAygCAEEBajYCAAsgACABIAIQxQULUgIBfwF+QoCAgIDgACEEIAAgASACEJMBIgMEfiADKAIgIgMoAgwoAiAtAAQEQCACRQRAQgAPCyAAEGtCgICAgOAADwsgAzUCEAVCgICAgOAACws4ACAAIAEgAhCTASIARQRAQoCAgIDgAA8LIAAoAiAoAgwiACAAKAIAQQFqNgIAIACtQoCAgIBwhAtRAgF+AX8gACAAKQOQAUEDEEkiAkKAgICAcINCgICAgOAAUgRAIAFCIIinQXVPBEAgAaciAyADKAIAQQFqNgIACyAAIAJBNCABQQMQGRoLIAILlQEBA38jAEEQayIEJAAgBCACNwMIIAEoAgAiBSABKAIEIgY2AgQgBiAFNgIAIAFCADcCACAAIAAgAUEgaiADQQN0aikDAEKAgICAMEEBIARBCGoQIRAPIAAgASkDEBAPIAAgASkDGBAPIAAgASkDIBAPIAAgASkDKBAPIAAoAhAiAEEQaiABIAAoAgQRAAAgBEEQaiQAC40BAQN/IwBBEGsiBCQAIAQgATcDCCADQQF0IQZBACEDA0ACQAJAIANBAkYNACAAQcwAQQEgAyAGakEBIARBCGoQzwEiAUKAgICAcINCgICAgOAAUg0BQX8hBSADQQFHDQAgACACKQMAEA8LIARBEGokACAFDwsgAiADQQN0aiABNwMAIANBAWohAwwACwALyAYC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IARuDAILIARBACABQQJPGyADbAwBCyAAQX9zQR92IQQgAUECayEBIAQCfiACBEAgA60iBiABQQN0IgFB5KEEajUCAH5CIIggAUHgoQRqNQIAIAZ+fEIfiAwBCyABQQJ0QYCkBGo1AgAgA61+Qh2IC6dqCyIBayABIABBAEgbC0gBAn8jAEEQayICJABBfyEDAkAgACACQQxqIAEQugENACACKAIMIgNBJWtBXEsNACAAQdmJAUEAEFBBfyEDCyACQRBqJAAgAwt1AQF/AkAgAUKAgICAcINCgICAgOB+UQRADAELAkAgAUKAgICAcFQNACABpyICLwEGQSFHDQAgAikDICIBQoCAgIBwg0KAgICA4H5SDQAMAQsgAEGiLEEAEBVCgICAgOAADwsgAaciACAAKAIAQQFqNgIAIAELrgICAXwBfwJAA0ACQAJAAkACQAJAQQcgAkIgiKciBCAEQQdrQW5JG0EJag4RAgMDAwMDAwMDAAAAAAMDBAEDCyABIALENwMADAULIAJCgICAgMCBgPz/AHwiAkL///////////8Ag0KBgICAgICA+P8AWgRAIAFCADcDAAwFCyACvyIDRAAAAAAAAODDYwRAIAFCgICAgICAgICAfzcDAAwFCyADRAAAAAAAAOBDZARAIAFC////////////ADcDAAwFCyABAn4gA5lEAAAAAAAA4ENjBEAgA7AMAQtCgICAgICAgICAfws3AwAMBAsgASACp0EEakEAEIIDGiAAIAIQDwwDCyAAIAIQjQEiAkKAgICAcINCgICAgOAAUg0BCwsgAUIANwMAQX8PC0EAC7ECAQJ/IwBBIGsiBCQAAkACQAJAIAIoAgxFBEACQAJAAkACQCACKAIIQf7///8Haw4CAQACCyAAEDUMAgsgAigCBA0DCyAAIAIQRBoLQQAhAiABRQ0DIAFCABAwGgwDCyACKAIERQ0BCyAAEDVBASECIAFFDQEgAUIAEDAaDAELIAAgAiACKAIIQQFqQQJtQQEQkQYgAEEBENEBGiABIgNFBEAgACgCACEDIARCADcCGCAEQoCAgICAgICAgH83AhAgBCADNgIMIARBDGohAwsgAyAAIABB/////wNBARBDGiADIAMoAgRBAXM2AgQgAyADIAJB/////wNBARDLARpBICECIAMoAghB/////wdHBEAgAygC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AkEAEI0FIQVBECEEA0AgA0E0aiILIAJBACAEIAVqIglBAWoiB0HgDxD8AiALIAsgA0EgaiAHQeAPEENyIgdBIHENAyAHQRBxRQ0CIANBNGogAygCPEEBIAkQ4QMNAiAEQQJtIARqIQQMAAsACyADQTRqIANBIGoQRA0BDAMLIANBNGpBARDRAUEgcUUNAgsgA0E0ahAbDAQLIANByABqIANBNGogAiAFIAUQjAUMAQsgAygCTCEFIANByABqIANBNGogAiAIIAgQjAUgAygCTCIJIAVBAWoiAiACIAlJG0EBayEIIAMoAkghByAFIQQDQAJAIAkgBCICQQFqIgRNBEAgCCECDAELIAIgB2otAABBMEcNACAEIAdqLQAAQS5HDQELCyACIAVNDQAgBSAHaiACIAdqIAkgAmsQnAEgAyAFIAJrIAlqNgJMCyADQTRqEBsLIANByABqQQAQESADKAJUDQAgAygCSAwBC0EAIAMoAkgiAkUNABogCigCACACQQAgCigCBBEBABpBAAshBCAGIAw2AgQgACAGIANBDGoQXiAERQRAIAAQfAwBCyAAIAQQYiENIAAoAtgBIgAoAgAgBEEAIAAoAgQRAQAaCyADQeAAaiQAIA0Lw3UCEn8BfiMAQaAGayIDJAAgASgCyAEiBEEAIARBAEobIQYDQCACIAZGRQRAIAEoAswBIAJBA3RqQX82AgQgAkEBaiECDAELCyABKAI8BEAgASgCzAFBfjYCDAtBACECIAEoAnwiBkEAIAZBAEobIQYCfgJAAkADQCACIAZGBEACQEECIQJBAiAEIARBAkwbIQgDQAJAIAIgCEYEQEEAIQIDQCACIAZGDQICQCABKAJ0IAJBBHRqIgQoAghBAE4NACAEKAIEIghBAkgNACAEIAEoAswBIgQgBCAIQQN0aigCAEEDdGooAgQ2AggLIAJBAWohAgwACwALIAEoAswBIgcgAkEDdGoiBCgCBEEASARAIAQgByAEKAIAQQN0aigCBDYCBAsgAkEBaiECDAELCwJAIAEoAkRFDQACQCABKAIgDQAgAS0AbkEBcQ0AIAEgACABQdIAEE82ApABIAEoAjxFDQAgASAAIAFB0wAQTzYClAELAkAgASgCTCIIRQ0AIAEoAqgBQQBIBEAgASAAIAEQygM2AqgBCyABKAKsAUEASARAIAEgACAB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KAIAEB0gAkHAABARIAIgACAJKAIMEBgQHSACIBEQEQsgACAJKAIMEBMgBEEBaiEEDAALAAtBhSlBrvwAQYzyAUH7ORAAAAtBmoIBQa78AEHY6wFB3/QAEAAAC0GuhAFBrvwAQZvrAUHf9AAQAAALA0AgAiAOTkUEQCADQYAGaiACIA1qIgQgBC0AAEECdEGAuAFqLQAAIgQQciACIARqIQIMAQsLIAwQ9gEgDCADKQOQBjcCECAMIAMpA4gGNwIIIAwgAykDgAY3AgAMDAsgDBD2ASAMIAMpA5AGNwIQIAwgAykDiAY3AgggDCADKQOABjcCAAJAIAEoAowCDQAgASgCpAIhDSADIAEoAvACNgKYBiADIAEoAoACIgk2AtwFIAMgASgChAIiCzYC4AUgACgCECECIANCADcDiAYgA0IANwOABiADIAI2ApQGIANBOzYCkAYgASgC0AIiAgRAIAEgASgCACACQQR0EF8iAjYCzAIgAkUNDQsCQCABKALcAiICRQ0AIAEtAG5BAnENACABIAEoAgAgAkEDdBBfIgI2AtgCIAJFDQ0gAUEANgLoAiABIAEoAvACNgLkAgsgASgCtAFBAE4EQCADQYAGaiICQQwQESACQQQQESACQdkAIAEoArQBEF0LIAEoArABQQBOBEAgA0GABmoiAkEMEBEgAkECEBEgAkHZACABKAKwARBdCyABKAKsAUEATgRAIANBgAZqIgJBDBARIAJBAxARIAJB2QAgASgCrAEQXQsCQCABKAKoAUEASA0AIAEoAmAEQCADQYAGaiICQeEAEBEgAiABLwGoARAqDAELIANBgAZqIgJBCBARIAJB2QAgASgCqAEQXQsgASgCmAFBAE4EQEEAIQIgAS0AbkEBcUUEQCABKAI4QQBHIQILIANBgAZqIgRBDBARIAQgAhARIAEoApwBIgJBAE4EQCADQYAGakHaACACEF0LIANBgAZqQdkAIAEoApgBEF0LIAEoAqABQQBOBEAgA0GABmoiAkEMEBEgAkECEBEgAkHZACABKAKgARBdCyABKAKQAUEATgRAIANBgAZqIgJBDBARIAJBBRARIAJB2QAgASgCkAEQXQsgASgClAFBAE4EQCADQYAGaiICQQwQESACQQUQESACQdkAIAEoApQBEF0LQQAhAgJAA0ACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAiALTgRAQQAhAiABKAKsAiIEQQAgBEEAShshBANAIAIgBEYNAiACQRRsIQYgAkEBaiECIAYgDWooAhBFDQALQdWDAUGu/ABB/foBQZQ4EAAACyACIAIgCWoiBi0AACIFQQJ0QYC4AWotAAAiB2ohBAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgBUHYAGsOIBASGhESGhESGhoaGhoaGhoaBAQBAwIaGgwMBQUFBQUFAAsCQCAFQQFrDhUJCgoLGg0HGggIGhoaBhoaDxoaGg4ACyAFQSJrIghBH0sNGEEBIAh0IgpBwOEBcQ0SIApBBXFFBEAgCEEfRw0ZIAYoAAFBMEcNGiABIAMoAoQGIAMoApgGEDMgA0GABmpB6QEQESAEIQIMIwsgBi8AASECIANCqICAgHA3A1AgA0HcBWogBCADQdAAahAnBEACQCADKALoBSIEQQBIBEAgAygCmAYhBAwBCyADIAQ2ApgGCyABIAMoAoQGIAQQMyADQYAGaiAFQQFqIAIQXSABIAkgCyADKALkBSADQZgGahCkAiECDCMLIAEgAygChAYgAygCmAYQMyADQYAGaiAFIAIQXSAEIQIMIgsgBigAASEFIAQhBgwWCyAGKAABIQdB7QAhBQwUCyAGKAABIQdB7AAhBQwTCyABIAYoAAEgA0GcBmpBABDHAyEHIAMoAtwFIAMoAuAFIAQgBxDGAwRAIAEgB0F/EGkaIANBgAZqQQ4QESAEIQIMHwsgA0LrgICAcDcDYCADQdwFaiAEIANB4ABqECdFDRIgAygC6AUhCCADKALcBSADKALgBSADKALkBSIGIAcQxgNFDRIgCEEATgRAIAMgCDYCmAYLIAEgB0F/EGkaIAVBA3MhBSADKAL0BSEHDBwLIAYtAAkhCCAGKAABIQcgASAGKAAFIANBnAZqQQAQxwMiAkEASA0PIAIgASgCrAJODQ8gASADKAKEBiADKAKYBhAzIAEgASgC1AIiBkEBajYC1AIgASgCzAIgBkEEdGoiBkEENgIEIAYgBTYCACADKAKEBiEKIAYgAjYCDCAGIApBBWo2AgggA0GABmoiBiAFEBEgBiAHEB0gBiANIAJBFGxqIgIoAgwgAygChAZrEB0gAigCDEF/RgRAIAAgAiADKAKEBkEEa0EEEOgCRQ0dCyADQYAGaiAIEBEgBCECDB0LIANCqYCAgHA3A3AgA0HcBWogBCADQfAAahAnRQ0TIAQhAiADKALoBSIEQQBIDRwgAyAENgKYBgwcCyADQquBgIBwNwOgASADQdwFaiAEIANBoAFqECcEQAJAIAMoAugFIgJBAEgEQCADKAKYBiECDAELIAMgAjYCmAYLIAEgAygChAYgAhAzIANBgAZqQfMBEBEMGAsgA0F/NgKYASADQqyBgICQzRo3A5ABIANB3AVqIAQgA0GQAWoQJ0UNAAJAIAMoAugFIgVBAEgEQCADKAKYBiEFDAELIAMgBTYCmAYLIAEgAygChAYgBRAzIANBgAZqQfMBEBEgAygC7AVBA3MhBQwYCyADQunUgYBwNwOAASADQdwFaiAEIANBgAFqECdFDREgBUEKRiEKDA0LAkAgBigAASIGQYCAgIB4ckGAgICAeEYNACADQoyBgIBwNwPgASADQdwFaiAEIANB4AFqECdFDQAgAygC6AUiAkEATgRAIAMgAjYCmAYLIANCjoCAgHA3A9ABIANB3AVqIAMoAuQFIANB0AFqECcEQCADKALoBSICQQBIDRcgAyACNgKYBgwXCyABIAMoAoQGIAMoApgGEDMgA0GABmpBACAGaxDFAwwWCyADQo6AgIBwNwPAASADQdwFaiAEIANBwAFqECcEQCADKALoBSICQQBIDRYgAyACNgKYBgwWCyADQunUgYBwNwOwASADQdwFaiAEIANBsAFqECcEQCAGQQBHIQoMDQsgASADKAKEBiADKAKYBhAzIANBgAZqIAYQxQMgBCECDBkLIAYoAAEiAkH/AUoNDyABIAMoAoQGIAMoApgGEDMgA0GABmoiBiAFQcMAa0H/AXEQESAGIAJB/wFxEBEgBCECDBgLIAYoAAEhAiADQo6AgIBwNwPwASADQdwFaiAEIANB8AFqECcEQCAAIAIQEyADKALoBSICQQBIDRQgAyACNgKYBgwUCyACQS9HDQ4gASADKAKEBiADKAKYBhAzIANBgAZqQcEBEBEgBCECDBcLIANCyYCAgHA3A6gCIANC2Lb5gnA3A6ACIANB3AVqIAQiAiADQaACahAnDRYgA0F/NgKYAiADQoGEkICQCTcDkAIgA0HcBWogAiADQZACahAnDRYgA0F/NgKIAiADQoaO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DQMgAyAGKAABNgKYBiAEIQIMDAsgBigAASICQQBIDQMgAiABKAKsAk4NAyANIAJBFGxqIggoAgxBf0cNBCAIIAMoAoQGNgIMIAgoAhAhBwNAIAciAgRAIAgoAgwgAigCBCIFayEGIAIoAgAhBwJAAkACQAJAIAIoAghBAWsOBAIBAwADCyADKAKABiAFaiAGNgAADAILIAZBgIACakGAgARPDQkgAygCgAYgBWogBjsAAAwBCyAGQYABakGAAk8NCSADKAKABiAFaiAGOgAACyAAKAIQIgZBEGogAiAGKAIEEQAADAELCyAIQQA2AhAgBCECDAsLIANCjoCAgHA3A6gFIANC2bj9gnA3A6AFIANB3AVqIAQgA0GgBWoQJwRAIAMoAugFIgJBAE4EQCADIAI2ApgGCyADIAMoAvAFIgY2ApQFIANBfzYCmAUgAyADKALsBSIEQQFrNgKQBSADQdwFaiADKALkBSICIANBkAVqECcEQCADKALoBSICQQBOBEAgAyACNgKYBgsgBEEBaiEEIAMoAuQFIQILIAEgAygChAYgAygCmAYQMyADQYAGaiIHIAVBAmtB/wFxEBEgByAEIAYQXQwLCyADQo6AgIBwNwOIBSADQpiAgICw6A43A4AFIANB3AVqIAQgA0GABWoQJwRAAkAgAygC6AUiAkEASARAIAMoApgGIQIMAQsgAyACNgKYBgsgASADKAKEBiACEDMgA0GABmoiAiAFQQJrQf8BcRARIAIgAy0A7AUQESACIAMoAvwFEB0MBwsgA0KOgICAcDcD+AQgA0KZgICAkAk3A/AEIANB3AVqIAQgA0HwBGoQJ0UNAQJAIAMoAugFIgJBAEgEQCADKAKYBiECDAELIAMgAjYCmAYLIAEgAygChAYgAhAzIANBgAZqIgIgBUECa0H/AXEQESACQckAEBEMBgsgA0F/NgLIBSADQoSAgICwlevUqn83A8AFIANB3AVqIAQgA0HABWoQJ0UNACADKALoBSIIQQBOBEAgAyAINgKYBgsgAygC7AUhCCADKAL8BSIFQcUARgR/QfQBBSAFQRtHDQFB9QELIQogCEF9cUGpAUYEQCABIAMoAoQGIAMoApgGEDMgA0GABmogChARIAAgAygC/AUQEwwGCyADQumAgIBwNwOwBSADQdwFaiADKALkBSADQbAFahAnRQ0A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DAELIAEgAzYCACACIAY2AgBBACEECyAHQRBqJAAgBAvCAwEJfyABKAIIIgZBACAGQQBKGyEFAkACQANAIAQgBUYNASAEQQJ0IQcgBEEBaiEEIAcgASgCAGooAgAgAkcNAAtBACEFDAELQX8hBSAAIAFBBCABQQRqIAZBAWoQeA0AIAEgASgCCCIEQQFqNgIIIAEoAgAgBEECdGogAjYCACABQRBqIQkgAUEMaiEHQQAhBQNAAkAgAigCICAFTARAQQAhBUEAIQQDQCAEIAIoAixODQQgBEECdCEDIARBAWohBCAAIAEgAigCECADIAIoAihqKAIAQQN0aigCBEEBEK8FRQ0ACwwBCwJAIANBACACKAIcIAVBFGxqIgYoAhAiCkEWRhsNAEEAIQQgASgCFCIIQQAgCEEAShshCwJAAkADQCAEIAtGDQEgCiAHKAIAIARBDGxqIgwoAgBHBEAgBEEBaiEEDAELCyAEQQBODQELIAAgB0EMIAkgCEEBahB4DQIgASABKAIUIgRBAWo2AhQgASgCDCAEQQxsaiIEIAYoAhA2AgACQCADRQRAIAYoAghFDQELIARBADYCCAwCCyAEIAY2AggMAQsgDEEANgIICyAFQQFqIQUMAQsLQX8PCyAFC2gCAn8BfiAAQRBqIQIgACkCBCIEp0H/////B3EhAwJAIARCgICAgAiDUEUEQEEAIQADQCAAIANGDQIgAiAAQQF0ai8BACABQYcCbGohASAAQQFqIQAMAAsACyACIAMgARCyBSEBCyABCxIAIAAgASACIANBgIABENABGgssAQF/A0AgASADRkUEQCAAIANqLQAAIAJBhwJsaiECIANBAWohAwwBCwsgAgvOAQIDfwF+IAEgAkEBELIFIgNB/////wNxIQUgACgCNCAAKAIkQQFrIANxQQJ0aiEDA0AgAygCACIERQRAQQAPCwJAIAAoAjggBEECdGooAgAiAykCBCIGQiCIp0H/////A3EgBUcgBkKAgICAgICAgECDQoCAgICAgICAwABSciAGp0H/////B3EgAkcgBkKAgICACINCAFJycg0AIANBEGogASACEGENACAEQd4BTgRAIAMgAygCAEEBajYCAAsgBA8LIANBDGohAwwACwALfwEEfyABLQAAQdsARgRAIAFBAWoiAxA/QQFrIQIgACgCECgCOCEEQdABIQEDQCABQd4BRwRAAkAgBCABQQJ0aigCACIFKAIEQf////8HcSACRw0AIAVBEGogAyACEGENACAAIAEQGA8LIAFBAWohAQwBCwsQAQALIAAgARCqAQusAgMCfwJ+AXwjAEEgayICJABEAAAAAAAA+H8hBiAAKAIIQf////8HRwRAIAAoAgAhAyACQgA3AhggAkKAgICAgICAgIB/NwIQIAIgAzYCDCACQQxqIAAQRBoCfiACKAIUIgBB/f///wdMBEAgAkEMakE1QcgEEM4BGiACKAIUIQALQoCAgICAgID4/wAgAEH+////B0YNABogAEGAgICAeEYEQEIADAELIAIoAhwhAwJ+IAIoAhhBAkYEQCADKQIADAELIAM1AgBCIIYLIQQgAEGCeEwEQCAEQY54IABrrYghBEIADAELIARCC4hC/////////weDIQQgAEH+B2qtQjSGCyEFIAQgBYQgAjUCEEI/hoS/IQYgAkEMahAbCyABIAY5AwAgAkEgaiQACw4AIABCgICAgPB+EIAGC+4PAwt/A34BfCMAQUBqIhAkAEHfAEGAAiAEQSBxGyEJIARBgANxIQsCQAJAAkACfwJAAkACQAJAAkACQAJAAkACQCABLQAAIgZBK2sOAwEDAAMLQQEhDiABQQFqIQEMAQsgAUEBaiEBCyAEQYAIcUUNASABLQAAIQYLIAZB/wFxQTBHDQACQAJAAkAgAS0AASIHQfgARwRAIAdB7wBGDQIgB0HYAEcNAQsgA0FvcQ0FIAFBAmohB0EQIQMMCQsgAyAHQc8AR3INAQwFCyADRQ0EDAMLAkACQCAHQeIARwRAIANFIAdBwgBGcQ0BIAMgB0Ewa0H/AXFBCUtyDQQgBEEQcQ0CDAcLIAMNBAsgBEEEcUUNBUECIQMgAUECaiEHDAcLIAFBAWohB0EBIQYDQCABIAZqIQMgBkEBaiEGIAMtAAAiCEH4AXFBMEYNAAtBCCEDQYACIQlBASEKIAhB/gFxQThGDQQMBgsgBEEBcSALQYACckGAAkdyDQAgAUEIaiEHQfUcIQYgASEIA0AgBkH9HEcEQCAILQAAIAYtAABHDQIgBkEBaiEGIAhBAWohCAwBCwsgC0GAAkYEQCAAELYFIhFCgICAgHCDQoCAgIDgAFEEQEKAgICA4AAhEQwJCyARp0EEaiAOEIwBDAgLRAAAAAAAAPD/RAAAAAAAAPB/IA4bIhS9IhECfyAUmUQAAAAAAADgQWMEQCAUqgwBC0GAgICAeAsiBre9UQRAIAatIREMCAtCgICAgMB+IBFCgICAgMCBgPz/AH0gEUL///////////8Ag0KAgICAgICA+P8AVhshEQwHCyABIgcgA0UNAxoMBQsgASEHDAQLIARBBHFFDQAgAUECaiEHQQghAwwCCyABCyEHQQohAwwBC0KAgICAwH4hESAHLQAAEJYBIANPDQELQQAhBiADQQpHIQwgByEBA0ACQCAGIAdqIg0tAAAiCMAhDyAIEJYBIANOBEAgCSAPRw0BAkAgDCAGQQFHcg0AIA1BAWstAABBMEcNAEEBIQYMAgsgDS0AARCWASADTg0BCyAHIAZBAWoiBmohAQwBCwtBACEMAkACQCAEQQFxDQACQCAIQS5HDQAgDS0AASEIIAZFBEAgCBCWASADTg0BCyANQQFqIQFCgICAgMB+IREgCSAIwEYNAgNAAkAgCEH/AXEQlgEgA0gEQCABLQABIQgMAQtBASEMIAkgCMBHDQIgAS0AASIIEJYBIANODQILIAFBAWohAQwACwALIAEgB00NAAJAIAEtAAAiBkHlAEcEQCADQQpGIAZBxQBGcQ0BIAZBIHJB8ABHIANBEEtyDQJBASADdEGEggRxDQEMAgsgA0EKRw0BC0EBIQwgAUEBaiEGAkACQAJAIAEtAAFBK2sOAwACAQILIAFBAmohBgwBCyABQQJqIQYLIAYtAABBOmtBdkkNACAGIQEDQCABIgZBAWohASAGLQABIgjAIQ0gCEE6a0F1Sw0AIAkgDUcNASAGLQACQTprQXVLDQALCyABIAdGBEBCgICAgMB+IREMAQsgECEJAkAgASAHayINQQJqIg9BwQBPBEAgACgCECIGQRBqIA8gBigCABEDACIJRQ0BC0EAIQZBACEIIA4EQCAJQS06AABBASEICyANQQAgDUEAShshDgNAIAYgDkZFBEAgBiAHai0AACINQd8ARwRAIAggCWogDToAACAIQQFqIQgLIAZBAWohBgwBCwsgCCAJakEAOgAAAn4CQAJAIARBwABxBEACQAJAAkACQCABLQAAQewAaw4DAQIAAwsgAUEBaiEBQYABIQsMBQsgAUEBaiEBQYACIQsMBAsgAUEBaiEBQYADIQsM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IAFBEGohAgJ/IAdCgICAgAiDUCIFRQRAIAIvAQAMAQsgAi0AAAsiAUEwayIDQQlLDQACfwJAIAFBMEcEQEEBIQEDQCABIARGDQICfyAFRQRAIAIgAUEBdGovAQAMAQsgASACai0AAAtBMGsiBkEJSw0EIAFBAWohASAGrSADrUIKfnwiB6chAyAHQoCAgIAQVA0ACwwDC0EAIgMgBEEBRw0BGgsgACADNgIAQQELDwtBAAupAgIDfwF+AkAgACACEDhFDQAgAqciBC8BBkEORgRAIAAgASAEKAIgKQMAENAFDwsgAUKAgICAcFQNAAJAIAAgAkE7IAJBABAUIgJC/////29YBEBBfyEDIAJCgICAgHCDQoCAgIDgAFENASAAQcYwQQAQFQwBCyABpyEEIAKnIQUCQANAAkAgBCgCECgCLCIDRQRAQQAhAyAELwEGQTBHDQQgBCAEKAIAQQFqNgIAIAStQoCAgIBwhCEBA0AgACABEIwCIgFCgICAgHCDIgZCgICAgCBRDQRBfyEDIAZCgICAgOAAUQ0FIAGnIAVGBEAgACABEA8MAwsgABB7RQ0ACyAAIAEQDwwECyADIgQgBUcNAQsLQQEhAwwBC0EAIQMLIAAgAhAPCyADC9IDAgJ+An8jAEEgayIEJAACQCABQv///////////wCDIgNCgICAgICAwIA8fSADQoCAgICAgMD/wwB9VARAIAFCBIYgAEI8iIQhAyAAQv//////////D4MiAEKBgICAgICAgAhaBEAgA0KBgICAgICAgMAAfCECDAILIANCgICAgICAgIBAfSECIABCgICAgICAgIAIUg0BIAIgA0IBg3whAgwBCyAAUCADQoCAgICAgMD//wBUIANCgICAgICAwP//AFEbRQRAIAFCBIYgAEI8iIRC/////////wODQoCAgICAgID8/wCEIQIMAQtCgICAgICAgPj/ACECIANC////////v//DAFYNAEIAIQIgA0IwiKciBUGR9wBJDQAgBEEQaiAAIAFC////////P4NCgICAgICAwACEIgIgBUGB9wBrEGcgBCAAIAJBgfgAIAVrEI4CIAQpAwhCBIYgBCkDACIAQjyIhCECIAQpAxAgBCkDGIRCAFKtIABC//////////8Pg4QiAEKBgICAgICAgAhaBEAgAkIBfCECDAELIABCgICA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cINCgICAgJB/UXFFBEAgAEGN9wBBABAVDAELIAAgAUESEGUiAUKAgICAcINCgICAgOAAUQ0AIAGnIgQgAz4CJCAEIAI+AiAgACABQdUAQgBBAhAZGiABDwsgACADEA8gACACEA9CgICAgOAACw0AIAAgAUHOlQEQ/wMLZwEBfwJAIAFBAE4EQCAAKAIQIgIoAiwgAU0NASACKAI4IAFBAnRqKAIAIgEgASgCAEEBajYCACAAIAFBBBCABA8LQfKRAUGu/ABBzhdBmdIAEAAAC0HZ3wBBrvwAQc8XQZnSABAAAAtEAQF/IABB+AFqIQIgAEH0AWohAAN/IAAgAigCACICRgRAQQAPCyABIAJBBGsoAgBGBH8gAkEIawUgAkEEaiECDAELCwtSAgJ/AX4CQCAAKAIQKAKMASIBRQ0AIAEpAwgiA0KAgICAcFQNACADpyIBLwEGEO4BRQ0AIAEoAiAiAS0AEkEEcUUNACAAIAEoAkAQGCECCyACC6oPAgV/D34jAEHQAmsiBSQAIARC////////P4MhCyACQv///////z+DIQogAiAEhUKAgICAgICAgIB/gyENIARCMIinQf//AXEhCAJAAkAgAkIwiKdB//8BcSIJQf//AWtBgoB+TwRAIAhB//8Ba0GBgH5LDQELIAFQIAJC////////////AIMiDEKAgICAgIDA//8AVCAMQoCAgICAgMD//wBRG0UEQCACQoCAgICAgCCEIQ0MAgsgA1AgBEL///////////8AgyICQoCAgICAgMD//wBUIAJCgICAgICAwP//AFEbRQRAIARCgICAgICAIIQhDSADIQEMAgsgASAMQoCAgICAgMD//wCFhFAEQCADIAJCgICAgICAwP//AIWEUARAQgAhAUKAgICAgIDg//8AIQ0MAwsgDUKAgICAgIDA//8AhCENQgAhAQwCCyADIAJCgICAgICAwP//AIWEUARAQgAhAQwCCyABIAyEUARAQoCAgICAgOD//wAgDSACIAOEUBshDUIAIQEMAgsgAiADhFAEQCANQoCAgICAgMD//wCEIQ1CACEBDAILIAxC////////P1gEQCAFQcACaiABIAogASAKIApQIgYbeSAGQQZ0rXynIgZBD2sQZ0EQIAZrIQYgBSkDyAIhCiAFKQPAAiEBCyACQv///////z9WDQAgBUGwAmogAyALIAMgCyALUCIHG3kgB0EGdK18pyIHQQ9rEGcgBiAHakEQayEGIAUpA7gCIQsgBSkDsAIhAwsgBUGgAmogC0KAgICAgIDAAIQiEkIPhiADQjGIhCICQgBCgICAgLDmvIL1ACACfSIEQgAQZiAFQZACakIAIAUpA6gCfUIAIARCABBmIAVBgAJqIAUpA5gCQgGGIAUpA5ACQj+IhCIEQgAgAkIAEGYgBUHwAWogBEIAQgAgBSkDiAJ9QgAQZiAFQeABaiAFKQP4AUIBhiAFKQPwAUI/iIQiBEIAIAJCABBmIAVB0AFqIARCAEIAIAUpA+gBfUIAEGYgBUHAAWogBSkD2AFCAYYgBSkD0AFCP4iEIgRCACACQgAQZiAFQbABaiAEQgBCACAFKQPIAX1CABBmIAVBoAFqIAJCACAFKQO4AUIBhiAFKQOwAUI/iIRCAX0iAkIAEGYgBUGQAWogA0IPhkIAIAJCABBmIAVB8ABqIAJCAEIAIAUpA6gBIAUpA6ABIgwgBSkDmAF8IgQgDFStfCAEQgFWrXx9QgAQZiAFQYABakIBIAR9QgAgAkIAEGYgBiAJIAhraiEGAn8gBSkDcCITQgGGIg4gBSkDiAEiD0IBhiAFKQOAAUI/iIR8IhBC5+wAfSIUQiCIIgIgCkKAgICAgIDAAIQiFUIBhiIWQiCIIgR+IhEgAUIBhiIMQiCIIgsgECAUVq0gDiAQVq0gBSkDeEIBhiATQj+IhCAPQj+IfHx8QgF9IhNCIIgiEH58Ig4gEVStIA4gDiATQv////8PgyITIAFCP4giFyAKQgGGhEL/////D4MiCn58Ig5WrXwgBCAQfnwgBCATfiIRIAogEH58Ig8gEVStQiCGIA9CIIiEfCAOIA4gD0IghnwiDlatfCAOIA4gFEL/////D4MiFCAKfiIRIAIgC358Ig8gEVStIA8gDyATIAxC/v///w+DIhF+fCIPVq18fCIOVq18IA4gBCAUfiIYIBAgEX58IgQgAiAKfnwiCiALIBN+fCIQQiCIIAogEFatIAQgGFStIAQgClatfHxCIIaEfCIEIA5UrXwgBCAPIAIgEX4iAiALIBR+fCILQiCIIAIgC1atQiCGhHwiAiAPVK0gAiAQQiCGfCACVK18fCICIARUrXwiBEL/////////AFgEQCAWIBeEIRUgBUHQAGogAiAEIAMgEhBmIAFCMYYgBSkDWH0gBSkDUCIBQgBSrX0hCkIAIAF9IQsgBkH+/wBqDAELIAVB4ABqIARCP4YgAkIBiIQiAiAEQgGIIgQgAyASEGYgAUIwhiAFKQNofSAFKQNgIgxCAFKtfSEKQgAgDH0hCyABIQwgBkH//wBqCyIGQf//AU4EQCANQoCAgICAgMD//wCEIQ1CACEBDAELAn4gBkEASgRAIApCAYYgC0I/iIQhCiAEQv///////z+DIAatQjCGhCEMIAtCAYYMAQsgBkGPf0wEQEIAIQEMAgsgBUFAayACIARBASAGaxCOAiAFQTBqIAwgFSAGQfAAahBnIAVBIGogAyASIAUpA0AiAiAFKQNIIgwQZiAFKQM4IAUpAyhCAYYgBSkDICIBQj+IhH0gBSkDMCIEIAFCAYYiAVStfSEKIAQgAX0LIQQgBUEQaiADIBJCA0IAEGYgBSADIBJCBUIAEGYgDCACIAIgAyACQgGDIgEgBHwiA1QgCiABIANWrXwiASASViABIBJRG618IgJWrXwiBCACIAIgBEKAgICAgIDA//8AVCADIAUpAxBWIAEgBSkDGCIEViABIARRG3GtfCICVq18IgQgAiAEQoCAgICAgMD//wBUIAMgBSkDAFYgASAFKQMIIgNWIAEgA1Ebca18IgEgAlStfCANhCENCyAAIAE3AwAgACANNwMIIAVB0AJqJAALyDIDEX8HfgF8IwBBEGsiECQAIwBBoAFrIg8kACAPIAA2AjwgDyAANgIUIA9BfzYCGCAPQRBqIgIQmgQjAEEwayIOJAADQAJ/IAIoAgQiACACKAJoRwRAIAIgAEEBajYCBCAALQAADAELIAIQVQsiBRCOBg0AC0EBIQMCQAJAIAVBK2sOAwABAAELQX9BASAFQS1GGyEDIAIoAgQiACACKAJoRwRAIAIgAEEBajYCBCAALQAAIQUMAQsgAhBVIQULAkACQAJAA0AgBkHsHGosAAAgBUEgckYEQAJAIAZBBksNACACKAIEIgAgAigCaEcEQCACIABBAWo2AgQgAC0AACEFDAELIAIQVSEFCyAGQQFqIgZBCEcNAQwCCwsgBkEDRwRAIAZBCEYNASAGQQRJDQIgBkEIRg0BCyACKQNwIhJCAFkEQCACIAIoAgRBAWs2AgQLIAZBBEkNACASQgBTIQADQCAARQRAIAIgAigCBEEBazYCBAsgBkEBayIGQQNLDQALC0IAIRIjAEEQayIFJAACfiADskMAAIB/lLwiA0H/////B3EiAEGAgIAEa0H////3B00EQCAArUIZhkKAgICAgICAwD98DAELIAOtQhmGQoCAgICAgMD//wCEIABBgICA/AdPDQAaQgAgAEUNABogBSAArUIAIABnIgBB0QBqEGcgBSkDACESIAUpAwhCgICAgICAwACFQYn/ACAAa61CMIaECyETIA4gEjcDACAOIBMgA0GAgICAeHGtQiCGhDcDCCAFQRBqJAAgDikDCCESIA4pAwAhEwwBCwJAAkAgBg0AQQAhBgNAIAZB4NEAaiwAACAFQSByRw0BAkAgBkEBSw0AIAIoAgQiACACKAJoRwRAIAIgAEEBajYCBCAALQAAIQUMAQsgAhBVIQULIAZBAWoiBkEDRw0ACwwBCwJAAkAgBg4EAAEBAgELAkAgBUEwRw0AAn8gAigCBCIAIAIoAmhHBEAgAiAAQQFqNgIEIAAtAAAMAQsgAhBVC0FfcUHYAEYEQCADIQBBACEDIwBBsANrIgQkAAJ/AkAgAigCBCIFIAIoAmhHBEAgAiAFQQFqNgIEIAUtAAAhAwwBC0EADAELQQELIQYDQAJAAkACQAJAAn4CQAJAAn8gBkUEQCACEFUMAQsgA0EwRwRAQoCAgICAgMD/PyETIANBLkYNA0IADAQLIAIoAgQiBSACKAJoRg0BQQEhCyACIAVBAWo2AgQgBS0AAAshA0EBIQYMBwtBASELDAQLAn8gAigCBCIDIAIoAmhHBEAgAiADQQFqNgIEIAMtAAAMAQsgAhBVCyIDQTBGDQFBASEMQgALIRYMAQsDQCAVQgF9IRVBASEMAn8gAigCBCIDIAIoAmhHBEAgAiADQQFqNgIEIAMtAAAMAQsgAhBVCyIDQTBGDQALQQEhCwsDQCADQSByIQoCQAJAIANBMGsiBUEKSQ0AIANBLkYgCkHhAGtBBklyRQRAIAMhBgwFC0EuIQYgA0EuRw0AIAwNBEEBIQwgEiEVDAELIApB1wBrIAUgA0E5ShshAwJAIBJCB1cEQCADIAdBBHRqIQcMAQsgEkIcWARAIARBMGogAxB5IARBIGogFyATQgBCgICAgICAwP0/EC4gBEEQaiAEKQMwIAQpAzggBCkDICIXIAQpAygiExAuIAQgBCkDECAEKQMYIBQgFhBwIAQpAwghFiAEKQMAIRQMAQsgA0UgCHINACAEQdAAaiAXIBNCAEKAgICAgICA/z8QLiAEQUBrIAQpA1AgBCkDWCAUIBYQcCAEKQNIIRZBASEIIAQpA0AhFAsgEkIBfCESQQEhCwsgAigCBCIDIAIoAmhHBH8gAiADQQFqNgIEIAMtAAAFIAIQVQshAwwACwALQQAhBgwBCwsCfiALRQRAAkAgAikDcEIAUw0AIAIgAigCBCIDQQJrNgIEIAxFDQAgAiADQQNrNgIECyAEQeAAaiAAt0QAAAAAAAAAAKIQqwEgBCkDYCEUIAQpA2gMAQsgEkIHVwRAIBIhEwNAIAdBBHQhByATQgF8IhNCCFINAAsLAkACQAJAIAZBX3FB0ABGBEAgAhCHBiITQoCAgICAgICAgH9SDQMgAikDcEIAWQ0BDAILQgAhEyACKQNwQgBTDQILIAIgAigCBEEBazYCBAtCACETCyAHRQRAIARB8ABqIAC3RAAAAAAAAAAAohCrASAEKQNwIRQgBCkDeAwBCyAVIBIgDBtCAoYgE3xCIH0iEkKzCFkEQEGg1ARBxAA2AgAgBEGgAWogABB5IARBkAFqIAQpA6ABIAQpA6gBQn9C////////v///ABAuIARBgAFqIAQpA5ABIAQpA5gBQn9C////////v///ABAuIAQpA4ABIRQgBCkDiAEMAQsgEkLsdVkEQCAHQQBOBEADQCAEQaADaiAUIBZCAEKAgICAgIDA/79/EHAgFCAWQoCAgICAgID/PxDpBSEDIARBkANqIBQgFiAEKQOgAyAUIANBAE4iAxsgBCkDqAMgFiADGxBwIBJCAX0hEiAEKQOYAyEWIAQpA5ADIRQgB0EBdCADciIHQQBODQALCwJ+QTUgEkLSCHwiE6ciA0EAIANBAEobIBNCNVkbIgNB8QBPBEAgBEGAA2ogABB5IAQpA4gDIRUgBCkDgAMhF0IADAELIARB4AJqRAAAAAAAAPA/QZABIANrENoBEKsBIARB0AJqIAAQeSAEQfACaiAEKQPgAiAEKQPoAiAEKQPQAiIXIAQpA9gCIhUQiQYgBCkD+AIhGCAEKQPwAgshEyAEQcACaiAHIAdBAXFFIBQgFkIAQgAQ7QFBAEcgA0EgSXFxIgBqEIYCIARBsAJqIBcgFSAEKQPAAiAEKQPIAhAuIARBkAJqIAQpA7ACIAQpA7gCIBMgGBBwIARBoAJqIBcgFUIAIBQgABtCACAWIAAbEC4gBEGAAmogBCkDoAIgBCkDqAIgBCkDkAIgBCkDmAIQcCAEQfABaiAEKQOAAiAEKQOIAiATIBgQggQgBCkD8AEiFSAEKQP4ASITQgBCABDtAUUEQEGg1ARBxAA2AgALIARB4AFqIBUgEyASpxCIBiAEKQPgASEUIAQpA+gBDAELQaDUBEHEADYCACAEQdABaiAAEHkgBEHAAWogBCkD0AEgBCkD2AFCAEKAgICAgIDAABAuIARBsAFqIAQpA8ABIAQpA8gBQgBCgICAgICAwAAQLiAEKQOwASEUIAQpA7gBCyESIA4gFDcDECAOIBI3AxggBEGwA2okACAOKQMYIRIgDikDECETDAQLIAIpA3BCAFMNACACIAIoAgRBAWs2AgQLIAUhACADIQZBACEDIwBBkMYAayIBJAACQAJ/A0AgAEEwRwRAAkAgAEEuRw0EIAIoAgQiACACKAJoRg0AIAIgAEEBajYCBCAALQAADAMLBSACKAIEIgAgAigCaEcEf0EBIQMgAiAAQQFqNgIEIAAtAAAFQQEhAyACEFULIQAMAQsLIAIQVQshAEEBIQggAEEwRw0AA0AgEkIBfSESAn8gAigCBCIAIAIoAmhHBEAgAiAAQQFqNgIEIAAtAAAMAQsgAhBVCyIAQTBGDQALQQEhAwsgAUEANgKQBiAOAn4CQAJAAkAgAEEuRiIFIABBMGsiDUEJTXIEQANAAkAgBUEBcQRAIAhFBEAgEyESQQEhCAwCCyADRSEFDAQLIBNCAXwhEyAHQfwPTARAIAsgE6cgAEEwRhshCyABQZAGaiAHQQJ0aiIDIAoEfyAAIAMoAgBBCmxqQTBrBSANCzYCAEEBIQNBACAKQQFqIgAgAEEJRiIAGyEKIAAgB2ohBwwBCyAAQTBGDQAgASABKAKARkEBcjYCgEZB3I8BIQsLAn8gAigCBCIAIAIoAmhHBEAgAiAAQQFqNgIEIAAtAAAMAQsgAhBVCyIAQS5GIgUgAEEwayINQQpJcg0ACwsgEiATIAgbIRIgA0UgAEFfcUHFAEdyRQRAAkAgAhCHBiIUQoCAgICAgICAgH9SDQBCACEUIAIpA3BCAFMNACACIAIoAgRBAWs2AgQLIBIgFHwhEgwDCyADRSEFIABBAEgNAQsgAikDcEIAUw0AIAIgAigCBEEBazYCBAsgBUUNAEGg1ARBHDYCACACEJoEQgAhE0IADAELIAEoApAGIgBFBEAgASAGt0QAAAAAAAAAAKIQqwEgASkDACETIAEpAwgMAQsgEiATUiATQglVckUEQCABQTBqIAYQeSABQSBqIAAQhgIgAUEQaiABKQMwIAEpAzggASkDICABKQMoEC4gASkDECETIAEpAxgMAQsgEkKaBFkEQEGg1ARBxAA2AgAgAUHgAGogBhB5IAFB0ABqIAEpA2AgASkDaEJ/Qv///////7///wAQLiABQUBrIAEpA1AgASkDWEJ/Qv///////7///wAQLiABKQNAIRMgASkDSAwBCyASQut1VwRAQaDUBEHEADYCACABQZABaiAGEHkgAUGAAWogASkDkAEgASkDmAFCAEKAgICAgIDAABAuIAFB8ABqIAEpA4ABIAEpA4gBQgBCgICAgICAwAAQLiABKQNwIRMgASkDeAwBCyAKBEAgCkEITARAIAFBkAZqIAdBAnRqIgAoAgAhCQNAIAlBCmwhCSAKQQFqIgpBCUcNAAsgACAJNgIACyAHQQFqIQcLAkAgCyASpyIISiALQQhKciAIQRFKcg0AIAhBCUYEQCABQcABaiAGEHkgAUGwAWogASgCkAYQhgIgAUGgAWogASkDwAEgASkDyAEgASkDsAEgASkDuAEQLiABKQOgASETIAEpA6gBDAILIAhBCEwEQCABQZACaiAGEHkgAUGAAmogASgCkAYQhgIgAUHwAWogASkDkAIgASkDmAIgASkDgAIgASkDiAIQLiABQeABakEAIAhrQQJ0QeDBBGooAgAQeSABQdABaiABKQPwASABKQP4ASABKQPgASABKQPoARDjBSABKQPQASETIAEpA9gBDAILIAhBEU5BACABKAKQBiIAIAhBfWxB0ABqdhsNACABQeACaiAGEHkgAUHQAmogABCGAiABQcACaiABKQPgAiABKQPoAiABKQPQAiABKQPYAhAuIAFBsAJqIAhBAnRBmMEEaigCABB5IAFBoAJqIAEpA8ACIAEpA8gCIAEpA7ACIAEpA7gCEC4gASkDoAIhEyABKQOoAgwBCwNAIAFBkAZqIAciAEEBayIHQQJ0aigCAEUNAAsCQCAI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AAEiAjoAASAAQQFqIQAgAUEBaiEBIAINAAsLC/UBAgF/AX4jAEHQAGsiAyQAAkACfiABQQBIBEAgAyABQf////8HcTYCACADQRBqIgFBwABB3CIgAxBOGiAAIAEQYgwBCyAAKAIQIgAoAiwgAU0NAQJAAkAgACgCOCIAIAFBAnRqKAIAIgEpAgQiBEKAgICAgICAgECDQoCAgICAgICAwABRDQAgAkUNASAEp0GAgICAeEcNACAAKAK8ASEBCyABIAEoAgBBAWo2AgAgAa1CgICAgJB/hAwBCyABIAEoAgBBAWo2AgAgAa1CgICAgIB/hAshBCADQdAAaiQAIAQPC0Hv3wBBrvwAQZgYQYfiABAAAAvrAgECfyAAIAEoAgQQEwNAIAEoAhAhAyACIAEoAhRORQRAIAAgAyACQQN0aigCABATIAJBAWohAgwBCwsgACgCECICQRBqIAMgAigCBBEAAEEAIQIDQAJAIAEoAhwhAyACIAEoAiBODQAgAyACQRRsaiIDKAIIRQRAIAAoAhAgAygCBBDrAQsgACADKAIQEBMgACADKAIMEBMgAkEBaiECDAELCyAAKAIQIgJBEGogAyACKAIEEQAAIAAoAhAiAkEQaiABKAIoIAIoAgQRAABBACECA0AgASgCNCEDIAIgASgCOE5FBEAgACADIAJBDGxqKAIEEBMgAkEBaiECDAELCyAAKAIQIgJBEGogAyACKAIEEQAAIAAgASkDQBAPIAAgASkDSBAPIAAgASkDYBAPIAAgASkDaBAPIAEoAggiAiABKAIMIgM2AgQgAyACNgIAIAFCADcCCCAAKAIQIgBBEGogASAAKAIEEQAACzABAX8gACgCOCABQQJ0aigCACIBIAEoAgAiAkEBazYCACACQQFMBEAgACABEKIDCwvAAQIBfwJ+QX8hAwJAIABCAFIgAUL///////////8AgyIEQoCAgICAgMD//wBWIARCgICAgICAwP//AFEbDQAgAkL///////////8AgyIFQoCAgICAgMD//wBWIAVCgICAgICAwP//AFJxDQAgACAEIAWEhFAEQEEADwsgASACg0IAWQRAIAEgAlIgASACU3ENASAAIAEgAoWEQgBSDwsgAEIAUiABIAJVIAEgAlEbDQAgACABIAKFhEIAUiEDCyADCwoAIABBfHEQpAMLZQEEfwNA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sgEhAyAAIAIQDyAAIAAgA0HdwAAQsgEiAiADQQEgARAhIQQgACACEA8gACADEA8gBAsMACAAIAEpAwAQswELygYCBH8DfiMAQYABayIFJAACQAJAAkAgAyAEQgBCABDtAUUNAAJ/IARC////////P4MhCgJ/IARCMIinQf//AXEiBkH//wFHBEBBBCAGDQEaQQJBAyADIAqEUBsMAgsgAyAKhFALCyEGIAJCMIinIghB//8BcSIHQf//AUYNACAGDQELIAVBEGogASACIAMgBBAuIAUgBSkDECICIAUpAxgiASACIAEQ4wUgBSkDCCECIAUpAwAhBAwBCyABIAJC////////////AIMiCiADIARC////////////AIMiCRDtAUEATARAIAEgCiADIAkQ7QEEQCABIQQMAgsgBUHwAGogASACQgBCABAuIAUpA3ghAiAFKQNwIQQMAQsgBEIwiKdB//8BcSEGIAcEfiABBSAFQeAAaiABIApCAEKAgICAgIDAu8AAEC4gBSkDaCIKQjCIp0H4AGshByAFKQNgCyEEIAZFBEAgBUHQAGogAyAJQgBCgICAgICAwLvAABAuIAUpA1giCUIwiKdB+ABrIQYgBSkDUCEDCyAJQv///////z+DQoCAgICAgMAAhCELIApC////////P4NCgICAgICAwACEIQogBiAHSARAA0ACfiAKIAt9IAMgBFatfSIJQgBZBEAgCSAEIAN9IgSEUARAIAVBIGogASACQgBCABAuIAUpAyghAiAFKQMgIQQMBQsgCUIBhiAEQj+IhAwBCyAKQgGGIARCP4iECyEKIARCAYYhBCAHQQFrIgcgBkoNAAsgBiEHCwJAIAogC30gAyAEVq19IglCAFMEQCAKIQkMAQsgCSAEIAN9IgSEQgBSDQAgBUEwaiABIAJCAEIAEC4gBSkDOCECIAUpAzAhBAwBCyAJQv///////z9YBEADQCAEQj+IIQEgB0EBayEHIARCAYYhBCABIAlCAYaEIglCgICAgICAwABUDQALCyAIQYCAAnEhBiAHQQBMBEAgBUFAayAEIAlC////////P4MgB0H4AGogBnKtQjCGhEIAQoCAgICAgMDDPxAuIAUpA0ghAiAFKQNAIQQMAQsgCUL///////8/gyAGIAdyrUIwhoQhAgsgACAENwMAIAAgAjcDCCAFQYABaiQAC4sDAgJ+A38jAEEgayICJABCgICAgOAAIQQCQCAAIAMpAwAiBRBgDQAgACABQTEQZSIBQoCAgIBwg0KAgICA4ABRDQAgAAJ+AkAgAEEgEF8iBkUNAEEAIQMgBkEANgIUIAZBADYCAANAIANBAkZFBEAgBiADQQN0aiIHIAdBBGoiCDYCCCAHIAg2AgQgA0EBaiEDDAELCyAGQoCAgIAwNwMYIAFCgICAgHBaBEAgAacgBjYCIAsgACACQRBqIAEQpAUNAAJAIAAgBUKAgICAMEECIAJBEGoQISIFQoCAgIBwg0KAgICA4ABRBEAgACgCECIDKQOAASEEIANCgICAgCA3A4ABIAIgBDcDCCAAIAIpAxhCgICAgDBBASACQQhqECEhBCAAIAIpAwgQDyAEQoCAgIBwg0KAgICA4ABRDQEgACAEEA8LIAAgBRAPIAAgAikDEBAPIAEhBCACKQMYDAILIAAgAikDEBAPIAAgAikDGBAPQoCAgIDgACEECyABCxAPCyACQSBqJAAgBAuSCwIHfgV/IwBBEGsiAiQAIARB5aYBai0AACINrSEJAkACQAJAIAMpAwAiBkL/////b1gEQEKAgICA4AAhBSAAIAJBCGogBhCmAQ0DIABCgICAgDAgAikDCCIHIAmGEPkCIgZCgICAgHCDQoCAgIDgAFENAwwBCwJAAkAgBqciDC8BBiIOQRNrQf//A3FBAU0EQCAMKAIgIQxCgICAgOAAIQUgACACIAMpAwgQpgENBSAMLQAEDQICQCACKQMAIghBfyANdEF/cyINrINQBEAgCCAMKAIAIg6sIgZYDQELIABB+C1BABBQDAYLAkAgAykDECIHQoCAgIBwg0KAgICAMFEEQCANIA5xDQEgBiAIfSAJiCEHDAMLIAAgAkEIaiAHEKYBDQYgDC0ABA0DIAw0AgAgAikDCCIHIAmGIAh8Wg0CCyAAQZLZAEEAEFAMBQsCfgJAAkAgAEKAgICAMAJ+AkACQAJ+AkACQAJAIA5BFWtB//8DcUEKTQRAIAAgASAEEGUiBUKAgICAcINCgICAgOAAUQ0PAkACQCAMKAIgIg8oAgwiAygCICINLQAERQRAIAwoAighDkKAgICAMCEBIA0tAAVFBEAgACADrUKAgICAcIRCgICAgDAQ4wEiAUKAgICAcINCgICAgOAAUQ0DCyAAIAEgDq0iCCAJhhD5AiEHIAAgARAPIAdCgICAgHCDQoCAgIDgAFENAiAMKAIgKAIMKAIgLQAERQ0BIAAgBxAPCyAAEGsMAQtBACEDAkAgB0KAgICAcFQNACAHpyIQLwEGQRNHDQAgECgCICEDCyAAIAUgB0IAIAgQ2wMNACAMLwEGIARGDQJBACEEA0AgBCAORg0RIAAgBiAEELABIgFCgICAgHCDQoCAgIDgAFENASAAIAUgBCABEKUBIQMgBEEBaiEEIANBAE4NAAsLIAAgBRAPDA4LQoCAgIDgACEFIAAgASAEEGUiCkKAgICAcINCgICAgOAAUQ0OQoCAgIAwIQUgACAGQdEBIAZBABAUIgtCgICAgHCDIgdCgICAgCBRIAdCgICAgDBRcg0BQoCAgIDgACEBIAdCgICAgOAAUQ0IQQAhAyAAED4iB0KAgICAcINCgICAgOAAUQ0FIAAgBiALEPoDIgVCgICAgHCDQoCAgIDgAFEEQEKAgICAMAwECyAAIAVB6gAgBUEAEBQiBkKAgICAcINCgICAgOAAUQ0CQQAhBANAIAAgBSAGIAJBCGoQrgEiCEKAgICAcINCgICAgOAAUQ0DIAIoAggEQCAEIQMgByEBDAYLIAAgByAErSAIQYCAARDSAUEASARAIAYhCCAFIQYgByEFDAYFIARBAWohBAwBCwALAAsgAygCCCANKAIIIA8oAhBqIAMoAgAQHxoMDQsgACACQQhqIAYQPA0GIAwgDCgCAEEBajYCACAGIQEgAikDCAwECyAGCyEIIAUhBiAHIQULIAAgCBAPIAAgBhAPIAAgBRAPCyAAIAsQDyABQoCAgIBwg0KAgICA4ABRDQEgA60LIgUgCYYQ+QIiBkKAgICAcINCgICAgOAAUQ0AIAAgCiAGQgAgBRDbAw0AQQAhBANAIAogBK0gBVkNAxogACABIAQQsAEiBkKAgICAcINCgICAgOAAUQ0BIAAgCiAEIAYQpQEhAyAEQQFqIQQgA0EATg0ACwsgASEFCyAAIAUQDyAKIQFCgICAgOAACyEFIAAgARAPDAQLIAMpAwAiBkIgiKdBdUkNASAGpyIDIAMoAgBBAWo2AgAMAQsgABBrDAILIAAgASAEEGUiAUKAgICAcINCgICAgOAAUQRAIAAgBhAPDAILIAAgASAGIAggBxDbA0UEQCABIQUMAgsgACABEA8LQoCAgIDgACEFCyACQRBqJAAgBQsPACAAIAEgAkEAQQMQlgIL9AECA34BfwJAIAMpAwAiBEKAgICAcFoEQCADKQMIIgVC/////29WDQELIAAQJEKAgICA4AAPC0KAgICA4AAhBiAAQoCAgIAgQTAQSSIBQoCAgIBwg0KAgICA4ABSBH4gAEEYECkiAkUEQCAAIAEQD0KAgICA4AAPCyAEpyIDIAMoAgBBAWo2AgAgAiAENwMAIAWnIgcgBygCAEEBajYCACACIAU3AwggACAEEDghACACQQA6ABEgAiAAOgAQIAFCgICAgHBaBEAgAaciACACNgIgIAAgAC0ABUHvAXEgAy0ABUEQcXI6AAULIAEFQoCAgIDgAAsLXgEBfwJAIAFCgICAgHBUDQAgAaciBC8BBiADRw0AIAQoAiAiBEUNACAEKQMAIgFCgICAgGBaBEAgACABpyACEQAACyAEKQMIIgFCgICAgGBUDQAgACABpyACEQAACwtKAQF/AkAgAUKAgICAcFQNACABpyIDLwEGIAJHDQAgAygCICIDRQ0AIAAgAykDABAjIAAgAykDCBAjIABBEGogAyAAKAIEEQAACws4AQF/IABBMGsiBEEKTwR/IABBwQBrIANNBEAgAEE3aw8LIAIgAEHXAGsgAEHhAGsgAU8bBSAECwtLAQF/IABBGBApIgJFBEBCgICAgOAADwsgAkEBNgIAIAAoAtgBIQAgAkIANwIQIAJCgICAgICAgICAfzcCCCACIAA2AgQgAq0gAYQLkQIAIABFBEBBAA8LAn8CQCABQf8ATQ0AAkBBiNUEKAIAKAIARQRAIAFBgH9xQYC/A0YNAgwBCyABQf8PTQRAIAAgAUE/cUGAAXI6AAEgACABQQZ2QcABcjoAAEECDAMLIAFBgEBxQYDAA0cgAUGAsANPcUUEQCAAIAFBP3FBgAFyOgACIAAgAUEMdkHgAXI6AAAgACABQQZ2QT9xQYABcjoAAUEDDAMLIAFBgIAEa0H//z9NBEAgACABQT9xQYABcjoAAyAAIAFBEnZB8AFyOgAAIAAgAUEGdkE/cUGAAXI6AAIgACABQQx2QT9xQYABcjoAAUEEDAMLC0Gg1ARBGTYCAEF/DAELIAAgAToAAEEBCwvEAgACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCABQQlrDhIACgsMCgsCAwQFDAsMDAoLBwgJCyACIAIoAgAiAUEEajYCACAAIAEoAgA2AgAPCwALIAIgAigCACIBQQRqNgIAIAAgATIBADcDAA8LIAIgAigCACIBQQRqNgIAIAAgATMBADcDAA8LIAIgAigCACIBQQRqNgIAIAAgATAAADcDAA8LIAIgAigCACIBQQRqNgIAIAAgATEAADcDAA8LAAsgAiACKAIAQQdqQXhxIgFBCGo2AgAgACABKwMAOQMADwsgACACIAMRAAALDwsgAiACKAIAIgFBBGo2AgAgACABNAIANwMADwsgAiACKAIAIgFBBGo2AgAgACABNQIANwMADwsgAiACKAIAQQdqQXhxIgFBCGo2AgAgACABKQMANwMAC14BBH8gACgCACECA0AgAiwAACIDENECBEBBfyEEIAAgAkEBaiICNgIAIAFBzJmz5gBNBH9BfyADQTBrIgMgAUEKbCIEaiADIARB/////wdzShsFQX8LIQEMAQsLIAEL3BICEn8BfiMAQdAAayIIJAAgCCABNgJMIAhBN2ohFyAIQThqIRICQAJAAkACQANAIAEhDCAHIA5B/////wdzSg0BIAcgDmohDgJAAkACQCAMIgctAAAiCQRAA0ACQAJAIAlB/wFxIgFFBEAgByEBDAELIAFBJUcNASAHIQkDQCAJLQABQSVHBEAgCSEBDAILIAdBAWohByAJLQACIQogCUECaiIBIQkgCkElRg0ACwsgByAMayIHIA5B/////wdzIhhKDQcgAARAIAAgDCAHEFsLIAcNBiAIIAE2AkwgAUEBaiEHQX8hDwJAIAEsAAEiChDRAkUNACABLQACQSRHDQAgAUEDaiEHIApBMGshD0EBIRMLIAggBzYCTEEAIQ0CQCAHLAAAIglBIGsiAUEfSwRAIAchCgwBCyAHIQpBASABdCIBQYnRBHFFDQADQCAIIAdBAWoiCjYCTCABIA1yIQ0gBywAASIJQSBrIgFBIE8NASAKIQdBASABdCIBQYnRBHENAAsLAkAgCUEqRgRAAn8CQCAKLAABIgEQ0QJFDQAgCi0AAkEkRw0AIAFBAnQgBGpBwAFrQQo2AgAgCkEDaiEJQQEhEyAKLAABQQN0IANqQYADaygCAAwBCyATDQYgCkEBaiEJIABFBEAgCCAJNgJMQQAhE0EAIRAM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IAgoAgRBAWsiBzYCBCAEIAlqQRBqIQQgBw0JIAAgACgCMEEBazYCMAwJCyAHCyEFIARBAWohBAwACwALIANBACAEQQFGGw0EQQAhCSADDQAgBEECRg0DCyAAIAU2AjAMAAsACyAJDwsgASAIQRBqIAAoAgxBA3QQHxoLIAgoAgghBSAIKAIMIQQgAiAIIAAoAgxBA3RqQRBqIAgtAAEiA0ECdBAfGiAAIAAoAjBBAWs2AjAMAAsAC4sCAQd/IAFBAnRBwP4DaigCACICIAFBAXRBkIAEai8BAGohCEEAIQECQANAIAIgCE8NASACQQFqIQYCQAJAIAItAAAiBEE/TQRAIAMgBEEDdmpBAWohAiABBEAgACADIAIQfg0DCyABQQFzIQEgBEEHcSACakEBaiEFDAELAn8gAyAEakH/AGsgBMBBAEgNABogBi0AACEFIARB3wBNBEAgAkECaiEGIAMgBEEIdGogBWpB//8AawwBCyACQQNqIQYgAi0AAiADIARBEHRqIAVBCHRqakH///8CawshBSADIQILIAEEQCAAIAIgBRB+DQELIAFBAXMhASAGIQIgBSEDDAELC0F/IQcLIAcLOABBsNQCIAEQrwQiAUEASARAQX4PCyAAIAFBHU0Ef0IBIAGthqcFIAFBAnRB2NgCaigCAAsQoQYLNQEBfyMAQRBrIgMkACADIAE2AgggAyACQQFqNgIMIAAgA0EIakECELEEIQAgA0EQaiQAIAALlwIBA38gASgCACICQf7/B08EQCAAQYY7QQAQOkF/DwsCQCACQQFNBEAgAEECQX8QuAEaDAELIAEoAgggAkECdGoiBEEEaygCACIDQX9GBEAgBEEIaygCACEDCyACQQF2IQIgA0H//wNNBEAgAEEVIAIQsgRBACECA0AgAiABKAIATg0CIAAgAkECdCIDIAEoAghqLwEAECogAEF/IAEoAgggA0EEcmooAgBBAWsiAyADQX5GG0H//wNxECogAkECaiECDAALAAsgAEEWIAIQsgRBACECA0AgAiABKAIATg0BIAAgAkECdCIDIAEoAghqKAIAEB0gACABKAIIIANBBHJqKAIAQQFrEB0gAkECaiECDAALAAtBAAsmAQF/IAAoAjgiAUEASARAIAAgACAAQTxqQQAQqwYiATYCOAsgAQvgAgEFfyMAQZABayIEJAAgAUEANgIAIAAoAiAhA0EBIQYDQCAEIAM2AowBAkACQAJAIAAoAhwiByADTQRAIAYhBQwBCwJAAkACQAJAIAMtAAAiBUHbAGsOAgECAAsgBUEoRw0FIAMtAAFBP0cNAiADLQACQTxHDQUgAy0AAyIFQSFGIAVBPUZyDQUgAUEBNgIAAkAgAkUNACAEIANBA2o2AowBIAQgBEGMAWogACgCKBC1BA0AIAQgAhDyA0UNBQsgBkEBaiEFIAZB/QFKDQMgBCgCjAEhAyAFIQYMBQsDQCAEIAMiBUEBaiIDNgKMASADIAdPDQUCQCADLQAAQdwAaw4CAAYBCyAEIAVBAmoiAzYCjAEMAAsACyAEIANBAWoiAzYCjAEMAwsgBkH9AUohByAGQQFqIgUhBiAHRQ0CC0F/IAUgAhshBgsgBEGQAWokACAGDwsgA0EBaiEDDAALAAtVAQN/IAAgAWohBCACED8hA0EBIQEDQAJAIAAgBE8EQEF/IQEMAQsgAyAAED8iBUYEQCACIAAgAxBhRQ0BCyABQQFqIQEgACAFakEBaiEADAELCyABC+QhARd/IwBB4AJrIgIkAEEMIAFrIRYgAUELaiEXIABBxABqIRIgAUETaiEYIABB3ABqIQ8gACgCBCETAkACQAJAA0AgACgCGCIDIAAoAhxPDQMgAy0AACIEQSlGIARB/ABGcg0DIAAoAgQhECACIAM2AhwCQAJAAkACQAJAAkACQAJAAkACfwJAAkACQAJAAkACQAJAAkACQAJAIARB2wBrDgQCAQMIAAsCQAJAAkACQAJAIARBJGsOCwEJCQkECRkZCQkCAAsgBEH7AGsOAwIIBgcLIAIgA0EBaiIINgIcIABBBhARDBQLIAIgA0EBajYCHCAAKAI0IQogAUUNCCAAQRsQESAAQQRBAyAAKAIwGxARDAwLIAAoAigEQCAAQdU/QQAQOgwXCyADLQABQTprQXZJDQUgAiADQQFqNgIgIAJBIGpBARDcAhoCQCACKAIgIgMtAAAiBUEsRw0AIAIgA0EBajYCICADLQABIgVBOmtBdkkNACACQSBqQQEQ3AIaIAIoAiAtAAAhBQsgBUH/AXFB/QBHDQUMFQsCQCADLQABQT9GBEBBAyEHQQAhCkEAIQVBACEGAkACQAJAAkAgAy0AAiIEQTprDgQAAwESAgsgACADQQNqNgIYIAAoAjQhCiAAIAEQ8gINGiACIAAoAhg2AhwgECEDIAAgAkEcakEpELADRQ0SDBoLQQEhBUEEIQcgAy0AAyIEQT1GBEBBASEGDBELQQEhBiAEQSFGDRAgAiADQQNqNgIcIA8gAkEcaiAAKAIoELUEBEAgAEGc5wBBABA6DBoLIBIoAgAgACgCSCAPEKwGQQBKBEAgAEGH5wBBABA6DBoLIBIgDyAPED9BAWoQciAAQQE2AjwMAwsgBEEhRg0PCyAAQcHJAEEAEDoMFwsgAiADQQFqNgIcIBJBABARCyAAKAI0IgpB/wFOBEAgAEGqOUEAEDoMFgsgACAKQQFqNgI0IAAoAgQhAyAAIBcgChCpAiAAIAIoAhw2AhggACABEPICDRUgAiAAKAIYNgIcIAAgFiAKEKkCIAAgAkEcakEpELADRQ0NDBULAkACQAJAAkACQAJAAkAgAy0AASIEQTBrDhMDBAQEBAQEBAQECgoKCgoKCgoBAAsgBEHrAEYNASAEQeIARw0JCyAAQRFBEiAEQeIARhsQESADQQJqIQgMEgsCQCADLQACQTxHBEBB8uYAIQUgACgCKA0BIAAQtAQNAQwJCyACIANBA2o2AiAgDyACQSBqIAAoAigQtQQEQEGc5wAhBSAAKAIoDQEgABC0BA0BDAkLIBIoAgAgACgCSCAPEKwGIgRBAE4NAyAAIAJBwAJqIA8QqwYiBEEATg0DQfv5ACEFIAAoAigNACAAELQERQ0ICyAAIAVBABA6DBgLIAIgA0ECajYCHCADLQACIQYgACgCKARAQQAhBCAGQTprQXZJDQggAEHIzQBBABA6DBgLQQAhBCAGQfgBcUEwRw0HIAIgA0EDajYCHCAGQTBrIQQgAy0AAyIGQfgBcUEwRw0HIAIgA0EEajYCHCAEQQN0IAZqQTBrIQQMBwsgAiADQQFqIgU2AhwgAkEcakEAENwCIgRBAE4EQCAEIAAoAjRIDQIgABCqBiAESg0CCyAAKAIoRQRAIAIgBTYCHCAFLQAAIgRBN00EQEEAIQYgBEEzTQRAIAIgA0ECaiIFNgIcIARBMGshBiADLQACIQQLIARB+AFxQTBHBEAgBiEEDAkLIAIgBUEBajYCHCAEQf8BcSAGQQN0akEwayEEIAUtAAEiA0H4AXFBMEcNCCACIAVBAmo2AhwgBEEDdCADakEwayEEDAgLIAIgA0ECajYCHAwHCyAAQfXNAEEAEDoMFgsgAiACKAIgNgIcCyAAKAI0IQogACgCBCEDIAAgGCAEEKkCDAwLIAAoAjQhCiABBEAgAEEbEBELIAAoAkAhBCACQTQ2AtACIAIgBDYCzAIgAkEANgLIAiACQgA3AsACIAIgA0EBaiIHNgLUAiADLQABIgRB3gBHIggNBiACIANBAmoiBzYC1AJBAAwHCyAAKAIoRQ0BIABB1T9BABA6DBILIARBP0YNEAsgACACQQhqIAJBHGpBABCzBCIEQQBIDRALIAAoAjQhCiAAKAIEIQMgAQRAIABBGxARCwJAIARBgICAgAROBEAgACACQQhqEKkGIQQgAigCFCACKAIQQQAgAigCGBEBABogBEUNAQwRCyAAKAIsBEAgBCAAKAIoEN0BIQQLIARB//8DTARAIABBASAEELIEDAELIABBAiAEELgBGgsgAUUNByAAQRsQEQwHCyAAQQRBAyAAKAIwGxARDAQLIAIgA0EBaiIINgIcIABBBRARDAkLQQELIQUDQCAFRQRAIActAAAhBEEBIQUMAQsCQAJAAkACQCAEQf8BcUHdAEcEQCAAIAJBrAJqIAJB1AJqQQEQswQiA0EASA0DAkACQAJAAkAgAigC1AIiBy0AAEEtRw0AIActAAFB3QBGDQAgAiAHQQFqNgIgIANBgICAgARPBEAgACgCKEUNASACKAK4AiACKAK0AkEAIAIoArwCEQEAGgwDCyAAIAJBrAJqIAJBIGpBARCzBCIGQQBIDQcgBkGAgICABEkNASACKAK4AiACKAK0AkEAIAIoArwCEQEAGiAAKAIoDQILIANBgICAgARJDQIgAkHAAmogAigCtAIiAyACKAKsAhCxBCEGIAIoArgCIANBACACKAK8AhEBABogBkUNBwwFCyACIAIoAiAiBzYC1AIgAyAGTQ0DCyAAQabrAEEAEDoMBAsgAkHAAmogAyADEKgGRQ0EDAILIAAoAiwEQCACQTQ2AjAgAiACKALMAjYCLCACQQA2AiggAkIANwIgIAJC4YCAgLAPNwLYAkEBIQUgAkEgaiACKALIAiACKALAAiACQdgCakECQQEQ2wIhBCACKAIoIQMgBEUEQEEAIQUgAigCICIEQQAgBEEAShshBgNAIAUgBkZFBEAgAyAFQQJ0aiIJIAkoAgBBIGs2AgAgBUEBaiEFDAELCyACQcACaiADIAQQsQQhBQsgAigCLCADQQAgAigCMBEBABogBQ0CCyAIRQRAIAJBwAJqENoCDQILIAAgAkHAAmoQqQYNAiACKALMAiACKALIAkEAIAIoAtACEQEAGiACIAdBAWo2AhwgAUUNBgwFCyACQcACaiADIAYQqAZFDQILIAAQqAILIAIoAswCIAIoAsgCQQAgAigC0AIRAQAaDA0LQQAhBQwACwALIABBGxARCyAQIQMMAQsgAyAHaiEHQX8hAwJAIAUNACAAKAIoDQAgACgCNCEKIBAhAwsgAEEYQRcgBEEhRhtBABC4ASEEIAAgBzYCGCAAIAYQ8gINCCACIAAoAhg2AhwgACACQRxqQSkQsAMNCCAAQQoQESAAKAIMDQggACgCACAEaiAAKAIEIARrQQRrNgAACyACKAIcIQggA0EASA0DAkACQAJAAkACQCAILQAAIgRBKmsOAgECAAsgBEE/Rg0CIARB+wBHDQcgCC0AAUE6a0F1Sw0DIAAoAihFDQcMCAsgCEEBaiEIQQAhC0H/////ByEJDAULQQEhCyAIQQFqIQhB/////wchCQwEC0EBIQkgAiAIQQFqIgg2AhxBACELDAMLIAIgCEEBajYCHCACQRxqQQEQ3AIiCyEJAkAgAigCHCIELQAAIgVBLEcNACACIARBAWo2AhxB/////wchCSAELQABIgVBOmtBdkkNACACQRxqQQEQ3AIiCSALSA0FIAIoAhwtAAAhBQsgBUH/AXFB/QBGDQEgACgCKA0BCyACIAg2AhwMAgsgACACQRxqQf0AELADDQUgAigCHCEICwJAAn8gCC0AAEE/RgRAIAIgCEEBaiIINgIcIAAoAgQgA2shB0EAIQVBAAwBCyAAKAIMIQQCQCAJQQBKBEAgBA0DIAAoAgQgA2shByAAKAIAIhEgA2ohDUEAIQVBACEMA0AgBSAHSARAIAUgDWoiDi0AACIUQfCBAmotAAAhBEECIQYCQAJAAkACQCAUQQFrDhYCAgICAwMHBwcHBwcHBwcHAwMHBwEABwtBAyEGCyAOLwABIAZ0IARqIQQLIAxBAWohDAsgBCAFaiEFDAELCyAMQQBMDQEgAEEKEBEgACADQREQ8AENAyAAKAIAIANqQRw6AAAgACgCBCEGIAMgACgCAGoiBCAMNgANIAQgCTYACSAEIAs2AAUgBCAGIANrQRFrNgABDAQLIAQNAiAAKAIEIANrIQcgACgCACERC0EAIQQgAkEgakEAQf8BECsaIAMgEWohFEF+IQ1BACERA0AgBCAHTkUEQCAEIBRqIg4tAAAiBUHwgQJqLQAAIQZBAiEMAkACQAJAAkACQAJAAkACQCAFQQFrDhsCAgICBwcGBgYGAwMEBgcHBwcFBQEABgYHBgcGC0EDIQwLIA4vAAEgDHQgBmohBgtBASANIA1BfkYbIQ0MBAsgDi0AASACQSBqaiIFIAUtAABBAXI6AAAMAwsgDi0AASIFIA4tAAIiDCAFIAxLGyEMA0AgBSAMRg0DIAJBIGogBWoiDiAOLQAAQQFyOgAAIAVBAWohBQwACwALQQEhESAOLQABIAJBIGpqIgUgBS0AAEECcjoAAAwBCyANQQAgDUF+RxshDQsgBCAGaiEEDAELC0EAIQUCfwJAIBFFDQADQCAFQf8BRg0BIAJBIGogBWohBCAFQQFqIQUgBC0AAEEDRw0AC0F/DAELIA1BACANQX5HGwtFIQVBAQshBAJAIAtFBEAgACgCNCAKRwRAIAAgA0EDEPABDQMgACgCACADakENOgAAIAMgACgCAGogCjoAASADIAAoAgBqIAAtADRBAWs6AAIgA0EDaiEDCwJAAkACQCAJDgIAAQILIAAgAzYCBAwFCyAAIANBBRDwAQ0DIAAoAgAgA2ogBEEIcjoAACAAKAIAIANqIAc2AAEMBAsgCUH/////B0YNASAAIANBChDwAQ0CIAAoAgAgA2pBDzoAACAAKAIAIgYgA0EFaiIFaiAEQQhyOgAAIAMgBmogCTYAASADIAAoAgBqIAdBBWo2AAYgAEEOIAUQ3AEgAEEQEBEMAwsgBSALQQFHIAlB/////wdHcnJFBEAgACAEQQlzIAMQ3AEMAwsgC0EBRwRAIAAgA0EFEPABDQIgACgCACADakEPOgAAIAAoAgAgA2ogCzYAASAAQQ4gA0EFaiIDENwBIABBEBARCyAJQf////8HRgRAIAAoAgQhBiAAIARBCHIgBSAHakEFahC4ARogBQRAIABBGRARIAAgAyAHELAEIABBGiAGENwBDAQLIAAgAyAHELAEIABBByAGENwBDAMLIAkgC0wNAiAAQQ8gCSALaxC4ARogACgCBCEGIAAgBEEIciAHQQVqELgBGiAAIAMgBxCwBCAAQQ4gBhDcASAAQRAQEQwCCyAAIAMgBUEFahDwAQ0AIAAoAgAgA2ogBEEIcjoAACAAKAIAIANqIgQgBSAHakEFajYAASAFBEAgBEEZOgAFIABBGiADENwBDAILIABBByADENwBDAELIAAQqAIMBAsgACAINgIYIAFFDQEgACAAKAIEIgMgEGsiECADahDGAQ0DIAAoAgAgE2oiBCAQaiAEIAMgE2sQnAEgACgCACIEIBNqIAMgBGogEBAfGgwBCwsgAEH3KkEAEDoMAQsgAEHuMUEAEDoLQX8hFQsgAkHgAmokACAVC44CAgZ/AX4jAEEQayIDJAACQCABQv////9vWARAIAAQJEF/IQQMAQtBfyEEIAAgAhAlIglCgICAgHCDQoCAgIDgAFENAAJAIAAgA0EMaiADQQhqIAmnQRMQjgFBAEgEQEKAgICAMCECIAMoAgghBiADKAIMIQcMAQtBACEEQoCAgIAwIQIgAygCDCEHIAMoAgghBgNAIAUgBkYNASAAIAIQDyAAIAkgByAFQQN0aiIIKAIEIAlBABAUIgJCgICAgHCDQoCAgIDgAFIEQCAFQQFqIQUgACABIAgoAgQgAkGAgAEQxwRBAE4NAQsLQX8hBAsgACAHIAYQWiAAIAkQDyAAIAIQDwsgA0EQaiQAIAQL2gMCA38EfiMAQTBrIggkAAJAIAAoAhAoAnggCE0EQCADQgAgA0IAVRshDSAFQQFrIQkgBkKAgICAcIMhDiAFQQBMIQpCACEDA0AgAyANUQRAIAQhDAwDC0J/IQwgACACIAMgCEEoahCFASIFQQBIDQICQCAFRQ0AIA5CgICAgDBSBEAgCCAIKQMoNwMAIAMhCyAIIAI3AxAgCCADQoCAgIAIWgR+QoCAgIDAfiADub0iC0KAgICAwIGA/P8AfSALQv///////////wCDQoCAgICAgID4/wBWGwUgCws3AwggCCAAIAYgB0EDIAgQISILNwMoIAAgCCkDABAPIAAgCCkDCBAPIAtCgICAgHCDQoCAgIDgAFENBAsCQAJAAkAgCg0AIAAgCCkDKCILEMoBIgVBAEgNASAFRQ0AIAAgCEEgaiALEDxBAEgNASAAIAEgCyAIKQMgIAQgCUKAgICAMEKAgICAMBCvBiIEQgBTDQEgACALEA8MAwsgBEL/////////D1MNASAAQbHaAEEAEBUgCCkDKCELCyAAIAsQDwwECyAAIAEgBCAIKQMoEGpBAEgNAyAEQgF8IQQLIANCAXwhAwwACwALIAAQ6QFCfyEMCyAIQTBqJAAgDAuZAgEBfgJAAkACQCABQoCAgIBwgyIEQoCAgIAwUgRAIARCgICAgCBSDQEgAEGp1AAQYiEEDAILIABBtvkAEGIhBAwBCyAAIAEQJSIBQoCAgIBwg0KAgICA4ABRDQEgACABEMoBIgNBAEgEQCAAIAEQD0KAgICA4AAPCwJ/QZMBIAMNABpBnQEgACABEDgNABpBkgEgAacvAQYiA0ESS0EBIAN0QfiOEHFFcg0AGiAAKAIQKAJEIANBGGxqKAIECyECIAAgAUHXASABQQAQFCEEIAAgARAPIARCgICAgHCDIgFCgICAgJB/UQ0AIAFCgICAgOAAUQ0BIAAgBBAPIAAgAhAtIQQLIABBu5kBIARBnIABEL4BIQELIAEL0AICBn8BfiMAQTBrIgIkAAJAAkAgAykDACIBQv////9vWARAIAFCIIinQXVJDQEgAaciACAAKAIAQQFqNgIADAELQoCAgIDgACELIAAgARC2AyIDQQBIDQEgA0UEQCAAQfjiAEEAEBUMAgsgACACQSxqIAJBKGogAaciBkEDEI4BDQEgAigCLCEHIAIoAighCEEAIQMCQANAIAMgCEcEQCAHIANBA3RqKAIEIQlBgIIBIQUCQCAERQ0AIAAgAkEIaiAGIAkQTCIKQQBIDQMgCkUNACACKAIIIQUgACACQQhqEEhBgIYBQYCCASAFQQJxGyEFCyAAIAEgCUKAgICAMEKAgICAMEKAgICAMCAFEG1BAEgNAiADQQFqIQMMAQsLIAAgByAIEFogBiAGKAIAQQFqNgIADAELIAAgByAIEFoMAQsgASELCyACQTBqJAAgCwsQAEGimQEgAEELEPsBQQBHC4kBAgN/AX5BlZkBIQMCQAJAIAEpAgQiBqdB/////wdxIgUgAkwNACABQRBqIQQCfyAGQoCAgIAIg1BFBEAgBCACQQF0ai8BAAwBCyACIARqLQAAC0ElRw0AQb0tIQMgAkECaiAFTg0AIAEgAkEBakECELgEIgJBAE4NAQsgACADELkEQX8hAgsgAguLAgIBfgF8IwBBEGsiAiQAQoCAgIDgACEEAkAgACABEN0CIgFCgICAgHCDQoCAgIDgAFEEQCABIQQMAQsgACACIAEQbg0AIAAgAkEMaiADKQMAELoBDQAgAisDACIFvSIBQoCAgICAgID4/wCDQoCAgICAgID4/wBRBEAgAEKAgICAwH4gAUKAgICAwIGA/P8AfSABQv///////////wCDQoCAgICAgID4/wBWGxA3IQQMAQsgAzUCBEIghkKAgICAMFEEQCAAIAVBCkEAQQQQjwIhBAwBCyACKAIMIgNB5QBPBEAgAEGKNEEAEFAMAQsgACAFQQogA0EBakEFEI8CIQQLIAJBEGokACAEC18AIwBBEGsiAiQAAn4gAykDACIBQiCIpyIDBEBCgICAgBAgA0ELakESSQ0BGgtCgICAgOAAIAAgAkEIaiABEEINABogAisDCBC9Aq1CgICAgBCECyEBIAJBEGokACABCyYAQoCAgIDgACAAIAMpAwAQzAUiAEEAR61CgICAgBCEIABBAEgbCy8BAX4CfiADKAIEIgIEQEKAgICAECIEIAJBC2pBEkkNARoLIAAgBCADIAMQvAQLCy8BAX4CfiADKAIEIgIEQEKAgICAECIEIAJBC2pBEkkNARoLIAAgBCADIAMQvQQLCwkAIAAgARC+BAssACAAIAEQvgQiAUKAgICAcINCgICAgOAAUgR+IABBA0ECIAGnGxAtBSABCwvMAgIBfwd+IwBBIGsiBCQAIAAgBEEIakEAED0aQoCAgIDgACEIQoCAgIAwIQUCQAJAAkAgACADKQMAECUiBkKAgICAcINCgICAgOAAUQ0AIAAgACAGQfAAIAZBABAUENwFIgVCgICAgHCDQoCAgIDgAFENACAAIAQgBRA8QQBIDQBCACEBIAQpAwAiB0IAIAdCAFUbIQkgB0IBfSEHIAKsIQoDQCABIAlRDQIgACAAIAUgARBzEDciC0KAgICAcINCgICAgOAAUQ0BIARBCGogCxB/GiABIAdZIQIgAUIBfCEBIAEgClkgAnINACAEQQhqIAMgAadBA3RqKQMAEIcBRQ0ACwsgACAGEA8gACAFEA8gBCgCCCgCECIAQRBqIAQoAgwgACgCBBEAAAwBCyAAIAYQDyAAIAUQDyAEQQhqEDYhCAsgBEEgaiQAIAgLgwICA38BfCMAQSBrIgQkAAJ+AkAgACAEIAIQPQ0AIAJBACACQQBKGyEGAkADQCAFIAZHBEACQCADIAVBA3RqKQMAIgFC/////w9YBEAgAaciAkH//8MATQ0BDAQLIAAgBEEYaiABEEINBCAEKwMYIgdEAAAAAAAAAABjIAdEAAAAAP//MEFkcg0DIAcCfyAHmUQAAAAAAADgQWMEQCAHqgwBC0GAgICAeAsiArdiDQMLIAVBAWohBSAEIAIQuQFFDQEMAwsLIAQQNgwCCyAAQZUrQQAQUAsgBCgCACgCECIAQRBqIAQoAgQgACgCBBEAAEKAgICA4AALIQEgBEEgaiQAIAELnAEBAn8jAEEgayIEJAAgACAEQQhqIAIQPRogAkEAIAJBAEobIQICfgNAIAIgBUcEQAJAIAAgBEEEaiADIAVBA3RqKQMAEHdFBEAgBEEIaiAELwEEEIsBRQ0BCyAEKAIIKAIQIgBBEGogBCgCDCAAKAIEEQAAQoCAgIDgAAwDCyAFQQFqIQUMAQsLIARBCGoQNgshASAEQSBqJAAgAQubAwIDfwJ+IwBBIGsiAiQAQoCAgIDgACEIAkAgACABEFkiAUKAgICAcINCgICAgOAAUQ0AIAAgAkEIaiIFQQcQPRogBUE8EDsaIAUgBEEDdCIFQYDrAWooAgAiBhCIARpBnj0gBHZBAXFFBEAgAkEIaiIEQSAQOxogBCAFQYTrAWooAgAQiAEaIARBrpkBEIgBGiAAIAMpAwAQWSIJQoCAgIBwg0KAgICA4ABRBEAgACABEA8gAigCCCgCECIAQRBqIAIoAgwgACgCBBEAAAwCCyAJpyIHQRBqIQVBACEEA0AgBCAHKQIEIginQf////8HcU9FBEACQAJ/IAhCgICAgAiDUEUEQCAFIARBAXRqLwEADAELIAQgBWotAAALIgNBIkYEQCACQQhqQaCJARCIARoMAQsgAkEIaiADEIsBGgsgBEEBaiEEDAELCyAAIAkQDyACQQhqQSIQOxoLIAJBCGoiAEE+EDsaIAAgARB/GiAAQbqQARCIARogACAGEIgBGiACQQhqQT4QOxogABA2IQgLIAJBIGokACAIC5MEAgh/AX4jAEEwayIFJAACQCAAIAEQWSIBQoCAgIBwg0KAgICA4ABRDQAgAaciBygCBEH/////B3EiAkUNAAJAIAAgBUEUaiACED0NAEEAIQIgBUEANgIQIAdBEGohCANAAkAgBykCBCINp0H/////B3EiCSACSgRAAn8CQCAERSAHIAVBEGoQyQEiCkGjB0dyDQAgBSgCECILQQFrIQIDQAJAIAJBAEwEQEEAIQYMAQsgAkEBayEDAkAgDUKAgICACINQRQRAIAggA0EBdGovAQAiBkGA+ANxQYC4A0cgAkECSXINASAIIAJBAmsiAkEBdGovAQAiDEGA0ABqQf//A3FBgAhLDQEgBkH/B3EgDEH/B3FBCnRyQYCABGohBgwCCyADIAhqLQAAIQYLIAMhAgsgBhDABA0ACyAGEL8ERQ0AIAUgCzYCLAJAA0AgBSgCLCAJTg0BIAcgBUEsahDJASICEMAEDQALIAIQvwQNAQsgBUHCBzYCBEEBDAELIAVBBGogCiAEELIDCyEDQQAhAgNAIAIgA0YNAiACQQJ0IQYgAkEBaiECIAVBFGogBiAFQQRqaigCABC5AUUNAAsMAwsgACABEA8gBUEUahA2IQEMAwsgBSgCECECDAALAAsgACABEA8gBSgCFCgCECIAQRBqIAUoAhggACgCBBEAAEKAgICA4AAhAQsgBUEwaiQAIAELdAEBfkKAgICA4AAhBCAAIAEQWSIBQoCAgIBwg0KAgICA4ABSBH4gACADKQMAECgiBEKAgICAcINCgICAgOAAUQRAIAAgARAPQoCAgIDgAA8LIAGnIASnEIMCIQIgACABEA8gACAEEA8gAq0FQoCAgIDgAAsLCQAgACABEPYECxIAIABBsjRBABAVQoCAgIDgAAtqAAJAAkAgAUIgiKciAkF/RwRAIAJBeUcNAQwCCyABpyICLwEGQQVHDQAgAikDICIBQoCAgIBwg0KAgICAkH9SDQAMAQsgAEGi2wBBABAVQoCAgIDgAA8LIAGnIgAgACgCAEEBajYCACABC4QCAgJ/An4gACABEFkiAUKAgICAcINCgICAgOAAUQRAIAEPCyABpyIGKQIEIgenQf////8HcSECAkAgBEEBcUUNACAGQRBqIQMgB0KAgICACIMhCANAIAIgBUYEQCACIQUMAgsCfyAIUEUEQCADIAVBAXRqLwEADAELIAMgBWotAAALEIcDRQ0BIAVBAWohBQwACwALAkAgBEECcUUEQCACIQMMAQsgBkEQaiEEIAdCgICAgAiDIQcDQCACIgMgBUwNASADQQFrIQICfyAHUEUEQCAEIAJBAXRqLwEADAELIAIgBGotAAALEIcDDQALCyAAIAYgBSADEIQBIQcgACABEA8gBwvqAwIGfwN+IwBBIGsiBSQAQoCAgIDgACEMAkAgACABEFkiAUKAgICAcINCgICAgOAAUQ0AAkACQCAAIAVBBGogAykDABC6AQ0AIAUoAgQiByABpyIJKAIEQf////8HcSIITA0BQSAhCkKAgICAMCELAkAgAkECSA0AIAMpAwgiDUKAgICAcINCgICAgDBRDQAgACANECgiC0KAgICAcINCgICAgOAAUQ0BAkACQCALpyIGKQIEIg2nQf////8HcQ4CAAECCyAAIAsQDwwDCwJ/IA1CgICAgAiDUEUEQCAGLwEQDAELIAYtABALIQpBACEGCyAHQYCAgIAETgRAIABBwNoAQQAQRgwBCyAAIAVBCGogBxA9RQRAAkAgBARAIAVBCGogCUEAIAgQUQ0BCyAHIAhrIQMCQCAGBEADQCADQQBMDQIgAyADIAYoAgRB/////wdxIgIgAiADShsiAmshAyAFQQhqIAZBACACEFFFDQAMAwsACyAFQQhqIAogAxDBBA0BCyAERQRAIAVBCGogCUEAIAgQUQ0BCyAAIAsQDyAAIAEQDyAFQQhqEDYhDAwECyAFKAIIKAIQIgJBEGogBSgCDCACKAIEEQAACyAAIAsQDwsgACABEA8MAQsgASEMCyAFQSBqJAAgDAuBBgIFfgV/IwBB0ABrIgIkAAJAAkACQAJAIAFCgICAgBCEQoCAgIBwg0KAgICAMFEEQCAAQZUwQQAQFQwBCyADKQMIIQkgAykDACIFQoCAgIAQhEKAgICAcINCgICAgDBRDQIgBEUNASAAIAUQxARBAE4NAQtCgICAgOAAIQYMAgsgACAFQdQBIAVBABAUIgdCgICAgHCDIgZCgICAgCBRIAZCgICAgDBRcg0AIAZCgICAgOAAUQ0BIAIgCTcDKCACIAE3AyAgACAHIAVBAiACQSBqEC8hBgwBCyAAIAJBCGpBABA9GkKAgICA4AAhBkKAgICAMCEIAkAgACABECgiB0KAgICAcINCgICAgOAAUQRAQoCAgIAwIQUMAQsgACAFECgiBUKAgICAcINCgICAgOAAUQ0AIAAgCRA4Ig5FBEAgACAJECgiCEKAgICAcINCgICAgOAAUQ0BCyAHpyELIAWnIg0pAgQhAQNAAkACQCABQv////8Hg1AEQEEAIQMgDEUNASAKIAsoAgRB/////wdxTw0CIApBAWohAwwBCyALIA0gChDCBCIDQQBODQAgDA0BIAIoAggoAhAiA0EQaiACKAIMIAMoAgQRAAAgACAFEA8gACAIEA8gByEGDAQLIAIgBTcDIAJ+IA4EQCACIAc3AzAgAiADrTcDKCAAIAAgCUKAgICAMEEDIAJBIGoQIRA3DAELIAIgCDcDSCACQoCAgIAwNwNAIAJCgICAgDA3AzggAiAHNwMoIAIgA603AzAgACACQSBqEO0ECyIBQoCAgIBwg0KAgICA4ABRDQIgAkEIaiIMIAsgCiADEFEaIAwgARB/GiANKQIEIgGnQf////8HcSADaiEKQQEhDCAEDQELCyACQQhqIgMgCyAKIAsoAgRB/////wdxEFEaIAAgBRAPIAAgCBAPIAAgBxAPIAMQNiEGDAELIAIoAggoAhAiA0EQaiACKAIMIAMoAgQRAAAgACAFEA8gACAIEA8gACAHEA8LIAJB0ABqJAAgBgu4AgIDfwN+IwBBIGsiAiQAQoCAgIDgACEHAkACQAJAIAAgARBZIgFCgICAgHCDQoCAgIDgAFENACAAIAIgAykDABDiAw0AIAIpAwAiCEKAgICACFoEQCAAQeIqQQAQUAwBCyABpyIEKQIEIgmnIgZB/////wdxIgVFDQEgCKciA0EBRg0BIAlC/////weDIAh+QoCAgIAEWgRAIABBwNoAQQAQRgwBCyAAIAJBCGogAyAFbCAGQR92EIoDDQACQCAFQQFHBEADQCADQQBMDQIgAkEIaiAEQQAgBRBRGiADQQFrIQMMAAsACyACQQhqAn8gBC0AB0GAAXEEQCAELwEQDAELIAQtABALIAMQwQQaCyAAIAEQDyACQQhqEDYhBwwCCyAAIAEQDwwBCyABIQcLIAJBIGokACAHC8EBAgJ/An4jAEEQayIEJABCgICAgOAAIQYCQCAAIAEQWSIBQoCAgIBwg0KAgICA4ABRBEAgASEGDAELAkAgACAEQQxqIAMpAwAgAaciBSgCBEH/////B3EiAiACEFcNACAEIAI2AgggAykDCCIHQoCAgIBwg0KAgICAMFIEQCAAIARBCGogByACIAIQVw0BIAQoAgghAgsgACAFIAQoAgwiAyACIAMgAiADShsQhAEhBgsgACABEA8LIARBEGokACAGC8ABAgN/An4jAEEQayICJABCgICAgOAAIQcCQCAAIAEQWSIBQoCAgIBwg0KAgICA4ABRBEAgASEHDAELAkAgACACQQxqIAMpAwAgAaciBigCBEH/////B3EiBCAEEFcNACACIAQgAigCDCIFayIENgIIIAAgBiAFIAMpAwgiCEKAgICAcINCgICAgDBSBH8gACACQQhqIAggBEEAEFcNASACKAIIBSAECyAFahCEASEHCyAAIAEQDwsgAkEQaiQAIAcL0wECAn8CfiMAQRBrIgIkAEKAgICA4AAhBgJAIAAgARBZIgFCgICAgHCDQoCAgIDgAFEEQCABIQYMAQsCQCAAIAJBDGogAykDACABpyIFKAIEQf////8HcUEAEFcNACACIAUoAgRB/////wdxIgQ2AgggAykDCCIHQoCAgIBwg0KAgICAMFIEQCAAIAJBCGogByAEQQAQVw0BIAIoAgghBAsgACAFIAIoAgwiAyAEIAMgBEgbIAMgBCADIARKGxCEASEGCyAAIAEQDwsgAkEQaiQAIAYLqAUCC34CfyMAQRBrIgIkAAJAIAFCgICAgBCEQoCAgIBwg0KAgICAMFEEQCAAQZUwQQAQFUKAgICA4AAhBwwBCyADKQMIIQYCQCADKQMAIgRCgICAgHCDIglCgICAgBCEQoCAgIAwUQ0AIAAgBEHWASAEQQAQFCIFQoCAgIBwgyIHQoCAgIAgUSAHQoCAgIAwUXINACAHQoCAgIDgAFENASACIAY3AwggAiABNwMAIAAgBSAEQQIgAhAvIQcMAQtCgICAgOAAIQdCgICAgDAhCCAAAn5CgICAgDAgACABECgiCkKAgICAcINCgICAgOAAUQ0AGkKAgICA4AAgABA+IgFCgICAgHCDQoCAgIDgAFENABoCQAJAIAZCgICAgHCDQoCAgIAwUQRAIAJBfzYCAAwBCyAAIAIgBhB3QQBIDQELIAqnIgMpAgQhCyAAIAQQKCIIQoCAgIBwg0KAgICA4ABRDQACQCACKAIAIg9FDQBCACEEAkAgCUKAgICAMFEEQEIAIQUMAQsgCKciECkCBEL/////B4MhBiALQv////8HgyIFUEUEQCAFIAZ9IAZQrSIJfSEMIA+tIQ1CACEFA0ACQCAEIAl8Ig4gDFUNACADIBAgDqcQwgQiD0EASA0AIAAgAyAEpyAPEIQBIgRCgICAgHCDQoCAgIDgAFENBSAAIAEgBSAEQQAQ0gFBAEgNBSAGIA+sfCEEIAVCAXwiBSANUg0BDAQLCyAFQv////8PgyEFDAELQgAhBSAGUA0BCyAAIAMgBKcgC6dB/////wdxEIQBIgRCgICAgHCDQoCAgIDgAFENASAAIAEgBSAEQQAQ0gFBAEgNAQsgACAKEA8gACAIEA8gASEHDAILIAELEA8gACAKEA8gACAIEA8LIAJBEGokACAHC6ADAQR+IwBBMGsiAiQAIAIgATcDKAJAIAFCgICAgBCEQoCAgIBwg0KAgICAMFEEQCAAQZUwQQAQFUKAgICA4AAhBgwBCwJAIAMpAwAiBUKAgICAEIRCgICAgHCDQoCAgIAwUQ0AQoCAgIDgACEGIAAgBSAEIAVBABAUIgdCgICAgHCDIghCgICAgOAAUQ0BAkAgBEHTAUcNACAAIAUQxARBAE4NACAAIAcQDwwCCyAIQoCAgIAQhEKAgICAMFENACAAIAcgBUEBIAJBKGoQLyEGDAELIAIgACABECgiBzcDCEKAgICA4AAhBiAHQoCAgIBwg0KAgICA4ABRDQAgAiAFNwMQAkACQAJ/IARB0wFHBEBCgICAgDAhAUEBDAELIABBp90AEGIiAUKAgICAcINCgICAgOAAUQ0BIAIgATcDGEECCyEDIAAgACkDSCADIAJBEGoQpwEhBSAAIAEQDyAFQoCAgIBwg0KAgICA4ABSDQELIAAgBxAPDAELIAAgBSAEQQEgAkEIahCtAiEGIAAgAikDCBAPCyACQTBqJAAgBguYAwIFfwN+IwBBEGsiBiQAAkAgACABEFkiCkKAgICAcINCgICAgOAAUQRAIAohAQwBCwJAIAAgAykDABDQAyIFBEBCgICAgOAAIQFCgICAgDAhCyAFQQBMDQEgAEH89QBBABAVDAELQoCAgIDgACEBIAAgAykDABAoIgtCgICAgHCDQoCAgIDgAFENACALpyIHKAIEIQggBiAKpyIJKAIEQf////8HcSIFQQAgBEECRhs2AgwCQCACQQJIDQAgAykDCCIMQoCAgIBwg0KAgICAMFENACAAIAZBDGogDCAFQQAQVw0BCyAFIAhB/////wdxIgVrIQICQAJAAkACQCAEDgIAAQILIAYoAgwhAwwCCyAGKAIMIgMgAkohBEKAgICAECEBIAMhAiAERQ0BDAILIAYoAgwgBWsiAyECC0KAgICAECEBIANBAEggAiADSHINAANAIAkgByADQQAgBRCzA0UEQEKBgICAECEBDAILIAIgA0chBCADQQFqIQMgBA0ACwsgACAKEA8gACALEA8LIAZBEGokACABC7ADAwd/AXwBfiMAQRBrIgUkAAJAIAAgARBZIgFCgICAgHCDQoCAgIDgAFENAAJAAkAgACADKQMAECgiDUKAgICAcINCgICAgOAAUQ0AIA2nIgkoAgRB/////wdxIQYgAaciCigCBEH/////B3EhBwJAIAQEQCAFIAcgBmsiCzYCDEF/IQhBACEEIAJBAkgNASAAIAUgAykDCBBCDQIgBSsDACIMvUL///////////8Ag0KAgICAgICA+P8AVg0BIAxEAAAAAAAAAABlBEAgBUEANgIMDAILIAwgC7djRQ0BIAUCfyAMmUQAAAAAAADgQWMEQCAMqgwBC0GAgICAeAs2AgwMAQsgBUEANgIMIAJBAk4EQCAAIAVBDGogAykDCCAHQQAQVw0CCyAHIAZrIQRBASEIC0F/IQIgBiAHSw0BIAQgBSgCDCIDayAIbEEASA0BA0AgCiAJIANBACAGELMDRQRAIAMhAgwDCyADIARGDQIgAyAIaiEDDAALAAsgACABEA8gACANEA9CgICAgOAAIQEMAQsgACABEA8gACANEA8gAq0hAQsgBUEQaiQAIAELkwECAX4BfyMAQRBrIgIkAEKAgICA4AAhBAJAIAAgARBZIgFCgICAgHCDQoCAgIDgAFEEQCABIQQMAQsCQCAAIAJBDGogAykDABC6AQ0AQoCAgIAwIQQgAigCDCIDQQBIDQAgAyABpyIFKAIEQf////8HcU8NACAFIAJBDGoQyQGtIQQLIAAgARAPCyACQRBqJAAgBAtpAgJ/AX4gACABEFkhAQNAIAIgBEwgAUKAgICAcINCgICAgOAAUXJFBEAgAyAEQQN0aikDACIGQiCIp0F1TwRAIAanIgUgBSgCAEEBajYCAAsgBEEBaiEEIAAgASAGEMQCIQEMAQsLIAELyAECAX4BfyMAQRBrIgIkAEKAgICA4AAhBAJAIAAgARBZIgFCgICAgHCDQoCAgIDgAFEEQCABIQQMAQsCQCAAIAJBDGogAykDABC6AQ0AAkAgAigCDCIDQQBOBEAgAyABpyIFKQIEIgSnQf////8HcUkNAQsgAEEvEC0hBAwBCyAFQRBqIQUgAAJ/IARCgICAgAiDUEUEQCAFIANBAXRqLwEADAELIAMgBWotAAALQf//A3EQnwMhBAsgACABEA8LIAJBEGokACAEC7gBAgJ+AX8jAEEQayICJABCgICAgOAAIQQCQCAAIAEQWSIBQoCAgIBwg0KAgICA4ABRBEAgASEEDAELAkAgACACQQxqIAMpAwAQugENAEKAgICAwH4hBCACKAIMIgNBAEgNACADIAGnIgYpAgQiBadB/////wdxTw0AIAZBEGohBiAFQoCAgIAIg1BFBEAgBiADQQF0ajMBACEEDAELIAMgBmoxAAAhBAsgACABEA8LIAJBEGokACAEC+MBAgF+An8jAEEQayICJAACQCAAIAFBLRBLIgNFBEAgBEEANgIAQoCAgIDgACEBDAELQoCAgIAwIQECQCADKQMAIgZCgICAgHCDQoCAgIAwUgRAIAIgAygCDCIFNgIMIAUgBqciBygCBEH/////B3FJDQEgACAGEA8gA0KAgICAMDcDAAsgBEEBNgIADAELIAcgAkEMahDJASEIIAMgAigCDDYCDCAEQQA2AgAgCEH//wNNBEAgACAIQf//A3EQnwMhAQwBCyAAIAcgBUEBdGpBEGpBAhDuAyEBCyACQRBqJAAgAQs3ACMAQRBrIgIkACAAIAJBDGogAykDABB3IQAgAigCDCEDIAJBEGokAEKAgICA4AAgA2etIAAbC04AIwBBEGsiAiQAQoCAgIDgACEBAkAgACACQQxqIAMpAwAQdw0AIAAgAkEIaiADKQMIEHcNACACKAIIIAIoAgxsrSEBCyACQRBqJAAgAQsGACAAtrsLfwAgACAAKQPQASIBQgyIIAGFIgFCGYYgAYUiAUIbiCABhSIBNwPQAUKAgICAwH4gAUKdurP7lJL9oiV+QgyIQoCAgICAgID4P4S/RAAAAAAAAPC/oL0iAUKAgICAwIGA/P8AfSABQv///////////wCDQoCAgICAgID4/wBWGwujBAMDfAV/A34jAEEQayIIJAAgCEIANwMIAkACQCACQQBMDQBCgICAgOAAIQEgACAIQQhqIAMpAwAQQg0BQQEhCSAIKwMIIQQgAkEBRwRAA0AgAiAJRg0CIAAgCCADIAlBA3RqKQMAEEINAyAJQQFqIQkgCCsDACEFIwBBIGsiByQAIAS9Qv///////////wCDIg0gBb1C////////////AIMiDCAMIA1WGyIOvyEEAkAgDkI0iKciCkH/D0YNACANIAwgDCANVBsiDL8hBQJAIA5QDQAgDEI0iKciC0H/D0YNACALIAprQcEATgRAIAUgBKAhBAwCCwJ8IAtB/gtPBEAgBEQAAAAAAAAwFKIhBCAFRAAAAAAAADAUoiEFRAAAAAAAALBrDAELRAAAAAAAAPA/IApBvARLDQAaIAREAAAAAAAAsGuiIQQgBUQAAAAAAACwa6IhBUQAAAAAAAAwFAshBiAHQRhqIAdBEGogBRCKBiAHQQhqIAcgBBCKBiAGIAcrAwAgBysDEKAgBysDCKAgBysDGKCfoiEEDAELIAUhBAsgB0EgaiQADAALAAsgBJkhBAsgBL0iAQJ/IASZRAAAAAAAAOBBYwRAIASqDAELQYCAgIB4CyIAt71RBEAgAK0hAQwBC0KAgICAwH4gAUKAgICAwIGA/P8AfSABQv///////////wCDQoCAgICAgID4/wBWGyEBCyAIQRBqJAAgAQtOACAAIABEAAAAAAAA8L9EAAAAAAAA8D8gAEQAAAAAAAAAAGMbIAC9Qv///////////wCDQoCAgICAgID4/wBWGyAARAAAAAAAAAAAYRsLQwACfCABvUKAgICAgICA+P8Ag0KAgICAgICA+P8AUQRARAAAAAAAAPh/IACZRAAAAAAAAPA/YQ0BGgsgACABEI8DCwuDAQICfgF/IAC9IgFCNIinQf8PcSIDQf4HTQRAIAFCgICAgICAgICAf4MhAiADQf4HRyABQoCAgICAgIDwv39RckUEQCACQoCAgICAgID4P4S/DwsgAr8PCyADQbIITQR8IAFCP4cgAXxCAUGzCCADa62GIgFCAYh8QgAgAX2DvwUgAAsLggUDAnwFfwF+IwBBEGsiCSQAAn5CgICAgMD+//v/AEKAgICAwP7/eyAEGyACRQ0AGgJ8IAMpAwAiAUL/////D1gEQEEBIAIgAkEBTBshCiABpyEIQQEhBwNAIAcgCkcEQCAItyADIAdBA3RqKQMAIgFCgICAgBBaDQMaIAggAaciCyAIIAtKGyAIIAsgCCALSBsgBBshCCAHQQFqIQcMAQsLIAitDAILQoCAgIDgACAAIAlBCGogARBCDQEaQQEhByAJKwMICyEFIAcgAiACIAdIGyECA0AgAiAHRwRAQoCAgIDgACAAIAkgAyAHQQN0aikDABBCDQIaAkAgBb0iDEL///////////8Ag0KAgICAgICA+P8AVg0AIAkrAwAiBr0iAUL///////////8Ag0KAgICAgICA+P8AVgRAIAYhBQwBCyAFRAAAAAAAAAAAYSAGRAAAAAAAAAAAYXEhCiAEBEAgCgRAIAEgDIO/IQUMAgsgBSAFIAalIAa9Qv///////////wCDQoCAgICAgID4/wBWGyAGIAW9Qv///////////wCDQoCAgICAgID4/wBYGyEFDAELIAoEQCABIAyEvyEFDAELIAUgBSAGpCAGvUL///////////8Ag0KAgICAgICA+P8AVhsgBiAFvUL///////////8Ag0KAgICAgICA+P8AWBshBQsgB0EBaiEHDAELCyAFvSIBAn8gBZlEAAAAAAAA4EFjBEAgBaoMAQtBgICAgHgLIgC3vVEEQCAArQwBC0KAgICAwH4gAUKAgICAwIGA/P8AfSABQv///////////wCDQoCAgICAgID4/wBWGwshASAJQRBqJAAgAQstAEKAgICA4AAgACADKQMAIAMpAwhBABCLAiIAQQBHrUKAgICAEIQgAEEASBsLoAEBA34gAykDACIFIQQgAkEETgRAIAMpAxghBAsgBUL/////b1gEQCAAECRCgICAgOAADwsgAykDECEBQoCAgIDgACEGAkAgACADKQMIEDEiAkUNACABQiCIp0F1TwRAIAGnIgMgAygCAEEBajYCAAsgACAFIAIgASAEQQAQhgQhAyAAIAIQEyADQQBIDQAgA0EAR61CgICAgBCEIQYLIAYLjwEAAkACQCADKQMAIgFC/////29YBEAgBARAIAAQJAwDCyABQiCIp0F1SQ0BIAGnIgAgACgCAEEBajYCACABDwsgACABELYDIgJBAEgNASAEBEAgAkEAR61CgICAgBCEDwsgAkUEQCAAQfjiAEEAEBUMAgsgAaciACAAKAIAQQFqNgIACyABDwtCgICAgOAACyoAIAMpAwAiAUL/////b1gEQCAAECRCgICAgOAADwsgACABQQNBABCqAgtPAAJAAkAgAykDACIBQv////9vWARAIARFBEBCgICAgBAPCyAAECQMAQsgACABEJkBIgBBAE4NAQtCgICAgOAADwsgAEEAR61CgICAgBCEC2MBAX4gAykDACIEQv////9vWARAIAAQJEKAgICA4AAPC0KAgICA4AAhAQJAIAAgAykDCBAxIgJFDQAgACAEIAIQcSEDIAAgAhATIANBAEgNACADQQBHrUKAgICAEIQhAQsgAQs2ACADKQMAIgFCIIinIgJBf0YgBEUgAkF+cUECR3FyRQRAIAAQJEKAgICA4AAPCyAAIAEQ6AELYwECfgJAAkAgAykDACIBQv////9vWARAIAAQJAwBCyADKQMIIQUgASEEIAJBA04EQCADKQMQIQQLIAAgBRAxIgINAQtCgICAgOAADwsgACABIAIgBEEAEBQhASAAIAIQEyABC2YBAX4gAykDACIEQv////9vWARAIAAQJEKAgICA4AAPC0KAgICA4AAhAQJAIAAgAykDCBAxIgJFDQAgACAEIAJBABDVASEDIAAgAhATIANBAEgNACADQQBHrUKAgICAEIQhAQsgAQuLAQECfiADKQMAIgFC/////29YBEAgABAkQoCAgIDgAA8LIAMpAxAhBkKAgICA4AAhBQJAIAAgAykDCBAxIgJFDQAgACABIAIgBiAERUEOdBDHBCEDIAAgAhATIANBAEgNACAEBEAgA0EAR61CgICAgBCEDwsgAaciACAAKAIAQQFqNgIAIAEhBQsgBQuaAQIBfwJ+IwBBEGsiBCQAIAMpAwghBSADKQMAIgYhAQJAAkACQAJAIAJBA0gNACADKQMQIgFCgICAgHBaBEAgAactAAVBEHENAQsgAEGiPkEAEBUMAQsgACAEQQxqIAUQiQQiAg0BC0KAgICA4AAhAQwBCyAAIAYgASAEKAIMIgMgAhCQAyEBIAAgAiADEJsDCyAEQRBqJAAgAQsVACAAIAMpAwAgAyADQQhqQQIQnQMLVgIBfgF/IAAgARC0AyIBQoCAgIBwg0KAgICA4ABRBEAgAQ8LQoCAgIAwIQIgAaciAygCBEGAgICAeEcEQCAAIAAoAhAgAxDBAhAtIQILIAAgARAPIAILCQAgACABELQDC1sBAX4jAEEQayICJAAgAiAAIAEQtAMiATcDCAJAIAFCgICAgHCDQoCAgIDgAFEEQCABIQQMAQsgAEKAgICAMEEBIAJBCGoQlwYhBCAAIAEQDwsgAkEQaiQAIAQLfgEBfiADKQMAIgFCgICAgHCDQoCAgICAf1IEQCAAQfbSAEEAEBVCgICAgOAADwtCgICAgDAhBCABpyIAKQIEQoCAgICAgICAQINCgICAgICAgICAf1EEfiAAIAAoAgBBAWo2AgAgAUL/////D4NCgICAgJB/hAVCgICAgDALCzwBAX5CgICAgOAAIQEgACADKQMAECgiBEKAgICAcINCgICAgOAAUgR+IAAgBKdBAhCABAVCgICAgOAACwuBBAIBfgF/AkACQAJAAkACQCABQoCAgIBwWgRAIAGnIgIvAQZBL0YNAQsgBEEBNgIADAELIAIoAiAhAiAEQQE2AgAgAg0BCyAAQbY/QQAQFQwBCwJAAkACQAJAAkACQAJAAkAgAigCACIHQQFrDgQCAgcBAAsgBUUNAiAAKAIQIAIQtQMLQoCAgIAwIQEgBUEBaw4CAwQHCyADKQMAIgFCIIinQXVPBEAgAaciAyADKAIAQQFqNgIACwJAIAVBAkcNAEEBIQMgB0EBRw0AIAAgARCKAQwCCyACKAJEIgMgBa03AwAgA0EIayABNwMAIAIgA0EIajYCRAtBACEDCyACQQM2AgAgAiADNgIUIAAgAkEIahC0AiEBIAJBATYCACABQoCAgIBwg0KAgICA4ABRBEAgACgCECACELUDIAEPCyACKAJEQQhrIgMpAwAhBiADQoCAgIAwNwMAIAFC/////w9YBEAgAUICUQRAIAJBAjYCACAEQQI2AgAgBg8LIARBADYCACAGDwsgACABEA8gACgCECACELUDIAYPCyADKQMAIgFCIIinQXVJDQMgAaciACAAKAIAQQFqNgIAIAEPCyADKQMAIgFCIIinQXVPBEAgAaciAiACKAIAQQFqNgIACyAAIAEQigEMAQsgAEGUP0EAEBULQoCAgIDgACEBCyABC+8BAQN+IwBBEGsiAiQAQoCAgIDgACEEAkAgACAAIAEQJSIBQQEQkAIiBUKAgICAcINCgICAgOAAUQ0AIAVCIIinIgNBACADQQtqQRJJG0UEQCAAIAJBCGogBRBCQQBIDQFCgICAgCAhBCACKQMIQoCAgICAgID4/wCDQoCAgICAgID4/wBRDQELQoCAgIDgACEEIAAgAUG/3AAQsgEiBkKAgICAcINCgICAgOAAUQ0AIAAgBhA4RQRAIABB7PEAQQAQFSAAIAYQDwwBCyAAIAYgAUEAQQAQLyEECyAAIAEQDyAAIAUQDyACQRBqJAAgBAuNAgIBfAF+IwBBEGsiAiQAQoCAgIDgACEFAkAgACACQQhqIAEQmwINACAAIAJBCGogAykDABBCDQAgAgJ+IAIrAwgiBL0iBUKAgICAgICA+P8Ag0KAgICAgICA+P8AUgRAIASdIgREAAAAAACwnUCgIAQgBEQAAAAAAABZQGMbIAQgBEQAAAAAAAAAAGYbIgS9IQULAn8gBJlEAAAAAAAA4EFjBEAgBKoMAQtBgICAgHgLIgO3vSAFUQRAIAOtDAELQoCAgIDAfiAFQoCAgIDAgYD8/wB9IAVC////////////AINCgICAgICAgPj/AFYbCzcDACAAIAFBASACQREQyAQhBQsgAkEQaiQAIAULiQECAX4BfCMAQRBrIgIkAEKAgICA4AAhBAJAIAAgAkEIaiABEJsCDQAgACACQQhqIAMpAwAQQg0AIAAgASACKwMIIgWdRAAAAAAAAAAAoEQAAAAAAAD4fyAFRAAA3MIIsj5DZRtEAAAAAAAA+H8gBUQAANzCCLI+w2YbEMkEIQQLIAJBEGokACAEC9cBAQF8IwBB0ABrIgIkAAJ+QoCAgIDgACAAIAEgAiAEQQ9xQQAQtwMiAEEASA0AGkKAgICAwH4gAEUNABogBEGAAnEEQCACIAIrAwBEAAAAAACwncCgOQMACyACIARBBHZBD3FBA3RqKwMAIgW9IgECfyAFmUQAAAAAAADgQWMEQCAFqgwBC0GAgICAeAsiBLe9UQRAIAStDAELQoCAgIDAfiABQoCAgIDAgYD8/wB9IAFC////////////AINCgICAgICAgPj/AFYbCyEBIAJB0ABqJAAgAQuFAQEBfCMAQRBrIgIkAAJ+QoCAgIDgACAAIAJBCGogARCbAg0AGkKAgICAwH4gAisDCCIEvUL///////////8Ag0KAgICAgICA+P8AVg0AGgJ+IASdIgSZRAAAAAAAAOBDYwRAIASwDAELQoCAgICAgICAgH8LELgDrQshASACQRBqJAAgAQuGAQEBfgJAIAFC/////29YBEAgABAkDAELAkAgAykDACIEQoCAgIBwg0KAgICAkH9SDQAgACAEEDEiAkUNASAAIAIQE0ERIQMCQAJAAkAgAkHGAGsOBgIDAQMDAgALIAJBFkcNAgtBECEDCyAAIAEgAxCQAg8LIABBtitBABAVC0KAgICA4AALlgEBAXwjAEEQayICJAACfkKAgICA4AAgACACQQhqIAEQmwINABogAisDCCIEvSIBAn8gBJlEAAAAAAAA4EFjBEAgBKoMAQtBgICAgHgLIgC3vVEEQCAArQwBC0KAgICAwH4gAUKAgICAwIGA/P8AfSABQv///////////wCDQoCAgICAgID4/wBWGwshASACQRBqJAAgAQvsAgIDfwF8IwBB0ABrIgQkACAEQRBqQQBBOBArGiAEQoCAgICAgID4PzcDIEKAgICAwH4hAQJAIAJFDQBBByACIAJBB04bIgJBACACQQBKGyECA0AgAiAFRwRAIAAgBEEIaiADIAVBA3QiBmopAwAQQgRAQoCAgIDgACEBDAMLIAQrAwgiB71CgICAgICAgPj/AINCgICAgICAgPj/AFENAiAEQRBqIAZqIAedOQMAAkAgBQ0AIAQrAxAiB0QAAAAAAAAAAGZFIAdEAAAAAAAAWUBjRXINACAEIAdEAAAAAACwnUCgOQMQCyAFQQFqIQUMAQsLIARBEGpBABDgAiIHvSIBAn8gB5lEAAAAAAAA4EFjBEAgB6oMAQtBgICAgHgLIgW3vVEEQCAFrSEBDAELQoCAgIDAfiABQoCAgIDAgYD8/wB9IAFC////////////AINCgICAgICAgPj/AFYbIQELIARB0ABqJAAgAQtWABDQBCIBQoCAgIAIfEL/////D1gEQCABQv////8Pgw8LQoCAgIDAfiABub0iAUKAgICAwIGA/P8AfSABQv///////////wCDQoCAgICAgID4/wBWGwsIAEKAgICAMAuqHQIGfwR+IwBB0ABrIgYkAAJAAkAgAEEQaiIDQYgCIAAoAgARAwAiAUUNACABQQVqQQBBgwIQKxogAUEFOgAEIAFBATYCACAAKAJQIgQgAUEIaiIFNgIEIAEgAEHQAGo2AgwgASAENgIIIAAgBTYCUCABIAMgACgCQEEDdCAAKAIAEQMAIgQ2AiggBEUEQCADIAEgACgCBBEAAAwBCyABIAA2AhAgACgCSCIDIAFBFGoiBTYCBCABIABByABqNgIYIAEgAzYCFCAAIAU2AkggAULxgICAgDk3AtwBIAEgAEHYAWo2AtgBIAAoAkAiAEEAIABBAEobIQADQCAAIAJGRQRAIAQgAkEDdGpCgICAgCA3AwAgAkEBaiECDAELCyABQoCAgIAgNwNQIAFCgICAgCA3A0ggAUKAgICAIDcDQCABIAFB9AFqIgA2AvgBIAEgADYC9AEgAUKAgICAIBBHIQcgASgCKCAHNwMIQQAhAiABIAFBEUHMngFBAEEAQQAgBxDxASIHNwMwIAdCIIinQXVPBEAgB6ciACAAKAIAQQFqNgIACyABKAIoIAc3A2ggARA0IQcgASgCKCAHNwMYIAEgB0GQ1QFBAxAiA0AgASgCKCEAIAJBCEZFBEAgAkECdEGQpgFqKAIAIQMgASABIAApAxgQRyIHQTYgASADEMoEQQMQGRogASAHQTMgAUEvEC1BAxAZGiABIAJBA3RqIAc3A1ggAkEBaiECDAELCyABIAApAwhBAhBJIQcgASgCKCAHNwMQQQAhAiABIAEgB6dBACAHQv////9vVhtBARDFBDYCJCABIAFBJGpBAEEwQQoQwwQaIAEgAUESQQBBABDeAjcDsAEgAUETQQBBABDeAiEHIAEgASkDMEHPAEKAgICAMCAHIAEpA7ABQYEyEG0aIAEgASkDMEHNAEKAgICAMCAHIAEpA7ABQYEyEG0aIAEgBxAPIAEgASAHIAEgAUGwAWpBARCxBhAPIAEgARA0NwPAASABIAFCgICAgCAQRzcDyAEgASABQc4xQRRBASABKAIoKQMIEL8BQcDVAUEWECIgASABKAIoKQMIQaDYAUELECIgASABKQMwQdDZAUEHECIgASABQRVB38wAQQFBBUEAEIIBIgc3AzggB0IgiKdBdU8EQCAHpyIAIAAoAgBBAWo2AgALIAEgB0HfzAAgASkDMBDeASABIAFBFkG8wABBAUEFQX8QggEiB0G8wAAgASgCKCkDGBDeAQNAIAJBCEZFBEAgASABQRYgAkECdEGQpgFqKAIAIgBBAkEBIAJBB0YbQQUgAiAHEPEBIAAgASACQQN0aikDWBDeASACQQFqIQIMAQsLIAEgARA0Igc3A5gBIAEgB0HA2gFBARAiIAEgASgCKCkDEEHQ2gFBIBAiIAFB1x9BF0EBIAEoAigpAxAQvwEiB0IgiKdBdU8EQCAHpyIAIAAoAgBBAWo2AgALIAEgBzcDQCABIAdB0N4BQQQQIiAGQbCmAUHKABAfIgMhAkHjACEAIAFCgICAgCAQRyEHA0AgAEH/AXEEQCABIAcgAkKBgICAEEEHEO8BGiACED8gAmpBAWoiAi0AACEADAELCyABIAEoAigpAxBB2wEgB0EBEBkaIAEgASABKAIoKQMQIgdB6wAgB0EAEBQ3A6gBIAEgASkDmAEQRyEHIAEoAiggBzcD4AIgASAHQZDfAUECECIgASABKQPAAUGw3wFBDhAiIAEgASgCKCkDCEEEEEkhByABKAIoIAc3AyAgASAHQgAQ2wEgASABKAIoKQMgQeDhAUEGECIgASABQYfIAEEYQQEgASgCKCkDIBC/AUHA4gFBDhAiIAEgASgCKCkDCEEGEEkhByABKAIoIAc3AzAgASAHQoCAgIAQENsBIAEgASgCKCkDMEGg5AFBAhAiIAFB8tEAQRlBASABKAIoKQMwEL8BGiABIAEoAigpAwhBBRBJIQcgASgCKCAHNwMoIAEgByABQS8QLRDbASABIAFB0NwAQRpBASABKAIoKQMoEL8BQcDkAUEDECIgASABKAIoKQMoQfDkAUExECIgASABKQOYARBHIQcgASgCKCAHNwPoAiABIAdB8OsBQQIQIiADEKMEIAFCASADNAIIIAMpAwBCwIQ9fnwiByAHQgFYGzcD0AEgASABKQPAAUGQ7AFBARAiIAEgASkDwAFB4PEBQQEQIiABEDQhByABKAIoIAc3AzggASAHQdDzAUEFECIgASABQYPTAEEbQQAgASgCKCkDOBC/ASIHQaD0AUECECJB0AEhAiABIQADQCACQd4BRkUEQCAAIAcgACgCECADIAIQkAEiBEEuEKYDIgVBAWogBCAFGyAAIAIQXEEAEO8BGiACQQFqIQIMAQsLIAAgACkDmAEQRyEHIAAoAiggBzcD+AIgACAHQcD0AUEEECIgACAAKQMwEEchByAAKAIoIAc3A4ABIABBFUHIzABBAUEFQQEQggEhByAAIAAoAigpA4ABQYD1AUEBECIgACAAKAIoIgIpA4ABIAIpA/gCQQFBARCWAiAAIAcgACgCKCkDgAFBAEEBEJYCIAAgBxAPIAAgAEEcQbnVAEEBEN4CIgc3A7gBIAApA8ABIQggB0IgiKdBdU8EQCAHpyICIAIoAgBBAWo2AgALIAAgCEE6IAdBAxAZGiAAKQPAASIHQiCIp0F1TwRAIAenIgIgAigCAEEBajYCAAsgACAHQYoBIAdBAxAZGiAAEDQhByAAKAIoIAc3A1AgACAHQdDLAUEvECIgACAAQeXiAEEdQQcgACgCKCkDUBC/AUHA0gFBAxAiIABBHjYCgAIgACAAKAIoKQMoQZDBAUEBECIgAEEfNgL8ASAAEDQhByAAKAIoIAc3A5ABIAAgB0GgwQFBERAiIABBtskAQSBBAiAAKAIoKQOQARC/ASIHQiCIp0F1TwRAIAenIgIgAigCAEEBajYCAAsgACAHNwNIIAAgB0GwwwFBARAiIAAgACkDmAEQRyEHIAAoAiggBzcD8AIgACAHQcDDAUECECIgACAAKQPAAUHgwwFBARAiAkAgACgCECICKAJAQTFPBEAgAigCRCgCgAkNAQsgAkHYpAFBMEEBEM0DGiACKAJEIgJBkAlqQSE2AgAgAkGUCWpB5KQBNgIACyAAQSJB0RpBAkECQQAQggEiB0KAgICAcFoEQCAHpyICIAItAAVBEHI6AAULIAAgB0GgxAFBARAiIAAgACkDwAFB0RogB0EDEO8BGkEAIQIDQAJAIAJBBEYEQEEAIQIDQCACQQJGDQIgACAAKQOYARBHIQcgACgCKCACQQN0aiAHNwPQAiAAIAcgAkECdEGQpQFqKAIAIAJBnKUBai0AABAiIAJBAWohAgwACwALIAAoAhAgAyACQbUBahCQASEEIAAQNCEHIAJBJmpBA3QiBSAAKAIoaiAHNwMAIAAgByACQQJ0QYClAWooAgAgAkGYpQFqLQAAECIgAEEjIARBAEEDIAIQggEhByACQQFNBEAgACAHQfDIAUEBECILIAAgByAEIAAoAiggBWopAwAQ3gEgAkEBaiECDAELCyAAEDQhByAAKAIoIAc3A5gBIAAgB0GQ9QFBAxAiIAAgAEHkxgBBJCAAKAIoKQOYARCXBEHA9QFBAhAiIAAQNCEHIAAoAiggBzcDoAEgACAHQeD1AUEDECIgACAAQb3GAEElIAAoAigpA6ABEJcEQZD2AUEBECIgACAAEDQiB0Gg9gFBHhAiIAAgB0E3IAAgACgCKCkDECIIQTcgCEEAEBRBAxAZGiAAIABBJkHSH0EAEN4CIghBgPoBQQMQIiAAIAggBxD7BUEVIQIDQCACQSBGRQRAIAEgBxBHIQkgAkEDdCIAIAEoAihqIAk3AwAgASAJQcWBAUEBIAJB5aYBai0AAHStIglBABDvARogASABQScgASgCECADIAJBjgFqEJABIgRBA0EDIAIgCBDxASIKIAQgASgCKCAAaikDABDeASABIApBxYEBIAlBABDvARogAkEBaiECDAELCyABIAcQDyABIAgQDyABEDQhByABKAIoIAc3A4ACIAEgB0Gw+gFBGBAiIAFBuyJBKCABKAIoKQOAAhCXBBoCQCABKAIQIgAoAkBBMk8EQCAAKAJEKAKYCQ0BCyAAQaClAUExQQkQzQMaIAAoAkQiAEHQCmpBKTYCACAAQaAKakEqNgIAIABBiApqQSo2AgAgAEHwCWpBKzYCACAAQdgJakEsNgIAIABBwAlqQSw2AgALIAEQNCEHIAEoAiggBzcDiAMgASAHQYDJAUEEECIgAUEtQafjAEEBQQJBABCCASIHQiCIp0F1TwRAIAenIgAgACgCAEEBajYCAAsgASAHNwNQIAEgB0HAyQFBBxAiIAEgB0Gn4wAgASgCKCkDiAMQ3gEgASABKQMwEEchByABKAIoIAc3A6ADIAFBFUHazABBAUEFQQIgASkDOBDxASEHIAEgASgCKCkDoANBsMoBQQEQIiABIAcgASgCKCkDoANBAEEBEJYCIAEgBxAPIAEgARA0Igc3A6ABIAEgB0HAygFBARAiIAEgASkDoAEQRyEHIAEoAiggBzcDuAMgASAHQdDKAUEDECIgASABKQOgARBHIQcgASgCKCAHNwPIAyABIAdBgMsBQQQQIiABIAEpAzAQRyEHIAEoAiggBzcDwAMgAUEVQcPMAEEBQQVBAyABKQM4EPEBIQcgASABKAIoKQPAA0HAywFBARAiIAEgASgCKCIAKQPAAyAAKQPIA0EBQQEQlgIgASAHIAEoAigpA8ADQQBBARCWAiABIAcQDyABKAIQIgBBLjYClAIgAEEvNgKkAiAAQTA2AqACIABBMTYCnAIgAEEyNgKYAiABEDQhByABKAIoIAc3A4gCIAEgB0GA0wFBAxAiIAEgAUGILUEzQQEgASgCKCkDiAIQvwFBsNMBQQ4QIgwBC0EAIQELIAZB0ABqJAAgAQsHACAAEN8EC4cCAQh/An4gACgCECgCeCMAIgciDCABpygCICIIKAIQIgkgA2oiC0EDdCIKa0sEQCAAEOkBQoCAgIDgAAwBCyAJQQAgCUEAShshDSAHIApBD2pBcHFrIgckAAN+IAYgDUYEfkEAIQYgA0EAIANBAEobIQMDQCADIAZGRQRAIAcgBiAJakEDdGogBCAGQQN0aikDADcDACAGQQFqIQYMAQsLIAVBAXEEQCAAIAEgAhBSIQMgACAIKQMAIgEgASACIAMbIAsgBxCQAwwDCyAAIAgpAwAgCCkDCCALIAcQIQUgByAGQQN0IgpqIAggCmopAxg3AwAgBkEBaiEGDAELCwshASAMJAAgAQuxAQEBfyAAQcgAEF8iBQRAIAVBADYCAAJAIAAgBUEIaiIGIAEgAiADIAQQ7QMEQCAFQQQ2AgAMAQsgACAGELQCIgJCgICAgHCDQoCAgIDgAFENACAAIAIQDyAAIAFBLxBlIgFCgICAgHCDQoCAgIDgAFENACABQoCAgIBwWgRAIAGnIAU2AiALIAEPCyAAKAIQIAUQ7AMgACgCECIAQRBqIAUgACgCBBEAAAtCgICAgOAAC4gHAgl/AXwjAEFAaiIGJAACQCAAKAIQIgooAnggBiABpyIILQAoIgtBA3QiDGtLBEAgABDpAUKAgICA4AAhAQwBCyAILQApIQ0gBiAKKAKMASIANgIQIAogBkEQajYCjAEgAAR/IAAoAihBBHEFQQALIQAgCCgCICEHIAYgATcDGCAGIAA2AjggBiADNgI0AkAgAyALTgRAIAQhAAwBCyADQQAgA0EAShshDiAGIAxBD2pB8B9xayIAJAADQCAJIA5GBEAgAyEEA0AgBCALRkUEQCAAIARBA3RqQoCAgIAwNwMAIARBAWohBAwBCwsgBiALNgI0BSAAIAlBA3QiDGogBCAMaikDADcDACAJQQFqIQkMAQsLCyAGIAA2AiAgCCgCJCEEAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIA0ODQsCAAEAAQcIAwQFBgkKCyAFQQFxDQpCgICAgDAhAiANQQJHDQoMCwsgBUEBcQ0AQoCAgIAwIQIgDUEDRg0KCyAHIAIgAyAAIAguASogBBEFACEBDAsLIAcgAiAEEQgAIQEMCgsgByACIAApAwAgBBEYACEBDAkLIAcgAiAILgEqIAQREAAhAQwICyAHIAIgACkDACAILgEqIAQRNAAhAQwHCyAHIAZBCGogACkDABBCDQUgBisDCCAEEQsAIg+9IgECfyAPmUQAAAAAAADgQWMEQCAPqgwBC0GAgICAeAsiALe9UQRAIACtIQEMBwtCgICAgMB+IAFCgICAgMCBgPz/AH0gAUL///////////8Ag0KAgICAgICA+P8AVhshAQwGC0KAgICA4AAhASAHIAZBCGogACkDABBCDQUgByAGIAApAwgQQg0FIAYrAwggBisDACAEESMAIg+9IgECfyAPmUQAAAAAAADgQWMEQCAPqgwBC0GAgICAeAsiALe9UQRAIACtIQEMBgtCgICAgMB+IAFCgICAgMCBgPz/AH0gAUL///////////8Ag0KAgICAgICA+P8AVhshAQwFCyAHIAIgAyAAIAZBCGogCC4BKiAEERIAIgFCgICAgHCDQoCAgIDgAFENBCAGKAIIIgBBAkYNBCAHIAEgABD/AiEBDAQLEAEACyAHIAIgAyAAIAQRAgAhAQwCCyAHQZwiQQAQFQtCgICAgOAAIQELIAogBigCEDYCjAELIAZBQGskACABC9UBAQV/IwAiBSEIAkAgAUKAgICAcFQNACABpyIGLwEGQQ9HDQAgBigCICEHCyAAIAIgAyADIActAAQiAEgEf0EAIQYgA0EAIANBAEobIQkgBSAAQQN0QQ9qQfAfcWsiBSQAA38gBiAJRgR/IAMhBAN/IAAgBEYEfyAFBSAFIARBA3RqQoCAgIAwNwMAIARBAWohBAwBCwsFIAUgBkEDdCIKaiAEIApqKQMANwMAIAZBAWohBgwBCwsFIAQLIAcvAQYgB0EIaiAHKAIAERIAIQEgCCQAIAEL0woCD38BfiMAQTBrIgUkAAJAIAAgARBZIgFCgICAgHCDQoCAgIDgAFENAAJAIAAgARAoIhNCgICAgHCDQoCAgIDgAFEEQEF/IQQMAQsCQCAAQQEgE6ciDCgCBEH/////B3EiBiAGQQFNG0ECdBApIgtFBEBBfyEEDAELIAVBADYCEANAIAYgB0wNASALIARBAnRqIAwgBUEQahDJATYCACAEQQFqIQQgBSgCECEHDAALAAsgACATEA8LIAAgARAPQoCAgIDgACEBIARBAEgNAAJAAkAgAkUNACADKQMAIhNCgICAgHCDQoCAgIAwUQ0AAkAgACAFQQxqIBMQ5QEiAgRAAkAgAi0AAEHOAEcNACACLQABQcYARw0AIAJBA0ECIAItAAJBywBGIgMbai0AACIGQcMAa0H/AXFBAUsNACAFKAIMIAJBA2ogAkECaiADGyACa0EBakYNAgsgACACEFQgAEGC0gBBABBQCyAAQRBqIRAgCyEGDAILIAAgAhBUIAYgA0EBdGpBwwBrIQgLIAAoAhAhAiAFQgA3AxggBUIANwMQIAUgAjYCJCAFQTs2AiAgACIMQRBqIRBBfyEAAkAgBUEQaiAEQQJ0IgIQxgEEQEEAIQYMAQsCQCAIRQRAQQAhByAEQQAgBEEAShshAwNAIAMgB0YNAiAHQQJ0IQYgB0EBaiEHIAYgC2ooAgBB/wFNDQALCyAFQRBqIAsgBCAIQQF2EOwEQQAhBiAFKAIcDQEgBSgCFCIHQQJ2IgBBAWshCkEAIQIgBSgCECEGA0ACQCAAIAJKBEAgBiACIgRBAnRqKAIAEKYCRQ0BA0AgBCAKRgRAIAAhAgwDCyAGIARBAWoiA0ECdGooAgAiDRCmAiIJBEADQAJAIAIgBEoNACAGIARBAnRqIg4oAgAiDxCmAiAJTA0AIA4gDzYCBCAEQQFrIQQMAQsLIARBAnQgBmogDTYCBCADIQQMAQUgAyECDAMLAAsACyAIQQFxIAdBCElyDQNBASAAIABBAU0bIQ5BASEIQQEhAANAIAggDkYNBCAGIAhBAnRqKAIAIgMQpgIhByAAIQQCQAJAA0AgBEEATA0BIAYgBEEBayIEQQJ0aiIPKAIAIgIQpgIiCgRAIAcgCkohAkGAAiEHIAINAQwCCwsCQCADQeEia0EUSyACQYAia0ESS3JFBEAgA0EcbCACQcwEbGpBnI2hAWshBwwBCwJAIAJBgNgCayIEQaPXAEsNACAEQf//A3FBHHAgA0GnI2siBEEbS3INACACIARqIQcMAQtBsAchBEEAIQoDQCAEIApIDQIgBUEoaiAEIApqQQJtIg1BAXRB8NEDai8BACIHQQZ2IhFBAnRBkOICaigCACIJQQ52IhIgB0E/cWoiByARIBIgCUEHdkH/AHEgCUEBdkE/cRDrBBogAyAFKAIsayACIAUoAigiCWsgAiAJRhsiCUEASARAIA1BAWshBAwBCyAJBEAgDUEBaiEKDAELCyAHRQ0BCyAPIAc2AgAMAQsgBiAAQQJ0aiADNgIAIABBAWohAAsgCEEBaiEIDAALAAsgAkEBaiECDAALAAsgBSgCECIGIAsgAhAfGiAEIQALIAwoAhAiAkEQaiALIAIoAgQRAAAgAEEASA0BIAwgBUEQaiAAED0NAEEAIQQCQANAIAAgBEYNASAEQQJ0IQIgBEEBaiEEIAVBEGogAiAGaigCABC5AUUNAAsgBSgCECgCECIAQRBqIAUoAhQgACgCBBEAAAwBCyAFQRBqEDYhAQsgECgCACIAQRBqIAYgACgCBBEAAAsgBUEwaiQAIAEL7AcCC34EfyMAQTBrIg8kAAJAIAFC/////29YBEAgABAkQoCAgIDgACEBDAELQoCAgIAwIQYCQAJAIAAgAykDABAoIgtCgICAgHCDQoCAgIDgAFEEQEKAgICAMCEHQoCAgIAwIQFCgICAgDAhCUKAgICAMCEMDAELIAAgASAAKQNIEOMBIgxCgICAgHCDQoCAgIDgAFEEQEKAgICAMCEHQoCAgIAwIQFCgICAgDAhCQwBCwJAAkAgACAAIAFB7QAgAUEAEBQQNyIJQoCAgIBwg0KAgICA4ABRDQAgCaciAkH1AEEAEMcBIRIgAkH5AEEAEMcBQQBIBEAgAEHMngEgCUHsHxC+ASIJQoCAgIBwg0KAgICA4ABRDQELIA8gCTcDKCAPIAE3AyAgACAMQQIgD0EgahCnASIHQoCAgIBwg0KAgICA4ABRDQEgABA+IgFCgICAgHCDQoCAgIDgAFEEQEKAgICA4AAhAQwDC0F/IQICQCADKQMIIgRCgICAgHCDQoCAgIAwUQ0AIAAgD0EcaiAEEHdBAEgNAyAPKAIcIgINAAwECwJ+IAunIhApAgQiBKdB/////wdxIhEEQCASQX9zQR92IRIgBEL/////B4MhDSACrSEOQQAhAgNAIAKtIQQgAiEDA0AgAyARTwRAIAAgECACIBEgAiARSRsgERCEAQwECyAAIAdB1QAgA60iChBFQQBIDQYgACAGEA8CQCAAIAcgCxDIASIGQoCAgIBwgyIFQoCAgIAgUgRAIAVCgICAgOAAUQ0IIAAgD0EQaiAAIAdB1QAgB0EAEBQQowENCCAPIA8pAxAiBSANIAUgDVMbIgU3AxAgBCAFUg0BCyAQIAogEhDxAqchAwwBCwsgACAQIAIgAxCEASIEQoCAgIBwg0KAgICA4ABRDQUgACABIAggBBBqQQBIDQUgCEIBfCIEIA5RDQYgACAPQQhqIAYQPA0FIAWnIQJCASEFIAhCASAPKQMIIgogCkIBVxt8IQgDQCAEIAhRBEAgBCEIDAILIAAgACAGIAUQcxA3IgpCgICAgHCDQoCAgIDgAFENBiAAIAEgBCAKEGpBAEgNBiAFQgF8IQUgBEIBfCIEIA5SDQALCwwFCyAAIAcgCxDIASIGQoCAgIBwgyIEQoCAgIDgAFENAyAEQoCAgIAgUg0EIAAgEEEAQQAQhAELIgRCgICAgHCDQoCAgIDgAFENAiAAIAEgCCAEEGpBAE4NAwwCC0KAgICAMCEHC0KAgICAMCEBCyAAIAEQD0KAgICA4AAhAQsgACALEA8gACAMEA8gACAHEA8gACAJEA8gACAGEA8LIA9BMGokACABC+ACAQZ+IAFC/////29YBEAgABAkQoCAgIDgAA8LQoCAgIDgACEIQoCAgIAwIQYCQAJAAkAgACADKQMAECgiB0KAgICAcINCgICAgOAAUQRAQoCAgIAwIQQMAQsgACABQdUAIAFBABAUIgRCgICAgHCDQoCAgIDgAFENACAAIARCABBSRQRAIAAgAUHVAEIAEEVBAEgNAQsgACABIAcQyAEiBUKAgICAcIMiCUKAgICA4ABRDQEgACABQdUAIAFBABAUIgZCgICAgHCDQoCAgIDgAFENAQJAIAAgBiAEEFIEQCAAIAQQDwwBCyAAIAFB1QAgBBBFQQBODQBCgICAgDAhBAwCCyAAIAcQDyAAIAYQD0L/////DyEIIAlCgICAgCBRDQIgACAFQdcAIAVBABAUIQEgACAFEA8gAQ8LQoCAgIAwIQULIAAgBRAPIAAgBxAPIAAgBhAPIAAgBBAPCyAIC80EAgZ+AX8jAEEgayICJAACQCABQv////9vWARAIAAQJEKAgICA4AAhBwwBC0KAgICA4AAhB0KAgICAMCEIAkAgACADKQMAECgiCUKAgICAcINCgICAgOAAUQRAQoCAgIAwIQRCgICAgDAhBUKAgICAMCEGDAELAkACQCAAIAEgACkDSBDjASIGQoCAgIBwg0KAgICA4ABRBEBCgICAgDAhBAwBCyAAIAAgAUHtACABQQAQFBA3IgRCgICAgHCDQoCAgIDgAFINAQtCgICAgDAhBQwBCyACIAQ3AxggAiABNwMQIAAgBkECIAJBEGoQpwEiBUKAgICAcINCgICAgOAAUQ0AIAAgAkEIaiAAIAFB1QAgAUEAEBQQowENACAAIAVB1QACfiACKQMIIgFCgICAgAh8Qv////8PWARAIAFC/////w+DDAELQoCAgIDAfiABub0iAUKAgICAwIGA/P8AfSABQv///////////wCDQoCAgICAgID4/wBWGwsQRUEASA0AQoCAgIDgACEIIABBLhB2IgFCgICAgHCDQoCAgIDgAFENACAAQSAQKSIDRQRAIAEhCAwBCyADIAk3AwggAyAFNwMAIAMgBKciCkHnAEEAEMcBQX9zQR92NgIQIApB9QBBABDHASEKIANBADYCGCADIApBf3NBH3Y2AhQgAUKAgICAcFoEQCABpyADNgIgCyAAIAYQDyAAIAQQDyABIQcMAQsgACAJEA8gACAGEA8gACAEEA8gACAFEA8gACAIEA8LIAJBIGokACAHC74EAgd+An8jAEEQayICJAACQCABQv////9vWARAIAAQJEKAgICA4AAhBgwBC0KAgICA4AAhBkKAgICAMCEFAkAgAAJ+AkAgACADKQMAECgiB0KAgICAcINCgICAgOAAUQ0AIAAgACABQe4AIAFBABAUECYiA0EASA0AIANFBEAgACABIAcQyAEhBgwDCyAAIAAgAUHvACABQQAQFBAmIgtBAEgNACAAIAFB1QBCABBFQQBIDQBCgICAgOAAIAAQPiIIQoCAgIBwg0KAgICA4ABRDQEaIAenIQwCQANAIAAgBRAPIAAgASAHEMgBIgVCgICAgHCDIgRCgICAgCBRDQECQCAEQoCAgIDgAFENAAJ/IAAgACAFQgAQTRA3IgRCgICAgHCDIgpCgICAgJB/UgRAQQAgCkKAgICA4ABSDQEaDAILIASnKAIEQf////8HcUULIQMgACAIIAkgBBCGAUEASA0AIAlCAXwhCSADRQ0BIAAgAkEIaiAAIAFB1QAgAUEAEBQQowFBAEgNACAAIAFB1QACfiAMIAIpAwggCxDxAiIEQoCAgIAIfEL/////D1gEQCAEQv////8PgwwBC0KAgICAwH4gBLm9IgRCgICAgMCBgPz/AH0gBEL///////////8Ag0KAgICAgICA+P8AVhsLEEVBAE4NAQsLIAgMAgsgCacEQCAIIQYMAwsgACAIEA9CgICAgCAhBgwCC0KAgICAMAsQDwsgACAFEA8gACAHEA8LIAJBEGokACAG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/////w+DEGpBAEgNDSADRQRAIAkgCSgCAEEBajYCAAsgACABIAZBAWqtIBQQakEASA0NIA5CgICAgDBSBEAgEUIgiKdBdU8EQCARpyICIAIoAgBBAWo2AgALIAAgASAGQQJqrSAREGpBAEgNDgsgBCABNwNYIARCgICAgDA3A1AgACATEA8gACAAIBkgBCAEQdAAakEAEJ0DEDchEwwBC0KAgICAMCEVIA5CgICAgDBSBEAgACARECUiFUKAgICAcINCgICAgOAAUQ0NCyAEIBc3A3ggBCAVNwNwIAQgATcDaCAEIBQ3A1ggBCAPNwNQIAQgEkL/////D4M3A2AgACATEA8gACAEQdAAahDtBCETIAAgFRAPCyATQoCAgIBwg0KAgICA4ABRDQsgB6wgElcEQCAEQThqIgIgCSAHIBKnEFEaIAIgExCHARogD6cpAgRC/////weDIBJ8pyEHCyAFQQFqIQUMAQsLIARBOGoiAiAJIAcgCSgCBEH/////B3EQURogAhA2IRAMCgsgACAPEA9CgICAgDAhEwJAAn8CQCAAIAAgEkIAEE0QNyIPQoCAgIBwgyIOQoCAgICQf1IEQCAOQoCAgIDgAFINASAOIRAMAwsgD6coAgRB/////wdxDQAgACAEQdAAaiAAIAFB1QAgAUEAEBQQowFBAEgNAiAAIAFB1QACfiAJIAQpA1AgDRDxAiIOQoCAgIAIfEL/////D1gEQCAOQv////8PgwwBC0KAgICAwH4gDrm9Ig5CgICAgMCBgPz/AH0gDkL///////////8Ag0KAgICAgICA+P8AVhsLEEUiAkEATg0AIAJBHnZBAnEMAQtBAAtFDQELCwwCCwwGC0KAgICAMCETC0KAgICAMCEBDAQLIARB0ABqIAsgCCALKAIEQf////8HcRBRDQAgACASEA8gACgCECICQRBqIAMgAigCBBEAACAEQdAAahA2IRAMAQsgACASEA8gACgCECICQRBqIAMgAigCBBEAACAEKAJQKAIQIgJBEGogBCgCVCACKAIEEQAAC0KAgICAMCERC0KAgICAMCETQoCAgIAwIQFCgICAgDAhDwsgBCgCOCgCECICQRBqIAQoAjwgAigCBBEAAAsgBBDuBCAAIBcQDyAAIA8QDyAAIAEQDyAAIBMQDyAAIBEQDyAAIBQQDwsgBEGQAWokACAQC6IBACMAQSBrIgIkAAJ+AkAgAUL/////b1gEQCAAECQMAQsgACACQQhqIgNBABA9GiADQS8QOxoCQCADIAAgAUHsACABQQAQFBB/DQAgAkEIaiIDQS8QOxogAyAAIAFB7QAgAUEAEBQQfw0AIAJBCGoQNgwCCyACKAIIKAIQIgBBEGogAigCDCAAKAIEEQAAC0KAgICA4AALIQEgAkEgaiQAIAELTgECfkKAgICA4AAhBCAAIAEgAykDABDIASIBQoCAgIBwgyIFQoCAgIDgAFIEfiAAIAEQDyAFQoCAgIAgUq1CgICAgBCEBUKAgICA4AALC/gCAgN+AX8CQAJAIAAgARDwAiICRQ0AIAMpAwghBgJAAkACQCADKQMAIgRCgICAgHBUDQAgBKciAy8BBkESRw0AIAZCgICAgHCDQoCAgIAwUgRAIABBnvkAQQAQFUKAgICA4AAPCyADKAIgIgcgBygCAEEBajYCACADKAIkIgMgAygCAEEBajYCACAHrUKAgICAkH+EIQQgA61CgICAgJB/hCEFDAELQoCAgIAwIQUCfiAEQoCAgIBwg0KAgICAMFEEQCAAQS8QLQwBCyAAIAQQKAsiBEKAgICAcINCgICAgOAAUQ0BIAAgBCAGEJgEIgVCgICAgHCDQoCAgIDgAFENAQsgACACNQIAQoCAgICQf4QQDyAAIAI1AgRCgICAgJB/hBAPIAIgBT4CBCACIAQ+AgAgACABQdUAQgAQRUEASA0BIAFCIIinQXVJDQIgAaciACAAKAIAQQFqNgIADAILIAAgBBAPIAAgBRAPC0KAgICA4AAPCyABC2oBAX8gAUL/////b1gEQCAAECRCgICAgOAADwsCfiABpyIDLwEGQRJHBEBCgICAgDAgACABIAAoAigpA5ABEFINARogAEESEIYDQoCAgIDgAA8LIAMoAiQtABAgAnFBAEetQoCAgIAQhAsLvQQBCX8jAEEgayIHJAACQAJAAkACQAJAIAFC/////29YBEAgABAkDAELIAAgASAAKAIoKQOQARBSDQIgACABEPACIgINAQtCgICAgOAAIQEMAwsgAigCACIIKAIEIgJB/////wdxIgMNAQsgAEH+kwEQYiEBDAELIAAgB0EIaiADIAJBH3YQigMaIAhBEGohBiAIKAIEQf////8HcSEJQQAhAANAAkACQCAAIAlIBEAgAEEBaiECQX8hBQJAAn8CQAJAAkACQAJAAkACQAJ/IAgpAgRCgICAgAiDIgFQIgpFBEAgBiAAQQF0ai8BAAwBCyAAIAZqLQAACyIDQdsAaw4DAwECAAsgAiEAAkAgA0EKaw4EBAsLBQALIANBL0cNByAERQ0FQQEhBEEvIQMMBwtB3AAhAyACIAlODQYgAEECaiEAIApFBEAgBiACQQF0ai8BACEFDAoLIAIgBmotAAAhBQwJC0EAIQRB3QAhAwwFC0HbACEDIAQgAiAJTnINBiAAQQJqIQAgAVAEQEHdAEF/IAIgBmotAABB3QBGIgQbIQUgACACIAQbIQBBASEEDAgLQQEhBEHdAEF/IAYgAkEBdGovAQBB3QBGIgobIQUgACACIAobIQAMBwtB7gAMAgtB8gAMAQtBACEEQS8LIQVB3AAhAwsgAiEADAILIAdBCGoQNiEBDAMLIAIhAEEBIQQLIAdBCGogAxCLARogBUEASA0AIAdBCGogBRCLARoMAAsACyAHQSBqJAAgAQvWAgIDfwF+IwBBEGsiBCQAAkAgAUL/////b1gEQCAAECRCgICAgOAAIQUMAQtCgICAgOAAIQUgACAAIAFB7gAgAUEAEBQQJiICQQBIDQAgAgR/IARB5wA6AAggBEEJagUgBEEIagshAiAAIAAgAUHr4wAQsgEQJiIDQQBIDQAgAwRAIAJB6QA6AAAgAkEBaiECCyAAIAAgAUGL5QAQsgEQJiIDQQBIDQAgAwRAIAJB7QA6AAAgAkEBaiECCyAAIAAgAUH01AAQsgEQJiIDQQBIDQAgAwRAIAJB8wA6AAAgAkEBaiECCyAAIAAgAUHvACABQQAQFBAmIgNBAEgNACADBEAgAkH1ADoAACACQQFqIQILIAAgACABQfsdELIBECYiA0EASA0AIAAgBEEIaiIAIAMEfyACQfkAOgAAIAJBAWoFIAILIABrEJMCIQULIARBEGokACAFC6UDAQR+IwBBEGsiAyQAIAQCfwJAAkACQAJAIAAgAUEuEEsiAkUEQEKAgICAMCEBDAELIAIoAhgEQEKAgICAMCEBQQEMBQsgACACKQMAIgggAikDCCIGEMgBIgFCgICAgHCDIgdCgICAgOAAUg0BC0KAgICAMCEHDAELIAdCgICAgCBRBEAgAkEBNgIYQoCAgIAwIQFBAQwDCyACKAIQBEAgACAAIAFCABBNEDciB0KAgICAcIMiCUKAgICA4ABRDQECQCAJQoCAgICQf1INACAHpygCBEH/////B3ENACAAIANBCGogACAIQdUAIAhBABAUEKMBQQBIDQIgACAIQdUAAn4gBqcgAykDCCACKAIUEPECIgZCgICAgAh8Qv////8PWARAIAZC/////w+DDAELQoCAgIDAfiAGub0iBkKAgICAwIGA/P8AfSAGQv///////////wCDQoCAgICAgID4/wBWGwsQRUEASA0CCyAAIAcQDwwCCyACQQE2AhgMAQsgACABEA8gACAHEA9CgICAgOAAIQELQQALNgIAIANBEGokACABCw4AIAAQtQJCgICAgOAACwkAQoCAgIDAfgsWACAAIAMpAwAgAykDCCADKQMQEJQEC9EBAgN+An8jAEEQayIHJAACQCAAIAdBDGogAykDABDlASIIRQRAQoCAgIDgACEEDAELIAAgCCAHKAIMQdKIARD1BSEBIAAgCBBUAkAgAkECSCABQoCAgIBwg0KAgICA4ABRcg0AIAAgAykDCCIGEDhFDQBCgICAgOAAIQQCQCAAEDQiBUKAgICAcINCgICAgOAAUQRAIAEhBQwBCyAAIAVBLyABQQcQGUEASA0AIAAgBUEvIAYQ+QQhBAsgACAFEA8MAQsgASEECyAHQRBqJAAgBAsNACAAIAEgAkEwEP0FCwsAIAAgAUEwEP4FC7QDAgN/An4jAEHQAGsiBiQAQX8hBwJAIAAgBkHIAGogAUHCABCBASIIRQ0AIAYpA0giAUKAgICAcINCgICAgDBRBEAgCCkDACEBIANCIIinQXVPBEAgA6ciByAHKAIAQQFqNgIACyAAIAEgAiADIAQgBRCGBCEHDAELIAAgAhBcIglCgICAgHCDQoCAgIDgAFEEQCAAIAEQDwwBCyAIKQMAIQogBiAENwM4IAYgAzcDMCAGIAk3AyggBiAKNwMgIAAgASAIKQMIQQQgBkEgahAvIQEgACAJEA8gAUKAgICAcINCgICAgOAAUQ0AAkACQCAAIAEQJiIHBEAgACAGIAgoAgAgAhBMIgJBAEgNASACRQ0DAkAgBigCACICQRNxRQRAIAAgBikDCCADEFJFDQEMBAsgAkERcUEQRw0DIAY1AhxCIIZCgICAgDBSDQMLIAAgBhBI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gICAwH4gALi9IgFCgICAgMCBgPz/AH0gAUL///////////8Ag0KAgICAgICA+P8AVhsLOQEBfkKAgICAwH4gASkDACICQoCAgIDAgYD8/wB9IAJC////////////AINCgICAgICAgPj/AFYbCzsBAX5CgICAgMB+IAEqAgC7vSICQoCAgIDAgYD8/wB9IAJC////////////AINCgICAgICAgPj/AFYbCwwAIAAgASkDABD7AwsMACAAIAEpAwAQhwILSQEBfiABKAIAIgBBAE4EQCAArQ8LQoCAgIDAfiAAuL0iAkKAgICAwIGA/P8AfSACQv///////////wCDQoCAgICAgID4/wBWGwsHACABNQIACwcAIAEzAQALDgAgATIBAEL/////D4MLCQAgABC1AkF/Cw4AIAEwAABC/////w+DCwcAIAExAAALDwAgACsDACABKwMAEP0ECxEAIAAqAgC7IAEqAgC7EP0ECxkBAn4gASkDACIDIAApAwAiBFQgAyAEVmsLGQECfiABKQMAIgMgACkDACIEUyADIARVawsXACABKAIAIgEgACgCACIASSAAIAFJawsXACABKAIAIgEgACgCACIASCAAIAFIawsNACAALwEAIAEvAQBrCw0AIAAuAQAgAS4BAGsLDQAgACwAACABLAAAawsNACAALQAAIAEtAABrC8wNBAd/AXwBfgF9IwBBIGsiBiQAQoCAgIDgACENAkAgACABEJIBIgpBAEgNAEF/IQUCQAJAAkAgCkUNAEEBIQgCQAJAIARBAUYEQEF/IQggBiAKQQFrIgU2AhwgAkECSA0BIAAgBkEIaiADKQMIEEINBiAGKwMIIgy9Qv///////////wCDQoGAgICAgID4/wBaBEAgBkEANgIcDAILIAxEAAAAAAAAAABmBEAgDCAFt2NFDQIgBgJ/IAyZRAAAAAAAAOBBYwRAIAyqDAELQYCAgIB4CzYCHAwCC0F/IQUgDCAKt6AiDEQAAAAAAAAAAGMNBCAGAn8gDJlEAAAAAAAA4EFjBEAgDKoMAQtBgICAgHgLNgIcDAELIAZBADYCHCACQQJIBEAgCiECDAILIAAgBkEcaiADKQMIIAoiAiACEFcNBQwBC0F/IQILIAGnIgkoAiAoAgwoAiAtAAQEQEF/IQUgBEF/Rw0CQX9BACADNQIEQiCGQoCA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IA1CgICAgDBBBCAFQRBqECEhCiAAIAsQDyAAIA8QDyAFQoCAgIAwNwM4IApCgICAgHCDQoCAgIDgAFENASAAIAkQDyAKIQkLIAhCAXwhCAwBCwsgBSAJNwMwIAUpAzghCwsgACAFKQMwEA8gACALEA9CgICAgOAAIQkLIAAgARAPIAVBQGskACAJC6wIAgN/CX4jAEEwayIFJABCgICAgDAhCSAFQoCAgIAwNwMoAkACQAJAAkAgBEEIcSIHBEAgAUIgiKdBdU8EQCABpyIGIAYoAgBBAWo2AgALIAUgACABEJIBIgasNwMIIAZBAE4NAQwCCyAAIAVBCGogACABECUiARA8DQELIAMpAwAhD0KAgICAMCEOIAJBAk4EQCADKQMIIQ4LIAAgDxBgDQACQAJAAkACQAJAAkACQCAEDg0FAAYBAgYGBgUABgMEBgtCgICAgBAhCQwFCyAAIAECfiAFKQMIIghCgICAgAh8Qv////8PWARAIAhC/////w+DDAELQoCAgIDAfiAIub0iCEKAgICAwIGA/P8AfSAIQv///////////wCDQoCAgICAgID4/wBWGwsQqwIiCUKAgICAcINCgICAgOAAUg0EDAULIAAgAUIAEKsCIglCgICAgHCDQoCAgIDgAFINAwwECyAFIAE3AxAgBSAFNQIINwMYIABBAiAFQRBqEPYCIglCgICAgHCDQoCAgIDgAFINAgwDCyAAED4iCUKAgICAcINCgICAgOAAUg0BQoCAgIDgACEJDAILQoGAgIAQIQkLQgAhCCAFKQMIIgpCACAKQgBVGyEQA0AgCCAQUgRAAkACQCAHBEAgBSAAIAEgCBBzIgo3AyggCkKAgICAcINCgICAgOAAUg0BDAULIAAgASAIIAVBKGoQhQEiAkEASA0EIAJFDQELIAghCiAIQoCAgIAIWgRAQoCAgIDAfiAIub0iCkKAgICAwIGA/P8AfSAKQv///////////wCDQoCAgICAgID4/wBWGyEKCyAKQoCAgIBwg0KAgICA4ABRDQMgBSABNwMgIAUgCjcDGCAFIAUpAygiDTcDECAAIA8gDkEDIAVBEGoQISELIAAgChAPIAtCgICAgHCDQoCAgIDgAFENAwJAAkACQAJAAkACQAJAIAQODQABBQIEBQUFAAEFAwQFCyAAIAsQJg0FQoCAgIAQIQgM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AUL///////////8Ag0KAgICAgICA+P8AVhshBQwCCxABAAsgAjAAAEL/////D4MhBQsgB0EQaiQAIAULUgIBfwF+QoCAgIDgACEEIAAgASACEJMBIgMEfiADKAIgIgMoAgwoAiAtAAQEQCACRQRAQgAPCyAAEGtCgICAgOAADwsgAzUCFAVCgICAgOAACwvXAQEDfwJAIAFCgICAgHBUDQAgAaciAy8BBkE5Rw0AIAMoAiAiBEUNACAEQcwAaiEDIARByABqIQUDQCAFIAMoAgAiA0cEQCADKQMQIgFCgICAgGBaBEAgACABpyACEQAACyADKQMYIgFCgICAgGBaBEAgACABpyACEQAACyADKQMgIgFCgICAgGBaBEAgACABpyACEQAACyADKQMoIgFCgICAgGBaBEAgACABpyACEQAACyADQQRqIQMMAQsLIAQoAgRBfnFBBEYNACAAIARBCGogAhDvAwsLBgBB4MYECzABAX8CQCABQoCAgIBwVA0AIAGnIgIvAQZBOUcNACACKAIgIgJFDQAgACACEIcFCwsNACAAIAEgAkE3EP0FCwsAIAAgAUE3EP4FCxYBAX8gAacoAiAiAgRAIAAgAhCIBQsLMQEBfyABpygCICICBEAgACACKAIIEKMFIAAgAikDABAjIABBEGogAiAAKAIEEQAACwvcAQEEfwJAIAFCgICAgHBUDQAgAaciBC8BBkExRw0AIAQoAiAiBkUNAEEAIQQDQCAEQQJGRQRAIAYgBEEDdGoiBUEIaiEDIAVBBGohBQNAIAUgAygCACIDRwRAIAMpAwgiAUKAgICAYFoEQCAAIAGnIAIRAAALIAMpAxAiAUKAgICAYFoEQCAAIAGnIAIRAAALIAMpAxgiAUKAgICAYFoEQCAAIAGnIAIRAAALIANBBGohAwwBCwsgBEEBaiEEDAELCyAGKQMYIgFCgICAgGBUDQAgACABpyACEQAACwuMAQEFfwJAIAFCgICAgHBUDQAgAaciAi8BBkExRw0AIAIoAiAiBEUNAANAIANBAkZFBEAgBCADQQN0aiICQQRqIQUgAigCCCECA0AgAiAFRkUEQCACKAIEIQYgACACEK4CIAYhAgwBCwsgA0EBaiEDDAELCyAAIAQpAxgQIyAAQRBqIAQgACgCBBEAAAsLJQAgBSkDACIBQiCIp0F1TwRAIAGn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IAMpAwAQpgENACAAEJcBIgVCgICAgHCDQoCAgIDgAFENACAAIAJBFGogAykDCBC7ASIGRQRAIAAgBRAPDAELIAAoAtgBIQMgAkIANwIMIAJCgICAgICAgICAfzcCBCACIAM2AgAgAkIBEDAaIAIgAikDKCIBpyIHQf////8DQQEQzAEaIAIgAkJ/Qf////8DQQEQdRogBadBBGoiAyAGIAIQkwUaAkAgBEUgAVByDQAgAkIBEDAaIAIgB0EBa0H/////A0EBEMwBGiADIAIQ0wFBAEgNACACQgEQMBogAiAHQf////8DQQEQzAEaIAMgAyACQf////8DQQEQ5AEaCyACEBsgACAGIAJBFGoQXiAAIAUQzQEhAQsgAkEwaiQAIAEL6hMCAn4BfyMAQdABayIEJAAgACAEEJgFIAEgARA0IgNBqi0CfiAEKQMIIgJCgICAgAh8Qv////8PWARAIAJC/////w+DDAELQoCAgIDAfiACub0iAkKAgICAwIGA/P8AfSACQv///////////wCDQoCAgICAgID4/wBWGwsQQCABIANB3+AAAn4gBCkDECICQoCAgIAIfEL/////D1gEQCACQv////8PgwwBC0KAgICAwH4gArm9IgJCgICAgMCBgPz/AH0gAkL///////////8Ag0KAgICAgICA+P8AVhsLEEAgASADQboqAn4gBCkDGCICQoCAgIAIfEL/////D1gEQCACQv////8PgwwBC0KAgICAwH4gArm9IgJCgICAgMCBgPz/AH0gAkL///////////8Ag0KAgICAgICA+P8AVhsLEEAgASADQagqAn4gBCkDICICQoCAgIAIfEL/////D1gEQCACQv////8PgwwBC0KAgICAwH4gArm9IgJCgICAgMCBgPz/AH0gAkL///////////8Ag0KAgICAgICA+P8AVhsLEEAgASADQfooAn4gBCkDKCICQoCAgIAIfEL/////D1gEQCACQv////8PgwwBC0KAgICAwH4gArm9IgJCgICAgMCBgPz/AH0gAkL///////////8Ag0KAgICAgICA+P8AVhsLEEAgASADQfrfAAJ+IAQpAzAiAkKAgICACHxC/////w9YBEAgAkL/////D4MMAQtCgICAgMB+IAK5vSICQoCAgIDAgYD8/wB9IAJC////////////AINCgICAgICAgPj/AFYbCxBAIAEgA0HYKAJ+IAQpAzgiAkKAgICACHxC/////w9YBEAgAkL/////D4MMAQtCgICAgMB+IAK5vSICQoCAgIDAgYD8/wB9IAJC////////////AINCgICAgICAgPj/AFYbCxBAIAEgA0G23wACfiAEKQNAIgJCgICAgAh8Qv////8PWARAIAJC/////w+DDAELQoCAgIDAfiACub0iAkKAgICAwIGA/P8AfSACQv///////////wCDQoCAgICAgID4/wBWGwsQQCABIANBzSkCfiAEKQNIIgJCgICAgAh8Qv////8PWARAIAJC/////w+DDAELQoCAgIDAfiACub0iAkKAgICAwIGA/P8AfSACQv///////////wCDQoCAgICAgID4/wBWGwsQQCABIANBl+AAAn4gBCkDUCICQoCAgIAIfEL/////D1gEQCACQv////8PgwwBC0KAgICAwH4gArm9IgJCgICAgMCBgPz/AH0gAkL///////////8Ag0KAgICAgICA+P8AVhsLEEAgASADQeIoAn4gBCkDWCICQoCAgIAIfEL/////D1gEQCACQv////8PgwwBC0KAgICAwH4gArm9IgJCgICAgMCBgPz/AH0gAkL///////////8Ag0KAgICAgICA+P8AVhsLEEAgASADQc/fAAJ+IAQpA2AiAkKAgICACHxC/////w9YBEAgAkL/////D4MMAQtCgICAgMB+IAK5vSICQoCAgIDAgYD8/wB9IAJC////////////AINCgICAgICAgPj/AFYbCxBAIAEgA0GGKgJ+IAQpA2giAkKAgICACHxC/////w9YBEAgAkL/////D4MMAQtCgICAgMB+IAK5vSICQoCAgIDAgYD8/wB9IAJC////////////AINCgICAgICAgPj/AFYbCxBAIAEgA0Gt4AACfiAEKQNwIgJCgICAgAh8Qv////8PWARAIAJC/////w+DDAELQoCAgIDAfiACub0iAkKAgICAwIGA/P8AfSACQv///////////wCDQoCAgICAgID4/wBWGwsQQCABIANBxyoCfiAEKQN4IgJCgICAgAh8Qv////8PWARAIAJC/////w+DDAELQoCAgIDAfiACub0iAkKAgICAwIGA/P8AfSACQv///////////wCDQoCAgICAgID4/wBWGwsQQCABIANB8OAAAn4gBCkDgAEiAkKAgICACHxC/////w9YBEAgAkL/////D4MMAQtCgICAgMB+IAK5vSICQoCAgIDAgYD8/wB9IAJC////////////AINCgICAgICAgPj/AFYbCxBAIAEgA0HN4AACfiAEKQOIASICQoCAgIAIfEL/////D1gEQCACQv////8PgwwBC0KAgICAwH4gArm9IgJCgICAgMCBgPz/AH0gAkL///////////8Ag0KAgICAgICA+P8AVhsLEEAgASADQZIqAn4gBCkDkAEiAkKAgICACHxC/////w9YBEAgAkL/////D4MMAQtCgICAgMB+IAK5vSICQoCAgIDAgYD8/wB9IAJC////////////AINCgICAgICAgPj/AFYbCxBAIAEgA0G44AACfiAEKQOYASICQoCAgIAIfEL/////D1gEQCACQv////8PgwwBC0KAgICAwH4gArm9IgJCgICAgMCBgPz/AH0gAkL///////////8Ag0KAgICAgICA+P8AVhsLEEAgASADQdUqAn4gBCkDoAEiAkKAgICACHxC/////w9YBEAgAkL/////D4MMAQtCgICAgMB+IAK5vSICQoCAgIDAgYD8/wB9IAJC////////////AINCgICAgICAgPj/AFYbCxBAIAEgA0HvJwJ+IAQpA6gBIgJCgICAgAh8Qv////8PWARAIAJC/////w+DDAELQoCAgIDAfiACub0iAkKAgICAwIGA/P8AfSACQv///////////wCDQoCAgICAgID4/wBWGwsQQCABIANB6icCfiAEKQOwASICQoCAgIAIfEL/////D1gEQCACQv////8PgwwBC0KAgICAwH4gArm9IgJCgICAgMCBgPz/AH0gAkL///////////8Ag0KAgICAgICA+P8AVhsLEEAgASADQeszAn4gBCkDuAEiAkKAgICACHxC/////w9YBEAgAkL/////D4MMAQtCgICAgMB+IAK5vSICQoCAgIDAgYD8/wB9IAJC////////////AINCgICAgICAgPj/AFYbCxBAIAEgA0H7JwJ+IAQpA8ABIgJCgICAgAh8Qv////8PWARAIAJC/////w+DDAELQoCAgIDAfiACub0iAkKAgICAwIGA/P8AfSACQv///////////wCDQoCAgICAgID4/wBWGwsQQCABIANBo98AAn4gBCkDyAEiAkKAgICACHxC/////w9YBEAgAkL/////D4MMAQtCgICAgMB+IAK5vSICQoCAgIDAgYD8/wB9IAJC////////////AINCgICAgICAgPj/AFYbCxBAIAMQUyEAIARB0AFqJAAgAAufAgEDfiABQv////9vWARAIAAQJEKAgICA4AAPC0KAgICA4AAhBQJ+IAAgAUE2IAFBABAUIgRCgICAgHCDQoCAgIAwUQRAIABBlAEQLQwBCyAAIAQQNwsiBEKAgICAcIMiBkKAgICA4ABSBH4CfiAAIAFBMyABQQAQFCIBQoCAgIBwg0KAgICAMFEEQCAAQS8QLQwBCyAAIAEQNwsiAUKAgICAcIMiBUKAgICA4ABRBEAgACAEEA9CgICAgOAADwsCQCAGQoCAgICQf1EEQCAEpygCBEH/////B3FFDQELIAVCgICAgJB/UQRAIAGnKAIEQf////8HcUUNAQsgAEHMngEgBEH4mQEQvgEhBAsgACAEIAEQxAIFQoCAgIDgAAsLXwEBfwJAIAFFBEAgAkUNASAAIAIQ2QMPCyACRQRAIAAgACgCAEEBazYCACAAIAAoAgRBCGs2AgQgARCbAQwBCyAAKAIIIAAoAgQgAmpPBH8gASACEPMFBUEACw8LQQALJgAgAQRAIAAgACgCAEEBazYCACAAIAAoAgRBCGs2AgQgARCbAQsLCQAgACABNgIYCygBAX8CQCABpygCICIDRQ0AIAMoAgBBBEYNACAAIANBCGogAhDvAwsLPwEBfwJAIAFCgICAgHBUDQAgAaciAi8BBkEvRw0AIAIoAiAiAkUNACAAIAIQ7AMgAEEQaiACIAAoAgQRAAALC0cBAX8CQCABpygCICIDRQ0AIAMpAwAiAUKAgICAYFoEQCAAIAGnIAIRAAALIAMpAwgiAUKAgICAYFQNACAAIAGnIAIRAAALCzABAX8gAacoAiAiAgRAIAAgAikDABAjIAAgAikDCBAjIABBEGogAiAAKAIEEQAACwsnAQF/IAGnKAIgIgIEQCAAIAIpAwAQIyAAQRBqIAIgACgCBBEAAAsLWgECfyABpygCICICBEACQCACKQMAIgFCgICAgHBUDQAgAactAAVBAnENACACKAIMIgNFDQAgACADEOoDIAIpAwAhAQsg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ACIGRQ0AIAYtAAVBAXFFDQAgACAGIAIRAAALIANBAWohAwwACwALIAAgBCACEQAACwt8AQN/IAGnIgIoAigiAwRAIAAgA61CgICAgHCEECMLIAIoAiAiAwRAIAIoAiQiBARAQQAhAgNAIAIgAygCPE5FBEAgACAEIAJBAnRqKAIAEOsBIAJBAWohAgwBCwsgAEEQaiAEIAAoAgQRAAALIAAgA61CgICAgGCEECMLCxIAIAGnKAIgIgAEQCAAEKQDCwseACABpykDICIBQoCAgIBgWgRAIAAgAacgAhEAAAsLGQAgACABpyIAKQMgECMgAEKAgICAMDcDIAtEAQJ/IAGnIQQDQCAEKAIoIANLBEAgBCgCJCADQQN0aikDACIBQoCAgIBgWgRAIAAgAacgAhEAAAsgA0EBaiEDDAELCwtGAQN/IAGnIQMDQCADKAIkIQQgAiADKAIoT0UEQCAAIAQgAkEDdGopAwAQIyACQQFqIQIMAQsLIABBEGogBCAAKAIEEQAAC2kBAn8jAEEQayIHJAACfwJAIAGnIggtAAVBCHFFDQAgACAHQQxqIAIQrAFFDQAgBygCDCAIKAIoTw0AQX8gACAIEJIDDQEaCyAAIAEgAiADIAQgBSAGQYCACHIQbQshACAHQRBqJAAgAAuBAgIDfwF+AkACQCACQQBODQAgAacpAyAiCkKAgICAcINCgICAgJB/Ug0AIAJB/////wdxIgggCqciBykCBCIKp0H/////B3FPDQACQEEEIAYQkwNFDQBBASECIAZBgMAAcUUNAiADQoCAgIBwg0KAgICAkH9SDQAgA6ciCSkCBCIBQv////8Hg0IBUg0AIAdBEGohBwJ/IApCgICAgAiDUEUEQCAHIAhBAXRqLwEADAELIAcgCGotAAALAn8gAUKAgICACINQRQRAIAkvARAMAQsgCS0AEAtGDQILIAAgBkHh6QAQbw8LIAAgASACIAMgBCAFIAZBgIAIchBtIQILIAILRgACfwJAIAJBAE4NACABpykDICIBQoCAgIBwg0KAgICAkH9SDQBBACACQf////8HcSABpygCBEH/////B3FJDQEaC0EBCwuzAQECfwJAIANBAE4NACACpykDICICQoCAgIBwg0KAgICAkH9SDQAgA0H/////B3EiAyACpyIEKQIEIgKnQf////8HcU8NAEEBIQUgAUUNACAEQRBqIQQCfyACQoCAgIAIg1BFBEAgBCADQQF0ai8BAAwBCyADIARqLQAACyEDIAFBBDYCACAAIANB//8DcRCfAyECIAFCgICAgDA3AxggAUKAgICAMDcDECABIAI3AwgLIAULWwECfyABpygCECIAQTBqIQMgACAAKAIYIAJxQX9zQQJ0aigCACEAA0ACQCAARQ0AIAMgAEEBa0EDdGoiBCgCBCACRg0AIAQoAgBB////H3EhAAwBCwsgAEEARws1AQF+IAEpAwAiAkIgiKdBdU8EQCACpyIBIAEoAgBBAWo2AgALIAAgAhCKAUKAgICA4AAQUwuOAQECfyABKAIAIgJBAEoEQCABIAJBAWsiAjYCAAJAIAINACABLQAEQfABcUEQRw0AIAEoAggiAiABKAIMIgM2AgQgAyACNgIAIAFBADYCCCAAKAJgIgIgAUEIaiIDNgIEIAEgAEHgAGo2AgwgASACNgIIIAAgAzYCYAsPC0HFjQFBrvwAQbAsQc/0ABAAAAtvAQJ/IAEgASgCACICQQFqNgIAIAJFBEAgASgCCCICIAEoAgwiAzYCBCADIAI2AgAgAUEANgIIIAAoAlAiAiABQQhqIgM2AgQgASAAQdAAajYCDCABIAI2AgggACADNgJQIAEgAS0ABEEPcToABAsLDwAgASABKAIAQQFqNgIAC4gBAgF+AX9BACECQoCAgIAwIQEDQAJAIAJBAkcEfiAFIAJBA3QiBGoiBzUCBEIghkKAgICAMFENASAAQawuQQAQFUKAgICA4AAFQoCAgIAwCw8LIAMgBGopAwAiBkIgiKdBdU8EQCAGpyIEIAQoAgBBAWo2AgALIAcgBjcDACACQQFqIQIMAAsAC1wBAn4gAiAAKAIAEC0hA0EAIQAgA0KAgICAcINCgICAgOAAUSACIAEoAgAQLSIEQoCAgIBwg0KAgICA4ABRckUEQCADpyAEpxCDAiEACyACIAMQDyACIAQQDyAAC2sBAX4CQAJAAkACQAJAIAMtAAUiAQ4EAwICAAELIAAgAygCCBDKBA8LIAFBCEYNAgsQAQALIAAgAygCDCADKAIAIAMtAAggAy0ACSADLgEGEIIBDwsgACAAEDQiBCADKAIIIAMoAgwQIiAECwkAIAAgAxCNAwtTAQF+IAAQNCIEQoCAgIBwg0KAgICA4ABSBEAgASABKAIAQQFqNgIAIAAgBEE8IAGtQoCAgIBwhEEDEBlBAE4EQCAEDwsgACAEEA8LQoCAgIDgAAsDAAELagEBfyMAQRBrIgMkACABKAIEIQEgAiADQQxqIAAoAgQQrAFBACACIANBCGogARCsARtFBEBB0MUAQa78AEGDOkH8yQAQAAALIAMoAgghACADKAIMIQEgA0EQaiQAQX8gACABRyAAIAFLGwvaAwICfgF/IwBBIGsiBSQAAkACQCAAIAFBLBBLIgJFDQBCgICAgDAhAQJAIAIpAwAiBkKAgICAcINCgICAgDBSBEACfwJAIAanIgMvAQZBFWtB//8DcUEKTQRAIAMoAiAoAgwoAiAtAARFDQEgABBrDAULIAAgBUEcaiAGENYBDQQgBUEcagwBCyADQShqCyEIIAIoAgwiAyAIKAIASQ0BIAAgAikDABAPIAJCgICAgDA3AwALIARBATYCAAwCCyACIANBAWo2AgwgBEEANgIAIAIoAghFBEAgA0EATgRAIAOtIQEMAwtCgICAgMB+IAO4vSIBQoCAgIDAgYD8/wB9IAFC////////////AINCgICAgICAgPj/AFYbIQEMAgtCgICAgOAAIQEgACACKQMAIAMQsAEiBkKAgICAcINCgICAgOAAUQ0BIAIoAghBAUYEQCAGIQEMAgsgBSAGNwMIIAUgA0EATgR+IAOtBUKAgICAwH4gA7i9IgFCgICAgMCBgPz/AH0gAUL///////////8Ag0KAgICAgICA+P8AVhsLIgc3AwAgAEECIAUQiQMhASAAIAYQDyAAIAcQDwwBCyAEQQA2AgBCgICAgOAAIQELIAVBIGokACABCxAAIwAgAGtBcHEiACQAIAALBgAgACQACwQAIwAL7gICBH8CfiMAQRBrIgMkAAJAAkAgAikDECIHQoCAgIBwg0KAgICAkH9SBEAgAEGDlAFBABAVDAELIAIpAxghCCAAIAcQswEiBEUEQEEAIQQMAQsgACAIELMBIgZFDQACQCAAIAQgBhDJBSIBRQ0AIAAgARD+A0EASARAIABBARCPBAwBCyABIAEoAgBBAWo2AgAgACABrUKAgICAUIQgACkDwAFBAEEAEMgFIgdCgICAgHCDQoCAgIDgAFENACAAIAcQDyABIQULIAAgBhBUIAVFDQAgAyAAIAUQjQMiBzcD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ACEEIANCADcCaCADQoCAgICAgICAgH83AmAgAyAENgJcIANB3ABqIgUgARBEGiADQgA3AlQgA0KAgICAgICAgIB/NwJMIAMgBDYCSCADKAJkIQYgA0EANgJkIANByABqIgFCqtWq1QoQMBogA0EANgJQIAUgARCyAgRAIAMgAygCZEEBajYCZCAGQQFrIQYLIANByABqEBsgAkEBakEBdhCVBiEFIANCADcCVCADQoCAgICAgICAgH83AkwgAyAENgJIIANCADcCQCADQoCAgICAgICAgH83AjggAyAENgI0IANB3ABqIgEgAUJ/Qf////8DQQAQdRogBUEAIAVBAEobIQkgAiAFaiACIAVBAXRuQQFqIgpBAXRqQSBqIQJBACEBA0AgASAJRkUEQCADQcgAaiIHIANB3ABqIghCASACQQAQdRogA0E0aiILIAcgAkEGEJEGIAcgC0IBIAJBABB1GiAIIAggByACQQAQlQEaIAFBAWohAQwBCwsgA0IANwIsIANCgICAgICAgICAfzcCJCADIAQ2AiAgA0IANwIYIANCgICAgICAgICAfzcCECADIAQ2AgwgA0EgaiIBIANB3ABqIgRCAiACQQAQdRogASAEIAEgAkEAEJUBGiADQQxqIAEgASACQQAQQxogAEIAEDAaIAqsIQwDQCAMQgBXRQRAIANByABqIgFCARAwGiADQTRqIgQgDKdBAXRBAXKsEDAaIAEgASAEIAJBABCVARogACAAIAEgAkEAEMsBGiAAIAAgA0EMaiACQQAQQxogDEIBfSEMDAELCyAAIABCASACQQAQdRogACAAIANBIGoiASACQQAQQxogARAbIANBDGoQGyADQTRqEBsgA0HIAGoQGyAAIAVBAWpB/////wNBARDMARogA0HcAGoiASACQQYQ0wIgASABIAasIAJBABDUAiAAIAAgASACQQAQywEaIAEQGyADQfAAaiQAQRAPC0HY/QBB1PwAQdciQajWABAAAAsRACAAIAEgAiADIARBABCWBgsRACAAIAEgAiADIARBARCWBgvYAwEHfyACKAIEIAEoAgRzIQcCQAJAAkACQAJAAkACQCABKAIIIgZB/f///wdMBEAgAigCCCIFQf3///8HSg0BIAZBgICAgHhHDQYgBUGAgICAeEYNBAwHCyAGQf////8HRg0BIAIoAggh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gICAMEEBENQFDQIgACABEA8LIAJBAWohAgwACwALIAAgBBAPIAAgARAPQoCAgIDgAAsYACAAIAMpAwAgAykDCBBSrUKAgICAEIQL4gICA34DfyMAQSBrIgIkAEKAgICA4AAhBCAAIAMpAwAQJSIFQoCAgIBwg0KAgICA4ABSBEBCgICAgDAhAQJAAkAgACACQRxqIAJBGGogBadBAxCOAQ0AQoCAgIDgACEBIAAQNCIEQoCAgIBwg0KAgICA4ABRDQAgAigCHCEHIAIoAhghCEEAIQMDQCADIAhHBEACQAJAIAAgByADQQN0aiIJKAIEEFwiAUKAgICAcINCgICAgOAAUQ0AIAIgATcDCCACIAU3AwAgACAEIAAgAkEAEMYEIQYgACABEA8gBkKAgICAcIMiAUKAgICAMFENASABQoCAgIDgAFENACAAIAQgCSgCBCAGQYeAARAZQQBODQELIAQhAQwDCyADQQFqIQMMAQsLIAAgByAIEFogBSEBDAELIAAgAigCHCACKAIYEFogACAFEA9CgICAgOAAIQQLIAAgARAPCyACQSBqJAAgBAsQACAAIAMpAwBBESAEEKoCCxAAIAAgAykDAEECQQAQqgILEAAgACADKQMAQQFBABCqAgtHAQF+QoCAgIDgACEEIAAgAykDACIBIAMpAwgQrgYEfkKAgICA4AAFIAFCIIinQXVPBEAgAaciACAAKAIAQQFqNgIACyABCwtBACAAIAMpAwAiASADKQMIQQEQiwJBAEgEQEKAgICA4AAPCyABQiCIp0F1TwRAIAGnIgAgACgCAEEBajYCAAsgAQuJAQEBfiADKQMAIgFC/////29WIAFCgICAgHCDQoCAgIAgUXJFBEAgAEG35ABBABAVQoCAgIDgAA8LAkAgACABEEciAUKAgICAcINCgICAgOAAUgRAIAMpAwgiBEKAgICAcINCgICAgDBRDQEgACABIAQQrgZFDQEgACABEA8LQoCAgIDgAA8LIAELpQQCBX8CfiMAQSBrIgUkACAAIAVBCGoiBkEAED0aIAZBKBA7GiAEQX5xQQJGBEAgBUEIakHxmQEQiAEaCyAFQQhqQbrMABCIARogBEF9cUEBRgRAIAVBCGpBKhA7GgsgBUEIakGvlAEQiAEaQQAhBiACQQFrIgdBACAHQQBKGyEIAkACQAJAA0AgBiAIRwRAIAYEQCAFQQhqQSwQOxoLIAZBA3QhCSAGQQFqIQYgBUEIaiADIAlqKQMAEIcBRQ0BDAILCyAFQQhqQYaaARCIARogAkEASgRAIAVBCGogAyAHQQN0aikDABCHAQ0BCyAFQQhqIgJBiZEBEIgBGkKAgICAMCELIAIQNiIKQoCAgIBwg0KAgICA4ABRDQEgACAAKQPAASAKQQNBfxCcAyELIAAgChAPIAtCgICAgHCDQoCAgIDgAFENASABQoCAgIBwg0KAgICAMFENAiAAIAFBOyABQQAQFCIKQoCAgIBwg0KAgICA4ABRDQECQCAKQv////9vVg0AIAAgChAPIAAgARCAAyICRQ0CIAIoAiggBEEBdEGuwAFqLwEAQQN0aikDACIKQiCIp0F1SQ0AIAqnIgIgAigCAEEBajYCAAsgACALIApBARCLAiECIAAgChAPIAJBAE4NAgwBCyAFKAIIKAIQIgJBEGogBSgCDCACKAIEEQAAQoCAgIAwIQsLIAAgCxAPQoCAgIDgACELCyAFQSBqJAAgCwuAAgICfgF/IwBBIGsiByQAQoCAgIDgACEFAkACQCAAIAEQJSIBQoCAgIBwg0KAgICA4ABRDQAgACADKQMAEDEiA0UNAANAIAAgByABpyADEEwiAkEASA0CIAIEQEKAgICAMCEFAkAgBy0AAEEQcUUNACAHQRhBECAEG2opAwAiBUIgiKdBdUkNACAFpyICIAIoAgBBAWo2AgALIAAgBxBIDAMLIAAgARCMAiIBQoCAgIBwgyIGQoCAgIAgUgRAIAZCgICAgOAAUQRAIAYhBQwECyAAEHtFDQEMAwsLQoCAgIAwIQUMAQtBACEDCyAAIAMQEyAAIAEQDyAHQSBqJAAgBQuxAQEDfiADKQMIIQUgAykDACEGQoCAgIDgACEHAkAgACABECUiAUKAgICAcINCgICAgOAAUgR+IAAgBRBgDQEgACAGEDEiAkUNASAAIAEgAkKAgICAMEKAgICAMCAFIAQbIAVCgICAgDAgBBtBhaoBQYWaASAEGxBtIQMgACABEA8gACACEBNCgICAgOAAQoCAgIAwIANBAEgbBUKAgICA4AALDwsgACABEA9CgICAgOAAC3IBAX5CgICAgDAhAyABQoCAgIAQhEKAgICAcINCgICAgDBRBEAgABAkQoCAgIDgAA8LIAJCgICAgHCDQoCAgIAgUiACQv////9vWHEEfkKAgICAMAVCgICAgOAAQoCAgIAwIAAgASACQQEQiwJBAEgbCwsyAQF+IAAgARAlIgFCgICAgHCDQoCAgIDgAFEEQCABDwsgACABEOgBIQIgACABEA8gAgugAQIBfgF/IwBBIGsiAiQAQoCAgIDgACEEAkACQCAAIAEQJSIBQoCAgIBwg0KAgICA4ABRDQAgACADKQMAEDEiA0UNACAAIAIgAacgAxBMIgVBAEgNASAFRQRAQoCAgIAQIQQMAgsgAjUCACEEIAAgAhBIIARCAohCAYNCgICAgBCEIQQMAQtBACEDCyAAIAMQEyAAIAEQDyACQSBqJAAgBAvBAQECfgJAAn5CgICAgBAgAykDACIEQoCAgIBwVA0AGkKAgICA4AAgACABECUiAUKAgICAcINCgICAgOAAUQ0AGiAEpyICIAIoAgBBAWo2AgAgAachAgNAIAAgBBCMAiIEQoCAgIBwgyIFQoCAgIDgAFIEQCACIASnRiAFQoCAgIAgUXINAyAAEHtFDQELCyAAIAQQDyAAIAEQD0KAgICA4AALDwsgACAEEA8gACABEA8gBUKAgICAIFKtQoCAgIAQhAt6AQF+IAAgAykDABAxIgJFBEBCgICAgOAADwtCgICAgOAAIQQgACABECUiAUKAgICAcINCgICAgOAAUQRAIAAgAhATIAEPCyAAQQAgAacgAhBMIQMgACACEBMgACABEA9CgICAgOAAIANBAEetQoCAgIAQhCADQQBIGwsIACAAIAEQJQsPACAAIAFBN0EAQQAQrAILLQEBfkKAgICAMCECAkAgARCjAyIARQ0AIAAtABJBBHFFDQAgADUCRCECCyACCzMCAX4Bf0KAgICAMCECAkAgARCjAyIDRQ0AIAMtABJBBHFFDQAgACADKAJAEC0hAgsgAgsoAEKAgICA4AAgACADKQMAIAEQvgUiAEEAR61CgICAgBCEIABBAEgbC7cBAgF+An9CgICAgOAAIQQgACABEGAEfkKAgICA4AAFQcqZASECAkAgAaciAy8BBhDuAUUNAAJAIAMoAiAiAy8AESIFQYAIcUUNACADKAJUIgZFDQAgACAGIAMoAkgQkwIPCyAFQQR2QQNxQQFrIgNBAksNACADQQJ0QfT/AWooAgAhAgsgACACIAAgAUE2IAFBABAUIgFCgICAgHCDQoCAgIAwUQR+IABBLxAtBSABC0G+GRC+AQsL6QUDA34GfwN8AkACfkKAgICA4AAgACABEGANABpCgICAgOAAIAAgACkDMEEOEEkiBUKAgICAcINCgICAgOAAUQ0AGiAFpyIKIAFCgICAgHBaBH8gAactAAVBEHEFQQALIAotAAVB7wFxcjoABSAAQQEgAiACQQFMGyILQQFrIghBA3RBGGoQKSIHRQ0BIAFCIIinQXVPBEAgAaciAiACKAIAQQFqNgIACyAHIAE3AwAgAykDACIEQiCIp0F1TwRAIASnIgIgAigCAEEBajYCAAsgByAINgIQIAcgBDcDCEEAIQIDQCACIAhHBEAgAyACQQFqIglBA3RqKQMAIgRCIIinQXVPBEAgBKciDCAMKAIAQQFqNgIACyAHIAJBA3RqIAQ3AxggCSECDAELCyAKIAc2AiAgAUL/////b1gEQCAAECQMAgsgAEEAIAGnQTAQTCICQQBIDQFCACEEAkAgAkUNACAAIAFBMCABQQAQFCIGQoCAgIBwg0KAgICA4ABRDQIgBkL/////D1gEQCAGpyICIAhrQQAgAiALThutIQQMAQsgBkIgiKdBB2tBbU0EQAJAIAZCgICAgMCBgPz/AHwiBEL///////////8Ag0KAgICAgICA+P8AVg0AIAS/nSIOIAi3Ig9lDQAgDiAPoSENCyANvSIEAn8gDZlEAAAAAAAA4EFjBEAgDaoMAQtBgICAgHgLIgK3vVEEQCACrSEEDAILQoCAgIDAfiAEQoCAgIDAgYD8/wB9IARC////////////AINCgICAgICAgPj/AFYbIQQMAQsgACAGEA8LIAAgBUEwIARBARAZGiAAQdSZASAAIAFBNiABQQAQFCIEQoCAgIBwgyIBQoCAgICQf1IEfiABQoCAgIDgAFENAiAAIAQQDyAAQS8QLQUgBAtBzJ4BEL4BIgFCgICAgHCDQoCAgIDgAFENASAAIAVBNiABQQEQGRogBQsPCyAAIAUQD0KAgICA4AALMAAgAkEATARAIAAgAUKAgICAMEEAQQAQIQ8LIAAgASADKQMAIAJBAWsgA0EIahAhC6MCAgF/BH4jAEEQayIFJABCgICAgDAhBgJAAkAgACAFQQhqIAAgARAlIgkQPA0AIAVBATYCBAJAIAQEQCAD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gDBSBEAgB0KAgICA4ABRDQcgACABECYMAQsgACAFEMoBCyICQQBIDQUgAkUNACAAIAkgBRA8DQUgCSkDACIHIAR8Qv////////8PVQ0EQgAhASAHQgAgB0IAVRshBwNAIAEgB1ENAiAAIAUgASAJQQhqEIUBIgJBAEgNBiACBEAgACAGIAQgCSkDCBBqQQBIDQcLIARCAXwhBCABQgF8IQEMAAsACyAEQv7///////8PVQ0DIAVCIIinQXVPBEAgBaciAiACKAIAQQFqNgIACyAAIAYgBCAFEGpBAEgNBCAEQgF8IQQLIApBAWohCgwBCwsgACAGQTAgBEKAgICACHxC/////w9YBH4gBEL/////D4MFQoCAgIDAfiAEub0iAUKAgICAwIGA/P8AfSABQv///////////wCDQoCAgICAgID4/wBWGwsQRUEASA0BDAILIABB0NoAQQAQFQsgACAGEA9CgICAgOAAIQYLIAAgCBAPIAlBEGokACAGC7ECAgR+An8jAEEQayIIJABCgICAgOAAIQUCQAJ+AkAgAUKAgICAcFQNACABpy0ABUEQcUUNACAIIAKtNwMIIAAgAUEBIAhBCGoQpwEMAQsgABA+CyIEQoCAgIBwg0KAgICA4ABRDQAgAkEAIAJBAEobrSEHQgAhAQJAA0AgASAHUgRAIAMgAadBA3RqKQMAIgZCIIinQXVPBEAgBqciCSAJKAIAQQFqNgIACyAAIAQgASAGQYCAARDSASEJIAFCAXwhASAJQQBODQEMAgsLIAAgBEEwIAJBAE4EfiACrQVCgICAgMB+IAK4vSIBQoCAgIDAgYD8/wB9IAFC////////////AINCgICAgICAgPj/AFYbCxBFQQBIDQAgBCEFDAELIAAgBBAPCyAIQRBqJAAgBQu6CQICfwh+IwBBMGsiBCQAIAMpAwAhBiAEQoCAgIAwNwMYQQEhBQJAAkACfiACQQJIBEBCgICAgDAhDEKAgICAMAwBC0KAgICAMCADKQMIIgxCgICAgHCDQoCAgIAwUQ0AGkKAgICAMCEKQoCAgIAwIQlCgICAgDAhCEKAgICAMCELIAAgDBBgDQFBACEFQoCAgIAwIAJBA0kNABogAykDEAshDQJAAkACQAJAIAAgBkHRASAGQQAQFCIHQoCAgIBwgyIIQoCAgIAwUgRAAkACQCAIQoCAgIDgAFEEQEKAgICAMCEKQoCAgIAwIQlCgICAgDAhCAwBCyAAIAcQDwJ+AkAgAUKAgICAcFQNACABpy0ABUEQcUUNACAAIAFBAEEAEKcBDAELIAAQPgsiCEKAgICAcINCgICAgOAAUQRAQoCAgIAwIQpCgICAgDAhCQwBCyAGQiCIp0F1TwRAIAanIgIgAigCAEEBajYCAAsgBCAGNwMQIAAgBEEQakEIckEAEJkDIQIgBCkDGCEKIAQpAxAhCSACRQ0BC0KAgICAMCELDAYLQgAhBwNAIAAgCSAKIARBCGoQrgEiBkKAgICAcINCgICAgOAAUQ0CIAQoAggEQEKAgICAMCELDAYLAkAgBQRAIAYhAQwBCyAEIAY3AyAgBCAHQv////8PgzcDKCAAIAwgDUECIARBIGoQISEBIAAgBhAPIAFCgICAgHCDQoCAgIDgAFENAwsgACAIIAcgARBqQQBIDQIgB0IBfCEHDAALAAsgACAGECUiC0KAgICAcINCgICAgOAAUQ0CIAAgBEEIaiALEDxBAEgNAiAEAn4gBCkDCCIGQoCAgIAIfEL/////D1gEQCAGQv////8PgwwBC0KAgICAwH4gBrm9IgdCgICAgMCBgPz/AH0gB0L///////////8Ag0KAgICAgICA+P8AVhsLIgc3AyACfgJAIAFCgICAgHBUDQAgAactAAVBEHFFDQAgACABQQEgBEEgahCnAQwBCyAAQoCAgIAwQQEgBEEgahCuAwshCCAAIAcQDyAIQoCAgIBwg0KAgICA4ABRBEBCgICAgDAhCgwCC0IAIQcgBkIAIAZCAFUbIQkDQCAHIAlRBEBCgICAgDAhCkKAgICAMCEJDAULQoCAgIAwIQogACALIAcQcyIGQoCAgIBwg0KAgICA4ABRDQICQCAFBEAgBiEBDAELIAQgBjcDICAEIAdC/////w+DNwMoIAAgDCANQQIgBEEgahAhIQEgACAGEA8gAUKAgICAcINCgICAgOAAUQ0DCyAAIAggByABEGpBAEgNAiAHQgF8IQcMAAsAC0KAgICAMCELIAlCgICAgHCDQoCAgIAwUQ0DIAAgCUEBEK0BGgwDC0KAgICAMCEJDAILQoCAgIAwIQpCgICAgDAhCUKAgICAMCEIDAELIAAgCEEwIAenIgJBAE4EfiAHQv////8PgwVCgICAgMB+IAK4vSIBQoCAgIDAgYD8/wB9IAFC////////////AINCgICAgICAgPj/AFYbCxBFQQBODQELIAAgCBAPQoCAgIDgACEICyAAIAsQDyAAIAkQDyAAIAoQDyAEQTBqJAAgCAsmAEKAgICA4AAgACADKQMAEMoBIgBBAEetQoCAgIAQhCAAQQBIGwuAAQAjAEEQayIAJAAgABCjBAJ+IAA0AgggACkDAELAhD1+fCIBQoCAgIAIfEL/////D1gEQCABQv////8PgwwBC0KAgICAwH4gAbm9IgFCgICAgMCBgPz/AH0gAUL///////////8Ag0KAgICAgICA+P8AVhsLIQEgAEEQaiQAIAELxwIBBX8jAEEgayIEJAAgACADKQMAECgiAUKAgICAcINCgICAgOAAUgRAIAAgBEEIakEAED0aIAGnIgVBEGohBiAFKAIEQf////8HcSEHQQAhAwNAIAMgB05FBEACQAJ/IAUpAgRCgICAgAiDUCIIRQRAIAYgA0EBdGovAQAMAQsgAyAGai0AAAsiAkElRw0AAkAgA0EGaiAHSg0AIANBAWohAgJ/IAhFBEAgBiACQQF0ai8BAAwBCyACIAZqLQAAC0H1AEcNACAFIANBAmpBBBC4BCICQQBIDQAgA0EFaiEDDAELQSUhAiADQQNqIAdKDQAgBSADQQFqQQIQuAQiAkElIAJBAE4iCBshAiADQQJqIAMgCBshAwsgBEEIaiACEIsBGiADQQFqIQMMAQsLIAAgARAPIARBCGoQNiEBCyAEQSBqJAAgAQvkAQEEfyMAQSBrIgIkACAAIAMpAwAQKCIBQoCAgIBwg0KAgICA4ABSBEAgACACQQhqIAGnIgUoAgRB/////wdxED0aIAVBEGohBiAFKAIEQf////8HcSEHQQAhAwNAIAMgB0ZFBEACQAJAAkAgBS0AB0GAAXFFBEAgAyAGai0AACEEDAELIAYgA0EBdGovAQAiBEH/AUsNAQtBkOEBIARBxQAQ+wFFDQAgAkEIaiAEEIsBGgwBCyACQQhqIAQQmgILIANBAWohAwwBCwsgACABEA8gAkEIahA2IQELIAJBIGokACABC84EAgZ/AX4jAEEgayIGJAACQCAAIAMpAwAQKCIBQoCAgIBwg0KAgICA4ABRDQAgACAGQQhqIAGnIgkoAgRB/////wdxED0aIAlBEGohCEEAIQICQANAIAkpAgQiC6dB/////wdxIgogAkoEQCACQQFqIQUCQAJAIAtCgICAgAiDIgtQBEAgAiAIai0AACEDDAELIAggAkEBdGovAQAiA0H/AUsNAQsCQCADQTBrQQpJIANB3/8DcUHBAGtBGklyDQBBpZQBIANBCRD7AQ0AIAQNASADELIGRQ0BCyAGQQhqIAMQiwEaIAUhAgwCCwJ/An8CQCADQYD4A3EiB0GAsANHBEAgB0GAuANHDQFBv8MAIQcMBgtB5MAAIQcgBSAKTg0FAn8gC1BFBEAgCCAFQQF0ai8BAAwBCyAFIAhqLQAACyIFQYDAA2tBgHhJDQUgBkEIaiAFQf8HcSADQQp0QYD4P3FyQYCABGoiA0ESdkHwAXIQmgIgA0EMdkE/cUGAAXIhByACQQJqDAELIANB/wBNBEAgBkEIaiADEJoCIAUhAgwECyADQf8PTQRAIAUhAiADQQZ2QcABcgwCCyADQQx2QeABciEHIAULIQIgBkEIaiAHEJoCIANBBnZBP3FBgAFyCyEHIAZBCGoiBSAHEJoCIAUgA0E/cUGAAXIQmgIMAQsLIAAgARAPIAZBCGoQNiEBDAELIAAgBxC5BCAAIAEQDyAGKAIIKAIQIgBBEGogBigCDCAAKAIEEQAAQoCAgIDgACEBCyAGQSBqJAAgAQuVBAIGfwF+IwBBIGsiBSQAAkAgACADKQMAECgiAUKAgICAcINCgICAgOAAUQ0AIAAgBUEIakEAED0aIAGnIghBEGohCUEAIQIDQAJAAkACQCAIKQIEIgunQf////8HcSACSgRAAn8gC0KAgICACINQRQRAIAkgAkEBdGovAQAMAQsgAiAJai0AAAsiA0ElRgRAIAAgCCACELMGIgNBAEgNAyACQQNqIQYgA0H/AE0EQCAEBEAgBiECDAYLQSUgAyADELIGIgcbIQMgAkEBaiAGIAcbIQIMBQsCfyADQWBxQcABRgRAIANBH3EhA0GAASEHQQEMAQsgA0FwcUHgAUYEQCADQQ9xIQNBgBAhB0ECDAELIANBeHFB8AFHBEBBASEHQQAhA0EADAELIANBB3EhA0GAgAQhB0EDCyECA0AgAkEATA0DIAAgCCAGELMGIgpBAEgNBCAGQQNqIQYgCkHAAXFBgAFHBEBBACEDDAQFIAJBAWshAiAKQT9xIANBBnRyIQMMAQsACwALIAJBAWohAgwDCyAAIAEQDyAFQQhqEDYhAQwECyAGIQIgAyAHSCADQf//wwBKckUgA0GAcHFBgLADR3ENASAAQcmJARC5BAsgACABEA8gBSgCCCgCECIAQRBqIAUoAgwgACgCBBEAAEKAgICA4AAhAQwCCyAFQQhqIAMQuQEaDAALAAsgBUEgaiQAIAELNwAgACADKQMAELMBIgJFBEBCgICAgOAADwsgACACEIECIAJqQQBBCkEAELgCIQEgACACEFQgAQuHAQEBfyMAQRBrIgIkAAJAIAAgAykDABCzASIERQRAQoCAgIDgACEBDAELAn5CgICAgOAAIAAgAkEMaiADKQMIEHcNABogAigCDCIDBEBCgICAgMB+IANBJWtBXUkNARoLIAAgBBCBAiAEakEAIANBgQgQuAILIQEgACAEEFQLIAJBEGokACABCwkAIAAgARDdAgujAQIBfgF/IwBBEGsiAiQAAn4gACABEN0CIgVCgICAgHCDQoCAgIDgAFEEQCAFDAELQQohBgJAAkAgBA0AIAMpAwAiAUKAgICAcINCgICAgDBRDQAgACABEI4FIgZBAEgNAQtCgICAgOAAIAAgAkEIaiAFEG4NARogACACKwMIIAZBAEEAEI8CDAELIAAgBRAPQoCAgIDgAAshASACQRBqJAAgAQuMAgIBfgF8IwBBEGsiAiQAQoCAgIDgACEEAkAgACABEN0CIgFCgICAgHCDQoCAgIDgAFEEQCABIQQMAQsgACACIAEQbg0AAkACQCADKQMAIgFCgICAgHCDQoCAgIAwUQRAIAIpAwAhAQwBCyAAIAJBDGogARC6AQ0CIAIrAwAiBb0iAUKAgICAgICA+P8Ag0KAgICAgICA+P8AUg0BCyAAQoCAgIDAfiABQoCAgIDAgYD8/wB9IAFC////////////AINCgICAgICAgPj/AFYbEDchBAwBCyACKAIMIgNB5QBrQZt/TQRAIABBijRBABBQDAELIAAgBUEKIANBARCPAiEECyACQRBqJAAgBAvYAQIBfgF8IwBBEGsiAiQAQoCAgIDgACEEAkAgACABEN0CIgFCgICAgHCDQoCAgIDgAFEEQCABIQQMAQsgACACIAEQbg0AIAAgAkEMaiADKQMAELoBDQAgAigCDCIDQeUATwRAIABBijRB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LUiv7z8IIKpBvMOOPCdaYe4buu8/Muupw5QrhDyXums3K8XvP+6F0TGpZIo8QEVuW3bQ7z/t4zvkujeOvBS+nK392+8/nc2RTTuJdzzYkJ6BwefvP4nMYEHBBVM88XGPK8Lz7z8AAAAAAADwPwAAAAAAAPg/AAAAAAAAAAAG0M9D6/1MPgBBmxkL54UBQAO44j8oKXt9ACgpe3N1cGVyKC4uLmFyZ3VtZW50cyk7fQAoKSB7CiAgICBbbmF0aXZlIGNvZGVdCn0AY2Fubm90IG1peCA/PyB3aXRoICYmIG9yIHx8AGN0egBwcm94eTogcHJvcGVydHkgbm90IHByZXNlbnQgaW4gdGFyZ2V0IHdlcmUgcmV0dXJuZWQgYnkgbm9uIGV4dGVuc2libGUgcHJveHkAcmV2b2tlZCBwcm94eQBQcm94eQBhZGRfcHJvcGVydHkAcHJveHk6IGNhbm5vdCBzZXQgcHJvcGVydHkAbm8gc2V0dGVyIGZvciBwcm9wZXJ0eQB2YWx1ZSBoYXMgbm8gcHJvcGVydHkAY291bGQgbm90IGRlbGV0ZSBwcm9wZXJ0eQBwcm94eTogZHVwbGljYXRlIHByb3BlcnR5AEpTX0RlZmluZUF1dG9Jbml0UHJvcGVydHkAaGFzT3duUHJvcGVydHkAcHJveHk6IGluY29uc2lzdGVudCBkZWxldGVQcm9wZXJ0eQBwcm94eTogaW5jb25zaXN0ZW50IGRlZmluZVByb3BlcnR5AEpTX0RlZmluZVByb3BlcnR5ACFtci0+ZW1wdHkAaW5maW5pdHkASW5maW5pdHkAb3V0IG9mIG1lbW9yeQB1bmtub3duIHVuaWNvZGUgZ2VuZXJhbCBjYXRlZ29yeQBHZW5lcmFsX0NhdGVnb3J5AGV2ZXJ5AGFueQBhcHBseQAnJXMnIGlzIHJlYWQtb25seQBleHBlY3RpbmcgY2F0Y2ggb3IgZmluYWxseQBzdGlja3kAYmlnaW50IGFyZSBmb3JiaWRkZW4gaW4gSlNPTi5zdHJpbmdpZnkAc3ViYXJyYXkAZW1wdHkgYXJyYXkAbm9uIGludGVnZXIgaW5kZXggaW4gdHlwZWQgYXJyYXkAbmVnYXRpdmUgaW5kZXggaW4gdHlwZWQgYXJyYXkAb3V0LW9mLWJvdW5kIGluZGV4IGluIHR5cGVkIGFycmF5AGNhbm5vdCBjcmVhdGUgbnVtZXJpYyBpbmRleCBpbiB0eXBlZCBhcnJheQBpc0FycmF5AFR5cGVkQXJyYXkAZ2V0RGF5AGdldFVUQ0RheQBqc19nZXRfYXRvbV9pbmRleABpbnZhbGlkIGFycmF5IGluZGV4AG91dC1vZi1ib3VuZCBudW1lcmljIGluZGV4AEpTX0F0b21Jc0FycmF5SW5kZXgAZmluZEluZGV4AGludmFsaWQgZXhwb3J0IHN5bnRheABpbnZhbGlkIGFzc2lnbm1lbnQgc3ludGF4AG1heABcdSUwNHgAaW52YWxpZCBvcGNvZGU6IHBjPSV1IG9wY29kZT0weCUwMngALSsgICAwWDB4AC0wWCswWCAwWC0weCsweCAweABsaW5lIHRlcm1pbmF0b3Igbm90IGFsbG93ZWQgYWZ0ZXIgdGhyb3cAYmZfcG93AG5vdwBpbnRlZ2VyIG92ZXJmbG93AHN0YWNrIG92ZXJmbG93AG11c3QgYmUgY2FsbGVkIHdpdGggbmV3AGlzVmlldwBEYXRhVmlldwByYXcAdGRpdgBmZGl2AGVkaXYAY2RpdgAldQBjbGFzcyBkZWNsYXJhdGlvbnMgY2FuJ3QgYXBwZWFyIGluIHNpbmdsZS1zdGF0ZW1lbnQgY29udGV4dABmdW5jdGlvbiBkZWNsYXJhdGlvbnMgY2FuJ3QgYXBwZWFyIGluIHNpbmdsZS1zdGF0ZW1lbnQgY29udGV4dABsZXhpY2FsIGRlY2xhcmF0aW9ucyBjYW4ndCBhcHBlYXIgaW4gc2luZ2xlLXN0YXRlbWVudCBjb250ZXh0AGR1cGxpY2F0ZSBhcmd1bWVudCBuYW1lcyBub3QgYWxsb3dlZCBpbiB0aGlzIGNvbnRleHQAZHVwbGljYXRlIHBhcmFtZXRlciBuYW1lcyBub3QgYWxsb3dlZCBpbiB0aGlzIGNvbnRleHQAaW1wb3J0Lm1ldGEgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGNvbnRleHQASlNfRnJlZUNvbnRleHQASlNDb250ZXh0AGpzX21hcF9pdGVyYXRvcl9uZXh0AGpzX2FzeW5jX2dlbmVyYXRvcl9yZXN1bWVfbmV4dAB1bmV4cGVjdGVkIGVuZCBvZiBpbnB1dAB0dABleHBvcnRlZCB2YXJpYWJsZSAnJXMnIGRvZXMgbm90IGV4aXN0AHByaXZhdGUgY2xhc3MgZmllbGQgJyVzJyBkb2VzIG5vdCBleGlzdAB0ZXN0AGFzc2lnbm1lbnQgcmVzdCBwcm9wZXJ0eSBtdXN0IGJlIGxhc3QAYmZfc3FydABzb3J0AGNicnQAdHJpbVN0YXJ0AHBhZFN0YXJ0AHVua25vd24gdW5pY29kZSBzY3JpcHQAU2NyaXB0AGh5cG90AGZyZWVfemVyb19yZWZjb3VudABmYXN0X2FycmF5X2NvdW50AGJpbmFyeV9vYmplY3RfY291bnQAc3RyX2luZGV4ID09IG51bV9rZXlzX2NvdW50ICsgc3RyX2tleXNfY291bnQAbnVtX2luZGV4ID09IG51bV9rZXlzX2NvdW50AHN0cl9jb3VudABwcm9wX2NvdW50AHN5bV9pbmRleCA9PSBhdG9tX2NvdW50AGxhYmVsID49IDAgJiYgbGFiZWwgPCBzLT5sYWJlbF9jb3VudABsYWIxID49IDAgJiYgbGFiMSA8IHMtPmxhYmVsX2NvdW50AG9ial9jb3VudAB2YWwgPCBzLT5jYXB0dXJlX2NvdW50AHZhbDIgPCBzLT5jYXB0dXJlX2NvdW50AHNoYXBlX2NvdW50AGpzX2Z1bmNfcGMybGluZV9jb3VudABtZW1vcnlfdXNlZF9jb3VudABtYWxsb2NfY291bnQAanNfZnVuY19jb3VudABjX2Z1bmNfY291bnQAaW52YWxpZCByZXBlYXQgY291bnQAaW52YWxpZCByZXBldGl0aW9uIGNvdW50AGZvbnQAaW52YWxpZCBjb2RlIHBvaW50AGZyb21Db2RlUG9pbnQAaW52YWxpZCBoaW50AGNhbm5vdCBjb252ZXJ0IE5hTiBvciBJbmZpbml0eSB0byBiaWdpbnQAY2Fubm90IGNvbnZlcnQgdG8gYmlnaW50AGJvdGggb3BlcmFuZHMgbXVzdCBiZSBiaWdpbnQAbm90IGEgYmlnaW50AGVuY29kZVVSSUNvbXBvbmVudABkZWNvZGVVUklDb21wb25lbnQAdW5leHBlY3RlZCBlbmQgb2YgY29tbWVudABpbnZhbGlkIHN3aXRjaCBzdGF0ZW1lbnQAQmlnSW50AHBhcnNlSW50AGR1cGxpY2F0ZSBkZWZhdWx0AG1hbGxvY19saW1pdABzcGxpdABleHBlY3RpbmcgaGV4IGRpZ2l0AHRyaW1SaWdodAByZWR1Y2VSaWdodAB1bnNoaWZ0AHRyaW1MZWZ0AGludmFsaWQgb2Zmc2V0AGludmFsaWQgYnl0ZU9mZnNldABnZXRUaW1lem9uZU9mZnNldAByZXNvbHZpbmcgZnVuY3Rpb24gYWxyZWFkeSBzZXQAcHJveHk6IGluY29uc2lzdGVudCBzZXQAZmluZF9qdW1wX3RhcmdldABleHBlY3RpbmcgdGFyZ2V0AGludmFsaWQgZGVzdHJ1Y3R1cmluZyB0YXJnZXQAcHJveHk6IGluY29uc2lzdGVudCBnZXQAV2Vha1NldABjb25zdHJ1Y3QASlNfRnJlZUF0b21TdHJ1Y3QAdXNlIHN0cmljdABSZWZsZWN0AHJlamVjdABub3QgYW4gQXN5bmNHZW5lcmF0b3Igb2JqZWN0AGNhbm5vdCBjb252ZXJ0IHRvIG9iamVjdABpbnZhbGlkIGJyYW5kIG9uIG9iamVjdABvcGVyYW5kICdwcm90b3R5cGUnIHByb3BlcnR5IGlzIG5vdCBhbiBvYmplY3QAcmVjZWl2ZXIgaXMgbm90IGFuIG9iamVjdABpdGVyYXRvciBtdXN0IHJldHVybiBhbiBvYmplY3QAbm90IGEgRGF0ZSBvYmplY3QAbm90IGEgb2JqZWN0AEpTT2JqZWN0AGJpZ2Zsb2F0AHBhcnNlRmxvYXQAZmxhdABub3RoaW5nIHRvIHJlcGVhdABjb25jYXQAY29kZVBvaW50QXQAY2hhckF0AGNoYXJDb2RlQXQAa2V5cwBwcm94eTogdGFyZ2V0IHByb3BlcnR5IG11c3QgYmUgcHJlc2VudCBpbiBwcm94eSBvd25LZXlzACAgZmFzdCBhcnJheXMAZXhwb3J0ICclcycgaW4gbW9kdWxlICclcycgaXMgYW1iaWd1b3VzAHByaXZhdGUgY2xhc3MgZmllbGQgJyVzJyBhbHJlYWR5IGV4aXN0cwB0b28gbWFueSBhcmd1bWVudHMAVG9vIG1hbnkgY2FsbCBhcmd1bWVudHMAZmFzdF9hcnJheV9lbGVtZW50cwAgIGVsZW1lbnRzAGludmFsaWQgbnVtYmVyIG9mIGRpZ2l0cwBiaW5hcnkgb2JqZWN0cwBpbnZhbGlkIHByb3BlcnR5IGFjY2VzcwBqc19vcF9kZWZpbmVfY2xhc3MAZmQtPmJ5dGVfY29kZS5idWZbZGVmaW5lX2NsYXNzX3Bvc10gPT0gT1BfZGVmaW5lX2NsYXNzAF9fZ2V0Q2xhc3MAc2V0SG91cnMAZ2V0SG91cnMAc2V0VVRDSG91cnMAZ2V0VVRDSG91cnMAZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycwB0b28gbWFueSBpbWJyaWNhdGVkIHF1YW50aWZpZXJzAHVuaWNvZGVfcHJvcF9vcHMAYWNvcwBmb3IgYXdhaXQgaXMgb25seSB2YWxpZCBpbiBhc3luY2hyb25vdXMgZnVuY3Rpb25zAG5ldy50YXJnZXQgb25seSBhbGxvd2VkIHdpdGhpbiBmdW5jdGlvbnMAYnl0ZWNvZGUgZnVuY3Rpb25zAEMgZnVuY3Rpb25zAHByb3h5OiBpbmNvbnNpc3RlbnQgcHJldmVudEV4dGVuc2lvbnMAU2NyaXB0X0V4dGVuc2lvbnMAYXRvbXMAcHJveHk6IHByb3BlcnRpZXMgbXVzdCBiZSBzdHJpbmdzIG9yIHN5bWJvbHMAZ2V0T3duUHJvcGVydHlTeW1ib2xzAHJlc29sdmVfbGFiZWxzAEpTX0V2YWxUaGlzAHN0cmluZ3MAaW52YWxpZCBkZXNjcmlwdG9yIGZsYWdzAGludmFsaWQgcmVndWxhciBleHByZXNzaW9uIGZsYWdzAHZhbHVlcwBzZXRNaW51dGVzAGdldE1pbnV0ZXMAc2V0VVRDTWludXRlcwBnZXRVVENNaW51dGVzAHRvbyBtYW55IGNhcHR1cmVzACAgc2hhcGVzAGdldE93blByb3BlcnR5TmFtZXMAZ2NfZnJlZV9jeWNsZXMAYWRkX2V2YWxfdmFyaWFibGVzAHJlc29sdmVfdmFyaWFibGVzAHRvbyBtYW55IGxvY2FsIHZhcmlhYmxlcwB0b28gbWFueSBjbG9zdXJlIHZhcmlhYmxlcwBjb21wYWN0X3Byb3BlcnRpZXMAICBwcm9wZXJ0aWVzAGRlZmluZVByb3BlcnRpZXMAZW50cmllcwBmcm9tRW50cmllcwB0b28gbWFueSByYW5nZXMAaW5jbHVkZXMAc2V0TWlsbGlzZWNvbmRzAGdldE1pbGxpc2Vjb25kcwBzZXRVVENNaWxsaXNlY29uZHMAZ2V0VVRDTWlsbGlzZWNvbmRzAHNldFNlY29uZHMAZ2V0U2Vjb25kcwBzZXRVVENTZWNvbmRzAGdldFVUQ1NlY29uZHMAaXRhbGljcwBhYnMAcHJveHk6IGluY29uc2lzdGVudCBoYXMAJS4qcwAgKCVzAHNldCAlcwBnZXQgJXMAICAgIGF0ICVzAG5vIG92ZXJsb2FkZWQgb3BlcmF0b3IgJXMAbm90IGEgJXMAdW5zdXBwb3J0ZWQga2V5d29yZDogJXMAc3Vic3RyAHByb3h5OiBpbmNvbnNpc3RlbnQgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yAHN1cGVyKCkgaXMgb25seSB2YWxpZCBpbiBhIGRlcml2ZWQgY2xhc3MgY29uc3RydWN0b3IAcGFyZW50IGNsYXNzIG11c3QgYmUgY29uc3RydWN0b3IAbm90IGEgY29uc3RydWN0b3IAQXJyYXkgSXRlcmF0b3IAU2V0IEl0ZXJhdG9yAE1hcCBJdGVyYXRvcgBSZWdFeHAgU3RyaW5nIEl0ZXJhdG9yAG5vdCBhbiBBc3luYy1mcm9tLVN5bmMgSXRlcmF0b3IAY2Fubm90IGludm9rZSBhIHJ1bm5pbmcgZ2VuZXJhdG9yAG5vdCBhIGdlbmVyYXRvcgBBc3luY0dlbmVyYXRvcgBzeW50YXggZXJyb3IAU3ludGF4RXJyb3IARXZhbEVycm9yAEludGVybmFsRXJyb3IAQWdncmVnYXRlRXJyb3IAVHlwZUVycm9yAFJhbmdlRXJyb3IAUmVmZXJlbmNlRXJyb3IAVVJJRXJyb3IAZmxvb3IAZm9udGNvbG9yAGFuY2hvcgBmb3IAa2V5Rm9yAGV4cGVjdGluZyBzdXJyb2dhdGUgcGFpcgBhIGRlY2xhcmF0aW9uIGluIHRoZSBoZWFkIG9mIGEgZm9yLSVzIGxvb3AgY2FuJ3QgaGF2ZSBhbiBpbml0aWFsaXplcgAnYXJndW1lbnRzJyBpZGVudGlmaWVyIGlzIG5vdCBhbGxvd2VkIGluIGNsYXNzIGZpZWxkIGluaXRpYWxpemVyAGludmFsaWQgbnVtYmVyIG9mIGFyZ3VtZW50cyBmb3IgZ2V0dGVyIG9yIHNldHRlcgBpbnZhbGlkIHNldHRlcgBpbnZhbGlkIGdldHRlcgBmaWx0ZXIAbWlzc2luZyBmb3JtYWwgcGFyYW1ldGVyACJ1c2Ugc3RyaWN0IiBub3QgYWxsb3dlZCBpbiBmdW5jdGlvbiB3aXRoIGRlZmF1bHQgb3IgZGVzdHJ1Y3R1cmluZyBwYXJhbWV0ZXIAaW52YWxpZCBjaGFyYWN0ZXIAdW5leHBlY3RlZCBjaGFyYWN0ZXIAcHJpdmF0ZSBjbGFzcyBmaWVsZCBmb3JiaWRkZW4gYWZ0ZXIgc3VwZXIAaW52YWxpZCByZWRlZmluaXRpb24gb2YgbGV4aWNhbCBpZGVudGlmaWVyACdsZXQnIGlzIG5vdCBhIHZhbGlkIGxleGljYWwgaWRlbnRpZmllcgBpbnZhbGlkIHJlZGVmaW5pdGlvbiBvZiBnbG9iYWwgaWRlbnRpZmllcgB5aWVsZCBpcyBhIHJlc2VydmVkIGlkZW50aWZpZXIAJyVzJyBpcyBhIHJlc2VydmVkIGlkZW50aWZpZXIAb3RoZXIAYXRvbTFfaXNfaW50ZWdlciAmJiBhdG9tMl9pc19pbnRlZ2VyAGNhbm5vdCBjb252ZXJ0IHRvIGJpZ2ludDogbm90IGFuIGludGVnZXIAaXNJbnRlZ2VyAGlzU2FmZUludGVnZXIAYnVmZmVyAFNoYXJlZEFycmF5QnVmZmVyAGNhbm5vdCB1c2UgaWRlbnRpY2FsIEFycmF5QnVmZmVyAGNhbm5vdCBjb252ZXJ0IGJpZ2ludCB0byBudW1iZXIAY2Fubm90IGNvbnZlcnQgYmlnZmxvYXQgdG8gbnVtYmVyAGNhbm5vdCBjb252ZXJ0IHN5bWJvbCB0byBudW1iZXIAY2Fubm90IGNvbnZlcnQgYmlnZGVjaW1hbCB0byBudW1iZXIAbm90IGEgbnVtYmVyAGxpbmVOdW1iZXIAbWFsZm9ybWVkIHVuaWNvZGUgY2hhcgBjbGVhcgBzZXRZZWFyAGdldFllYXIAc2V0RnVsbFllYXIAZ2V0RnVsbFllYXIAc2V0VVRDRnVsbFllYXIAZ2V0VVRDRnVsbFllYXIAcSAhPSByAHVuZXhwZWN0ZWQgbGluZSB0ZXJtaW5hdG9yIGluIHJlZ2V4cAB1bmV4cGVjdGVkIGVuZCBvZiByZWdleHAAUmVnRXhwAHN1cABpbnZhbGlkIGdyb3VwAHBvcABjb250aW51ZSBtdXN0IGJlIGluc2lkZSBsb29wAGJmX2xvZ2ljX29wAG51bV9rZXlzX2NtcAB1c2Ugc3RyaXAAbWFwAGZsYXRNYXAAV2Vha01hcABleHBlY3RpbmcgJ3snIGFmdGVyIFxwAGxvZzFwAGRpdmlzaW9uIGJ5IHplcm8AdW5rbm93bgBpdGVyYXRvcl9jbG9zZV9yZXR1cm4AcHJvbWlzZSBzZWxmIHJlc29sdXRpb24Ab3V0IG9mIG1lbW9yeSBpbiByZWdleHAgZXhlY3V0aW9uAGRlc2NyaXB0aW9uAHByb3h5OiBkZWZpbmVQcm9wZXJ0eSBleGNlcHRpb24AanNfYXN5bmNfZ2VuZXJhdG9yX3Jlc29sdmVfZnVuY3Rpb24AanNfY3JlYXRlX2Z1bmN0aW9uAHNldC9hZGQgaXMgbm90IGEgZnVuY3Rpb24AcmV0dXJuIG5vdCBpbiBhIGZ1bmN0aW9uAEFzeW5jR2VuZXJhdG9yRnVuY3Rpb24AQXN5bmNGdW5jdGlvbgBpbnZhbGlkIG9wZXJhdGlvbgB1bnN1cHBvcnRlZCBvcGVyYXRpb24AYXdhaXQgaW4gZGVmYXVsdCBleHByZXNzaW9uAHlpZWxkIGluIGRlZmF1bHQgZXhwcmVzc2lvbgBpbnZhbGlkIGRlY2ltYWwgZXNjYXBlIGluIHJlZ3VsYXIgZXhwcmVzc2lvbgBiYWNrIHJlZmVyZW5jZSBvdXQgb2YgcmFuZ2UgaW4gcmVndWxhciBleHByZXNzaW9uAGludmFsaWQgZXNjYXBlIHNlcXVlbmNlIGluIHJlZ3VsYXIgZXhwcmVzc2lvbgBleHBlY3RlZCAnb2YnIG9yICdpbicgaW4gZm9yIGNvbnRyb2wgZXhwcmVzc2lvbgB0b28gY29tcGxpY2F0ZWQgZGVzdHJ1Y3R1cmluZyBleHByZXNzaW9uAGV4cGVjdGVkICd9JyBhZnRlciB0ZW1wbGF0ZSBleHByZXNzaW9uAHRvUHJlY2lzaW9uAGFzaW4Aam9pbgBtaW4AY29weVdpdGhpbgB0ZW1wbGF0ZSBsaXRlcmFsIGNhbm5vdCBhcHBlYXIgaW4gYW4gb3B0aW9uYWwgY2hhaW4AY2lyY3VsYXIgcHJvdG90eXBlIGNoYWluAGFzc2lnbgAheS0+c2lnbgBpc0Zyb3plbgBtYXJrX2NoaWxkcmVuAChwb3MgKyBsZW4pIDw9IGJjX2J1Zl9sZW4AdW5leHBlY3RlZCBlbGxpcHNpcyB0b2tlbgB0aGVuAHNldHRlciBpcyBmb3JiaWRkZW4AbnVsbCBvciB1bmRlZmluZWQgYXJlIGZvcmJpZGRlbgBhdGFuAG5hbgBub3QgYSBib29sZWFuAEJvb2xlYW4AZ2Nfc2NhbgBiYWQgbm9ybWFsaXphdGlvbiBmb3JtAEpTX05ld1N5bWJvbEZyb21BdG9tAGZyb20AcmFuZG9tAHRyaW0AdGRpdnJlbQBmZGl2cmVtAGVkaXZyZW0AY2RpdnJlbQBiZl9kaXZyZW0Ac3FydHJlbQBpbXVsAG5vdCBhIHN5bWJvbABTeW1ib2wAUmVnRXhwIGV4ZWMgbWV0aG9kIG11c3QgcmV0dXJuIGFuIG9iamVjdCBvciBudWxsAHBhcmVudCBwcm90b3R5cGUgbXVzdCBiZSBhbiBvYmplY3Qgb3IgbnVsbABjYW5ub3Qgc2V0IHByb3BlcnR5ICclcycgb2YgbnVsbABjYW5ub3QgcmVhZCBwcm9wZXJ0eSAnJXMnIG9mIG51bGwATnVsbABmaWxsAG5ldyBBcnJheUJ1ZmZlciBpcyB0b28gc21hbGwAVHlwZWRBcnJheSBsZW5ndGggaXMgdG9vIHNtYWxsAGNhbGwAZG90QWxsAG1hdGNoQWxsAHJlcGxhY2VBbGwAY2VpbAB1cGRhdGVfbGFiZWwAYmNfYnVmW3Bvc10gPT0gT1BfbGFiZWwAZXZhbABpbnZhbGlkIGJpZ2ludCBsaXRlcmFsAGludmFsaWQgbnVtYmVyIGxpdGVyYWwAbWFsZm9ybWVkIGVzY2FwZSBzZXF1ZW5jZSBpbiBzdHJpbmcgbGl0ZXJhbABiZl9leHBfaW50ZXJuYWwAYmZfbG9nX2ludGVybmFsAEpTX1NldFByb3BlcnR5SW50ZXJuYWwASlNfR2V0T3duUHJvcGVydHlOYW1lc0ludGVybmFsAF9fSlNfRXZhbEludGVybmFsAGJpZ2RlY2ltYWwAbnR0X2ZmdF9wYXJ0aWFsAHRvRXhwb25lbnRpYWwAc2VhbABnbG9iYWwAYmxpbmsAX19kYXRlX2Nsb2NrAHN0YWNrAGxyZV9leGVjX2JhY2t0cmFjawBzLT5pc193ZWFrAGJmX3Bvd191aQBzZXRNb250aABnZXRNb250aABzZXRVVENNb250aABnZXRVVENNb250aABpbnZhbGlkIGtleXdvcmQ6IHdpdGgAc3RhcnRzV2l0aABlbmRzV2l0aABwcm9wID09IEpTX0FUT01fbGVuZ3RoAGludmFsaWQgYXJyYXkgbGVuZ3RoAGludmFsaWQgYXJyYXkgYnVmZmVyIGxlbmd0aABpbnZhbGlkIGxlbmd0aABpbnZhbGlkIGJ5dGVMZW5ndGgAdXNlIG1hdGgATWF0aABwdXNoAGFjb3NoAEpTX1Jlc2l6ZUF0b21IYXNoAGFzaW5oAGF0YW5oAGJyZWFrIG11c3QgYmUgaW5zaWRlIGxvb3Agb3Igc3dpdGNoAG1hdGNoAGNhdGNoAHNlYXJjaABmb3JFYWNoAGJmX2xvZwBBcnJheSB0b28gbG9uZwBzdHJpbmcgdG9vIGxvbmcAQXJyYXkgbG9vIGxvbmcAc3Vic3RyaW5nAGNhbm5vdCBjb252ZXJ0IHN5bWJvbCB0byBzdHJpbmcAdW5leHBlY3RlZCBlbmQgb2Ygc3RyaW5nAG5vdCBhIHN0cmluZwBpbnZhbGlkIGNoYXJhY3RlciBpbiBhIEpTT04gc3RyaW5nAHRvU3RyaW5nAHRvRGF0ZVN0cmluZwB0b0xvY2FsZURhdGVTdHJpbmcAdG9UaW1lU3RyaW5nAHRvTG9jYWxlVGltZVN0cmluZwB0b0xvY2FsZVN0cmluZwB0b0dNVFN0cmluZwBKU1N0cmluZwB0b0lTT1N0cmluZwB0b1VUQ1N0cmluZwBkdXBsaWNhdGUgaW1wb3J0IGJpbmRpbmcAaW52YWxpZCBpbXBvcnQgYmluZGluZwBiaWcAcmVnZXhwIG11c3QgaGF2ZSB0aGUgJ2cnIGZsYWcAb2YAaW5mAGRpZmYgPT0gKGludDhfdClkaWZmAGRpZmYgPT0gKGludDE2X3QpZGlmZgBocmVmAGdjX2RlY3JlZgBmcmVlX3Zhcl9yZWYAb3B0aW1pemVfc2NvcGVfbWFrZV9nbG9iYWxfcmVmAHJlc2V0X3dlYWtfcmVmAGRlbGV0ZV93ZWFrX3JlZgBvcHRpbWl6ZV9zY29wZV9tYWtlX3JlZgBpbmRleE9mAGxhc3RJbmRleE9mAHZhbHVlT2YAc2V0UHJvdG90eXBlT2YAZ2V0UHJvdG90eXBlT2YAaXNQcm90b3R5cGVPZgAlLipmAGZvbnRzaXplAGJpbmFyeV9vYmplY3Rfc2l6ZQBzdHJfc2l6ZQBuZXdfc2l6ZSA8PSBzaC0+cHJvcF9zaXplAGRlc2NyIDwgcnQtPmF0b21fc2l6ZQBhdG9tIDwgcnQtPmF0b21fc2l6ZQBjb21wdXRlX3N0YWNrX3NpemUAb2JqX3NpemUAbiA8IGJ1Zl9zaXplAHNoYXBlX3NpemUAanNfZnVuY19wYzJsaW5lX3NpemUAanNfZnVuY19jb2RlX3NpemUAbWVtb3J5X3VzZWRfc2l6ZQBqc19mdW5jX3NpemUAbm9ybWFsaXplAGZyZWV6ZQByZXNvbHZlAHRvUHJpbWl0aXZlAHB1dF9sdmFsdWUAdW5rbm93biB1bmljb2RlIHByb3BlcnR5IHZhbHVlAHJlc3QgZWxlbWVudCBjYW5ub3QgaGF2ZSBhIGRlZmF1bHQgdmFsdWUAaW52YWxpZCByZXQgdmFsdWUAX19KU19BdG9tVG9WYWx1ZQBfX3F1b3RlAGlzRmluaXRlAGRlbGV0ZQBjcmVhdGUAc2V0RGF0ZQBnZXREYXRlAHNldFVUQ0RhdGUAZ2V0VVRDRGF0ZQBJbnZhbGlkIERhdGUAcmV2ZXJzZQBwYXJzZQBwcm94eSBwcmV2ZW50RXh0ZW5zaW9ucyBoYW5kbGVyIHJldHVybmVkIGZhbHNlAFByb21pc2UAdG9Mb3dlckNhc2UAdG9Mb2NhbGVMb3dlckNhc2UAdG9VcHBlckNhc2UAdG9Mb2NhbGVVcHBlckNhc2UAaWdub3JlQ2FzZQBsb2NhbGVDb21wYXJlAHByb3h5OiBpbmNvbnNpc3RlbnQgcHJvdG90eXBlAHByb3h5OiBiYWQgcHJvdG90eXBlAG5vdCBhIHByb3RvdHlwZQBpbnZhbGlkIG9iamVjdCB0eXBlAHVuZXNjYXBlAG5vbmUAcmVzdCBlbGVtZW50IG11c3QgYmUgdGhlIGxhc3Qgb25lAG11bHRpbGluZQAgIHBjMmxpbmUAc29tZQBKU19GcmVlUnVudGltZQBKU1J1bnRpbWUAc2V0VGltZQBnZXRUaW1lAHNldF9vYmplY3RfbmFtZQBleHBlY3RpbmcgcHJvcGVydHkgbmFtZQB1bmtub3duIHVuaWNvZGUgcHJvcGVydHkgbmFtZQBpbnZhbGlkIHByb3BlcnR5IG5hbWUAZHVwbGljYXRlIF9fcHJvdG9fXyBwcm9wZXJ0eSBuYW1lAGludmFsaWQgcmVkZWZpbml0aW9uIG9mIHBhcmFtZXRlciBuYW1lAGV4cGVjdGluZyBncm91cCBuYW1lAGR1cGxpY2F0ZSBncm91cCBuYW1lAGludmFsaWQgZ3JvdXAgbmFtZQBkdXBsaWNhdGUgbGFiZWwgbmFtZQBpbnZhbGlkIGZpcnN0IGNoYXJhY3RlciBvZiBwcml2YXRlIG5hbWUAaW52YWxpZCBsZXhpY2FsIHZhcmlhYmxlIG5hbWUAaW52YWxpZCBtZXRob2QgbmFtZQBleHBlY3RpbmcgZmllbGQgbmFtZQBpbnZhbGlkIGZpZWxkIG5hbWUAY2xhc3Mgc3RhdGVtZW50IHJlcXVpcmVzIGEgbmFtZQBmaWxlTmFtZQBjb21waWxlAG9iamVjdCBpcyBub3QgZXh0ZW5zaWJsZQBwcm94eTogaW5jb25zaXN0ZW50IGlzRXh0ZW5zaWJsZQBjYW5ub3QgaGF2ZSBzZXR0ZXIvZ2V0dGVyIGFuZCB2YWx1ZSBvciB3cml0YWJsZQBwcm9wZXJ0eSBpcyBub3QgY29uZmlndXJhYmxlAHZhbHVlIGlzIG5vdCBpdGVyYWJsZQBwcm9wZXJ0eUlzRW51bWVyYWJsZQBtaXNzaW5nIGluaXRpYWxpemVyIGZvciBjb25zdCB2YXJpYWJsZQBsZXhpY2FsIHZhcmlhYmxlAGludmFsaWQgcmVkZWZpbml0aW9uIG9mIGEgdmFyaWFibGUAcmV2b2NhYmxlAHN0cmlrZQBtcF9kaXZub3JtX2xhcmdlAGludmFsaWQgY2xhc3MgcmFuZ2UAbWVzc2FnZQBhc3luY19mdW5jX2ZyZWUAaW52YWxpZCBsdmFsdWUgaW4gc3RyaWN0IG1vZGUAaW52YWxpZCB2YXJpYWJsZSBuYW1lIGluIHN0cmljdCBtb2RlAGNhbm5vdCBkZWxldGUgYSBkaXJlY3QgcmVmZXJlbmNlIGluIHN0cmljdCBtb2RlAG9jdGFsIGVzY2FwZSBzZXF1ZW5jZXMgYXJlIG5vdCBhbGxvd2VkIGluIHN0cmljdCBtb2RlAG9jdGFsIGxpdGVyYWxzIGFyZSBkZXByZWNhdGVkIGluIHN0cmljdCBtb2RlAHVuaWNvZGUAICBieXRlY29kZQBKU0Z1bmN0aW9uQnl0ZWNvZGUAc2tpcF9kZWFkX2NvZGUAaW52YWxpZCBhcmd1bWVudCBuYW1lIGluIHN0cmljdCBjb2RlAGludmFsaWQgZnVuY3Rpb24gbmFtZSBpbiBzdHJpY3QgY29kZQBpbnZhbGlkIHJlZGVmaW5pdGlvbiBvZiBnbG9iYWwgaWRlbnRpZmllciBpbiBtb2R1bGUgY29kZQBpbXBvcnQubWV0YSBvbmx5IHZhbGlkIGluIG1vZHVsZSBjb2RlAGZyb21DaGFyQ29kZQBpbnZhbGlkIGZvciBpbi9vZiBsZWZ0IGhhbmQtc2lkZQBpbnZhbGlkIGFzc2lnbm1lbnQgbGVmdC1oYW5kIHNpZGUAcmVkdWNlAHNvdXJjZQAndGhpcycgY2FuIGJlIGluaXRpYWxpemVkIG9ubHkgb25jZQBwcm9wZXJ0eSBjb25zdHJ1Y3RvciBhcHBlYXJzIG1vcmUgdGhhbiBvbmNlAGludmFsaWQgVVRGLTggc2VxdWVuY2UAY2lyY3VsYXIgcmVmZXJlbmNlAHNsaWNlAHNwbGljZQByYWNlAHJlcGxhY2UAJSsuKmUAdW5leHBlY3RlZCAnYXdhaXQnIGtleXdvcmQAdW5leHBlY3RlZCAneWllbGQnIGtleXdvcmQAbWFwX2RlY3JlZl9yZWNvcmQAaXRlcmF0b3IgZG9lcyBub3QgaGF2ZSBhIHRocm93IG1ldGhvZABvYmplY3QgbmVlZHMgdG9JU09TdHJpbmcgbWV0aG9kACdzdXBlcicgaXMgb25seSB2YWxpZCBpbiBhIG1ldGhvZABmcm91bmQAX19iZl9yb3VuZABicmVhay9jb250aW51ZSBsYWJlbCBub3QgZm91bmQAb3V0IG9mIGJvdW5kAGZpbmQAYmluZABpbnZhbGlkIGluZGV4IGZvciBhcHBlbmQAZXh0cmFuZW91cyBjaGFyYWN0ZXJzIGF0IHRoZSBlbmQAdW5leHBlY3RlZCBkYXRhIGF0IHRoZSBlbmQAdW5leHBlY3RlZCBlbmQAaW52YWxpZCBpbmNyZW1lbnQvZGVjcmVtZW50IG9wZXJhbmQAaW52YWxpZCAnaW5zdGFuY2VvZicgcmlnaHQgb3BlcmFuZABpbnZhbGlkICdpbicgb3BlcmFuZAB0cmltRW5kAHBhZEVuZABib2xkACVsbGQAZ2NfZGVjcmVmX2NoaWxkAHJlc29sdmVfc2NvcGVfcHJpdmF0ZV9maWVsZABjYW5ub3QgZGVsZXRlIGEgcHJpdmF0ZSBjbGFzcyBmaWVsZABleHBlY3RpbmcgPGJyYW5kPiBwcml2YXRlIGZpZWxkACVzIGlzIG5vdCBpbml0aWFsaXplZABmaXhlZAB0b0ZpeGVkAHNldF9vYmplY3RfbmFtZV9jb21wdXRlZAByZWdleCBub3Qgc3VwcG9ydGVkAGV2YWwgaXMgbm90IHN1cHBvcnRlZABSZWdFeHAgYXJlIG5vdCBzdXBwb3J0ZWQAaW50ZXJydXB0ZWQAJXMgb2JqZWN0IGV4cGVjdGVkAGlkZW50aWZpZXIgZXhwZWN0ZWQAYnl0ZWNvZGUgZnVuY3Rpb24gZXhwZWN0ZWQAc3RyaW5nIGV4cGVjdGVkAGZyb20gY2xhdXNlIGV4cGVjdGVkAGZ1bmN0aW9uIG5hbWUgZXhwZWN0ZWQAdmFyaWFibGUgbmFtZSBleHBlY3RlZABtZXRhIGV4cGVjdGVkAHJlamVjdGVkAG1lbW9yeSBhbGxvY2F0ZWQAbWVtb3J5IHVzZWQAZGVyaXZlZCBjbGFzcyBjb25zdHJ1Y3RvciBtdXN0IHJldHVybiBhbiBvYmplY3Qgb3IgdW5kZWZpbmVkAGNhbm5vdCBzZXQgcHJvcGVydHkgJyVzJyBvZiB1bmRlZmluZWQAY2Fubm90IHJlYWQgcHJvcGVydHkgJyVzJyBvZiB1bmRlZmluZWQAZmxhZ3MgbXVzdCBiZSB1bmRlZmluZWQAVW5kZWZpbmVkAHByaXZhdGUgY2xhc3MgZmllbGQgaXMgYWxyZWFkeSBkZWZpbmVkACclcycgaXMgbm90IGRlZmluZWQAZ3JvdXAgbmFtZSBub3QgZGVmaW5lZABvcGVyYXRvciAlczogbm8gZnVuY3Rpb24gZGVmaW5lZABhbGxTZXR0bGVkAGZ1bGZpbGxlZABjYW5ub3QgYmUgY2FsbGVkAGlzU2VhbGVkACFzaC0+aXNfaGFzaGVkAHZhcl9yZWYtPmlzX2RldGFjaGVkAEFycmF5QnVmZmVyIGlzIGRldGFjaGVkAGFkZAAlKzA3ZAAlMDRkACUwMmQlMDJkACUwMmQvJTAyZC8lMCpkACUuM3MgJS4zcyAlMDJkICUwKmQAOiVkAGludmFsaWQgdGhyb3cgdmFyIHR5cGUgJWQAc2MAanNfZGVmX21hbGxvYwB0cnVuYwBnYwBleGVjAGJmX2ludGVnZXJfdG9fcmFkaXhfcmVjAHF1aWNranMvcXVpY2tqcy5jAHF1aWNranMvbGlicmVnZXhwLmMAcXVpY2tqcy9saWJiZi5jAHF1aWNranMvbGlidW5pY29kZS5jAHN1YgBwcm9taXNlX3JlYWN0aW9uX2pvYgBqc19wcm9taXNlX3Jlc29sdmVfdGhlbmFibGVfam9iAHIgIT0gYSAmJiByICE9IGIAcSAhPSBhICYmIHEgIT0gYgByd2EAciAhPSBhAF9fbG9va3VwU2V0dGVyX18AX19kZWZpbmVTZXR0ZXJfXwBfX2xvb2t1cEdldHRlcl9fAF9fZGVmaW5lR2V0dGVyX18AX19wcm90b19fAFtTeW1ib2wuc3BsaXRdAFtTeW1ib2wuc3BlY2llc10AW1N5bWJvbC5pdGVyYXRvcl0AW1N5bWJvbC5hc3luY0l0ZXJhdG9yXQBbU3ltYm9sLm1hdGNoQWxsXQBbU3ltYm9sLm1hdGNoXQBbU3ltYm9sLnNlYXJjaF0AW1N5bWJvbC50b1N0cmluZ1RhZ10AW1N5bWJvbC50b1ByaW1pdGl2ZV0AW3Vuc3VwcG9ydGVkIHR5cGVdAFtmdW5jdGlvbiBieXRlY29kZV0AW1N5bWJvbC5oYXNJbnN0YW5jZV0AW1N5bWJvbC5yZXBsYWNlXQBbACUwMmQ6JTAyZDolMDJkLiUwM2RaAFBPU0lUSVZFX0lORklOSVRZAE5FR0FUSVZFX0lORklOSVRZAHAtPmNsYXNzX2lkID09IEpTX0NMQVNTX0FSUkFZAHN0YWNrX2xlbiA8IFBPUF9TVEFDS19MRU5fTUFYAC0lMDJkLSUwMmRUAEpTX0F0b21HZXRTdHJSVABvcGNvZGUgPCBSRU9QX0NPVU5UAEJZVEVTX1BFUl9FTEVNRU5UACUwMmQ6JTAyZDolMDJkIEdNVABKU19WQUxVRV9HRVRfVEFHKHNmLT5jdXJfZnVuYykgPT0gSlNfVEFHX09CSkVDVAB2YXJfa2luZCA9PSBKU19WQVJfUFJJVkFURV9TRVRURVIATUFYX1NBRkVfSU5URUdFUgBNSU5fU0FGRV9JTlRFR0VSAGFzVWludE4AYXNJbnROAGlzTmFOAERhdGUgdmFsdWUgaXMgTmFOAHRvSlNPTgBFUFNJTE9OAE5BTgAlMDJkOiUwMmQ6JTAyZCAlY00Acy0+bGFiZWxfc2xvdHNbbGFiZWxdLmZpcnN0X3JlbG9jID09IE5VTEwAbGFiZWxfc2xvdHNbaV0uZmlyc3RfcmVsb2MgPT0gTlVMTABwcnMgIT0gTlVMTABzZi0+Y3VyX3NwICE9IE5VTEwAc2YgIT0gTlVMTABtcjEgIT0gTlVMTAB2YXJfa2luZCAhPSBKU19WQVJfTk9STUFMAGItPmZ1bmNfa2luZCA9PSBKU19GVU5DX05PUk1BTABlbmNvZGVVUkkAZGVjb2RlVVJJAFBJAHNwZWNpYWwgPT0gUFVUX0xWQUxVRV9OT0tFRVAgfHwgc3BlY2lhbCA9PSBQVVRfTFZBTFVFX05PS0VFUF9ERVBUSABzLT5zdGF0ZSA9PSBKU19BU1lOQ19HRU5FUkFUT1JfU1RBVEVfRVhFQ1VUSU5HAHByZWMxICE9IEJGX1BSRUNfSU5GADAxMjM0NTY3ODlBQkNERUYAU0laRQBNQVhfVkFMVUUATUlOX1ZBTFVFAE5BTUUAZXZhbF90eXBlID09IEpTX0VWQUxfVFlQRV9HTE9CQUwgfHwgZXZhbF90eXBlID09IEpTX0VWQUxfVFlQRV9NT0RVTEUAcC0+Z2Nfb2JqX3R5cGUgPT0gSlNfR0NfT0JKX1RZUEVfSlNfT0JKRUNUIHx8IHAtPmdjX29ial90eXBlID09IEpTX0dDX09CSl9UWVBFX0ZVTkNUSU9OX0JZVEVDT0RFAExPRzJFAExPRzEwRQBzLT5zdGF0ZSA9PSBKU19BU1lOQ19HRU5FUkFUT1JfU1RBVEVfQVdBSVRJTkdfUkVUVVJOIHx8IHMtPnN0YXRlID09IEpTX0FTWU5DX0dFTkVSQVRPUl9TVEFURV9DT01QTEVURUQAVVRDADxpbnB1dD4APHNldD4APGFub255bW91cz4APGR1bXA+ADxudWxsPgBiaWdpbnQgb3BlcmFuZHMgYXJlIGZvcmJpZGRlbiBmb3IgPj4+ACZxdW90OwBzZXRVaW50OABnZXRVaW50OABzZXRJbnQ4AGdldEludDgAbWFsZm9ybWVkIFVURi04AHJhZGl4IG11c3QgYmUgYmV0d2VlbiAyIGFuZCAzNgBzZXRVaW50MTYAZ2V0VWludDE2AHNldEludDE2AGdldEludDE2AGFyZ2MgPT0gNQBzZXRCaWdVaW50NjQAZ2V0QmlnVWludDY0AHNldEJpZ0ludDY0AGdldEJpZ0ludDY0AHNldEZsb2F0NjQAZ2V0RmxvYXQ2NABhcmdjID09IDMAYXRhbjIAbG9nMgBmbG9vckxvZzIAU1FSVDFfMgBTUVJUMgBMTjIAY2x6MzIAc2V0VWludDMyAGdldFVpbnQzMgBzZXRJbnQzMgBnZXRJbnQzMgBzZXRGbG9hdDMyAGdldEZsb2F0MzIAc3RhY2tfbGVuID49IDIASlNfQXRvbUlzTnVtZXJpY0luZGV4MQBqc19mY3Z0MQBKU19Db21wYWN0QmlnSW50MQBleHBtMQByICE9IGExICYmIHIgIT0gYjEAbHMtPmFkZHIgPT0gLTEAbnEgPj0gMQBzdGFja19sZW4gPj0gMQBwLT5oZWFkZXIucmVmX2NvdW50ID09IDEAcC0+c2hhcGUtPmhlYWRlci5yZWZfY291bnQgPT0gMQBzdGFja19sZW4gPT0gMQBqc19mcmVlX3NoYXBlMABsb2cxMABMTjEwAHAtPnJlZl9jb3VudCA+IDAAdmFyX3JlZi0+aGVhZGVyLnJlZl9jb3VudCA+IDAAc3RhY2tfc2l6ZSA+IDAAY3Bvb2xfaWR4ID49IDAAcnQtPmF0b21fY291bnQgPj0gMABscy0+cmVmX2NvdW50ID49IDAAcy0+aXNfZXZhbCB8fCBzLT5jbG9zdXJlX3Zhcl9jb3VudCA9PSAwAHAtPnJlZl9jb3VudCA9PSAwAGN0eC0+aGVhZGVyLnJlZl9jb3VudCA9PSAwAHNoLT5oZWFkZXIucmVmX2NvdW50ID09IDAAcC0+bWFyayA9PSAwAChuMiAlIHN0cmlwX2xlbikgPT0gMAAocHItPnUuaW5pdC5yZWFsbV9hbmRfaWQgJiAzKSA9PSAwAChuZXdfaGFzaF9zaXplICYgKG5ld19oYXNoX3NpemUgLSAxKSkgPT0gMABpICE9IDAAc2l6ZSAhPSAwAF4kXC4qKz8oKVtde318LwA8LwAwLgBtaXNzaW5nIGJpbmRpbmcgcGF0dGVybi4uLgBiaWdpbnQgYXJndW1lbnQgd2l0aCB1bmFyeSArAGFzeW5jIGZ1bmN0aW9uICoACn0pAGxpc3RfZW1wdHkoJnJ0LT5nY19vYmpfbGlzdCkAaiA9PSAoc2gtPnByb3BfY291bnQgLSBzaC0+ZGVsZXRlZF9wcm9wX2NvdW50KQBKU19Jc1VuZGVmaW5lZChmdW5jX3JldCkAIV9fSlNfQXRvbUlzVGFnZ2VkSW50KGRlc2NyKQAhYXRvbV9pc19mcmVlKHApAChudWxsKQAgKG5hdGl2ZSkAanNfY2xhc3NfaGFzX2J5dGVjb2RlKHAtPmNsYXNzX2lkKQB1bmNvbnNpc3RlbnQgc3RhY2sgc2l6ZTogJWQgJWQgKHBjPSVkKQBieXRlY29kZSBidWZmZXIgb3ZlcmZsb3cgKG9wPSVkLCBwYz0lZCkAc3RhY2sgb3ZlcmZsb3cgKG9wPSVkLCBwYz0lZCkAc3RhY2sgdW5kZXJmbG93IChvcD0lZCwgcGM9JWQpAGludmFsaWQgb3Bjb2RlIChvcD0lZCwgcGM9JWQpACg/OikAbm8gZnVuY3Rpb24gZmlsZW5hbWUgZm9yIGltcG9ydCgpAC1fLiF+KicoKQAgYW5vbnltb3VzKABTeW1ib2woAGV4cGVjdGluZyAnfScAY2xhc3MgY29uc3RydWN0b3JzIG11c3QgYmUgaW52b2tlZCB3aXRoICduZXcnAGV4cGVjdGluZyAnYXMnAHVuZXhwZWN0ZWQgdG9rZW4gaW4gZXhwcmVzc2lvbjogJyUuKnMnAHVuZXhwZWN0ZWQgdG9rZW46ICclLipzJwByZWRlY2xhcmF0aW9uIG9mICclcycAZHVwbGljYXRlIGV4cG9ydGVkIG5hbWUgJyVzJwBjaXJjdWxhciByZWZlcmVuY2Ugd2hlbiBsb29raW5nIGZvciBleHBvcnQgJyVzJyBpbiBtb2R1bGUgJyVzJwBDb3VsZCBub3QgZmluZCBleHBvcnQg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AJYAAADBAAAAlwAAAJgAAADCAAAAlwAAAJgAAADDAAAAawAAAGwAAADEAAAAmQAAAJoAAADFAAAAmQAAAJoAAAAvAAAAmwAAAJwAAADGAAAAawAAAGwAAADHAAAAnQAAAJ4AAAAAAAAA7h8AAB8gAAAqIAAA4h8AABUgAAA5IAAA+B8AAAYgAABjb3B5V2l0aGluAGVudHJpZXMAZmlsbABmaW5kAGZpbmRJbmRleABmbGF0AGZsYXRNYXAAaW5jbHVkZXMAa2V5cwB2YWx1ZXMAAAAAAAEBAgIDAwIDAEGQpwEL3xBudWxsAGZhbHNlAHRydWUAaWYAZWxzZQByZXR1cm4AdmFyAHRoaXMAZGVsZXRlAHZvaWQAdHlwZW9mAG5ldwBpbgBpbnN0YW5jZW9mAGRvAHdoaWxlAGZvcgBicmVhawBjb250aW51ZQBzd2l0Y2gAY2FzZQBkZWZhdWx0AHRocm93AHRyeQBjYXRjaABmaW5hbGx5AGZ1bmN0aW9uAGRlYnVnZ2VyAHdpdGgAY2xhc3MAY29uc3QAZW51bQBleHBvcnQAZXh0ZW5kcwBpbXBvcnQAc3VwZXIAaW1wbGVtZW50cwBpbnRlcmZhY2UAbGV0AHBhY2thZ2UAcHJpdmF0ZQBwcm90ZWN0ZWQAcHVibGljAHN0YXRpYwB5aWVsZABhd2FpdAAAbGVuZ3RoAGZpbGVOYW1lAGxpbmVOdW1iZXIAbWVzc2FnZQBlcnJvcnMAc3RhY2sAbmFtZQB0b1N0cmluZwB0b0xvY2FsZVN0cmluZwB2YWx1ZU9mAGV2YWwAcHJvdG90eXBlAGNvbnN0cnVjdG9yAGNvbmZpZ3VyYWJsZQB3cml0YWJsZQBlbnVtZXJhYmxlAHZhbHVlAGdldABzZXQAb2YAX19wcm90b19fAHVuZGVmaW5lZABudW1iZXIAYm9vbGVhbgBzdHJpbmcAb2JqZWN0AHN5bWJvbABpbnRlZ2VyAHVua25vd24AYXJndW1lbnRzAGNhbGxlZQBjYWxsZXIAPGV2YWw+ADxyZXQ+ADx2YXI+ADxhcmdfdmFyPgA8d2l0aD4AbGFzdEluZGV4AHRhcmdldABpbmRleABpbnB1dABkZWZpbmVQcm9wZXJ0aWVzAGFwcGx5AGpvaW4AY29uY2F0AHNwbGl0AGNvbnN0cnVjdABnZXRQcm90b3R5cGVPZgBzZXRQcm90b3R5cGVPZgBpc0V4dGVuc2libGUAcHJldmVudEV4dGVuc2lvbnMAaGFzAGRlbGV0ZVByb3BlcnR5AGRlZmluZVByb3BlcnR5AGdldE93blByb3BlcnR5RGVzY3JpcHRvcgBvd25LZXlzAGFkZABkb25lAG5leHQAdmFsdWVzAHNvdXJjZQBmbGFncwBnbG9iYWwAdW5pY29kZQByYXcAbmV3LnRhcmdldAB0aGlzLmFjdGl2ZV9mdW5jADxob21lX29iamVjdD4APGNvbXB1dGVkX2ZpZWxkPgA8c3RhdGljX2NvbXB1dGVkX2ZpZWxkPgA8Y2xhc3NfZmllbGRzX2luaXQ+ADxicmFuZD4AI2NvbnN0cnVjdG9yAGFzAGZyb20AbWV0YQAqZGVmYXVsdCoAKgBNb2R1bGUAdGhlbgByZXNvbHZlAHJlamVjdABwcm9taXNlAHByb3h5AHJldm9rZQBhc3luYwBleGVjAGdyb3VwcwBzdGF0dXMAcmVhc29uAGdsb2JhbFRoaXMAYmlnaW50AGJpZ2Zsb2F0AGJpZ2RlY2ltYWwAcm91bmRpbmdNb2RlAG1heGltdW1TaWduaWZpY2FudERpZ2l0cwBtYXhpbXVtRnJhY3Rpb25EaWdpdHMAdG9KU09OAE9iamVjdABBcnJheQBFcnJvcgBOdW1iZXIAU3RyaW5nAEJvb2xlYW4AU3ltYm9sAEFyZ3VtZW50cwBNYXRoAEpTT04ARGF0ZQBGdW5jdGlvbgBHZW5lcmF0b3JGdW5jdGlvbgBGb3JJbkl0ZXJhdG9yAFJlZ0V4cABBcnJheUJ1ZmZlcgBTaGFyZWRBcnJheUJ1ZmZlcgBVaW50OENsYW1wZWRBcnJheQBJbnQ4QXJyYXkAVWludDhBcnJheQBJbnQxNkFycmF5AFVpbnQxNkFycmF5AEludDMyQXJyYXkAVWludDMyQXJyYXkAQmlnSW50NjRBcnJheQBCaWdVaW50NjRBcnJheQBGbG9hdDMyQXJyYXkARmxvYXQ2NEFycmF5AERhdGFWaWV3AEJpZ0ludABCaWdGbG9hdABCaWdGbG9hdEVudgBCaWdEZWNpbWFsAE9wZXJhdG9yU2V0AE9wZXJhdG9ycwBNYXAAU2V0AFdlYWtNYXAAV2Vha1NldABNYXAgSXRlcmF0b3IAU2V0IEl0ZXJhdG9yAEFycmF5IEl0ZXJhdG9yAFN0cmluZyBJdGVyYXRvcgBSZWdFeHAgU3RyaW5nIEl0ZXJhdG9yAEdlbmVyYXRvcgBQcm94eQBQcm9taXNlAFByb21pc2VSZXNvbHZlRnVuY3Rpb24AUHJvbWlzZVJlamVjdEZ1bmN0aW9uAEFzeW5jRnVuY3Rpb24AQXN5bmNGdW5jdGlvblJlc29sdmUAQXN5bmNGdW5jdGlvblJlamVjdABBc3luY0dlbmVyYXRvckZ1bmN0aW9uAEFzeW5jR2VuZXJhdG9yAEV2YWxFcnJvcgBSYW5nZUVycm9yAFJlZmVyZW5jZUVycm9yAFN5bnRheEVycm9yAFR5cGVFcnJvcgBVUklFcnJvcgBJbnRlcm5hbEVycm9yADxicmFuZD4AU3ltYm9sLnRvUHJpbWl0aXZlAFN5bWJvbC5pdGVyYXRvcgBTeW1ib2wubWF0Y2gAU3ltYm9sLm1hdGNoQWxsAFN5bWJvbC5yZXBsYWNlAFN5bWJvbC5zZWFyY2gAU3ltYm9sLnNwbGl0AFN5bWJvbC50b1N0cmluZ1RhZwBTeW1ib2wuaXNDb25jYXRTcHJlYWRhYmxlAFN5bWJvbC5oYXNJbnN0YW5jZQBTeW1ib2wuc3BlY2llcwBTeW1ib2wudW5zY29wYWJsZXMAU3ltYm9sLmFzeW5jSXRlcmF0b3IAU3ltYm9sLm9wZXJhdG9yU2V0AEGAuAELtQgBAAAABQABFAUAARUFAAEVBQABFwUAARcBAAEAAQABAAEAAQABAAEAAQABAAEAAQACAAEFAwABCgEBAAABAgEAAQMCAAEBAgABAgMAAQIEAAEDBgABAgMAAQMEAAEEBQABAwMAAQQEAAEFBQABAgIAAQQEAAEDAwABAwMAAQQEAAEFBQADAgENAwEBDQMBAA0DAgENAwIADQMAAQ0DAwEKAQEAAAEAAAABAQIAAQAAAAECAgABAgAAAQEAAAEBAAAGAAAYBQEBDwMCAQoBAgEAAQEBAAEBAQAFAAEXBQABFwUAARcFAQAXBQEAFwUCABcBAgMAAQMAAAYAABgGAAAYBgEAGAUBARcFAQIXBQIAFwECAQABAwAAAQMBAAECAQABAgIAAQMAAAEDAQABBAAABQIBFwUBARcBAgIAAQIB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AAABADAAOgBB0IECCxEEADAAOgBBAFsAXwBgAGEAewBB8IECC8QLAQMFAQEBAQUFBQECAgMFBQEBAQICAwMFBQEFAREAAAAwmiAAAJowAHOBWgAwF2AAMAdsALOBbwAAF3AAAAd8AACBfwBAMIAAwwGYAJCBmABABpkAQJCcALSBpABALqUAMAG8AECGvABwgb8AAAHAADCBwABABMEAMAHDAECCwwAwgsQAQILFADABxwAwgccAMAHIAECCyAAwgckAMAHKAACBygAwAcsAMIHLAEACzAAAAc0AMAHOADCBzgAAAc8AMIHPAEAG0AAwAdMAQILTADCB1ABAAtYAMAHXAECC1wAwgtgAQITZADCB2wBAAtwAQALeAACB3wBQA+IAUIPjAFAD5QBAkOYAAIHuAEAS7wC0AfgAUIP4AEAC+gAwAfsAMIH7AEAo/AAwARABQBIRATEBHQFAgh0BMIEeATEBHwEBgh8BQIIgATCBIQEwASIBMIEiAUAKIwEBASgBAYEoAQEBKQEAgSkBAAEqAQACKwEAgSwBAIEtAQEBLgEAATABAYEwAQCBMQEBgTIBAQEzAQABNAEAgTQBAQE1AQGBNQEBATYBAIE3AQGBOAEAATkBAIE6AQGBPgEAAUABAQFBAQCBQQEBgUMBAAFEAQCBRAEAAkUBAAFGAQABSQEBgU4BAQFPAXOBogFABLgBQAK7AQCDvQEwgb8BMAHDATADxAEwAcYBMALHAdAByAEwkcgBMInRAQAB1gEAg9YB0wHYAQCR2AFzAeEBAInhAQAB5gEAguYBMIHnAXMB6AFzgegBc4HqAXMB6wEAgesBQBjsAXMB+AFzgfgBAAH5AQCB+QGgAfoBc4H6AUCC+wEwgfwBQAL9ATCD/gEwEAACMCAIAgAgGAIAECgCQCIwAkA2RQIwAWACQI5gAgCBZwJAYGgCMKaYAgCmsAK1gcMCMSZQCDGBYwgxgWYIACtoCACDfggRUNAJEAb4CSAG/Al0AUAOdIFADnQBQQ50gUEOdAFCDnSBQg50AUMOgIFDDoABRA4wK0gOMINeDgGBvA4Bgb4OAQHHDkB+AA9AGD8PtQFLD7aBSw+2AUwPtoFMD7cBTQ+AgU0PMAFPD0BgUA8ACIAPMAiEDwAGiA8wBowPAAiQDzAIlA8ACJgPMAicDwAGoA8wBqQPsAGoDwCBqA/TAakPAIGpD9MBqg8AgaoP0wGrDwCBqw8wgawPMIGtDzCBrg8wga8PAAiwDzAItA8AArgPAAS5DwACuw8BArwPAQK9DwECvg+3CMAPZwjED7gIyA9oCMwPuAjQD2gI1A8AAtgPuQHZD7GB2Q+5AdoPsQHbD9eB2w8wAtwPMALdD2EB3g9zAd8PuQHhD7KB4Q+6AeIPsgHjD9iB4w8wBOQPYgHmDwAC6A/QAekP0IHpD7AB6w/QgesPMALsDzAC7Q8BAvAP0wHxD9OB8Q+6AfIPAYHyD7AB8w/TgfMPMAL0DzAC9Q8xAfYPugH5D7KB+Q+7AfoPsgH7D9mB+w8wAvwPMAL9D2IB/g+gAZMQoAGVEKCBlRAxAZkQAQGnEDEQsBABELgQQILBEDEaWxIBGmgSMS8AFgEvGBZAAjAWMAExFjCBMRYwATIWAIEyFgABMxZAhjMWMIE2FjABNxYwgTcWMAE4FkACORZAgjoWMAI/FkBkQBZAhHUWQAJ5FgAmgBYAgZMWAIGWFkAuIFNAHEBTQA6RU0A+mVNAhLxTMIG+U0AKv1NAgsVTMIHGU0AEyFMBAcpTQBTLUzAB1VMwgdVTMAHWUzCB1lMwAddTMAHYUzCB2FMwAdlTMYHZU0AM2lNAAuFTMQHiUzCB4lMwAeNTQITjU0CC+lMBgalVIFC4VbIBgH2ygYB9sgGBfdqBgX3aAYJ9s4GCfbMBg327gYl9uwGKfbuBin28AYt9u4GLfTGakH8BmqB/MSgAggEoFIIxJFiCASRsgjEzQIYBM2CGMSBQjAEgYIwxICC3ASAwtzEigPQBIpH0AEHAjQIL4wMBAJwGB00DBBAAjwsAABEACABTSlEAUgBTADpUVQBXWT9dXABGYWNCZABmAGgAagBsAG4AAEAAAAAAGgCTAAAgNQAnACEAJCIqABNrbQAmJCcUFhgbHD4ePx85PSIhQR5AJSUmKCAqSSxDLkswTDJEQpkAAJWPfX6DhBKAgnZ3EnujfHh5ipKYpqCFAJqhk3UzlQCOAHSZmJeWAACeAJwAoaAVLi8wtLVOqqkSFB4hIiIqNDWmpzYfSgAAlwFa2h02BQDEw8bFyMfKyczLxNVF1kLXRtjO0NLU2tnu9v4OBw+AnwAhgKPtAMBAxmDn2+aZwAAABmDcKf0VEgYW+N0GFRKECMYW/98DwEAARmDe4G03ODkVFBcWABoZHBsAX7dlREcAT2JOUAAASAAAAKOkpQAAAAAAtgAAWgBIAFtWWGBecGlvTQAAO2e4AABFqIqLjKusWFivlLBvslxbXl1gX2JhZGNmZWhnAAAAAAAAAJkDCAMBA6UDEwMAA0IDkQOXA6kDRgBJAEwAUwBpAAcDvAJOAEoADAM1BVIFSAAxA1QAVwAKA1kAQQC+AggfgB8oH5AfaB+gH7ofhgOzH8ofiQPDH6ED+h+PA/MfRAVGBTsFTgU9BbgDYgRKpmAeyQNrAOUAQbCRAgvCAUCpgI6A/IDTgIyAjYGNAoDhgJGFmgEAAREAAQQIAQgwCAEVIAA5mTGdhECUgNaCpoBBYoCmgFd2+AKAj4CwQNsIgEHQgIyAj4zkAwGJABQoEBECARgLJEsmAQGG5YBgebaBQJGBvYiUBYCYgMeCQzSiBoCMYSiW1IDGAQgJC4CLAAaAwAMPBoCbAwQAFoBBU4GYgJiAnoCYgJ6AmICegJiAnoCYB1ljmYWZhZkAAAAAuQLgoB5AnqZAutQBidcBivEBAEGAkwILtAWmBYCKgKIAgMYDAAMBgUH2QL8ZGIgIgED6hkDOBICwrAABAQCrgIqFiYoAooCJlI+A5DiJA6AAgJ2a2oq5ihgIl5eqgvavtgADOwKGiYGMgI6AuQMfgJOBmQGBuAMLCRKAnQqAioG4AyALgJOBlSiAuQEAHwaBioGdgLyAi4CxAoC4FBAegYqBnIC5AQUEgZOBm4G4Cx+Ak4GcgMcGEIDZAYaKiOEBiIgAhcmBmgAAgLaNBAGEioCjiIDlGCgJgZgLgo+DjAENgI6A3YBCX4JDsYKcgpyBnYG/CDcBihAgrIOzgMCBoYD1E4GIBYJA2gmAuQAwAAE9iQimB5C+g68AIASAp4iLgZ8ZCIK3AAoAgrk5gb+F0RCMBhgoEbG+jICh3gRBvACCioKMgoyCjIGLJ4GJAQGEsCCJAIyAj4yyoEuKgfCC/ICOgN+froBB1ICjGiSA3IXcgmBvFYBE4YVBDYDhGIkAm4PPgY2hzYCWguwPAgOAmAyAQJaBmZGMgKWHmIqtgq8BGYGQgJSBwSkJgYsHgKKAioCyABEMCICagI0MCIDjhIiC+AEDgGBPL4BAko9CPY8Qi4+hAYBAqAYFgIqAogCAroCsgcKAlIJCAIBA4YBAlIRGhRAMg6cTgECkgUI8g0GCgUCYikCvgLWOt4KwGQmAjoCxgqMgh72Ai4GziIkZgN4RAA2AQJ8Ch5SBuAqApDKEQMI5EICWgNMoAwiBQO0dCIGagdQ5AIHpAAEogOQRGIRBAogBQP8IA4BAjxkLgJ+JpykfgIgpgq2MAUGVMCiA0ZUOAQH5KgAIMIDHCgCAQVqBVTqIYDa2hLqGiINECoC+kL8IgWBMtwiDVMKCiI8OnYNAk4JHuraDsTiNgJUgjkVPMJAOAQRBBI1BrYNF34bsh0quhGwMAICd3/9A7wBBwJgCC0K+BQD+BwBSCiAFDCA7DkBhEEAPGCBDG2B5HQDxIAANpkAuqSDeqgAP/yDnCkGCESHEFGFEGQFIHSGkvAE+4QHwAQ4AQZCZAguVCMCZhZmugIkDBJaAnoBByYOLjSYAgECAIAkYBQAQAJOA0oBAiodApYClCIWoxpobrKqiCOIAjg6BiRGAjwCdnNiKgJegiAsElRiIAoCWmIaKtJSAkbu1EJEGiY6PHwmBlQYAExCPgIwIgo2BiQcrCZUGAQEBnhiAkoKPiAKAlQYBBBCRgI6BloCKOQmVBgEEEJ0Igo6AkAAqEBoIAAoKEouVgLM4EJaAjxCZFIGdAzgQloCJBBCfAIGOgZCIAoCoCI8EF4KXLJGCl4CIAA65rwGLhrkIACCXAICJAYgBIICUg5+AvjijmoTyqpOAjysaAg4TjIuAkKUAIIGqgEFMAw4AA4GoA4GgAw4AA4GOgLgDgcKkj4/VDYJCa4GQgJmEyoKKhowDjZGNkY2MAo6zogOAwtiGqACExYmesJ0MiquDmbWWiLTRgNyukIa2nYyBiauZo6iCiaOBiIaqCqgYKAoEQL+/QRUNgaUNDwAAAICegbQGABIGEw2DjCIG84CMgI+M5AMBiQANKAAAgI8LJBiQqEp2roCugECEKxGLpQAggbcwj5aIMDAwMDAwMIZCJYKYiDQMg9UcgNkDhKqA3ZCfr49B/1m/v2BR/IJEjMKtgUEMgo+JgZOuj56Bz6aIgeaBtIGIqYwCA4CWnLONsb0qAIGKm4mWmJyGrpuAjyCJiSColhCHk5YQgrEAEQwIAJcRijKLKSmFiDAwqoCNhfKcYCuji5aDsGAhA0FtgemlhoskAImAjAQAAQGA66BBapG/gbWni/MgQIajmYWZitgVDQ0KoouAmYCSAYCOgY2h+sS0QQqcgrCun4ydhKWJnYGjHwSpQJ2Ro4Ojg6eHs0CbQTaIlYmHQJcpAKsBEIGWiZaInsCSAYmViZnFtym/gI4YEJypnIKcojibmrWJlYmSjJHtyLayjLKMo0FbqSnNnIkHlemUmpaLtMqsn5iZo5wBB6IQi6+Ng5QAgKKRgJjTMAAYjoCJhq6lOQmVBgEEEJGAi4RAnbSRg5OCna+TCIBAt66og6Ovk4C6qoyAxppA5Kvzv545ATgIl44AgN05po8AgJuAiacwlICKrZKAobhBBoiApJCAsJ3vMAillICYKAifjYBBRpJAvIDOQ5nl7pBAw0q7RC5P0EJGYCG4QjiGnvCdka+Pg56UhJJCr7//yiDBjL8IgJtX94dE1amIYCL2QR6wgpAfQYtJA+qEjIKIholXZdSAxgEICQuAiwAGgMADDwaAmwMEABaAQVOBmICYgJ6AmICegJiAnoCYgJ6AmAdJM6yJho+AQXCrRRNAxLrDMESzGJoBAAiAiQMAACgYAAACAQAIAAAAAAEACwYDAwCAiYCQIgSAkFFDYKbdoVA0ikDdgVaBjV0wTB5CHUXhU0oAQbChAgtj9gMgpgcAqQkAtAoAugsAPg0A4A4gVxIA6xYAyhkgwB1ggCAALi0AwDEgiacg8KkA46sAPv0A+wAhNwdhAQoBHQ8hLBIByBQh0RkhRx0BOWohCY0BvNQBqdchOu4B3qYiSxMDAEGgogIL8gSviaSA1oBCR++WgED6hEEIrAABAQDHiq+eKOQxKQgZiZaAnZraio6JoIiIgJcYiAIEqoL2joCgtRCRBokJiZCCtwAxCYKIgIkJiY0BgrcAIwkSgJOLEIqCtwA4EIKTCYmJKIK3ADEJFoKJCYmRgLoiEIOIgI2Jj4S4MBAegYoJiZCCtwAwEB6BigmJj4O2CDAQg4iAiQmJkILFAygAPYkJvAGGiziJ1gGIiimJvQ2JigAAA4GwkwGEioCjiIDjk4CJixsQETKDjIuAjkK+goiIQ5+CnIKcgZ2Bv5+IAYmgEYlAjoD1i4OLiYn/iruEuImAnIGKhYmVjQG+hK6QiomQiIuCnYyBiauNr5OHiYWJ9RCUGCgKQMW5BEI+gZKA+owYgotL/YJAjIDfn0IpheiBYHWEicQDiZ+Bz4FBDwIDgJYjgNKBsZGJiYWRjIqbh5iMq4OujY6JioCJia6NiwcJiaCCsQARDAiAqCSBQOs4CYlgTyOAQuCPj48Rl4JAv4mkgEK8gEDhgECUhEEkiUVWEAyDpxOAQKSBQjwfiUFwgUCYikCugrSOnomOg6yKtIkqo42AiSGrgIuCr407gIvRiyhAn4uEiSu2CDEJgoiAiQkyhEC/kYiJGNCTi4lA1DGImoHRkI6J0IyHidKOg4lA8Y5ApInFKAkYAIGLifYxMoCbiacwH4CIiq2PQZQ4h4+Jt5WAjfkqAAgwB4mvIAgniUFIg2BLaIlAhYS6hpiJQ/QAtjPQgIqBYEyqgVTFIi85hp2DQJOCRYixQf+2g7E4jYCVII5FTzCQDgEEQQSGiIlBoY1F1YbsNIlSlYlsBQVA7wBBoKcCC6MS+gYAhAkA8AoAcAwA9A0AShAgGhggdBsg3SAADKgAWqogGv8ArQ4BOBIhwRUh5Rkhqh0hjNFBSuEh8AEOAAAAAEFkbGFtLEFkbG0AQWhvbSxBaG9tAEFuYXRvbGlhbl9IaWVyb2dseXBocyxIbHV3AEFyYWJpYyxBcmFiAEFybWVuaWFuLEFybW4AQXZlc3RhbixBdnN0AEJhbGluZXNlLEJhbGkAQmFtdW0sQmFtdQBCYXNzYV9WYWgsQmFzcwBCYXRhayxCYXRrAEJlbmdhbGksQmVuZwBCaGFpa3N1a2ksQmhrcwBCb3BvbW9mbyxCb3BvAEJyYWhtaSxCcmFoAEJyYWlsbGUsQnJhaQBCdWdpbmVzZSxCdWdpAEJ1aGlkLEJ1aGQAQ2FuYWRpYW5fQWJvcmlnaW5hbCxDYW5zAENhcmlhbixDYXJpAENhdWNhc2lhbl9BbGJhbmlhbixBZ2hiAENoYWttYSxDYWttAENoYW0sQ2hhbQBDaGVyb2tlZSxDaGVyAENob3Jhc21pYW4sQ2hycwBDb21tb24sWnl5eQBDb3B0aWMsQ29wdCxRYWFjAEN1bmVpZm9ybSxYc3V4AEN5cHJpb3QsQ3BydABDeXJpbGxpYyxDeXJsAERlc2VyZXQsRHNydABEZXZhbmFnYXJpLERldmEARGl2ZXNfQWt1cnUsRGlhawBEb2dyYSxEb2dyAER1cGxveWFuLER1cGwARWd5cHRpYW5fSGllcm9nbHlwaHMsRWd5cABFbGJhc2FuLEVsYmEARWx5bWFpYyxFbHltAEV0aGlvcGljLEV0aGkAR2VvcmdpYW4sR2VvcgBHbGFnb2xpdGljLEdsYWcAR290aGljLEdvdGgAR3JhbnRoYSxHcmFuAEdyZWVrLEdyZWsAR3VqYXJhdGksR3VqcgBHdW5qYWxhX0dvbmRpLEdvbmcAR3VybXVraGksR3VydQBIYW4sSGFuaQBIYW5ndWwsSGFuZwBIYW5pZmlfUm9oaW5neWEsUm9oZwBIYW51bm9vLEhhbm8ASGF0cmFuLEhhdHIASGVicmV3LEhlYnIASGlyYWdhbmEsSGlyYQBJbXBlcmlhbF9BcmFtYWljLEFybWkASW5oZXJpdGVkLFppbmgsUWFhaQBJbnNjcmlwdGlvbmFsX1BhaGxhdmksUGhsaQBJbnNjcmlwdGlvbmFsX1BhcnRoaWFuLFBydGkASmF2YW5lc2UsSmF2YQBLYWl0aGksS3RoaQBLYW5uYWRhLEtuZGEAS2F0YWthbmEsS2FuYQBLYXlhaF9MaSxLYWxpAEtoYXJvc2h0aGksS2hhcgBLaG1lcixLaG1yAEtob2praSxLaG9qAEtoaXRhbl9TbWFsbF9TY3JpcHQsS2l0cwBLaHVkYXdhZGksU2luZABMYW8sTGFvbwBMYXRpbixMYXRuAExlcGNoYSxMZXBjAExpbWJ1LExpbWIATGluZWFyX0EsTGluYQBMaW5lYXJfQixMaW5iAExpc3UsTGlzdQBMeWNpYW4sTHljaQBMeWRpYW4sTHlkaQBNYWthc2FyLE1ha2EATWFoYWphbmksTWFoagBNYWxheWFsYW0sTWx5bQBNYW5kYWljLE1hbmQATWFuaWNoYWVhbixNYW5pAE1hcmNoZW4sTWFyYwBNYXNhcmFtX0dvbmRpLEdvbm0ATWVkZWZhaWRyaW4sTWVkZgBNZWV0ZWlfTWF5ZWssTXRlaQBNZW5kZV9LaWtha3VpLE1lbmQATWVyb2l0aWNfQ3Vyc2l2ZSxNZXJjAE1lcm9pdGljX0hpZXJvZ2x5cGhzLE1lcm8ATWlhbyxQbHJkAE1vZGksTW9kaQBNb25nb2xpYW4sTW9uZwBNcm8sTXJvbwBNdWx0YW5pLE11bHQATXlhbm1hcixNeW1yAE5hYmF0YWVhbixOYmF0AE5hbmRpbmFnYXJpLE5hbmQATmV3X1RhaV9MdWUsVGFsdQBOZXdhLE5ld2EATmtvLE5rb28ATnVzaHUsTnNodQBOeWlha2VuZ19QdWFjaHVlX0htb25nLEhtbnAAT2doYW0sT2dhbQBPbF9DaGlraSxPbGNrAE9sZF9IdW5nYXJpYW4sSHVuZwBPbGRfSXRhbGljLEl0YWwAT2xkX05vcnRoX0FyYWJpYW4sTmFyYgBPbGRfUGVybWljLFBlcm0AT2xkX1BlcnNpYW4sWHBlbwBPbGRfU29nZGlhbixTb2dvAE9sZF9Tb3V0aF9BcmFiaWFuLFNhcmIAT2xkX1R1cmtpYyxPcmtoAE9yaXlhLE9yeWEAT3NhZ2UsT3NnZQBPc21hbnlhLE9zbWEAUGFoYXdoX0htb25nLEhtbmcAUGFsbXlyZW5lLFBhbG0AUGF1X0Npbl9IYXUsUGF1YwBQaGFnc19QYSxQaGFnAFBob2VuaWNpYW4sUGhueABQc2FsdGVyX1BhaGxhdmksUGhscABSZWphbmcsUmpuZwBSdW5pYyxSdW5yAFNhbWFyaXRhbixTYW1yAFNhdXJhc2h0cmEsU2F1cgBTaGFyYWRhLFNocmQAU2hhdmlhbixTaGF3AFNpZGRoYW0sU2lkZABTaWduV3JpdGluZyxTZ253AFNpbmhhbGEsU2luaABTb2dkaWFuLFNvZ2QAU29yYV9Tb21wZW5nLFNvcmEAU295b21ibyxTb3lvAFN1bmRhbmVzZSxTdW5kAFN5bG90aV9OYWdyaSxTeWxvAFN5cmlhYyxTeXJjAFRhZ2Fsb2csVGdsZwBUYWdiYW53YSxUYWdiAFRhaV9MZSxUYWxlAFRhaV9UaGFtLExhbmEAVGFpX1ZpZXQsVGF2dABUYWtyaSxUYWtyAFRhbWlsLFRhbWwAVGFuZ3V0LFRhbmcAVGVsdWd1LFRlbHUAVGhhYW5hLFRoYWEAVGhhaSxUaGFpAFRpYmV0YW4sVGlidABUaWZpbmFnaCxUZm5nAFRpcmh1dGEsVGlyaABVZ2FyaXRpYyxVZ2FyAFZhaSxWYWlpAFdhbmNobyxXY2hvAFdhcmFuZ19DaXRpLFdhcmEAWWV6aWRpLFllemkAWWksWWlpaQBaYW5hYmF6YXJfU3F1YXJlLFphbmIAQdC5AguxFMAZmUWFGZlFrhmARY4ZgEWEGZZFgBmeRYAZ4WBFphmERYQZgQ2TGeAPN4MrgBmCKwGDK4AZgCsDgCuAGYArgBmCKwCAKwCT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ayxNb2RpZmllcl9TeW1ib2wAU28sT3RoZXJfU3ltYm9sAFBjLENvbm5lY3Rvcl9QdW5jdHVhdGlvbgBQZCxEYXNoX1B1bmN0dWF0aW9uAFBzLE9wZW5fUHVuY3R1YXRpb24AUGUsQ2xvc2VfUHVuY3R1YXRpb24AUGksSW5pdGlhbF9QdW5jdHVhdGlvbgBQZixGaW5hbF9QdW5jdHVhdGlvbgBQbyxPdGhlcl9QdW5jdHVhdGlvbgBacyxTcGFjZV9TZXBhcmF0b3IAWmwsTGluZV9TZXBhcmF0b3IAWnAsUGFyYWdyYXBoX1NlcGFyYXRvcgBDYyxDb250cm9sLGNudHJsAENmLEZvcm1hdABDcyxTdXJyb2dhdGUAQ28sUHJpdmF0ZV9Vc2UATEMsQ2FzZWRfTGV0dGVyAEwsTGV0dGVyAE0sTWFyayxDb21iaW5pbmdfTWFyawBOLE51bWJlcgBTLFN5bWJvbABQLFB1bmN0dWF0aW9uLHB1bmN0AFosU2VwYXJhdG9yAEMsT3RoZXIAQdDZAguwCA4AAAA+AAAAwAEAAAAOAAAA8AAAAAB/AAAAgAMBAAA8QVNDSUlfSGV4X0RpZ2l0LEFIZXgAQmlkaV9Db250cm9sLEJpZGlfQwBEYXNoAERlcHJlY2F0ZWQsRGVwAERpYWNyaXRpYyxEaWEARXh0ZW5kZXIsRXh0AEhleF9EaWdpdCxIZXgASURTX0JpbmFyeV9PcGVyYXRvcixJRFNCAElEU19UcmluYXJ5X09wZXJhdG9yLElEU1QASWRlb2dyYXBoaWMsSWRlbwBKb2luX0NvbnRyb2wsSm9pbl9DAExvZ2ljYWxfT3JkZXJfRXhjZXB0aW9uLExPRQBOb25jaGFyYWN0ZXJfQ29kZV9Qb2ludCxOQ2hhcgBQYXR0ZXJuX1N5bnRheCxQYXRfU3luAFBhdHRlcm5fV2hpdGVfU3BhY2UsUGF0X1dTAFF1b3RhdGlvbl9NYXJrLFFNYXJrAFJhZGljYWwAUmVnaW9uYWxfSW5kaWNhdG9yLFJJAFNlbnRlbmNlX1Rlcm1pbmFsLFNUZXJtAFNvZnRfRG90dGVkLFNEAFRlcm1pbmFsX1B1bmN0dWF0aW9uLFRlcm0AVW5pZmllZF9JZGVvZ3JhcGgsVUlkZW8AVmFyaWF0aW9uX1NlbGVjdG9yLFZTAFdoaXRlX1NwYWNlLHNwYWNlAEJpZGlfTWlycm9yZWQsQmlkaV9NAEVtb2ppAEVtb2ppX0NvbXBvbmVudCxFQ29tcABFbW9qaV9Nb2RpZmllcixFTW9kAEVtb2ppX01vZGlmaWVyX0Jhc2UsRUJhc2UARW1vamlfUHJlc2VudGF0aW9uLEVQcmVzAEV4dGVuZGVkX1BpY3RvZ3JhcGhpYyxFeHRQaWN0AERlZmF1bHRfSWdub3JhYmxlX0NvZGVfUG9pbnQsREkASURfU3RhcnQsSURTAENhc2VfSWdub3JhYmxlLENJAEFTQ0lJAEFscGhhYmV0aWMsQWxwaGEAQW55AEFzc2lnbmVkAENhc2VkAENoYW5nZXNfV2hlbl9DYXNlZm9sZGVkLENXQ0YAQ2hhbmdlc19XaGVuX0Nhc2VtYXBwZWQsQ1dDTQBDaGFuZ2VzX1doZW5fTG93ZXJjYXNlZCxDV0wAQ2hhbmdlc19XaGVuX05GS0NfQ2FzZWZvbGRlZCxDV0tDRgBDaGFuZ2VzX1doZW5fVGl0bGVjYXNlZCxDV1QAQ2hhbmdlc19XaGVuX1VwcGVyY2FzZWQsQ1dVAEdyYXBoZW1lX0Jhc2UsR3JfQmFzZQBHcmFwaGVtZV9FeHRlbmQsR3JfRXh0AElEX0NvbnRpbnVlLElEQwBMb3dlcmNhc2UsTG93ZXIATWF0aABVcHBlcmNhc2UsVXBwZXIAWElEX0NvbnRpbnVlLFhJREMAWElEX1N0YXJ0LFhJRFMAQZDiAgu0IIEAKACXACoAgYAqAJfAKwAVgSwAlwAtAIFALQCXAC4AFUEuAJkBLwAWIDAAQghAAEKKRABCBEoAlgBMABeBTABCAk0AQkNOAC/BTwBCw1AAv0BSAEIDUwBCCVUAQghaAJYAXgBCQ14AgcBfAEIBaABCwWsAhQFxABfDcQBESHMARIN3AEKDeQC+AnsAl0F8AEIBfQBEBH4AQg6AAEKBhwBEh4kAgwSsABcDtgCDArgAFALQAJYA0QCAAN0Al4DeAICA3wCXAOEAPkHhAIDA4QC+BOIAroPqAK6C8gCtAfQALsH0AANB9QADA/wAgUD+AD4CAAG+wAEBvgEDAb5ABgG+QA4BPgIUAb7AFQG+ARcBRIEdAURBMAFEAjQBRIE1AUSDNgFEgzgBRIY6AUQBPgGFwGEB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SHpUSHq8AxMhbQATIWQAEyFrABMhZgBtbgBtvANtbQBtYwBtawBtYwAKCk8ACk9tALIAYwAICk8KClAAClBtALMAawBtALMAbQAVInMAbQAVInMAsgBQYWtQYU1QYUdQYXJhZHJhZNFzcgBhAGQAFSJzALIAcABzbgBzvANzbQBzcABWbgBWvANWbQBWawBWTQBWcABXbgBXvANXbQBXawBXTQBXawCpA00AqQNhLm0uQnFjY2NkQ9FrZ0NvLmRCR3loYUhQaW5LS0tNa3RsbWxubG9nbHhtYm1pbG1vbFBIcC5tLlBQTVBSc3JTdldiVtFtQdFtMQDlZTEAMADlZTIAMADlZTMAMADlZWdhbEoETAQmAVMBJ6c3q2sCUqtIjPRmyo7IjNFuMk7lU5yfnJ9RWdGRh1VIWfZhaXaFfz+Guof4iI+QAmobbdlw3nM9hGqR8ZmCTnVTBGsbci2GHp5QXetvzYVkicli2IEfiMpeF2dqbfxyzpCGT7dR3lLEZNNqEHLndgGABoZchu+NMpdvm/qdjHh/eaB9yYMEk3+e1orfWARfYHx+gGJyynjCjPeW2FhiXBNq2m0Pby99N35LltJSi4DcUcxRHHq+ffGDdZaAi89iAmr+ijlO51sSYIdzcHUXU/t4v0+pXw1OzGx4ZSJ9w1NeWAF3SYSqirprsI+IbP5i5YKgY2V1rk5pUclRgWjnfG+C0orPkfVSQlRzWexexWX+byp5rZVqmpeezp6bUsZmd2tij3RekGEAYppkI29JcYl0ynn0fW+AJo/uhCOQSpMXUqNSvVTIcMKIqorJXvVfe2Ouaz58dXPkTvlW51u6XRxgsnNpdJp/RoA0kvaWSJcYmItPrnm0kbiW4WCGTtpQ7ls/XJllAmrOcUJ2/IR8kI2fiGYulolSe2fzZ0FtnG4JdFl1a3gQfV6YbVEuYniWK1AZXeptKo+LX0RhF2iHc4aWKVIPVGVcE2ZOZ6ho5WwGdOJ1eX/PiOGIzJHilj9Tum4dVNBxmHT6haOWV5yfnpdny23ogct6IHuSfMBymXBYi8BONoM6UgdSpl7TYtZ8hVsebbRmO49MiE2Wi4nTXkBRwFUAAAAAWlgAAHRmAAAAAN5RKnPKdjx5XnlleY95Vpe+fL1/AAAShgAA+IoAAAAAOJD9kO+Y/JgombSd3pC3lq5P51BNUclS5FJRU51VBlZoVkBYqFhkXG5clGBoYY5h8mFPZeJlkWaFaHdtGm4ib25xK3IidJF4PnlJeUh5UHlWeV15jXmOeUB6gXrAe/R9CX5BfnJ/BYDtgXmCeYJXhBCJlokBizmL04wIjbaPOJDjlv+XO5h1YO5CGIICJk61UWhRgE9FUYBRx1L6Up1VVVWZVeJVWlizWERZVFliWihb0l7ZXmlfrV/YYE5hCGGOYWBh8mE0YsRjHGRSZFZldGYXZxtnVmd5a7prQW3bbstuIm8ecG5xp3c1cq9yKnNxdAZ1O3Uddh92ynbbdvR2SndAd8x4sXrAe3t8W330fT5/BYBSg++DeYdBiYaJlom/iviKy4oBi/6K7Yo5i4qLCI04j3KQmZF2knyW45ZWl9uX/5cLmDuYEpucn0ooRCjVM507GEA5QElS0FzTfkOfjp8qoAJmZmZpZmxmZmlmZmx/AXRzAHRlBQ8RDwAPBhkRDwjZBbQFAAAAAPIFtwXQBRIAAwQLDA0YGukFwQXpBcIFSfvBBUn7wgXQBbcF0AW4BdAFvAXYBbwF3gW8BeAFvAXjBbwFuQUtAy4DLwMwAzEDHAAYBiIGKwbQBdwFcQYAAAoKCgoNDQ0NDw8PDwkJCQkODg4OCAgICDMzMzM1NTU1ExMTExISEhIVFRUVFhYWFhwcGxsdHRcXJycgIDg4ODg+Pj4+QkJCQkBAQEBJSUpKSkpPT1BQUFBNTU1NYWFiYkkGZGRkZH5+fX1/fy6Cgnx8gICHh4eHAAAmBgABAAEArwCvACIAIgChAKEAoACgAKIAogCqAKoAqgAjACMAI8wGAAAAACYGAAYABwAfACMAJAIGAgcCCAIfAiMCJAQGBAcECAQfBCMEJAUGBR8FIwUkBgcGHwcGBx8IBggHCB8NBg0HDQgNHw8HDx8QBhAHEAgQHxEHER8SHxMGEx8UBhQfGwYbBxsIGx8bIxskHAccHxwjHCQdAR0GHQcdCB0eHR8dIx0kHgYeBx4IHh8eIx4kHwYfBx8IHx8fIx8kIAYgByAIIB8gIyAkIQYhHyEjISQkBiQHJAgkHyQjJCQKSgtKI0ogAEwGUQZRBv8AHyYGAAsADAAfACAAIwAkAgsCDAIfAiACIwIkBAsEDAQfJgYEIAQjBCQFCwUMBR8FIAUjBSQbIxskHCMcJB0BHR4dHx0jHSQeHx4jHiQfAR8fIAsgDCAfICAgIyAkI0okCyQMJB8kICQjJCQABgAHAAgAHwAhAgYCBwIIAh8CIQQGBAcECAQfBCEFHwYHBh8HBgcfCAYIHw0GDQcNCA0fDwcPCA8fEAYQBxAIEB8RBxIfEwYTHxQGFB8bBhsHGwgbHxwHHB8dBh0HHQgdHh0fHgYeBx4IHh8eIR8GHwcfCB8fIAYgByAIIB8gISEGIR8hSiQGJAckCCQfJCEAHwAhAh8CIQQfBCEFHwUhDR8NIQ4fDiEdHh0fHh8gHyAhJB8kIUAGTgZRBicGECIQIxIiEiMTIhMjDCIMIw0iDSMGIgYjBSIFIwciByMOIg4jDyIPIw0FDQYNBw0eDQoMCg4KDwoQIhAjEiISIxMiEyMMIgwjDSINIwYiBiMFIgUjByIHIw4iDiMPIg8jDQUNBg0HDR4NCgwKDgoPCg0FDQYNBw0eDCANIBAeDAUMBgwHDQUNBg0HEB4RHgAkACQqBgACGwADAgADAgADGwAEGwAbAgAbAwAbBAIbAwIbAwMbIAMbHwkDAgkCAwkCHwkbAwkbAwkbAgkbGwkbGwsDAwsDAwsbGwoDGwoDGwoCIAobBAobBAobGwobGwwDHwwEGwwEGw0bAw0bAw0bGw0bIA8CGw8bGw8bGw8bHxAbGxAbIBAbHxcEGxcEGxgbAxgbGxoDGxoDIBoDHxoCAhoCAhoEGxoEGxobAxobAxsDAhsDGxsDIBsCAxsCGxsEAhsEGygGHQQGHx0EHx0dHgUdHgUhHgQdHgQdHgQhHh0iHh0hIh0dIh0dAAYiAgQiAgQhAgYiAgYhAh0iAh0hBB0iBAUhBB0hCwYhDQUiDAUiDgUiHAQiHB0iIgUiIgQiIh0iHR0iGh0iHgUiGh0FHAUdER0iGx0iHgQFHQYiHAQdGx0dHAQdHgQFBAUiBQQiHQQiGR0iAAUiGx0dEQQdDR0dCwYiHgQiNQYAD50ND50nBgAdHSAAHAEKHgYeCA4dEh4KDCEdEh0jICEMHR41BgAPFCcGDh0i/wAdHSD/Eh0jIP8hDB0eJwYFHf8FHQAdICcGCqUAHSwAATACMDoAOwAhAD8AFjAXMCYgEyASAQBfXygpe30IMAwNCAkCAwABBAUGB1sAXQA+ID4gPiA+IF8AXwBfACwAATAuAAAAOwA6AD8AIQAUICgAKQB7AH0AFDAVMCMmKistPD49AFwkJUBABv8LAAv/DCAATQZABv8OAA7/DwAP/xAAEP8RABH/EgASIQYAAQECAgMDBAQFBQUFBgYHBwcHCAgJCQkJCgoKCgsLCwsMDAwMDQ0NDQ4ODw8QEBEREhISEhMTExMUFBQUFRUVFRYWFhYXFxcXGBgYGBkZGRkgICAgISEhISIiIiIjIyMjJCQkJCUlJSUmJiYmJycoKCkpKSkiBiIAIgAiASIBIgMiAyIFIgUhAIUpATABCwwA+vGgoqSmqOLk5sL7oaOlp6mqrK6wsrS2uLq8vsDDxcfJysvMzc7R1Nfa3d7f4OHj5efo6err7O7ymJkxMU8xVTFbMWExogCjAKwArwCmAKUAqSAAAAIlkCGRIZIhkyGgJcslmRC6EAAAAACbELoQBQWlELoQBTERJxEyEScRVUcTPhNHE1cTVbkUuhS5FLAUAAAAALkUvRRVULgVrxW5Fa8VVTUZMBkFV9Fl0VjRZdFf0W7RX9Fv0V/RcNFf0XHRX9Fy0VVVVQW50WXRutFl0bvRbtG80W7Ru9Fv0bzRb9FVVVVBAGEAQQBhAGkAQQBhAEEAQ0QAAEcAAEpLAABOT1BRAFNUVVZXWFlaYWJjZABmaABwAEEAYQBBQgBERUZHSgBTAGEAQUIAREVGRwBJSktMTQBPUwBhAEEAYQBBAGEAQQBhAEEAYQBBAGEAQQBhADEBNwKRA6MDsQPRAyQAHwQgBZEDowOxA9EDJAAfBCAFkQOjA7ED0QMkAB8EIAWRA6MDsQPRAyQAHwQgBZEDowOxA9EDJAAfBCAFCwwwADAAMAAwADAAJwYAAQUIKgYeCAMNIBkaGxwJDxcLGAcKAAEEBgwOEESQd0UoBiwGAABHBjMGFxAREhMABg4CDzQGKgYrBi4GAAA2BgAAOgYtBgAASgYAAEQGAABGBjMGOQYAADUGQgYAADQGAAAAAC4GAAA2BgAAOgYAALoGAABvBgAAKAYsBgAARwYAAAAALQY3BkoGQwYAAEUGRgYzBjkGQQY1BkIGAAA0BioGKwYuBgAANgY4BjoGbgYAAKEGJwYAAQUIICELBhAjKgYaGxwJDxcLGAcKAAEEBgwOECgGLAYvBgAASAYyBi0GNwZKBioGGhscCQ8XCxgHCgABBAYMDhAwLjAALAAoAEEAKQAUMFMAFTBDUkNEV1pBAEhWTVZTRFNTUFBWV0NNQ01ETVJESkswMABoaEtiV1vMU8cwjE4aWeOJKVmkTiBmIXGZZU1SjF+NUbBlHVJCfR91qYzwWDlUFG+VYlVjAE4JTkqQ5l0tTvNTB2NwjVNigXl6eghUgG4JZwhnM3VyUrZVTZEUMBUwLGcJToxOiVu5cFNi13bdUldll1/vUzAAOE4FAAkiAWBPrk+7TwJQelCZUOdQz1CeNDoGTVFUUWRRd1EcBbk0Z1GNUUsFl1GkUcxOrFG1Ud+R9VEDUt80O1JGUnJSd1IVNQIAIICAAAgAAMdSAAIdMz4/UIKKk6y2uLi4LApwcMpT31NjC+tT8VMGVJ5UOFRIVGhUolT2VBBVU1VjVYRVhFWZVatVs1XCVRZXBlYXV1FWdFYHUu5Yzlf0Vw1Yi1cyWDFYrFjkFPJY91gGWRpZIlliWagW6hbsWRtaJ1rYWWZa7jb8NghbPls+W8gZw1vYW+db81sYG/9bBlxTXyJcgTdgXG5cwFyNXOQdQ13mHW5da118XeFd4l0vOP1dKF49XmleYjiDIXw4sF6zXrZeyl6So/5eMSMxIwGCIl8iX8c4uDLaYWJfa1/jOJpfzV/XX/lfgWA6ORw5lGDUJsdgAgIAAAAAAAAACAAKAAACCACACAAACIAogAIAAAJIYQAEBgQyRmpcZ5aqrsjTXWIAVHfzDCs9Y/xiaGODY+Rj8SsiZMVjqWMuOmlkfmSdZHdkbDpPZWxlCjDjZfhmSWYZO5FmCDvkOpJRlVEAZ5xmrYDZQxdnG2chZ15nU2fDM0k7+meFZ1JohWhtNI5oH2gUaZ07QmmjaeppqGqjNttqGDwha6c4VGtOPHJrn2u6a7trjToLHfo6Tmy8PL9szWxnbBZtPm13bUFtaW14bYVtHj00bS9ubm4zPctux27RPvltbm9eP44/xm85cB5wG3CWPUpwfXB3cK1wJQVFcWNCnHGrQyhyNXJQcghGgHKVcjVHAiAAACAAAAAACIAAAAICgIoAACAACAoAgIiAIBRIenOLc6w+pXO4Prg+R3RcdHF0hXTKdBs/JHU2TD51kkxwdZ8hEHahT7hPRFD8PwhA9HbzUPJQGVEzUR53H3cfd0p3OUCLd0ZAlkAdVE54jHjMeONAJlZWeZpWxVaPeet5L0FAekp6T3p8Wadap1ruegJCq1vGe8l7J0KAXNJ8oELofON8AH2GX2N9AUPHfQJ+RX40QyhiR2JZQ9lien8+Y5V/+n8FgNpkI2VggKhlcIBfM9VDsoADgQtEPoG1WqdntWeTM5wzAYIEgp6Pa0SRgouCnYKzUrGCs4K9guaCPGvlgh2DY4OtgyODvYPng1eEU4PKg8yD3IM2bGttAgAAICIqoAoAIIAoAKggIAACgCICiggAqgAAAAIAACjVbCtF8YTzhBaFynNkhSxvXUVhRbFv0nBrRVCGXIZnhmmGqYaIhg6H4oZ5hyiHa4eGh9dF4YcBiPlFYIhjiGd214jeiDVG+oi7NK54Znm+RsdGoIrtioqLVYyofKuMwYwbjXeNL38ECMuNvI3wjd4I1I44j9KF7YWUkPGQEZEuhxuROJLXktiSfJL5kxWU+ouLlZVJt5V3jeZJw5ayXSOXRZEakm5KdkrglwqUskqWlAuYC5gpmLaV4pgzSymZp5nCmf6ZzkswmxKbQJz9nM5M7Uxnnc6g+EwFoQ6ikaK7nlZN+Z7+ngWfD58WnzufAKYCiKAAAAAAgAAoAAiggKCAAICAAAqIgACAACAqAIAARCAVIgBBsMoDC1FNAwCXBSDGBQDnBgBFBwDiCABTCQDNCyA4DgBzDyBdEyBgGiCqGwD0HAD+HSB/LSDwpgCyqgD+AQGrDgFzESFwEwG4FgGaGgGfvAEi4AFL6QEAQZDLAwvTBrLP1ADoA9wA6ADYBNwBygPcAcoK3AQBA9zHAPDAAtzCAdyAwgPcwADoAdzAQekA6kHpAOoA6cyw4sSw2ADcwwDcwgDeANzFBdzBANzBAN4A5MBJCkMTgAAXgEEYgMAA3IAAErAXx0Ier0cbwQHcxADcwQDcjwAjsDTGgcMA3MCBwYAA3MEA3KIAJJ3AANzBANzBAtzAAdzAANzCANzAANzAANzAANzBsG/GANzAiADcl8OAyIDCgMSqAtywRgDczYAA3MEA3MEA3MIC3EIbwgDcwQHcxLALAAePAAmCwADcwbA2AAePAAmvwLAMAAePAAmwPQAHjwAJsD0AB48ACbBOAAmwTgAJhgBUAFuwNAAHjwAJsDwBCY8ACbBLAAmwPAFnAAmMA2uwOwF2AAmMA3qwGwHcmgDcgADcgADYsAZBgYAAhIQDgoEAgoDBAAmAwbANANywPwAHgAEJsCEA3LKewrODAAmeAAmwbAAJicCwmgDksF4A3sAA3LCqwADcsBYACZPHgQDcr8QF3MEA3IAB3LBCAAeOAAmlwADcxrAFAQmwCQAHigEJsBIAB7BnwkEABNzBA9zAQQAFAYMA3IXAgsGwlcEA3MYA3MEA6gDWANwAyuQA6AHkANyAwADpANzAANyyn8EBAcMCAcGDwIIBAcAA3MABAQPcwLgDzcKwXAAJsC/fsfkA2gDkAOgA3gHgsDgBCLhto8CDyZ/BsB/BsOMACaQACbBmAAma0bAIAtykAAmwLgAHiwAJsL7AgMEA3IHBhMGAwLADAAmwxQAJuEb/ABqy0MYG3MGznADcsLEA3LBkxLZhANyAwKfAAAEA3IMACbB0wADcsgzDsVLBsGgB3MIA3MAD3LDEAAmwBwAJsAgACQAHsBTCrwEJsA0AB7AbAAmIAAewOQAJAAewgQAHAAmwHwEHjwAJl8aCxLCcAAmCAAeWwLAyAAkAB7DKAAkAB7BNAAmwRQAJAAewQgAJsNwACQAHsNEBCYMAB7BrAAmwIgAJkQAJsCAACbF0AAmw0QAHgAEJsCAACbhFJwQBsArGtIgBBrhEewABuAyVAdgCAYIA4gTYhwfcgcQB3J3DsGPCuAWKxoDQgcaAwYDEsNTGsYTDta8G3LA8xQAHAEHw0QML4g4BSsBJAkqAAoECggKDAsACwgIACoQCQiSFAsAHgAmCCUAkgCLEAoIihCKGIsYCyALKAswChwKKIs4CjCKQIpIijiKIAokCigKCJAADAgMEA4sCgCQIA4QJhglYJAIKBgOYIpoiniIACQoDoCIMAw4DQAgQAxIDoiKmIsAJpCKoIqoijAKNAo4CQANCA0QDgAOPAo4kwgeICYoJkCRGA6wiAASwIkIIsiICBLQiQAREBLYiQgTCIsAixCLGIsgiQAnABJECyiLEBMwiwgTQIs4ikgKTApQClQJABUIFCAqWApQkRAXEB4wJjgnABpIkRAgIIwojgAUMI4QFkAmSCQ4jggUSI4YFiAUUI4wFFiOYCYoFHiOQBSAjmgmOBSQjIiOZApoCmwLABcIFxAWcAqwkxgXIBcYHlAmWCQAHqiQmI8oFKiMoI0AjQiNEI0YjzAVKI0gjTCNOI1AjuCSdAs4FviQMClIjAAa8JLokQAZUI0IGRAZWI1gjoAKhAqICowLBAsMCAQqkAkMkpQLBB4EJgwlBJIEixQKDIoUihyLHAskCywLNAqcCiyLPAo0ikSKTIo8iqAKpAqoCgyQBAwMDBQOrAoEkCQOFCYcJWSQDCgcDmSKbIp8iAQkLA6EiDQMPA0EIEQMTA6MipyLBCaUiqSKrIoAjrAKtAq4CQQNDA0UDrwKPJMMHiQmLCZEkRwOtIgEEhAixIkMIsyIDBLUiQQRFBLciQwTDIsEixSLHIskiQQnBBLECyyLFBM0iwwTRIs8isgKzArQCtQJBBUMFCQq2ApUkRQXFB40JjwnBBpMkRQgJIwsjgQUNI4UFkQmTCQ8jgwUTI4cFiQUVI40FFyOZCYsFHyOBI5EFISObCY8FJSMjI7kCugK7AsEFwwXFBbwCrSTHBckFxweVCZcJAQerJCcjywUrIykjQSNDI0UjRyPNBUsjSSOCI00jTyNRI7kkvQLPBb8kDQpTI78CvSSDI7skQQZVI0MGRQZXI1kjATGADAAuRiREJEokSCQACEIJRAkECIgihiSEJIokiCSuIpgkliScJJokACMGCgIjBApGCc4HygfIB8wHRyRFJEskSSQBCEMJRQkFCIkihySFJIskiSSvIpkklySdJJskASMHCgMjBQpHCc8HywfJB80HUCROJFQkUiRRJE8kVSRTJJQiliKVIpciBCMGIwUjByMYIxkjGiMbIywjLSMuIy8jACSiJKAkpiSkJKgkoyShJKckpSSpJLAkriS0JLIktiSxJK8ktSSzJLckggiACIEIAggDCJwinSIKCgsKgwhAC4osgQyJLIgsQCVBJQAtBy4ADUAmQSaALgENyCbJJgAvhC8CDYMvgi9ADdgm2SaGMQQNQCdBJwAxhjAGDYUwhDBBDUAoADIHDU8oUCiAMoQsAy5XKEINgSyALMAkwSSGLIMswChDDcAlwSVAKUQNwCbBJgUuAi7AKUUNBS8EL4AN0CbRJoAvQCqCDeAm4SaAMIEwwCqDDQQwAzCBDcAnwSeCMEArhA1HKEgohDGBMQYvCA2BLwUwRg2DMIIxAA4BDkAPgBGCEQMPAA/AEQEPQBECEgQSgQ9AEsAPQhKAD0QShBKCD4YSiBKKEsASghKBEYMRQxBAEMERQRBBEQMSBRLBEEESABBDEsAQRRKFEsIQhxKJEosSwRKDEoAQABEBEQASARKAEoESQBNBE0MTQhNEE8ITABTAE0AUgBTAFEAVQRVAFwAXQRfAFwAYAhgBGEAYgBgAGcAYwRgBGUAZQhlBGYAZwBnCGcEZgBzAHMAdgB8AIAIgBCAGIAggQCCAIIIgwCDBIAAhuCK5IhAjESMcIx0jTCRWJE0kVySMJI0kniSfJAAlAiUEJcArASUDJQUlwSvCK8MrxCvFK8YrxyuAJYIlhCXIK4ElgyWFJckryivLK8wrzSvOK88rACYCJgEmAyaAJoImgSaDJsImxCbGJgAswybFJscmASwCLAMsBCwFLAYsByzKJswmziYILMsmzSbPJgksCiwLLAwsDSwOLA8s0ibUJtYm0ybVJtcm2ibcJt4m2ybdJt8mACcCJwEnAyeAJ4IngSeDJwAoAigEKAEoAygFKEIoRChGKEkoSyhNKEAsSihMKE4oQSxCLEMsRCxFLEYsRyxRKFMoVShILFIoVChWKEksSixLLEwsTSxOLE8sgiwBLoAxhywBLwIvAy8GLoUxADABMAIwQEZBRoBGwEbCRsFGAEdAR4BHwEfCRwBJQEmASYJJAErCSQNKBEpASkFKgEqBSsBKwUrAS8FLAEsBS0BLQUvCS8NLgEuBS4JLg0sATAFMAkwDTABWQFRCVERURlRIVEpUTFROVFBUUlRUVFZUgFSCVIRUwFTBVABVAVVAVUFVgFWBVcBVwVWAVsBYAFcCVwRXBlcIVwpXDFcOVxBXElcUVxZXQFdCV0RXgFeBV8BXwVcAWAFYQFhBWIBYgVgAWQFZAlkDWUBZgI6CjsCOAI8Bj0CPQY+Bj4CPg4/Aj8GPAJAAQeDgAwumH/oYF1YNVhITFgwWETbpAjZMNuESEhYTDhAO4hISDBMM+hkXFm0PFg4PBRQMGw8ODwwrDgI2DgsFFUsW4Q8MweIQDOIA/zAC/wgC/ye/IiECX18hImECIQJBQiECIQKffwJfXyECXz8CBT8iZQEDAgEDAgEDAv8IAv8KAgEDAl8hAv8yoiECISJfQQL/AOI8BeIT5Apu5ATuBoTOBA4E7gnmaH8EDj8gBEIWAWAuARZBAAEAIQLhCQDhAeIbPwJBQv8QYj8MXz8C4SviKP8aD4Yo/y//BgL/WADhHiAEtuIhFhEgLw0A5iURBhYmFiYWBuAA5RNgZTbgA7tMNg02L+YDFhsANuUYBOUC5g3pAnYlBuVbFgXGGw+mJCYPZiXpAkUvBfYGABsFBuUW5hMg5VHmAwXgBukC5RnmASQPVgQgBi3lDmYE5gEERgSGIPYHAOURRiAWAOUD4C3lDQDlCuAD5gcb5hgH5S4GBwYFR+YAZwYnBcblAiY26QIWBOUHBicA5QAgJSDlDgDFAAVAZSAGBUdmICcgJwYF4AAHYCUARSYg6QIlLasPDQUWBiAmBwClYCUg5Q4AxQAlACUAJSAGAEcmYCYgRkAGwGUABcDpAiZFBhbgAiYHAOUBAEUA5Q4AxQAlAIUgBgVHhgAmBwAnBiAF4AclJiDpAhYNwAWmAAYnAOUAICUg5Q4AxQAlAIUgBgUHBgdmICcgJwbAJgdgJQBFJiDpAg8Fq+ACBgUApUBFAGVAJQAFACVAJUBFQOUEYCcGJ0BHAEcGIAWgB+AG6QJLrw0PgAZHBuUAAEUA5Q8A5QhABUZnAEYAZsAmAEWAJSYg6QLAFssPBQYnFuUAAEUA5Q8A5QIAhSAGBQcGhwAGJwAnJsAnwAUAJSYg6QIAJeAFJiflAQBFAOUhJgVHZgBHAEcGBQ9gRQfLRSYg6QLrAQ+lAAYnAOUKQOUQAOUBAAUgxUAGYEdGAAYA5wCg6QIgJxbgBOUoBiXGYA2lBOYAFukCNuAdJQAFAIUA5RAABQDlAgYl5gEFIIUABACmIOkCIGXgGAVP9gcPFk8mr+kC6wIPBg8GDwYSExITJ+UAAOUcYOYGB4YWJoXmAwDmHADvAAavAC+WbzbgHeUjJ2YHpgcmJyYF6QK2pScmZUYFRyXHRWblBQYnJqcGBQfpAkcGL+EeAAGAASDiIxYEQuWAwQBlIMUABQBlIOUhAGUg5RkAZSDFAAUAZSDlBwDlMQBlIOU7IEb2AesMQOUI7wKg4U4goiAR5YHkDxblCRflEhITQOVDVkrlAMDlBQBlRuAD5QpGNuAB5Qom4ATlBQBFACbgBOUsJgfG5wAGJ+YDVgRWDQUGIOkCoOsCoLYRdkYbAOkCoOUbBOUtwIUm5RoGBYDlPuAC5RcARmcmR2AnBqdGYA9ANukC5RYgheAD5SRg5RKg6QILQO8a5Q8mJwYgNuUtBwYHxgAGBwYn5gCn5gIgBukCoOkCoNYEtiDmBggm4DdmB+UnBgeGBwaHBifFYOkC1u8C5gHvAUAmB+UWB2YnJgdGJekC5SQGByZHBgdGJ+AAduUc5wDmACcmQJbpAkBF6QLlFqQ24gHA4SMgQfYA4ABGFuYFB8ZlBqUGJQcmBYDiJOQ34gUE4hrkHeYyAIb/gA7iAP9a4gDhAKIgoSDiAOEA4gDhAKIgoSDiAAABAAEAAQA/wuEA4gYg4gDjAOIA4wDiAOMAggAiYQMOAk5CACJhA05iICJhAE7iAIFOIEIAImEDLgD3A5uxNhQVEjQVEhT2ABgZmxf2ARQVdjBWDBIT9gMMFhD2AhebAPsCCwQgq0wSEwTrAkwSEwDkBUDtGOAI5gVoBkjmBOAHLwFvAS8CQSJBAg8BLwyBrwEPAQ8BD2EPAmECZQIvIiGMP0IPDC8CD+sI6hs/agsvYIyPLG8MLwwvDM8M7xcsLwwPDO8X7ICE7wASExIT7wwszxIT70kM7xbsEe8grO894BHvA+AN6zTvRusO74AvDO8BDO8u7ADvZwzvgHASExITEhMSExITEhMSE+sW7ySMEhPsFxITEhMSExITEhPsCO+AeOx7EhMSExITEhMSExITEhMSExITEhMSE+w3EhMSE+wYEhPsgHrvKOwNL6zvHyDvGADvYeEnAOInAF8hIt9BAj8CP4IkQQL/WgKvf0Y/gHYLNuIeAAKAAiDlMMAEFuAGBuUP4AHFAMUAxQDFAMUAxQDFAMUA5hg2FBUUFVYUFRYUFfYBETYRFhQVNhQVEhMSExITEhOWBPYCMXYRFhL2BS8W4CXvEgDvUeAE74BO4BLvBGAXVg8EBQoSExITEhMSExITLxITEhMSExITERIzD+oBZicRhC9KBAUWLwDlTiAmLiQFEeVSFkQFgOUjAOVWAC9r7wLlGO8c4ATlCO8XAOsC7xbrAA/rB+8Y6wLvH+sH74C45Zk47zjlwBF1QOUNBOWD70DvL+AB5SCkNuWAhARW5QjpAiXgDP8mBQZIFuYCFgT/FCQm5T7qAia24ADuD+QBLv8GIv82BOIAn/8CBC5/BX8i/w1hAoEC/wIgX0ECP+AiPwUkAsUGRQZlBuUPJyYHbwZAqy8ND6DlLHbgACflKucIJuAANukCoOYKpVYFFiUG6QLlFOYANuUP5gMn4AMW5RVARgflJwYnZicmR/YFAATpAmA2hQYE5QHpAoUA5SGmJyYnJuABRQblAAYHIOkCIHblCASlTwUHBgflKgYFRiUmhSYFBgXgECUENuUDByYnNgUkBwbgAqUgpSCl4AHFAMUA4iMOZOIBBC5g4kjlGycGJwYnFgcGIOkCoOWrHOAE5Q9g5Slg/Id4/Zh45YDmIOVi4B7C4ASCgAUG5QIM5QUAhQAFACUAJQDlZO4I4AnlgOMTEuAI5Tgg5S7gIOUEDQ8g5gjWEhMWoOYIFjEwEhMSExITEhMSExITEhMSEzYSE3ZQVgB2ERITEhMSE1YMEUwAFg02YIUA5X8gGwBWDVYSExYMFhE26QI2TDbhEhIWEw4QDuISEgwTDBITFhITNuUCBOUlJOUXQKUgpSClIEVALQwODy0AD2wv4AJbLyDlBADlEgDlCwAlAOUHIOUG4Brlc4BWYOslQO8B6i1r7wkrTwDvBUAP4CfvJQbgeuUVQOUp4AcG6xNg5Rhr4AHlDArlAAqA5R6GgOUWABblHGDlABaK4CLhIOIg5UYg6QKg4Rxg4hxg5SDgAOUs4AMW4IAI5YCv4AHlDuAC5QDggBClIAUA5SQAJUAFIOUPABbrAOUPL8vlF+AA6wHgKOULACWAi+UOq0AW5RKAFuA45TBgKyXrCCDrJgVGACaAZmUARQDlFSBGYAbrAcD2AcDlFSsW5RVL4BjlAA/lFCZgi9bgAeUuQNblDiDrAOULgOsA5QrAduAEy+BI5UHgL+Er4AXiK8Cr5Rxm4ADpAuCAnusXAOUiACYRICXgRuUV6wIF4ADlDuYDa5bgTuUNy+AM5Q/gAQcGB+Ut5gfWYOsM6QLgB0YH5SVHZicmNht24AMbIOURwOkCoEblHIYH5gAA6QJ2BScF4ADlGwY2BeABJgflKEfmASdldmYWBwbpAgUWBVYA6wzgA+UKAOURR0YnBgcmtgbgOcUABQBlAOUHAOUCFqDlJwZH5gCA6QKgJicA5QAgJSDlDgDFACUAhQAmBScGZyAnIEcgBaAHgIUnIMZAhuCAA+UtR+YAJ0YHBmWW6QI2ABYGReAW5ShHpgcGZyYHJiUWBeAA6QLggB7lJ0dmIGcmByb2D2Um4BrlKEfmACcGByZWBeAD6QKg9gXgC+UjBgcGJ6YHBgXA6QLgLuUTIEYnZgeGYOkCK1YP4IA45SRH5gEHJhbgXOEY4hjpAusB4ATlACAFIOUAACUA5RCnACcgJgcGBQcFBwZW4AHpAuA+5QAg5R9HZiAmZwYFFgUH4BMF5gLlIKYHBWb2AAbgAAWmJ0blJuYFByZWBZbgFeUx4IB/5QEA5R0HxgCmBwYFluAC6QLrC0A25RYg5g4AB8YHJgcm4EHFACUA5R6mQAYAJgDGBQbgAOkCoKUAJQDlGIcAJgAnBgcGBcDpAuCAruULJic24IAvBeAH6w3vAG3vCeAFFuWDEuBe6mcAluAD5YA84Io05YOnAPsB4I8/5YG/4KEx5YGxwOUXAOkCYDbgWOUWIIYW4ALlKMaWb2QWD+AC6QIAywDlDYDlC+CCKOEY4hjrD3bgXeVDYAYF5y/AZuQF4DgkFgQG4AMn4Abll3DgAOWETuAi5QHgom/lgJfgKUXgCWXgAOWBBOCIfOVjgOUFQOUBwOUCIA8mFnvgktTvgG7gAu8fIO80J0ZPp/sA5gAvxu8WZu8z4A/vOkYP4IAS6wzgBO9P4AHrEeB/4RLiEuESwgDiCuES4hIBACEgASAhIGEA4QBiAAIAwgDiA+ES4hIhAGEg4QAAwQDiEiEAYQCBAAFAwQDiEuES4hLhEuIS4RLiEuES4hLhEuIS4RLiFCDhEQziEQyi4REM4hEMouERDOIRDKLhEQziEQyi4REM4hEMoj8g6SrvgXjmL2/mKu8ABu8GBi+W4AeGAOYH4ITIxgDmCSDGACYAhuCATeUlQMbEIOkCYAUP4IDo5SRm6QKADeCEeOWAPSDrAcbgIeEa4hrGBGDpAmA24IKJ6zMPSw1r4ETrJQ/rB+CAOmUA5RMAJQAFIAUA5QIAZQAFAAWgBWAFAAUABQBFACUABSAFAAUABQAFAAUAJQAFIGUAxQBlAGUABQDlAgDlCYBFAIUA5QngLCzggIbvJGDvXOAE7wcg7wcA7wcA7x3gAusF74AZ4DDvFeAF7yRg7wHAL+AGr+CAEu+Ac47vglDgAO8FQO8FQO9s4ATvUcDvBOAM7wRg7zDgAO8CoO8g4ADvFiAv4EbvcQDvSgDvf+AE7wYgj0BPgM/gAe8RwM/gAU/gBc/gIe+ACwDvL+Ad6QLgg37lwGZW4Brlj63gA+WAViDllfrgBuWcqeCLl+WBluCFWuWSw+DKrC4b4Bb7WOB45oBo4MC9iP3Av3Yg/cC/diAAAPUrAAB6FAAA/AUAAAAAAACAAAEAoAABAHABAQAQAwEAQwMBAGADAQCwAwEA0AMBANsDAQDwAwEAIJEAABAEAQAwBAEAUAQBAHAEAQCgBAEAWQYBAF4GAQBwBgEAsAYBANAGAQBACAEAmQgBAKUIAQCqCAEAsAgBAPIIAQD2CAEAEAkBAGAJAQCaCQEAsAkBAM8JAQDYCQEA4AkBAKAKAQDwCgEA8AsBABoMAQAwDAEAUAwBAAANAQDwDQEADA4BABAOAQBgDgEA8A4BAJAPAQCQjAAAgIkAQZCABAtkHADIAJsBMwAPAEEAIAALAAwAEQByAh8AFwAWACEAuQEFAAoANQAXAGYBWQAMAAUABABCAAQADwBHADoACwAfAAkABAC8AEcA8QAqAAwAFgCrAO4AHAAEAEIAkACcADMAFQS0AgBBgIEEC9IFrID+gETbgFJ6gEgIgU4EgELigGDNZoBAqIDWgAAAAADdgENwEYCZCYFcH4CagoqAn4OXgY2BwIwYERyRAwGJABQoEQkCBRMkyiEYCAgAIQsLkQkABgApQSGDQKcIgJeAkIBBvIGLiCQhCRSNAAGFl4G4AICcg4iBQVWBnolBkpW+g5+BYNRiAAOAQNIAgGDUwNSAxgEICQuAiwAGgMADDwaAmwMEABaAQVOBmICYgJ6AmICegJiAnoCYgJ6AmAeBsVX/GJoBAAiAiQMAACgYAAACAQAIAAAAAAEACwYDAwCAiYCQIgSAkAAAAAAAAAAAQ0SAQmmNAAEBAMeKr4wGj4DkMxkLgKKAnY/liuQKiAIDQKaLFoWTtQmOASKJgZyCuTEJgYmAiYGcgrkjCQuAnQqAioK5OBCBlIGVE4K5MQmBiIGJgZ2AuiIQgomAp4O5MBAXgYqBnIK5MBAXgYqBm4O5MBCCiYCJgZyCyigAh5GBvAGGkYDiASiBj4BAopCKioCj7YsAC5YbEBEyg4yLAImDRnOBnYGdgZ2BwZJAu4GhgPWLg4hA3YS4iYGTyYG+hK+Ou4KdiAm4irGSQa+NRsCzSPWfYHhzh6GBQWEHgJaE14GxjwC4gKWEm4usg6+LpIDCjYsHgayCsQARDICrJIBA7IdgTzKASFaERoUQDINDE4NBgoFBUoK0jbuArIjGgqOLkYG4gq+MjYHbiAgoQJ+JloO5MQmBiYCJgUDQjALpkUDsMYacgdGOAOmK5o1BAIxA9igJCgCAQI0xK4Cbiakgg5GKrY1BljiG0pWAjfkqAAgQAoDBIAiDQVuDYFBXALYz3IFgTKuAYCNgMJAOAQRJG4BH55mFmYWZAAAAAABAqYCOgEH0iDGdhN+As4BZsL6MgKGkQrCAjICPjEDSj0NPmUeRgWB6HYFA0YBAhoFDYYNgIV+PQ0WZYcxfmYWZhZkAQeCGBAtBSb2Al4BBZYCXgOWAl4BA6YCRgeaAl4D2gI6ATVSARNWAUCCBYM9tgVOdgJeAQVeAi4BA8IBDf4BguDMHhGwurN8AQbCHBAs3Q06ATg6BRlKBSK6AUP2AYM46gM6IbQAGAJ3f/0DvTg9YhIFIkICUgE9rgUC2gELOgE/giEZngABB8IcECxFF/4VA1oCwgEHRgGEH2YCOgABBkIgECzdDeYBKt4D+gGAh5oFgy8CFQZWB8wAAAAAAAACAQR6BAEN5gGAtH4Fgy8CFQZWB8wAAAAAAAACAAEHQiAQLFkHDCAiBpIFO3KoKToc/P4eLgI6AroAAQfCIBAshQN6Az4CXgEQ8gFkRgEDkPz+HiREFAhGAqRGAYNsHhouEAEGgiQQLhQRAnwYAAQABEhCCn4DPAYCLB4D7AQGApYBAu4ieKYTaCIGJgKMEAgQIgMmCnIBBk4BAk4DXg0Leh/sIgNIBgKERgED8gULUgP6Ap4GtgLWAiAMDA4CLgIgAJoCQgIgDAwOAi4BBQYDhgUZSgdSDRRwQioCRgJuMgKGkQNmAQNUAAAAAAAABPz+HiREEACkEEoCIEoCIEREECI8AIIsSKggLAAeCjAaSgZqAjIqA1hgQigEMCgAQEQIGBRyFj4+PiIBAoQiBQPeBQTTVmZpFIIDmguSAQZ6BQPCAQS6A0oCLQNWpgLQAgt8JgN6AsN2Cjd+egKeHroBBf2Bym4FA0YBAhoFDYYOIgGBNlUENCACBiQAACYLDgemlhoskAJcEAAEBgOugQWqRv4G1p4yCmZWUgYuAkgMaAIBAhgiAn5lAgxUNDQoWBoCIYLymg1S5ho2Hv4VCPtSAxgEICQuAiwAGgMADDwaAmwMEABaAQVOBQSOBsVX/GJoBAAiAiQMAACgYAAACAQAIAAAAAAEACwYDAwCAiYCQIgSAkEJDioSegJ+ZgqKA7oKMq4OIMUmdiWD8BUIdawXhT/+viTWZhUYbgFnwgZmEtoMAAAAAAAAAAKyARVuAsoBOQIBEBIBICIW8gKaAjoBBhYBMAwGAnguAQdqAkoDugGDNj4GkgImAQKiAT56AAEGwjQQLF0FIgEUogEkCAIBIKIFIxIVCuIFt3NWAAEHQjQQL5gLdAIDGBQMBgUH2QJ4HJZALgIiBQPyEQNCAtpCAmgABAECFO4FAhQsKgsKa2oq5iqGBQMibvICPAoObgMmAj4DtgI+A7YCPgK6Cu4CPBoD2gP6A7YCPgOyBj4D7gPsogOqAjITKgZoAAAOBwRCBvYDvAIGnC4SYMICJgULAgkRoioiAQVqCQTg5gK+N9YCOgKWItYFAiYG/hdGYGCgKsb7Yi6QigkG8AIKKgoyCjIKMgUzvgkE8gEH5heiD3oBgdXGAiwiAm4HRgY2h5YLsgUDJgJqRuIOjgN6Ai4CjgECUgsCDsoDjhIiC/4FgTy+AQwCPQQ0AgK6ArIHCgEL7gEgDgUI6hUIdikFngfeBvYDLgIiC54FAsYHQgI+AlzKEQMwCgPqBQPqB/YD1gfKAQQyBQQELgECbgNKAkYDQgEGkgEEBAIHQgGBNV4S6hkRXkM+BYGF0Ei85hp2DT4GGQbSDRd+G7BCCAEHAkAQLxQFAtoBCF4FDbYBBuIBDWYBC74D+gElCgLeAQmKAQY2Aw4BTiICqhOaB3IJgbxWARfWAQ8GAlYBAiIDrgJSBYFR6gFPrgEJngkTOgGBQqIFEmwiAYHFXgUgFgq+JNZmFYP6oiTWZhWAv7wmHYC/xgQAAYDAFgZiIjYJDxFm/v2BR/GBZAkFtgelgdQmAmlf3h0TVqYhgJGZBi2BNA2Cm3aFQNIpA3YFWgY1dMEweQh1F4VNKYCALgU4/hPqESu8RgGCQ+QkAgQBBkJIEC0dg/c+fQg2BYP/9gWD//YFg//2BYP/9gWD//YFg//2BYP/9gWD//YFg//2BYP/9gWD//YFg//2BYP/9gWD//YFg//2BYP/9gQBB4JIEC0WgjomGmRiAmYOhMAAIAAsDAoCWgJ6AXxeXh46BkoCJQTBCz0CfQnWdRGtB//9BgBOYjoBgzQyBQQSBiISRgOOAX4eBl4EAQbCTBAu3AqEDgECCgI6AX1uHmIFOBoBByIOMgmDOIINAvAOA2YFgLn+ZgNiLQNVh8eWZAAAAAKCAi4CPgEVIgECTgUCzgKqCQPWAvAACgUEkgUbjgUMVA4FDBIBAxYFAywSAQTmBQWGDQK0JgUDagcCBQ7uBiIJN44CMgEHEgGB0+4BBDYFA4gKAQX2B1YHegECXgUCSgkCPgUD4gGBSZQKBQKiAi4CPgMCASvOBRPyEQOyB9IP+gkCADYCPgdcIgeuAQaCBQXQMjuiBQPiCQgQAgED6gdaBQaOBQrOBYEt0gUCEgMCBioBDUoBgTgWAXeeAAAAAAOiBQMOAQRiAnYCzgJOAQT+A4QCAWQiAsoCMAoBAg4BAnIBBpIBA1YFLMYBhp6SBsYGxgbGBsYGxgbGBsYGxgbGBsYGxgbGBAEHwlQQL8QGggIkAgIoKgEM9B4BCAIC4gMeAjQGBQLOAqooAQOqBtY6egEEEgUTzgUCrA4VBNoFDFIdDBID7gsaBQJwSgKYZgUE5gUFhg0CtCIJA2oS9gUO7gYiCTeOAjAOAiQCBQbCBYHT6gUEMgkDihEF9gdWB3oBAloJAkoL+gI+BQPiAYFJjEINAqICJAICKCoDAAYBEOYCvgESFgEDGgEE1gUCXhcOF2INDt4RA7Ibvg/6CQIANgI+B14TrgEGggouBQWUajuiBQPiCQgQAgED6gdYLgUGdgqyAQoSBRXaEYEX4gUCEgMCCiYBDUYFgTgWAXeaDAEHwlwQLNmAz/1m/v2BR/GBaEAgAgYkAAAmCYQXVYKbdoVA0ikDdgVaBjV0wVB5TSlgKgmDl8Y9tAu9A7wBBsJgECxaIhJGA44CZgFXegEl+ipwMgK6AT5+AAEHQmAQLggSngZEAgJsAgJwAgKyAjoBOfYNHXIFJm4GJgbWBjYFAsIBAvxoqAgoYGAADiCCAkSOICAA5ngsgiAmSIYghC5eBjzuTDoFEPI3JARgIFBwSjUGSlQ2AjTg1EBwBDBgCCYkpgYuSAwgACAMhKpeBigsYCQuqD4CnIAAUIhgUAED/gEICGgiBjQmJQd2JD2DOPCyBQKGBkQCAmwCAnAAACIFg13aAuIC4gLiAuIAAAAAAAKIFBInuA4BfjICLgEDXgJWA2YWOgUFugYuAQKWAmIoaQMaAQOaBiYCIgLkYhIgBAQkDAQAJAgIPFAAEi4oJAAiAkQGBkSgACgwBC4GKDAkECACBkwwoGQMBASgBAAAFAgWAiYGOAQMAAxCAioGvgoiAjYCNgEFzgUHOgpKBsgOARNmAi4BCWACAYb1pgEDJgECfgYuBjQGJypkBloCTAYiUgUCtoYHvCQKB0gqAQQaAvooolzEPiwEZA4GMCQeBiASCixcRAAMFAgXVr8UnCj0QARCBiUDii0EfroCJgLGA0YCy7yIUhoiYNoiCjIYAAKIFBIlf0oBA1IBg3SqAYPPVmUH6hEWvg2wGa99h8/qEYCYcgEDagI+DYcx2gLsRAYL0CYqUkhAaAjAAl4BAyAuAlAOBQK0ShNKAj4KIgIqAQj4BBz2AiIkKt4C8CAiAkBCMAEHgnAQL+QRgIxmBQMwaAYBCCIGUgbGLqoCSgIwHgZAMDwSAlAYIAwEGA4GbgKIAAxCAvIKXgI2AQ1qBsgOAYcStgEDJgEC9AYnKmQCXgJMBIIKUgUCtoIuIgMWAlYuqHIuQEILGAIBAuoG+jBiXkYCZgYyA1dSvxSgSCpIOiEDii0EfroCJgLGA0YCy7yIUhoiYNoiCjIZAqAOAX4yAi4BA14CVgNmFjoFBboGLgN6AxYCYihpAxoBA5oGJgIiAuRgoi4DxifWBigAAKBAoiYGOAQMAAxCAioSsgoiAjYCNgEFzgUHOgpKBsgOARNmAi4BCWACAYb1lQP+Mgp6Au4WLgY0BiZG4mo6JgJMBiAOIQbGEQT2HQQmv//OL1KqLg7eHiYWnh53Ri66AiYBBuED/Q/0AAAAAQKyAQqCAQsuAS0GBRlKB1INH+4SZhLCPUPOAYMyaj0DugECfgM6IYLymg1TOh2wuhE//Hw8HAwEAAAAAAAAAAIAAAAAACAAAAAABAAAAIAAAAAAEAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAACAAAAAgAAAAIAAAACAAAAAgAAAAIAAAACAAAAAgAAAAIAAAACAAAAAgAAAAIAAAACAAAAAgAAAAIAAAACAAAAAwAAAAMAAAADAAAAAwAAAAMAAAADAAAAAwAAAAMAAAAEAAAABAAAAAQAAAAEAAAABQAAAAUAQeOhBAuVAoAAAAAAYE7CUKf01NQAAABAAAAAANJoIDfK5R4KjWSEMXo+Fbh1MpgtxGlTnaqqqiqrqqqqMCdhKFR6amqhJogm5v3zPoMTACVEp8i6Bme0IwnHwILxKZci7T3Isv1/niErV62liDvDIKspfNoAAAAgAAAAAH61UB+zhFisxiyyHm/ipooY4SEesqpdDCHNnR3kNJhDeEwkHWUNejaJBbQcDD4XrFvZSxwNK9eoaNfqG0zO+JhpNJAb5XIPBT9DOxsVb7AudW/rGjj8RpzrOKAaF/07DmIwWRpWjI2zw/QVGuailSvcMNYZ+d59zJmZmRmamZmZgOxfGTGUYIp77igZ+SJPC89q9BgY4waMRjLCGD2fCtwAQYOkBAvOASBHA7gyAAAAQCY8TUpHA7hS/dnVWQAAAGCOBnBlJjxNavCps25HA7hyjgBqdv3Z1XltPwV9AAAAgN9+zIKOBnCFrgXvhyY8TYpF3Y2M8KmzjgEFwZBHA7iSTHialI4AapbWCSiY/dnVmY+UdJttPwWds8aIngAAAKA3rWuh337MoiMWI6SOBnClAAAAAAEAAAAKAAAAZAAAAOgDAAAQJwAAoIYBAEBCDwCAlpgAAOH1BQDKmjsAAAAAAAAAAJQAAAB3AAAAWQAAADsAAAAdAEHgpQQLowOAAIAAgQCCAIMAhACFAIYAhwCIAIkAigCLAIwAjQCOAI8AkACQAJEAkgCTAJQAlQCWAJYAlwCYAJkAmgCbAJsAnACdAJ4AnwCgAKAAoQCiAKMAowCkAKUApgCnAKcAqACpAKoAqgCrAKwArQCtAK4ArwCwALAAsQCyALIAswC0ALUAtQC2ALcAtwC4ALkAuQC6ALsAuwC8AL0AvQC+AL8AwADAAMEAwQDCAMMAwwDEAMUAxQDGAMcAxwDIAMkAyQDKAMsAywDMAMwAzQDOAM4AzwDQANAA0QDRANIA0wDTANQA1ADVANYA1gDXANcA2ADZANkA2gDaANsA2wDcAN0A3QDeAN4A3wDgAOAA4QDhAOIA4gDjAOMA5ADlAOUA5gDmAOcA5wDoAOgA6QDqAOoA6wDrAOwA7ADtAO0A7gDuAO8A8ADwAPEA8QDyAPIA8wDzAPQA9AD1APUA9gD2APcA9wD4APgA+QD5APoA+gD7APsA/AD8AP0A/QD+AP4A/wAgFBANDAsKCgkJCAgICAgHBwcHBwcHBgYGBgYGBgYGBgYGBgBBkKkECxQBALAyAQBwMwEA0DYBADA3AQBQPgBBsKkEC8ABMV9SMjc76wWf2m4kAVnyNWhXLwIauh4FDuF7EOB01RzmBjgFmL/WLAAAAAAAAAAAmlVJBKlsuh5GjsEuCxZgCAcTMg0gEfULOClmDz6rMgn47kAvBQl2LgAAAAAAAAAAT7thBWes3T8YLURU+yHpP5v2gdILc+8/GC1EVPsh+T/iZS8ifyt6PAdcFDMmpoE8vcvweogHcDwHXBQzJqaRPBgtRFT7Iek/GC1EVPsh6b/SITN/fNkCQNIhM3982QLAAEH/qgQL6BWAGC1EVPshCUAYLURU+yEJwAMAAAAEAAAABAAAAAYAAACD+aIARE5uAPwpFQDRVycA3TT1AGLbwAA8mZUAQZBDAGNR/gC73qsAt2HFADpuJADSTUIASQbgAAnqLgAcktEA6x3+ACmxHADoPqcA9TWCAES7LgCc6YQAtCZwAEF+XwDWkTkAU4M5AJz0OQCLX4QAKPm9APgfOwDe/5cAD5gFABEv7wAKWosAbR9tAM9+NgAJyycARk+3AJ5mPwAt6l8Auid1AOXrxwA9e/EA9zkHAJJSigD7a+oAH7FfAAhdjQAwA1YAe/xGAPCrawAgvM8ANvSaAOOpHQBeYZEACBvmAIWZZQCgFF8AjUBoAIDY/wAnc00ABgYxAMpWFQDJqHMAe+JgAGuMwAAZxEcAzWfDAAno3ABZgyoAi3bEAKYclgBEr90AGVfRAKU+BQAFB/8AM34/AMIy6ACYT94Au30yACY9wwAea+8An/heADUfOgB/8soA8YcdAHyQIQBqJHwA1W76ADAtdwAVO0MAtRTGAMMZnQCtxMIALE1BAAwAXQCGfUYA43EtAJvGmgAzYgAAtNJ8ALSnlwA3VdUA1z72AKMQGABNdvwAZJ0qAHDXqwBjfPgAerBXABcV5wDASVYAO9bZAKeEOAAkI8sA1op3AFpUIwAAH7kA8QobABnO3wCfMf8AZh5qAJlXYQCs+0cAfn/YACJltwAy6IkA5r9gAO/EzQBsNgkAXT/UABbe1wBYO94A3puSANIiKAAohugA4lhNAMbKMgAI4xYA4H3LABfAUADzHacAGOBbAC4TNACDEmIAg0gBAPWOWwCtsH8AHunyAEhKQwAQZ9MAqt3YAK5fQgBqYc4ACiikANOZtAAGpvIAXHd/AKPCgwBhPIgAinN4AK+MWgBv170ALaZjAPS/ywCNge8AJsFnAFXKRQDK2TYAKKjSAMJhjQASyXcABCYUABJGmwDEWcQAyMVEAE2ykQAAF/MA1EOtAClJ5QD91RAAAL78AB6UzABwzu4AEz71AOzxgACz58MAx/goAJMFlADBcT4ALgmzAAtF8wCIEpwAqyB7AC61nwBHksIAezIvAAxVbQByp5AAa+cfADHLlgB5FkoAQXniAPTfiQDolJcA4uaEAJkxlwCI7WsAX182ALv9DgBImrQAZ6RsAHFyQgCNXTIAnxW4ALzlCQCNMSUA93Q5ADAFHAANDAEASwhoACzuWABHqpAAdOcCAL3WJAD3faYAbkhyAJ8W7wCOlKYAtJH2ANFTUQDPCvIAIJgzAPVLfgCyY2gA3T5fAEBdAwCFiX8AVVIpADdkwABt2BAAMkgyAFtMdQBOcdQARVRuAAsJwQAq9WkAFGbVACcHnQBdBFAAtDvbAOp2xQCH+RcASWt9AB0nugCWaSkAxsysAK0UVACQ4moAiNmJACxyUAAEpL4AdweUAPMwcAAA/CcA6nGoAGbCSQBk4D0Al92DAKM/lwBDlP0ADYaMADFB3gCSOZ0A3XCMABe35wAI3zsAFTcrAFyAoABagJMAEBGSAA/o2ABsgK8A2/9LADiQDwBZGHYAYqUVAGHLuwDHibkAEEC9ANLyBABJdScA67b2ANsiuwAKFKoAiSYvAGSDdgAJOzMADpQaAFE6qgAdo8IAr+2uAFwmEgBtwk0ALXqcAMBWlwADP4MACfD2ACtAjABtMZkAObQHAAwgFQDYw1sA9ZLEAMatSwBOyqUApzfNAOapNgCrkpQA3UJoABlj3gB2jO8AaItSAPzbNwCuoasA3xUxAACuoQAM+9oAZE1mAO0FtwApZTAAV1a/AEf/OgBq+bkAdb7zACiT3wCrgDAAZoz2AATLFQD6IgYA2eQdAD2zpABXG48ANs0JAE5C6QATvqQAMyO1APCqGgBPZagA0sGlAAs/DwBbeM0AI/l2AHuLBACJF3IAxqZTAG9u4gDv6wAAm0pYAMTatwCqZroAds/PANECHQCx8S0AjJnBAMOtdwCGSNoA912gAMaA9ACs8C8A3eyaAD9cvADQ3m0AkMcfACrbtgCjJToAAK+aAK1TkwC2VwQAKS20AEuAfgDaB6cAdqoOAHtZoQAWEioA3LctAPrl/QCJ2/4Aib79AOR2bAAGqfwAPoBwAIVuFQD9h/8AKD4HAGFnMwAqGIYATb3qALPnrwCPbW4AlWc5ADG/WwCE10gAMN8WAMctQwAlYTUAyXDOADDLuAC/bP0ApACiAAVs5ABa3aAAIW9HAGIS0gC5XIQAcGFJAGtW4ACZUgEAUFU3AB7VtwAz8cQAE25fAF0w5ACFLqkAHbLDAKEyNgAIt6QA6rHUABb3IQCPaeQAJ/93AAwDgACNQC0AT82gACClmQCzotMAL10KALT5QgAR2ssAfb7QAJvbwQCrF70AyqKBAAhqXAAuVRcAJwBVAH8U8ADhB4YAFAtkAJZBjQCHvt4A2v0qAGsltgB7iTQABfP+ALm/ngBoak8ASiqoAE/EWgAt+LwA11qYAPTHlQANTY0AIDqmAKRXXwAUP7EAgDiVAMwgAQBx3YYAyd62AL9g9QBNZREAAQdrAIywrACywNAAUVVIAB77DgCVcsMAowY7AMBANQAG3HsA4EXMAE4p+gDWysgA6PNBAHxk3gCbZNgA2b4xAKSXwwB3WNQAaePFAPDaEwC6OjwARhhGAFV1XwDSvfUAbpLGAKwuXQAORO0AHD5CAGHEhwAp/ekA59bzACJ8ygBvkTUACODFAP/XjQBuauIAsP3GAJMIwQB8XXQAa62yAM1unQA+cnsAxhFqAPfPqQApc98Atcm6ALcAUQDisg0AdLokAOV9YAB02IoADRUsAIEYDAB+ZpQAASkWAJ96dgD9/b4AVkXvANl+NgDs2RMAi7q5AMSX/AAxqCcA8W7DAJTFNgDYqFYAtKi1AM/MDgASiS0Ab1c0ACxWiQCZzuMA1iC5AGteqgA+KpwAEV/MAP0LSgDh9PsAjjttAOKGLADp1IQA/LSpAO/u0QAuNckALzlhADghRAAb2cgAgfwKAPtKagAvHNgAU7SEAE6ZjABUIswAKlXcAMDG1gALGZYAGnC4AGmVZAAmWmAAP1LuAH8RDwD0tREA/Mv1ADS8LQA0vO4A6F3MAN1eYABnjpsAkjPvAMkXuABhWJsA4Ve8AFGDxgDYPhAA3XFIAC0c3QCvGKEAISxGAFnz1wDZepgAnlTAAE+G+gBWBvwA5XmuAIkiNgA4rSIAZ5PcAFXoqgCCJjgAyuebAFENpACZM7EAqdcOAGkFSABlsvAAf4inAIhMlwD50TYAIZKzAHuCSgCYzyEAQJ/cANxHVQDhdDoAZ+tCAP6d3wBe1F8Ae2ekALqsegBV9qIAK4gjAEG6VQBZbggAISqGADlHgwCJ4+YA5Z7UAEn7QAD/VukAHA/KAMVZigCU+isA08HFAA/FzwDbWq4AR8WGAIVDYgAhhjsALHmUABBhhwAqTHsAgCwaAEO/EgCIJpAAeDyJAKjE5ADl23sAxDrCACb06gD3Z4oADZK/AGWjKwA9k7EAvXwLAKRR3AAn3WMAaeHdAJqUGQCoKZUAaM4oAAnttABEnyAATpjKAHCCYwB+fCMAD7kyAKf1jgAUVucAIfEIALWdKgBvfk0ApRlRALX5qwCC39YAlt1hABY2AgDEOp8Ag6KhAHLtbQA5jXoAgripAGsyXABGJ1sAADTtANIAdwD89FUAAVlNAOBxgABB88AEC64BQPsh+T8AAAAALUR0PgAAAICYRvg8AAAAYFHMeDsAAACAgxvwOQAAAEAgJXo4AAAAgCKC4zYAAAAAHfNpNdF0ngBXnb0qgHBSD///PicKAAAAZAAAAOgDAAAQJwAAoIYBAEBCDwCAlpgAAOH1BRkACgAZGRkAAAAABQAAAAAAAAkAAAAACwAAAAAAAAAAGQARChkZGQMKBwABAAkLGAAACQYLAAALAAYZAAAAGRkZAEGxwgQLIQ4AAAAAAAAAABkACg0ZGRkADQAAAgAJDgAAAAkADgAADgBB68IECwEMAEH3wgQLFRMAAAAAEwAAAAAJDAAAAAAADAAADABBpcMECwEQAEGxwwQLFQ8AAAAEDwAAAAAJEAAAAAAAEAAAEABB38MECwESAEHrwwQLHhEAAAAAEQAAAAAJEgAAAAAAEgAAEgAAGgAAABoaGgBBosQECw4aAAAAGhoaAAAAAAAACQBB08QECwEUAEHfxAQLFRcAAAAAFwAAAAAJFAAAAAAAFAAAFABBjcUECwEWAEGZxQQLJxUAAAAAFQAAAAAJFgAAAAAAFgAAFgAAMDEyMzQ1Njc4OUFCQ0RFRgBB5MUECwE6AEGMxgQLCP//////////AEHQxgQLAxAvUQBB3MYECx0DAAAAAAAAAAIAAAAAAAAAAQAAAAEAAAABAAAABQBBhMcECwKWAQBBnMcECwuXAQAAmAEAAOwqAQBBtMcECwECAEHExwQLCP//////////AEGIyAQLCXgjAQAAAAAABQBBnMgECwKZAQBBtMgECw6XAQAAmgEAAPgqAQAABABBzMgECwEBAEHcyAQLBf////8KAEGgyQQLAxAkAQ==", !UA.startsWith(hA)) {
          var iA = UA;
          UA = n.locateFile ? n.locateFile(iA, C) : C + iA;
        }
        function wA(q) {
          try {
            if (q == UA && y)
              return new Uint8Array(y);
            var AA = vA(q);
            if (AA)
              return AA;
            if (B)
              return B(q);
            throw "both async and sync fetching of the wasm failed";
          } catch (gA) {
            rA(gA);
          }
        }
        function Re(q) {
          if (!y && (u || I)) {
            if (typeof fetch == "function" && !q.startsWith("file://"))
              return fetch(q, { credentials: "same-origin" }).then(function(AA) {
                if (!AA.ok)
                  throw "failed to load wasm binary file at '" + q + "'";
                return AA.arrayBuffer();
              }).catch(function() {
                return wA(q);
              });
            if (l)
              return new Promise(function(AA, gA) {
                l(q, function(fA) {
                  AA(new Uint8Array(fA));
                }, gA);
              });
          }
          return Promise.resolve().then(function() {
            return wA(q);
          });
        }
        function zA(q, AA, gA) {
          return Re(q).then(function(fA) {
            return WebAssembly.instantiate(fA, AA);
          }).then(function(fA) {
            return fA;
          }).then(gA, function(fA) {
            p("failed to asynchronously prepare wasm: " + fA), rA(fA);
          });
        }
        function U(q, AA) {
          var gA = UA;
          return y || typeof WebAssembly.instantiateStreaming != "function" || gA.startsWith(hA) || gA.startsWith("file://") || c || typeof fetch != "function" ? zA(gA, q, AA) : fetch(gA, { credentials: "same-origin" }).then(function(fA) {
            return WebAssembly.instantiateStreaming(fA, q).then(AA, function(LA) {
              return p("wasm streaming compile failed: " + LA), p("falling back to ArrayBuffer instantiation"), zA(gA, q, AA);
            });
          });
        }
        function N(q) {
          for (; 0 < q.length; )
            q.shift()(n);
        }
        var CA = typeof TextDecoder < "u" ? new TextDecoder("utf8") : void 0;
        function P(q, AA, gA) {
          var fA = AA + gA;
          for (gA = AA; q[gA] && !(gA >= fA); )
            ++gA;
          if (16 < gA - AA && q.buffer && CA)
            return CA.decode(q.subarray(AA, gA));
          for (fA = ""; AA < gA; ) {
            var LA = q[AA++];
            if (LA & 128) {
              var YA = q[AA++] & 63;
              if ((LA & 224) == 192)
                fA += String.fromCharCode((LA & 31) << 6 | YA);
              else {
                var le = q[AA++] & 63;
                LA = (LA & 240) == 224 ? (LA & 15) << 12 | YA << 6 | le : (LA & 7) << 18 | YA << 12 | le << 6 | q[AA++] & 63, 65536 > LA ? fA += String.fromCharCode(LA) : (LA -= 65536, fA += String.fromCharCode(55296 | LA >> 10, 56320 | LA & 1023));
              }
            } else
              fA += String.fromCharCode(LA);
          }
          return fA;
        }
        function XA(q, AA) {
          return q ? P(F, q, AA) : "";
        }
        var ue = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335], Y = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
        function L(q) {
          for (var AA = 0, gA = 0; gA < q.length; ++gA) {
            var fA = q.charCodeAt(gA);
            127 >= fA ? AA++ : 2047 >= fA ? AA += 2 : 55296 <= fA && 57343 >= fA ? (AA += 4, ++gA) : AA += 3;
          }
          return AA;
        }
        function V(q, AA, gA) {
          var fA = F;
          if (!(0 < gA))
            return 0;
          var LA = AA;
          gA = AA + gA - 1;
          for (var YA = 0; YA < q.length; ++YA) {
            var le = q.charCodeAt(YA);
            if (55296 <= le && 57343 >= le) {
              var Oe = q.charCodeAt(++YA);
              le = 65536 + ((le & 1023) << 10) | Oe & 1023;
            }
            if (127 >= le) {
              if (AA >= gA)
                break;
              fA[AA++] = le;
            } else {
              if (2047 >= le) {
                if (AA + 1 >= gA)
                  break;
                fA[AA++] = 192 | le >> 6;
              } else {
                if (65535 >= le) {
                  if (AA + 2 >= gA)
                    break;
                  fA[AA++] = 224 | le >> 12;
                } else {
                  if (AA + 3 >= gA)
                    break;
                  fA[AA++] = 240 | le >> 18, fA[AA++] = 128 | le >> 12 & 63;
                }
                fA[AA++] = 128 | le >> 6 & 63;
              }
              fA[AA++] = 128 | le & 63;
            }
          }
          return fA[AA] = 0, AA - LA;
        }
        function Z(q) {
          var AA = L(q) + 1, gA = MA(AA);
          return gA && V(q, gA, AA), gA;
        }
        var cA = {};
        function X() {
          if (!z) {
            var q = { USER: "web_user", LOGNAME: "web_user", PATH: "/", PWD: "/", HOME: "/home/web_user", LANG: (typeof navigator == "object" && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8", _: o || "./this.program" }, AA;
            for (AA in cA)
              cA[AA] === void 0 ? delete q[AA] : q[AA] = cA[AA];
            var gA = [];
            for (AA in q)
              gA.push(AA + "=" + q[AA]);
            z = gA;
          }
          return z;
        }
        var z, SA = [null, [], []];
        function aA(q, AA, gA, fA) {
          var LA = { string: (we) => {
            var nt = 0;
            if (we != null && we !== 0) {
              nt = L(we) + 1;
              var bn = EA(nt);
              V(we, bn, nt), nt = bn;
            }
            return nt;
          }, array: (we) => {
            var nt = EA(we.length);
            return w.set(we, nt), nt;
          } };
          q = n["_" + q];
          var YA = [], le = 0;
          if (fA)
            for (var Oe = 0; Oe < fA.length; Oe++) {
              var Qe = LA[gA[Oe]];
              Qe ? (le === 0 && (le = BA()), YA[Oe] = Qe(fA[Oe])) : YA[Oe] = fA[Oe];
            }
          return gA = q.apply(null, YA), gA = function(we) {
            return le !== 0 && pA(le), AA === "string" ? XA(we) : AA === "boolean" ? !!we : we;
          }(gA);
        }
        var Ae = typeof atob == "function" ? atob : function(q) {
          var AA = "", gA = 0;
          q = q.replace(/[^A-Za-z0-9\+\/=]/g, "");
          do {
            var fA = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(q.charAt(gA++)), LA = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(q.charAt(gA++)), YA = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(q.charAt(gA++)), le = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(q.charAt(gA++));
            fA = fA << 2 | LA >> 4, LA = (LA & 15) << 4 | YA >> 2;
            var Oe = (YA & 3) << 6 | le;
            AA += String.fromCharCode(fA), YA !== 64 && (AA += String.fromCharCode(LA)), le !== 64 && (AA += String.fromCharCode(Oe));
          } while (gA < q.length);
          return AA;
        };
        function vA(q) {
          if (q.startsWith(hA)) {
            if (q = q.slice(hA.length), typeof c == "boolean" && c) {
              var AA = Buffer.from(q, "base64");
              AA = new Uint8Array(AA.buffer, AA.byteOffset, AA.byteLength);
            } else
              try {
                var gA = Ae(q), fA = new Uint8Array(gA.length);
                for (q = 0; q < gA.length; ++q)
                  fA[q] = gA.charCodeAt(q);
                AA = fA;
              } catch {
                throw Error("Converting base64 string to bytes failed.");
              }
            return AA;
          }
        }
        var RA = {
          a: function(q, AA, gA, fA) {
            rA("Assertion failed: " + XA(q) + ", at: " + [AA ? XA(AA) : "unknown filename", gA, fA ? XA(fA) : "unknown function"]);
          },
          l: function(q, AA) {
            q = new Date(1e3 * (G[q >> 2] + 4294967296 * b[q + 4 >> 2])), b[AA >> 2] = q.getSeconds(), b[AA + 4 >> 2] = q.getMinutes(), b[AA + 8 >> 2] = q.getHours(), b[AA + 12 >> 2] = q.getDate(), b[AA + 16 >> 2] = q.getMonth(), b[AA + 20 >> 2] = q.getFullYear() - 1900, b[AA + 24 >> 2] = q.getDay();
            var gA = q.getFullYear();
            b[AA + 28 >> 2] = (gA % 4 !== 0 || gA % 100 === 0 && gA % 400 !== 0 ? Y : ue)[q.getMonth()] + q.getDate() - 1 | 0, b[AA + 36 >> 2] = -(60 * q.getTimezoneOffset()), gA = new Date(q.getFullYear(), 6, 1).getTimezoneOffset();
            var fA = new Date(q.getFullYear(), 0, 1).getTimezoneOffset();
            b[AA + 32 >> 2] = (gA != fA && q.getTimezoneOffset() == Math.min(fA, gA)) | 0;
          },
          k: function(q, AA, gA) {
            function fA(Qe) {
              return (Qe = Qe.toTimeString().match(/\(([A-Za-z ]+)\)$/)) ? Qe[1] : "GMT";
            }
            var LA = (/* @__PURE__ */ new Date()).getFullYear(), YA = new Date(LA, 0, 1), le = new Date(LA, 6, 1);
            LA = YA.getTimezoneOffset();
            var Oe = le.getTimezoneOffset();
            G[q >> 2] = 60 * Math.max(LA, Oe), b[AA >> 2] = +(LA != Oe), q = fA(YA), AA = fA(le), q = Z(q), AA = Z(AA), Oe < LA ? (G[gA >> 2] = q, G[gA + 4 >> 2] = AA) : (G[gA >> 2] = AA, G[gA + 4 >> 2] = q);
          },
          b: function() {
            rA("");
          },
          m: function() {
            return Date.now();
          },
          j: function(q) {
            var AA = F.length;
            if (q >>>= 0, 2147483648 < q)
              return !1;
            for (var gA = 1; 4 >= gA; gA *= 2) {
              var fA = AA * (1 + 0.2 / gA);
              fA = Math.min(fA, q + 100663296);
              var LA = Math, YA = LA.min;
              fA = Math.max(q, fA), fA += (65536 - fA % 65536) % 65536;
              A: {
                var le = m.buffer;
                try {
                  m.grow(YA.call(LA, 2147483648, fA) - le.byteLength + 65535 >>> 16), T();
                  var Oe = 1;
                  break A;
                } catch {
                }
                Oe = void 0;
              }
              if (Oe)
                return !0;
            }
            return !1;
          },
          e: function(q, AA) {
            var gA = 0;
            return X().forEach(function(fA, LA) {
              var YA = AA + gA;
              for (LA = G[q + 4 * LA >> 2] = YA, YA = 0; YA < fA.length; ++YA)
                w[LA++ >> 0] = fA.charCodeAt(YA);
              w[LA >> 0] = 0, gA += fA.length + 1;
            }), 0;
          },
          f: function(q, AA) {
            var gA = X();
            G[q >> 2] = gA.length;
            var fA = 0;
            return gA.forEach(function(LA) {
              fA += LA.length + 1;
            }), G[AA >> 2] = fA, 0;
          },
          d: function() {
            return 52;
          },
          i: function() {
            return 70;
          },
          c: function(q, AA, gA, fA) {
            for (var LA = 0, YA = 0; YA < gA; YA++) {
              var le = G[AA >> 2], Oe = G[AA + 4 >> 2];
              AA += 8;
              for (var Qe = 0; Qe < Oe; Qe++) {
                var we = F[le + Qe], nt = SA[q];
                we === 0 || we === 10 ? ((q === 1 ? f : p)(P(nt, 0)), nt.length = 0) : nt.push(we);
              }
              LA += Oe;
            }
            return G[fA >> 2] = LA, 0;
          },
          o: function(q, AA, gA, fA, LA) {
            return n.callbacks.callFunction(void 0, q, AA, gA, fA, LA);
          },
          n: function(q) {
            return n.callbacks.shouldInterrupt(void 0, q);
          },
          h: function(q, AA, gA) {
            return gA = XA(gA), n.callbacks.loadModuleSource(void 0, q, AA, gA);
          },
          g: function(q, AA, gA, fA) {
            return gA = XA(gA), fA = XA(fA), n.callbacks.normalizeModule(void 0, q, AA, gA, fA);
          }
        };
        (function() {
          function q(gA) {
            if (gA = gA.exports, n.asm = gA, m = n.asm.p, T(), H.unshift(n.asm.q), sA--, n.monitorRunDependencies && n.monitorRunDependencies(sA), sA == 0 && uA) {
              var fA = uA;
              uA = null, fA();
            }
            return gA;
          }
          var AA = { a: RA };
          if (sA++, n.monitorRunDependencies && n.monitorRunDependencies(sA), n.instantiateWasm)
            try {
              return n.instantiateWasm(AA, q);
            } catch (gA) {
              p("Module.instantiateWasm callback failed with error: " + gA), a(gA);
            }
          return U(AA, function(gA) {
            q(gA.instance);
          }).catch(a), {};
        })();
        var MA = n._malloc = function() {
          return (MA = n._malloc = n.asm.r).apply(null, arguments);
        };
        n._QTS_Throw = function() {
          return (n._QTS_Throw = n.asm.s).apply(null, arguments);
        }, n._QTS_NewError = function() {
          return (n._QTS_NewError = n.asm.t).apply(null, arguments);
        }, n._QTS_RuntimeSetMemoryLimit = function() {
          return (n._QTS_RuntimeSetMemoryLimit = n.asm.u).apply(null, arguments);
        }, n._QTS_RuntimeComputeMemoryUsage = function() {
          return (n._QTS_RuntimeComputeMemoryUsage = n.asm.v).apply(null, arguments);
        }, n._QTS_RuntimeDumpMemoryUsage = function() {
          return (n._QTS_RuntimeDumpMemoryUsage = n.asm.w).apply(null, arguments);
        }, n._QTS_RecoverableLeakCheck = function() {
          return (n._QTS_RecoverableLeakCheck = n.asm.x).apply(null, arguments);
        }, n._QTS_BuildIsSanitizeLeak = function() {
          return (n._QTS_BuildIsSanitizeLeak = n.asm.y).apply(null, arguments);
        }, n._QTS_RuntimeSetMaxStackSize = function() {
          return (n._QTS_RuntimeSetMaxStackSize = n.asm.z).apply(null, arguments);
        }, n._QTS_GetUndefined = function() {
          return (n._QTS_GetUndefined = n.asm.A).apply(null, arguments);
        }, n._QTS_GetNull = function() {
          return (n._QTS_GetNull = n.asm.B).apply(null, arguments);
        }, n._QTS_GetFalse = function() {
          return (n._QTS_GetFalse = n.asm.C).apply(null, arguments);
        }, n._QTS_GetTrue = function() {
          return (n._QTS_GetTrue = n.asm.D).apply(null, arguments);
        }, n._QTS_NewRuntime = function() {
          return (n._QTS_NewRuntime = n.asm.E).apply(null, arguments);
        }, n._QTS_FreeRuntime = function() {
          return (n._QTS_FreeRuntime = n.asm.F).apply(null, arguments);
        }, n._QTS_NewContext = function() {
          return (n._QTS_NewContext = n.asm.G).apply(null, arguments);
        }, n._QTS_FreeContext = function() {
          return (n._QTS_FreeContext = n.asm.H).apply(null, arguments);
        }, n._QTS_FreeValuePointer = function() {
          return (n._QTS_FreeValuePointer = n.asm.I).apply(null, arguments);
        }, n._free = function() {
          return (n._free = n.asm.J).apply(null, arguments);
        }, n._QTS_FreeValuePointerRuntime = function() {
          return (n._QTS_FreeValuePointerRuntime = n.asm.K).apply(null, arguments);
        }, n._QTS_FreeVoidPointer = function() {
          return (n._QTS_FreeVoidPointer = n.asm.L).apply(null, arguments);
        }, n._QTS_FreeCString = function() {
          return (n._QTS_FreeCString = n.asm.M).apply(null, arguments);
        }, n._QTS_DupValuePointer = function() {
          return (n._QTS_DupValuePointer = n.asm.N).apply(null, arguments);
        }, n._QTS_NewObject = function() {
          return (n._QTS_NewObject = n.asm.O).apply(null, arguments);
        }, n._QTS_NewObjectProto = function() {
          return (n._QTS_NewObjectProto = n.asm.P).apply(null, arguments);
        }, n._QTS_NewArray = function() {
          return (n._QTS_NewArray = n.asm.Q).apply(null, arguments);
        }, n._QTS_NewFloat64 = function() {
          return (n._QTS_NewFloat64 = n.asm.R).apply(null, arguments);
        }, n._QTS_GetFloat64 = function() {
          return (n._QTS_GetFloat64 = n.asm.S).apply(null, arguments);
        }, n._QTS_NewString = function() {
          return (n._QTS_NewString = n.asm.T).apply(null, arguments);
        }, n._QTS_GetString = function() {
          return (n._QTS_GetString = n.asm.U).apply(null, arguments);
        }, n._QTS_NewSymbol = function() {
          return (n._QTS_NewSymbol = n.asm.V).apply(null, arguments);
        }, n._QTS_GetSymbolDescriptionOrKey = function() {
          return (n._QTS_GetSymbolDescriptionOrKey = n.asm.W).apply(null, arguments);
        }, n._QTS_IsGlobalSymbol = function() {
          return (n._QTS_IsGlobalSymbol = n.asm.X).apply(null, arguments);
        }, n._QTS_IsJobPending = function() {
          return (n._QTS_IsJobPending = n.asm.Y).apply(null, arguments);
        }, n._QTS_ExecutePendingJob = function() {
          return (n._QTS_ExecutePendingJob = n.asm.Z).apply(null, arguments);
        }, n._QTS_GetProp = function() {
          return (n._QTS_GetProp = n.asm._).apply(null, arguments);
        }, n._QTS_SetProp = function() {
          return (n._QTS_SetProp = n.asm.$).apply(null, arguments);
        }, n._QTS_DefineProp = function() {
          return (n._QTS_DefineProp = n.asm.aa).apply(null, arguments);
        }, n._QTS_Call = function() {
          return (n._QTS_Call = n.asm.ba).apply(null, arguments);
        }, n._QTS_ResolveException = function() {
          return (n._QTS_ResolveException = n.asm.ca).apply(null, arguments);
        }, n._QTS_Dump = function() {
          return (n._QTS_Dump = n.asm.da).apply(null, arguments);
        }, n._QTS_Eval = function() {
          return (n._QTS_Eval = n.asm.ea).apply(null, arguments);
        }, n._QTS_Typeof = function() {
          return (n._QTS_Typeof = n.asm.fa).apply(null, arguments);
        }, n._QTS_GetGlobalObject = function() {
          return (n._QTS_GetGlobalObject = n.asm.ga).apply(null, arguments);
        }, n._QTS_NewPromiseCapability = function() {
          return (n._QTS_NewPromiseCapability = n.asm.ha).apply(null, arguments);
        }, n._QTS_TestStringArg = function() {
          return (n._QTS_TestStringArg = n.asm.ia).apply(null, arguments);
        }, n._QTS_BuildIsDebug = function() {
          return (n._QTS_BuildIsDebug = n.asm.ja).apply(null, arguments);
        }, n._QTS_BuildIsAsyncify = function() {
          return (n._QTS_BuildIsAsyncify = n.asm.ka).apply(null, arguments);
        }, n._QTS_NewFunction = function() {
          return (n._QTS_NewFunction = n.asm.la).apply(null, arguments);
        }, n._QTS_ArgvGetJSValueConstPointer = function() {
          return (n._QTS_ArgvGetJSValueConstPointer = n.asm.ma).apply(null, arguments);
        }, n._QTS_RuntimeEnableInterruptHandler = function() {
          return (n._QTS_RuntimeEnableInterruptHandler = n.asm.na).apply(null, arguments);
        }, n._QTS_RuntimeDisableInterruptHandler = function() {
          return (n._QTS_RuntimeDisableInterruptHandler = n.asm.oa).apply(null, arguments);
        }, n._QTS_RuntimeEnableModuleLoader = function() {
          return (n._QTS_RuntimeEnableModuleLoader = n.asm.pa).apply(null, arguments);
        }, n._QTS_RuntimeDisableModuleLoader = function() {
          return (n._QTS_RuntimeDisableModuleLoader = n.asm.qa).apply(null, arguments);
        };
        function BA() {
          return (BA = n.asm.sa).apply(null, arguments);
        }
        function pA() {
          return (pA = n.asm.ta).apply(null, arguments);
        }
        function EA() {
          return (EA = n.asm.ua).apply(null, arguments);
        }
        n.___start_em_js = 74916, n.___stop_em_js = 75818, n.cwrap = function(q, AA, gA, fA) {
          var LA = !gA || gA.every((YA) => YA === "number" || YA === "boolean");
          return AA !== "string" && LA && !fA ? n["_" + q] : function() {
            return aA(q, AA, gA, arguments);
          };
        }, n.UTF8ToString = XA, n.stringToUTF8 = function(q, AA, gA) {
          return V(q, AA, gA);
        }, n.lengthBytesUTF8 = L;
        var _A;
        uA = function q() {
          _A || oe(), _A || (uA = q);
        };
        function oe() {
          function q() {
            if (!_A && (_A = !0, n.calledRun = !0, !S)) {
              if (N(H), s(n), n.onRuntimeInitialized && n.onRuntimeInitialized(), n.postRun)
                for (typeof n.postRun == "function" && (n.postRun = [n.postRun]); n.postRun.length; ) {
                  var AA = n.postRun.shift();
                  j.unshift(AA);
                }
              N(j);
            }
          }
          if (!(0 < sA)) {
            if (n.preRun)
              for (typeof n.preRun == "function" && (n.preRun = [n.preRun]); n.preRun.length; )
                eA();
            N(K), 0 < sA || (n.setStatus ? (n.setStatus("Running..."), setTimeout(function() {
              setTimeout(function() {
                n.setStatus("");
              }, 1), q();
            }, 1)) : q());
          }
        }
        if (n.preInit)
          for (typeof n.preInit == "function" && (n.preInit = [n.preInit]); 0 < n.preInit.length; )
            n.preInit.pop()();
        return oe(), i.ready;
      };
    })();
    t.exports = e;
  }(Bw)), Bw.exports;
}
var KM;
function xtA() {
  return KM || (KM = 1, function(t) {
    var A = W && W.__createBinding || (Object.create ? function(g, o, u, I) {
      I === void 0 && (I = u);
      var c = Object.getOwnPropertyDescriptor(o, u);
      (!c || ("get" in c ? !o.__esModule : c.writable || c.configurable)) && (c = { enumerable: !0, get: function() {
        return o[u];
      } }), Object.defineProperty(g, I, c);
    } : function(g, o, u, I) {
      I === void 0 && (I = u), g[I] = o[u];
    }), e = W && W.__setModuleDefault || (Object.create ? function(g, o) {
      Object.defineProperty(g, "default", { enumerable: !0, value: o });
    } : function(g, o) {
      g.default = o;
    }), r = W && W.__importStar || function(g) {
      if (g && g.__esModule) return g;
      var o = {};
      if (g != null) for (var u in g) u !== "default" && Object.prototype.hasOwnProperty.call(g, u) && A(o, g, u);
      return e(o, g), o;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.RELEASE_ASYNC = t.DEBUG_ASYNC = t.RELEASE_SYNC = t.DEBUG_SYNC = t.memoizePromiseFactory = t.newQuickJSAsyncWASMModule = t.newQuickJSWASMModule = void 0;
    const i = vtA();
    async function n(g = t.RELEASE_SYNC) {
      const [o, u, { QuickJSWASMModule: I }] = await Promise.all([
        g.importModuleLoader(),
        g.importFFI(),
        Promise.resolve().then(() => r(GK())).then(i.unwrapTypescript)
      ]), c = await o();
      c.type = "sync";
      const C = new u(c);
      return new I(c, C);
    }
    t.newQuickJSWASMModule = n;
    async function s(g = t.RELEASE_ASYNC) {
      const [o, u, { QuickJSAsyncWASMModule: I }] = await Promise.all([
        g.importModuleLoader(),
        g.importFFI(),
        Promise.resolve().then(() => r(_tA())).then(i.unwrapTypescript)
      ]), c = await o();
      c.type = "async";
      const C = new u(c);
      return new I(c, C);
    }
    t.newQuickJSAsyncWASMModule = s;
    function a(g) {
      let o;
      return () => o ?? (o = g());
    }
    t.memoizePromiseFactory = a, t.DEBUG_SYNC = {
      type: "sync",
      async importFFI() {
        throw new Error("not implemented");
      },
      async importModuleLoader() {
        throw new Error("not implemented");
      }
    }, t.RELEASE_SYNC = {
      type: "sync",
      async importFFI() {
        const g = await Promise.resolve().then(() => r(NtA()));
        return (0, i.unwrapTypescript)(g).QuickJSFFI;
      },
      async importModuleLoader() {
        const g = await Promise.resolve().then(() => r(LtA()));
        return (0, i.unwrapJavascript)(g);
      }
    }, t.DEBUG_ASYNC = {
      type: "async",
      async importFFI() {
        throw new Error("not implemented");
      },
      async importModuleLoader() {
        throw new Error("not implemented");
      }
    }, t.RELEASE_ASYNC = {
      type: "async",
      async importFFI() {
        throw new Error("not implemented");
      },
      async importModuleLoader() {
        throw new Error("not implemented");
      }
    };
  }(Cw)), Cw;
}
var Va = {}, JM;
function GtA() {
  if (JM) return Va;
  JM = 1, Object.defineProperty(Va, "__esModule", { value: !0 }), Va.isFail = Va.isSuccess = void 0;
  function t(e) {
    return !("error" in e);
  }
  Va.isSuccess = t;
  function A(e) {
    return "error" in e;
  }
  return Va.isFail = A, Va;
}
var iC = {}, HM;
function UtA() {
  if (HM) return iC;
  HM = 1, Object.defineProperty(iC, "__esModule", { value: !0 }), iC.TestQuickJSWASMModule = void 0;
  const t = vg(), A = Rg();
  class e {
    constructor(i) {
      this.parent = i, this.contexts = /* @__PURE__ */ new Set(), this.runtimes = /* @__PURE__ */ new Set();
    }
    newRuntime(i) {
      const n = this.parent.newRuntime({
        ...i,
        ownedLifetimes: [
          new A.Lifetime(void 0, void 0, () => this.runtimes.delete(n)),
          ...(i == null ? void 0 : i.ownedLifetimes) ?? []
        ]
      });
      return this.runtimes.add(n), n;
    }
    newContext(i) {
      const n = this.parent.newContext({
        ...i,
        ownedLifetimes: [
          new A.Lifetime(void 0, void 0, () => this.contexts.delete(n)),
          ...(i == null ? void 0 : i.ownedLifetimes) ?? []
        ]
      });
      return this.contexts.add(n), n;
    }
    evalCode(i, n) {
      return this.parent.evalCode(i, n);
    }
    disposeAll() {
      const i = [...this.contexts, ...this.runtimes];
      this.runtimes.clear(), this.contexts.clear(), i.forEach((n) => {
        n.alive && n.dispose();
      });
    }
    assertNoMemoryAllocated() {
      if (this.getFFI().QTS_RecoverableLeakCheck())
        throw new t.QuickJSMemoryLeakDetected("Leak sanitizer detected un-freed memory");
      if (this.contexts.size > 0)
        throw new t.QuickJSMemoryLeakDetected(`${this.contexts.size} contexts leaked`);
      if (this.runtimes.size > 0)
        throw new t.QuickJSMemoryLeakDetected(`${this.runtimes.size} runtimes leaked`);
    }
    /** @private */
    getFFI() {
      return this.parent.getFFI();
    }
  }
  return iC.TestQuickJSWASMModule = e, iC;
}
var PM;
function UK() {
  return PM || (PM = 1, function(t) {
    var A = W && W.__createBinding || (Object.create ? function(C, E, l, B) {
      B === void 0 && (B = l);
      var h = Object.getOwnPropertyDescriptor(E, l);
      (!h || ("get" in h ? !E.__esModule : h.writable || h.configurable)) && (h = { enumerable: !0, get: function() {
        return E[l];
      } }), Object.defineProperty(C, B, h);
    } : function(C, E, l, B) {
      B === void 0 && (B = l), C[B] = E[l];
    }), e = W && W.__setModuleDefault || (Object.create ? function(C, E) {
      Object.defineProperty(C, "default", { enumerable: !0, value: E });
    } : function(C, E) {
      C.default = E;
    }), r = W && W.__exportStar || function(C, E) {
      for (var l in C) l !== "default" && !Object.prototype.hasOwnProperty.call(E, l) && A(E, C, l);
    }, i = W && W.__importStar || function(C) {
      if (C && C.__esModule) return C;
      var E = {};
      if (C != null) for (var l in C) l !== "default" && Object.prototype.hasOwnProperty.call(C, l) && A(E, C, l);
      return e(E, C), E;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.shouldInterruptAfterDeadline = t.newAsyncContext = t.newAsyncRuntime = t.getQuickJSSync = t.getQuickJS = t.errors = t.RELEASE_SYNC = t.RELEASE_ASYNC = t.DEBUG_SYNC = t.DEBUG_ASYNC = t.newQuickJSAsyncWASMModule = t.newQuickJSWASMModule = void 0;
    const n = xtA();
    Object.defineProperty(t, "newQuickJSWASMModule", { enumerable: !0, get: function() {
      return n.newQuickJSWASMModule;
    } }), Object.defineProperty(t, "newQuickJSAsyncWASMModule", { enumerable: !0, get: function() {
      return n.newQuickJSAsyncWASMModule;
    } }), Object.defineProperty(t, "DEBUG_ASYNC", { enumerable: !0, get: function() {
      return n.DEBUG_ASYNC;
    } }), Object.defineProperty(t, "DEBUG_SYNC", { enumerable: !0, get: function() {
      return n.DEBUG_SYNC;
    } }), Object.defineProperty(t, "RELEASE_ASYNC", { enumerable: !0, get: function() {
      return n.RELEASE_ASYNC;
    } }), Object.defineProperty(t, "RELEASE_SYNC", { enumerable: !0, get: function() {
      return n.RELEASE_SYNC;
    } }), r(GtA(), t), r(Rg(), t), t.errors = i(vg()), r(_K(), t), r(UtA(), t);
    let s, a;
    async function g() {
      return a ?? (a = (0, n.newQuickJSWASMModule)().then((C) => (s = C, C))), await a;
    }
    t.getQuickJS = g;
    function o() {
      if (!s)
        throw new Error("QuickJS not initialized. Await getQuickJS() at least once.");
      return s;
    }
    t.getQuickJSSync = o;
    async function u(C) {
      return (await (0, n.newQuickJSAsyncWASMModule)()).newRuntime(C);
    }
    t.newAsyncRuntime = u;
    async function I(C) {
      return (await (0, n.newQuickJSAsyncWASMModule)()).newContext(C);
    }
    t.newAsyncContext = I;
    function c(C) {
      const E = typeof C == "number" ? C : C.getTime();
      return function() {
        return Date.now() > E;
      };
    }
    t.shouldInterruptAfterDeadline = c;
  }(Iw)), Iw;
}
var nC = {}, sC = {}, OM;
function TtA() {
  if (OM) return sC;
  OM = 1;
  var t = W && W.__importDefault || function(i) {
    return i && i.__esModule ? i : { default: i };
  };
  Object.defineProperty(sC, "__esModule", { value: !0 }), sC.parseProxyResponse = void 0;
  const e = (0, t(Ir).default)("https-proxy-agent:parse-proxy-response");
  function r(i) {
    return new Promise((n, s) => {
      let a = 0;
      const g = [];
      function o() {
        const E = i.read();
        E ? C(E) : i.once("readable", o);
      }
      function u() {
        i.removeListener("end", I), i.removeListener("error", c), i.removeListener("readable", o);
      }
      function I() {
        u(), e("onend"), s(new Error("Proxy connection ended before receiving CONNECT response"));
      }
      function c(E) {
        u(), e("onerror %o", E), s(E);
      }
      function C(E) {
        g.push(E), a += E.length;
        const l = Buffer.concat(g, a), B = l.indexOf(`\r
\r
`);
        if (B === -1) {
          e("have not received end of HTTP headers yet..."), o();
          return;
        }
        const h = l.slice(0, B).toString("ascii").split(`\r
`), Q = h.shift();
        if (!Q)
          return i.destroy(), s(new Error("No header received from proxy CONNECT response"));
        const f = Q.split(" "), p = +f[1], y = f.slice(2).join(" "), m = {};
        for (const S of h) {
          if (!S)
            continue;
          const w = S.indexOf(":");
          if (w === -1)
            return i.destroy(), s(new Error(`Invalid header from proxy CONNECT response: "${S}"`));
          const F = S.slice(0, w).toLowerCase(), b = S.slice(w + 1).trimStart(), G = m[F];
          typeof G == "string" ? m[F] = [G, b] : Array.isArray(G) ? G.push(b) : m[F] = b;
        }
        e("got proxy server response: %o %o", Q, m), u(), n({
          connect: {
            statusCode: p,
            statusText: y,
            headers: m
          },
          buffered: l
        });
      }
      i.on("error", c), i.on("end", I), o();
    });
  }
  return sC.parseProxyResponse = r, sC;
}
var YM;
function KtA() {
  if (YM) return nC;
  YM = 1;
  var t = W && W.__createBinding || (Object.create ? function(B, h, Q, f) {
    f === void 0 && (f = Q);
    var p = Object.getOwnPropertyDescriptor(h, Q);
    (!p || ("get" in p ? !h.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {
      return h[Q];
    } }), Object.defineProperty(B, f, p);
  } : function(B, h, Q, f) {
    f === void 0 && (f = Q), B[f] = h[Q];
  }), A = W && W.__setModuleDefault || (Object.create ? function(B, h) {
    Object.defineProperty(B, "default", { enumerable: !0, value: h });
  } : function(B, h) {
    B.default = h;
  }), e = W && W.__importStar || function(B) {
    if (B && B.__esModule) return B;
    var h = {};
    if (B != null) for (var Q in B) Q !== "default" && Object.prototype.hasOwnProperty.call(B, Q) && t(h, B, Q);
    return A(h, B), h;
  }, r = W && W.__importDefault || function(B) {
    return B && B.__esModule ? B : { default: B };
  };
  Object.defineProperty(nC, "__esModule", { value: !0 }), nC.HttpsProxyAgent = void 0;
  const i = e(yr), n = e(Sn), s = r(R_), a = r(Ir), g = KS(), o = Dn, u = TtA(), I = (0, a.default)("https-proxy-agent"), c = (B) => B.servername === void 0 && B.host && !i.isIP(B.host) ? {
    ...B,
    servername: B.host
  } : B;
  class C extends g.Agent {
    constructor(h, Q) {
      super(Q), this.options = { path: void 0 }, this.proxy = typeof h == "string" ? new o.URL(h) : h, this.proxyHeaders = (Q == null ? void 0 : Q.headers) ?? {}, I("Creating new HttpsProxyAgent instance: %o", this.proxy.href);
      const f = (this.proxy.hostname || this.proxy.host).replace(/^\[|\]$/g, ""), p = this.proxy.port ? parseInt(this.proxy.port, 10) : this.proxy.protocol === "https:" ? 443 : 80;
      this.connectOpts = {
        // Attempt to negotiate http/1.1 for proxy servers that support http/2
        ALPNProtocols: ["http/1.1"],
        ...Q ? l(Q, "headers") : null,
        host: f,
        port: p
      };
    }
    /**
     * Called when the node-core HTTP client library is creating a
     * new HTTP request.
     */
    async connect(h, Q) {
      const { proxy: f } = this;
      if (!Q.host)
        throw new TypeError('No "host" provided');
      let p;
      f.protocol === "https:" ? (I("Creating `tls.Socket`: %o", this.connectOpts), p = n.connect(c(this.connectOpts))) : (I("Creating `net.Socket`: %o", this.connectOpts), p = i.connect(this.connectOpts));
      const y = typeof this.proxyHeaders == "function" ? this.proxyHeaders() : { ...this.proxyHeaders }, m = i.isIPv6(Q.host) ? `[${Q.host}]` : Q.host;
      let S = `CONNECT ${m}:${Q.port} HTTP/1.1\r
`;
      if (f.username || f.password) {
        const T = `${decodeURIComponent(f.username)}:${decodeURIComponent(f.password)}`;
        y["Proxy-Authorization"] = `Basic ${Buffer.from(T).toString("base64")}`;
      }
      y.Host = `${m}:${Q.port}`, y["Proxy-Connection"] || (y["Proxy-Connection"] = this.keepAlive ? "Keep-Alive" : "close");
      for (const T of Object.keys(y))
        S += `${T}: ${y[T]}\r
`;
      const w = (0, u.parseProxyResponse)(p);
      p.write(`${S}\r
`);
      const { connect: F, buffered: b } = await w;
      if (h.emit("proxyConnect", F), this.emit("proxyConnect", F, h), F.statusCode === 200)
        return h.once("socket", E), Q.secureEndpoint ? (I("Upgrading socket connection to TLS"), n.connect({
          ...l(c(Q), "host", "path", "port"),
          socket: p
        })) : p;
      p.destroy();
      const G = new i.Socket({ writable: !1 });
      return G.readable = !0, h.once("socket", (T) => {
        I("Replaying proxy buffer for failed request"), (0, s.default)(T.listenerCount("data") > 0), T.push(b), T.push(null);
      }), G;
    }
  }
  C.protocols = ["http", "https"], nC.HttpsProxyAgent = C;
  function E(B) {
    B.resume();
  }
  function l(B, ...h) {
    const Q = {};
    let f;
    for (f in B)
      h.includes(f) || (Q[f] = B[f]);
    return Q;
  }
  return nC;
}
var aC = {}, qM;
function JtA() {
  if (qM) return aC;
  qM = 1;
  var t = W && W.__createBinding || (Object.create ? function(C, E, l, B) {
    B === void 0 && (B = l);
    var h = Object.getOwnPropertyDescriptor(E, l);
    (!h || ("get" in h ? !E.__esModule : h.writable || h.configurable)) && (h = { enumerable: !0, get: function() {
      return E[l];
    } }), Object.defineProperty(C, B, h);
  } : function(C, E, l, B) {
    B === void 0 && (B = l), C[B] = E[l];
  }), A = W && W.__setModuleDefault || (Object.create ? function(C, E) {
    Object.defineProperty(C, "default", { enumerable: !0, value: E });
  } : function(C, E) {
    C.default = E;
  }), e = W && W.__importStar || function(C) {
    if (C && C.__esModule) return C;
    var E = {};
    if (C != null) for (var l in C) l !== "default" && Object.prototype.hasOwnProperty.call(C, l) && t(E, C, l);
    return A(E, C), E;
  }, r = W && W.__importDefault || function(C) {
    return C && C.__esModule ? C : { default: C };
  };
  Object.defineProperty(aC, "__esModule", { value: !0 }), aC.HttpProxyAgent = void 0;
  const i = e(yr), n = e(Sn), s = r(Ir), a = rI, g = KS(), o = Dn, u = (0, s.default)("http-proxy-agent");
  class I extends g.Agent {
    constructor(E, l) {
      super(l), this.proxy = typeof E == "string" ? new o.URL(E) : E, this.proxyHeaders = (l == null ? void 0 : l.headers) ?? {}, u("Creating new HttpProxyAgent instance: %o", this.proxy.href);
      const B = (this.proxy.hostname || this.proxy.host).replace(/^\[|\]$/g, ""), h = this.proxy.port ? parseInt(this.proxy.port, 10) : this.proxy.protocol === "https:" ? 443 : 80;
      this.connectOpts = {
        ...l ? c(l, "headers") : null,
        host: B,
        port: h
      };
    }
    addRequest(E, l) {
      E._header = null, this.setRequestProps(E, l), super.addRequest(E, l);
    }
    setRequestProps(E, l) {
      const { proxy: B } = this, h = l.secureEndpoint ? "https:" : "http:", Q = E.getHeader("host") || "localhost", f = `${h}//${Q}`, p = new o.URL(E.path, f);
      l.port !== 80 && (p.port = String(l.port)), E.path = String(p);
      const y = typeof this.proxyHeaders == "function" ? this.proxyHeaders() : { ...this.proxyHeaders };
      if (B.username || B.password) {
        const m = `${decodeURIComponent(B.username)}:${decodeURIComponent(B.password)}`;
        y["Proxy-Authorization"] = `Basic ${Buffer.from(m).toString("base64")}`;
      }
      y["Proxy-Connection"] || (y["Proxy-Connection"] = this.keepAlive ? "Keep-Alive" : "close");
      for (const m of Object.keys(y)) {
        const S = y[m];
        S && E.setHeader(m, S);
      }
    }
    async connect(E, l) {
      E._header = null, E.path.includes("://") || this.setRequestProps(E, l);
      let B, h;
      u("Regenerating stored HTTP header string for request"), E._implicitHeader(), E.outputData && E.outputData.length > 0 && (u("Patching connection write() output buffer with updated header"), B = E.outputData[0].data, h = B.indexOf(`\r
\r
`) + 4, E.outputData[0].data = E._header + B.substring(h), u("Output buffer: %o", E.outputData[0].data));
      let Q;
      return this.proxy.protocol === "https:" ? (u("Creating `tls.Socket`: %o", this.connectOpts), Q = n.connect(this.connectOpts)) : (u("Creating `net.Socket`: %o", this.connectOpts), Q = i.connect(this.connectOpts)), await (0, a.once)(Q, "connect"), Q;
    }
  }
  I.protocols = ["http", "https"], aC.HttpProxyAgent = I;
  function c(C, ...E) {
    const l = {};
    let B;
    for (B in C)
      E.includes(B) || (l[B] = C[B]);
    return l;
  }
  return aC;
}
var jM;
function HtA() {
  if (jM) return _I;
  jM = 1;
  var t = W && W.__createBinding || (Object.create ? function(h, Q, f, p) {
    p === void 0 && (p = f);
    var y = Object.getOwnPropertyDescriptor(Q, f);
    (!y || ("get" in y ? !Q.__esModule : y.writable || y.configurable)) && (y = { enumerable: !0, get: function() {
      return Q[f];
    } }), Object.defineProperty(h, p, y);
  } : function(h, Q, f, p) {
    p === void 0 && (p = f), h[p] = Q[f];
  }), A = W && W.__setModuleDefault || (Object.create ? function(h, Q) {
    Object.defineProperty(h, "default", { enumerable: !0, value: Q });
  } : function(h, Q) {
    h.default = Q;
  }), e = W && W.__importStar || function(h) {
    if (h && h.__esModule) return h;
    var Q = {};
    if (h != null) for (var f in h) f !== "default" && Object.prototype.hasOwnProperty.call(h, f) && t(Q, h, f);
    return A(Q, h), Q;
  }, r = W && W.__importDefault || function(h) {
    return h && h.__esModule ? h : { default: h };
  };
  Object.defineProperty(_I, "__esModule", { value: !0 }), _I.PacProxyAgent = void 0;
  const i = e(yr), n = e(Sn), s = e(un), a = rI, g = r(Ir), o = Dn, u = KS(), I = NeA(), c = ktA(), C = UK(), E = (0, g.default)("pac-proxy-agent"), l = (h) => h.servername === void 0 && h.host && !i.isIP(h.host) ? {
    ...h,
    servername: h.host
  } : h;
  class B extends u.Agent {
    constructor(Q, f) {
      super(f), this.clearResolverPromise = () => {
        this.resolverPromise = void 0;
      };
      const p = typeof Q == "string" ? Q : Q.href;
      this.uri = new o.URL(p.replace(/^pac\+/i, "")), E("Creating PacProxyAgent with URI %o", this.uri.href), this.opts = { ...f }, this.cache = void 0, this.resolver = void 0, this.resolverHash = "", this.resolverPromise = void 0, this.opts.filename || (this.opts.filename = this.uri.href);
    }
    /**
     * Loads the PAC proxy file from the source if necessary, and returns
     * a generated `FindProxyForURL()` resolver function to use.
     */
    getResolver() {
      return this.resolverPromise || (this.resolverPromise = this.loadResolver(), this.resolverPromise.then(this.clearResolverPromise, this.clearResolverPromise)), this.resolverPromise;
    }
    async loadResolver() {
      try {
        const [Q, f] = await Promise.all([
          (0, C.getQuickJS)(),
          this.loadPacFile()
        ]), p = s.createHash("sha1").update(f).digest("hex");
        return this.resolver && this.resolverHash === p ? (E("Same sha1 hash for code - contents have not changed, reusing previous proxy resolver"), this.resolver) : (E("Creating new proxy resolver instance"), this.resolver = (0, c.createPacResolver)(Q, f, this.opts), this.resolverHash = p, this.resolver);
      } catch (Q) {
        if (this.resolver && Q.code === "ENOTMODIFIED")
          return E("Got ENOTMODIFIED response, reusing previous proxy resolver"), this.resolver;
        throw Q;
      }
    }
    /**
     * Loads the contents of the PAC proxy file.
     *
     * @api private
     */
    async loadPacFile() {
      E("Loading PAC file: %o", this.uri);
      const Q = await (0, I.getUri)(this.uri, { ...this.opts, cache: this.cache });
      E("Got `Readable` instance for URI"), this.cache = Q;
      const f = await (0, u.toBuffer)(Q);
      return E("Read %o byte PAC file from URI", f.length), f.toString("utf8");
    }
    /**
     * Called when the node-core HTTP client library is creating a new HTTP request.
     */
    async connect(Q, f) {
      const { secureEndpoint: p } = f, y = Q.getHeader("upgrade") === "websocket", m = await this.getResolver(), S = p ? "https:" : "http:", w = f.host && i.isIPv6(f.host) ? `[${f.host}]` : f.host, F = Object.assign(new o.URL(Q.path, `${S}//${w}`), void 0);
      E("url: %s", F);
      let b = await m(F);
      b || (b = "DIRECT");
      const G = String(b).trim().split(/\s*;\s*/g).filter(Boolean);
      this.opts.fallbackToDirect && !G.includes("DIRECT") && G.push("DIRECT");
      for (const T of G) {
        let K = null, H = null;
        const [j, eA] = T.split(/\s+/);
        if (E("Attempting to use proxy: %o", T), j === "DIRECT")
          p ? H = n.connect(l(f)) : H = i.connect(f);
        else if (j === "SOCKS" || j === "SOCKS5") {
          const { SocksProxyAgent: sA } = await Promise.resolve().then(() => e(UD()));
          K = new sA(`socks://${eA}`, this.opts);
        } else if (j === "SOCKS4") {
          const { SocksProxyAgent: sA } = await Promise.resolve().then(() => e(UD()));
          K = new sA(`socks4a://${eA}`, this.opts);
        } else if (j === "PROXY" || j === "HTTP" || j === "HTTPS") {
          const sA = `${j === "HTTPS" ? "https" : "http"}://${eA}`;
          if (p || y) {
            const { HttpsProxyAgent: uA } = await Promise.resolve().then(() => e(KtA()));
            K = new uA(sA, this.opts);
          } else {
            const { HttpProxyAgent: uA } = await Promise.resolve().then(() => e(JtA()));
            K = new uA(sA, this.opts);
          }
        }
        try {
          if (H)
            return await (0, a.once)(H, "connect"), Q.emit("proxy", { proxy: T, socket: H }), H;
          if (K) {
            const sA = await K.connect(Q, f);
            if (!(sA instanceof i.Socket))
              throw new Error("Expected a `net.Socket` to be returned from agent");
            return Q.emit("proxy", { proxy: T, socket: sA }), sA;
          }
          throw new Error(`Could not determine proxy type for: ${T}`);
        } catch (sA) {
          E("Got error for proxy %o: %o", T, sA), Q.emit("proxy", { proxy: T, error: sA });
        }
      }
      throw new Error(`Failed to establish a socket connection to proxies: ${JSON.stringify(G)}`);
    }
  }
  return B.protocols = [
    "pac+data",
    "pac+file",
    "pac+ftp",
    "pac+http",
    "pac+https"
  ], _I.PacProxyAgent = B, _I;
}
(function(t) {
  var A = W && W.__createBinding || (Object.create ? function(B, h, Q, f) {
    f === void 0 && (f = Q);
    var p = Object.getOwnPropertyDescriptor(h, Q);
    (!p || ("get" in p ? !h.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {
      return h[Q];
    } }), Object.defineProperty(B, f, p);
  } : function(B, h, Q, f) {
    f === void 0 && (f = Q), B[f] = h[Q];
  }), e = W && W.__setModuleDefault || (Object.create ? function(B, h) {
    Object.defineProperty(B, "default", { enumerable: !0, value: h });
  } : function(B, h) {
    B.default = h;
  }), r = W && W.__importStar || function(B) {
    if (B && B.__esModule) return B;
    var h = {};
    if (B != null) for (var Q in B) Q !== "default" && Object.prototype.hasOwnProperty.call(B, Q) && A(h, B, Q);
    return e(h, B), h;
  }, i = W && W.__importDefault || function(B) {
    return B && B.__esModule ? B : { default: B };
  };
  Object.defineProperty(t, "__esModule", { value: !0 }), t.ProxyAgent = t.proxies = void 0;
  const n = r(wn), s = r(mn), a = Dn, g = i(HAA), o = kp, u = i(Ir), I = NT, c = (0, u.default)("proxy-agent"), C = {
    http: async () => (await Promise.resolve().then(() => r(seA()))).HttpProxyAgent,
    https: async () => (await Promise.resolve().then(() => r(oeA()))).HttpsProxyAgent,
    socks: async () => (await Promise.resolve().then(() => r(UD()))).SocksProxyAgent,
    pac: async () => (await Promise.resolve().then(() => r(HtA()))).PacProxyAgent
  };
  t.proxies = {
    http: [C.http, C.https],
    https: [C.http, C.https],
    socks: [C.socks, C.socks],
    socks4: [C.socks, C.socks],
    socks4a: [C.socks, C.socks],
    socks5: [C.socks, C.socks],
    socks5h: [C.socks, C.socks],
    "pac+data": [C.pac, C.pac],
    "pac+file": [C.pac, C.pac],
    "pac+ftp": [C.pac, C.pac],
    "pac+http": [C.pac, C.pac],
    "pac+https": [C.pac, C.pac]
  };
  function E(B) {
    return Object.keys(t.proxies).includes(B);
  }
  class l extends o.Agent {
    constructor(h) {
      super(h), this.cache = new g.default({
        max: 20,
        dispose: (Q) => Q.destroy()
      }), c("Creating new ProxyAgent instance: %o", h), this.connectOpts = h, this.httpAgent = (h == null ? void 0 : h.httpAgent) || new n.Agent(h), this.httpsAgent = (h == null ? void 0 : h.httpsAgent) || new s.Agent(h), this.getProxyForUrl = (h == null ? void 0 : h.getProxyForUrl) || I.getProxyForUrl;
    }
    async connect(h, Q) {
      const { secureEndpoint: f } = Q, p = h.getHeader("upgrade") === "websocket", y = f ? p ? "wss:" : "https:" : p ? "ws:" : "http:", m = h.getHeader("host"), S = new a.URL(h.path, `${y}//${m}`).href, w = await this.getProxyForUrl(S, h);
      if (!w)
        return c("Proxy not enabled for URL: %o", S), f ? this.httpsAgent : this.httpAgent;
      c("Request URL: %o", S), c("Proxy URL: %o", w);
      const F = `${y}+${w}`;
      let b = this.cache.get(F);
      if (b)
        c("Cache hit for proxy URL: %o", w);
      else {
        const T = new a.URL(w).protocol.replace(":", "");
        if (!E(T))
          throw new Error(`Unsupported protocol for proxy URL: ${w}`);
        const K = await t.proxies[T][f || p ? 1 : 0]();
        b = new K(w, this.connectOpts), this.cache.set(F, b);
      }
      return b;
    }
    destroy() {
      for (const h of this.cache.values())
        h.destroy();
      super.destroy();
    }
  }
  t.ProxyAgent = l;
})(FT);
/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
function TK(t, A, e, r = !0) {
  const i = {
    protocol: t.protocol,
    hostname: t.hostname,
    port: t.port,
    path: t.pathname + t.search,
    method: A,
    headers: r ? { Connection: "keep-alive" } : void 0,
    auth: FJ(t).auth,
    agent: new FT.ProxyAgent()
  }, n = (a) => {
    a.statusCode && a.statusCode >= 300 && a.statusCode < 400 && a.headers.location ? (TK(new kJ(a.headers.location), A, e), a.resume()) : e(a);
  }, s = i.protocol === "https:" ? PJ.request(i, n) : HJ.request(i, n);
  return s.end(), s;
}
async function _p(t) {
  const A = await KK(t);
  try {
    return JSON.parse(A);
  } catch {
    throw new Error("Could not parse JSON from " + t.toString());
  }
}
function KK(t) {
  return new Promise((A, e) => {
    TK(t, "GET", (i) => {
      let n = "";
      if (i.statusCode && i.statusCode >= 400)
        return e(new Error(`Got status code ${i.statusCode}`));
      i.on("data", (s) => {
        n += s;
      }), i.on("end", () => {
        try {
          return A(String(n));
        } catch {
          return e(new Error("Chrome version not found"));
        }
      });
    }, !1).on("error", (i) => {
      e(i);
    });
  });
}
/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
function of(t) {
  switch (t) {
    case QA.LINUX_ARM:
    case QA.LINUX:
      return "linux64";
    case QA.MAC_ARM:
      return "mac-arm64";
    case QA.MAC:
      return "mac-x64";
    case QA.WIN32:
      return "win32";
    case QA.WIN64:
      return "win64";
  }
}
function PtA(t, A, e = "https://storage.googleapis.com/chrome-for-testing-public") {
  return `${e}/${JK(t, A).join("/")}`;
}
function JK(t, A) {
  return [A, of(t), `chrome-${of(t)}.zip`];
}
function OtA(t, A) {
  switch (t) {
    case QA.MAC:
    case QA.MAC_ARM:
      return VA.join("chrome-" + of(t), "Google Chrome for Testing.app", "Contents", "MacOS", "Google Chrome for Testing");
    case QA.LINUX_ARM:
    case QA.LINUX:
      return VA.join("chrome-linux64", "chrome");
    case QA.WIN32:
    case QA.WIN64:
      return VA.join("chrome-" + of(t), "chrome.exe");
  }
}
let YS = "https://googlechromelabs.github.io/chrome-for-testing";
async function YtA(t) {
  const A = await _p(new URL(`${YS}/last-known-good-versions.json`));
  for (const e of Object.keys(A.channels))
    A.channels[e.toLowerCase()] = A.channels[e], delete A.channels[e];
  return A.channels[t];
}
async function qtA(t) {
  return (await _p(new URL(`${YS}/latest-versions-per-milestone.json`))).milestones[t];
}
async function jtA(t) {
  return (await _p(new URL(`${YS}/latest-patch-versions-per-build.json`))).builds[t];
}
async function Vt(t) {
  var A, e;
  if (Object.values(ie).includes(t))
    return (await YtA(t)).version;
  if (t.match(/^\d+$/))
    return (A = await qtA(t)) == null ? void 0 : A.version;
  if (t.match(/^\d+\.\d+\.\d+$/))
    return (e = await jtA(t)) == null ? void 0 : e.version;
}
const HK = [
  "PROGRAMFILES",
  "ProgramW6432",
  "ProgramFiles(x86)",
  // https://source.chromium.org/chromium/chromium/src/+/main:chrome/installer/mini_installer/README.md
  "LOCALAPPDATA"
];
function PK(t, A) {
  if (A.size === 0)
    throw new Error("Non of the common Windows Env variables were set");
  let e;
  switch (t) {
    case ie.STABLE:
      e = "Google\\Chrome\\Application\\chrome.exe";
      break;
    case ie.BETA:
      e = "Google\\Chrome Beta\\Application\\chrome.exe";
      break;
    case ie.CANARY:
      e = "Google\\Chrome SxS\\Application\\chrome.exe";
      break;
    case ie.DEV:
      e = "Google\\Chrome Dev\\Application\\chrome.exe";
      break;
  }
  return [...A.values()].map((r) => VA.win32.join(r, e));
}
function WtA(t) {
  try {
    const A = Sw(`cmd.exe /c echo %${t.toLocaleUpperCase()}%`, {
      // We need to ignore the stderr as cmd.exe
      // prints a message about wrong UNC path not supported.
      stdio: ["ignore", "pipe", "ignore"],
      encoding: "utf-8"
    }).trim();
    if (A)
      return A;
  } catch {
  }
}
function VtA(t) {
  if (!Sw("wslinfo --version", {
    stdio: ["ignore", "pipe", "ignore"],
    encoding: "utf-8"
  }).trim())
    throw new Error("Not in WSL or unsupported version of WSL.");
  const e = /* @__PURE__ */ new Set();
  for (const i of HK) {
    const n = WtA(i);
    n && e.add(n);
  }
  return PK(t, e).map((i) => Sw(`wslpath "${i}"`).toString().trim());
}
function ZtA(t) {
  const A = [];
  try {
    const e = VtA(t);
    e && A.push(...e);
  } catch {
  }
  switch (t) {
    case ie.STABLE:
      A.push("/opt/google/chrome/chrome");
      break;
    case ie.BETA:
      A.push("/opt/google/chrome-beta/chrome");
      break;
    case ie.CANARY:
      A.push("/opt/google/chrome-canary/chrome");
      break;
    case ie.DEV:
      A.push("/opt/google/chrome-unstable/chrome");
      break;
  }
  return A;
}
function XtA(t, A) {
  switch (t) {
    case QA.WIN64:
    case QA.WIN32:
      const e = new Set(HK.map((r) => process.env[r]).filter((r) => !!r));
      return e.add("C:\\Program Files"), e.add("C:\\Program Files (x86)"), e.add("D:\\Program Files"), e.add("D:\\Program Files (x86)"), PK(A, e);
    case QA.MAC_ARM:
    case QA.MAC:
      switch (A) {
        case ie.STABLE:
          return [
            "/Applications/Google Chrome.app/Contents/MacOS/Google Chrome"
          ];
        case ie.BETA:
          return [
            "/Applications/Google Chrome Beta.app/Contents/MacOS/Google Chrome Beta"
          ];
        case ie.CANARY:
          return [
            "/Applications/Google Chrome Canary.app/Contents/MacOS/Google Chrome Canary"
          ];
        case ie.DEV:
          return [
            "/Applications/Google Chrome Dev.app/Contents/MacOS/Google Chrome Dev"
          ];
      }
    case QA.LINUX_ARM:
    case QA.LINUX:
      return ZtA(A);
  }
}
function ztA(t, A) {
  switch (t) {
    case QA.WIN64:
    case QA.WIN32:
      switch (A) {
        case ie.STABLE:
          return VA.join(hQ(), "Google", "Chrome", "User Data");
        case ie.BETA:
          return VA.join(hQ(), "Google", "Chrome Beta", "User Data");
        case ie.CANARY:
          return VA.join(hQ(), "Google", "Chrome SxS", "User Data");
        case ie.DEV:
          return VA.join(hQ(), "Google", "Chrome Dev", "User Data");
      }
    case QA.MAC_ARM:
    case QA.MAC:
      switch (A) {
        case ie.STABLE:
          return VA.join(dQ(), "Chrome");
        case ie.BETA:
          return VA.join(dQ(), "Chrome Beta");
        case ie.DEV:
          return VA.join(dQ(), "Chrome Dev");
        case ie.CANARY:
          return VA.join(dQ(), "Chrome Canary");
      }
    case QA.LINUX_ARM:
    case QA.LINUX:
      switch (A) {
        case ie.STABLE:
          return VA.join(QQ(), "google-chrome");
        case ie.BETA:
          return VA.join(QQ(), "google-chrome-beta");
        case ie.CANARY:
          return VA.join(QQ(), "google-chrome-canary");
        case ie.DEV:
          return VA.join(QQ(), "google-chrome-unstable");
      }
  }
}
function hQ() {
  return process.env.LOCALAPPDATA || VA.join(gr.homedir(), "AppData", "Local");
}
function QQ() {
  return process.env.CHROME_CONFIG_HOME || process.env.XDG_CONFIG_HOME || VA.join(gr.homedir(), "config");
}
function dQ() {
  return VA.join(gr.homedir(), "Library", "Application Support", "Google");
}
function Ew(t, A) {
  if (!hh.valid(t))
    throw new Error(`Version ${t} is not a valid semver version`);
  if (!hh.valid(A))
    throw new Error(`Version ${A} is not a valid semver version`);
  return hh.gt(t, A) ? 1 : hh.lt(t, A) ? -1 : 0;
}
/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
function gf(t) {
  switch (t) {
    case QA.LINUX_ARM:
    case QA.LINUX:
      return "linux64";
    case QA.MAC_ARM:
      return "mac-arm64";
    case QA.MAC:
      return "mac-x64";
    case QA.WIN32:
      return "win32";
    case QA.WIN64:
      return "win64";
  }
}
function $tA(t, A, e = "https://storage.googleapis.com/chrome-for-testing-public") {
  return `${e}/${OK(t, A).join("/")}`;
}
function OK(t, A) {
  return [
    A,
    gf(t),
    `chrome-headless-shell-${gf(t)}.zip`
  ];
}
function ArA(t, A) {
  switch (t) {
    case QA.MAC:
    case QA.MAC_ARM:
      return VA.join("chrome-headless-shell-" + gf(t), "chrome-headless-shell");
    case QA.LINUX_ARM:
    case QA.LINUX:
      return VA.join("chrome-headless-shell-linux64", "chrome-headless-shell");
    case QA.WIN32:
    case QA.WIN64:
      return VA.join("chrome-headless-shell-" + gf(t), "chrome-headless-shell.exe");
  }
}
/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
function uf(t) {
  switch (t) {
    case QA.LINUX_ARM:
    case QA.LINUX:
      return "linux64";
    case QA.MAC_ARM:
      return "mac-arm64";
    case QA.MAC:
      return "mac-x64";
    case QA.WIN32:
      return "win32";
    case QA.WIN64:
      return "win64";
  }
}
function erA(t, A, e = "https://storage.googleapis.com/chrome-for-testing-public") {
  return `${e}/${YK(t, A).join("/")}`;
}
function YK(t, A) {
  return [A, uf(t), `chromedriver-${uf(t)}.zip`];
}
function trA(t, A) {
  switch (t) {
    case QA.MAC:
    case QA.MAC_ARM:
      return VA.join("chromedriver-" + uf(t), "chromedriver");
    case QA.LINUX_ARM:
    case QA.LINUX:
      return VA.join("chromedriver-linux64", "chromedriver");
    case QA.WIN32:
    case QA.WIN64:
      return VA.join("chromedriver-" + uf(t), "chromedriver.exe");
  }
}
/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
function rrA(t, A) {
  switch (t) {
    case QA.LINUX_ARM:
    case QA.LINUX:
      return "chrome-linux";
    case QA.MAC_ARM:
    case QA.MAC:
      return "chrome-mac";
    case QA.WIN32:
    case QA.WIN64:
      return parseInt(A, 10) > 591479 ? "chrome-win" : "chrome-win32";
  }
}
function qK(t) {
  switch (t) {
    case QA.LINUX_ARM:
    case QA.LINUX:
      return "Linux_x64";
    case QA.MAC_ARM:
      return "Mac_Arm";
    case QA.MAC:
      return "Mac";
    case QA.WIN32:
      return "Win";
    case QA.WIN64:
      return "Win_x64";
  }
}
function irA(t, A, e = "https://storage.googleapis.com/chromium-browser-snapshots") {
  return `${e}/${jK(t, A).join("/")}`;
}
function jK(t, A) {
  return [qK(t), A, `${rrA(t, A)}.zip`];
}
function nrA(t, A) {
  switch (t) {
    case QA.MAC:
    case QA.MAC_ARM:
      return VA.join("chrome-mac", "Chromium.app", "Contents", "MacOS", "Chromium");
    case QA.LINUX_ARM:
    case QA.LINUX:
      return VA.join("chrome-linux", "chrome");
    case QA.WIN32:
    case QA.WIN64:
      return VA.join("chrome-win", "chrome.exe");
  }
}
async function srA(t) {
  return await KK(new URL(`https://storage.googleapis.com/chromium-browser-snapshots/${qK(t)}/LAST_CHANGE`));
}
function arA(t, A) {
  return Number(t) - Number(A);
}
/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
function JD(t) {
  return Number(t.split(".").shift()) >= 135 ? "xz" : "bz2";
}
function orA(t, A) {
  switch (t) {
    case QA.LINUX:
      return `firefox-${A}.en-US.linux-x86_64.tar.${JD(A)}`;
    case QA.LINUX_ARM:
      return `firefox-${A}.en-US.linux-aarch64.tar.${JD(A)}`;
    case QA.MAC_ARM:
    case QA.MAC:
      return `firefox-${A}.en-US.mac.dmg`;
    case QA.WIN32:
    case QA.WIN64:
      return `firefox-${A}.en-US.${t}.zip`;
  }
}
function grA(t, A) {
  switch (t) {
    case QA.LINUX_ARM:
    case QA.LINUX:
      return `firefox-${A}.tar.${JD(A)}`;
    case QA.MAC_ARM:
    case QA.MAC:
      return `Firefox ${A}.dmg`;
    case QA.WIN32:
    case QA.WIN64:
      return `Firefox Setup ${A}.exe`;
  }
}
function urA(t) {
  switch (t) {
    case QA.LINUX:
      return "linux-x86_64";
    case QA.LINUX_ARM:
      return "linux-aarch64";
    case QA.MAC_ARM:
    case QA.MAC:
      return "mac";
    case QA.WIN32:
    case QA.WIN64:
      return t;
  }
}
function qS(t) {
  for (const A of Object.values(be))
    if (t.startsWith(A + "_"))
      return t = t.substring(A.length + 1), [A, t];
  return [be.NIGHTLY, t];
}
function crA(t, A, e) {
  const [r] = qS(A);
  switch (r) {
    case be.NIGHTLY:
      e ?? (e = "https://archive.mozilla.org/pub/firefox/nightly/latest-mozilla-central");
      break;
    case be.DEVEDITION:
      e ?? (e = "https://archive.mozilla.org/pub/devedition/releases");
      break;
    case be.BETA:
    case be.STABLE:
    case be.ESR:
      e ?? (e = "https://archive.mozilla.org/pub/firefox/releases");
      break;
  }
  return `${e}/${WK(t, A).join("/")}`;
}
function WK(t, A) {
  const [e, r] = qS(A);
  switch (e) {
    case be.NIGHTLY:
      return [orA(t, r)];
    case be.DEVEDITION:
    case be.BETA:
    case be.STABLE:
    case be.ESR:
      return [
        r,
        urA(t),
        "en-US",
        grA(t, r)
      ];
  }
}
function IrA(t, A) {
  const [e] = qS(A);
  switch (e) {
    case be.NIGHTLY:
      switch (t) {
        case QA.MAC_ARM:
        case QA.MAC:
          return VA.join("Firefox Nightly.app", "Contents", "MacOS", "firefox");
        case QA.LINUX_ARM:
        case QA.LINUX:
          return VA.join("firefox", "firefox");
        case QA.WIN32:
        case QA.WIN64:
          return VA.join("firefox", "firefox.exe");
      }
    case be.BETA:
    case be.DEVEDITION:
    case be.ESR:
    case be.STABLE:
      switch (t) {
        case QA.MAC_ARM:
        case QA.MAC:
          return VA.join("Firefox.app", "Contents", "MacOS", "firefox");
        case QA.LINUX_ARM:
        case QA.LINUX:
          return VA.join("firefox", "firefox");
        case QA.WIN32:
        case QA.WIN64:
          return VA.join("core", "firefox.exe");
      }
  }
}
var be;
(function(t) {
  t.STABLE = "stable", t.ESR = "esr", t.DEVEDITION = "devedition", t.BETA = "beta", t.NIGHTLY = "nightly";
})(be || (be = {}));
let CrA = "https://product-details.mozilla.org/1.0";
async function Tg(t = be.NIGHTLY) {
  const A = {
    [be.ESR]: "FIREFOX_ESR",
    [be.STABLE]: "LATEST_FIREFOX_VERSION",
    [be.DEVEDITION]: "FIREFOX_DEVEDITION",
    [be.BETA]: "FIREFOX_DEVEDITION",
    [be.NIGHTLY]: "FIREFOX_NIGHTLY"
  }, r = (await _p(new URL(`${CrA}/firefox_versions.json`)))[A[t]];
  if (!r)
    throw new Error(`Channel ${t} is not found.`);
  return t + "_" + r;
}
async function lrA(t) {
  Ft.existsSync(t.path) || await Ft.promises.mkdir(t.path, {
    recursive: !0
  }), await ErA({
    preferences: {
      ...BrA(t.preferences),
      ...t.preferences
    },
    path: t.path
  });
}
function BrA(t) {
  const A = "dummy.test", e = {
    // Make sure Shield doesn't hit the network.
    "app.normandy.api_url": "",
    // Disable Firefox old build background check
    "app.update.checkInstallTime": !1,
    // Disable automatically upgrading Firefox
    "app.update.disabledForTesting": !0,
    // Increase the APZ content response timeout to 1 minute
    "apz.content_response_timeout": 6e4,
    // Prevent various error message on the console
    // jest-puppeteer asserts that no error message is emitted by the console
    "browser.contentblocking.features.standard": "-tp,tpPrivate,cookieBehavior0,-cryptoTP,-fp",
    // Enable the dump function: which sends messages to the system
    // console
    // https://bugzilla.mozilla.org/show_bug.cgi?id=1543115
    "browser.dom.window.dump.enabled": !0,
    // Disable topstories
    "browser.newtabpage.activity-stream.feeds.system.topstories": !1,
    // Always display a blank page
    "browser.newtabpage.enabled": !1,
    // Background thumbnails in particular cause grief: and disabling
    // thumbnails in general cannot hurt
    "browser.pagethumbnails.capturing_disabled": !0,
    // Disable safebrowsing components.
    "browser.safebrowsing.blockedURIs.enabled": !1,
    "browser.safebrowsing.downloads.enabled": !1,
    "browser.safebrowsing.malware.enabled": !1,
    "browser.safebrowsing.phishing.enabled": !1,
    // Disable updates to search engines.
    "browser.search.update": !1,
    // Do not restore the last open set of tabs if the browser has crashed
    "browser.sessionstore.resume_from_crash": !1,
    // Skip check for default browser on startup
    "browser.shell.checkDefaultBrowser": !1,
    // Disable newtabpage
    "browser.startup.homepage": "about:blank",
    // Do not redirect user when a milstone upgrade of Firefox is detected
    "browser.startup.homepage_override.mstone": "ignore",
    // Start with a blank page about:blank
    "browser.startup.page": 0,
    // Do not allow background tabs to be zombified on Android: otherwise for
    // tests that open additional tabs: the test harness tab itself might get
    // unloaded
    "browser.tabs.disableBackgroundZombification": !1,
    // Do not warn when closing all other open tabs
    "browser.tabs.warnOnCloseOtherTabs": !1,
    // Do not warn when multiple tabs will be opened
    "browser.tabs.warnOnOpen": !1,
    // Do not automatically offer translations, as tests do not expect this.
    "browser.translations.automaticallyPopup": !1,
    // Disable the UI tour.
    "browser.uitour.enabled": !1,
    // Turn off search suggestions in the location bar so as not to trigger
    // network connections.
    "browser.urlbar.suggest.searches": !1,
    // Disable first run splash page on Windows 10
    "browser.usedOnWindows10.introURL": "",
    // Do not warn on quitting Firefox
    "browser.warnOnQuit": !1,
    // Defensively disable data reporting systems
    "datareporting.healthreport.documentServerURI": `http://${A}/dummy/healthreport/`,
    "datareporting.healthreport.logging.consoleEnabled": !1,
    "datareporting.healthreport.service.enabled": !1,
    "datareporting.healthreport.service.firstRun": !1,
    "datareporting.healthreport.uploadEnabled": !1,
    // Do not show datareporting policy notifications which can interfere with tests
    "datareporting.policy.dataSubmissionEnabled": !1,
    "datareporting.policy.dataSubmissionPolicyBypassNotification": !0,
    // DevTools JSONViewer sometimes fails to load dependencies with its require.js.
    // This doesn't affect Puppeteer but spams console (Bug 1424372)
    "devtools.jsonview.enabled": !1,
    // Disable popup-blocker
    "dom.disable_open_during_load": !1,
    // Enable the support for File object creation in the content process
    // Required for |Page.setFileInputFiles| protocol method.
    "dom.file.createInChild": !0,
    // Disable the ProcessHangMonitor
    "dom.ipc.reportProcessHangs": !1,
    // Disable slow script dialogues
    "dom.max_chrome_script_run_time": 0,
    "dom.max_script_run_time": 0,
    // Only load extensions from the application and user profile
    // AddonManager.SCOPE_PROFILE + AddonManager.SCOPE_APPLICATION
    "extensions.autoDisableScopes": 0,
    "extensions.enabledScopes": 5,
    // Disable metadata caching for installed add-ons by default
    "extensions.getAddons.cache.enabled": !1,
    // Disable installing any distribution extensions or add-ons.
    "extensions.installDistroAddons": !1,
    // Turn off extension updates so they do not bother tests
    "extensions.update.enabled": !1,
    // Turn off extension updates so they do not bother tests
    "extensions.update.notifyUser": !1,
    // Make sure opening about:addons will not hit the network
    "extensions.webservice.discoverURL": `http://${A}/dummy/discoveryURL`,
    // Allow the application to have focus even it runs in the background
    "focusmanager.testmode": !0,
    // Disable useragent updates
    "general.useragent.updates.enabled": !1,
    // Always use network provider for geolocation tests so we bypass the
    // macOS dialog raised by the corelocation provider
    "geo.provider.testing": !0,
    // Do not scan Wifi
    "geo.wifi.scan": !1,
    // No hang monitor
    "hangmonitor.timeout": 0,
    // Show chrome errors and warnings in the error console
    "javascript.options.showInConsole": !0,
    // Disable download and usage of OpenH264: and Widevine plugins
    "media.gmp-manager.updateEnabled": !1,
    // Disable the GFX sanity window
    "media.sanity-test.disabled": !0,
    // Disable experimental feature that is only available in Nightly
    "network.cookie.sameSite.laxByDefault": !1,
    // Do not prompt for temporary redirects
    "network.http.prompt-temp-redirect": !1,
    // Disable speculative connections so they are not reported as leaking
    // when they are hanging around
    "network.http.speculative-parallel-limit": 0,
    // Do not automatically switch between offline and online
    "network.manage-offline-status": !1,
    // Make sure SNTP requests do not hit the network
    "network.sntp.pools": A,
    // Disable Flash.
    "plugin.state.flash": 0,
    "privacy.trackingprotection.enabled": !1,
    // Can be removed once Firefox 89 is no longer supported
    // https://bugzilla.mozilla.org/show_bug.cgi?id=1710839
    "remote.enabled": !0,
    // Disabled screenshots component
    "screenshots.browser.component.enabled": !1,
    // Don't do network connections for mitm priming
    "security.certerrors.mitm.priming.enabled": !1,
    // Local documents have access to all other local documents,
    // including directory listings
    "security.fileuri.strict_origin_policy": !1,
    // Do not wait for the notification button security delay
    "security.notification_enable_delay": 0,
    // Ensure blocklist updates do not hit the network
    "services.settings.server": `http://${A}/dummy/blocklist/`,
    // Do not automatically fill sign-in forms with known usernames and
    // passwords
    "signon.autofillForms": !1,
    // Disable password capture, so that tests that include forms are not
    // influenced by the presence of the persistent doorhanger notification
    "signon.rememberSignons": !1,
    // Disable first-run welcome page
    "startup.homepage_welcome_url": "about:blank",
    // Disable first-run welcome page
    "startup.homepage_welcome_url.additional": "",
    // Disable browser animations (tabs, fullscreen, sliding alerts)
    "toolkit.cosmeticAnimations.enabled": !1,
    // Prevent starting into safe mode after application crashes
    "toolkit.startup.max_resumed_crashes": -1
  };
  return Object.assign(e, t);
}
async function WM(t) {
  Ft.existsSync(t) && await Ft.promises.copyFile(t, t + ".puppeteer");
}
async function ErA(t) {
  const A = VA.join(t.path, "prefs.js"), e = VA.join(t.path, "user.js"), r = Object.entries(t.preferences).map(([n, s]) => `user_pref(${JSON.stringify(n)}, ${JSON.stringify(s)});`), i = await Promise.allSettled([
    WM(e).then(async () => {
      await Ft.promises.writeFile(e, r.join(`
`));
    }),
    WM(A)
  ]);
  for (const n of i)
    if (n.status === "rejected")
      throw n.reason;
}
function hrA(t, A) {
  return parseInt(t.replace(".", ""), 16) - parseInt(A.replace(".", ""), 16);
}
/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
ZA.CHROMEDRIVER + "", ZA.CHROMEHEADLESSSHELL + "", ZA.CHROME + "", ZA.CHROMIUM + "", ZA.FIREFOX + "";
ZA.CHROMEDRIVER + "", ZA.CHROMEHEADLESSSHELL + "", ZA.CHROME + "", ZA.CHROMIUM + "", ZA.FIREFOX + "";
const VK = {
  [ZA.CHROMEDRIVER]: trA,
  [ZA.CHROMEHEADLESSSHELL]: ArA,
  [ZA.CHROME]: OtA,
  [ZA.CHROMIUM]: nrA,
  [ZA.FIREFOX]: IrA
}, QrA = {
  [ZA.CHROMEDRIVER]: Ew,
  [ZA.CHROMEHEADLESSSHELL]: Ew,
  [ZA.CHROME]: Ew,
  [ZA.CHROMIUM]: arA,
  [ZA.FIREFOX]: hrA
};
async function drA(t, A, e) {
  switch (t) {
    case ZA.FIREFOX:
      switch (e) {
        case ae.LATEST:
          return await Tg(be.NIGHTLY);
        case ae.BETA:
          return await Tg(be.BETA);
        case ae.NIGHTLY:
          return await Tg(be.NIGHTLY);
        case ae.DEVEDITION:
          return await Tg(be.DEVEDITION);
        case ae.STABLE:
          return await Tg(be.STABLE);
        case ae.ESR:
          return await Tg(be.ESR);
        case ae.CANARY:
        case ae.DEV:
          throw new Error(`${e.toUpperCase()} is not available for Firefox`);
      }
    case ZA.CHROME:
      switch (e) {
        case ae.LATEST:
          return await Vt(ie.CANARY);
        case ae.BETA:
          return await Vt(ie.BETA);
        case ae.CANARY:
          return await Vt(ie.CANARY);
        case ae.DEV:
          return await Vt(ie.DEV);
        case ae.STABLE:
          return await Vt(ie.STABLE);
        case ae.NIGHTLY:
        case ae.DEVEDITION:
        case ae.ESR:
          throw new Error(`${e.toUpperCase()} is not available for Chrome`);
      }
    case ZA.CHROMEDRIVER:
      switch (e) {
        case ae.LATEST:
        case ae.CANARY:
          return await Vt(ie.CANARY);
        case ae.BETA:
          return await Vt(ie.BETA);
        case ae.DEV:
          return await Vt(ie.DEV);
        case ae.STABLE:
          return await Vt(ie.STABLE);
        case ae.NIGHTLY:
        case ae.DEVEDITION:
        case ae.ESR:
          throw new Error(`${e.toUpperCase()} is not available for ChromeDriver`);
      }
    case ZA.CHROMEHEADLESSSHELL:
      switch (e) {
        case ae.LATEST:
        case ae.CANARY:
          return await Vt(ie.CANARY);
        case ae.BETA:
          return await Vt(ie.BETA);
        case ae.DEV:
          return await Vt(ie.DEV);
        case ae.STABLE:
          return await Vt(ie.STABLE);
        case ae.NIGHTLY:
        case ae.DEVEDITION:
        case ae.ESR:
          throw new Error(`${e} is not available for chrome-headless-shell`);
      }
    case ZA.CHROMIUM:
      switch (e) {
        case ae.LATEST:
          return await srA(A);
        case ae.NIGHTLY:
        case ae.CANARY:
        case ae.DEV:
        case ae.DEVEDITION:
        case ae.BETA:
        case ae.STABLE:
        case ae.ESR:
          throw new Error(`${e} is not supported for Chromium. Use 'latest' instead.`);
      }
  }
}
async function frA(t, A, e) {
  const r = e;
  if (Object.values(ae).includes(r))
    return await drA(t, A, r);
  switch (t) {
    case ZA.FIREFOX:
      return e;
    case ZA.CHROME:
      const i = await Vt(e);
      return i || e;
    case ZA.CHROMEDRIVER:
      const n = await Vt(e);
      return n || e;
    case ZA.CHROMEHEADLESSSHELL:
      const s = await Vt(e);
      return s || e;
    case ZA.CHROMIUM:
      return e;
  }
}
async function prA(t, A) {
  switch (t) {
    case ZA.FIREFOX:
      return await lrA(A);
    case ZA.CHROME:
    case ZA.CHROMIUM:
      throw new Error(`Profile creation is not support for ${t} yet`);
  }
}
function qsA(t, A, e) {
  switch (t) {
    case ZA.CHROMEDRIVER:
    case ZA.CHROMEHEADLESSSHELL:
    case ZA.FIREFOX:
    case ZA.CHROMIUM:
      throw new Error(`Default user dir detection is not supported for ${t} yet.`);
    case ZA.CHROME:
      return ztA(A, e);
  }
}
function yrA(t, A, e) {
  switch (t) {
    case ZA.CHROMEDRIVER:
    case ZA.CHROMEHEADLESSSHELL:
    case ZA.FIREFOX:
    case ZA.CHROMIUM:
      throw new Error(`System browser detection is not supported for ${t} yet.`);
    case ZA.CHROME:
      return XtA(A, e);
  }
}
function wrA(t) {
  return QrA[t];
}
/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
function ZE() {
  const t = gr.platform(), A = gr.arch();
  switch (t) {
    case "darwin":
      return A === "arm64" ? QA.MAC_ARM : QA.MAC;
    case "linux":
      return A === "arm64" ? QA.LINUX_ARM : QA.LINUX;
    case "win32":
      return A === "x64" || // Windows 11 for ARM supports x64 emulation
      A === "arm64" && mrA(gr.release()) ? QA.WIN64 : QA.WIN32;
    default:
      return;
  }
}
function mrA(t) {
  const A = t.split(".");
  if (A.length > 2) {
    const e = parseInt(A[0], 10), r = parseInt(A[1], 10), i = parseInt(A[2], 10);
    return e > 10 || e === 10 && r > 0 || e === 10 && r === 0 && i >= 22e3;
  }
  return !1;
}
/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
const DrA = II("puppeteer:browsers:cache");
var sg;
class SrA {
  /**
   * @internal
   */
  constructor(A, e, r, i) {
    R(this, "browser");
    R(this, "buildId");
    R(this, "platform");
    R(this, "executablePath");
    k(this, sg);
    x(this, sg, A), this.browser = e, this.buildId = r, this.platform = i, this.executablePath = A.computeExecutablePath({
      browser: e,
      buildId: r,
      platform: i
    });
  }
  /**
   * Path to the root of the installation folder. Use
   * {@link computeExecutablePath} to get the path to the executable binary.
   */
  get path() {
    return d(this, sg).installationDir(this.browser, this.platform, this.buildId);
  }
  readMetadata() {
    return d(this, sg).readMetadata(this.browser);
  }
  writeMetadata(A) {
    d(this, sg).writeMetadata(this.browser, A);
  }
}
sg = new WeakMap();
var ns;
class jS {
  constructor(A) {
    k(this, ns);
    x(this, ns, A);
  }
  /**
   * @internal
   */
  get rootDir() {
    return d(this, ns);
  }
  browserRoot(A) {
    return VA.join(d(this, ns), A);
  }
  metadataFile(A) {
    return VA.join(this.browserRoot(A), ".metadata");
  }
  readMetadata(A) {
    const e = this.metadataFile(A);
    if (!Ft.existsSync(e))
      return { aliases: {} };
    const r = JSON.parse(Ft.readFileSync(e, "utf8"));
    if (typeof r != "object")
      throw new Error(".metadata is not an object");
    return r;
  }
  writeMetadata(A, e) {
    const r = this.metadataFile(A);
    Ft.mkdirSync(VA.dirname(r), { recursive: !0 }), Ft.writeFileSync(r, JSON.stringify(e, null, 2));
  }
  resolveAlias(A, e) {
    const r = this.readMetadata(A);
    return e === "latest" ? Object.values(r.aliases || {}).sort(wrA(A)).at(-1) : r.aliases[e];
  }
  installationDir(A, e, r) {
    return VA.join(this.browserRoot(A), `${e}-${r}`);
  }
  clear() {
    Ft.rmSync(d(this, ns), {
      force: !0,
      recursive: !0,
      maxRetries: 10,
      retryDelay: 500
    });
  }
  uninstall(A, e, r) {
    const i = this.readMetadata(A);
    for (const n of Object.keys(i.aliases))
      i.aliases[n] === r && delete i.aliases[n];
    Ft.rmSync(this.installationDir(A, e, r), {
      force: !0,
      recursive: !0,
      maxRetries: 10,
      retryDelay: 500
    });
  }
  getInstalledBrowsers() {
    return Ft.existsSync(d(this, ns)) ? Ft.readdirSync(d(this, ns)).filter((r) => Object.values(ZA).includes(r)).flatMap((r) => Ft.readdirSync(this.browserRoot(r)).map((n) => {
      const s = FrA(VA.join(this.browserRoot(r), n));
      return s ? new SrA(this, r, s.buildId, s.platform) : null;
    }).filter((n) => n !== null)) : [];
  }
  computeExecutablePath(A) {
    if (A.platform ?? (A.platform = ZE()), !A.platform)
      throw new Error(`Cannot download a binary for the provided platform: ${gr.platform()} (${gr.arch()})`);
    try {
      A.buildId = this.resolveAlias(A.browser, A.buildId) ?? A.buildId;
    } catch {
      DrA("could not read .metadata file for the browser");
    }
    const e = this.installationDir(A.browser, A.platform, A.buildId);
    return VA.join(e, VK[A.browser](A.platform, A.buildId));
  }
}
ns = new WeakMap();
function FrA(t) {
  const e = VA.basename(t).split("-");
  if (e.length !== 2)
    return;
  const [r, i] = e;
  if (!(!i || !r))
    return { platform: r, buildId: i };
}
/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
const Za = II("puppeteer:browsers:launcher");
function krA(t) {
  if (t.cacheDir === null) {
    if (t.platform ?? (t.platform = ZE()), t.platform === void 0)
      throw new Error("No platform specified. Couldn't auto-detect browser platform.");
    return VK[t.browser](t.platform, t.buildId);
  }
  return new jS(t.cacheDir).computeExecutablePath(t);
}
function vrA(t) {
  if (t.platform ?? (t.platform = ZE()), !t.platform)
    throw new Error(`Cannot download a binary for the provided platform: ${gr.platform()} (${gr.arch()})`);
  const A = yrA(t.browser, t.platform, t.channel);
  for (const e of A)
    try {
      return KJ(e), e;
    } catch {
    }
  throw new Error(`Could not find Google Chrome executable for channel '${t.channel}' at:${A.map((e) => `
 - ${e}`)}.`);
}
function RrA(t) {
  return new _rA(t);
}
const brA = /^DevTools listening on (ws:\/\/.*)$/, MrA = /^WebDriver BiDi listening on (ws:\/\/.*)$/, Sa = /* @__PURE__ */ new Map(), ZK = {
  exit: (...t) => {
    var A;
    (A = Sa.get("exit")) == null || A.forEach((e) => e(...t));
  },
  SIGINT: (...t) => {
    var A;
    (A = Sa.get("SIGINT")) == null || A.forEach((e) => e(...t));
  },
  SIGHUP: (...t) => {
    var A;
    (A = Sa.get("SIGHUP")) == null || A.forEach((e) => e(...t));
  },
  SIGTERM: (...t) => {
    var A;
    (A = Sa.get("SIGTERM")) == null || A.forEach((e) => e(...t));
  }
};
function fQ(t, A) {
  const e = Sa.get(t) || [];
  e.length === 0 && process.on(t, ZK[t]), e.push(A), Sa.set(t, e);
}
function pQ(t, A) {
  const e = Sa.get(t) || [], r = e.indexOf(A);
  r !== -1 && (e.splice(r, 1), Sa.set(t, e), e.length === 0 && process.off(t, ZK[t]));
}
var Mc, _c, Ue, fE, pE, yE, Nc, fa, kf, Lc, Or, HD, XK, PD, wE, ss, OD;
class _rA {
  constructor(A) {
    k(this, Or);
    k(this, Mc);
    k(this, _c);
    k(this, Ue);
    k(this, fE, !1);
    // The browser process can be closed externally or from the driver process. We
    // need to invoke the hooks only once though but we don't know how many times
    // we will be invoked.
    k(this, pE, !1);
    k(this, yE, async () => {
    });
    k(this, Nc);
    k(this, fa, []);
    k(this, kf, 1e3);
    k(this, Lc, new TJ());
    k(this, wE, (A) => {
      this.kill();
    });
    k(this, ss, (A) => {
      switch (A) {
        case "SIGINT":
          this.kill(), process.exit(130);
        case "SIGTERM":
        case "SIGHUP":
          this.close();
          break;
      }
    });
    var i, n;
    x(this, Mc, A.executablePath), x(this, _c, A.args ?? []), A.pipe ?? (A.pipe = !1), A.dumpio ?? (A.dumpio = !1), A.handleSIGINT ?? (A.handleSIGINT = !0), A.handleSIGTERM ?? (A.handleSIGTERM = !0), A.handleSIGHUP ?? (A.handleSIGHUP = !0), A.detached ?? (A.detached = process.platform !== "win32");
    const e = O(this, Or, XK).call(this, {
      pipe: A.pipe
    }), r = A.env || {};
    Za(`Launching ${d(this, Mc)} ${d(this, _c).join(" ")}`, {
      detached: A.detached,
      env: Object.keys(r).reduce((s, a) => (a.toLowerCase().startsWith("puppeteer_") && (s[a] = r[a]), s), {}),
      stdio: e
    }), x(this, Ue, gF.spawn(d(this, Mc), d(this, _c), {
      detached: A.detached,
      env: r,
      stdio: e
    })), O(this, Or, OD).call(this, d(this, Ue).stderr), O(this, Or, OD).call(this, d(this, Ue).stdout), Za(`Launched ${d(this, Ue).pid}`), A.dumpio && ((i = d(this, Ue).stderr) == null || i.pipe(process.stderr), (n = d(this, Ue).stdout) == null || n.pipe(process.stdout)), fQ("exit", d(this, wE)), A.handleSIGINT && fQ("SIGINT", d(this, ss)), A.handleSIGTERM && fQ("SIGTERM", d(this, ss)), A.handleSIGHUP && fQ("SIGHUP", d(this, ss)), A.onExit && x(this, yE, A.onExit), x(this, Nc, new Promise((s, a) => {
      d(this, Ue).once("exit", async () => {
        Za(`Browser process ${d(this, Ue).pid} onExit`), O(this, Or, PD).call(this), x(this, fE, !0);
        try {
          await O(this, Or, HD).call(this);
        } catch (g) {
          a(g);
          return;
        }
        s();
      });
    }));
  }
  get nodeProcess() {
    return d(this, Ue);
  }
  async close() {
    return await O(this, Or, HD).call(this), d(this, fE) || this.kill(), await d(this, Nc);
  }
  hasClosed() {
    return d(this, Nc);
  }
  kill() {
    if (Za(`Trying to kill ${d(this, Ue).pid}`), d(this, Ue) && d(this, Ue).pid && LrA(d(this, Ue).pid))
      try {
        if (Za(`Browser process ${d(this, Ue).pid} exists`), process.platform === "win32")
          try {
            gF.execSync(`taskkill /pid ${d(this, Ue).pid} /T /F`);
          } catch (A) {
            Za(`Killing ${d(this, Ue).pid} using taskkill failed`, A), d(this, Ue).kill();
          }
        else {
          const A = -d(this, Ue).pid;
          try {
            process.kill(A, "SIGKILL");
          } catch (e) {
            Za(`Killing ${d(this, Ue).pid} using process.kill failed`, e), d(this, Ue).kill("SIGKILL");
          }
        }
      } catch (A) {
        throw new Error(`${NrA}
Error cause: ${zK(A) ? A.stack : A}`);
      }
    O(this, Or, PD).call(this);
  }
  /**
   * Get recent logs (stderr + stdout) emitted by the browser.
   *
   * @public
   */
  getRecentLogs() {
    return [...d(this, fa)];
  }
  waitForLineOutput(A, e = 0) {
    return new Promise((r, i) => {
      const n = (u) => {
        a(), i(new Error([
          `Failed to launch the browser process: ${u instanceof Error ? ` ${u.message}` : ` Code: ${u}`}`,
          "",
          "stderr:",
          this.getRecentLogs().join(`
`),
          "",
          "TROUBLESHOOTING: https://pptr.dev/troubleshooting",
          ""
        ].join(`
`)));
      };
      d(this, Ue).on("exit", n), d(this, Ue).on("error", n);
      const s = e > 0 ? setTimeout(g, e) : void 0;
      d(this, Lc).on("line", o);
      const a = () => {
        clearTimeout(s), d(this, Lc).off("line", o), d(this, Ue).off("exit", n), d(this, Ue).off("error", n);
      };
      function g() {
        a(), i(new $K(`Timed out after ${e} ms while waiting for the WS endpoint URL to appear in stdout!`));
      }
      for (const u of d(this, fa))
        o(u);
      function o(u) {
        const I = u.match(A);
        I && (a(), r(I[1]));
      }
    });
  }
}
Mc = new WeakMap(), _c = new WeakMap(), Ue = new WeakMap(), fE = new WeakMap(), pE = new WeakMap(), yE = new WeakMap(), Nc = new WeakMap(), fa = new WeakMap(), kf = new WeakMap(), Lc = new WeakMap(), Or = new WeakSet(), HD = async function() {
  d(this, pE) || (x(this, pE, !0), await d(this, yE).call(this));
}, XK = function(A) {
  return A.pipe ? ["pipe", "pipe", "pipe", "pipe", "pipe"] : ["pipe", "pipe", "pipe"];
}, PD = function() {
  pQ("exit", d(this, wE)), pQ("SIGINT", d(this, ss)), pQ("SIGTERM", d(this, ss)), pQ("SIGHUP", d(this, ss));
}, wE = new WeakMap(), ss = new WeakMap(), OD = function(A) {
  const e = JJ.createInterface(A), r = () => {
    e.off("line", i), e.off("close", n);
    try {
      e.close();
    } catch {
    }
  }, i = (s) => {
    if (s.trim() === "")
      return;
    d(this, fa).push(s);
    const a = d(this, fa).length - d(this, kf);
    a && d(this, fa).splice(0, a), d(this, Lc).emit("line", s);
  }, n = () => {
    r();
  };
  e.on("line", i), e.on("close", n);
};
const NrA = `Puppeteer was unable to kill the process which ran the browser binary.
This means that, on future Puppeteer launches, Puppeteer might not be able to launch the browser.
Please check your open processes and ensure that the browser processes that Puppeteer launched have been killed.
If you think this is a bug, please report it on the Puppeteer issue tracker.`;
function LrA(t) {
  try {
    return process.kill(t, 0);
  } catch (A) {
    if (xrA(A) && A.code && A.code === "ESRCH")
      return !1;
    throw A;
  }
}
function zK(t) {
  return typeof t == "object" && t !== null && "name" in t && "message" in t;
}
function xrA(t) {
  return zK(t) && ("errno" in t || "code" in t || "path" in t || "syscall" in t);
}
class $K extends Error {
  /**
   * @internal
   */
  constructor(A) {
    super(A), this.name = this.constructor.name, Error.captureStackTrace(this, this.constructor);
  }
}
var GrA = { exports: {} };
/*!
 * node-progress
 * Copyright(c) 2011 TJ Holowaychuk <tj@vision-media.ca>
 * MIT Licensed
 */
(function(t, A) {
  t.exports = e;
  function e(r, i) {
    if (this.stream = i.stream || process.stderr, typeof i == "number") {
      var n = i;
      i = {}, i.total = n;
    } else {
      if (i = i || {}, typeof r != "string") throw new Error("format required");
      if (typeof i.total != "number") throw new Error("total required");
    }
    this.fmt = r, this.curr = i.curr || 0, this.total = i.total, this.width = i.width || this.total, this.clear = i.clear, this.chars = {
      complete: i.complete || "=",
      incomplete: i.incomplete || "-",
      head: i.head || i.complete || "="
    }, this.renderThrottle = i.renderThrottle !== 0 ? i.renderThrottle || 16 : 0, this.lastRender = -1 / 0, this.callback = i.callback || function() {
    }, this.tokens = {}, this.lastDraw = "";
  }
  e.prototype.tick = function(r, i) {
    if (r !== 0 && (r = r || 1), typeof r == "object" && (i = r, r = 1), i && (this.tokens = i), this.curr == 0 && (this.start = /* @__PURE__ */ new Date()), this.curr += r, this.render(), this.curr >= this.total) {
      this.render(void 0, !0), this.complete = !0, this.terminate(), this.callback(this);
      return;
    }
  }, e.prototype.render = function(r, i) {
    if (i = i !== void 0 ? i : !1, r && (this.tokens = r), !!this.stream.isTTY) {
      var n = Date.now(), s = n - this.lastRender;
      if (!(!i && s < this.renderThrottle)) {
        this.lastRender = n;
        var a = this.curr / this.total;
        a = Math.min(Math.max(a, 0), 1);
        var g = Math.floor(a * 100), o, u, I, c = /* @__PURE__ */ new Date() - this.start, C = g == 100 ? 0 : c * (this.total / this.curr - 1), E = this.curr / (c / 1e3), l = this.fmt.replace(":current", this.curr).replace(":total", this.total).replace(":elapsed", isNaN(c) ? "0.0" : (c / 1e3).toFixed(1)).replace(":eta", isNaN(C) || !isFinite(C) ? "0.0" : (C / 1e3).toFixed(1)).replace(":percent", g.toFixed(0) + "%").replace(":rate", Math.round(E)), B = Math.max(0, this.stream.columns - l.replace(":bar", "").length);
        B && process.platform === "win32" && (B = B - 1);
        var h = Math.min(this.width, B);
        if (I = Math.round(h * a), u = Array(Math.max(0, I + 1)).join(this.chars.complete), o = Array(Math.max(0, h - I + 1)).join(this.chars.incomplete), I > 0 && (u = u.slice(0, -1) + this.chars.head), l = l.replace(":bar", u + o), this.tokens) for (var Q in this.tokens) l = l.replace(":" + Q, this.tokens[Q]);
        this.lastDraw !== l && (this.stream.cursorTo(0), this.stream.write(l), this.stream.clearLine(1), this.lastDraw = l);
      }
    }
  }, e.prototype.update = function(r, i) {
    var n = Math.floor(r * this.total), s = n - this.curr;
    this.tick(s, i);
  }, e.prototype.interrupt = function(r) {
    this.stream.clearLine(), this.stream.cursorTo(0), this.stream.write(r), this.stream.write(`
`), this.stream.write(this.lastDraw);
  }, e.prototype.terminate = function() {
    this.clear ? this.stream.clearLine && (this.stream.clearLine(), this.stream.cursorTo(0)) : this.stream.write(`
`);
  };
})(GrA);
/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
II("puppeteer:browsers:fileUtil");
/**
 * @license
 * Copyright 2017 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
II("puppeteer:browsers:install");
async function UrA(t) {
  if (t.platform ?? (t.platform = ZE()), !t.platform)
    throw new Error(`Cannot detect the browser platform for: ${gr.platform()} (${gr.arch()})`);
  new jS(t.cacheDir).uninstall(t.browser, t.platform, t.buildId);
}
async function TrA(t) {
  return new jS(t.cacheDir).getInstalledBrowsers();
}
var cf = { exports: {} };
const AJ = ["nodebuffer", "arraybuffer", "fragments"], eJ = typeof Blob < "u";
eJ && AJ.push("blob");
var Ua = {
  BINARY_TYPES: AJ,
  EMPTY_BUFFER: Buffer.alloc(0),
  GUID: "258EAFA5-E914-47DA-95CA-C5AB0DC85B11",
  hasBlob: eJ,
  kForOnEventAttribute: Symbol("kIsForOnEventAttribute"),
  kListener: Symbol("kListener"),
  kStatusCode: Symbol("status-code"),
  kWebSocket: Symbol("websocket"),
  NOOP: () => {
  }
};
const KrA = {}, JrA = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: KrA
}, Symbol.toStringTag, { value: "Module" })), HrA = /* @__PURE__ */ y0(JrA);
var PrA, OrA;
const { EMPTY_BUFFER: YrA } = Ua, YD = Buffer[Symbol.species];
function qrA(t, A) {
  if (t.length === 0) return YrA;
  if (t.length === 1) return t[0];
  const e = Buffer.allocUnsafe(A);
  let r = 0;
  for (let i = 0; i < t.length; i++) {
    const n = t[i];
    e.set(n, r), r += n.length;
  }
  return r < A ? new YD(e.buffer, e.byteOffset, r) : e;
}
function tJ(t, A, e, r, i) {
  for (let n = 0; n < i; n++)
    e[r + n] = t[n] ^ A[n & 3];
}
function rJ(t, A) {
  for (let e = 0; e < t.length; e++)
    t[e] ^= A[e & 3];
}
function jrA(t) {
  return t.length === t.buffer.byteLength ? t.buffer : t.buffer.slice(t.byteOffset, t.byteOffset + t.length);
}
function qD(t) {
  if (qD.readOnly = !0, Buffer.isBuffer(t)) return t;
  let A;
  return t instanceof ArrayBuffer ? A = new YD(t) : ArrayBuffer.isView(t) ? A = new YD(t.buffer, t.byteOffset, t.byteLength) : (A = Buffer.from(t), qD.readOnly = !1), A;
}
cf.exports = {
  concat: qrA,
  mask: tJ,
  toArrayBuffer: jrA,
  toBuffer: qD,
  unmask: rJ
};
if (!process.env.WS_NO_BUFFER_UTIL)
  try {
    const t = HrA;
    OrA = cf.exports.mask = function(A, e, r, i, n) {
      n < 48 ? tJ(A, e, r, i, n) : t.mask(A, e, r, i, n);
    }, PrA = cf.exports.unmask = function(A, e) {
      A.length < 32 ? rJ(A, e) : t.unmask(A, e);
    };
  } catch {
  }
var Np = cf.exports;
const VM = Symbol("kDone"), hw = Symbol("kRun");
let WrA = class {
  /**
   * Creates a new `Limiter`.
   *
   * @param {Number} [concurrency=Infinity] The maximum number of jobs allowed
   *     to run concurrently
   */
  constructor(A) {
    this[VM] = () => {
      this.pending--, this[hw]();
    }, this.concurrency = A || 1 / 0, this.jobs = [], this.pending = 0;
  }
  /**
   * Adds a job to the queue.
   *
   * @param {Function} job The job to run
   * @public
   */
  add(A) {
    this.jobs.push(A), this[hw]();
  }
  /**
   * Removes a job from the queue and runs it if possible.
   *
   * @private
   */
  [hw]() {
    if (this.pending !== this.concurrency && this.jobs.length) {
      const A = this.jobs.shift();
      this.pending++, A(this[VM]);
    }
  }
};
var VrA = WrA;
const oC = YJ, ZM = Np, ZrA = VrA, { kStatusCode: iJ } = Ua, XrA = Buffer[Symbol.species], zrA = Buffer.from([0, 0, 255, 255]), If = Symbol("permessage-deflate"), On = Symbol("total-length"), iu = Symbol("callback"), Gs = Symbol("buffers"), Iu = Symbol("error");
let yQ, $rA = class {
  /**
   * Creates a PerMessageDeflate instance.
   *
   * @param {Object} [options] Configuration options
   * @param {(Boolean|Number)} [options.clientMaxWindowBits] Advertise support
   *     for, or request, a custom client window size
   * @param {Boolean} [options.clientNoContextTakeover=false] Advertise/
   *     acknowledge disabling of client context takeover
   * @param {Number} [options.concurrencyLimit=10] The number of concurrent
   *     calls to zlib
   * @param {(Boolean|Number)} [options.serverMaxWindowBits] Request/confirm the
   *     use of a custom server window size
   * @param {Boolean} [options.serverNoContextTakeover=false] Request/accept
   *     disabling of server context takeover
   * @param {Number} [options.threshold=1024] Size (in bytes) below which
   *     messages should not be compressed if context takeover is disabled
   * @param {Object} [options.zlibDeflateOptions] Options to pass to zlib on
   *     deflate
   * @param {Object} [options.zlibInflateOptions] Options to pass to zlib on
   *     inflate
   * @param {Boolean} [isServer=false] Create the instance in either server or
   *     client mode
   * @param {Number} [maxPayload=0] The maximum allowed message length
   */
  constructor(A, e, r) {
    if (this._maxPayload = r | 0, this._options = A || {}, this._threshold = this._options.threshold !== void 0 ? this._options.threshold : 1024, this._isServer = !!e, this._deflate = null, this._inflate = null, this.params = null, !yQ) {
      const i = this._options.concurrencyLimit !== void 0 ? this._options.concurrencyLimit : 10;
      yQ = new ZrA(i);
    }
  }
  /**
   * @type {String}
   */
  static get extensionName() {
    return "permessage-deflate";
  }
  /**
   * Create an extension negotiation offer.
   *
   * @return {Object} Extension parameters
   * @public
   */
  offer() {
    const A = {};
    return this._options.serverNoContextTakeover && (A.server_no_context_takeover = !0), this._options.clientNoContextTakeover && (A.client_no_context_takeover = !0), this._options.serverMaxWindowBits && (A.server_max_window_bits = this._options.serverMaxWindowBits), this._options.clientMaxWindowBits ? A.client_max_window_bits = this._options.clientMaxWindowBits : this._options.clientMaxWindowBits == null && (A.client_max_window_bits = !0), A;
  }
  /**
   * Accept an extension negotiation offer/response.
   *
   * @param {Array} configurations The extension negotiation offers/reponse
   * @return {Object} Accepted configuration
   * @public
   */
  accept(A) {
    return A = this.normalizeParams(A), this.params = this._isServer ? this.acceptAsServer(A) : this.acceptAsClient(A), this.params;
  }
  /**
   * Releases all resources used by the extension.
   *
   * @public
   */
  cleanup() {
    if (this._inflate && (this._inflate.close(), this._inflate = null), this._deflate) {
      const A = this._deflate[iu];
      this._deflate.close(), this._deflate = null, A && A(
        new Error(
          "The deflate stream was closed while data was being processed"
        )
      );
    }
  }
  /**
   *  Accept an extension negotiation offer.
   *
   * @param {Array} offers The extension negotiation offers
   * @return {Object} Accepted configuration
   * @private
   */
  acceptAsServer(A) {
    const e = this._options, r = A.find((i) => !(e.serverNoContextTakeover === !1 && i.server_no_context_takeover || i.server_max_window_bits && (e.serverMaxWindowBits === !1 || typeof e.serverMaxWindowBits == "number" && e.serverMaxWindowBits > i.server_max_window_bits) || typeof e.clientMaxWindowBits == "number" && !i.client_max_window_bits));
    if (!r)
      throw new Error("None of the extension offers can be accepted");
    return e.serverNoContextTakeover && (r.server_no_context_takeover = !0), e.clientNoContextTakeover && (r.client_no_context_takeover = !0), typeof e.serverMaxWindowBits == "number" && (r.server_max_window_bits = e.serverMaxWindowBits), typeof e.clientMaxWindowBits == "number" ? r.client_max_window_bits = e.clientMaxWindowBits : (r.client_max_window_bits === !0 || e.clientMaxWindowBits === !1) && delete r.client_max_window_bits, r;
  }
  /**
   * Accept the extension negotiation response.
   *
   * @param {Array} response The extension negotiation response
   * @return {Object} Accepted configuration
   * @private
   */
  acceptAsClient(A) {
    const e = A[0];
    if (this._options.clientNoContextTakeover === !1 && e.client_no_context_takeover)
      throw new Error('Unexpected parameter "client_no_context_takeover"');
    if (!e.client_max_window_bits)
      typeof this._options.clientMaxWindowBits == "number" && (e.client_max_window_bits = this._options.clientMaxWindowBits);
    else if (this._options.clientMaxWindowBits === !1 || typeof this._options.clientMaxWindowBits == "number" && e.client_max_window_bits > this._options.clientMaxWindowBits)
      throw new Error(
        'Unexpected or invalid parameter "client_max_window_bits"'
      );
    return e;
  }
  /**
   * Normalize parameters.
   *
   * @param {Array} configurations The extension negotiation offers/reponse
   * @return {Array} The offers/response with normalized parameters
   * @private
   */
  normalizeParams(A) {
    return A.forEach((e) => {
      Object.keys(e).forEach((r) => {
        let i = e[r];
        if (i.length > 1)
          throw new Error(`Parameter "${r}" must have only a single value`);
        if (i = i[0], r === "client_max_window_bits") {
          if (i !== !0) {
            const n = +i;
            if (!Number.isInteger(n) || n < 8 || n > 15)
              throw new TypeError(
                `Invalid value for parameter "${r}": ${i}`
              );
            i = n;
          } else if (!this._isServer)
            throw new TypeError(
              `Invalid value for parameter "${r}": ${i}`
            );
        } else if (r === "server_max_window_bits") {
          const n = +i;
          if (!Number.isInteger(n) || n < 8 || n > 15)
            throw new TypeError(
              `Invalid value for parameter "${r}": ${i}`
            );
          i = n;
        } else if (r === "client_no_context_takeover" || r === "server_no_context_takeover") {
          if (i !== !0)
            throw new TypeError(
              `Invalid value for parameter "${r}": ${i}`
            );
        } else
          throw new Error(`Unknown parameter "${r}"`);
        e[r] = i;
      });
    }), A;
  }
  /**
   * Decompress data. Concurrency limited.
   *
   * @param {Buffer} data Compressed data
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @public
   */
  decompress(A, e, r) {
    yQ.add((i) => {
      this._decompress(A, e, (n, s) => {
        i(), r(n, s);
      });
    });
  }
  /**
   * Compress data. Concurrency limited.
   *
   * @param {(Buffer|String)} data Data to compress
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @public
   */
  compress(A, e, r) {
    yQ.add((i) => {
      this._compress(A, e, (n, s) => {
        i(), r(n, s);
      });
    });
  }
  /**
   * Decompress data.
   *
   * @param {Buffer} data Compressed data
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @private
   */
  _decompress(A, e, r) {
    const i = this._isServer ? "client" : "server";
    if (!this._inflate) {
      const n = `${i}_max_window_bits`, s = typeof this.params[n] != "number" ? oC.Z_DEFAULT_WINDOWBITS : this.params[n];
      this._inflate = oC.createInflateRaw({
        ...this._options.zlibInflateOptions,
        windowBits: s
      }), this._inflate[If] = this, this._inflate[On] = 0, this._inflate[Gs] = [], this._inflate.on("error", eiA), this._inflate.on("data", nJ);
    }
    this._inflate[iu] = r, this._inflate.write(A), e && this._inflate.write(zrA), this._inflate.flush(() => {
      const n = this._inflate[Iu];
      if (n) {
        this._inflate.close(), this._inflate = null, r(n);
        return;
      }
      const s = ZM.concat(
        this._inflate[Gs],
        this._inflate[On]
      );
      this._inflate._readableState.endEmitted ? (this._inflate.close(), this._inflate = null) : (this._inflate[On] = 0, this._inflate[Gs] = [], e && this.params[`${i}_no_context_takeover`] && this._inflate.reset()), r(null, s);
    });
  }
  /**
   * Compress data.
   *
   * @param {(Buffer|String)} data Data to compress
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @private
   */
  _compress(A, e, r) {
    const i = this._isServer ? "server" : "client";
    if (!this._deflate) {
      const n = `${i}_max_window_bits`, s = typeof this.params[n] != "number" ? oC.Z_DEFAULT_WINDOWBITS : this.params[n];
      this._deflate = oC.createDeflateRaw({
        ...this._options.zlibDeflateOptions,
        windowBits: s
      }), this._deflate[On] = 0, this._deflate[Gs] = [], this._deflate.on("data", AiA);
    }
    this._deflate[iu] = r, this._deflate.write(A), this._deflate.flush(oC.Z_SYNC_FLUSH, () => {
      if (!this._deflate)
        return;
      let n = ZM.concat(
        this._deflate[Gs],
        this._deflate[On]
      );
      e && (n = new XrA(n.buffer, n.byteOffset, n.length - 4)), this._deflate[iu] = null, this._deflate[On] = 0, this._deflate[Gs] = [], e && this.params[`${i}_no_context_takeover`] && this._deflate.reset(), r(null, n);
    });
  }
};
var WS = $rA;
function AiA(t) {
  this[Gs].push(t), this[On] += t.length;
}
function nJ(t) {
  if (this[On] += t.length, this[If]._maxPayload < 1 || this[On] <= this[If]._maxPayload) {
    this[Gs].push(t);
    return;
  }
  this[Iu] = new RangeError("Max payload size exceeded"), this[Iu].code = "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH", this[Iu][iJ] = 1009, this.removeListener("data", nJ), this.reset();
}
function eiA(t) {
  if (this[If]._inflate = null, this[Iu]) {
    this[iu](this[Iu]);
    return;
  }
  t[iJ] = 1007, this[iu](t);
}
var Cf = { exports: {} };
const tiA = {}, riA = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: tiA
}, Symbol.toStringTag, { value: "Module" })), iiA = /* @__PURE__ */ y0(riA);
var XM;
const { isUtf8: zM } = b_, { hasBlob: niA } = Ua, siA = [
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  // 0 - 15
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  // 16 - 31
  0,
  1,
  0,
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  1,
  1,
  0,
  1,
  1,
  0,
  // 32 - 47
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  // 48 - 63
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  // 64 - 79
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  0,
  1,
  1,
  // 80 - 95
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  // 96 - 111
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  1,
  0,
  1,
  0
  // 112 - 127
];
function aiA(t) {
  return t >= 1e3 && t <= 1014 && t !== 1004 && t !== 1005 && t !== 1006 || t >= 3e3 && t <= 4999;
}
function jD(t) {
  const A = t.length;
  let e = 0;
  for (; e < A; )
    if (!(t[e] & 128))
      e++;
    else if ((t[e] & 224) === 192) {
      if (e + 1 === A || (t[e + 1] & 192) !== 128 || (t[e] & 254) === 192)
        return !1;
      e += 2;
    } else if ((t[e] & 240) === 224) {
      if (e + 2 >= A || (t[e + 1] & 192) !== 128 || (t[e + 2] & 192) !== 128 || t[e] === 224 && (t[e + 1] & 224) === 128 || // Overlong
      t[e] === 237 && (t[e + 1] & 224) === 160)
        return !1;
      e += 3;
    } else if ((t[e] & 248) === 240) {
      if (e + 3 >= A || (t[e + 1] & 192) !== 128 || (t[e + 2] & 192) !== 128 || (t[e + 3] & 192) !== 128 || t[e] === 240 && (t[e + 1] & 240) === 128 || // Overlong
      t[e] === 244 && t[e + 1] > 143 || t[e] > 244)
        return !1;
      e += 4;
    } else
      return !1;
  return !0;
}
function oiA(t) {
  return niA && typeof t == "object" && typeof t.arrayBuffer == "function" && typeof t.type == "string" && typeof t.stream == "function" && (t[Symbol.toStringTag] === "Blob" || t[Symbol.toStringTag] === "File");
}
Cf.exports = {
  isBlob: oiA,
  isValidStatusCode: aiA,
  isValidUTF8: jD,
  tokenChars: siA
};
if (zM)
  XM = Cf.exports.isValidUTF8 = function(t) {
    return t.length < 24 ? jD(t) : zM(t);
  };
else if (!process.env.WS_NO_UTF_8_VALIDATE)
  try {
    const t = iiA;
    XM = Cf.exports.isValidUTF8 = function(A) {
      return A.length < 32 ? jD(A) : t(A);
    };
  } catch {
  }
var XE = Cf.exports;
const { Writable: giA } = Fn, $M = WS, {
  BINARY_TYPES: uiA,
  EMPTY_BUFFER: A_,
  kStatusCode: ciA,
  kWebSocket: IiA
} = Ua, { concat: Qw, toArrayBuffer: CiA, unmask: liA } = Np, { isValidStatusCode: BiA, isValidUTF8: e_ } = XE, wQ = Buffer[Symbol.species], Yr = 0, t_ = 1, r_ = 2, i_ = 3, dw = 4, fw = 5, mQ = 6;
let EiA = class extends giA {
  /**
   * Creates a Receiver instance.
   *
   * @param {Object} [options] Options object
   * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether
   *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
   *     multiple times in the same tick
   * @param {String} [options.binaryType=nodebuffer] The type for binary data
   * @param {Object} [options.extensions] An object containing the negotiated
   *     extensions
   * @param {Boolean} [options.isServer=false] Specifies whether to operate in
   *     client or server mode
   * @param {Number} [options.maxPayload=0] The maximum allowed message length
   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
   *     not to skip UTF-8 validation for text and close messages
   */
  constructor(A = {}) {
    super(), this._allowSynchronousEvents = A.allowSynchronousEvents !== void 0 ? A.allowSynchronousEvents : !0, this._binaryType = A.binaryType || uiA[0], this._extensions = A.extensions || {}, this._isServer = !!A.isServer, this._maxPayload = A.maxPayload | 0, this._skipUTF8Validation = !!A.skipUTF8Validation, this[IiA] = void 0, this._bufferedBytes = 0, this._buffers = [], this._compressed = !1, this._payloadLength = 0, this._mask = void 0, this._fragmented = 0, this._masked = !1, this._fin = !1, this._opcode = 0, this._totalPayloadLength = 0, this._messageLength = 0, this._fragments = [], this._errored = !1, this._loop = !1, this._state = Yr;
  }
  /**
   * Implements `Writable.prototype._write()`.
   *
   * @param {Buffer} chunk The chunk of data to write
   * @param {String} encoding The character encoding of `chunk`
   * @param {Function} cb Callback
   * @private
   */
  _write(A, e, r) {
    if (this._opcode === 8 && this._state == Yr) return r();
    this._bufferedBytes += A.length, this._buffers.push(A), this.startLoop(r);
  }
  /**
   * Consumes `n` bytes from the buffered data.
   *
   * @param {Number} n The number of bytes to consume
   * @return {Buffer} The consumed bytes
   * @private
   */
  consume(A) {
    if (this._bufferedBytes -= A, A === this._buffers[0].length) return this._buffers.shift();
    if (A < this._buffers[0].length) {
      const r = this._buffers[0];
      return this._buffers[0] = new wQ(
        r.buffer,
        r.byteOffset + A,
        r.length - A
      ), new wQ(r.buffer, r.byteOffset, A);
    }
    const e = Buffer.allocUnsafe(A);
    do {
      const r = this._buffers[0], i = e.length - A;
      A >= r.length ? e.set(this._buffers.shift(), i) : (e.set(new Uint8Array(r.buffer, r.byteOffset, A), i), this._buffers[0] = new wQ(
        r.buffer,
        r.byteOffset + A,
        r.length - A
      )), A -= r.length;
    } while (A > 0);
    return e;
  }
  /**
   * Starts the parsing loop.
   *
   * @param {Function} cb Callback
   * @private
   */
  startLoop(A) {
    this._loop = !0;
    do
      switch (this._state) {
        case Yr:
          this.getInfo(A);
          break;
        case t_:
          this.getPayloadLength16(A);
          break;
        case r_:
          this.getPayloadLength64(A);
          break;
        case i_:
          this.getMask();
          break;
        case dw:
          this.getData(A);
          break;
        case fw:
        case mQ:
          this._loop = !1;
          return;
      }
    while (this._loop);
    this._errored || A();
  }
  /**
   * Reads the first two bytes of a frame.
   *
   * @param {Function} cb Callback
   * @private
   */
  getInfo(A) {
    if (this._bufferedBytes < 2) {
      this._loop = !1;
      return;
    }
    const e = this.consume(2);
    if (e[0] & 48) {
      const i = this.createError(
        RangeError,
        "RSV2 and RSV3 must be clear",
        !0,
        1002,
        "WS_ERR_UNEXPECTED_RSV_2_3"
      );
      A(i);
      return;
    }
    const r = (e[0] & 64) === 64;
    if (r && !this._extensions[$M.extensionName]) {
      const i = this.createError(
        RangeError,
        "RSV1 must be clear",
        !0,
        1002,
        "WS_ERR_UNEXPECTED_RSV_1"
      );
      A(i);
      return;
    }
    if (this._fin = (e[0] & 128) === 128, this._opcode = e[0] & 15, this._payloadLength = e[1] & 127, this._opcode === 0) {
      if (r) {
        const i = this.createError(
          RangeError,
          "RSV1 must be clear",
          !0,
          1002,
          "WS_ERR_UNEXPECTED_RSV_1"
        );
        A(i);
        return;
      }
      if (!this._fragmented) {
        const i = this.createError(
          RangeError,
          "invalid opcode 0",
          !0,
          1002,
          "WS_ERR_INVALID_OPCODE"
        );
        A(i);
        return;
      }
      this._opcode = this._fragmented;
    } else if (this._opcode === 1 || this._opcode === 2) {
      if (this._fragmented) {
        const i = this.createError(
          RangeError,
          `invalid opcode ${this._opcode}`,
          !0,
          1002,
          "WS_ERR_INVALID_OPCODE"
        );
        A(i);
        return;
      }
      this._compressed = r;
    } else if (this._opcode > 7 && this._opcode < 11) {
      if (!this._fin) {
        const i = this.createError(
          RangeError,
          "FIN must be set",
          !0,
          1002,
          "WS_ERR_EXPECTED_FIN"
        );
        A(i);
        return;
      }
      if (r) {
        const i = this.createError(
          RangeError,
          "RSV1 must be clear",
          !0,
          1002,
          "WS_ERR_UNEXPECTED_RSV_1"
        );
        A(i);
        return;
      }
      if (this._payloadLength > 125 || this._opcode === 8 && this._payloadLength === 1) {
        const i = this.createError(
          RangeError,
          `invalid payload length ${this._payloadLength}`,
          !0,
          1002,
          "WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH"
        );
        A(i);
        return;
      }
    } else {
      const i = this.createError(
        RangeError,
        `invalid opcode ${this._opcode}`,
        !0,
        1002,
        "WS_ERR_INVALID_OPCODE"
      );
      A(i);
      return;
    }
    if (!this._fin && !this._fragmented && (this._fragmented = this._opcode), this._masked = (e[1] & 128) === 128, this._isServer) {
      if (!this._masked) {
        const i = this.createError(
          RangeError,
          "MASK must be set",
          !0,
          1002,
          "WS_ERR_EXPECTED_MASK"
        );
        A(i);
        return;
      }
    } else if (this._masked) {
      const i = this.createError(
        RangeError,
        "MASK must be clear",
        !0,
        1002,
        "WS_ERR_UNEXPECTED_MASK"
      );
      A(i);
      return;
    }
    this._payloadLength === 126 ? this._state = t_ : this._payloadLength === 127 ? this._state = r_ : this.haveLength(A);
  }
  /**
   * Gets extended payload length (7+16).
   *
   * @param {Function} cb Callback
   * @private
   */
  getPayloadLength16(A) {
    if (this._bufferedBytes < 2) {
      this._loop = !1;
      return;
    }
    this._payloadLength = this.consume(2).readUInt16BE(0), this.haveLength(A);
  }
  /**
   * Gets extended payload length (7+64).
   *
   * @param {Function} cb Callback
   * @private
   */
  getPayloadLength64(A) {
    if (this._bufferedBytes < 8) {
      this._loop = !1;
      return;
    }
    const e = this.consume(8), r = e.readUInt32BE(0);
    if (r > Math.pow(2, 21) - 1) {
      const i = this.createError(
        RangeError,
        "Unsupported WebSocket frame: payload length > 2^53 - 1",
        !1,
        1009,
        "WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH"
      );
      A(i);
      return;
    }
    this._payloadLength = r * Math.pow(2, 32) + e.readUInt32BE(4), this.haveLength(A);
  }
  /**
   * Payload length has been read.
   *
   * @param {Function} cb Callback
   * @private
   */
  haveLength(A) {
    if (this._payloadLength && this._opcode < 8 && (this._totalPayloadLength += this._payloadLength, this._totalPayloadLength > this._maxPayload && this._maxPayload > 0)) {
      const e = this.createError(
        RangeError,
        "Max payload size exceeded",
        !1,
        1009,
        "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH"
      );
      A(e);
      return;
    }
    this._masked ? this._state = i_ : this._state = dw;
  }
  /**
   * Reads mask bytes.
   *
   * @private
   */
  getMask() {
    if (this._bufferedBytes < 4) {
      this._loop = !1;
      return;
    }
    this._mask = this.consume(4), this._state = dw;
  }
  /**
   * Reads data bytes.
   *
   * @param {Function} cb Callback
   * @private
   */
  getData(A) {
    let e = A_;
    if (this._payloadLength) {
      if (this._bufferedBytes < this._payloadLength) {
        this._loop = !1;
        return;
      }
      e = this.consume(this._payloadLength), this._masked && this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3] && liA(e, this._mask);
    }
    if (this._opcode > 7) {
      this.controlMessage(e, A);
      return;
    }
    if (this._compressed) {
      this._state = fw, this.decompress(e, A);
      return;
    }
    e.length && (this._messageLength = this._totalPayloadLength, this._fragments.push(e)), this.dataMessage(A);
  }
  /**
   * Decompresses data.
   *
   * @param {Buffer} data Compressed data
   * @param {Function} cb Callback
   * @private
   */
  decompress(A, e) {
    this._extensions[$M.extensionName].decompress(A, this._fin, (i, n) => {
      if (i) return e(i);
      if (n.length) {
        if (this._messageLength += n.length, this._messageLength > this._maxPayload && this._maxPayload > 0) {
          const s = this.createError(
            RangeError,
            "Max payload size exceeded",
            !1,
            1009,
            "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH"
          );
          e(s);
          return;
        }
        this._fragments.push(n);
      }
      this.dataMessage(e), this._state === Yr && this.startLoop(e);
    });
  }
  /**
   * Handles a data message.
   *
   * @param {Function} cb Callback
   * @private
   */
  dataMessage(A) {
    if (!this._fin) {
      this._state = Yr;
      return;
    }
    const e = this._messageLength, r = this._fragments;
    if (this._totalPayloadLength = 0, this._messageLength = 0, this._fragmented = 0, this._fragments = [], this._opcode === 2) {
      let i;
      this._binaryType === "nodebuffer" ? i = Qw(r, e) : this._binaryType === "arraybuffer" ? i = CiA(Qw(r, e)) : this._binaryType === "blob" ? i = new Blob(r) : i = r, this._allowSynchronousEvents ? (this.emit("message", i, !0), this._state = Yr) : (this._state = mQ, setImmediate(() => {
        this.emit("message", i, !0), this._state = Yr, this.startLoop(A);
      }));
    } else {
      const i = Qw(r, e);
      if (!this._skipUTF8Validation && !e_(i)) {
        const n = this.createError(
          Error,
          "invalid UTF-8 sequence",
          !0,
          1007,
          "WS_ERR_INVALID_UTF8"
        );
        A(n);
        return;
      }
      this._state === fw || this._allowSynchronousEvents ? (this.emit("message", i, !1), this._state = Yr) : (this._state = mQ, setImmediate(() => {
        this.emit("message", i, !1), this._state = Yr, this.startLoop(A);
      }));
    }
  }
  /**
   * Handles a control message.
   *
   * @param {Buffer} data Data to handle
   * @return {(Error|RangeError|undefined)} A possible error
   * @private
   */
  controlMessage(A, e) {
    if (this._opcode === 8) {
      if (A.length === 0)
        this._loop = !1, this.emit("conclude", 1005, A_), this.end();
      else {
        const r = A.readUInt16BE(0);
        if (!BiA(r)) {
          const n = this.createError(
            RangeError,
            `invalid status code ${r}`,
            !0,
            1002,
            "WS_ERR_INVALID_CLOSE_CODE"
          );
          e(n);
          return;
        }
        const i = new wQ(
          A.buffer,
          A.byteOffset + 2,
          A.length - 2
        );
        if (!this._skipUTF8Validation && !e_(i)) {
          const n = this.createError(
            Error,
            "invalid UTF-8 sequence",
            !0,
            1007,
            "WS_ERR_INVALID_UTF8"
          );
          e(n);
          return;
        }
        this._loop = !1, this.emit("conclude", r, i), this.end();
      }
      this._state = Yr;
      return;
    }
    this._allowSynchronousEvents ? (this.emit(this._opcode === 9 ? "ping" : "pong", A), this._state = Yr) : (this._state = mQ, setImmediate(() => {
      this.emit(this._opcode === 9 ? "ping" : "pong", A), this._state = Yr, this.startLoop(e);
    }));
  }
  /**
   * Builds an error object.
   *
   * @param {function(new:Error|RangeError)} ErrorCtor The error constructor
   * @param {String} message The error message
   * @param {Boolean} prefix Specifies whether or not to add a default prefix to
   *     `message`
   * @param {Number} statusCode The status code
   * @param {String} errorCode The exposed error code
   * @return {(Error|RangeError)} The error
   * @private
   */
  createError(A, e, r, i, n) {
    this._loop = !1, this._errored = !0;
    const s = new A(
      r ? `Invalid WebSocket frame: ${e}` : e
    );
    return Error.captureStackTrace(s, this.createError), s.code = n, s[ciA] = i, s;
  }
};
var hiA = EiA;
const { Duplex: ZsA } = Fn, { randomFillSync: QiA } = un, n_ = WS, { EMPTY_BUFFER: diA, kWebSocket: fiA, NOOP: piA } = Ua, { isBlob: Kg, isValidStatusCode: yiA } = XE, { mask: s_, toBuffer: Xa } = Np, qr = Symbol("kByteLength"), wiA = Buffer.alloc(4), sd = 8 * 1024;
let za, Jg = sd;
const li = 0, miA = 1, DiA = 2;
let SiA = class so {
  /**
   * Creates a Sender instance.
   *
   * @param {Duplex} socket The connection socket
   * @param {Object} [extensions] An object containing the negotiated extensions
   * @param {Function} [generateMask] The function used to generate the masking
   *     key
   */
  constructor(A, e, r) {
    this._extensions = e || {}, r && (this._generateMask = r, this._maskBuffer = Buffer.alloc(4)), this._socket = A, this._firstFragment = !0, this._compress = !1, this._bufferedBytes = 0, this._queue = [], this._state = li, this.onerror = piA, this[fiA] = void 0;
  }
  /**
   * Frames a piece of data according to the HyBi WebSocket protocol.
   *
   * @param {(Buffer|String)} data The data to frame
   * @param {Object} options Options object
   * @param {Boolean} [options.fin=false] Specifies whether or not to set the
   *     FIN bit
   * @param {Function} [options.generateMask] The function used to generate the
   *     masking key
   * @param {Boolean} [options.mask=false] Specifies whether or not to mask
   *     `data`
   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
   *     key
   * @param {Number} options.opcode The opcode
   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
   *     modified
   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
   *     RSV1 bit
   * @return {(Buffer|String)[]} The framed data
   * @public
   */
  static frame(A, e) {
    let r, i = !1, n = 2, s = !1;
    e.mask && (r = e.maskBuffer || wiA, e.generateMask ? e.generateMask(r) : (Jg === sd && (za === void 0 && (za = Buffer.alloc(sd)), QiA(za, 0, sd), Jg = 0), r[0] = za[Jg++], r[1] = za[Jg++], r[2] = za[Jg++], r[3] = za[Jg++]), s = (r[0] | r[1] | r[2] | r[3]) === 0, n = 6);
    let a;
    typeof A == "string" ? (!e.mask || s) && e[qr] !== void 0 ? a = e[qr] : (A = Buffer.from(A), a = A.length) : (a = A.length, i = e.mask && e.readOnly && !s);
    let g = a;
    a >= 65536 ? (n += 8, g = 127) : a > 125 && (n += 2, g = 126);
    const o = Buffer.allocUnsafe(i ? a + n : n);
    return o[0] = e.fin ? e.opcode | 128 : e.opcode, e.rsv1 && (o[0] |= 64), o[1] = g, g === 126 ? o.writeUInt16BE(a, 2) : g === 127 && (o[2] = o[3] = 0, o.writeUIntBE(a, 4, 6)), e.mask ? (o[1] |= 128, o[n - 4] = r[0], o[n - 3] = r[1], o[n - 2] = r[2], o[n - 1] = r[3], s ? [o, A] : i ? (s_(A, r, o, n, a), [o]) : (s_(A, r, A, 0, a), [o, A])) : [o, A];
  }
  /**
   * Sends a close message to the other peer.
   *
   * @param {Number} [code] The status code component of the body
   * @param {(String|Buffer)} [data] The message component of the body
   * @param {Boolean} [mask=false] Specifies whether or not to mask the message
   * @param {Function} [cb] Callback
   * @public
   */
  close(A, e, r, i) {
    let n;
    if (A === void 0)
      n = diA;
    else {
      if (typeof A != "number" || !yiA(A))
        throw new TypeError("First argument must be a valid error code number");
      if (e === void 0 || !e.length)
        n = Buffer.allocUnsafe(2), n.writeUInt16BE(A, 0);
      else {
        const a = Buffer.byteLength(e);
        if (a > 123)
          throw new RangeError("The message must not be greater than 123 bytes");
        n = Buffer.allocUnsafe(2 + a), n.writeUInt16BE(A, 0), typeof e == "string" ? n.write(e, 2) : n.set(e, 2);
      }
    }
    const s = {
      [qr]: n.length,
      fin: !0,
      generateMask: this._generateMask,
      mask: r,
      maskBuffer: this._maskBuffer,
      opcode: 8,
      readOnly: !1,
      rsv1: !1
    };
    this._state !== li ? this.enqueue([this.dispatch, n, !1, s, i]) : this.sendFrame(so.frame(n, s), i);
  }
  /**
   * Sends a ping message to the other peer.
   *
   * @param {*} data The message to send
   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
   * @param {Function} [cb] Callback
   * @public
   */
  ping(A, e, r) {
    let i, n;
    if (typeof A == "string" ? (i = Buffer.byteLength(A), n = !1) : Kg(A) ? (i = A.size, n = !1) : (A = Xa(A), i = A.length, n = Xa.readOnly), i > 125)
      throw new RangeError("The data size must not be greater than 125 bytes");
    const s = {
      [qr]: i,
      fin: !0,
      generateMask: this._generateMask,
      mask: e,
      maskBuffer: this._maskBuffer,
      opcode: 9,
      readOnly: n,
      rsv1: !1
    };
    Kg(A) ? this._state !== li ? this.enqueue([this.getBlobData, A, !1, s, r]) : this.getBlobData(A, !1, s, r) : this._state !== li ? this.enqueue([this.dispatch, A, !1, s, r]) : this.sendFrame(so.frame(A, s), r);
  }
  /**
   * Sends a pong message to the other peer.
   *
   * @param {*} data The message to send
   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
   * @param {Function} [cb] Callback
   * @public
   */
  pong(A, e, r) {
    let i, n;
    if (typeof A == "string" ? (i = Buffer.byteLength(A), n = !1) : Kg(A) ? (i = A.size, n = !1) : (A = Xa(A), i = A.length, n = Xa.readOnly), i > 125)
      throw new RangeError("The data size must not be greater than 125 bytes");
    const s = {
      [qr]: i,
      fin: !0,
      generateMask: this._generateMask,
      mask: e,
      maskBuffer: this._maskBuffer,
      opcode: 10,
      readOnly: n,
      rsv1: !1
    };
    Kg(A) ? this._state !== li ? this.enqueue([this.getBlobData, A, !1, s, r]) : this.getBlobData(A, !1, s, r) : this._state !== li ? this.enqueue([this.dispatch, A, !1, s, r]) : this.sendFrame(so.frame(A, s), r);
  }
  /**
   * Sends a data message to the other peer.
   *
   * @param {*} data The message to send
   * @param {Object} options Options object
   * @param {Boolean} [options.binary=false] Specifies whether `data` is binary
   *     or text
   * @param {Boolean} [options.compress=false] Specifies whether or not to
   *     compress `data`
   * @param {Boolean} [options.fin=false] Specifies whether the fragment is the
   *     last one
   * @param {Boolean} [options.mask=false] Specifies whether or not to mask
   *     `data`
   * @param {Function} [cb] Callback
   * @public
   */
  send(A, e, r) {
    const i = this._extensions[n_.extensionName];
    let n = e.binary ? 2 : 1, s = e.compress, a, g;
    typeof A == "string" ? (a = Buffer.byteLength(A), g = !1) : Kg(A) ? (a = A.size, g = !1) : (A = Xa(A), a = A.length, g = Xa.readOnly), this._firstFragment ? (this._firstFragment = !1, s && i && i.params[i._isServer ? "server_no_context_takeover" : "client_no_context_takeover"] && (s = a >= i._threshold), this._compress = s) : (s = !1, n = 0), e.fin && (this._firstFragment = !0);
    const o = {
      [qr]: a,
      fin: e.fin,
      generateMask: this._generateMask,
      mask: e.mask,
      maskBuffer: this._maskBuffer,
      opcode: n,
      readOnly: g,
      rsv1: s
    };
    Kg(A) ? this._state !== li ? this.enqueue([this.getBlobData, A, this._compress, o, r]) : this.getBlobData(A, this._compress, o, r) : this._state !== li ? this.enqueue([this.dispatch, A, this._compress, o, r]) : this.dispatch(A, this._compress, o, r);
  }
  /**
   * Gets the contents of a blob as binary data.
   *
   * @param {Blob} blob The blob
   * @param {Boolean} [compress=false] Specifies whether or not to compress
   *     the data
   * @param {Object} options Options object
   * @param {Boolean} [options.fin=false] Specifies whether or not to set the
   *     FIN bit
   * @param {Function} [options.generateMask] The function used to generate the
   *     masking key
   * @param {Boolean} [options.mask=false] Specifies whether or not to mask
   *     `data`
   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
   *     key
   * @param {Number} options.opcode The opcode
   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
   *     modified
   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
   *     RSV1 bit
   * @param {Function} [cb] Callback
   * @private
   */
  getBlobData(A, e, r, i) {
    this._bufferedBytes += r[qr], this._state = DiA, A.arrayBuffer().then((n) => {
      if (this._socket.destroyed) {
        const a = new Error(
          "The socket was closed while the blob was being read"
        );
        process.nextTick(WD, this, a, i);
        return;
      }
      this._bufferedBytes -= r[qr];
      const s = Xa(n);
      e ? this.dispatch(s, e, r, i) : (this._state = li, this.sendFrame(so.frame(s, r), i), this.dequeue());
    }).catch((n) => {
      process.nextTick(kiA, this, n, i);
    });
  }
  /**
   * Dispatches a message.
   *
   * @param {(Buffer|String)} data The message to send
   * @param {Boolean} [compress=false] Specifies whether or not to compress
   *     `data`
   * @param {Object} options Options object
   * @param {Boolean} [options.fin=false] Specifies whether or not to set the
   *     FIN bit
   * @param {Function} [options.generateMask] The function used to generate the
   *     masking key
   * @param {Boolean} [options.mask=false] Specifies whether or not to mask
   *     `data`
   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
   *     key
   * @param {Number} options.opcode The opcode
   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
   *     modified
   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
   *     RSV1 bit
   * @param {Function} [cb] Callback
   * @private
   */
  dispatch(A, e, r, i) {
    if (!e) {
      this.sendFrame(so.frame(A, r), i);
      return;
    }
    const n = this._extensions[n_.extensionName];
    this._bufferedBytes += r[qr], this._state = miA, n.compress(A, r.fin, (s, a) => {
      if (this._socket.destroyed) {
        const g = new Error(
          "The socket was closed while data was being compressed"
        );
        WD(this, g, i);
        return;
      }
      this._bufferedBytes -= r[qr], this._state = li, r.readOnly = !1, this.sendFrame(so.frame(a, r), i), this.dequeue();
    });
  }
  /**
   * Executes queued send operations.
   *
   * @private
   */
  dequeue() {
    for (; this._state === li && this._queue.length; ) {
      const A = this._queue.shift();
      this._bufferedBytes -= A[3][qr], Reflect.apply(A[0], this, A.slice(1));
    }
  }
  /**
   * Enqueues a send operation.
   *
   * @param {Array} params Send operation parameters.
   * @private
   */
  enqueue(A) {
    this._bufferedBytes += A[3][qr], this._queue.push(A);
  }
  /**
   * Sends a frame.
   *
   * @param {(Buffer | String)[]} list The frame to send
   * @param {Function} [cb] Callback
   * @private
   */
  sendFrame(A, e) {
    A.length === 2 ? (this._socket.cork(), this._socket.write(A[0]), this._socket.write(A[1], e), this._socket.uncork()) : this._socket.write(A[0], e);
  }
};
var FiA = SiA;
function WD(t, A, e) {
  typeof e == "function" && e(A);
  for (let r = 0; r < t._queue.length; r++) {
    const i = t._queue[r], n = i[i.length - 1];
    typeof n == "function" && n(A);
  }
}
function kiA(t, A, e) {
  WD(t, A, e), t.onerror(A);
}
const { kForOnEventAttribute: gC, kListener: pw } = Ua, a_ = Symbol("kCode"), o_ = Symbol("kData"), g_ = Symbol("kError"), u_ = Symbol("kMessage"), c_ = Symbol("kReason"), nu = Symbol("kTarget"), I_ = Symbol("kType"), C_ = Symbol("kWasClean");
let lI = class {
  /**
   * Create a new `Event`.
   *
   * @param {String} type The name of the event
   * @throws {TypeError} If the `type` argument is not specified
   */
  constructor(A) {
    this[nu] = null, this[I_] = A;
  }
  /**
   * @type {*}
   */
  get target() {
    return this[nu];
  }
  /**
   * @type {String}
   */
  get type() {
    return this[I_];
  }
};
Object.defineProperty(lI.prototype, "target", { enumerable: !0 });
Object.defineProperty(lI.prototype, "type", { enumerable: !0 });
class Lp extends lI {
  /**
   * Create a new `CloseEvent`.
   *
   * @param {String} type The name of the event
   * @param {Object} [options] A dictionary object that allows for setting
   *     attributes via object members of the same name
   * @param {Number} [options.code=0] The status code explaining why the
   *     connection was closed
   * @param {String} [options.reason=''] A human-readable string explaining why
   *     the connection was closed
   * @param {Boolean} [options.wasClean=false] Indicates whether or not the
   *     connection was cleanly closed
   */
  constructor(A, e = {}) {
    super(A), this[a_] = e.code === void 0 ? 0 : e.code, this[c_] = e.reason === void 0 ? "" : e.reason, this[C_] = e.wasClean === void 0 ? !1 : e.wasClean;
  }
  /**
   * @type {Number}
   */
  get code() {
    return this[a_];
  }
  /**
   * @type {String}
   */
  get reason() {
    return this[c_];
  }
  /**
   * @type {Boolean}
   */
  get wasClean() {
    return this[C_];
  }
}
Object.defineProperty(Lp.prototype, "code", { enumerable: !0 });
Object.defineProperty(Lp.prototype, "reason", { enumerable: !0 });
Object.defineProperty(Lp.prototype, "wasClean", { enumerable: !0 });
class VS extends lI {
  /**
   * Create a new `ErrorEvent`.
   *
   * @param {String} type The name of the event
   * @param {Object} [options] A dictionary object that allows for setting
   *     attributes via object members of the same name
   * @param {*} [options.error=null] The error that generated this event
   * @param {String} [options.message=''] The error message
   */
  constructor(A, e = {}) {
    super(A), this[g_] = e.error === void 0 ? null : e.error, this[u_] = e.message === void 0 ? "" : e.message;
  }
  /**
   * @type {*}
   */
  get error() {
    return this[g_];
  }
  /**
   * @type {String}
   */
  get message() {
    return this[u_];
  }
}
Object.defineProperty(VS.prototype, "error", { enumerable: !0 });
Object.defineProperty(VS.prototype, "message", { enumerable: !0 });
class sJ extends lI {
  /**
   * Create a new `MessageEvent`.
   *
   * @param {String} type The name of the event
   * @param {Object} [options] A dictionary object that allows for setting
   *     attributes via object members of the same name
   * @param {*} [options.data=null] The message content
   */
  constructor(A, e = {}) {
    super(A), this[o_] = e.data === void 0 ? null : e.data;
  }
  /**
   * @type {*}
   */
  get data() {
    return this[o_];
  }
}
Object.defineProperty(sJ.prototype, "data", { enumerable: !0 });
const viA = {
  /**
   * Register an event listener.
   *
   * @param {String} type A string representing the event type to listen for
   * @param {(Function|Object)} handler The listener to add
   * @param {Object} [options] An options object specifies characteristics about
   *     the event listener
   * @param {Boolean} [options.once=false] A `Boolean` indicating that the
   *     listener should be invoked at most once after being added. If `true`,
   *     the listener would be automatically removed when invoked.
   * @public
   */
  addEventListener(t, A, e = {}) {
    for (const i of this.listeners(t))
      if (!e[gC] && i[pw] === A && !i[gC])
        return;
    let r;
    if (t === "message")
      r = function(n, s) {
        const a = new sJ("message", {
          data: s ? n : n.toString()
        });
        a[nu] = this, DQ(A, this, a);
      };
    else if (t === "close")
      r = function(n, s) {
        const a = new Lp("close", {
          code: n,
          reason: s.toString(),
          wasClean: this._closeFrameReceived && this._closeFrameSent
        });
        a[nu] = this, DQ(A, this, a);
      };
    else if (t === "error")
      r = function(n) {
        const s = new VS("error", {
          error: n,
          message: n.message
        });
        s[nu] = this, DQ(A, this, s);
      };
    else if (t === "open")
      r = function() {
        const n = new lI("open");
        n[nu] = this, DQ(A, this, n);
      };
    else
      return;
    r[gC] = !!e[gC], r[pw] = A, e.once ? this.once(t, r) : this.on(t, r);
  },
  /**
   * Remove an event listener.
   *
   * @param {String} type A string representing the event type to remove
   * @param {(Function|Object)} handler The listener to remove
   * @public
   */
  removeEventListener(t, A) {
    for (const e of this.listeners(t))
      if (e[pw] === A && !e[gC]) {
        this.removeListener(t, e);
        break;
      }
  }
};
var RiA = {
  EventTarget: viA
};
function DQ(t, A, e) {
  typeof t == "object" && t.handleEvent ? t.handleEvent.call(t, e) : t.call(A, e);
}
const { tokenChars: uC } = XE;
function Hi(t, A, e) {
  t[A] === void 0 ? t[A] = [e] : t[A].push(e);
}
function biA(t) {
  const A = /* @__PURE__ */ Object.create(null);
  let e = /* @__PURE__ */ Object.create(null), r = !1, i = !1, n = !1, s, a, g = -1, o = -1, u = -1, I = 0;
  for (; I < t.length; I++)
    if (o = t.charCodeAt(I), s === void 0)
      if (u === -1 && uC[o] === 1)
        g === -1 && (g = I);
      else if (I !== 0 && (o === 32 || o === 9))
        u === -1 && g !== -1 && (u = I);
      else if (o === 59 || o === 44) {
        if (g === -1)
          throw new SyntaxError(`Unexpected character at index ${I}`);
        u === -1 && (u = I);
        const C = t.slice(g, u);
        o === 44 ? (Hi(A, C, e), e = /* @__PURE__ */ Object.create(null)) : s = C, g = u = -1;
      } else
        throw new SyntaxError(`Unexpected character at index ${I}`);
    else if (a === void 0)
      if (u === -1 && uC[o] === 1)
        g === -1 && (g = I);
      else if (o === 32 || o === 9)
        u === -1 && g !== -1 && (u = I);
      else if (o === 59 || o === 44) {
        if (g === -1)
          throw new SyntaxError(`Unexpected character at index ${I}`);
        u === -1 && (u = I), Hi(e, t.slice(g, u), !0), o === 44 && (Hi(A, s, e), e = /* @__PURE__ */ Object.create(null), s = void 0), g = u = -1;
      } else if (o === 61 && g !== -1 && u === -1)
        a = t.slice(g, I), g = u = -1;
      else
        throw new SyntaxError(`Unexpected character at index ${I}`);
    else if (i) {
      if (uC[o] !== 1)
        throw new SyntaxError(`Unexpected character at index ${I}`);
      g === -1 ? g = I : r || (r = !0), i = !1;
    } else if (n)
      if (uC[o] === 1)
        g === -1 && (g = I);
      else if (o === 34 && g !== -1)
        n = !1, u = I;
      else if (o === 92)
        i = !0;
      else
        throw new SyntaxError(`Unexpected character at index ${I}`);
    else if (o === 34 && t.charCodeAt(I - 1) === 61)
      n = !0;
    else if (u === -1 && uC[o] === 1)
      g === -1 && (g = I);
    else if (g !== -1 && (o === 32 || o === 9))
      u === -1 && (u = I);
    else if (o === 59 || o === 44) {
      if (g === -1)
        throw new SyntaxError(`Unexpected character at index ${I}`);
      u === -1 && (u = I);
      let C = t.slice(g, u);
      r && (C = C.replace(/\\/g, ""), r = !1), Hi(e, a, C), o === 44 && (Hi(A, s, e), e = /* @__PURE__ */ Object.create(null), s = void 0), a = void 0, g = u = -1;
    } else
      throw new SyntaxError(`Unexpected character at index ${I}`);
  if (g === -1 || n || o === 32 || o === 9)
    throw new SyntaxError("Unexpected end of input");
  u === -1 && (u = I);
  const c = t.slice(g, u);
  return s === void 0 ? Hi(A, c, e) : (a === void 0 ? Hi(e, c, !0) : r ? Hi(e, a, c.replace(/\\/g, "")) : Hi(e, a, c), Hi(A, s, e)), A;
}
function MiA(t) {
  return Object.keys(t).map((A) => {
    let e = t[A];
    return Array.isArray(e) || (e = [e]), e.map((r) => [A].concat(
      Object.keys(r).map((i) => {
        let n = r[i];
        return Array.isArray(n) || (n = [n]), n.map((s) => s === !0 ? i : `${i}=${s}`).join("; ");
      })
    ).join("; ")).join(", ");
  }).join(", ");
}
var _iA = { format: MiA, parse: biA };
const NiA = rI, LiA = mn, xiA = wn, aJ = yr, GiA = Sn, { randomBytes: UiA, createHash: TiA } = un, { Duplex: zsA, Readable: $sA } = Fn, { URL: yw } = Dn, Us = WS, KiA = hiA, JiA = FiA, { isBlob: HiA } = XE, {
  BINARY_TYPES: l_,
  EMPTY_BUFFER: SQ,
  GUID: PiA,
  kForOnEventAttribute: ww,
  kListener: OiA,
  kStatusCode: YiA,
  kWebSocket: Mt,
  NOOP: oJ
} = Ua, {
  EventTarget: { addEventListener: qiA, removeEventListener: jiA }
} = RiA, { format: WiA, parse: ViA } = _iA, { toBuffer: ZiA } = Np, XiA = 30 * 1e3, gJ = Symbol("kAborted"), mw = [8, 13], Ds = ["CONNECTING", "OPEN", "CLOSING", "CLOSED"], ziA = /^[!#$%&'*+\-.0-9A-Z^_`|a-z~]+$/;
class re extends NiA {
  /**
   * Create a new `WebSocket`.
   *
   * @param {(String|URL)} address The URL to which to connect
   * @param {(String|String[])} [protocols] The subprotocols
   * @param {Object} [options] Connection options
   */
  constructor(A, e, r) {
    super(), this._binaryType = l_[0], this._closeCode = 1006, this._closeFrameReceived = !1, this._closeFrameSent = !1, this._closeMessage = SQ, this._closeTimer = null, this._errorEmitted = !1, this._extensions = {}, this._paused = !1, this._protocol = "", this._readyState = re.CONNECTING, this._receiver = null, this._sender = null, this._socket = null, A !== null ? (this._bufferedAmount = 0, this._isServer = !1, this._redirects = 0, e === void 0 ? e = [] : Array.isArray(e) || (typeof e == "object" && e !== null ? (r = e, e = []) : e = [e]), uJ(this, A, e, r)) : (this._autoPong = r.autoPong, this._isServer = !0);
  }
  /**
   * For historical reasons, the custom "nodebuffer" type is used by the default
   * instead of "blob".
   *
   * @type {String}
   */
  get binaryType() {
    return this._binaryType;
  }
  set binaryType(A) {
    l_.includes(A) && (this._binaryType = A, this._receiver && (this._receiver._binaryType = A));
  }
  /**
   * @type {Number}
   */
  get bufferedAmount() {
    return this._socket ? this._socket._writableState.length + this._sender._bufferedBytes : this._bufferedAmount;
  }
  /**
   * @type {String}
   */
  get extensions() {
    return Object.keys(this._extensions).join();
  }
  /**
   * @type {Boolean}
   */
  get isPaused() {
    return this._paused;
  }
  /**
   * @type {Function}
   */
  /* istanbul ignore next */
  get onclose() {
    return null;
  }
  /**
   * @type {Function}
   */
  /* istanbul ignore next */
  get onerror() {
    return null;
  }
  /**
   * @type {Function}
   */
  /* istanbul ignore next */
  get onopen() {
    return null;
  }
  /**
   * @type {Function}
   */
  /* istanbul ignore next */
  get onmessage() {
    return null;
  }
  /**
   * @type {String}
   */
  get protocol() {
    return this._protocol;
  }
  /**
   * @type {Number}
   */
  get readyState() {
    return this._readyState;
  }
  /**
   * @type {String}
   */
  get url() {
    return this._url;
  }
  /**
   * Set up the socket and the internal resources.
   *
   * @param {Duplex} socket The network socket between the server and client
   * @param {Buffer} head The first packet of the upgraded stream
   * @param {Object} options Options object
   * @param {Boolean} [options.allowSynchronousEvents=false] Specifies whether
   *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
   *     multiple times in the same tick
   * @param {Function} [options.generateMask] The function used to generate the
   *     masking key
   * @param {Number} [options.maxPayload=0] The maximum allowed message size
   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
   *     not to skip UTF-8 validation for text and close messages
   * @private
   */
  setSocket(A, e, r) {
    const i = new KiA({
      allowSynchronousEvents: r.allowSynchronousEvents,
      binaryType: this.binaryType,
      extensions: this._extensions,
      isServer: this._isServer,
      maxPayload: r.maxPayload,
      skipUTF8Validation: r.skipUTF8Validation
    }), n = new JiA(A, this._extensions, r.generateMask);
    this._receiver = i, this._sender = n, this._socket = A, i[Mt] = this, n[Mt] = this, A[Mt] = this, i.on("conclude", tnA), i.on("drain", rnA), i.on("error", inA), i.on("message", nnA), i.on("ping", snA), i.on("pong", anA), n.onerror = onA, A.setTimeout && A.setTimeout(0), A.setNoDelay && A.setNoDelay(), e.length > 0 && A.unshift(e), A.on("close", CJ), A.on("data", xp), A.on("end", lJ), A.on("error", BJ), this._readyState = re.OPEN, this.emit("open");
  }
  /**
   * Emit the `'close'` event.
   *
   * @private
   */
  emitClose() {
    if (!this._socket) {
      this._readyState = re.CLOSED, this.emit("close", this._closeCode, this._closeMessage);
      return;
    }
    this._extensions[Us.extensionName] && this._extensions[Us.extensionName].cleanup(), this._receiver.removeAllListeners(), this._readyState = re.CLOSED, this.emit("close", this._closeCode, this._closeMessage);
  }
  /**
   * Start a closing handshake.
   *
   *          +----------+   +-----------+   +----------+
   *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -
   *    |     +----------+   +-----------+   +----------+     |
   *          +----------+   +-----------+         |
   * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING
   *          +----------+   +-----------+   |
   *    |           |                        |   +---+        |
   *                +------------------------+-->|fin| - - - -
   *    |         +---+                      |   +---+
   *     - - - - -|fin|<---------------------+
   *              +---+
   *
   * @param {Number} [code] Status code explaining why the connection is closing
   * @param {(String|Buffer)} [data] The reason why the connection is
   *     closing
   * @public
   */
  close(A, e) {
    if (this.readyState !== re.CLOSED) {
      if (this.readyState === re.CONNECTING) {
        Rr(this, this._req, "WebSocket was closed before the connection was established");
        return;
      }
      if (this.readyState === re.CLOSING) {
        this._closeFrameSent && (this._closeFrameReceived || this._receiver._writableState.errorEmitted) && this._socket.end();
        return;
      }
      this._readyState = re.CLOSING, this._sender.close(A, e, !this._isServer, (r) => {
        r || (this._closeFrameSent = !0, (this._closeFrameReceived || this._receiver._writableState.errorEmitted) && this._socket.end());
      }), IJ(this);
    }
  }
  /**
   * Pause the socket.
   *
   * @public
   */
  pause() {
    this.readyState === re.CONNECTING || this.readyState === re.CLOSED || (this._paused = !0, this._socket.pause());
  }
  /**
   * Send a ping.
   *
   * @param {*} [data] The data to send
   * @param {Boolean} [mask] Indicates whether or not to mask `data`
   * @param {Function} [cb] Callback which is executed when the ping is sent
   * @public
   */
  ping(A, e, r) {
    if (this.readyState === re.CONNECTING)
      throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
    if (typeof A == "function" ? (r = A, A = e = void 0) : typeof e == "function" && (r = e, e = void 0), typeof A == "number" && (A = A.toString()), this.readyState !== re.OPEN) {
      Dw(this, A, r);
      return;
    }
    e === void 0 && (e = !this._isServer), this._sender.ping(A || SQ, e, r);
  }
  /**
   * Send a pong.
   *
   * @param {*} [data] The data to send
   * @param {Boolean} [mask] Indicates whether or not to mask `data`
   * @param {Function} [cb] Callback which is executed when the pong is sent
   * @public
   */
  pong(A, e, r) {
    if (this.readyState === re.CONNECTING)
      throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
    if (typeof A == "function" ? (r = A, A = e = void 0) : typeof e == "function" && (r = e, e = void 0), typeof A == "number" && (A = A.toString()), this.readyState !== re.OPEN) {
      Dw(this, A, r);
      return;
    }
    e === void 0 && (e = !this._isServer), this._sender.pong(A || SQ, e, r);
  }
  /**
   * Resume the socket.
   *
   * @public
   */
  resume() {
    this.readyState === re.CONNECTING || this.readyState === re.CLOSED || (this._paused = !1, this._receiver._writableState.needDrain || this._socket.resume());
  }
  /**
   * Send a data message.
   *
   * @param {*} data The message to send
   * @param {Object} [options] Options object
   * @param {Boolean} [options.binary] Specifies whether `data` is binary or
   *     text
   * @param {Boolean} [options.compress] Specifies whether or not to compress
   *     `data`
   * @param {Boolean} [options.fin=true] Specifies whether the fragment is the
   *     last one
   * @param {Boolean} [options.mask] Specifies whether or not to mask `data`
   * @param {Function} [cb] Callback which is executed when data is written out
   * @public
   */
  send(A, e, r) {
    if (this.readyState === re.CONNECTING)
      throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
    if (typeof e == "function" && (r = e, e = {}), typeof A == "number" && (A = A.toString()), this.readyState !== re.OPEN) {
      Dw(this, A, r);
      return;
    }
    const i = {
      binary: typeof A != "string",
      mask: !this._isServer,
      compress: !0,
      fin: !0,
      ...e
    };
    this._extensions[Us.extensionName] || (i.compress = !1), this._sender.send(A || SQ, i, r);
  }
  /**
   * Forcibly close the connection.
   *
   * @public
   */
  terminate() {
    if (this.readyState !== re.CLOSED) {
      if (this.readyState === re.CONNECTING) {
        Rr(this, this._req, "WebSocket was closed before the connection was established");
        return;
      }
      this._socket && (this._readyState = re.CLOSING, this._socket.destroy());
    }
  }
}
Object.defineProperty(re, "CONNECTING", {
  enumerable: !0,
  value: Ds.indexOf("CONNECTING")
});
Object.defineProperty(re.prototype, "CONNECTING", {
  enumerable: !0,
  value: Ds.indexOf("CONNECTING")
});
Object.defineProperty(re, "OPEN", {
  enumerable: !0,
  value: Ds.indexOf("OPEN")
});
Object.defineProperty(re.prototype, "OPEN", {
  enumerable: !0,
  value: Ds.indexOf("OPEN")
});
Object.defineProperty(re, "CLOSING", {
  enumerable: !0,
  value: Ds.indexOf("CLOSING")
});
Object.defineProperty(re.prototype, "CLOSING", {
  enumerable: !0,
  value: Ds.indexOf("CLOSING")
});
Object.defineProperty(re, "CLOSED", {
  enumerable: !0,
  value: Ds.indexOf("CLOSED")
});
Object.defineProperty(re.prototype, "CLOSED", {
  enumerable: !0,
  value: Ds.indexOf("CLOSED")
});
[
  "binaryType",
  "bufferedAmount",
  "extensions",
  "isPaused",
  "protocol",
  "readyState",
  "url"
].forEach((t) => {
  Object.defineProperty(re.prototype, t, { enumerable: !0 });
});
["open", "error", "close", "message"].forEach((t) => {
  Object.defineProperty(re.prototype, `on${t}`, {
    enumerable: !0,
    get() {
      for (const A of this.listeners(t))
        if (A[ww]) return A[OiA];
      return null;
    },
    set(A) {
      for (const e of this.listeners(t))
        if (e[ww]) {
          this.removeListener(t, e);
          break;
        }
      typeof A == "function" && this.addEventListener(t, A, {
        [ww]: !0
      });
    }
  });
});
re.prototype.addEventListener = qiA;
re.prototype.removeEventListener = jiA;
var $iA = re;
function uJ(t, A, e, r) {
  const i = {
    allowSynchronousEvents: !0,
    autoPong: !0,
    protocolVersion: mw[1],
    maxPayload: 104857600,
    skipUTF8Validation: !1,
    perMessageDeflate: !0,
    followRedirects: !1,
    maxRedirects: 10,
    ...r,
    socketPath: void 0,
    hostname: void 0,
    protocol: void 0,
    timeout: void 0,
    method: "GET",
    host: void 0,
    path: void 0,
    port: void 0
  };
  if (t._autoPong = i.autoPong, !mw.includes(i.protocolVersion))
    throw new RangeError(
      `Unsupported protocol version: ${i.protocolVersion} (supported versions: ${mw.join(", ")})`
    );
  let n;
  if (A instanceof yw)
    n = A;
  else
    try {
      n = new yw(A);
    } catch {
      throw new SyntaxError(`Invalid URL: ${A}`);
    }
  n.protocol === "http:" ? n.protocol = "ws:" : n.protocol === "https:" && (n.protocol = "wss:"), t._url = n.href;
  const s = n.protocol === "wss:", a = n.protocol === "ws+unix:";
  let g;
  if (n.protocol !== "ws:" && !s && !a ? g = `The URL's protocol must be one of "ws:", "wss:", "http:", "https:", or "ws+unix:"` : a && !n.pathname ? g = "The URL's pathname is empty" : n.hash && (g = "The URL contains a fragment identifier"), g) {
    const l = new SyntaxError(g);
    if (t._redirects === 0)
      throw l;
    ad(t, l);
    return;
  }
  const o = s ? 443 : 80, u = UiA(16).toString("base64"), I = s ? LiA.request : xiA.request, c = /* @__PURE__ */ new Set();
  let C;
  if (i.createConnection = i.createConnection || (s ? enA : AnA), i.defaultPort = i.defaultPort || o, i.port = n.port || o, i.host = n.hostname.startsWith("[") ? n.hostname.slice(1, -1) : n.hostname, i.headers = {
    ...i.headers,
    "Sec-WebSocket-Version": i.protocolVersion,
    "Sec-WebSocket-Key": u,
    Connection: "Upgrade",
    Upgrade: "websocket"
  }, i.path = n.pathname + n.search, i.timeout = i.handshakeTimeout, i.perMessageDeflate && (C = new Us(
    i.perMessageDeflate !== !0 ? i.perMessageDeflate : {},
    !1,
    i.maxPayload
  ), i.headers["Sec-WebSocket-Extensions"] = WiA({
    [Us.extensionName]: C.offer()
  })), e.length) {
    for (const l of e) {
      if (typeof l != "string" || !ziA.test(l) || c.has(l))
        throw new SyntaxError(
          "An invalid or duplicated subprotocol was specified"
        );
      c.add(l);
    }
    i.headers["Sec-WebSocket-Protocol"] = e.join(",");
  }
  if (i.origin && (i.protocolVersion < 13 ? i.headers["Sec-WebSocket-Origin"] = i.origin : i.headers.Origin = i.origin), (n.username || n.password) && (i.auth = `${n.username}:${n.password}`), a) {
    const l = i.path.split(":");
    i.socketPath = l[0], i.path = l[1];
  }
  let E;
  if (i.followRedirects) {
    if (t._redirects === 0) {
      t._originalIpc = a, t._originalSecure = s, t._originalHostOrSocketPath = a ? i.socketPath : n.host;
      const l = r && r.headers;
      if (r = { ...r, headers: {} }, l)
        for (const [B, h] of Object.entries(l))
          r.headers[B.toLowerCase()] = h;
    } else if (t.listenerCount("redirect") === 0) {
      const l = a ? t._originalIpc ? i.socketPath === t._originalHostOrSocketPath : !1 : t._originalIpc ? !1 : n.host === t._originalHostOrSocketPath;
      (!l || t._originalSecure && !s) && (delete i.headers.authorization, delete i.headers.cookie, l || delete i.headers.host, i.auth = void 0);
    }
    i.auth && !r.headers.authorization && (r.headers.authorization = "Basic " + Buffer.from(i.auth).toString("base64")), E = t._req = I(i), t._redirects && t.emit("redirect", t.url, E);
  } else
    E = t._req = I(i);
  i.timeout && E.on("timeout", () => {
    Rr(t, E, "Opening handshake has timed out");
  }), E.on("error", (l) => {
    E === null || E[gJ] || (E = t._req = null, ad(t, l));
  }), E.on("response", (l) => {
    const B = l.headers.location, h = l.statusCode;
    if (B && i.followRedirects && h >= 300 && h < 400) {
      if (++t._redirects > i.maxRedirects) {
        Rr(t, E, "Maximum redirects exceeded");
        return;
      }
      E.abort();
      let Q;
      try {
        Q = new yw(B, A);
      } catch {
        const p = new SyntaxError(`Invalid URL: ${B}`);
        ad(t, p);
        return;
      }
      uJ(t, Q, e, r);
    } else t.emit("unexpected-response", E, l) || Rr(
      t,
      E,
      `Unexpected server response: ${l.statusCode}`
    );
  }), E.on("upgrade", (l, B, h) => {
    if (t.emit("upgrade", l), t.readyState !== re.CONNECTING) return;
    E = t._req = null;
    const Q = l.headers.upgrade;
    if (Q === void 0 || Q.toLowerCase() !== "websocket") {
      Rr(t, B, "Invalid Upgrade header");
      return;
    }
    const f = TiA("sha1").update(u + PiA).digest("base64");
    if (l.headers["sec-websocket-accept"] !== f) {
      Rr(t, B, "Invalid Sec-WebSocket-Accept header");
      return;
    }
    const p = l.headers["sec-websocket-protocol"];
    let y;
    if (p !== void 0 ? c.size ? c.has(p) || (y = "Server sent an invalid subprotocol") : y = "Server sent a subprotocol but none was requested" : c.size && (y = "Server sent no subprotocol"), y) {
      Rr(t, B, y);
      return;
    }
    p && (t._protocol = p);
    const m = l.headers["sec-websocket-extensions"];
    if (m !== void 0) {
      if (!C) {
        Rr(t, B, "Server sent a Sec-WebSocket-Extensions header but no extension was requested");
        return;
      }
      let S;
      try {
        S = ViA(m);
      } catch {
        Rr(t, B, "Invalid Sec-WebSocket-Extensions header");
        return;
      }
      const w = Object.keys(S);
      if (w.length !== 1 || w[0] !== Us.extensionName) {
        Rr(t, B, "Server indicated an extension that was not requested");
        return;
      }
      try {
        C.accept(S[Us.extensionName]);
      } catch {
        Rr(t, B, "Invalid Sec-WebSocket-Extensions header");
        return;
      }
      t._extensions[Us.extensionName] = C;
    }
    t.setSocket(B, h, {
      allowSynchronousEvents: i.allowSynchronousEvents,
      generateMask: i.generateMask,
      maxPayload: i.maxPayload,
      skipUTF8Validation: i.skipUTF8Validation
    });
  }), i.finishRequest ? i.finishRequest(E, t) : E.end();
}
function ad(t, A) {
  t._readyState = re.CLOSING, t._errorEmitted = !0, t.emit("error", A), t.emitClose();
}
function AnA(t) {
  return t.path = t.socketPath, aJ.connect(t);
}
function enA(t) {
  return t.path = void 0, !t.servername && t.servername !== "" && (t.servername = aJ.isIP(t.host) ? "" : t.host), GiA.connect(t);
}
function Rr(t, A, e) {
  t._readyState = re.CLOSING;
  const r = new Error(e);
  Error.captureStackTrace(r, Rr), A.setHeader ? (A[gJ] = !0, A.abort(), A.socket && !A.socket.destroyed && A.socket.destroy(), process.nextTick(ad, t, r)) : (A.destroy(r), A.once("error", t.emit.bind(t, "error")), A.once("close", t.emitClose.bind(t)));
}
function Dw(t, A, e) {
  if (A) {
    const r = HiA(A) ? A.size : ZiA(A).length;
    t._socket ? t._sender._bufferedBytes += r : t._bufferedAmount += r;
  }
  if (e) {
    const r = new Error(
      `WebSocket is not open: readyState ${t.readyState} (${Ds[t.readyState]})`
    );
    process.nextTick(e, r);
  }
}
function tnA(t, A) {
  const e = this[Mt];
  e._closeFrameReceived = !0, e._closeMessage = A, e._closeCode = t, e._socket[Mt] !== void 0 && (e._socket.removeListener("data", xp), process.nextTick(cJ, e._socket), t === 1005 ? e.close() : e.close(t, A));
}
function rnA() {
  const t = this[Mt];
  t.isPaused || t._socket.resume();
}
function inA(t) {
  const A = this[Mt];
  A._socket[Mt] !== void 0 && (A._socket.removeListener("data", xp), process.nextTick(cJ, A._socket), A.close(t[YiA])), A._errorEmitted || (A._errorEmitted = !0, A.emit("error", t));
}
function B_() {
  this[Mt].emitClose();
}
function nnA(t, A) {
  this[Mt].emit("message", t, A);
}
function snA(t) {
  const A = this[Mt];
  A._autoPong && A.pong(t, !this._isServer, oJ), A.emit("ping", t);
}
function anA(t) {
  this[Mt].emit("pong", t);
}
function cJ(t) {
  t.resume();
}
function onA(t) {
  const A = this[Mt];
  A.readyState !== re.CLOSED && (A.readyState === re.OPEN && (A._readyState = re.CLOSING, IJ(A)), this._socket.end(), A._errorEmitted || (A._errorEmitted = !0, A.emit("error", t)));
}
function IJ(t) {
  t._closeTimer = setTimeout(
    t._socket.destroy.bind(t._socket),
    XiA
  );
}
function CJ() {
  const t = this[Mt];
  this.removeListener("close", CJ), this.removeListener("data", xp), this.removeListener("end", lJ), t._readyState = re.CLOSING;
  let A;
  !this._readableState.endEmitted && !t._closeFrameReceived && !t._receiver._writableState.errorEmitted && (A = t._socket.read()) !== null && t._receiver.write(A), t._receiver.end(), this[Mt] = void 0, clearTimeout(t._closeTimer), t._receiver._writableState.finished || t._receiver._writableState.errorEmitted ? t.emitClose() : (t._receiver.on("error", B_), t._receiver.on("finish", B_));
}
function xp(t) {
  this[Mt]._receiver.write(t) || this.pause();
}
function lJ() {
  const t = this[Mt];
  t._readyState = re.CLOSING, t._receiver.end(), this.end();
}
function BJ() {
  const t = this[Mt];
  this.removeListener("error", BJ), this.on("error", oJ), t && (t._readyState = re.CLOSING, this.destroy());
}
const gnA = /* @__PURE__ */ sI($iA), { Duplex: AaA } = Fn, { tokenChars: eaA } = XE, { Duplex: taA } = Fn, { createHash: raA } = un, { GUID: iaA, kWebSocket: naA } = Ua;
/**
 * @license
 * Copyright 2018 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
var as;
const nF = class nF {
  constructor(A) {
    k(this, as);
    R(this, "onmessage");
    R(this, "onclose");
    x(this, as, A), d(this, as).addEventListener("message", (e) => {
      this.onmessage && this.onmessage.call(null, e.data);
    }), d(this, as).addEventListener("close", () => {
      this.onclose && this.onclose.call(null);
    }), d(this, as).addEventListener("error", () => {
    });
  }
  static create(A, e) {
    return new Promise((r, i) => {
      const n = new gnA(A, [], {
        followRedirects: !0,
        perMessageDeflate: !1,
        allowSynchronousEvents: !1,
        maxPayload: 268435456,
        // 256Mb
        headers: {
          "User-Agent": `Puppeteer ${jU}`,
          ...e
        }
      });
      n.addEventListener("open", () => r(new nF(n))), n.addEventListener("error", i);
    });
  }
  send(A) {
    d(this, as).send(A);
  }
  close() {
    d(this, as).close();
  }
};
as = new WeakMap();
let cl = nF;
const unA = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  NodeWebSocketTransport: cl
}, Symbol.toStringTag, { value: "Module" }));
var xc, Gc, Uc, ag, vf, EJ;
class cnA {
  constructor(A, e) {
    k(this, vf);
    k(this, xc);
    k(this, Gc, new ms());
    k(this, Uc, !1);
    k(this, ag, []);
    R(this, "onclose");
    R(this, "onmessage");
    x(this, xc, A);
    const r = d(this, Gc).use(
      // NodeJS event emitters don't support `*` so we need to typecast
      // As long as we don't use it we should be OK.
      new je(e)
    );
    r.on("data", (n) => O(this, vf, EJ).call(this, n)), r.on("close", () => {
      this.onclose && this.onclose.call(null);
    }), r.on("error", HA), d(this, Gc).use(
      // NodeJS event emitters don't support `*` so we need to typecast
      // As long as we don't use it we should be OK.
      new je(A)
    ).on("error", HA);
  }
  send(A) {
    bA(!d(this, Uc), "`PipeTransport` is closed."), d(this, xc).write(A), d(this, xc).write("\0");
  }
  close() {
    x(this, Uc, !0), d(this, Gc).dispose();
  }
}
xc = new WeakMap(), Gc = new WeakMap(), Uc = new WeakMap(), ag = new WeakMap(), vf = new WeakSet(), EJ = function(A) {
  if (bA(!d(this, Uc), "`PipeTransport` is closed."), d(this, ag).push(A), A.indexOf("\0") === -1)
    return;
  const e = Buffer.concat(d(this, ag));
  let r = 0, i = e.indexOf("\0");
  for (; i !== -1; ) {
    const n = e.toString(void 0, r, i);
    setImmediate(() => {
      this.onmessage && this.onmessage.call(null, n);
    }), r = i + 1, i = e.indexOf("\0", r);
  }
  r >= e.length ? x(this, ag, []) : x(this, ag, [e.subarray(r)]);
};
/**
 * @license
 * Copyright 2017 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
var an;
class hJ {
  /**
   * @internal
   */
  constructor(A, e) {
    k(this, an);
    /**
     * @internal
     */
    R(this, "puppeteer");
    this.puppeteer = A, x(this, an, e);
  }
  get browser() {
    return d(this, an);
  }
  async launch(A = {}) {
    const { dumpio: e = !1, enableExtensions: r = !1, env: i = process.env, handleSIGINT: n = !0, handleSIGTERM: s = !0, handleSIGHUP: a = !0, acceptInsecureCerts: g = !1, networkEnabled: o = !0, defaultViewport: u = NS, downloadBehavior: I, slowMo: c = 0, timeout: C = 3e4, waitForInitialPage: E = !0, protocolTimeout: l, handleDevToolsAsPage: B, idGenerator: h = qE() } = A;
    let { protocol: Q } = A;
    if (d(this, an) === "firefox" && Q === void 0 && (Q = "webDriverBiDi"), d(this, an) === "firefox" && Q === "cdp")
      throw new Error("Connecting to Firefox using CDP is no longer supported");
    const f = await this.computeLaunchArguments({
      ...A,
      protocol: Q
    });
    if (!zE(f.executablePath))
      throw new Error(`Browser was not found at the configured executablePath (${f.executablePath})`);
    const p = f.args.includes("--remote-debugging-pipe"), y = async () => {
      await this.cleanUserDataDir(f.userDataDir, {
        isTemp: f.isTempUserDataDir
      });
    };
    if (d(this, an) === "firefox" && Q === "webDriverBiDi" && p)
      throw new Error("Pipe connections are not supported with Firefox and WebDriver BiDi");
    const m = RrA({
      executablePath: f.executablePath,
      args: f.args,
      handleSIGHUP: a,
      handleSIGTERM: s,
      handleSIGINT: n,
      dumpio: e,
      env: i,
      pipe: p,
      onExit: y
    });
    let S, w, F = !1;
    const b = async () => {
      F || (F = !0, await this.closeBrowser(m, w));
    };
    try {
      d(this, an) === "firefox" ? S = await this.createBiDiBrowser(m, b, {
        timeout: C,
        protocolTimeout: l,
        slowMo: c,
        defaultViewport: u,
        acceptInsecureCerts: g,
        networkEnabled: o,
        idGenerator: h
      }) : (p ? w = await this.createCdpPipeConnection(m, {
        timeout: C,
        protocolTimeout: l,
        slowMo: c,
        idGenerator: h
      }) : w = await this.createCdpSocketConnection(m, {
        timeout: C,
        protocolTimeout: l,
        slowMo: c,
        idGenerator: h
      }), Q === "webDriverBiDi" ? S = await this.createBiDiOverCdpBrowser(m, w, b, {
        defaultViewport: u,
        acceptInsecureCerts: g,
        networkEnabled: o
      }) : S = await rf._create(w, [], g, u, I, m.nodeProcess, b, A.targetFilter, void 0, void 0, o, B));
    } catch (G) {
      b();
      const T = m.getRecentLogs().join(`
`);
      throw T.includes("Failed to create a ProcessSingleton for your profile directory") || // On Windows we will not get logs due to the singleton process
      // handover. See
      // https://source.chromium.org/chromium/chromium/src/+/main:chrome/browser/process_singleton_win.cc;l=46;drc=fc7952f0422b5073515a205a04ec9c3a1ae81658
      process.platform === "win32" && zE(oF(f.userDataDir, "lockfile")) ? new Error(`The browser is already running for ${f.userDataDir}. Use a different \`userDataDir\` or stop the running browser first.`) : T.includes("Missing X server") && A.headless === !1 ? new Error("Missing X server to start the headful browser. Either set headless to true or use xvfb-run to run your Puppeteer script.") : G instanceof $K ? new zc(G.message) : G;
    }
    if (Array.isArray(r)) {
      if (d(this, an) === "chrome" && !p)
        throw new Error("To use `enableExtensions` with a list of paths in Chrome, you must be connected with `--remote-debugging-pipe` (`pipe: true`).");
      await Promise.all([
        r.map((G) => S.installExtension(G))
      ]);
    }
    return E && await this.waitForPageTarget(S, C), S;
  }
  /**
   * @internal
   */
  async closeBrowser(A, e) {
    if (e)
      try {
        await e.closeBrowser(), await A.hasClosed();
      } catch (r) {
        HA(r), await A.close();
      }
    else
      await or(KU(de(A.hasClosed()), yp(5e3).pipe(ht(() => de(A.close())))));
  }
  /**
   * @internal
   */
  async waitForPageTarget(A, e) {
    try {
      await A.waitForTarget((r) => r.type() === "page", { timeout: e });
    } catch (r) {
      throw await A.close(), r;
    }
  }
  /**
   * @internal
   */
  async createCdpSocketConnection(A, e) {
    const r = await A.waitForLineOutput(brA, e.timeout), i = await cl.create(r);
    return new Af(
      r,
      i,
      e.slowMo,
      e.protocolTimeout,
      /* rawErrors */
      !1,
      e.idGenerator
    );
  }
  /**
   * @internal
   */
  async createCdpPipeConnection(A, e) {
    const { 3: r, 4: i } = A.nodeProcess.stdio, n = new cnA(r, i);
    return new Af(
      "",
      n,
      e.slowMo,
      e.protocolTimeout,
      /* rawErrors */
      !1,
      e.idGenerator
    );
  }
  /**
   * @internal
   */
  async createBiDiOverCdpBrowser(A, e, r, i) {
    const n = process.env.PUPPETEER_WEBDRIVER_BIDI_ONLY === "true", s = await import(
      /* webpackIgnore: true */
      "./bidi-igbSTPgO.js"
    ), a = await s.connectBidiOverCdp(e);
    return await s.BidiBrowser.create({
      connection: a,
      // Do not provide CDP connection to Browser, if BiDi-only mode is enabled. This
      // would restrict Browser to use only BiDi endpoint.
      cdpConnection: n ? void 0 : e,
      closeCallback: r,
      process: A.nodeProcess,
      defaultViewport: i.defaultViewport,
      acceptInsecureCerts: i.acceptInsecureCerts,
      networkEnabled: i.networkEnabled
    });
  }
  /**
   * @internal
   */
  async createBiDiBrowser(A, e, r) {
    const i = await A.waitForLineOutput(MrA, r.timeout) + "/session", n = await cl.create(i), s = await import(
      /* webpackIgnore: true */
      "./bidi-igbSTPgO.js"
    ), a = new s.BidiConnection(i, n, r.idGenerator, r.slowMo, r.protocolTimeout);
    return await s.BidiBrowser.create({
      connection: a,
      closeCallback: e,
      process: A.nodeProcess,
      defaultViewport: r.defaultViewport,
      acceptInsecureCerts: r.acceptInsecureCerts,
      networkEnabled: r.networkEnabled ?? !0
    });
  }
  /**
   * @internal
   */
  getProfilePath() {
    return oF(this.puppeteer.configuration.temporaryDirectory ?? xJ(), `puppeteer_dev_${this.browser}_profile-`);
  }
  /**
   * @internal
   */
  resolveExecutablePath(A, e = !0) {
    var s, a;
    let r = this.puppeteer.configuration.executablePath;
    if (r) {
      if (e && !zE(r))
        throw new Error(`Tried to find the browser at the configured path (${r}), but no executable was found.`);
      return r;
    }
    function i(g, o) {
      switch (g) {
        case "chrome":
          return o === "shell" ? ZA.CHROMEHEADLESSSHELL : ZA.CHROME;
        case "firefox":
          return ZA.FIREFOX;
      }
      return ZA.CHROME;
    }
    const n = i(this.browser, A);
    if (r = krA({
      cacheDir: this.puppeteer.defaultDownloadPath,
      browser: n,
      buildId: this.puppeteer.browserVersion
    }), e && !zE(r)) {
      const g = (a = (s = this.puppeteer.configuration) == null ? void 0 : s[this.browser]) == null ? void 0 : a.version;
      if (g)
        throw new Error(`Tried to find the browser at the configured path (${r}) for version ${g}, but no executable was found.`);
      switch (this.browser) {
        case "chrome":
          throw new Error(`Could not find Chrome (ver. ${this.puppeteer.browserVersion}). This can occur if either
 1. you did not perform an installation before running the script (e.g. \`npx puppeteer browsers install ${n}\`) or
 2. your cache path is incorrectly configured (which is: ${this.puppeteer.configuration.cacheDirectory}).
For (2), check out our guide on configuring puppeteer at https://pptr.dev/guides/configuration.`);
        case "firefox":
          throw new Error(`Could not find Firefox (rev. ${this.puppeteer.browserVersion}). This can occur if either
 1. you did not perform an installation for Firefox before running the script (e.g. \`npx puppeteer browsers install firefox\`) or
 2. your cache path is incorrectly configured (which is: ${this.puppeteer.configuration.cacheDirectory}).
For (2), check out our guide on configuring puppeteer at https://pptr.dev/guides/configuration.`);
      }
    }
    return r;
  }
}
an = new WeakMap();
/**
 * @license
 * Copyright 2020 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
function QJ(t) {
  switch (t) {
    case "chrome":
      return ie.STABLE;
    case "chrome-dev":
      return ie.DEV;
    case "chrome-beta":
      return ie.BETA;
    case "chrome-canary":
      return ie.CANARY;
  }
}
const InA = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  convertPuppeteerChannelToBrowsersChannel: QJ
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
const CnA = {
  force: !0,
  recursive: !0,
  maxRetries: 5
};
async function dJ(t) {
  await Ft.promises.rm(t, CnA);
}
/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
class lnA extends hJ {
  constructor(A) {
    super(A, "chrome");
  }
  launch(A = {}) {
    var e;
    return this.puppeteer.configuration.logLevel === "warn" && process.platform === "darwin" && process.arch === "x64" && (e = gr.cpus()[0]) != null && e.model.includes("Apple") && console.warn([
      "\x1B[1m\x1B[43m\x1B[30m",
      "Degraded performance warning:\x1B[0m\x1B[33m",
      "Launching Chrome on Mac Silicon (arm64) from an x64 Node installation results in",
      "Rosetta translating the Chrome binary, even if Chrome is already arm64. This would",
      "result in huge performance issues. To resolve this, you must run Puppeteer with",
      "a version of Node built for arm64."
    ].join(`
  `)), super.launch(A);
  }
  /**
   * @internal
   */
  async computeLaunchArguments(A = {}) {
    const { ignoreDefaultArgs: e = !1, args: r = [], pipe: i = !1, debuggingPort: n, channel: s, executablePath: a } = A, g = [];
    e ? Array.isArray(e) ? g.push(...this.defaultArgs(A).filter((C) => !e.includes(C))) : g.push(...r) : g.push(...this.defaultArgs(A)), g.some((C) => C.startsWith("--remote-debugging-")) || (i ? (bA(!n, "Browser should be launched with either pipe or debugging port - not both."), g.push("--remote-debugging-pipe")) : g.push(`--remote-debugging-port=${n || 0}`));
    let o = !1, u = g.findIndex((C) => C.startsWith("--user-data-dir"));
    u < 0 && (o = !0, g.push(`--user-data-dir=${await k_(this.getProfilePath())}`), u = g.length - 1);
    const I = g[u].split("=", 2)[1];
    bA(typeof I == "string", "`--user-data-dir` is malformed");
    let c = a;
    return c || (bA(s || !this.puppeteer._isPuppeteerCore, "An `executablePath` or `channel` must be specified for `puppeteer-core`"), c = s ? this.executablePath(s) : this.resolveExecutablePath(A.headless ?? !0)), {
      executablePath: c,
      args: g,
      isTempUserDataDir: o,
      userDataDir: I
    };
  }
  /**
   * @internal
   */
  async cleanUserDataDir(A, e) {
    if (e.isTemp)
      try {
        await dJ(A);
      } catch (r) {
        throw HA(r), r;
      }
  }
  defaultArgs(A = {}) {
    const e = E_("--disable-features", A.args);
    A.args && e.length > 0 && h_(A.args, "--disable-features");
    const i = [
      "Translate",
      // AcceptCHFrame disabled because of crbug.com/1348106.
      "AcceptCHFrame",
      "MediaRouter",
      "OptimizationHints",
      "RenderDocument",
      // https://crbug.com/444150315
      ...process.env.PUPPETEER_TEST_EXPERIMENTAL_CHROME_FEATURES === "true" ? [] : [
        // https://crbug.com/1492053
        "ProcessPerSiteUpToMainFrameThreshold",
        // https://github.com/puppeteer/puppeteer/issues/10715
        "IsolateSandboxedIframes"
      ],
      ...e
    ].filter((C) => C !== ""), n = E_("--enable-features", A.args);
    A.args && n.length > 0 && h_(A.args, "--enable-features");
    const s = [
      "PdfOopif",
      // Add features to enable by default here.
      ...n
    ].filter((C) => C !== ""), a = [
      "--allow-pre-commit-input",
      "--disable-background-networking",
      "--disable-background-timer-throttling",
      "--disable-backgrounding-occluded-windows",
      "--disable-breakpad",
      "--disable-client-side-phishing-detection",
      "--disable-component-extensions-with-background-pages",
      "--disable-crash-reporter",
      // No crash reporting in CfT.
      "--disable-default-apps",
      "--disable-dev-shm-usage",
      "--disable-hang-monitor",
      "--disable-infobars",
      "--disable-ipc-flooding-protection",
      "--disable-popup-blocking",
      "--disable-prompt-on-repost",
      "--disable-renderer-backgrounding",
      "--disable-search-engine-choice-screen",
      "--disable-sync",
      "--enable-automation",
      "--export-tagged-pdf",
      "--force-color-profile=srgb",
      "--generate-pdf-document-outline",
      "--metrics-recording-only",
      "--no-first-run",
      "--password-store=basic",
      "--use-mock-keychain",
      `--disable-features=${i.join(",")}`,
      `--enable-features=${s.join(",")}`
    ].filter((C) => C !== ""), { devtools: g = !1, headless: o = !g, args: u = [], userDataDir: I, enableExtensions: c = !1 } = A;
    return I && a.push(`--user-data-dir=${VA.resolve(I)}`), g && a.push("--auto-open-devtools-for-tabs"), o && a.push(o === "shell" ? "--headless" : "--headless=new", "--hide-scrollbars", "--mute-audio"), a.push(c ? "--enable-unsafe-extension-debugging" : "--disable-extensions"), u.every((C) => C.startsWith("-")) && a.push("about:blank"), a.push(...u), a;
  }
  executablePath(A, e = !0) {
    return A ? vrA({
      browser: ZA.CHROME,
      channel: QJ(A)
    }) : this.resolveExecutablePath(void 0, e);
  }
}
function E_(t, A = []) {
  return A.filter((e) => e.startsWith(t.endsWith("=") ? t : `${t}=`)).map((e) => {
    var r;
    return (r = e.split(new RegExp(`${t}=\\s*`))[1]) == null ? void 0 : r.trim();
  }).filter((e) => e);
}
function h_(t, A) {
  const e = new RegExp(`^${A}=.*`);
  let r = 0;
  for (; r < t.length; )
    e.test(t[r]) ? t.splice(r, 1) : r++;
  return t;
}
/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
class ZS extends hJ {
  constructor(A) {
    super(A, "firefox");
  }
  static getPreferences(A) {
    return {
      ...A,
      // Force all web content to use a single content process. TODO: remove
      // this once Firefox supports mouse event dispatch from the main frame
      // context. See https://bugzilla.mozilla.org/show_bug.cgi?id=1773393.
      "fission.webContentIsolationStrategy": 0
    };
  }
  /**
   * @internal
   */
  async computeLaunchArguments(A = {}) {
    const { ignoreDefaultArgs: e = !1, args: r = [], executablePath: i, pipe: n = !1, extraPrefsFirefox: s = {}, debuggingPort: a = null } = A, g = [];
    e ? Array.isArray(e) ? g.push(...this.defaultArgs(A).filter((C) => !e.includes(C))) : g.push(...r) : g.push(...this.defaultArgs(A)), g.some((C) => C.startsWith("--remote-debugging-")) || (n && bA(a === null, "Browser should be launched with either pipe or debugging port - not both."), g.push(`--remote-debugging-port=${a || 0}`));
    let o, u = !0;
    const I = g.findIndex((C) => ["-profile", "--profile"].includes(C));
    if (I !== -1) {
      if (o = g[I + 1], !o)
        throw new Error("Missing value for profile command line argument");
      u = !1;
    } else
      o = await k_(this.getProfilePath()), g.push("--profile"), g.push(o);
    await prA(ZA.FIREFOX, {
      path: o,
      preferences: ZS.getPreferences(s)
    });
    let c;
    return this.puppeteer._isPuppeteerCore || i ? (bA(i, "An `executablePath` must be specified for `puppeteer-core`"), c = i) : c = this.executablePath(void 0), {
      isTempUserDataDir: u,
      userDataDir: o,
      args: g,
      executablePath: c
    };
  }
  /**
   * @internal
   */
  async cleanUserDataDir(A, e) {
    if (e.isTemp)
      try {
        await dJ(A);
      } catch (r) {
        throw HA(r), r;
      }
    else
      try {
        const r = ".puppeteer", i = ["prefs.js", "user.js"], n = await Promise.allSettled(i.map(async (s) => {
          const a = VA.join(A, s + r);
          if (Ft.existsSync(a)) {
            const g = VA.join(A, s);
            await NJ(g), await LJ(a, g);
          }
        }));
        for (const s of n)
          if (s.status === "rejected")
            throw s.reason;
      } catch (r) {
        HA(r);
      }
  }
  executablePath(A, e = !0) {
    return this.resolveExecutablePath(
      void 0,
      /* validatePath=*/
      e
    );
  }
  defaultArgs(A = {}) {
    const { devtools: e = !1, headless: r = !e, args: i = [], userDataDir: n = null } = A, s = [];
    switch (gr.platform()) {
      case "darwin":
        s.push("--foreground");
        break;
      case "win32":
        s.push("--wait-for-browser");
        break;
    }
    return n && (s.push("--profile"), s.push(n)), r && s.push("--headless"), e && s.push("--devtools"), i.every((a) => a.startsWith("-")) && s.push("about:blank"), s.push(...i), s;
  }
}
/**
 * @license
 * Copyright 2020 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
var pa, mE, ya, Wg;
class BnA extends ST {
  /**
   * @internal
   */
  constructor(e) {
    const { configuration: r, ...i } = e;
    super(i);
    k(this, ya);
    k(this, pa);
    k(this, mE);
    /**
     * @internal
     */
    R(this, "defaultBrowserRevision");
    /**
     * @internal
     */
    R(this, "configuration", {});
    switch (r && (this.configuration = r), this.configuration.defaultBrowser) {
      case "firefox":
        this.defaultBrowserRevision = wI.firefox;
        break;
      default:
        this.configuration.defaultBrowser = "chrome", this.defaultBrowserRevision = wI.chrome;
        break;
    }
    this.connect = this.connect.bind(this), this.launch = this.launch.bind(this), this.executablePath = this.executablePath.bind(this), this.defaultArgs = this.defaultArgs.bind(this), this.trimCache = this.trimCache.bind(this);
  }
  /**
   * This method attaches Puppeteer to an existing browser instance.
   *
   * @param options - Set of configurable options to set on the browser.
   * @returns Promise which resolves to browser instance.
   */
  connect(e) {
    return super.connect(e);
  }
  /**
   * Launches a browser instance with given arguments and options when
   * specified.
   *
   * When using with `puppeteer-core`,
   * {@link LaunchOptions.executablePath | options.executablePath} or
   * {@link LaunchOptions.channel | options.channel} must be provided.
   *
   * @example
   * You can use {@link LaunchOptions.ignoreDefaultArgs | options.ignoreDefaultArgs}
   * to filter out `--mute-audio` from default arguments:
   *
   * ```ts
   * const browser = await puppeteer.launch({
   *   ignoreDefaultArgs: ['--mute-audio'],
   * });
   * ```
   *
   * @remarks
   * Puppeteer can also be used to control the Chrome browser, but it works best
   * with the version of Chrome for Testing downloaded by default.
   * There is no guarantee it will work with any other version. If Google Chrome
   * (rather than Chrome for Testing) is preferred, a
   * {@link https://www.google.com/chrome/browser/canary.html | Chrome Canary}
   * or
   * {@link https://www.chromium.org/getting-involved/dev-channel | Dev Channel}
   * build is suggested. See
   * {@link https://www.howtogeek.com/202825/what%E2%80%99s-the-difference-between-chromium-and-chrome/ | this article}
   * for a description of the differences between Chromium and Chrome.
   * {@link https://chromium.googlesource.com/chromium/src/+/lkgr/docs/chromium_browser_vs_google_chrome.md | This article}
   * describes some differences for Linux users. See
   * {@link https://developer.chrome.com/blog/chrome-for-testing/ | this doc} for the description
   * of Chrome for Testing.
   *
   * @param options - Options to configure launching behavior.
   */
  launch(e = {}) {
    const { browser: r = this.defaultBrowser } = e;
    switch (x(this, mE, r), r) {
      case "chrome":
        this.defaultBrowserRevision = wI.chrome;
        break;
      case "firefox":
        this.defaultBrowserRevision = wI.firefox;
        break;
      default:
        throw new Error(`Unknown product: ${r}`);
    }
    return x(this, pa, O(this, ya, Wg).call(this, r)), d(this, pa).launch(e);
  }
  executablePath(e) {
    return e === void 0 ? O(this, ya, Wg).call(this, this.lastLaunchedBrowser).executablePath(
      void 0,
      /* validatePath= */
      !1
    ) : typeof e == "string" ? O(this, ya, Wg).call(this, "chrome").executablePath(
      e,
      /* validatePath= */
      !1
    ) : O(this, ya, Wg).call(this, e.browser ?? this.lastLaunchedBrowser).resolveExecutablePath(
      e.headless,
      /* validatePath= */
      !1
    );
  }
  /**
   * @internal
   */
  get browserVersion() {
    var e, r;
    return ((r = (e = this.configuration) == null ? void 0 : e[this.lastLaunchedBrowser]) == null ? void 0 : r.version) ?? this.defaultBrowserRevision;
  }
  /**
   * The default download path for puppeteer. For puppeteer-core, this
   * code should never be called as it is never defined.
   *
   * @internal
   */
  get defaultDownloadPath() {
    return this.configuration.cacheDirectory;
  }
  /**
   * The name of the browser that was last launched.
   */
  get lastLaunchedBrowser() {
    return d(this, mE) ?? this.defaultBrowser;
  }
  /**
   * The name of the browser that will be launched by default. For
   * `puppeteer`, this is influenced by your configuration. Otherwise, it's
   * `chrome`.
   */
  get defaultBrowser() {
    return this.configuration.defaultBrowser ?? "chrome";
  }
  /**
   * @deprecated Do not use as this field as it does not take into account
   * multiple browsers of different types. Use
   * {@link PuppeteerNode.defaultBrowser | defaultBrowser} or
   * {@link PuppeteerNode.lastLaunchedBrowser | lastLaunchedBrowser}.
   *
   * @returns The name of the browser that is under automation.
   */
  get product() {
    return this.lastLaunchedBrowser;
  }
  /**
   * @param options - Set of configurable options to set on the browser.
   *
   * @returns The default arguments that the browser will be launched with.
   */
  defaultArgs(e = {}) {
    return O(this, ya, Wg).call(this, e.browser ?? this.lastLaunchedBrowser).defaultArgs(e);
  }
  /**
   * Removes all non-current Firefox and Chrome binaries in the cache directory
   * identified by the provided Puppeteer configuration. The current browser
   * version is determined by resolving PUPPETEER_REVISIONS from Puppeteer
   * unless `configuration.browserRevision` is provided.
   *
   * @remarks
   *
   * Note that the method does not check if any other Puppeteer versions
   * installed on the host that use the same cache directory require the
   * non-current binaries.
   *
   * @public
   */
  async trimCache() {
    var g, o;
    const e = ZE();
    if (!e)
      throw new Error("The current platform is not supported.");
    const r = this.configuration.cacheDirectory, i = await TrA({
      cacheDir: r
    }), n = [
      {
        product: "chrome",
        browser: ZA.CHROME,
        currentBuildId: ""
      },
      {
        product: "firefox",
        browser: ZA.FIREFOX,
        currentBuildId: ""
      }
    ];
    for (const u of n) {
      const I = ((o = (g = this.configuration) == null ? void 0 : g[u.product]) == null ? void 0 : o.version) ?? wI[u.product];
      u.currentBuildId = await frA(u.browser, e, I);
    }
    const s = new Set(n.map((u) => `${u.browser}_${u.currentBuildId}`)), a = new Set(n.map((u) => u.browser));
    for (const u of i)
      a.has(u.browser) && (s.has(`${u.browser}_${u.buildId}`) || await UrA({
        browser: u.browser,
        platform: e,
        cacheDir: r,
        buildId: u.buildId
      }));
  }
}
pa = new WeakMap(), mE = new WeakMap(), ya = new WeakSet(), /**
 * @internal
 */
Wg = function(e) {
  if (d(this, pa) && d(this, pa).browser === e)
    return d(this, pa);
  switch (e) {
    case "chrome":
      return new lnA(this);
    case "firefox":
      return new ZS(this);
    default:
      throw new Error(`Unknown product: ${e}`);
  }
};
/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
var EnA = function(t, A, e) {
  for (var r = arguments.length > 2, i = 0; i < A.length; i++)
    e = r ? A[i].call(t, e) : A[i].call(t);
  return r ? e : void 0;
}, Q_ = function(t, A, e, r, i, n) {
  function s(h) {
    if (h !== void 0 && typeof h != "function") throw new TypeError("Function expected");
    return h;
  }
  for (var a = r.kind, g = a === "getter" ? "get" : a === "setter" ? "set" : "value", o = !A && t ? r.static ? t : t.prototype : null, u = A || (o ? Object.getOwnPropertyDescriptor(o, r.name) : {}), I, c = !1, C = e.length - 1; C >= 0; C--) {
    var E = {};
    for (var l in r) E[l] = l === "access" ? {} : r[l];
    for (var l in r.access) E.access[l] = r.access[l];
    E.addInitializer = function(h) {
      if (c) throw new TypeError("Cannot add initializers after decoration has completed");
      n.push(s(h || null));
    };
    var B = (0, e[C])(a === "accessor" ? { get: u.get, set: u.set } : u[g], E);
    if (a === "accessor") {
      if (B === void 0) continue;
      if (B === null || typeof B != "object") throw new TypeError("Object expected");
      (I = s(B.get)) && (u.get = I), (I = s(B.set)) && (u.set = I), (I = s(B.init)) && i.unshift(I);
    } else (I = s(B)) && (a === "field" ? i.unshift(I) : u[g] = I);
  }
  o && Object.defineProperty(o, r.name, u), c = !0;
}, hnA = function(t, A, e) {
  return typeof A == "symbol" && (A = A.description ? "[".concat(A.description, "]") : ""), Object.defineProperty(t, "name", { configurable: !0, value: e ? "".concat(e, " ", A) : A });
};
const QnA = 30, d_ = 30, dnA = II("puppeteer:ffmpeg");
let fnA = (() => {
  var n, s, a, g, o, u, fJ, od, C;
  let t = OJ, A = [], e, r, i;
  return C = class extends t {
    /**
     * @internal
     */
    constructor(B, h, Q, { ffmpegPath: f, speed: p, scale: y, crop: m, format: S, fps: w, loop: F, delay: b, quality: G, colors: T, path: K, overwrite: H } = {}) {
      super({ allowHalfOpen: !1 });
      k(this, u);
      k(this, n, EnA(this, A));
      k(this, s);
      k(this, a, new AbortController());
      k(this, g);
      k(this, o);
      f ?? (f = "ffmpeg"), S ?? (S = "webm"), w ?? (w = d_), F || (F = -1), b ?? (b = -1), G ?? (G = QnA), T ?? (T = 256), H ?? (H = !0), x(this, o, w);
      const { error: j } = GJ(f);
      if (j)
        throw j;
      const eA = [
        `crop='min(${h},iw):min(${Q},ih):0:0'`,
        `pad=${h}:${Q}:0:0`
      ];
      p && eA.push(`setpts=${1 / p}*PTS`), m && eA.push(`crop=${m.width}:${m.height}:${m.x}:${m.y}`), y && eA.push(`scale=iw*${y}:-1:flags=lanczos`);
      const sA = O(this, u, fJ).call(this, S, w, F, b, G, T), uA = sA.indexOf("-vf");
      uA !== -1 && eA.push(sA.splice(uA, 2).at(-1) ?? ""), K && Ft.mkdirSync(RJ(K), { recursive: H }), x(this, s, UJ(
        f,
        // See https://trac.ffmpeg.org/wiki/Encode/VP9 for more information on flags.
        [
          ["-loglevel", "error"],
          // Reduces general buffering.
          ["-avioflags", "direct"],
          // Reduces initial buffering while analyzing input fps and other stats.
          [
            "-fpsprobesize",
            "0",
            "-probesize",
            "32",
            "-analyzeduration",
            "0",
            "-fflags",
            "nobuffer"
          ],
          // Forces input to be read from standard input, and forces png input
          // image format.
          ["-f", "image2pipe", "-vcodec", "png", "-i", "pipe:0"],
          // No audio
          ["-an"],
          // This drastically reduces stalling when cpu is overbooked. By default
          // VP9 tries to use all available threads?
          ["-threads", "1"],
          // Specifies the frame rate we are giving ffmpeg.
          ["-framerate", `${w}`],
          // Disable bitrate.
          ["-b:v", "0"],
          // Specifies the encoding and format we are using.
          sA,
          // Filters to ensure the images are piped correctly,
          // combined with any format-specific filters.
          ["-vf", eA.join()],
          // Overwrite output, or exit immediately if file already exists.
          [H ? "-y" : "-n"],
          "pipe:1"
        ].flat(),
        { stdio: ["pipe", "pipe", "pipe"] }
      )), d(this, s).stdout.pipe(this), d(this, s).stderr.on("data", (hA) => {
        dnA(hA.toString("utf8"));
      }), x(this, n, B);
      const { client: rA } = d(this, n).mainFrame();
      rA.once(He.Disconnected, () => {
        this.stop().catch(HA);
      }), x(this, g, Yz(ot(rA, "Page.screencastFrame").pipe(kC((hA) => {
        rA.send("Page.screencastFrameAck", {
          sessionId: hA.sessionId
        });
      }), Fg((hA) => hA.metadata.timestamp !== void 0), ht((hA) => ({
        buffer: Buffer.from(hA.data, "base64"),
        timestamp: hA.metadata.timestamp
      })), I$(2, 1), C$(([{ timestamp: hA, buffer: UA }, { timestamp: iA }]) => de(Array(Math.round(w * Math.max(iA - hA, 0))).fill(UA))), ht((hA) => (d(this, u, od).call(this, hA), [hA, performance.now()])), PU(Yd(d(this, a).signal, "abort"))), { defaultValue: [Buffer.from([]), performance.now()] }));
    }
    /**
     * Stops the recorder.
     *
     * @public
     */
    async stop() {
      if (d(this, a).signal.aborted)
        return;
      await d(this, n)._stopScreencast().catch(HA), d(this, a).abort();
      const [B, h] = await d(this, g);
      await Promise.all(Array(Math.max(1, Math.round(d(this, o) * (performance.now() - h) / 1e3))).fill(B).map(d(this, u, od).bind(this))), d(this, s).stdin.end(), await new Promise((Q) => {
        d(this, s).once("close", Q);
      });
    }
    /**
     * @internal
     */
    async [(e = [Hm()], i = [Hm()], sr)]() {
      await this.stop();
    }
  }, n = new WeakMap(), s = new WeakMap(), a = new WeakMap(), g = new WeakMap(), o = new WeakMap(), u = new WeakSet(), fJ = function(B, h, Q, f, p, y) {
    const m = [
      ["-vcodec", "vp9"],
      // Sets the quality. Lower the better.
      ["-crf", `${p}`],
      // Sets the quality and how efficient the compression will be.
      [
        "-deadline",
        "realtime",
        "-cpu-used",
        `${Math.min(gr.cpus().length / 2, 8)}`
      ]
    ];
    switch (B) {
      case "webm":
        return [
          ...m,
          // Sets the format
          ["-f", "webm"]
        ].flat();
      case "gif":
        return h = d_ === h ? 20 : "source_fps", Q === 1 / 0 && (Q = 0), f !== -1 && (f /= 10), [
          // Sets the frame rate and uses a custom palette generated from the
          // input.
          [
            "-vf",
            `fps=${h},split[s0][s1];[s0]palettegen=stats_mode=diff:max_colors=${y}[p];[s1][p]paletteuse=dither=bayer`
          ],
          // Sets the number of times to loop playback.
          ["-loop", `${Q}`],
          // Sets the delay between iterations of a loop.
          ["-final_delay", `${f}`],
          // Sets the format
          ["-f", "gif"]
        ].flat();
      case "mp4":
        return [
          ...m,
          // Fragment file during stream to avoid errors.
          ["-movflags", "hybrid_fragmented"],
          // Sets the format
          ["-f", "mp4"]
        ].flat();
    }
  }, od = function() {
    return r.value;
  }, (() => {
    const B = typeof Symbol == "function" && Symbol.metadata ? Object.create(t[Symbol.metadata] ?? null) : void 0;
    Q_(C, r = { value: hnA(async function(h) {
      const Q = await new Promise((f) => {
        d(this, s).stdin.write(h, f);
      });
      Q && console.log(`ffmpeg failed to write: ${Q.message}.`);
    }, "#writeFrame") }, e, { kind: "method", name: "#writeFrame", static: !1, private: !0, access: { has: (h) => Cr(u, h), get: (h) => d(h, u, od) }, metadata: B }, null, A), Q_(C, null, i, { kind: "method", name: "stop", static: !1, private: !1, access: { has: (h) => "stop" in h, get: (h) => h.stop }, metadata: B }, null, A), B && Object.defineProperty(C, Symbol.metadata, { enumerable: !0, configurable: !0, writable: !0, value: B });
  })(), C;
})();
/**
 * @license
 * Copyright 2017 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
cs.value = {
  fs: Ft,
  path: VA,
  ScreenRecorder: fnA
};
const pJ = new BnA({
  isPuppeteerCore: !0
}), {
  /**
   * @public
   */
  connect: saA,
  /**
   * @public
   */
  defaultArgs: aaA,
  /**
   * @public
   */
  executablePath: oaA,
  /**
   * @public
   */
  launch: gaA
} = pJ;
class pnA {
  constructor() {
    R(this, "browser", null);
    R(this, "page", null);
    this.registerTools();
  }
  async ensureBrowser() {
    if (this.page && !this.page.isClosed())
      try {
        return await this.page.url(), this.page;
      } catch {
        console.warn("Page connection is stale, reconnecting..."), this.page = null, this.browser && (await this.browser.disconnect(), this.browser = null);
      }
    let A = 5;
    for (; A > 0; )
      try {
        console.log(`Connecting to Electron CDP at http://127.0.0.1:9222... (Attempts left: ${A})`);
        const r = await (await fetch("http://127.0.0.1:9222/json/version")).json();
        this.browser = await pJ.connect({
          browserWSEndpoint: r.webSocketDebuggerUrl,
          defaultViewport: null
          // Use actual viewport
        });
        const i = await this.browser.pages();
        console.log(`Found ${i.length} pages/webviews via Puppeteer`), i.forEach((s, a) => console.log(`Page ${a}: ${s.url()}`));
        const n = i.filter((s) => {
          const a = s.url();
          return !a.includes("localhost:5173") && !a.includes("app.asar") && !a.endsWith("index.html") && !a.startsWith("devtools://");
        });
        if (console.log(`Found ${n.length} valid targets (webviews)`), n.length > 0)
          return this.page = n[n.length - 1], console.log(`Attached to page: ${this.page.url()}`), this.page;
        throw console.warn("No webview found. Waiting for one to be created..."), new Error("No active webview found in Enterprise Browser.");
      } catch (e) {
        if (console.warn(`Connection attempt failed: ${e.message}`), A--, this.browser) {
          try {
            await this.browser.disconnect();
          } catch {
          }
          this.browser = null;
        }
        if (this.page = null, A === 0)
          throw console.error("Failed to connect to Electron CDP after multiple attempts."), new Error("Could not connect to the Enterprise Browser. Is the app running with remote debugging enabled? Please restart the app.");
        await new Promise((r) => setTimeout(r, 2e3));
      }
    throw new Error("Could not connect to the Enterprise Browser.");
  }
  registerTools() {
    const A = {
      name: "browser_observe",
      description: "Analyze the current page content, URL, and interactive elements. Use this to find selectors.",
      schema: ar({}),
      execute: async () => {
        try {
          const a = await this.ensureBrowser(), g = a.url(), o = await a.title(), u = await a.evaluate(() => {
            const I = (C) => {
              if (C.id) return `#${C.id}`;
              if (C.className && typeof C.className == "string") {
                const E = C.className.split(" ").filter((l) => l.trim()).join(".");
                if (E) return `${C.tagName.toLowerCase()}.${E}`;
              }
              return C.tagName.toLowerCase();
            };
            return Array.from(document.querySelectorAll('button, input, a, textarea, [role="button"]')).slice(0, 50).map((C) => {
              const E = C.tagName.toLowerCase(), l = (C.textContent || "").substring(0, 50).trim().replace(/\s+/g, " "), B = C.getAttribute("placeholder") || "", h = C.getAttribute("type") || "", Q = C.getAttribute("role") || "", f = I(C);
              return { tag: E, text: l, placeholder: B, type: h, role: Q, selector: f };
            });
          });
          return JSON.stringify({
            url: g,
            title: o,
            interactiveElements: u
          }, null, 2);
        } catch (a) {
          return `Failed to observe page: ${a.message}`;
        }
      }
    }, e = {
      name: "browser_navigate",
      description: "Navigate the browser to a specific URL.",
      schema: ar({
        url: At().describe("The URL to navigate to (must include http/https)")
      }),
      execute: async ({ url: a }) => {
        try {
          return await (await this.ensureBrowser()).goto(a), `Navigated to ${a}`;
        } catch (g) {
          return `Failed to navigate: ${g.message}`;
        }
      }
    }, r = {
      name: "browser_click",
      description: "Click an element on the current page.",
      schema: ar({
        selector: At().describe("CSS selector of the element to click")
      }),
      execute: async ({ selector: a }) => {
        try {
          const g = await this.ensureBrowser();
          return await g.waitForSelector(a, { timeout: 5e3 }), await g.click(a), `Clicked element ${a}`;
        } catch (g) {
          return `Failed to click ${a}: ${g.message}`;
        }
      }
    }, i = {
      name: "browser_type",
      description: "Type text into an input field.",
      schema: ar({
        selector: At().describe("CSS selector of the input"),
        text: At().describe("Text to type")
      }),
      execute: async ({ selector: a, text: g }) => {
        try {
          const o = await this.ensureBrowser();
          return await o.waitForSelector(a, { timeout: 5e3 }), await o.type(a, g), `Typed "${g}" into ${a}`;
        } catch (o) {
          return `Failed to type into ${a}: ${o.message}`;
        }
      }
    }, n = {
      name: "browser_get_text",
      description: "Get the text content of an element.",
      schema: ar({
        selector: At().describe("CSS selector")
      }),
      execute: async ({ selector: a }) => {
        const g = await this.ensureBrowser();
        try {
          return await g.$eval(a, (u) => u.textContent) || "Element found but has no text.";
        } catch (o) {
          return `Failed to get text: ${o.message}`;
        }
      }
    }, s = {
      name: "browser_screenshot",
      description: "Take a screenshot of the current page.",
      schema: ar({
        path: At().optional().describe("Path to save the screenshot (optional)")
      }),
      execute: async () => `Screenshot taken (${(await (await this.ensureBrowser()).screenshot()).length} bytes).`
    };
    Yt.register(A), Yt.register(e), Yt.register(r), Yt.register(i), Yt.register(n), Yt.register(s);
  }
}
new pnA();
const yJ = VA.dirname(vJ(import.meta.url));
process.env.APP_ROOT = VA.join(yJ, "..");
const VD = process.env.VITE_DEV_SERVER_URL, uaA = VA.join(process.env.APP_ROOT, "dist-electron"), wJ = VA.join(process.env.APP_ROOT, "dist");
process.env.VITE_PUBLIC = VD ? VA.join(process.env.APP_ROOT, "public") : wJ;
let Ls;
function mJ() {
  Ls = new F_({
    icon: VA.join(process.env.VITE_PUBLIC, "electron-vite.svg"),
    webPreferences: {
      preload: VA.join(yJ, "preload.mjs"),
      webviewTag: !0
    }
  }), Ls.webContents.on("did-finish-load", () => {
    Ls == null || Ls.webContents.send("main-process-message", (/* @__PURE__ */ new Date()).toLocaleString());
  }), VD ? Ls.loadURL(VD) : Ls.loadFile(VA.join(wJ, "index.html"));
}
Tc.commandLine.appendSwitch("remote-debugging-port", "9222");
Tc.on("window-all-closed", () => {
  process.platform !== "darwin" && (Tc.quit(), Ls = null);
});
Tc.on("activate", () => {
  F_.getAllWindows().length === 0 && mJ();
});
Tc.whenReady().then(() => {
  EI.handle("vault:set", async (t, A, e) => await MC.setSecret(A, e)), EI.handle("vault:get", async (t, A) => await MC.getSecret(A)), EI.handle("vault:delete", async (t, A) => await MC.deleteSecret(A)), EI.handle("agent:chat", async (t, A) => {
    await Ov.log({
      actor: "user",
      action: "chat_message",
      details: { message: A },
      status: "success"
    }), Yt.setApprovalHandler(async (r, i) => (t.sender.send("agent:request-approval", { toolName: r, args: i }), new Promise((n) => {
      EI.once("agent:approval-response", (s, { toolName: a, approved: g }) => {
        a === r && n(g);
      });
    }))), Hv.setStepHandler((r) => {
      t.sender.send("agent:step", r);
    });
    const e = await Hv.chat(A);
    return await Ov.log({
      actor: "agent",
      action: "chat_response",
      details: { response: e },
      status: "success"
    }), e;
  }), mJ();
});
export {
  y$ as $,
  Ie as A,
  ZA as B,
  brA as C,
  Ke as D,
  je as E,
  bS as F,
  Qg as G,
  bA as H,
  SrA as I,
  kg as J,
  gu as K,
  E7 as L,
  cs as M,
  Dp as N,
  De as O,
  _rA as P,
  G$ as Q,
  Ra as R,
  HC as S,
  $K as T,
  _S as U,
  uAA as V,
  MrA as W,
  y7 as X,
  ni as Y,
  rR as Z,
  Oi as _,
  vrA as a,
  Dy as a0,
  f7 as a1,
  _sA as a2,
  NsA as a3,
  LsA as a4,
  zc as a5,
  Is as a6,
  ol as a7,
  M7 as a8,
  WQ as a9,
  Ot as aA,
  D7 as aB,
  Nm as aC,
  v7 as aD,
  W7 as aE,
  fAA as aF,
  P7 as aG,
  M$ as aH,
  de as aI,
  T7 as aJ,
  TsA as aK,
  WU as aL,
  _7 as aM,
  xr as aN,
  _$ as aO,
  L$ as aP,
  N$ as aQ,
  VD as aR,
  uaA as aS,
  wJ as aT,
  R$ as aa,
  F$ as ab,
  vi as ac,
  $v as ad,
  N7 as ae,
  d7 as af,
  Rm as ag,
  vsA as ah,
  ot as ai,
  ht as aj,
  qd as ak,
  ln as al,
  Bn as am,
  L7 as an,
  gR as ao,
  ou as ap,
  Fg as aq,
  _i as ar,
  or as as,
  KU as at,
  f$ as au,
  RsA as av,
  eu as aw,
  Te as ax,
  w7 as ay,
  m7 as az,
  QA as b,
  krA as c,
  ZE as d,
  ie as e,
  prA as f,
  TrA as g,
  wrA as h,
  qsA as i,
  jS as j,
  ae as k,
  RrA as l,
  y0 as m,
  W as n,
  XU as o,
  Da as p,
  h1 as q,
  frA as r,
  D$ as s,
  MS as t,
  UrA as u,
  HA as v,
  x$ as w,
  ms as x,
  ke as y,
  UsA as z
};
