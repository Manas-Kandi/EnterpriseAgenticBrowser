var __defProp2 = Object.defineProperty;
var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField2 = (obj, key, value) => __defNormalProp2(obj, typeof key !== "symbol" ? key + "" : key, value);
var _a2;
import * as electron from "electron";
import { app as app$1, BrowserWindow as BrowserWindow$1, webContents as webContents$1, ipcMain as ipcMain$1, clipboard, Notification } from "electron";
import { URL as URL$2, fileURLToPath } from "node:url";
import * as path$2 from "node:path";
import path__default$1 from "node:path";
import crypto$2, { randomFillSync, randomUUID } from "node:crypto";
import fs$3 from "node:fs/promises";
import keytar from "keytar";
import require$$0 from "fs";
import * as path$3 from "path";
import path__default from "path";
import require$$2 from "os";
import crypto$3 from "crypto";
import { AsyncLocalStorage } from "node:async_hooks";
import Database from "better-sqlite3";
import * as fs$1 from "node:fs";
import fs__default from "node:fs";
import os$1 from "node:os";
import * as vm from "vm";
import * as fs$2 from "fs/promises";
const byteToHex$2 = [];
for (let i2 = 0; i2 < 256; ++i2) {
  byteToHex$2.push((i2 + 256).toString(16).slice(1));
}
function unsafeStringify$2(arr2, offset = 0) {
  return (byteToHex$2[arr2[offset + 0]] + byteToHex$2[arr2[offset + 1]] + byteToHex$2[arr2[offset + 2]] + byteToHex$2[arr2[offset + 3]] + "-" + byteToHex$2[arr2[offset + 4]] + byteToHex$2[arr2[offset + 5]] + "-" + byteToHex$2[arr2[offset + 6]] + byteToHex$2[arr2[offset + 7]] + "-" + byteToHex$2[arr2[offset + 8]] + byteToHex$2[arr2[offset + 9]] + "-" + byteToHex$2[arr2[offset + 10]] + byteToHex$2[arr2[offset + 11]] + byteToHex$2[arr2[offset + 12]] + byteToHex$2[arr2[offset + 13]] + byteToHex$2[arr2[offset + 14]] + byteToHex$2[arr2[offset + 15]]).toLowerCase();
}
const rnds8Pool$2 = new Uint8Array(256);
let poolPtr$2 = rnds8Pool$2.length;
function rng$2() {
  if (poolPtr$2 > rnds8Pool$2.length - 16) {
    randomFillSync(rnds8Pool$2);
    poolPtr$2 = 0;
  }
  return rnds8Pool$2.slice(poolPtr$2, poolPtr$2 += 16);
}
const native$2 = { randomUUID };
function _v4(options2, buf, offset) {
  var _a3;
  options2 = options2 || {};
  const rnds = options2.random ?? ((_a3 = options2.rng) == null ? void 0 : _a3.call(options2)) ?? rng$2();
  if (rnds.length < 16) {
    throw new Error("Random bytes length must be >= 16");
  }
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  return unsafeStringify$2(rnds);
}
function v4$2(options2, buf, offset) {
  if (native$2.randomUUID && true && !options2) {
    return native$2.randomUUID();
  }
  return _v4(options2);
}
class VaultService {
  constructor() {
    __publicField2(this, "serviceName", "EnterpriseAgenticBrowser");
  }
  async setSecret(account, secret) {
    await keytar.setPassword(this.serviceName, account, secret);
  }
  async getSecret(account) {
    return await keytar.getPassword(this.serviceName, account);
  }
  async deleteSecret(account) {
    return await keytar.deletePassword(this.serviceName, account);
  }
}
const vaultService = new VaultService();
function addLangChainErrorFields$1(error, lc_error_code) {
  error.lc_error_code = lc_error_code;
  error.message = `${error.message}

Troubleshooting URL: https://docs.langchain.com/oss/javascript/langchain/errors/${lc_error_code}/
`;
  return error;
}
function __classPrivateFieldSet(receiver, state, value, kind, f) {
  if (typeof state === "function" ? receiver !== state || true : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return state.set(receiver, value), value;
}
function __classPrivateFieldGet(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}
let uuid4 = function() {
  const { crypto: crypto2 } = globalThis;
  if (crypto2 == null ? void 0 : crypto2.randomUUID) {
    uuid4 = crypto2.randomUUID.bind(crypto2);
    return crypto2.randomUUID();
  }
  const u8 = new Uint8Array(1);
  const randomByte = crypto2 ? () => crypto2.getRandomValues(u8)[0] : () => Math.random() * 255 & 255;
  return "10000000-1000-4000-8000-100000000000".replace(/[018]/g, (c) => (+c ^ randomByte() & 15 >> +c / 4).toString(16));
};
function isAbortError(err) {
  return typeof err === "object" && err !== null && // Spec-compliant fetch implementations
  ("name" in err && err.name === "AbortError" || // Expo fetch
  "message" in err && String(err.message).includes("FetchRequestCanceledException"));
}
const castToError = (err) => {
  if (err instanceof Error)
    return err;
  if (typeof err === "object" && err !== null) {
    try {
      if (Object.prototype.toString.call(err) === "[object Error]") {
        const error = new Error(err.message, err.cause ? { cause: err.cause } : {});
        if (err.stack)
          error.stack = err.stack;
        if (err.cause && !error.cause)
          error.cause = err.cause;
        if (err.name)
          error.name = err.name;
        return error;
      }
    } catch {
    }
    try {
      return new Error(JSON.stringify(err));
    } catch {
    }
  }
  return new Error(err);
};
class OpenAIError extends Error {
}
class APIError extends OpenAIError {
  constructor(status, error, message, headers) {
    super(`${APIError.makeMessage(status, error, message)}`);
    this.status = status;
    this.headers = headers;
    this.requestID = headers == null ? void 0 : headers.get("x-request-id");
    this.error = error;
    const data = error;
    this.code = data == null ? void 0 : data["code"];
    this.param = data == null ? void 0 : data["param"];
    this.type = data == null ? void 0 : data["type"];
  }
  static makeMessage(status, error, message) {
    const msg = (error == null ? void 0 : error.message) ? typeof error.message === "string" ? error.message : JSON.stringify(error.message) : error ? JSON.stringify(error) : message;
    if (status && msg) {
      return `${status} ${msg}`;
    }
    if (status) {
      return `${status} status code (no body)`;
    }
    if (msg) {
      return msg;
    }
    return "(no status code or body)";
  }
  static generate(status, errorResponse, message, headers) {
    if (!status || !headers) {
      return new APIConnectionError({ message, cause: castToError(errorResponse) });
    }
    const error = errorResponse == null ? void 0 : errorResponse["error"];
    if (status === 400) {
      return new BadRequestError(status, error, message, headers);
    }
    if (status === 401) {
      return new AuthenticationError(status, error, message, headers);
    }
    if (status === 403) {
      return new PermissionDeniedError(status, error, message, headers);
    }
    if (status === 404) {
      return new NotFoundError(status, error, message, headers);
    }
    if (status === 409) {
      return new ConflictError(status, error, message, headers);
    }
    if (status === 422) {
      return new UnprocessableEntityError(status, error, message, headers);
    }
    if (status === 429) {
      return new RateLimitError(status, error, message, headers);
    }
    if (status >= 500) {
      return new InternalServerError(status, error, message, headers);
    }
    return new APIError(status, error, message, headers);
  }
}
class APIUserAbortError extends APIError {
  constructor({ message } = {}) {
    super(void 0, void 0, message || "Request was aborted.", void 0);
  }
}
class APIConnectionError extends APIError {
  constructor({ message, cause }) {
    super(void 0, void 0, message || "Connection error.", void 0);
    if (cause)
      this.cause = cause;
  }
}
class APIConnectionTimeoutError extends APIConnectionError {
  constructor({ message } = {}) {
    super({ message: message ?? "Request timed out." });
  }
}
class BadRequestError extends APIError {
}
class AuthenticationError extends APIError {
}
class PermissionDeniedError extends APIError {
}
class NotFoundError extends APIError {
}
class ConflictError extends APIError {
}
class UnprocessableEntityError extends APIError {
}
class RateLimitError extends APIError {
}
class InternalServerError extends APIError {
}
class LengthFinishReasonError extends OpenAIError {
  constructor() {
    super(`Could not parse response content as the length limit was reached`);
  }
}
class ContentFilterFinishReasonError extends OpenAIError {
  constructor() {
    super(`Could not parse response content as the request was rejected by the content filter`);
  }
}
class InvalidWebhookSignatureError extends Error {
  constructor(message) {
    super(message);
  }
}
const startsWithSchemeRegexp = /^[a-z][a-z0-9+.-]*:/i;
const isAbsoluteURL = (url) => {
  return startsWithSchemeRegexp.test(url);
};
let isArray = (val) => (isArray = Array.isArray, isArray(val));
let isReadonlyArray = isArray;
function maybeObj(x) {
  if (typeof x !== "object") {
    return {};
  }
  return x ?? {};
}
function isEmptyObj$1(obj) {
  if (!obj)
    return true;
  for (const _k in obj)
    return false;
  return true;
}
function hasOwn(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}
function isObj(obj) {
  return obj != null && typeof obj === "object" && !Array.isArray(obj);
}
const validatePositiveInteger = (name, n) => {
  if (typeof n !== "number" || !Number.isInteger(n)) {
    throw new OpenAIError(`${name} must be an integer`);
  }
  if (n < 0) {
    throw new OpenAIError(`${name} must be a positive integer`);
  }
  return n;
};
const safeJSON = (text) => {
  try {
    return JSON.parse(text);
  } catch (err) {
    return void 0;
  }
};
const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
const VERSION = "6.10.0";
const isRunningInBrowser = () => {
  return (
    // @ts-ignore
    typeof window !== "undefined" && // @ts-ignore
    typeof window.document !== "undefined" && // @ts-ignore
    typeof navigator !== "undefined"
  );
};
function getDetectedPlatform() {
  if (typeof Deno !== "undefined" && Deno.build != null) {
    return "deno";
  }
  if (typeof EdgeRuntime !== "undefined") {
    return "edge";
  }
  if (Object.prototype.toString.call(typeof globalThis.process !== "undefined" ? globalThis.process : 0) === "[object process]") {
    return "node";
  }
  return "unknown";
}
const getPlatformProperties = () => {
  var _a3;
  const detectedPlatform = getDetectedPlatform();
  if (detectedPlatform === "deno") {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION,
      "X-Stainless-OS": normalizePlatform(Deno.build.os),
      "X-Stainless-Arch": normalizeArch(Deno.build.arch),
      "X-Stainless-Runtime": "deno",
      "X-Stainless-Runtime-Version": typeof Deno.version === "string" ? Deno.version : ((_a3 = Deno.version) == null ? void 0 : _a3.deno) ?? "unknown"
    };
  }
  if (typeof EdgeRuntime !== "undefined") {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION,
      "X-Stainless-OS": "Unknown",
      "X-Stainless-Arch": `other:${EdgeRuntime}`,
      "X-Stainless-Runtime": "edge",
      "X-Stainless-Runtime-Version": globalThis.process.version
    };
  }
  if (detectedPlatform === "node") {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION,
      "X-Stainless-OS": normalizePlatform(globalThis.process.platform ?? "unknown"),
      "X-Stainless-Arch": normalizeArch(globalThis.process.arch ?? "unknown"),
      "X-Stainless-Runtime": "node",
      "X-Stainless-Runtime-Version": globalThis.process.version ?? "unknown"
    };
  }
  const browserInfo = getBrowserInfo();
  if (browserInfo) {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION,
      "X-Stainless-OS": "Unknown",
      "X-Stainless-Arch": "unknown",
      "X-Stainless-Runtime": `browser:${browserInfo.browser}`,
      "X-Stainless-Runtime-Version": browserInfo.version
    };
  }
  return {
    "X-Stainless-Lang": "js",
    "X-Stainless-Package-Version": VERSION,
    "X-Stainless-OS": "Unknown",
    "X-Stainless-Arch": "unknown",
    "X-Stainless-Runtime": "unknown",
    "X-Stainless-Runtime-Version": "unknown"
  };
};
function getBrowserInfo() {
  if (typeof navigator === "undefined" || !navigator) {
    return null;
  }
  const browserPatterns = [
    { key: "edge", pattern: /Edge(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "ie", pattern: /MSIE(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "ie", pattern: /Trident(?:.*rv\:(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "chrome", pattern: /Chrome(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "firefox", pattern: /Firefox(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "safari", pattern: /(?:Version\W+(\d+)\.(\d+)(?:\.(\d+))?)?(?:\W+Mobile\S*)?\W+Safari/ }
  ];
  for (const { key, pattern } of browserPatterns) {
    const match = pattern.exec(navigator.userAgent);
    if (match) {
      const major = match[1] || 0;
      const minor = match[2] || 0;
      const patch = match[3] || 0;
      return { browser: key, version: `${major}.${minor}.${patch}` };
    }
  }
  return null;
}
const normalizeArch = (arch) => {
  if (arch === "x32")
    return "x32";
  if (arch === "x86_64" || arch === "x64")
    return "x64";
  if (arch === "arm")
    return "arm";
  if (arch === "aarch64" || arch === "arm64")
    return "arm64";
  if (arch)
    return `other:${arch}`;
  return "unknown";
};
const normalizePlatform = (platform) => {
  platform = platform.toLowerCase();
  if (platform.includes("ios"))
    return "iOS";
  if (platform === "android")
    return "Android";
  if (platform === "darwin")
    return "MacOS";
  if (platform === "win32")
    return "Windows";
  if (platform === "freebsd")
    return "FreeBSD";
  if (platform === "openbsd")
    return "OpenBSD";
  if (platform === "linux")
    return "Linux";
  if (platform)
    return `Other:${platform}`;
  return "Unknown";
};
let _platformHeaders;
const getPlatformHeaders = () => {
  return _platformHeaders ?? (_platformHeaders = getPlatformProperties());
};
function getDefaultFetch() {
  if (typeof fetch !== "undefined") {
    return fetch;
  }
  throw new Error("`fetch` is not defined as a global; Either pass `fetch` to the client, `new OpenAI({ fetch })` or polyfill the global, `globalThis.fetch = fetch`");
}
function makeReadableStream(...args) {
  const ReadableStream2 = globalThis.ReadableStream;
  if (typeof ReadableStream2 === "undefined") {
    throw new Error("`ReadableStream` is not defined as a global; You will need to polyfill it, `globalThis.ReadableStream = ReadableStream`");
  }
  return new ReadableStream2(...args);
}
function ReadableStreamFrom(iterable) {
  let iter = Symbol.asyncIterator in iterable ? iterable[Symbol.asyncIterator]() : iterable[Symbol.iterator]();
  return makeReadableStream({
    start() {
    },
    async pull(controller) {
      const { done, value } = await iter.next();
      if (done) {
        controller.close();
      } else {
        controller.enqueue(value);
      }
    },
    async cancel() {
      var _a3;
      await ((_a3 = iter.return) == null ? void 0 : _a3.call(iter));
    }
  });
}
function ReadableStreamToAsyncIterable(stream) {
  if (stream[Symbol.asyncIterator])
    return stream;
  const reader = stream.getReader();
  return {
    async next() {
      try {
        const result = await reader.read();
        if (result == null ? void 0 : result.done)
          reader.releaseLock();
        return result;
      } catch (e) {
        reader.releaseLock();
        throw e;
      }
    },
    async return() {
      const cancelPromise = reader.cancel();
      reader.releaseLock();
      await cancelPromise;
      return { done: true, value: void 0 };
    },
    [Symbol.asyncIterator]() {
      return this;
    }
  };
}
async function CancelReadableStream(stream) {
  var _a3, _b;
  if (stream === null || typeof stream !== "object")
    return;
  if (stream[Symbol.asyncIterator]) {
    await ((_b = (_a3 = stream[Symbol.asyncIterator]()).return) == null ? void 0 : _b.call(_a3));
    return;
  }
  const reader = stream.getReader();
  const cancelPromise = reader.cancel();
  reader.releaseLock();
  await cancelPromise;
}
const FallbackEncoder = ({ headers, body }) => {
  return {
    bodyHeaders: {
      "content-type": "application/json"
    },
    body: JSON.stringify(body)
  };
};
const default_format = "RFC3986";
const default_formatter = (v) => String(v);
const formatters = {
  RFC1738: (v) => String(v).replace(/%20/g, "+"),
  RFC3986: default_formatter
};
const RFC1738 = "RFC1738";
let has = (obj, key) => (has = Object.hasOwn ?? Function.prototype.call.bind(Object.prototype.hasOwnProperty), has(obj, key));
const hex_table = /* @__PURE__ */ (() => {
  const array2 = [];
  for (let i2 = 0; i2 < 256; ++i2) {
    array2.push("%" + ((i2 < 16 ? "0" : "") + i2.toString(16)).toUpperCase());
  }
  return array2;
})();
const limit = 1024;
const encode$1 = (str2, _defaultEncoder, charset, _kind, format2) => {
  if (str2.length === 0) {
    return str2;
  }
  let string2 = str2;
  if (typeof str2 === "symbol") {
    string2 = Symbol.prototype.toString.call(str2);
  } else if (typeof str2 !== "string") {
    string2 = String(str2);
  }
  if (charset === "iso-8859-1") {
    return escape(string2).replace(/%u[0-9a-f]{4}/gi, function($0) {
      return "%26%23" + parseInt($0.slice(2), 16) + "%3B";
    });
  }
  let out = "";
  for (let j = 0; j < string2.length; j += limit) {
    const segment = string2.length >= limit ? string2.slice(j, j + limit) : string2;
    const arr2 = [];
    for (let i2 = 0; i2 < segment.length; ++i2) {
      let c = segment.charCodeAt(i2);
      if (c === 45 || // -
      c === 46 || // .
      c === 95 || // _
      c === 126 || // ~
      c >= 48 && c <= 57 || // 0-9
      c >= 65 && c <= 90 || // a-z
      c >= 97 && c <= 122 || // A-Z
      format2 === RFC1738 && (c === 40 || c === 41)) {
        arr2[arr2.length] = segment.charAt(i2);
        continue;
      }
      if (c < 128) {
        arr2[arr2.length] = hex_table[c];
        continue;
      }
      if (c < 2048) {
        arr2[arr2.length] = hex_table[192 | c >> 6] + hex_table[128 | c & 63];
        continue;
      }
      if (c < 55296 || c >= 57344) {
        arr2[arr2.length] = hex_table[224 | c >> 12] + hex_table[128 | c >> 6 & 63] + hex_table[128 | c & 63];
        continue;
      }
      i2 += 1;
      c = 65536 + ((c & 1023) << 10 | segment.charCodeAt(i2) & 1023);
      arr2[arr2.length] = hex_table[240 | c >> 18] + hex_table[128 | c >> 12 & 63] + hex_table[128 | c >> 6 & 63] + hex_table[128 | c & 63];
    }
    out += arr2.join("");
  }
  return out;
};
function is_buffer(obj) {
  if (!obj || typeof obj !== "object") {
    return false;
  }
  return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
}
function maybe_map(val, fn) {
  if (isArray(val)) {
    const mapped = [];
    for (let i2 = 0; i2 < val.length; i2 += 1) {
      mapped.push(fn(val[i2]));
    }
    return mapped;
  }
  return fn(val);
}
const array_prefix_generators = {
  brackets(prefix) {
    return String(prefix) + "[]";
  },
  comma: "comma",
  indices(prefix, key) {
    return String(prefix) + "[" + key + "]";
  },
  repeat(prefix) {
    return String(prefix);
  }
};
const push_to_array = function(arr2, value_or_array) {
  Array.prototype.push.apply(arr2, isArray(value_or_array) ? value_or_array : [value_or_array]);
};
let toISOString;
const defaults = {
  addQueryPrefix: false,
  allowDots: false,
  allowEmptyArrays: false,
  arrayFormat: "indices",
  charset: "utf-8",
  charsetSentinel: false,
  delimiter: "&",
  encode: true,
  encodeDotInKeys: false,
  encoder: encode$1,
  encodeValuesOnly: false,
  format: default_format,
  formatter: default_formatter,
  /** @deprecated */
  indices: false,
  serializeDate(date2) {
    return (toISOString ?? (toISOString = Function.prototype.call.bind(Date.prototype.toISOString)))(date2);
  },
  skipNulls: false,
  strictNullHandling: false
};
function is_non_nullish_primitive(v) {
  return typeof v === "string" || typeof v === "number" || typeof v === "boolean" || typeof v === "symbol" || typeof v === "bigint";
}
const sentinel = {};
function inner_stringify(object2, prefix, generateArrayPrefix, commaRoundTrip, allowEmptyArrays, strictNullHandling, skipNulls, encodeDotInKeys, encoder2, filter, sort, allowDots, serializeDate, format2, formatter, encodeValuesOnly, charset, sideChannel) {
  let obj = object2;
  let tmp_sc = sideChannel;
  let step = 0;
  let find_flag = false;
  while ((tmp_sc = tmp_sc.get(sentinel)) !== void 0 && !find_flag) {
    const pos = tmp_sc.get(object2);
    step += 1;
    if (typeof pos !== "undefined") {
      if (pos === step) {
        throw new RangeError("Cyclic object value");
      } else {
        find_flag = true;
      }
    }
    if (typeof tmp_sc.get(sentinel) === "undefined") {
      step = 0;
    }
  }
  if (typeof filter === "function") {
    obj = filter(prefix, obj);
  } else if (obj instanceof Date) {
    obj = serializeDate == null ? void 0 : serializeDate(obj);
  } else if (generateArrayPrefix === "comma" && isArray(obj)) {
    obj = maybe_map(obj, function(value) {
      if (value instanceof Date) {
        return serializeDate == null ? void 0 : serializeDate(value);
      }
      return value;
    });
  }
  if (obj === null) {
    if (strictNullHandling) {
      return encoder2 && !encodeValuesOnly ? (
        // @ts-expect-error
        encoder2(prefix, defaults.encoder, charset, "key", format2)
      ) : prefix;
    }
    obj = "";
  }
  if (is_non_nullish_primitive(obj) || is_buffer(obj)) {
    if (encoder2) {
      const key_value = encodeValuesOnly ? prefix : encoder2(prefix, defaults.encoder, charset, "key", format2);
      return [
        (formatter == null ? void 0 : formatter(key_value)) + "=" + // @ts-expect-error
        (formatter == null ? void 0 : formatter(encoder2(obj, defaults.encoder, charset, "value", format2)))
      ];
    }
    return [(formatter == null ? void 0 : formatter(prefix)) + "=" + (formatter == null ? void 0 : formatter(String(obj)))];
  }
  const values = [];
  if (typeof obj === "undefined") {
    return values;
  }
  let obj_keys;
  if (generateArrayPrefix === "comma" && isArray(obj)) {
    if (encodeValuesOnly && encoder2) {
      obj = maybe_map(obj, encoder2);
    }
    obj_keys = [{ value: obj.length > 0 ? obj.join(",") || null : void 0 }];
  } else if (isArray(filter)) {
    obj_keys = filter;
  } else {
    const keys = Object.keys(obj);
    obj_keys = sort ? keys.sort(sort) : keys;
  }
  const encoded_prefix = encodeDotInKeys ? String(prefix).replace(/\./g, "%2E") : String(prefix);
  const adjusted_prefix = commaRoundTrip && isArray(obj) && obj.length === 1 ? encoded_prefix + "[]" : encoded_prefix;
  if (allowEmptyArrays && isArray(obj) && obj.length === 0) {
    return adjusted_prefix + "[]";
  }
  for (let j = 0; j < obj_keys.length; ++j) {
    const key = obj_keys[j];
    const value = (
      // @ts-ignore
      typeof key === "object" && typeof key.value !== "undefined" ? key.value : obj[key]
    );
    if (skipNulls && value === null) {
      continue;
    }
    const encoded_key = allowDots && encodeDotInKeys ? key.replace(/\./g, "%2E") : key;
    const key_prefix = isArray(obj) ? typeof generateArrayPrefix === "function" ? generateArrayPrefix(adjusted_prefix, encoded_key) : adjusted_prefix : adjusted_prefix + (allowDots ? "." + encoded_key : "[" + encoded_key + "]");
    sideChannel.set(object2, step);
    const valueSideChannel = /* @__PURE__ */ new WeakMap();
    valueSideChannel.set(sentinel, sideChannel);
    push_to_array(values, inner_stringify(
      value,
      key_prefix,
      generateArrayPrefix,
      commaRoundTrip,
      allowEmptyArrays,
      strictNullHandling,
      skipNulls,
      encodeDotInKeys,
      // @ts-ignore
      generateArrayPrefix === "comma" && encodeValuesOnly && isArray(obj) ? null : encoder2,
      filter,
      sort,
      allowDots,
      serializeDate,
      format2,
      formatter,
      encodeValuesOnly,
      charset,
      valueSideChannel
    ));
  }
  return values;
}
function normalize_stringify_options(opts = defaults) {
  if (typeof opts.allowEmptyArrays !== "undefined" && typeof opts.allowEmptyArrays !== "boolean") {
    throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
  }
  if (typeof opts.encodeDotInKeys !== "undefined" && typeof opts.encodeDotInKeys !== "boolean") {
    throw new TypeError("`encodeDotInKeys` option can only be `true` or `false`, when provided");
  }
  if (opts.encoder !== null && typeof opts.encoder !== "undefined" && typeof opts.encoder !== "function") {
    throw new TypeError("Encoder has to be a function.");
  }
  const charset = opts.charset || defaults.charset;
  if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
    throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
  }
  let format2 = default_format;
  if (typeof opts.format !== "undefined") {
    if (!has(formatters, opts.format)) {
      throw new TypeError("Unknown format option provided.");
    }
    format2 = opts.format;
  }
  const formatter = formatters[format2];
  let filter = defaults.filter;
  if (typeof opts.filter === "function" || isArray(opts.filter)) {
    filter = opts.filter;
  }
  let arrayFormat;
  if (opts.arrayFormat && opts.arrayFormat in array_prefix_generators) {
    arrayFormat = opts.arrayFormat;
  } else if ("indices" in opts) {
    arrayFormat = opts.indices ? "indices" : "repeat";
  } else {
    arrayFormat = defaults.arrayFormat;
  }
  if ("commaRoundTrip" in opts && typeof opts.commaRoundTrip !== "boolean") {
    throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
  }
  const allowDots = typeof opts.allowDots === "undefined" ? !!opts.encodeDotInKeys === true ? true : defaults.allowDots : !!opts.allowDots;
  return {
    addQueryPrefix: typeof opts.addQueryPrefix === "boolean" ? opts.addQueryPrefix : defaults.addQueryPrefix,
    // @ts-ignore
    allowDots,
    allowEmptyArrays: typeof opts.allowEmptyArrays === "boolean" ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,
    arrayFormat,
    charset,
    charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
    commaRoundTrip: !!opts.commaRoundTrip,
    delimiter: typeof opts.delimiter === "undefined" ? defaults.delimiter : opts.delimiter,
    encode: typeof opts.encode === "boolean" ? opts.encode : defaults.encode,
    encodeDotInKeys: typeof opts.encodeDotInKeys === "boolean" ? opts.encodeDotInKeys : defaults.encodeDotInKeys,
    encoder: typeof opts.encoder === "function" ? opts.encoder : defaults.encoder,
    encodeValuesOnly: typeof opts.encodeValuesOnly === "boolean" ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
    filter,
    format: format2,
    formatter,
    serializeDate: typeof opts.serializeDate === "function" ? opts.serializeDate : defaults.serializeDate,
    skipNulls: typeof opts.skipNulls === "boolean" ? opts.skipNulls : defaults.skipNulls,
    // @ts-ignore
    sort: typeof opts.sort === "function" ? opts.sort : null,
    strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling
  };
}
function stringify(object2, opts = {}) {
  let obj = object2;
  const options2 = normalize_stringify_options(opts);
  let obj_keys;
  let filter;
  if (typeof options2.filter === "function") {
    filter = options2.filter;
    obj = filter("", obj);
  } else if (isArray(options2.filter)) {
    filter = options2.filter;
    obj_keys = filter;
  }
  const keys = [];
  if (typeof obj !== "object" || obj === null) {
    return "";
  }
  const generateArrayPrefix = array_prefix_generators[options2.arrayFormat];
  const commaRoundTrip = generateArrayPrefix === "comma" && options2.commaRoundTrip;
  if (!obj_keys) {
    obj_keys = Object.keys(obj);
  }
  if (options2.sort) {
    obj_keys.sort(options2.sort);
  }
  const sideChannel = /* @__PURE__ */ new WeakMap();
  for (let i2 = 0; i2 < obj_keys.length; ++i2) {
    const key = obj_keys[i2];
    if (options2.skipNulls && obj[key] === null) {
      continue;
    }
    push_to_array(keys, inner_stringify(
      obj[key],
      key,
      // @ts-expect-error
      generateArrayPrefix,
      commaRoundTrip,
      options2.allowEmptyArrays,
      options2.strictNullHandling,
      options2.skipNulls,
      options2.encodeDotInKeys,
      options2.encode ? options2.encoder : null,
      options2.filter,
      options2.sort,
      options2.allowDots,
      options2.serializeDate,
      options2.format,
      options2.formatter,
      options2.encodeValuesOnly,
      options2.charset,
      sideChannel
    ));
  }
  const joined = keys.join(options2.delimiter);
  let prefix = options2.addQueryPrefix === true ? "?" : "";
  if (options2.charsetSentinel) {
    if (options2.charset === "iso-8859-1") {
      prefix += "utf8=%26%2310003%3B&";
    } else {
      prefix += "utf8=%E2%9C%93&";
    }
  }
  return joined.length > 0 ? prefix + joined : "";
}
function concatBytes(buffers) {
  let length = 0;
  for (const buffer of buffers) {
    length += buffer.length;
  }
  const output = new Uint8Array(length);
  let index = 0;
  for (const buffer of buffers) {
    output.set(buffer, index);
    index += buffer.length;
  }
  return output;
}
let encodeUTF8_;
function encodeUTF8(str2) {
  let encoder2;
  return (encodeUTF8_ ?? (encoder2 = new globalThis.TextEncoder(), encodeUTF8_ = encoder2.encode.bind(encoder2)))(str2);
}
let decodeUTF8_;
function decodeUTF8(bytes) {
  let decoder;
  return (decodeUTF8_ ?? (decoder = new globalThis.TextDecoder(), decodeUTF8_ = decoder.decode.bind(decoder)))(bytes);
}
var _LineDecoder_buffer, _LineDecoder_carriageReturnIndex;
class LineDecoder {
  constructor() {
    _LineDecoder_buffer.set(this, void 0);
    _LineDecoder_carriageReturnIndex.set(this, void 0);
    __classPrivateFieldSet(this, _LineDecoder_buffer, new Uint8Array());
    __classPrivateFieldSet(this, _LineDecoder_carriageReturnIndex, null);
  }
  decode(chunk) {
    if (chunk == null) {
      return [];
    }
    const binaryChunk = chunk instanceof ArrayBuffer ? new Uint8Array(chunk) : typeof chunk === "string" ? encodeUTF8(chunk) : chunk;
    __classPrivateFieldSet(this, _LineDecoder_buffer, concatBytes([__classPrivateFieldGet(this, _LineDecoder_buffer, "f"), binaryChunk]));
    const lines = [];
    let patternIndex;
    while ((patternIndex = findNewlineIndex(__classPrivateFieldGet(this, _LineDecoder_buffer, "f"), __classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, "f"))) != null) {
      if (patternIndex.carriage && __classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, "f") == null) {
        __classPrivateFieldSet(this, _LineDecoder_carriageReturnIndex, patternIndex.index);
        continue;
      }
      if (__classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, "f") != null && (patternIndex.index !== __classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, "f") + 1 || patternIndex.carriage)) {
        lines.push(decodeUTF8(__classPrivateFieldGet(this, _LineDecoder_buffer, "f").subarray(0, __classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, "f") - 1)));
        __classPrivateFieldSet(this, _LineDecoder_buffer, __classPrivateFieldGet(this, _LineDecoder_buffer, "f").subarray(__classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, "f")));
        __classPrivateFieldSet(this, _LineDecoder_carriageReturnIndex, null);
        continue;
      }
      const endIndex = __classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, "f") !== null ? patternIndex.preceding - 1 : patternIndex.preceding;
      const line = decodeUTF8(__classPrivateFieldGet(this, _LineDecoder_buffer, "f").subarray(0, endIndex));
      lines.push(line);
      __classPrivateFieldSet(this, _LineDecoder_buffer, __classPrivateFieldGet(this, _LineDecoder_buffer, "f").subarray(patternIndex.index));
      __classPrivateFieldSet(this, _LineDecoder_carriageReturnIndex, null);
    }
    return lines;
  }
  flush() {
    if (!__classPrivateFieldGet(this, _LineDecoder_buffer, "f").length) {
      return [];
    }
    return this.decode("\n");
  }
}
_LineDecoder_buffer = /* @__PURE__ */ new WeakMap(), _LineDecoder_carriageReturnIndex = /* @__PURE__ */ new WeakMap();
LineDecoder.NEWLINE_CHARS = /* @__PURE__ */ new Set(["\n", "\r"]);
LineDecoder.NEWLINE_REGEXP = /\r\n|[\n\r]/g;
function findNewlineIndex(buffer, startIndex) {
  const newline = 10;
  const carriage = 13;
  for (let i2 = startIndex ?? 0; i2 < buffer.length; i2++) {
    if (buffer[i2] === newline) {
      return { preceding: i2, index: i2 + 1, carriage: false };
    }
    if (buffer[i2] === carriage) {
      return { preceding: i2, index: i2 + 1, carriage: true };
    }
  }
  return null;
}
function findDoubleNewlineIndex(buffer) {
  const newline = 10;
  const carriage = 13;
  for (let i2 = 0; i2 < buffer.length - 1; i2++) {
    if (buffer[i2] === newline && buffer[i2 + 1] === newline) {
      return i2 + 2;
    }
    if (buffer[i2] === carriage && buffer[i2 + 1] === carriage) {
      return i2 + 2;
    }
    if (buffer[i2] === carriage && buffer[i2 + 1] === newline && i2 + 3 < buffer.length && buffer[i2 + 2] === carriage && buffer[i2 + 3] === newline) {
      return i2 + 4;
    }
  }
  return -1;
}
const levelNumbers = {
  off: 0,
  error: 200,
  warn: 300,
  info: 400,
  debug: 500
};
const parseLogLevel = (maybeLevel, sourceName, client2) => {
  if (!maybeLevel) {
    return void 0;
  }
  if (hasOwn(levelNumbers, maybeLevel)) {
    return maybeLevel;
  }
  loggerFor(client2).warn(`${sourceName} was set to ${JSON.stringify(maybeLevel)}, expected one of ${JSON.stringify(Object.keys(levelNumbers))}`);
  return void 0;
};
function noop() {
}
function makeLogFn(fnLevel, logger, logLevel) {
  if (!logger || levelNumbers[fnLevel] > levelNumbers[logLevel]) {
    return noop;
  } else {
    return logger[fnLevel].bind(logger);
  }
}
const noopLogger = {
  error: noop,
  warn: noop,
  info: noop,
  debug: noop
};
let cachedLoggers = /* @__PURE__ */ new WeakMap();
function loggerFor(client2) {
  const logger = client2.logger;
  const logLevel = client2.logLevel ?? "off";
  if (!logger) {
    return noopLogger;
  }
  const cachedLogger = cachedLoggers.get(logger);
  if (cachedLogger && cachedLogger[0] === logLevel) {
    return cachedLogger[1];
  }
  const levelLogger = {
    error: makeLogFn("error", logger, logLevel),
    warn: makeLogFn("warn", logger, logLevel),
    info: makeLogFn("info", logger, logLevel),
    debug: makeLogFn("debug", logger, logLevel)
  };
  cachedLoggers.set(logger, [logLevel, levelLogger]);
  return levelLogger;
}
const formatRequestDetails = (details) => {
  if (details.options) {
    details.options = { ...details.options };
    delete details.options["headers"];
  }
  if (details.headers) {
    details.headers = Object.fromEntries((details.headers instanceof Headers ? [...details.headers] : Object.entries(details.headers)).map(([name, value]) => [
      name,
      name.toLowerCase() === "authorization" || name.toLowerCase() === "cookie" || name.toLowerCase() === "set-cookie" ? "***" : value
    ]));
  }
  if ("retryOfRequestLogID" in details) {
    if (details.retryOfRequestLogID) {
      details.retryOf = details.retryOfRequestLogID;
    }
    delete details.retryOfRequestLogID;
  }
  return details;
};
var _Stream_client;
class Stream {
  constructor(iterator, controller, client2) {
    this.iterator = iterator;
    _Stream_client.set(this, void 0);
    this.controller = controller;
    __classPrivateFieldSet(this, _Stream_client, client2);
  }
  static fromSSEResponse(response, controller, client2) {
    let consumed = false;
    const logger = client2 ? loggerFor(client2) : console;
    async function* iterator() {
      if (consumed) {
        throw new OpenAIError("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
      }
      consumed = true;
      let done = false;
      try {
        for await (const sse of _iterSSEMessages(response, controller)) {
          if (done)
            continue;
          if (sse.data.startsWith("[DONE]")) {
            done = true;
            continue;
          }
          if (sse.event === null || !sse.event.startsWith("thread.")) {
            let data;
            try {
              data = JSON.parse(sse.data);
            } catch (e) {
              logger.error(`Could not parse message into JSON:`, sse.data);
              logger.error(`From chunk:`, sse.raw);
              throw e;
            }
            if (data && data.error) {
              throw new APIError(void 0, data.error, void 0, response.headers);
            }
            yield data;
          } else {
            let data;
            try {
              data = JSON.parse(sse.data);
            } catch (e) {
              console.error(`Could not parse message into JSON:`, sse.data);
              console.error(`From chunk:`, sse.raw);
              throw e;
            }
            if (sse.event == "error") {
              throw new APIError(void 0, data.error, data.message, void 0);
            }
            yield { event: sse.event, data };
          }
        }
        done = true;
      } catch (e) {
        if (isAbortError(e))
          return;
        throw e;
      } finally {
        if (!done)
          controller.abort();
      }
    }
    return new Stream(iterator, controller, client2);
  }
  /**
   * Generates a Stream from a newline-separated ReadableStream
   * where each item is a JSON value.
   */
  static fromReadableStream(readableStream, controller, client2) {
    let consumed = false;
    async function* iterLines() {
      const lineDecoder = new LineDecoder();
      const iter = ReadableStreamToAsyncIterable(readableStream);
      for await (const chunk of iter) {
        for (const line of lineDecoder.decode(chunk)) {
          yield line;
        }
      }
      for (const line of lineDecoder.flush()) {
        yield line;
      }
    }
    async function* iterator() {
      if (consumed) {
        throw new OpenAIError("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
      }
      consumed = true;
      let done = false;
      try {
        for await (const line of iterLines()) {
          if (done)
            continue;
          if (line)
            yield JSON.parse(line);
        }
        done = true;
      } catch (e) {
        if (isAbortError(e))
          return;
        throw e;
      } finally {
        if (!done)
          controller.abort();
      }
    }
    return new Stream(iterator, controller, client2);
  }
  [(_Stream_client = /* @__PURE__ */ new WeakMap(), Symbol.asyncIterator)]() {
    return this.iterator();
  }
  /**
   * Splits the stream into two streams which can be
   * independently read from at different speeds.
   */
  tee() {
    const left = [];
    const right = [];
    const iterator = this.iterator();
    const teeIterator = (queue2) => {
      return {
        next: () => {
          if (queue2.length === 0) {
            const result = iterator.next();
            left.push(result);
            right.push(result);
          }
          return queue2.shift();
        }
      };
    };
    return [
      new Stream(() => teeIterator(left), this.controller, __classPrivateFieldGet(this, _Stream_client, "f")),
      new Stream(() => teeIterator(right), this.controller, __classPrivateFieldGet(this, _Stream_client, "f"))
    ];
  }
  /**
   * Converts this stream to a newline-separated ReadableStream of
   * JSON stringified values in the stream
   * which can be turned back into a Stream with `Stream.fromReadableStream()`.
   */
  toReadableStream() {
    const self2 = this;
    let iter;
    return makeReadableStream({
      async start() {
        iter = self2[Symbol.asyncIterator]();
      },
      async pull(ctrl) {
        try {
          const { value, done } = await iter.next();
          if (done)
            return ctrl.close();
          const bytes = encodeUTF8(JSON.stringify(value) + "\n");
          ctrl.enqueue(bytes);
        } catch (err) {
          ctrl.error(err);
        }
      },
      async cancel() {
        var _a3;
        await ((_a3 = iter.return) == null ? void 0 : _a3.call(iter));
      }
    });
  }
}
async function* _iterSSEMessages(response, controller) {
  if (!response.body) {
    controller.abort();
    if (typeof globalThis.navigator !== "undefined" && globalThis.navigator.product === "ReactNative") {
      throw new OpenAIError(`The default react-native fetch implementation does not support streaming. Please use expo/fetch: https://docs.expo.dev/versions/latest/sdk/expo/#expofetch-api`);
    }
    throw new OpenAIError(`Attempted to iterate over a response with no body`);
  }
  const sseDecoder = new SSEDecoder();
  const lineDecoder = new LineDecoder();
  const iter = ReadableStreamToAsyncIterable(response.body);
  for await (const sseChunk of iterSSEChunks(iter)) {
    for (const line of lineDecoder.decode(sseChunk)) {
      const sse = sseDecoder.decode(line);
      if (sse)
        yield sse;
    }
  }
  for (const line of lineDecoder.flush()) {
    const sse = sseDecoder.decode(line);
    if (sse)
      yield sse;
  }
}
async function* iterSSEChunks(iterator) {
  let data = new Uint8Array();
  for await (const chunk of iterator) {
    if (chunk == null) {
      continue;
    }
    const binaryChunk = chunk instanceof ArrayBuffer ? new Uint8Array(chunk) : typeof chunk === "string" ? encodeUTF8(chunk) : chunk;
    let newData = new Uint8Array(data.length + binaryChunk.length);
    newData.set(data);
    newData.set(binaryChunk, data.length);
    data = newData;
    let patternIndex;
    while ((patternIndex = findDoubleNewlineIndex(data)) !== -1) {
      yield data.slice(0, patternIndex);
      data = data.slice(patternIndex);
    }
  }
  if (data.length > 0) {
    yield data;
  }
}
class SSEDecoder {
  constructor() {
    this.event = null;
    this.data = [];
    this.chunks = [];
  }
  decode(line) {
    if (line.endsWith("\r")) {
      line = line.substring(0, line.length - 1);
    }
    if (!line) {
      if (!this.event && !this.data.length)
        return null;
      const sse = {
        event: this.event,
        data: this.data.join("\n"),
        raw: this.chunks
      };
      this.event = null;
      this.data = [];
      this.chunks = [];
      return sse;
    }
    this.chunks.push(line);
    if (line.startsWith(":")) {
      return null;
    }
    let [fieldname, _, value] = partition(line, ":");
    if (value.startsWith(" ")) {
      value = value.substring(1);
    }
    if (fieldname === "event") {
      this.event = value;
    } else if (fieldname === "data") {
      this.data.push(value);
    }
    return null;
  }
}
function partition(str2, delimiter) {
  const index = str2.indexOf(delimiter);
  if (index !== -1) {
    return [str2.substring(0, index), delimiter, str2.substring(index + delimiter.length)];
  }
  return [str2, "", ""];
}
async function defaultParseResponse(client2, props) {
  const { response, requestLogID, retryOfRequestLogID, startTime: startTime2 } = props;
  const body = await (async () => {
    var _a3;
    if (props.options.stream) {
      loggerFor(client2).debug("response", response.status, response.url, response.headers, response.body);
      if (props.options.__streamClass) {
        return props.options.__streamClass.fromSSEResponse(response, props.controller, client2);
      }
      return Stream.fromSSEResponse(response, props.controller, client2);
    }
    if (response.status === 204) {
      return null;
    }
    if (props.options.__binaryResponse) {
      return response;
    }
    const contentType = response.headers.get("content-type");
    const mediaType = (_a3 = contentType == null ? void 0 : contentType.split(";")[0]) == null ? void 0 : _a3.trim();
    const isJSON = (mediaType == null ? void 0 : mediaType.includes("application/json")) || (mediaType == null ? void 0 : mediaType.endsWith("+json"));
    if (isJSON) {
      const json = await response.json();
      return addRequestID(json, response);
    }
    const text = await response.text();
    return text;
  })();
  loggerFor(client2).debug(`[${requestLogID}] response parsed`, formatRequestDetails({
    retryOfRequestLogID,
    url: response.url,
    status: response.status,
    body,
    durationMs: Date.now() - startTime2
  }));
  return body;
}
function addRequestID(value, response) {
  if (!value || typeof value !== "object" || Array.isArray(value)) {
    return value;
  }
  return Object.defineProperty(value, "_request_id", {
    value: response.headers.get("x-request-id"),
    enumerable: false
  });
}
var _APIPromise_client;
class APIPromise extends Promise {
  constructor(client2, responsePromise, parseResponse2 = defaultParseResponse) {
    super((resolve) => {
      resolve(null);
    });
    this.responsePromise = responsePromise;
    this.parseResponse = parseResponse2;
    _APIPromise_client.set(this, void 0);
    __classPrivateFieldSet(this, _APIPromise_client, client2);
  }
  _thenUnwrap(transform2) {
    return new APIPromise(__classPrivateFieldGet(this, _APIPromise_client, "f"), this.responsePromise, async (client2, props) => addRequestID(transform2(await this.parseResponse(client2, props), props), props.response));
  }
  /**
   * Gets the raw `Response` instance instead of parsing the response
   * data.
   *
   * If you want to parse the response body but still get the `Response`
   * instance, you can use {@link withResponse()}.
   *
   * ðŸ‘‹ Getting the wrong TypeScript type for `Response`?
   * Try setting `"moduleResolution": "NodeNext"` or add `"lib": ["DOM"]`
   * to your `tsconfig.json`.
   */
  asResponse() {
    return this.responsePromise.then((p) => p.response);
  }
  /**
   * Gets the parsed response data, the raw `Response` instance and the ID of the request,
   * returned via the X-Request-ID header which is useful for debugging requests and reporting
   * issues to OpenAI.
   *
   * If you just want to get the raw `Response` instance without parsing it,
   * you can use {@link asResponse()}.
   *
   * ðŸ‘‹ Getting the wrong TypeScript type for `Response`?
   * Try setting `"moduleResolution": "NodeNext"` or add `"lib": ["DOM"]`
   * to your `tsconfig.json`.
   */
  async withResponse() {
    const [data, response] = await Promise.all([this.parse(), this.asResponse()]);
    return { data, response, request_id: response.headers.get("x-request-id") };
  }
  parse() {
    if (!this.parsedPromise) {
      this.parsedPromise = this.responsePromise.then((data) => this.parseResponse(__classPrivateFieldGet(this, _APIPromise_client, "f"), data));
    }
    return this.parsedPromise;
  }
  then(onfulfilled, onrejected) {
    return this.parse().then(onfulfilled, onrejected);
  }
  catch(onrejected) {
    return this.parse().catch(onrejected);
  }
  finally(onfinally) {
    return this.parse().finally(onfinally);
  }
}
_APIPromise_client = /* @__PURE__ */ new WeakMap();
var _AbstractPage_client;
class AbstractPage {
  constructor(client2, response, body, options2) {
    _AbstractPage_client.set(this, void 0);
    __classPrivateFieldSet(this, _AbstractPage_client, client2);
    this.options = options2;
    this.response = response;
    this.body = body;
  }
  hasNextPage() {
    const items = this.getPaginatedItems();
    if (!items.length)
      return false;
    return this.nextPageRequestOptions() != null;
  }
  async getNextPage() {
    const nextOptions = this.nextPageRequestOptions();
    if (!nextOptions) {
      throw new OpenAIError("No next page expected; please check `.hasNextPage()` before calling `.getNextPage()`.");
    }
    return await __classPrivateFieldGet(this, _AbstractPage_client, "f").requestAPIList(this.constructor, nextOptions);
  }
  async *iterPages() {
    let page = this;
    yield page;
    while (page.hasNextPage()) {
      page = await page.getNextPage();
      yield page;
    }
  }
  async *[(_AbstractPage_client = /* @__PURE__ */ new WeakMap(), Symbol.asyncIterator)]() {
    for await (const page of this.iterPages()) {
      for (const item of page.getPaginatedItems()) {
        yield item;
      }
    }
  }
}
class PagePromise extends APIPromise {
  constructor(client2, request, Page2) {
    super(client2, request, async (client3, props) => new Page2(client3, props.response, await defaultParseResponse(client3, props), props.options));
  }
  /**
   * Allow auto-paginating iteration on an unawaited list call, eg:
   *
   *    for await (const item of client.items.list()) {
   *      console.log(item)
   *    }
   */
  async *[Symbol.asyncIterator]() {
    const page = await this;
    for await (const item of page) {
      yield item;
    }
  }
}
class Page extends AbstractPage {
  constructor(client2, response, body, options2) {
    super(client2, response, body, options2);
    this.data = body.data || [];
    this.object = body.object;
  }
  getPaginatedItems() {
    return this.data ?? [];
  }
  nextPageRequestOptions() {
    return null;
  }
}
class CursorPage extends AbstractPage {
  constructor(client2, response, body, options2) {
    super(client2, response, body, options2);
    this.data = body.data || [];
    this.has_more = body.has_more || false;
  }
  getPaginatedItems() {
    return this.data ?? [];
  }
  hasNextPage() {
    if (this.has_more === false) {
      return false;
    }
    return super.hasNextPage();
  }
  nextPageRequestOptions() {
    var _a3;
    const data = this.getPaginatedItems();
    const id = (_a3 = data[data.length - 1]) == null ? void 0 : _a3.id;
    if (!id) {
      return null;
    }
    return {
      ...this.options,
      query: {
        ...maybeObj(this.options.query),
        after: id
      }
    };
  }
}
class ConversationCursorPage extends AbstractPage {
  constructor(client2, response, body, options2) {
    super(client2, response, body, options2);
    this.data = body.data || [];
    this.has_more = body.has_more || false;
    this.last_id = body.last_id || "";
  }
  getPaginatedItems() {
    return this.data ?? [];
  }
  hasNextPage() {
    if (this.has_more === false) {
      return false;
    }
    return super.hasNextPage();
  }
  nextPageRequestOptions() {
    const cursor = this.last_id;
    if (!cursor) {
      return null;
    }
    return {
      ...this.options,
      query: {
        ...maybeObj(this.options.query),
        after: cursor
      }
    };
  }
}
const checkFileSupport = () => {
  var _a3;
  if (typeof File === "undefined") {
    const { process: process2 } = globalThis;
    const isOldNode = typeof ((_a3 = process2 == null ? void 0 : process2.versions) == null ? void 0 : _a3.node) === "string" && parseInt(process2.versions.node.split(".")) < 20;
    throw new Error("`File` is not defined as a global, which is required for file uploads." + (isOldNode ? " Update to Node 20 LTS or newer, or set `globalThis.File` to `import('node:buffer').File`." : ""));
  }
};
function makeFile(fileBits, fileName, options2) {
  checkFileSupport();
  return new File(fileBits, fileName ?? "unknown_file", options2);
}
function getName(value) {
  return (typeof value === "object" && value !== null && ("name" in value && value.name && String(value.name) || "url" in value && value.url && String(value.url) || "filename" in value && value.filename && String(value.filename) || "path" in value && value.path && String(value.path)) || "").split(/[\\/]/).pop() || void 0;
}
const isAsyncIterable$1 = (value) => value != null && typeof value === "object" && typeof value[Symbol.asyncIterator] === "function";
const maybeMultipartFormRequestOptions = async (opts, fetch2) => {
  if (!hasUploadableValue(opts.body))
    return opts;
  return { ...opts, body: await createForm(opts.body, fetch2) };
};
const multipartFormRequestOptions = async (opts, fetch2) => {
  return { ...opts, body: await createForm(opts.body, fetch2) };
};
const supportsFormDataMap = /* @__PURE__ */ new WeakMap();
function supportsFormData(fetchObject) {
  const fetch2 = typeof fetchObject === "function" ? fetchObject : fetchObject.fetch;
  const cached2 = supportsFormDataMap.get(fetch2);
  if (cached2)
    return cached2;
  const promise = (async () => {
    try {
      const FetchResponse = "Response" in fetch2 ? fetch2.Response : (await fetch2("data:,")).constructor;
      const data = new FormData();
      if (data.toString() === await new FetchResponse(data).text()) {
        return false;
      }
      return true;
    } catch {
      return true;
    }
  })();
  supportsFormDataMap.set(fetch2, promise);
  return promise;
}
const createForm = async (body, fetch2) => {
  if (!await supportsFormData(fetch2)) {
    throw new TypeError("The provided fetch function does not support file uploads with the current global FormData class.");
  }
  const form = new FormData();
  await Promise.all(Object.entries(body || {}).map(([key, value]) => addFormValue(form, key, value)));
  return form;
};
const isNamedBlob = (value) => value instanceof Blob && "name" in value;
const isUploadable = (value) => typeof value === "object" && value !== null && (value instanceof Response || isAsyncIterable$1(value) || isNamedBlob(value));
const hasUploadableValue = (value) => {
  if (isUploadable(value))
    return true;
  if (Array.isArray(value))
    return value.some(hasUploadableValue);
  if (value && typeof value === "object") {
    for (const k in value) {
      if (hasUploadableValue(value[k]))
        return true;
    }
  }
  return false;
};
const addFormValue = async (form, key, value) => {
  if (value === void 0)
    return;
  if (value == null) {
    throw new TypeError(`Received null for "${key}"; to pass null in FormData, you must use the string 'null'`);
  }
  if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
    form.append(key, String(value));
  } else if (value instanceof Response) {
    form.append(key, makeFile([await value.blob()], getName(value)));
  } else if (isAsyncIterable$1(value)) {
    form.append(key, makeFile([await new Response(ReadableStreamFrom(value)).blob()], getName(value)));
  } else if (isNamedBlob(value)) {
    form.append(key, value, getName(value));
  } else if (Array.isArray(value)) {
    await Promise.all(value.map((entry) => addFormValue(form, key + "[]", entry)));
  } else if (typeof value === "object") {
    await Promise.all(Object.entries(value).map(([name, prop]) => addFormValue(form, `${key}[${name}]`, prop)));
  } else {
    throw new TypeError(`Invalid value given to form, expected a string, number, boolean, object, Array, File or Blob but got ${value} instead`);
  }
};
const isBlobLike = (value) => value != null && typeof value === "object" && typeof value.size === "number" && typeof value.type === "string" && typeof value.text === "function" && typeof value.slice === "function" && typeof value.arrayBuffer === "function";
const isFileLike = (value) => value != null && typeof value === "object" && typeof value.name === "string" && typeof value.lastModified === "number" && isBlobLike(value);
const isResponseLike = (value) => value != null && typeof value === "object" && typeof value.url === "string" && typeof value.blob === "function";
async function toFile(value, name, options2) {
  checkFileSupport();
  value = await value;
  if (isFileLike(value)) {
    if (value instanceof File) {
      return value;
    }
    return makeFile([await value.arrayBuffer()], value.name);
  }
  if (isResponseLike(value)) {
    const blob = await value.blob();
    name || (name = new URL(value.url).pathname.split(/[\\/]/).pop());
    return makeFile(await getBytes(blob), name, options2);
  }
  const parts = await getBytes(value);
  name || (name = getName(value));
  if (!(options2 == null ? void 0 : options2.type)) {
    const type = parts.find((part) => typeof part === "object" && "type" in part && part.type);
    if (typeof type === "string") {
      options2 = { ...options2, type };
    }
  }
  return makeFile(parts, name, options2);
}
async function getBytes(value) {
  var _a3;
  let parts = [];
  if (typeof value === "string" || ArrayBuffer.isView(value) || // includes Uint8Array, Buffer, etc.
  value instanceof ArrayBuffer) {
    parts.push(value);
  } else if (isBlobLike(value)) {
    parts.push(value instanceof Blob ? value : await value.arrayBuffer());
  } else if (isAsyncIterable$1(value)) {
    for await (const chunk of value) {
      parts.push(...await getBytes(chunk));
    }
  } else {
    const constructor = (_a3 = value == null ? void 0 : value.constructor) == null ? void 0 : _a3.name;
    throw new Error(`Unexpected data type: ${typeof value}${constructor ? `; constructor: ${constructor}` : ""}${propsForError(value)}`);
  }
  return parts;
}
function propsForError(value) {
  if (typeof value !== "object" || value === null)
    return "";
  const props = Object.getOwnPropertyNames(value);
  return `; props: [${props.map((p) => `"${p}"`).join(", ")}]`;
}
class APIResource {
  constructor(client2) {
    this._client = client2;
  }
}
function encodeURIPath(str2) {
  return str2.replace(/[^A-Za-z0-9\-._~!$&'()*+,;=:@]+/g, encodeURIComponent);
}
const EMPTY = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.create(null));
const createPathTagFunction = (pathEncoder = encodeURIPath) => function path2(statics, ...params) {
  if (statics.length === 1)
    return statics[0];
  let postPath = false;
  const invalidSegments = [];
  const path3 = statics.reduce((previousValue, currentValue, index) => {
    var _a3;
    if (/[?#]/.test(currentValue)) {
      postPath = true;
    }
    const value = params[index];
    let encoded = (postPath ? encodeURIComponent : pathEncoder)("" + value);
    if (index !== params.length && (value == null || typeof value === "object" && // handle values from other realms
    value.toString === ((_a3 = Object.getPrototypeOf(Object.getPrototypeOf(value.hasOwnProperty ?? EMPTY) ?? EMPTY)) == null ? void 0 : _a3.toString))) {
      encoded = value + "";
      invalidSegments.push({
        start: previousValue.length + currentValue.length,
        length: encoded.length,
        error: `Value of type ${Object.prototype.toString.call(value).slice(8, -1)} is not a valid path parameter`
      });
    }
    return previousValue + currentValue + (index === params.length ? "" : encoded);
  }, "");
  const pathOnly = path3.split(/[?#]/, 1)[0];
  const invalidSegmentPattern = new RegExp("(?<=^|\\/)(?:\\.|%2e){1,2}(?=\\/|$)", "gi");
  let match;
  while ((match = invalidSegmentPattern.exec(pathOnly)) !== null) {
    invalidSegments.push({
      start: match.index,
      length: match[0].length,
      error: `Value "${match[0]}" can't be safely passed as a path parameter`
    });
  }
  invalidSegments.sort((a, b) => a.start - b.start);
  if (invalidSegments.length > 0) {
    let lastEnd = 0;
    const underline = invalidSegments.reduce((acc, segment) => {
      const spaces = " ".repeat(segment.start - lastEnd);
      const arrows = "^".repeat(segment.length);
      lastEnd = segment.start + segment.length;
      return acc + spaces + arrows;
    }, "");
    throw new OpenAIError(`Path parameters result in path with invalid segments:
${invalidSegments.map((e) => e.error).join("\n")}
${path3}
${underline}`);
  }
  return path3;
};
const path$1 = /* @__PURE__ */ createPathTagFunction(encodeURIPath);
let Messages$1 = class Messages2 extends APIResource {
  /**
   * Get the messages in a stored chat completion. Only Chat Completions that have
   * been created with the `store` parameter set to `true` will be returned.
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const chatCompletionStoreMessage of client.chat.completions.messages.list(
   *   'completion_id',
   * )) {
   *   // ...
   * }
   * ```
   */
  list(completionID, query = {}, options2) {
    return this._client.getAPIList(path$1`/chat/completions/${completionID}/messages`, CursorPage, { query, ...options2 });
  }
};
function isChatCompletionFunctionTool(tool2) {
  return tool2 !== void 0 && "function" in tool2 && tool2.function !== void 0;
}
function makeParseableResponseFormat$1(response_format, parser) {
  const obj = { ...response_format };
  Object.defineProperties(obj, {
    $brand: {
      value: "auto-parseable-response-format",
      enumerable: false
    },
    $parseRaw: {
      value: parser,
      enumerable: false
    }
  });
  return obj;
}
function isAutoParsableResponseFormat(response_format) {
  return (response_format == null ? void 0 : response_format["$brand"]) === "auto-parseable-response-format";
}
function isAutoParsableTool$1(tool2) {
  return (tool2 == null ? void 0 : tool2["$brand"]) === "auto-parseable-tool";
}
function maybeParseChatCompletion(completion, params) {
  if (!params || !hasAutoParseableInput$1(params)) {
    return {
      ...completion,
      choices: completion.choices.map((choice) => {
        assertToolCallsAreChatCompletionFunctionToolCalls(choice.message.tool_calls);
        return {
          ...choice,
          message: {
            ...choice.message,
            parsed: null,
            ...choice.message.tool_calls ? {
              tool_calls: choice.message.tool_calls
            } : void 0
          }
        };
      })
    };
  }
  return parseChatCompletion(completion, params);
}
function parseChatCompletion(completion, params) {
  const choices = completion.choices.map((choice) => {
    var _a3;
    if (choice.finish_reason === "length") {
      throw new LengthFinishReasonError();
    }
    if (choice.finish_reason === "content_filter") {
      throw new ContentFilterFinishReasonError();
    }
    assertToolCallsAreChatCompletionFunctionToolCalls(choice.message.tool_calls);
    return {
      ...choice,
      message: {
        ...choice.message,
        ...choice.message.tool_calls ? {
          tool_calls: ((_a3 = choice.message.tool_calls) == null ? void 0 : _a3.map((toolCall) => parseToolCall$2(params, toolCall))) ?? void 0
        } : void 0,
        parsed: choice.message.content && !choice.message.refusal ? parseResponseFormat(params, choice.message.content) : null
      }
    };
  });
  return { ...completion, choices };
}
function parseResponseFormat(params, content) {
  var _a3, _b;
  if (((_a3 = params.response_format) == null ? void 0 : _a3.type) !== "json_schema") {
    return null;
  }
  if (((_b = params.response_format) == null ? void 0 : _b.type) === "json_schema") {
    if ("$parseRaw" in params.response_format) {
      const response_format = params.response_format;
      return response_format.$parseRaw(content);
    }
    return JSON.parse(content);
  }
  return null;
}
function parseToolCall$2(params, toolCall) {
  var _a3;
  const inputTool = (_a3 = params.tools) == null ? void 0 : _a3.find((inputTool2) => {
    var _a4;
    return isChatCompletionFunctionTool(inputTool2) && ((_a4 = inputTool2.function) == null ? void 0 : _a4.name) === toolCall.function.name;
  });
  return {
    ...toolCall,
    function: {
      ...toolCall.function,
      parsed_arguments: isAutoParsableTool$1(inputTool) ? inputTool.$parseRaw(toolCall.function.arguments) : (inputTool == null ? void 0 : inputTool.function.strict) ? JSON.parse(toolCall.function.arguments) : null
    }
  };
}
function shouldParseToolCall(params, toolCall) {
  var _a3;
  if (!params || !("tools" in params) || !params.tools) {
    return false;
  }
  const inputTool = (_a3 = params.tools) == null ? void 0 : _a3.find((inputTool2) => {
    var _a4;
    return isChatCompletionFunctionTool(inputTool2) && ((_a4 = inputTool2.function) == null ? void 0 : _a4.name) === toolCall.function.name;
  });
  return isChatCompletionFunctionTool(inputTool) && (isAutoParsableTool$1(inputTool) || (inputTool == null ? void 0 : inputTool.function.strict) || false);
}
function hasAutoParseableInput$1(params) {
  var _a3;
  if (isAutoParsableResponseFormat(params.response_format)) {
    return true;
  }
  return ((_a3 = params.tools) == null ? void 0 : _a3.some((t2) => isAutoParsableTool$1(t2) || t2.type === "function" && t2.function.strict === true)) ?? false;
}
function assertToolCallsAreChatCompletionFunctionToolCalls(toolCalls) {
  for (const toolCall of toolCalls || []) {
    if (toolCall.type !== "function") {
      throw new OpenAIError(`Currently only \`function\` tool calls are supported; Received \`${toolCall.type}\``);
    }
  }
}
function validateInputTools(tools) {
  for (const tool2 of tools ?? []) {
    if (tool2.type !== "function") {
      throw new OpenAIError(`Currently only \`function\` tool types support auto-parsing; Received \`${tool2.type}\``);
    }
    if (tool2.function.strict !== true) {
      throw new OpenAIError(`The \`${tool2.function.name}\` tool is not marked with \`strict: true\`. Only strict function tools can be auto-parsed`);
    }
  }
}
const isAssistantMessage = (message) => {
  return (message == null ? void 0 : message.role) === "assistant";
};
const isToolMessage$1 = (message) => {
  return (message == null ? void 0 : message.role) === "tool";
};
var _EventStream_instances, _EventStream_connectedPromise, _EventStream_resolveConnectedPromise, _EventStream_rejectConnectedPromise, _EventStream_endPromise, _EventStream_resolveEndPromise, _EventStream_rejectEndPromise, _EventStream_listeners, _EventStream_ended, _EventStream_errored, _EventStream_aborted, _EventStream_catchingPromiseCreated, _EventStream_handleError;
class EventStream {
  constructor() {
    _EventStream_instances.add(this);
    this.controller = new AbortController();
    _EventStream_connectedPromise.set(this, void 0);
    _EventStream_resolveConnectedPromise.set(this, () => {
    });
    _EventStream_rejectConnectedPromise.set(this, () => {
    });
    _EventStream_endPromise.set(this, void 0);
    _EventStream_resolveEndPromise.set(this, () => {
    });
    _EventStream_rejectEndPromise.set(this, () => {
    });
    _EventStream_listeners.set(this, {});
    _EventStream_ended.set(this, false);
    _EventStream_errored.set(this, false);
    _EventStream_aborted.set(this, false);
    _EventStream_catchingPromiseCreated.set(this, false);
    __classPrivateFieldSet(this, _EventStream_connectedPromise, new Promise((resolve, reject) => {
      __classPrivateFieldSet(this, _EventStream_resolveConnectedPromise, resolve, "f");
      __classPrivateFieldSet(this, _EventStream_rejectConnectedPromise, reject, "f");
    }));
    __classPrivateFieldSet(this, _EventStream_endPromise, new Promise((resolve, reject) => {
      __classPrivateFieldSet(this, _EventStream_resolveEndPromise, resolve, "f");
      __classPrivateFieldSet(this, _EventStream_rejectEndPromise, reject, "f");
    }));
    __classPrivateFieldGet(this, _EventStream_connectedPromise, "f").catch(() => {
    });
    __classPrivateFieldGet(this, _EventStream_endPromise, "f").catch(() => {
    });
  }
  _run(executor) {
    setTimeout(() => {
      executor().then(() => {
        this._emitFinal();
        this._emit("end");
      }, __classPrivateFieldGet(this, _EventStream_instances, "m", _EventStream_handleError).bind(this));
    }, 0);
  }
  _connected() {
    if (this.ended)
      return;
    __classPrivateFieldGet(this, _EventStream_resolveConnectedPromise, "f").call(this);
    this._emit("connect");
  }
  get ended() {
    return __classPrivateFieldGet(this, _EventStream_ended, "f");
  }
  get errored() {
    return __classPrivateFieldGet(this, _EventStream_errored, "f");
  }
  get aborted() {
    return __classPrivateFieldGet(this, _EventStream_aborted, "f");
  }
  abort() {
    this.controller.abort();
  }
  /**
   * Adds the listener function to the end of the listeners array for the event.
   * No checks are made to see if the listener has already been added. Multiple calls passing
   * the same combination of event and listener will result in the listener being added, and
   * called, multiple times.
   * @returns this ChatCompletionStream, so that calls can be chained
   */
  on(event, listener) {
    const listeners = __classPrivateFieldGet(this, _EventStream_listeners, "f")[event] || (__classPrivateFieldGet(this, _EventStream_listeners, "f")[event] = []);
    listeners.push({ listener });
    return this;
  }
  /**
   * Removes the specified listener from the listener array for the event.
   * off() will remove, at most, one instance of a listener from the listener array. If any single
   * listener has been added multiple times to the listener array for the specified event, then
   * off() must be called multiple times to remove each instance.
   * @returns this ChatCompletionStream, so that calls can be chained
   */
  off(event, listener) {
    const listeners = __classPrivateFieldGet(this, _EventStream_listeners, "f")[event];
    if (!listeners)
      return this;
    const index = listeners.findIndex((l) => l.listener === listener);
    if (index >= 0)
      listeners.splice(index, 1);
    return this;
  }
  /**
   * Adds a one-time listener function for the event. The next time the event is triggered,
   * this listener is removed and then invoked.
   * @returns this ChatCompletionStream, so that calls can be chained
   */
  once(event, listener) {
    const listeners = __classPrivateFieldGet(this, _EventStream_listeners, "f")[event] || (__classPrivateFieldGet(this, _EventStream_listeners, "f")[event] = []);
    listeners.push({ listener, once: true });
    return this;
  }
  /**
   * This is similar to `.once()`, but returns a Promise that resolves the next time
   * the event is triggered, instead of calling a listener callback.
   * @returns a Promise that resolves the next time given event is triggered,
   * or rejects if an error is emitted.  (If you request the 'error' event,
   * returns a promise that resolves with the error).
   *
   * Example:
   *
   *   const message = await stream.emitted('message') // rejects if the stream errors
   */
  emitted(event) {
    return new Promise((resolve, reject) => {
      __classPrivateFieldSet(this, _EventStream_catchingPromiseCreated, true);
      if (event !== "error")
        this.once("error", reject);
      this.once(event, resolve);
    });
  }
  async done() {
    __classPrivateFieldSet(this, _EventStream_catchingPromiseCreated, true);
    await __classPrivateFieldGet(this, _EventStream_endPromise, "f");
  }
  _emit(event, ...args) {
    if (__classPrivateFieldGet(this, _EventStream_ended, "f")) {
      return;
    }
    if (event === "end") {
      __classPrivateFieldSet(this, _EventStream_ended, true);
      __classPrivateFieldGet(this, _EventStream_resolveEndPromise, "f").call(this);
    }
    const listeners = __classPrivateFieldGet(this, _EventStream_listeners, "f")[event];
    if (listeners) {
      __classPrivateFieldGet(this, _EventStream_listeners, "f")[event] = listeners.filter((l) => !l.once);
      listeners.forEach(({ listener }) => listener(...args));
    }
    if (event === "abort") {
      const error = args[0];
      if (!__classPrivateFieldGet(this, _EventStream_catchingPromiseCreated, "f") && !(listeners == null ? void 0 : listeners.length)) {
        Promise.reject(error);
      }
      __classPrivateFieldGet(this, _EventStream_rejectConnectedPromise, "f").call(this, error);
      __classPrivateFieldGet(this, _EventStream_rejectEndPromise, "f").call(this, error);
      this._emit("end");
      return;
    }
    if (event === "error") {
      const error = args[0];
      if (!__classPrivateFieldGet(this, _EventStream_catchingPromiseCreated, "f") && !(listeners == null ? void 0 : listeners.length)) {
        Promise.reject(error);
      }
      __classPrivateFieldGet(this, _EventStream_rejectConnectedPromise, "f").call(this, error);
      __classPrivateFieldGet(this, _EventStream_rejectEndPromise, "f").call(this, error);
      this._emit("end");
    }
  }
  _emitFinal() {
  }
}
_EventStream_connectedPromise = /* @__PURE__ */ new WeakMap(), _EventStream_resolveConnectedPromise = /* @__PURE__ */ new WeakMap(), _EventStream_rejectConnectedPromise = /* @__PURE__ */ new WeakMap(), _EventStream_endPromise = /* @__PURE__ */ new WeakMap(), _EventStream_resolveEndPromise = /* @__PURE__ */ new WeakMap(), _EventStream_rejectEndPromise = /* @__PURE__ */ new WeakMap(), _EventStream_listeners = /* @__PURE__ */ new WeakMap(), _EventStream_ended = /* @__PURE__ */ new WeakMap(), _EventStream_errored = /* @__PURE__ */ new WeakMap(), _EventStream_aborted = /* @__PURE__ */ new WeakMap(), _EventStream_catchingPromiseCreated = /* @__PURE__ */ new WeakMap(), _EventStream_instances = /* @__PURE__ */ new WeakSet(), _EventStream_handleError = function _EventStream_handleError2(error) {
  __classPrivateFieldSet(this, _EventStream_errored, true);
  if (error instanceof Error && error.name === "AbortError") {
    error = new APIUserAbortError();
  }
  if (error instanceof APIUserAbortError) {
    __classPrivateFieldSet(this, _EventStream_aborted, true);
    return this._emit("abort", error);
  }
  if (error instanceof OpenAIError) {
    return this._emit("error", error);
  }
  if (error instanceof Error) {
    const openAIError = new OpenAIError(error.message);
    openAIError.cause = error;
    return this._emit("error", openAIError);
  }
  return this._emit("error", new OpenAIError(String(error)));
};
function isRunnableFunctionWithParse(fn) {
  return typeof fn.parse === "function";
}
var _AbstractChatCompletionRunner_instances, _AbstractChatCompletionRunner_getFinalContent, _AbstractChatCompletionRunner_getFinalMessage, _AbstractChatCompletionRunner_getFinalFunctionToolCall, _AbstractChatCompletionRunner_getFinalFunctionToolCallResult, _AbstractChatCompletionRunner_calculateTotalUsage, _AbstractChatCompletionRunner_validateParams, _AbstractChatCompletionRunner_stringifyFunctionCallResult;
const DEFAULT_MAX_CHAT_COMPLETIONS = 10;
class AbstractChatCompletionRunner extends EventStream {
  constructor() {
    super(...arguments);
    _AbstractChatCompletionRunner_instances.add(this);
    this._chatCompletions = [];
    this.messages = [];
  }
  _addChatCompletion(chatCompletion) {
    var _a3;
    this._chatCompletions.push(chatCompletion);
    this._emit("chatCompletion", chatCompletion);
    const message = (_a3 = chatCompletion.choices[0]) == null ? void 0 : _a3.message;
    if (message)
      this._addMessage(message);
    return chatCompletion;
  }
  _addMessage(message, emit = true) {
    if (!("content" in message))
      message.content = null;
    this.messages.push(message);
    if (emit) {
      this._emit("message", message);
      if (isToolMessage$1(message) && message.content) {
        this._emit("functionToolCallResult", message.content);
      } else if (isAssistantMessage(message) && message.tool_calls) {
        for (const tool_call of message.tool_calls) {
          if (tool_call.type === "function") {
            this._emit("functionToolCall", tool_call.function);
          }
        }
      }
    }
  }
  /**
   * @returns a promise that resolves with the final ChatCompletion, or rejects
   * if an error occurred or the stream ended prematurely without producing a ChatCompletion.
   */
  async finalChatCompletion() {
    await this.done();
    const completion = this._chatCompletions[this._chatCompletions.length - 1];
    if (!completion)
      throw new OpenAIError("stream ended without producing a ChatCompletion");
    return completion;
  }
  /**
   * @returns a promise that resolves with the content of the final ChatCompletionMessage, or rejects
   * if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.
   */
  async finalContent() {
    await this.done();
    return __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalContent).call(this);
  }
  /**
   * @returns a promise that resolves with the the final assistant ChatCompletionMessage response,
   * or rejects if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.
   */
  async finalMessage() {
    await this.done();
    return __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalMessage).call(this);
  }
  /**
   * @returns a promise that resolves with the content of the final FunctionCall, or rejects
   * if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.
   */
  async finalFunctionToolCall() {
    await this.done();
    return __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalFunctionToolCall).call(this);
  }
  async finalFunctionToolCallResult() {
    await this.done();
    return __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalFunctionToolCallResult).call(this);
  }
  async totalUsage() {
    await this.done();
    return __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_calculateTotalUsage).call(this);
  }
  allChatCompletions() {
    return [...this._chatCompletions];
  }
  _emitFinal() {
    const completion = this._chatCompletions[this._chatCompletions.length - 1];
    if (completion)
      this._emit("finalChatCompletion", completion);
    const finalMessage = __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalMessage).call(this);
    if (finalMessage)
      this._emit("finalMessage", finalMessage);
    const finalContent = __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalContent).call(this);
    if (finalContent)
      this._emit("finalContent", finalContent);
    const finalFunctionCall = __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalFunctionToolCall).call(this);
    if (finalFunctionCall)
      this._emit("finalFunctionToolCall", finalFunctionCall);
    const finalFunctionCallResult = __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalFunctionToolCallResult).call(this);
    if (finalFunctionCallResult != null)
      this._emit("finalFunctionToolCallResult", finalFunctionCallResult);
    if (this._chatCompletions.some((c) => c.usage)) {
      this._emit("totalUsage", __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_calculateTotalUsage).call(this));
    }
  }
  async _createChatCompletion(client2, params, options2) {
    const signal = options2 == null ? void 0 : options2.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_validateParams).call(this, params);
    const chatCompletion = await client2.chat.completions.create({ ...params, stream: false }, { ...options2, signal: this.controller.signal });
    this._connected();
    return this._addChatCompletion(parseChatCompletion(chatCompletion, params));
  }
  async _runChatCompletion(client2, params, options2) {
    for (const message of params.messages) {
      this._addMessage(message, false);
    }
    return await this._createChatCompletion(client2, params, options2);
  }
  async _runTools(client2, params, options2) {
    var _a3, _b, _c;
    const role = "tool";
    const { tool_choice = "auto", stream, ...restParams } = params;
    const singleFunctionToCall = typeof tool_choice !== "string" && tool_choice.type === "function" && ((_a3 = tool_choice == null ? void 0 : tool_choice.function) == null ? void 0 : _a3.name);
    const { maxChatCompletions = DEFAULT_MAX_CHAT_COMPLETIONS } = options2 || {};
    const inputTools = params.tools.map((tool2) => {
      if (isAutoParsableTool$1(tool2)) {
        if (!tool2.$callback) {
          throw new OpenAIError("Tool given to `.runTools()` that does not have an associated function");
        }
        return {
          type: "function",
          function: {
            function: tool2.$callback,
            name: tool2.function.name,
            description: tool2.function.description || "",
            parameters: tool2.function.parameters,
            parse: tool2.$parseRaw,
            strict: true
          }
        };
      }
      return tool2;
    });
    const functionsByName = {};
    for (const f of inputTools) {
      if (f.type === "function") {
        functionsByName[f.function.name || f.function.function.name] = f.function;
      }
    }
    const tools = "tools" in params ? inputTools.map((t2) => t2.type === "function" ? {
      type: "function",
      function: {
        name: t2.function.name || t2.function.function.name,
        parameters: t2.function.parameters,
        description: t2.function.description,
        strict: t2.function.strict
      }
    } : t2) : void 0;
    for (const message of params.messages) {
      this._addMessage(message, false);
    }
    for (let i2 = 0; i2 < maxChatCompletions; ++i2) {
      const chatCompletion = await this._createChatCompletion(client2, {
        ...restParams,
        tool_choice,
        tools,
        messages: [...this.messages]
      }, options2);
      const message = (_b = chatCompletion.choices[0]) == null ? void 0 : _b.message;
      if (!message) {
        throw new OpenAIError(`missing message in ChatCompletion response`);
      }
      if (!((_c = message.tool_calls) == null ? void 0 : _c.length)) {
        return;
      }
      for (const tool_call of message.tool_calls) {
        if (tool_call.type !== "function")
          continue;
        const tool_call_id = tool_call.id;
        const { name, arguments: args } = tool_call.function;
        const fn = functionsByName[name];
        if (!fn) {
          const content2 = `Invalid tool_call: ${JSON.stringify(name)}. Available options are: ${Object.keys(functionsByName).map((name2) => JSON.stringify(name2)).join(", ")}. Please try again`;
          this._addMessage({ role, tool_call_id, content: content2 });
          continue;
        } else if (singleFunctionToCall && singleFunctionToCall !== name) {
          const content2 = `Invalid tool_call: ${JSON.stringify(name)}. ${JSON.stringify(singleFunctionToCall)} requested. Please try again`;
          this._addMessage({ role, tool_call_id, content: content2 });
          continue;
        }
        let parsed;
        try {
          parsed = isRunnableFunctionWithParse(fn) ? await fn.parse(args) : args;
        } catch (error) {
          const content2 = error instanceof Error ? error.message : String(error);
          this._addMessage({ role, tool_call_id, content: content2 });
          continue;
        }
        const rawContent = await fn.function(parsed, this);
        const content = __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_stringifyFunctionCallResult).call(this, rawContent);
        this._addMessage({ role, tool_call_id, content });
        if (singleFunctionToCall) {
          return;
        }
      }
    }
    return;
  }
}
_AbstractChatCompletionRunner_instances = /* @__PURE__ */ new WeakSet(), _AbstractChatCompletionRunner_getFinalContent = function _AbstractChatCompletionRunner_getFinalContent2() {
  return __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalMessage).call(this).content ?? null;
}, _AbstractChatCompletionRunner_getFinalMessage = function _AbstractChatCompletionRunner_getFinalMessage2() {
  let i2 = this.messages.length;
  while (i2-- > 0) {
    const message = this.messages[i2];
    if (isAssistantMessage(message)) {
      const ret = {
        ...message,
        content: message.content ?? null,
        refusal: message.refusal ?? null
      };
      return ret;
    }
  }
  throw new OpenAIError("stream ended without producing a ChatCompletionMessage with role=assistant");
}, _AbstractChatCompletionRunner_getFinalFunctionToolCall = function _AbstractChatCompletionRunner_getFinalFunctionToolCall2() {
  var _a3, _b;
  for (let i2 = this.messages.length - 1; i2 >= 0; i2--) {
    const message = this.messages[i2];
    if (isAssistantMessage(message) && ((_a3 = message == null ? void 0 : message.tool_calls) == null ? void 0 : _a3.length)) {
      return (_b = message.tool_calls.filter((x) => x.type === "function").at(-1)) == null ? void 0 : _b.function;
    }
  }
  return;
}, _AbstractChatCompletionRunner_getFinalFunctionToolCallResult = function _AbstractChatCompletionRunner_getFinalFunctionToolCallResult2() {
  for (let i2 = this.messages.length - 1; i2 >= 0; i2--) {
    const message = this.messages[i2];
    if (isToolMessage$1(message) && message.content != null && typeof message.content === "string" && this.messages.some((x) => {
      var _a3;
      return x.role === "assistant" && ((_a3 = x.tool_calls) == null ? void 0 : _a3.some((y) => y.type === "function" && y.id === message.tool_call_id));
    })) {
      return message.content;
    }
  }
  return;
}, _AbstractChatCompletionRunner_calculateTotalUsage = function _AbstractChatCompletionRunner_calculateTotalUsage2() {
  const total = {
    completion_tokens: 0,
    prompt_tokens: 0,
    total_tokens: 0
  };
  for (const { usage } of this._chatCompletions) {
    if (usage) {
      total.completion_tokens += usage.completion_tokens;
      total.prompt_tokens += usage.prompt_tokens;
      total.total_tokens += usage.total_tokens;
    }
  }
  return total;
}, _AbstractChatCompletionRunner_validateParams = function _AbstractChatCompletionRunner_validateParams2(params) {
  if (params.n != null && params.n > 1) {
    throw new OpenAIError("ChatCompletion convenience helpers only support n=1 at this time. To use n>1, please use chat.completions.create() directly.");
  }
}, _AbstractChatCompletionRunner_stringifyFunctionCallResult = function _AbstractChatCompletionRunner_stringifyFunctionCallResult2(rawContent) {
  return typeof rawContent === "string" ? rawContent : rawContent === void 0 ? "undefined" : JSON.stringify(rawContent);
};
class ChatCompletionRunner extends AbstractChatCompletionRunner {
  static runTools(client2, params, options2) {
    const runner = new ChatCompletionRunner();
    const opts = {
      ...options2,
      headers: { ...options2 == null ? void 0 : options2.headers, "X-Stainless-Helper-Method": "runTools" }
    };
    runner._run(() => runner._runTools(client2, params, opts));
    return runner;
  }
  _addMessage(message, emit = true) {
    super._addMessage(message, emit);
    if (isAssistantMessage(message) && message.content) {
      this._emit("content", message.content);
    }
  }
}
const STR = 1;
const NUM = 2;
const ARR = 4;
const OBJ = 8;
const NULL = 16;
const BOOL = 32;
const NAN = 64;
const INFINITY = 128;
const MINUS_INFINITY = 256;
const INF = INFINITY | MINUS_INFINITY;
const SPECIAL = NULL | BOOL | INF | NAN;
const ATOM = STR | NUM | SPECIAL;
const COLLECTION = ARR | OBJ;
const ALL = ATOM | COLLECTION;
const Allow = {
  STR,
  NUM,
  ARR,
  OBJ,
  NULL,
  BOOL,
  NAN,
  INFINITY,
  MINUS_INFINITY,
  INF,
  SPECIAL,
  ATOM,
  COLLECTION,
  ALL
};
class PartialJSON extends Error {
}
class MalformedJSON extends Error {
}
function parseJSON(jsonString, allowPartial = Allow.ALL) {
  if (typeof jsonString !== "string") {
    throw new TypeError(`expecting str, got ${typeof jsonString}`);
  }
  if (!jsonString.trim()) {
    throw new Error(`${jsonString} is empty`);
  }
  return _parseJSON(jsonString.trim(), allowPartial);
}
const _parseJSON = (jsonString, allow) => {
  const length = jsonString.length;
  let index = 0;
  const markPartialJSON = (msg) => {
    throw new PartialJSON(`${msg} at position ${index}`);
  };
  const throwMalformedError = (msg) => {
    throw new MalformedJSON(`${msg} at position ${index}`);
  };
  const parseAny = () => {
    skipBlank();
    if (index >= length)
      markPartialJSON("Unexpected end of input");
    if (jsonString[index] === '"')
      return parseStr();
    if (jsonString[index] === "{")
      return parseObj();
    if (jsonString[index] === "[")
      return parseArr();
    if (jsonString.substring(index, index + 4) === "null" || Allow.NULL & allow && length - index < 4 && "null".startsWith(jsonString.substring(index))) {
      index += 4;
      return null;
    }
    if (jsonString.substring(index, index + 4) === "true" || Allow.BOOL & allow && length - index < 4 && "true".startsWith(jsonString.substring(index))) {
      index += 4;
      return true;
    }
    if (jsonString.substring(index, index + 5) === "false" || Allow.BOOL & allow && length - index < 5 && "false".startsWith(jsonString.substring(index))) {
      index += 5;
      return false;
    }
    if (jsonString.substring(index, index + 8) === "Infinity" || Allow.INFINITY & allow && length - index < 8 && "Infinity".startsWith(jsonString.substring(index))) {
      index += 8;
      return Infinity;
    }
    if (jsonString.substring(index, index + 9) === "-Infinity" || Allow.MINUS_INFINITY & allow && 1 < length - index && length - index < 9 && "-Infinity".startsWith(jsonString.substring(index))) {
      index += 9;
      return -Infinity;
    }
    if (jsonString.substring(index, index + 3) === "NaN" || Allow.NAN & allow && length - index < 3 && "NaN".startsWith(jsonString.substring(index))) {
      index += 3;
      return NaN;
    }
    return parseNum();
  };
  const parseStr = () => {
    const start = index;
    let escape2 = false;
    index++;
    while (index < length && (jsonString[index] !== '"' || escape2 && jsonString[index - 1] === "\\")) {
      escape2 = jsonString[index] === "\\" ? !escape2 : false;
      index++;
    }
    if (jsonString.charAt(index) == '"') {
      try {
        return JSON.parse(jsonString.substring(start, ++index - Number(escape2)));
      } catch (e) {
        throwMalformedError(String(e));
      }
    } else if (Allow.STR & allow) {
      try {
        return JSON.parse(jsonString.substring(start, index - Number(escape2)) + '"');
      } catch (e) {
        return JSON.parse(jsonString.substring(start, jsonString.lastIndexOf("\\")) + '"');
      }
    }
    markPartialJSON("Unterminated string literal");
  };
  const parseObj = () => {
    index++;
    skipBlank();
    const obj = {};
    try {
      while (jsonString[index] !== "}") {
        skipBlank();
        if (index >= length && Allow.OBJ & allow)
          return obj;
        const key = parseStr();
        skipBlank();
        index++;
        try {
          const value = parseAny();
          Object.defineProperty(obj, key, { value, writable: true, enumerable: true, configurable: true });
        } catch (e) {
          if (Allow.OBJ & allow)
            return obj;
          else
            throw e;
        }
        skipBlank();
        if (jsonString[index] === ",")
          index++;
      }
    } catch (e) {
      if (Allow.OBJ & allow)
        return obj;
      else
        markPartialJSON("Expected '}' at end of object");
    }
    index++;
    return obj;
  };
  const parseArr = () => {
    index++;
    const arr2 = [];
    try {
      while (jsonString[index] !== "]") {
        arr2.push(parseAny());
        skipBlank();
        if (jsonString[index] === ",") {
          index++;
        }
      }
    } catch (e) {
      if (Allow.ARR & allow) {
        return arr2;
      }
      markPartialJSON("Expected ']' at end of array");
    }
    index++;
    return arr2;
  };
  const parseNum = () => {
    if (index === 0) {
      if (jsonString === "-" && Allow.NUM & allow)
        markPartialJSON("Not sure what '-' is");
      try {
        return JSON.parse(jsonString);
      } catch (e) {
        if (Allow.NUM & allow) {
          try {
            if ("." === jsonString[jsonString.length - 1])
              return JSON.parse(jsonString.substring(0, jsonString.lastIndexOf(".")));
            return JSON.parse(jsonString.substring(0, jsonString.lastIndexOf("e")));
          } catch (e2) {
          }
        }
        throwMalformedError(String(e));
      }
    }
    const start = index;
    if (jsonString[index] === "-")
      index++;
    while (jsonString[index] && !",]}".includes(jsonString[index]))
      index++;
    if (index == length && !(Allow.NUM & allow))
      markPartialJSON("Unterminated number literal");
    try {
      return JSON.parse(jsonString.substring(start, index));
    } catch (e) {
      if (jsonString.substring(start, index) === "-" && Allow.NUM & allow)
        markPartialJSON("Not sure what '-' is");
      try {
        return JSON.parse(jsonString.substring(start, jsonString.lastIndexOf("e")));
      } catch (e2) {
        throwMalformedError(String(e2));
      }
    }
  };
  const skipBlank = () => {
    while (index < length && " \n\r	".includes(jsonString[index])) {
      index++;
    }
  };
  return parseAny();
};
const partialParse = (input) => parseJSON(input, Allow.ALL ^ Allow.NUM);
var _ChatCompletionStream_instances, _ChatCompletionStream_params, _ChatCompletionStream_choiceEventStates, _ChatCompletionStream_currentChatCompletionSnapshot, _ChatCompletionStream_beginRequest, _ChatCompletionStream_getChoiceEventState, _ChatCompletionStream_addChunk, _ChatCompletionStream_emitToolCallDoneEvent, _ChatCompletionStream_emitContentDoneEvents, _ChatCompletionStream_endRequest, _ChatCompletionStream_getAutoParseableResponseFormat, _ChatCompletionStream_accumulateChatCompletion;
class ChatCompletionStream extends AbstractChatCompletionRunner {
  constructor(params) {
    super();
    _ChatCompletionStream_instances.add(this);
    _ChatCompletionStream_params.set(this, void 0);
    _ChatCompletionStream_choiceEventStates.set(this, void 0);
    _ChatCompletionStream_currentChatCompletionSnapshot.set(this, void 0);
    __classPrivateFieldSet(this, _ChatCompletionStream_params, params);
    __classPrivateFieldSet(this, _ChatCompletionStream_choiceEventStates, []);
  }
  get currentChatCompletionSnapshot() {
    return __classPrivateFieldGet(this, _ChatCompletionStream_currentChatCompletionSnapshot, "f");
  }
  /**
   * Intended for use on the frontend, consuming a stream produced with
   * `.toReadableStream()` on the backend.
   *
   * Note that messages sent to the model do not appear in `.on('message')`
   * in this context.
   */
  static fromReadableStream(stream) {
    const runner = new ChatCompletionStream(null);
    runner._run(() => runner._fromReadableStream(stream));
    return runner;
  }
  static createChatCompletion(client2, params, options2) {
    const runner = new ChatCompletionStream(params);
    runner._run(() => runner._runChatCompletion(client2, { ...params, stream: true }, { ...options2, headers: { ...options2 == null ? void 0 : options2.headers, "X-Stainless-Helper-Method": "stream" } }));
    return runner;
  }
  async _createChatCompletion(client2, params, options2) {
    var _a3;
    super._createChatCompletion;
    const signal = options2 == null ? void 0 : options2.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    __classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_beginRequest).call(this);
    const stream = await client2.chat.completions.create({ ...params, stream: true }, { ...options2, signal: this.controller.signal });
    this._connected();
    for await (const chunk of stream) {
      __classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_addChunk).call(this, chunk);
    }
    if ((_a3 = stream.controller.signal) == null ? void 0 : _a3.aborted) {
      throw new APIUserAbortError();
    }
    return this._addChatCompletion(__classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_endRequest).call(this));
  }
  async _fromReadableStream(readableStream, options2) {
    var _a3;
    const signal = options2 == null ? void 0 : options2.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    __classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_beginRequest).call(this);
    this._connected();
    const stream = Stream.fromReadableStream(readableStream, this.controller);
    let chatId;
    for await (const chunk of stream) {
      if (chatId && chatId !== chunk.id) {
        this._addChatCompletion(__classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_endRequest).call(this));
      }
      __classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_addChunk).call(this, chunk);
      chatId = chunk.id;
    }
    if ((_a3 = stream.controller.signal) == null ? void 0 : _a3.aborted) {
      throw new APIUserAbortError();
    }
    return this._addChatCompletion(__classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_endRequest).call(this));
  }
  [(_ChatCompletionStream_params = /* @__PURE__ */ new WeakMap(), _ChatCompletionStream_choiceEventStates = /* @__PURE__ */ new WeakMap(), _ChatCompletionStream_currentChatCompletionSnapshot = /* @__PURE__ */ new WeakMap(), _ChatCompletionStream_instances = /* @__PURE__ */ new WeakSet(), _ChatCompletionStream_beginRequest = function _ChatCompletionStream_beginRequest2() {
    if (this.ended)
      return;
    __classPrivateFieldSet(this, _ChatCompletionStream_currentChatCompletionSnapshot, void 0);
  }, _ChatCompletionStream_getChoiceEventState = function _ChatCompletionStream_getChoiceEventState2(choice) {
    let state = __classPrivateFieldGet(this, _ChatCompletionStream_choiceEventStates, "f")[choice.index];
    if (state) {
      return state;
    }
    state = {
      content_done: false,
      refusal_done: false,
      logprobs_content_done: false,
      logprobs_refusal_done: false,
      done_tool_calls: /* @__PURE__ */ new Set(),
      current_tool_call_index: null
    };
    __classPrivateFieldGet(this, _ChatCompletionStream_choiceEventStates, "f")[choice.index] = state;
    return state;
  }, _ChatCompletionStream_addChunk = function _ChatCompletionStream_addChunk2(chunk) {
    var _a3, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o;
    if (this.ended)
      return;
    const completion = __classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_accumulateChatCompletion).call(this, chunk);
    this._emit("chunk", chunk, completion);
    for (const choice of chunk.choices) {
      const choiceSnapshot = completion.choices[choice.index];
      if (choice.delta.content != null && ((_a3 = choiceSnapshot.message) == null ? void 0 : _a3.role) === "assistant" && ((_b = choiceSnapshot.message) == null ? void 0 : _b.content)) {
        this._emit("content", choice.delta.content, choiceSnapshot.message.content);
        this._emit("content.delta", {
          delta: choice.delta.content,
          snapshot: choiceSnapshot.message.content,
          parsed: choiceSnapshot.message.parsed
        });
      }
      if (choice.delta.refusal != null && ((_c = choiceSnapshot.message) == null ? void 0 : _c.role) === "assistant" && ((_d = choiceSnapshot.message) == null ? void 0 : _d.refusal)) {
        this._emit("refusal.delta", {
          delta: choice.delta.refusal,
          snapshot: choiceSnapshot.message.refusal
        });
      }
      if (((_e = choice.logprobs) == null ? void 0 : _e.content) != null && ((_f = choiceSnapshot.message) == null ? void 0 : _f.role) === "assistant") {
        this._emit("logprobs.content.delta", {
          content: (_g = choice.logprobs) == null ? void 0 : _g.content,
          snapshot: ((_h = choiceSnapshot.logprobs) == null ? void 0 : _h.content) ?? []
        });
      }
      if (((_i = choice.logprobs) == null ? void 0 : _i.refusal) != null && ((_j = choiceSnapshot.message) == null ? void 0 : _j.role) === "assistant") {
        this._emit("logprobs.refusal.delta", {
          refusal: (_k = choice.logprobs) == null ? void 0 : _k.refusal,
          snapshot: ((_l = choiceSnapshot.logprobs) == null ? void 0 : _l.refusal) ?? []
        });
      }
      const state = __classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_getChoiceEventState).call(this, choiceSnapshot);
      if (choiceSnapshot.finish_reason) {
        __classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_emitContentDoneEvents).call(this, choiceSnapshot);
        if (state.current_tool_call_index != null) {
          __classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_emitToolCallDoneEvent).call(this, choiceSnapshot, state.current_tool_call_index);
        }
      }
      for (const toolCall of choice.delta.tool_calls ?? []) {
        if (state.current_tool_call_index !== toolCall.index) {
          __classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_emitContentDoneEvents).call(this, choiceSnapshot);
          if (state.current_tool_call_index != null) {
            __classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_emitToolCallDoneEvent).call(this, choiceSnapshot, state.current_tool_call_index);
          }
        }
        state.current_tool_call_index = toolCall.index;
      }
      for (const toolCallDelta of choice.delta.tool_calls ?? []) {
        const toolCallSnapshot = (_m = choiceSnapshot.message.tool_calls) == null ? void 0 : _m[toolCallDelta.index];
        if (!(toolCallSnapshot == null ? void 0 : toolCallSnapshot.type)) {
          continue;
        }
        if ((toolCallSnapshot == null ? void 0 : toolCallSnapshot.type) === "function") {
          this._emit("tool_calls.function.arguments.delta", {
            name: (_n = toolCallSnapshot.function) == null ? void 0 : _n.name,
            index: toolCallDelta.index,
            arguments: toolCallSnapshot.function.arguments,
            parsed_arguments: toolCallSnapshot.function.parsed_arguments,
            arguments_delta: ((_o = toolCallDelta.function) == null ? void 0 : _o.arguments) ?? ""
          });
        } else {
          assertNever(toolCallSnapshot == null ? void 0 : toolCallSnapshot.type);
        }
      }
    }
  }, _ChatCompletionStream_emitToolCallDoneEvent = function _ChatCompletionStream_emitToolCallDoneEvent2(choiceSnapshot, toolCallIndex) {
    var _a3, _b, _c;
    const state = __classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_getChoiceEventState).call(this, choiceSnapshot);
    if (state.done_tool_calls.has(toolCallIndex)) {
      return;
    }
    const toolCallSnapshot = (_a3 = choiceSnapshot.message.tool_calls) == null ? void 0 : _a3[toolCallIndex];
    if (!toolCallSnapshot) {
      throw new Error("no tool call snapshot");
    }
    if (!toolCallSnapshot.type) {
      throw new Error("tool call snapshot missing `type`");
    }
    if (toolCallSnapshot.type === "function") {
      const inputTool = (_c = (_b = __classPrivateFieldGet(this, _ChatCompletionStream_params, "f")) == null ? void 0 : _b.tools) == null ? void 0 : _c.find((tool2) => isChatCompletionFunctionTool(tool2) && tool2.function.name === toolCallSnapshot.function.name);
      this._emit("tool_calls.function.arguments.done", {
        name: toolCallSnapshot.function.name,
        index: toolCallIndex,
        arguments: toolCallSnapshot.function.arguments,
        parsed_arguments: isAutoParsableTool$1(inputTool) ? inputTool.$parseRaw(toolCallSnapshot.function.arguments) : (inputTool == null ? void 0 : inputTool.function.strict) ? JSON.parse(toolCallSnapshot.function.arguments) : null
      });
    } else {
      assertNever(toolCallSnapshot.type);
    }
  }, _ChatCompletionStream_emitContentDoneEvents = function _ChatCompletionStream_emitContentDoneEvents2(choiceSnapshot) {
    var _a3, _b;
    const state = __classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_getChoiceEventState).call(this, choiceSnapshot);
    if (choiceSnapshot.message.content && !state.content_done) {
      state.content_done = true;
      const responseFormat = __classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_getAutoParseableResponseFormat).call(this);
      this._emit("content.done", {
        content: choiceSnapshot.message.content,
        parsed: responseFormat ? responseFormat.$parseRaw(choiceSnapshot.message.content) : null
      });
    }
    if (choiceSnapshot.message.refusal && !state.refusal_done) {
      state.refusal_done = true;
      this._emit("refusal.done", { refusal: choiceSnapshot.message.refusal });
    }
    if (((_a3 = choiceSnapshot.logprobs) == null ? void 0 : _a3.content) && !state.logprobs_content_done) {
      state.logprobs_content_done = true;
      this._emit("logprobs.content.done", { content: choiceSnapshot.logprobs.content });
    }
    if (((_b = choiceSnapshot.logprobs) == null ? void 0 : _b.refusal) && !state.logprobs_refusal_done) {
      state.logprobs_refusal_done = true;
      this._emit("logprobs.refusal.done", { refusal: choiceSnapshot.logprobs.refusal });
    }
  }, _ChatCompletionStream_endRequest = function _ChatCompletionStream_endRequest2() {
    if (this.ended) {
      throw new OpenAIError(`stream has ended, this shouldn't happen`);
    }
    const snapshot = __classPrivateFieldGet(this, _ChatCompletionStream_currentChatCompletionSnapshot, "f");
    if (!snapshot) {
      throw new OpenAIError(`request ended without sending any chunks`);
    }
    __classPrivateFieldSet(this, _ChatCompletionStream_currentChatCompletionSnapshot, void 0);
    __classPrivateFieldSet(this, _ChatCompletionStream_choiceEventStates, []);
    return finalizeChatCompletion(snapshot, __classPrivateFieldGet(this, _ChatCompletionStream_params, "f"));
  }, _ChatCompletionStream_getAutoParseableResponseFormat = function _ChatCompletionStream_getAutoParseableResponseFormat2() {
    var _a3;
    const responseFormat = (_a3 = __classPrivateFieldGet(this, _ChatCompletionStream_params, "f")) == null ? void 0 : _a3.response_format;
    if (isAutoParsableResponseFormat(responseFormat)) {
      return responseFormat;
    }
    return null;
  }, _ChatCompletionStream_accumulateChatCompletion = function _ChatCompletionStream_accumulateChatCompletion2(chunk) {
    var _a3, _b, _c, _d;
    let snapshot = __classPrivateFieldGet(this, _ChatCompletionStream_currentChatCompletionSnapshot, "f");
    const { choices, ...rest } = chunk;
    if (!snapshot) {
      snapshot = __classPrivateFieldSet(this, _ChatCompletionStream_currentChatCompletionSnapshot, {
        ...rest,
        choices: []
      });
    } else {
      Object.assign(snapshot, rest);
    }
    for (const { delta, finish_reason, index, logprobs = null, ...other } of chunk.choices) {
      let choice = snapshot.choices[index];
      if (!choice) {
        choice = snapshot.choices[index] = { finish_reason, index, message: {}, logprobs, ...other };
      }
      if (logprobs) {
        if (!choice.logprobs) {
          choice.logprobs = Object.assign({}, logprobs);
        } else {
          const { content: content2, refusal: refusal2, ...rest3 } = logprobs;
          Object.assign(choice.logprobs, rest3);
          if (content2) {
            (_a3 = choice.logprobs).content ?? (_a3.content = []);
            choice.logprobs.content.push(...content2);
          }
          if (refusal2) {
            (_b = choice.logprobs).refusal ?? (_b.refusal = []);
            choice.logprobs.refusal.push(...refusal2);
          }
        }
      }
      if (finish_reason) {
        choice.finish_reason = finish_reason;
        if (__classPrivateFieldGet(this, _ChatCompletionStream_params, "f") && hasAutoParseableInput$1(__classPrivateFieldGet(this, _ChatCompletionStream_params, "f"))) {
          if (finish_reason === "length") {
            throw new LengthFinishReasonError();
          }
          if (finish_reason === "content_filter") {
            throw new ContentFilterFinishReasonError();
          }
        }
      }
      Object.assign(choice, other);
      if (!delta)
        continue;
      const { content, refusal, function_call, role, tool_calls, ...rest2 } = delta;
      Object.assign(choice.message, rest2);
      if (refusal) {
        choice.message.refusal = (choice.message.refusal || "") + refusal;
      }
      if (role)
        choice.message.role = role;
      if (function_call) {
        if (!choice.message.function_call) {
          choice.message.function_call = function_call;
        } else {
          if (function_call.name)
            choice.message.function_call.name = function_call.name;
          if (function_call.arguments) {
            (_c = choice.message.function_call).arguments ?? (_c.arguments = "");
            choice.message.function_call.arguments += function_call.arguments;
          }
        }
      }
      if (content) {
        choice.message.content = (choice.message.content || "") + content;
        if (!choice.message.refusal && __classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_getAutoParseableResponseFormat).call(this)) {
          choice.message.parsed = partialParse(choice.message.content);
        }
      }
      if (tool_calls) {
        if (!choice.message.tool_calls)
          choice.message.tool_calls = [];
        for (const { index: index2, id, type, function: fn, ...rest3 } of tool_calls) {
          const tool_call = (_d = choice.message.tool_calls)[index2] ?? (_d[index2] = {});
          Object.assign(tool_call, rest3);
          if (id)
            tool_call.id = id;
          if (type)
            tool_call.type = type;
          if (fn)
            tool_call.function ?? (tool_call.function = { name: fn.name ?? "", arguments: "" });
          if (fn == null ? void 0 : fn.name)
            tool_call.function.name = fn.name;
          if (fn == null ? void 0 : fn.arguments) {
            tool_call.function.arguments += fn.arguments;
            if (shouldParseToolCall(__classPrivateFieldGet(this, _ChatCompletionStream_params, "f"), tool_call)) {
              tool_call.function.parsed_arguments = partialParse(tool_call.function.arguments);
            }
          }
        }
      }
    }
    return snapshot;
  }, Symbol.asyncIterator)]() {
    const pushQueue = [];
    const readQueue = [];
    let done = false;
    this.on("chunk", (chunk) => {
      const reader = readQueue.shift();
      if (reader) {
        reader.resolve(chunk);
      } else {
        pushQueue.push(chunk);
      }
    });
    this.on("end", () => {
      done = true;
      for (const reader of readQueue) {
        reader.resolve(void 0);
      }
      readQueue.length = 0;
    });
    this.on("abort", (err) => {
      done = true;
      for (const reader of readQueue) {
        reader.reject(err);
      }
      readQueue.length = 0;
    });
    this.on("error", (err) => {
      done = true;
      for (const reader of readQueue) {
        reader.reject(err);
      }
      readQueue.length = 0;
    });
    return {
      next: async () => {
        if (!pushQueue.length) {
          if (done) {
            return { value: void 0, done: true };
          }
          return new Promise((resolve, reject) => readQueue.push({ resolve, reject })).then((chunk2) => chunk2 ? { value: chunk2, done: false } : { value: void 0, done: true });
        }
        const chunk = pushQueue.shift();
        return { value: chunk, done: false };
      },
      return: async () => {
        this.abort();
        return { value: void 0, done: true };
      }
    };
  }
  toReadableStream() {
    const stream = new Stream(this[Symbol.asyncIterator].bind(this), this.controller);
    return stream.toReadableStream();
  }
}
function finalizeChatCompletion(snapshot, params) {
  const { id, choices, created, model, system_fingerprint, ...rest } = snapshot;
  const completion = {
    ...rest,
    id,
    choices: choices.map(({ message, finish_reason, index, logprobs, ...choiceRest }) => {
      if (!finish_reason) {
        throw new OpenAIError(`missing finish_reason for choice ${index}`);
      }
      const { content = null, function_call, tool_calls, ...messageRest } = message;
      const role = message.role;
      if (!role) {
        throw new OpenAIError(`missing role for choice ${index}`);
      }
      if (function_call) {
        const { arguments: args, name } = function_call;
        if (args == null) {
          throw new OpenAIError(`missing function_call.arguments for choice ${index}`);
        }
        if (!name) {
          throw new OpenAIError(`missing function_call.name for choice ${index}`);
        }
        return {
          ...choiceRest,
          message: {
            content,
            function_call: { arguments: args, name },
            role,
            refusal: message.refusal ?? null
          },
          finish_reason,
          index,
          logprobs
        };
      }
      if (tool_calls) {
        return {
          ...choiceRest,
          index,
          finish_reason,
          logprobs,
          message: {
            ...messageRest,
            role,
            content,
            refusal: message.refusal ?? null,
            tool_calls: tool_calls.map((tool_call, i2) => {
              const { function: fn, type, id: id2, ...toolRest } = tool_call;
              const { arguments: args, name, ...fnRest } = fn || {};
              if (id2 == null) {
                throw new OpenAIError(`missing choices[${index}].tool_calls[${i2}].id
${str(snapshot)}`);
              }
              if (type == null) {
                throw new OpenAIError(`missing choices[${index}].tool_calls[${i2}].type
${str(snapshot)}`);
              }
              if (name == null) {
                throw new OpenAIError(`missing choices[${index}].tool_calls[${i2}].function.name
${str(snapshot)}`);
              }
              if (args == null) {
                throw new OpenAIError(`missing choices[${index}].tool_calls[${i2}].function.arguments
${str(snapshot)}`);
              }
              return { ...toolRest, id: id2, type, function: { ...fnRest, name, arguments: args } };
            })
          }
        };
      }
      return {
        ...choiceRest,
        message: { ...messageRest, content, role, refusal: message.refusal ?? null },
        finish_reason,
        index,
        logprobs
      };
    }),
    created,
    model,
    object: "chat.completion",
    ...system_fingerprint ? { system_fingerprint } : {}
  };
  return maybeParseChatCompletion(completion, params);
}
function str(x) {
  return JSON.stringify(x);
}
function assertNever(_x) {
}
class ChatCompletionStreamingRunner extends ChatCompletionStream {
  static fromReadableStream(stream) {
    const runner = new ChatCompletionStreamingRunner(null);
    runner._run(() => runner._fromReadableStream(stream));
    return runner;
  }
  static runTools(client2, params, options2) {
    const runner = new ChatCompletionStreamingRunner(
      // @ts-expect-error TODO these types are incompatible
      params
    );
    const opts = {
      ...options2,
      headers: { ...options2 == null ? void 0 : options2.headers, "X-Stainless-Helper-Method": "runTools" }
    };
    runner._run(() => runner._runTools(client2, params, opts));
    return runner;
  }
}
let Completions$1 = class Completions2 extends APIResource {
  constructor() {
    super(...arguments);
    this.messages = new Messages$1(this._client);
  }
  create(body, options2) {
    return this._client.post("/chat/completions", { body, ...options2, stream: body.stream ?? false });
  }
  /**
   * Get a stored chat completion. Only Chat Completions that have been created with
   * the `store` parameter set to `true` will be returned.
   *
   * @example
   * ```ts
   * const chatCompletion =
   *   await client.chat.completions.retrieve('completion_id');
   * ```
   */
  retrieve(completionID, options2) {
    return this._client.get(path$1`/chat/completions/${completionID}`, options2);
  }
  /**
   * Modify a stored chat completion. Only Chat Completions that have been created
   * with the `store` parameter set to `true` can be modified. Currently, the only
   * supported modification is to update the `metadata` field.
   *
   * @example
   * ```ts
   * const chatCompletion = await client.chat.completions.update(
   *   'completion_id',
   *   { metadata: { foo: 'string' } },
   * );
   * ```
   */
  update(completionID, body, options2) {
    return this._client.post(path$1`/chat/completions/${completionID}`, { body, ...options2 });
  }
  /**
   * List stored Chat Completions. Only Chat Completions that have been stored with
   * the `store` parameter set to `true` will be returned.
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const chatCompletion of client.chat.completions.list()) {
   *   // ...
   * }
   * ```
   */
  list(query = {}, options2) {
    return this._client.getAPIList("/chat/completions", CursorPage, { query, ...options2 });
  }
  /**
   * Delete a stored chat completion. Only Chat Completions that have been created
   * with the `store` parameter set to `true` can be deleted.
   *
   * @example
   * ```ts
   * const chatCompletionDeleted =
   *   await client.chat.completions.delete('completion_id');
   * ```
   */
  delete(completionID, options2) {
    return this._client.delete(path$1`/chat/completions/${completionID}`, options2);
  }
  parse(body, options2) {
    validateInputTools(body.tools);
    return this._client.chat.completions.create(body, {
      ...options2,
      headers: {
        ...options2 == null ? void 0 : options2.headers,
        "X-Stainless-Helper-Method": "chat.completions.parse"
      }
    })._thenUnwrap((completion) => parseChatCompletion(completion, body));
  }
  runTools(body, options2) {
    if (body.stream) {
      return ChatCompletionStreamingRunner.runTools(this._client, body, options2);
    }
    return ChatCompletionRunner.runTools(this._client, body, options2);
  }
  /**
   * Creates a chat completion stream
   */
  stream(body, options2) {
    return ChatCompletionStream.createChatCompletion(this._client, body, options2);
  }
};
Completions$1.Messages = Messages$1;
class Chat extends APIResource {
  constructor() {
    super(...arguments);
    this.completions = new Completions$1(this._client);
  }
}
Chat.Completions = Completions$1;
const brand_privateNullableHeaders = /* @__PURE__ */ Symbol("brand.privateNullableHeaders");
function* iterateHeaders(headers) {
  if (!headers)
    return;
  if (brand_privateNullableHeaders in headers) {
    const { values, nulls } = headers;
    yield* values.entries();
    for (const name of nulls) {
      yield [name, null];
    }
    return;
  }
  let shouldClear = false;
  let iter;
  if (headers instanceof Headers) {
    iter = headers.entries();
  } else if (isReadonlyArray(headers)) {
    iter = headers;
  } else {
    shouldClear = true;
    iter = Object.entries(headers ?? {});
  }
  for (let row of iter) {
    const name = row[0];
    if (typeof name !== "string")
      throw new TypeError("expected header name to be a string");
    const values = isReadonlyArray(row[1]) ? row[1] : [row[1]];
    let didClear = false;
    for (const value of values) {
      if (value === void 0)
        continue;
      if (shouldClear && !didClear) {
        didClear = true;
        yield [name, null];
      }
      yield [name, value];
    }
  }
}
const buildHeaders = (newHeaders) => {
  const targetHeaders = new Headers();
  const nullHeaders = /* @__PURE__ */ new Set();
  for (const headers of newHeaders) {
    const seenHeaders = /* @__PURE__ */ new Set();
    for (const [name, value] of iterateHeaders(headers)) {
      const lowerName = name.toLowerCase();
      if (!seenHeaders.has(lowerName)) {
        targetHeaders.delete(name);
        seenHeaders.add(lowerName);
      }
      if (value === null) {
        targetHeaders.delete(name);
        nullHeaders.add(lowerName);
      } else {
        targetHeaders.append(name, value);
        nullHeaders.delete(lowerName);
      }
    }
  }
  return { [brand_privateNullableHeaders]: true, values: targetHeaders, nulls: nullHeaders };
};
class Speech extends APIResource {
  /**
   * Generates audio from the input text.
   *
   * @example
   * ```ts
   * const speech = await client.audio.speech.create({
   *   input: 'input',
   *   model: 'string',
   *   voice: 'ash',
   * });
   *
   * const content = await speech.blob();
   * console.log(content);
   * ```
   */
  create(body, options2) {
    return this._client.post("/audio/speech", {
      body,
      ...options2,
      headers: buildHeaders([{ Accept: "application/octet-stream" }, options2 == null ? void 0 : options2.headers]),
      __binaryResponse: true
    });
  }
}
class Transcriptions extends APIResource {
  create(body, options2) {
    return this._client.post("/audio/transcriptions", multipartFormRequestOptions({
      body,
      ...options2,
      stream: body.stream ?? false,
      __metadata: { model: body.model }
    }, this._client));
  }
}
class Translations extends APIResource {
  create(body, options2) {
    return this._client.post("/audio/translations", multipartFormRequestOptions({ body, ...options2, __metadata: { model: body.model } }, this._client));
  }
}
class Audio extends APIResource {
  constructor() {
    super(...arguments);
    this.transcriptions = new Transcriptions(this._client);
    this.translations = new Translations(this._client);
    this.speech = new Speech(this._client);
  }
}
Audio.Transcriptions = Transcriptions;
Audio.Translations = Translations;
Audio.Speech = Speech;
class Batches extends APIResource {
  /**
   * Creates and executes a batch from an uploaded file of requests
   */
  create(body, options2) {
    return this._client.post("/batches", { body, ...options2 });
  }
  /**
   * Retrieves a batch.
   */
  retrieve(batchID, options2) {
    return this._client.get(path$1`/batches/${batchID}`, options2);
  }
  /**
   * List your organization's batches.
   */
  list(query = {}, options2) {
    return this._client.getAPIList("/batches", CursorPage, { query, ...options2 });
  }
  /**
   * Cancels an in-progress batch. The batch will be in status `cancelling` for up to
   * 10 minutes, before changing to `cancelled`, where it will have partial results
   * (if any) available in the output file.
   */
  cancel(batchID, options2) {
    return this._client.post(path$1`/batches/${batchID}/cancel`, options2);
  }
}
class Assistants extends APIResource {
  /**
   * Create an assistant with a model and instructions.
   *
   * @example
   * ```ts
   * const assistant = await client.beta.assistants.create({
   *   model: 'gpt-4o',
   * });
   * ```
   */
  create(body, options2) {
    return this._client.post("/assistants", {
      body,
      ...options2,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options2 == null ? void 0 : options2.headers])
    });
  }
  /**
   * Retrieves an assistant.
   *
   * @example
   * ```ts
   * const assistant = await client.beta.assistants.retrieve(
   *   'assistant_id',
   * );
   * ```
   */
  retrieve(assistantID, options2) {
    return this._client.get(path$1`/assistants/${assistantID}`, {
      ...options2,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options2 == null ? void 0 : options2.headers])
    });
  }
  /**
   * Modifies an assistant.
   *
   * @example
   * ```ts
   * const assistant = await client.beta.assistants.update(
   *   'assistant_id',
   * );
   * ```
   */
  update(assistantID, body, options2) {
    return this._client.post(path$1`/assistants/${assistantID}`, {
      body,
      ...options2,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options2 == null ? void 0 : options2.headers])
    });
  }
  /**
   * Returns a list of assistants.
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const assistant of client.beta.assistants.list()) {
   *   // ...
   * }
   * ```
   */
  list(query = {}, options2) {
    return this._client.getAPIList("/assistants", CursorPage, {
      query,
      ...options2,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options2 == null ? void 0 : options2.headers])
    });
  }
  /**
   * Delete an assistant.
   *
   * @example
   * ```ts
   * const assistantDeleted =
   *   await client.beta.assistants.delete('assistant_id');
   * ```
   */
  delete(assistantID, options2) {
    return this._client.delete(path$1`/assistants/${assistantID}`, {
      ...options2,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options2 == null ? void 0 : options2.headers])
    });
  }
}
let Sessions$1 = class Sessions2 extends APIResource {
  /**
   * Create an ephemeral API token for use in client-side applications with the
   * Realtime API. Can be configured with the same session parameters as the
   * `session.update` client event.
   *
   * It responds with a session object, plus a `client_secret` key which contains a
   * usable ephemeral API token that can be used to authenticate browser clients for
   * the Realtime API.
   *
   * @example
   * ```ts
   * const session =
   *   await client.beta.realtime.sessions.create();
   * ```
   */
  create(body, options2) {
    return this._client.post("/realtime/sessions", {
      body,
      ...options2,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options2 == null ? void 0 : options2.headers])
    });
  }
};
class TranscriptionSessions extends APIResource {
  /**
   * Create an ephemeral API token for use in client-side applications with the
   * Realtime API specifically for realtime transcriptions. Can be configured with
   * the same session parameters as the `transcription_session.update` client event.
   *
   * It responds with a session object, plus a `client_secret` key which contains a
   * usable ephemeral API token that can be used to authenticate browser clients for
   * the Realtime API.
   *
   * @example
   * ```ts
   * const transcriptionSession =
   *   await client.beta.realtime.transcriptionSessions.create();
   * ```
   */
  create(body, options2) {
    return this._client.post("/realtime/transcription_sessions", {
      body,
      ...options2,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options2 == null ? void 0 : options2.headers])
    });
  }
}
let Realtime$1 = class Realtime2 extends APIResource {
  constructor() {
    super(...arguments);
    this.sessions = new Sessions$1(this._client);
    this.transcriptionSessions = new TranscriptionSessions(this._client);
  }
};
Realtime$1.Sessions = Sessions$1;
Realtime$1.TranscriptionSessions = TranscriptionSessions;
class Sessions extends APIResource {
  /**
   * Create a ChatKit session
   *
   * @example
   * ```ts
   * const chatSession =
   *   await client.beta.chatkit.sessions.create({
   *     user: 'x',
   *     workflow: { id: 'id' },
   *   });
   * ```
   */
  create(body, options2) {
    return this._client.post("/chatkit/sessions", {
      body,
      ...options2,
      headers: buildHeaders([{ "OpenAI-Beta": "chatkit_beta=v1" }, options2 == null ? void 0 : options2.headers])
    });
  }
  /**
   * Cancel a ChatKit session
   *
   * @example
   * ```ts
   * const chatSession =
   *   await client.beta.chatkit.sessions.cancel('cksess_123');
   * ```
   */
  cancel(sessionID, options2) {
    return this._client.post(path$1`/chatkit/sessions/${sessionID}/cancel`, {
      ...options2,
      headers: buildHeaders([{ "OpenAI-Beta": "chatkit_beta=v1" }, options2 == null ? void 0 : options2.headers])
    });
  }
}
let Threads$1 = class Threads2 extends APIResource {
  /**
   * Retrieve a ChatKit thread
   *
   * @example
   * ```ts
   * const chatkitThread =
   *   await client.beta.chatkit.threads.retrieve('cthr_123');
   * ```
   */
  retrieve(threadID, options2) {
    return this._client.get(path$1`/chatkit/threads/${threadID}`, {
      ...options2,
      headers: buildHeaders([{ "OpenAI-Beta": "chatkit_beta=v1" }, options2 == null ? void 0 : options2.headers])
    });
  }
  /**
   * List ChatKit threads
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const chatkitThread of client.beta.chatkit.threads.list()) {
   *   // ...
   * }
   * ```
   */
  list(query = {}, options2) {
    return this._client.getAPIList("/chatkit/threads", ConversationCursorPage, {
      query,
      ...options2,
      headers: buildHeaders([{ "OpenAI-Beta": "chatkit_beta=v1" }, options2 == null ? void 0 : options2.headers])
    });
  }
  /**
   * Delete a ChatKit thread
   *
   * @example
   * ```ts
   * const thread = await client.beta.chatkit.threads.delete(
   *   'cthr_123',
   * );
   * ```
   */
  delete(threadID, options2) {
    return this._client.delete(path$1`/chatkit/threads/${threadID}`, {
      ...options2,
      headers: buildHeaders([{ "OpenAI-Beta": "chatkit_beta=v1" }, options2 == null ? void 0 : options2.headers])
    });
  }
  /**
   * List ChatKit thread items
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const thread of client.beta.chatkit.threads.listItems(
   *   'cthr_123',
   * )) {
   *   // ...
   * }
   * ```
   */
  listItems(threadID, query = {}, options2) {
    return this._client.getAPIList(path$1`/chatkit/threads/${threadID}/items`, ConversationCursorPage, { query, ...options2, headers: buildHeaders([{ "OpenAI-Beta": "chatkit_beta=v1" }, options2 == null ? void 0 : options2.headers]) });
  }
};
class ChatKit extends APIResource {
  constructor() {
    super(...arguments);
    this.sessions = new Sessions(this._client);
    this.threads = new Threads$1(this._client);
  }
}
ChatKit.Sessions = Sessions;
ChatKit.Threads = Threads$1;
class Messages extends APIResource {
  /**
   * Create a message.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  create(threadID, body, options2) {
    return this._client.post(path$1`/threads/${threadID}/messages`, {
      body,
      ...options2,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options2 == null ? void 0 : options2.headers])
    });
  }
  /**
   * Retrieve a message.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  retrieve(messageID, params, options2) {
    const { thread_id } = params;
    return this._client.get(path$1`/threads/${thread_id}/messages/${messageID}`, {
      ...options2,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options2 == null ? void 0 : options2.headers])
    });
  }
  /**
   * Modifies a message.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  update(messageID, params, options2) {
    const { thread_id, ...body } = params;
    return this._client.post(path$1`/threads/${thread_id}/messages/${messageID}`, {
      body,
      ...options2,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options2 == null ? void 0 : options2.headers])
    });
  }
  /**
   * Returns a list of messages for a given thread.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  list(threadID, query = {}, options2) {
    return this._client.getAPIList(path$1`/threads/${threadID}/messages`, CursorPage, {
      query,
      ...options2,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options2 == null ? void 0 : options2.headers])
    });
  }
  /**
   * Deletes a message.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  delete(messageID, params, options2) {
    const { thread_id } = params;
    return this._client.delete(path$1`/threads/${thread_id}/messages/${messageID}`, {
      ...options2,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options2 == null ? void 0 : options2.headers])
    });
  }
}
class Steps extends APIResource {
  /**
   * Retrieves a run step.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  retrieve(stepID, params, options2) {
    const { thread_id, run_id, ...query } = params;
    return this._client.get(path$1`/threads/${thread_id}/runs/${run_id}/steps/${stepID}`, {
      query,
      ...options2,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options2 == null ? void 0 : options2.headers])
    });
  }
  /**
   * Returns a list of run steps belonging to a run.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  list(runID, params, options2) {
    const { thread_id, ...query } = params;
    return this._client.getAPIList(path$1`/threads/${thread_id}/runs/${runID}/steps`, CursorPage, {
      query,
      ...options2,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options2 == null ? void 0 : options2.headers])
    });
  }
}
const toFloat32Array = (base64Str) => {
  if (typeof Buffer !== "undefined") {
    const buf = Buffer.from(base64Str, "base64");
    return Array.from(new Float32Array(buf.buffer, buf.byteOffset, buf.length / Float32Array.BYTES_PER_ELEMENT));
  } else {
    const binaryStr = atob(base64Str);
    const len2 = binaryStr.length;
    const bytes = new Uint8Array(len2);
    for (let i2 = 0; i2 < len2; i2++) {
      bytes[i2] = binaryStr.charCodeAt(i2);
    }
    return Array.from(new Float32Array(bytes.buffer));
  }
};
const readEnv = (env) => {
  var _a3, _b, _c, _d, _e;
  if (typeof globalThis.process !== "undefined") {
    return ((_b = (_a3 = globalThis.process.env) == null ? void 0 : _a3[env]) == null ? void 0 : _b.trim()) ?? void 0;
  }
  if (typeof globalThis.Deno !== "undefined") {
    return (_e = (_d = (_c = globalThis.Deno.env) == null ? void 0 : _c.get) == null ? void 0 : _d.call(_c, env)) == null ? void 0 : _e.trim();
  }
  return void 0;
};
var _AssistantStream_instances, _a$2, _AssistantStream_events, _AssistantStream_runStepSnapshots, _AssistantStream_messageSnapshots, _AssistantStream_messageSnapshot, _AssistantStream_finalRun, _AssistantStream_currentContentIndex, _AssistantStream_currentContent, _AssistantStream_currentToolCallIndex, _AssistantStream_currentToolCall, _AssistantStream_currentEvent, _AssistantStream_currentRunSnapshot, _AssistantStream_currentRunStepSnapshot, _AssistantStream_addEvent, _AssistantStream_endRequest, _AssistantStream_handleMessage, _AssistantStream_handleRunStep, _AssistantStream_handleEvent, _AssistantStream_accumulateRunStep, _AssistantStream_accumulateMessage, _AssistantStream_accumulateContent, _AssistantStream_handleRun;
class AssistantStream extends EventStream {
  constructor() {
    super(...arguments);
    _AssistantStream_instances.add(this);
    _AssistantStream_events.set(this, []);
    _AssistantStream_runStepSnapshots.set(this, {});
    _AssistantStream_messageSnapshots.set(this, {});
    _AssistantStream_messageSnapshot.set(this, void 0);
    _AssistantStream_finalRun.set(this, void 0);
    _AssistantStream_currentContentIndex.set(this, void 0);
    _AssistantStream_currentContent.set(this, void 0);
    _AssistantStream_currentToolCallIndex.set(this, void 0);
    _AssistantStream_currentToolCall.set(this, void 0);
    _AssistantStream_currentEvent.set(this, void 0);
    _AssistantStream_currentRunSnapshot.set(this, void 0);
    _AssistantStream_currentRunStepSnapshot.set(this, void 0);
  }
  [(_AssistantStream_events = /* @__PURE__ */ new WeakMap(), _AssistantStream_runStepSnapshots = /* @__PURE__ */ new WeakMap(), _AssistantStream_messageSnapshots = /* @__PURE__ */ new WeakMap(), _AssistantStream_messageSnapshot = /* @__PURE__ */ new WeakMap(), _AssistantStream_finalRun = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentContentIndex = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentContent = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentToolCallIndex = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentToolCall = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentEvent = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentRunSnapshot = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentRunStepSnapshot = /* @__PURE__ */ new WeakMap(), _AssistantStream_instances = /* @__PURE__ */ new WeakSet(), Symbol.asyncIterator)]() {
    const pushQueue = [];
    const readQueue = [];
    let done = false;
    this.on("event", (event) => {
      const reader = readQueue.shift();
      if (reader) {
        reader.resolve(event);
      } else {
        pushQueue.push(event);
      }
    });
    this.on("end", () => {
      done = true;
      for (const reader of readQueue) {
        reader.resolve(void 0);
      }
      readQueue.length = 0;
    });
    this.on("abort", (err) => {
      done = true;
      for (const reader of readQueue) {
        reader.reject(err);
      }
      readQueue.length = 0;
    });
    this.on("error", (err) => {
      done = true;
      for (const reader of readQueue) {
        reader.reject(err);
      }
      readQueue.length = 0;
    });
    return {
      next: async () => {
        if (!pushQueue.length) {
          if (done) {
            return { value: void 0, done: true };
          }
          return new Promise((resolve, reject) => readQueue.push({ resolve, reject })).then((chunk2) => chunk2 ? { value: chunk2, done: false } : { value: void 0, done: true });
        }
        const chunk = pushQueue.shift();
        return { value: chunk, done: false };
      },
      return: async () => {
        this.abort();
        return { value: void 0, done: true };
      }
    };
  }
  static fromReadableStream(stream) {
    const runner = new _a$2();
    runner._run(() => runner._fromReadableStream(stream));
    return runner;
  }
  async _fromReadableStream(readableStream, options2) {
    var _a3;
    const signal = options2 == null ? void 0 : options2.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    this._connected();
    const stream = Stream.fromReadableStream(readableStream, this.controller);
    for await (const event of stream) {
      __classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_addEvent).call(this, event);
    }
    if ((_a3 = stream.controller.signal) == null ? void 0 : _a3.aborted) {
      throw new APIUserAbortError();
    }
    return this._addRun(__classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_endRequest).call(this));
  }
  toReadableStream() {
    const stream = new Stream(this[Symbol.asyncIterator].bind(this), this.controller);
    return stream.toReadableStream();
  }
  static createToolAssistantStream(runId, runs, params, options2) {
    const runner = new _a$2();
    runner._run(() => runner._runToolAssistantStream(runId, runs, params, {
      ...options2,
      headers: { ...options2 == null ? void 0 : options2.headers, "X-Stainless-Helper-Method": "stream" }
    }));
    return runner;
  }
  async _createToolAssistantStream(run, runId, params, options2) {
    var _a3;
    const signal = options2 == null ? void 0 : options2.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    const body = { ...params, stream: true };
    const stream = await run.submitToolOutputs(runId, body, {
      ...options2,
      signal: this.controller.signal
    });
    this._connected();
    for await (const event of stream) {
      __classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_addEvent).call(this, event);
    }
    if ((_a3 = stream.controller.signal) == null ? void 0 : _a3.aborted) {
      throw new APIUserAbortError();
    }
    return this._addRun(__classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_endRequest).call(this));
  }
  static createThreadAssistantStream(params, thread, options2) {
    const runner = new _a$2();
    runner._run(() => runner._threadAssistantStream(params, thread, {
      ...options2,
      headers: { ...options2 == null ? void 0 : options2.headers, "X-Stainless-Helper-Method": "stream" }
    }));
    return runner;
  }
  static createAssistantStream(threadId, runs, params, options2) {
    const runner = new _a$2();
    runner._run(() => runner._runAssistantStream(threadId, runs, params, {
      ...options2,
      headers: { ...options2 == null ? void 0 : options2.headers, "X-Stainless-Helper-Method": "stream" }
    }));
    return runner;
  }
  currentEvent() {
    return __classPrivateFieldGet(this, _AssistantStream_currentEvent, "f");
  }
  currentRun() {
    return __classPrivateFieldGet(this, _AssistantStream_currentRunSnapshot, "f");
  }
  currentMessageSnapshot() {
    return __classPrivateFieldGet(this, _AssistantStream_messageSnapshot, "f");
  }
  currentRunStepSnapshot() {
    return __classPrivateFieldGet(this, _AssistantStream_currentRunStepSnapshot, "f");
  }
  async finalRunSteps() {
    await this.done();
    return Object.values(__classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, "f"));
  }
  async finalMessages() {
    await this.done();
    return Object.values(__classPrivateFieldGet(this, _AssistantStream_messageSnapshots, "f"));
  }
  async finalRun() {
    await this.done();
    if (!__classPrivateFieldGet(this, _AssistantStream_finalRun, "f"))
      throw Error("Final run was not received.");
    return __classPrivateFieldGet(this, _AssistantStream_finalRun, "f");
  }
  async _createThreadAssistantStream(thread, params, options2) {
    var _a3;
    const signal = options2 == null ? void 0 : options2.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    const body = { ...params, stream: true };
    const stream = await thread.createAndRun(body, { ...options2, signal: this.controller.signal });
    this._connected();
    for await (const event of stream) {
      __classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_addEvent).call(this, event);
    }
    if ((_a3 = stream.controller.signal) == null ? void 0 : _a3.aborted) {
      throw new APIUserAbortError();
    }
    return this._addRun(__classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_endRequest).call(this));
  }
  async _createAssistantStream(run, threadId, params, options2) {
    var _a3;
    const signal = options2 == null ? void 0 : options2.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    const body = { ...params, stream: true };
    const stream = await run.create(threadId, body, { ...options2, signal: this.controller.signal });
    this._connected();
    for await (const event of stream) {
      __classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_addEvent).call(this, event);
    }
    if ((_a3 = stream.controller.signal) == null ? void 0 : _a3.aborted) {
      throw new APIUserAbortError();
    }
    return this._addRun(__classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_endRequest).call(this));
  }
  static accumulateDelta(acc, delta) {
    for (const [key, deltaValue] of Object.entries(delta)) {
      if (!acc.hasOwnProperty(key)) {
        acc[key] = deltaValue;
        continue;
      }
      let accValue = acc[key];
      if (accValue === null || accValue === void 0) {
        acc[key] = deltaValue;
        continue;
      }
      if (key === "index" || key === "type") {
        acc[key] = deltaValue;
        continue;
      }
      if (typeof accValue === "string" && typeof deltaValue === "string") {
        accValue += deltaValue;
      } else if (typeof accValue === "number" && typeof deltaValue === "number") {
        accValue += deltaValue;
      } else if (isObj(accValue) && isObj(deltaValue)) {
        accValue = this.accumulateDelta(accValue, deltaValue);
      } else if (Array.isArray(accValue) && Array.isArray(deltaValue)) {
        if (accValue.every((x) => typeof x === "string" || typeof x === "number")) {
          accValue.push(...deltaValue);
          continue;
        }
        for (const deltaEntry of deltaValue) {
          if (!isObj(deltaEntry)) {
            throw new Error(`Expected array delta entry to be an object but got: ${deltaEntry}`);
          }
          const index = deltaEntry["index"];
          if (index == null) {
            console.error(deltaEntry);
            throw new Error("Expected array delta entry to have an `index` property");
          }
          if (typeof index !== "number") {
            throw new Error(`Expected array delta entry \`index\` property to be a number but got ${index}`);
          }
          const accEntry = accValue[index];
          if (accEntry == null) {
            accValue.push(deltaEntry);
          } else {
            accValue[index] = this.accumulateDelta(accEntry, deltaEntry);
          }
        }
        continue;
      } else {
        throw Error(`Unhandled record type: ${key}, deltaValue: ${deltaValue}, accValue: ${accValue}`);
      }
      acc[key] = accValue;
    }
    return acc;
  }
  _addRun(run) {
    return run;
  }
  async _threadAssistantStream(params, thread, options2) {
    return await this._createThreadAssistantStream(thread, params, options2);
  }
  async _runAssistantStream(threadId, runs, params, options2) {
    return await this._createAssistantStream(runs, threadId, params, options2);
  }
  async _runToolAssistantStream(runId, runs, params, options2) {
    return await this._createToolAssistantStream(runs, runId, params, options2);
  }
}
_a$2 = AssistantStream, _AssistantStream_addEvent = function _AssistantStream_addEvent2(event) {
  if (this.ended)
    return;
  __classPrivateFieldSet(this, _AssistantStream_currentEvent, event);
  __classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_handleEvent).call(this, event);
  switch (event.event) {
    case "thread.created":
      break;
    case "thread.run.created":
    case "thread.run.queued":
    case "thread.run.in_progress":
    case "thread.run.requires_action":
    case "thread.run.completed":
    case "thread.run.incomplete":
    case "thread.run.failed":
    case "thread.run.cancelling":
    case "thread.run.cancelled":
    case "thread.run.expired":
      __classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_handleRun).call(this, event);
      break;
    case "thread.run.step.created":
    case "thread.run.step.in_progress":
    case "thread.run.step.delta":
    case "thread.run.step.completed":
    case "thread.run.step.failed":
    case "thread.run.step.cancelled":
    case "thread.run.step.expired":
      __classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_handleRunStep).call(this, event);
      break;
    case "thread.message.created":
    case "thread.message.in_progress":
    case "thread.message.delta":
    case "thread.message.completed":
    case "thread.message.incomplete":
      __classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_handleMessage).call(this, event);
      break;
    case "error":
      throw new Error("Encountered an error event in event processing - errors should be processed earlier");
  }
}, _AssistantStream_endRequest = function _AssistantStream_endRequest2() {
  if (this.ended) {
    throw new OpenAIError(`stream has ended, this shouldn't happen`);
  }
  if (!__classPrivateFieldGet(this, _AssistantStream_finalRun, "f"))
    throw Error("Final run has not been received");
  return __classPrivateFieldGet(this, _AssistantStream_finalRun, "f");
}, _AssistantStream_handleMessage = function _AssistantStream_handleMessage2(event) {
  const [accumulatedMessage, newContent] = __classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_accumulateMessage).call(this, event, __classPrivateFieldGet(this, _AssistantStream_messageSnapshot, "f"));
  __classPrivateFieldSet(this, _AssistantStream_messageSnapshot, accumulatedMessage);
  __classPrivateFieldGet(this, _AssistantStream_messageSnapshots, "f")[accumulatedMessage.id] = accumulatedMessage;
  for (const content of newContent) {
    const snapshotContent = accumulatedMessage.content[content.index];
    if ((snapshotContent == null ? void 0 : snapshotContent.type) == "text") {
      this._emit("textCreated", snapshotContent.text);
    }
  }
  switch (event.event) {
    case "thread.message.created":
      this._emit("messageCreated", event.data);
      break;
    case "thread.message.in_progress":
      break;
    case "thread.message.delta":
      this._emit("messageDelta", event.data.delta, accumulatedMessage);
      if (event.data.delta.content) {
        for (const content of event.data.delta.content) {
          if (content.type == "text" && content.text) {
            let textDelta = content.text;
            let snapshot = accumulatedMessage.content[content.index];
            if (snapshot && snapshot.type == "text") {
              this._emit("textDelta", textDelta, snapshot.text);
            } else {
              throw Error("The snapshot associated with this text delta is not text or missing");
            }
          }
          if (content.index != __classPrivateFieldGet(this, _AssistantStream_currentContentIndex, "f")) {
            if (__classPrivateFieldGet(this, _AssistantStream_currentContent, "f")) {
              switch (__classPrivateFieldGet(this, _AssistantStream_currentContent, "f").type) {
                case "text":
                  this._emit("textDone", __classPrivateFieldGet(this, _AssistantStream_currentContent, "f").text, __classPrivateFieldGet(this, _AssistantStream_messageSnapshot, "f"));
                  break;
                case "image_file":
                  this._emit("imageFileDone", __classPrivateFieldGet(this, _AssistantStream_currentContent, "f").image_file, __classPrivateFieldGet(this, _AssistantStream_messageSnapshot, "f"));
                  break;
              }
            }
            __classPrivateFieldSet(this, _AssistantStream_currentContentIndex, content.index);
          }
          __classPrivateFieldSet(this, _AssistantStream_currentContent, accumulatedMessage.content[content.index]);
        }
      }
      break;
    case "thread.message.completed":
    case "thread.message.incomplete":
      if (__classPrivateFieldGet(this, _AssistantStream_currentContentIndex, "f") !== void 0) {
        const currentContent = event.data.content[__classPrivateFieldGet(this, _AssistantStream_currentContentIndex, "f")];
        if (currentContent) {
          switch (currentContent.type) {
            case "image_file":
              this._emit("imageFileDone", currentContent.image_file, __classPrivateFieldGet(this, _AssistantStream_messageSnapshot, "f"));
              break;
            case "text":
              this._emit("textDone", currentContent.text, __classPrivateFieldGet(this, _AssistantStream_messageSnapshot, "f"));
              break;
          }
        }
      }
      if (__classPrivateFieldGet(this, _AssistantStream_messageSnapshot, "f")) {
        this._emit("messageDone", event.data);
      }
      __classPrivateFieldSet(this, _AssistantStream_messageSnapshot, void 0);
  }
}, _AssistantStream_handleRunStep = function _AssistantStream_handleRunStep2(event) {
  const accumulatedRunStep = __classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_accumulateRunStep).call(this, event);
  __classPrivateFieldSet(this, _AssistantStream_currentRunStepSnapshot, accumulatedRunStep);
  switch (event.event) {
    case "thread.run.step.created":
      this._emit("runStepCreated", event.data);
      break;
    case "thread.run.step.delta":
      const delta = event.data.delta;
      if (delta.step_details && delta.step_details.type == "tool_calls" && delta.step_details.tool_calls && accumulatedRunStep.step_details.type == "tool_calls") {
        for (const toolCall of delta.step_details.tool_calls) {
          if (toolCall.index == __classPrivateFieldGet(this, _AssistantStream_currentToolCallIndex, "f")) {
            this._emit("toolCallDelta", toolCall, accumulatedRunStep.step_details.tool_calls[toolCall.index]);
          } else {
            if (__classPrivateFieldGet(this, _AssistantStream_currentToolCall, "f")) {
              this._emit("toolCallDone", __classPrivateFieldGet(this, _AssistantStream_currentToolCall, "f"));
            }
            __classPrivateFieldSet(this, _AssistantStream_currentToolCallIndex, toolCall.index);
            __classPrivateFieldSet(this, _AssistantStream_currentToolCall, accumulatedRunStep.step_details.tool_calls[toolCall.index]);
            if (__classPrivateFieldGet(this, _AssistantStream_currentToolCall, "f"))
              this._emit("toolCallCreated", __classPrivateFieldGet(this, _AssistantStream_currentToolCall, "f"));
          }
        }
      }
      this._emit("runStepDelta", event.data.delta, accumulatedRunStep);
      break;
    case "thread.run.step.completed":
    case "thread.run.step.failed":
    case "thread.run.step.cancelled":
    case "thread.run.step.expired":
      __classPrivateFieldSet(this, _AssistantStream_currentRunStepSnapshot, void 0);
      const details = event.data.step_details;
      if (details.type == "tool_calls") {
        if (__classPrivateFieldGet(this, _AssistantStream_currentToolCall, "f")) {
          this._emit("toolCallDone", __classPrivateFieldGet(this, _AssistantStream_currentToolCall, "f"));
          __classPrivateFieldSet(this, _AssistantStream_currentToolCall, void 0);
        }
      }
      this._emit("runStepDone", event.data, accumulatedRunStep);
      break;
  }
}, _AssistantStream_handleEvent = function _AssistantStream_handleEvent2(event) {
  __classPrivateFieldGet(this, _AssistantStream_events, "f").push(event);
  this._emit("event", event);
}, _AssistantStream_accumulateRunStep = function _AssistantStream_accumulateRunStep2(event) {
  switch (event.event) {
    case "thread.run.step.created":
      __classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, "f")[event.data.id] = event.data;
      return event.data;
    case "thread.run.step.delta":
      let snapshot = __classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, "f")[event.data.id];
      if (!snapshot) {
        throw Error("Received a RunStepDelta before creation of a snapshot");
      }
      let data = event.data;
      if (data.delta) {
        const accumulated = _a$2.accumulateDelta(snapshot, data.delta);
        __classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, "f")[event.data.id] = accumulated;
      }
      return __classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, "f")[event.data.id];
    case "thread.run.step.completed":
    case "thread.run.step.failed":
    case "thread.run.step.cancelled":
    case "thread.run.step.expired":
    case "thread.run.step.in_progress":
      __classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, "f")[event.data.id] = event.data;
      break;
  }
  if (__classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, "f")[event.data.id])
    return __classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, "f")[event.data.id];
  throw new Error("No snapshot available");
}, _AssistantStream_accumulateMessage = function _AssistantStream_accumulateMessage2(event, snapshot) {
  let newContent = [];
  switch (event.event) {
    case "thread.message.created":
      return [event.data, newContent];
    case "thread.message.delta":
      if (!snapshot) {
        throw Error("Received a delta with no existing snapshot (there should be one from message creation)");
      }
      let data = event.data;
      if (data.delta.content) {
        for (const contentElement of data.delta.content) {
          if (contentElement.index in snapshot.content) {
            let currentContent = snapshot.content[contentElement.index];
            snapshot.content[contentElement.index] = __classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_accumulateContent).call(this, contentElement, currentContent);
          } else {
            snapshot.content[contentElement.index] = contentElement;
            newContent.push(contentElement);
          }
        }
      }
      return [snapshot, newContent];
    case "thread.message.in_progress":
    case "thread.message.completed":
    case "thread.message.incomplete":
      if (snapshot) {
        return [snapshot, newContent];
      } else {
        throw Error("Received thread message event with no existing snapshot");
      }
  }
  throw Error("Tried to accumulate a non-message event");
}, _AssistantStream_accumulateContent = function _AssistantStream_accumulateContent2(contentElement, currentContent) {
  return _a$2.accumulateDelta(currentContent, contentElement);
}, _AssistantStream_handleRun = function _AssistantStream_handleRun2(event) {
  __classPrivateFieldSet(this, _AssistantStream_currentRunSnapshot, event.data);
  switch (event.event) {
    case "thread.run.created":
      break;
    case "thread.run.queued":
      break;
    case "thread.run.in_progress":
      break;
    case "thread.run.requires_action":
    case "thread.run.cancelled":
    case "thread.run.failed":
    case "thread.run.completed":
    case "thread.run.expired":
    case "thread.run.incomplete":
      __classPrivateFieldSet(this, _AssistantStream_finalRun, event.data);
      if (__classPrivateFieldGet(this, _AssistantStream_currentToolCall, "f")) {
        this._emit("toolCallDone", __classPrivateFieldGet(this, _AssistantStream_currentToolCall, "f"));
        __classPrivateFieldSet(this, _AssistantStream_currentToolCall, void 0);
      }
      break;
  }
};
let Runs$1 = class Runs2 extends APIResource {
  constructor() {
    super(...arguments);
    this.steps = new Steps(this._client);
  }
  create(threadID, params, options2) {
    const { include, ...body } = params;
    return this._client.post(path$1`/threads/${threadID}/runs`, {
      query: { include },
      body,
      ...options2,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options2 == null ? void 0 : options2.headers]),
      stream: params.stream ?? false
    });
  }
  /**
   * Retrieves a run.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  retrieve(runID, params, options2) {
    const { thread_id } = params;
    return this._client.get(path$1`/threads/${thread_id}/runs/${runID}`, {
      ...options2,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options2 == null ? void 0 : options2.headers])
    });
  }
  /**
   * Modifies a run.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  update(runID, params, options2) {
    const { thread_id, ...body } = params;
    return this._client.post(path$1`/threads/${thread_id}/runs/${runID}`, {
      body,
      ...options2,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options2 == null ? void 0 : options2.headers])
    });
  }
  /**
   * Returns a list of runs belonging to a thread.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  list(threadID, query = {}, options2) {
    return this._client.getAPIList(path$1`/threads/${threadID}/runs`, CursorPage, {
      query,
      ...options2,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options2 == null ? void 0 : options2.headers])
    });
  }
  /**
   * Cancels a run that is `in_progress`.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  cancel(runID, params, options2) {
    const { thread_id } = params;
    return this._client.post(path$1`/threads/${thread_id}/runs/${runID}/cancel`, {
      ...options2,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options2 == null ? void 0 : options2.headers])
    });
  }
  /**
   * A helper to create a run an poll for a terminal state. More information on Run
   * lifecycles can be found here:
   * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
   */
  async createAndPoll(threadId, body, options2) {
    const run = await this.create(threadId, body, options2);
    return await this.poll(run.id, { thread_id: threadId }, options2);
  }
  /**
   * Create a Run stream
   *
   * @deprecated use `stream` instead
   */
  createAndStream(threadId, body, options2) {
    return AssistantStream.createAssistantStream(threadId, this._client.beta.threads.runs, body, options2);
  }
  /**
   * A helper to poll a run status until it reaches a terminal state. More
   * information on Run lifecycles can be found here:
   * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
   */
  async poll(runId, params, options2) {
    var _a3;
    const headers = buildHeaders([
      options2 == null ? void 0 : options2.headers,
      {
        "X-Stainless-Poll-Helper": "true",
        "X-Stainless-Custom-Poll-Interval": ((_a3 = options2 == null ? void 0 : options2.pollIntervalMs) == null ? void 0 : _a3.toString()) ?? void 0
      }
    ]);
    while (true) {
      const { data: run, response } = await this.retrieve(runId, params, {
        ...options2,
        headers: { ...options2 == null ? void 0 : options2.headers, ...headers }
      }).withResponse();
      switch (run.status) {
        case "queued":
        case "in_progress":
        case "cancelling":
          let sleepInterval = 5e3;
          if (options2 == null ? void 0 : options2.pollIntervalMs) {
            sleepInterval = options2.pollIntervalMs;
          } else {
            const headerInterval = response.headers.get("openai-poll-after-ms");
            if (headerInterval) {
              const headerIntervalMs = parseInt(headerInterval);
              if (!isNaN(headerIntervalMs)) {
                sleepInterval = headerIntervalMs;
              }
            }
          }
          await sleep(sleepInterval);
          break;
        case "requires_action":
        case "incomplete":
        case "cancelled":
        case "completed":
        case "failed":
        case "expired":
          return run;
      }
    }
  }
  /**
   * Create a Run stream
   */
  stream(threadId, body, options2) {
    return AssistantStream.createAssistantStream(threadId, this._client.beta.threads.runs, body, options2);
  }
  submitToolOutputs(runID, params, options2) {
    const { thread_id, ...body } = params;
    return this._client.post(path$1`/threads/${thread_id}/runs/${runID}/submit_tool_outputs`, {
      body,
      ...options2,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options2 == null ? void 0 : options2.headers]),
      stream: params.stream ?? false
    });
  }
  /**
   * A helper to submit a tool output to a run and poll for a terminal run state.
   * More information on Run lifecycles can be found here:
   * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
   */
  async submitToolOutputsAndPoll(runId, params, options2) {
    const run = await this.submitToolOutputs(runId, params, options2);
    return await this.poll(run.id, params, options2);
  }
  /**
   * Submit the tool outputs from a previous run and stream the run to a terminal
   * state. More information on Run lifecycles can be found here:
   * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
   */
  submitToolOutputsStream(runId, params, options2) {
    return AssistantStream.createToolAssistantStream(runId, this._client.beta.threads.runs, params, options2);
  }
};
Runs$1.Steps = Steps;
class Threads extends APIResource {
  constructor() {
    super(...arguments);
    this.runs = new Runs$1(this._client);
    this.messages = new Messages(this._client);
  }
  /**
   * Create a thread.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  create(body = {}, options2) {
    return this._client.post("/threads", {
      body,
      ...options2,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options2 == null ? void 0 : options2.headers])
    });
  }
  /**
   * Retrieves a thread.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  retrieve(threadID, options2) {
    return this._client.get(path$1`/threads/${threadID}`, {
      ...options2,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options2 == null ? void 0 : options2.headers])
    });
  }
  /**
   * Modifies a thread.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  update(threadID, body, options2) {
    return this._client.post(path$1`/threads/${threadID}`, {
      body,
      ...options2,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options2 == null ? void 0 : options2.headers])
    });
  }
  /**
   * Delete a thread.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  delete(threadID, options2) {
    return this._client.delete(path$1`/threads/${threadID}`, {
      ...options2,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options2 == null ? void 0 : options2.headers])
    });
  }
  createAndRun(body, options2) {
    return this._client.post("/threads/runs", {
      body,
      ...options2,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options2 == null ? void 0 : options2.headers]),
      stream: body.stream ?? false
    });
  }
  /**
   * A helper to create a thread, start a run and then poll for a terminal state.
   * More information on Run lifecycles can be found here:
   * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
   */
  async createAndRunPoll(body, options2) {
    const run = await this.createAndRun(body, options2);
    return await this.runs.poll(run.id, { thread_id: run.thread_id }, options2);
  }
  /**
   * Create a thread and stream the run back
   */
  createAndRunStream(body, options2) {
    return AssistantStream.createThreadAssistantStream(body, this._client.beta.threads, options2);
  }
}
Threads.Runs = Runs$1;
Threads.Messages = Messages;
class Beta extends APIResource {
  constructor() {
    super(...arguments);
    this.realtime = new Realtime$1(this._client);
    this.chatkit = new ChatKit(this._client);
    this.assistants = new Assistants(this._client);
    this.threads = new Threads(this._client);
  }
}
Beta.Realtime = Realtime$1;
Beta.ChatKit = ChatKit;
Beta.Assistants = Assistants;
Beta.Threads = Threads;
class Completions extends APIResource {
  create(body, options2) {
    return this._client.post("/completions", { body, ...options2, stream: body.stream ?? false });
  }
}
class Content extends APIResource {
  /**
   * Retrieve Container File Content
   */
  retrieve(fileID, params, options2) {
    const { container_id } = params;
    return this._client.get(path$1`/containers/${container_id}/files/${fileID}/content`, {
      ...options2,
      headers: buildHeaders([{ Accept: "application/binary" }, options2 == null ? void 0 : options2.headers]),
      __binaryResponse: true
    });
  }
}
let Files$2 = class Files2 extends APIResource {
  constructor() {
    super(...arguments);
    this.content = new Content(this._client);
  }
  /**
   * Create a Container File
   *
   * You can send either a multipart/form-data request with the raw file content, or
   * a JSON request with a file ID.
   */
  create(containerID, body, options2) {
    return this._client.post(path$1`/containers/${containerID}/files`, multipartFormRequestOptions({ body, ...options2 }, this._client));
  }
  /**
   * Retrieve Container File
   */
  retrieve(fileID, params, options2) {
    const { container_id } = params;
    return this._client.get(path$1`/containers/${container_id}/files/${fileID}`, options2);
  }
  /**
   * List Container files
   */
  list(containerID, query = {}, options2) {
    return this._client.getAPIList(path$1`/containers/${containerID}/files`, CursorPage, {
      query,
      ...options2
    });
  }
  /**
   * Delete Container File
   */
  delete(fileID, params, options2) {
    const { container_id } = params;
    return this._client.delete(path$1`/containers/${container_id}/files/${fileID}`, {
      ...options2,
      headers: buildHeaders([{ Accept: "*/*" }, options2 == null ? void 0 : options2.headers])
    });
  }
};
Files$2.Content = Content;
class Containers extends APIResource {
  constructor() {
    super(...arguments);
    this.files = new Files$2(this._client);
  }
  /**
   * Create Container
   */
  create(body, options2) {
    return this._client.post("/containers", { body, ...options2 });
  }
  /**
   * Retrieve Container
   */
  retrieve(containerID, options2) {
    return this._client.get(path$1`/containers/${containerID}`, options2);
  }
  /**
   * List Containers
   */
  list(query = {}, options2) {
    return this._client.getAPIList("/containers", CursorPage, { query, ...options2 });
  }
  /**
   * Delete Container
   */
  delete(containerID, options2) {
    return this._client.delete(path$1`/containers/${containerID}`, {
      ...options2,
      headers: buildHeaders([{ Accept: "*/*" }, options2 == null ? void 0 : options2.headers])
    });
  }
}
Containers.Files = Files$2;
class Items extends APIResource {
  /**
   * Create items in a conversation with the given ID.
   */
  create(conversationID, params, options2) {
    const { include, ...body } = params;
    return this._client.post(path$1`/conversations/${conversationID}/items`, {
      query: { include },
      body,
      ...options2
    });
  }
  /**
   * Get a single item from a conversation with the given IDs.
   */
  retrieve(itemID, params, options2) {
    const { conversation_id, ...query } = params;
    return this._client.get(path$1`/conversations/${conversation_id}/items/${itemID}`, { query, ...options2 });
  }
  /**
   * List all items for a conversation with the given ID.
   */
  list(conversationID, query = {}, options2) {
    return this._client.getAPIList(path$1`/conversations/${conversationID}/items`, ConversationCursorPage, { query, ...options2 });
  }
  /**
   * Delete an item from a conversation with the given IDs.
   */
  delete(itemID, params, options2) {
    const { conversation_id } = params;
    return this._client.delete(path$1`/conversations/${conversation_id}/items/${itemID}`, options2);
  }
}
class Conversations extends APIResource {
  constructor() {
    super(...arguments);
    this.items = new Items(this._client);
  }
  /**
   * Create a conversation.
   */
  create(body = {}, options2) {
    return this._client.post("/conversations", { body, ...options2 });
  }
  /**
   * Get a conversation
   */
  retrieve(conversationID, options2) {
    return this._client.get(path$1`/conversations/${conversationID}`, options2);
  }
  /**
   * Update a conversation
   */
  update(conversationID, body, options2) {
    return this._client.post(path$1`/conversations/${conversationID}`, { body, ...options2 });
  }
  /**
   * Delete a conversation. Items in the conversation will not be deleted.
   */
  delete(conversationID, options2) {
    return this._client.delete(path$1`/conversations/${conversationID}`, options2);
  }
}
Conversations.Items = Items;
let Embeddings$1 = class Embeddings2 extends APIResource {
  /**
   * Creates an embedding vector representing the input text.
   *
   * @example
   * ```ts
   * const createEmbeddingResponse =
   *   await client.embeddings.create({
   *     input: 'The quick brown fox jumped over the lazy dog',
   *     model: 'text-embedding-3-small',
   *   });
   * ```
   */
  create(body, options2) {
    const hasUserProvidedEncodingFormat = !!body.encoding_format;
    let encoding_format = hasUserProvidedEncodingFormat ? body.encoding_format : "base64";
    if (hasUserProvidedEncodingFormat) {
      loggerFor(this._client).debug("embeddings/user defined encoding_format:", body.encoding_format);
    }
    const response = this._client.post("/embeddings", {
      body: {
        ...body,
        encoding_format
      },
      ...options2
    });
    if (hasUserProvidedEncodingFormat) {
      return response;
    }
    loggerFor(this._client).debug("embeddings/decoding base64 embeddings from base64");
    return response._thenUnwrap((response2) => {
      if (response2 && response2.data) {
        response2.data.forEach((embeddingBase64Obj) => {
          const embeddingBase64Str = embeddingBase64Obj.embedding;
          embeddingBase64Obj.embedding = toFloat32Array(embeddingBase64Str);
        });
      }
      return response2;
    });
  }
};
class OutputItems extends APIResource {
  /**
   * Get an evaluation run output item by ID.
   */
  retrieve(outputItemID, params, options2) {
    const { eval_id, run_id } = params;
    return this._client.get(path$1`/evals/${eval_id}/runs/${run_id}/output_items/${outputItemID}`, options2);
  }
  /**
   * Get a list of output items for an evaluation run.
   */
  list(runID, params, options2) {
    const { eval_id, ...query } = params;
    return this._client.getAPIList(path$1`/evals/${eval_id}/runs/${runID}/output_items`, CursorPage, { query, ...options2 });
  }
}
class Runs extends APIResource {
  constructor() {
    super(...arguments);
    this.outputItems = new OutputItems(this._client);
  }
  /**
   * Kicks off a new run for a given evaluation, specifying the data source, and what
   * model configuration to use to test. The datasource will be validated against the
   * schema specified in the config of the evaluation.
   */
  create(evalID, body, options2) {
    return this._client.post(path$1`/evals/${evalID}/runs`, { body, ...options2 });
  }
  /**
   * Get an evaluation run by ID.
   */
  retrieve(runID, params, options2) {
    const { eval_id } = params;
    return this._client.get(path$1`/evals/${eval_id}/runs/${runID}`, options2);
  }
  /**
   * Get a list of runs for an evaluation.
   */
  list(evalID, query = {}, options2) {
    return this._client.getAPIList(path$1`/evals/${evalID}/runs`, CursorPage, {
      query,
      ...options2
    });
  }
  /**
   * Delete an eval run.
   */
  delete(runID, params, options2) {
    const { eval_id } = params;
    return this._client.delete(path$1`/evals/${eval_id}/runs/${runID}`, options2);
  }
  /**
   * Cancel an ongoing evaluation run.
   */
  cancel(runID, params, options2) {
    const { eval_id } = params;
    return this._client.post(path$1`/evals/${eval_id}/runs/${runID}`, options2);
  }
}
Runs.OutputItems = OutputItems;
class Evals extends APIResource {
  constructor() {
    super(...arguments);
    this.runs = new Runs(this._client);
  }
  /**
   * Create the structure of an evaluation that can be used to test a model's
   * performance. An evaluation is a set of testing criteria and the config for a
   * data source, which dictates the schema of the data used in the evaluation. After
   * creating an evaluation, you can run it on different models and model parameters.
   * We support several types of graders and datasources. For more information, see
   * the [Evals guide](https://platform.openai.com/docs/guides/evals).
   */
  create(body, options2) {
    return this._client.post("/evals", { body, ...options2 });
  }
  /**
   * Get an evaluation by ID.
   */
  retrieve(evalID, options2) {
    return this._client.get(path$1`/evals/${evalID}`, options2);
  }
  /**
   * Update certain properties of an evaluation.
   */
  update(evalID, body, options2) {
    return this._client.post(path$1`/evals/${evalID}`, { body, ...options2 });
  }
  /**
   * List evaluations for a project.
   */
  list(query = {}, options2) {
    return this._client.getAPIList("/evals", CursorPage, { query, ...options2 });
  }
  /**
   * Delete an evaluation.
   */
  delete(evalID, options2) {
    return this._client.delete(path$1`/evals/${evalID}`, options2);
  }
}
Evals.Runs = Runs;
let Files$1 = class Files3 extends APIResource {
  /**
   * Upload a file that can be used across various endpoints. Individual files can be
   * up to 512 MB, and the size of all files uploaded by one organization can be up
   * to 1 TB.
   *
   * - The Assistants API supports files up to 2 million tokens and of specific file
   *   types. See the
   *   [Assistants Tools guide](https://platform.openai.com/docs/assistants/tools)
   *   for details.
   * - The Fine-tuning API only supports `.jsonl` files. The input also has certain
   *   required formats for fine-tuning
   *   [chat](https://platform.openai.com/docs/api-reference/fine-tuning/chat-input)
   *   or
   *   [completions](https://platform.openai.com/docs/api-reference/fine-tuning/completions-input)
   *   models.
   * - The Batch API only supports `.jsonl` files up to 200 MB in size. The input
   *   also has a specific required
   *   [format](https://platform.openai.com/docs/api-reference/batch/request-input).
   *
   * Please [contact us](https://help.openai.com/) if you need to increase these
   * storage limits.
   */
  create(body, options2) {
    return this._client.post("/files", multipartFormRequestOptions({ body, ...options2 }, this._client));
  }
  /**
   * Returns information about a specific file.
   */
  retrieve(fileID, options2) {
    return this._client.get(path$1`/files/${fileID}`, options2);
  }
  /**
   * Returns a list of files.
   */
  list(query = {}, options2) {
    return this._client.getAPIList("/files", CursorPage, { query, ...options2 });
  }
  /**
   * Delete a file and remove it from all vector stores.
   */
  delete(fileID, options2) {
    return this._client.delete(path$1`/files/${fileID}`, options2);
  }
  /**
   * Returns the contents of the specified file.
   */
  content(fileID, options2) {
    return this._client.get(path$1`/files/${fileID}/content`, {
      ...options2,
      headers: buildHeaders([{ Accept: "application/binary" }, options2 == null ? void 0 : options2.headers]),
      __binaryResponse: true
    });
  }
  /**
   * Waits for the given file to be processed, default timeout is 30 mins.
   */
  async waitForProcessing(id, { pollInterval = 5e3, maxWait = 30 * 60 * 1e3 } = {}) {
    const TERMINAL_STATES = /* @__PURE__ */ new Set(["processed", "error", "deleted"]);
    const start = Date.now();
    let file = await this.retrieve(id);
    while (!file.status || !TERMINAL_STATES.has(file.status)) {
      await sleep(pollInterval);
      file = await this.retrieve(id);
      if (Date.now() - start > maxWait) {
        throw new APIConnectionTimeoutError({
          message: `Giving up on waiting for file ${id} to finish processing after ${maxWait} milliseconds.`
        });
      }
    }
    return file;
  }
};
class Methods extends APIResource {
}
let Graders$1 = class Graders2 extends APIResource {
  /**
   * Run a grader.
   *
   * @example
   * ```ts
   * const response = await client.fineTuning.alpha.graders.run({
   *   grader: {
   *     input: 'input',
   *     name: 'name',
   *     operation: 'eq',
   *     reference: 'reference',
   *     type: 'string_check',
   *   },
   *   model_sample: 'model_sample',
   * });
   * ```
   */
  run(body, options2) {
    return this._client.post("/fine_tuning/alpha/graders/run", { body, ...options2 });
  }
  /**
   * Validate a grader.
   *
   * @example
   * ```ts
   * const response =
   *   await client.fineTuning.alpha.graders.validate({
   *     grader: {
   *       input: 'input',
   *       name: 'name',
   *       operation: 'eq',
   *       reference: 'reference',
   *       type: 'string_check',
   *     },
   *   });
   * ```
   */
  validate(body, options2) {
    return this._client.post("/fine_tuning/alpha/graders/validate", { body, ...options2 });
  }
};
class Alpha extends APIResource {
  constructor() {
    super(...arguments);
    this.graders = new Graders$1(this._client);
  }
}
Alpha.Graders = Graders$1;
class Permissions extends APIResource {
  /**
   * **NOTE:** Calling this endpoint requires an [admin API key](../admin-api-keys).
   *
   * This enables organization owners to share fine-tuned models with other projects
   * in their organization.
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const permissionCreateResponse of client.fineTuning.checkpoints.permissions.create(
   *   'ft:gpt-4o-mini-2024-07-18:org:weather:B7R9VjQd',
   *   { project_ids: ['string'] },
   * )) {
   *   // ...
   * }
   * ```
   */
  create(fineTunedModelCheckpoint, body, options2) {
    return this._client.getAPIList(path$1`/fine_tuning/checkpoints/${fineTunedModelCheckpoint}/permissions`, Page, { body, method: "post", ...options2 });
  }
  /**
   * **NOTE:** This endpoint requires an [admin API key](../admin-api-keys).
   *
   * Organization owners can use this endpoint to view all permissions for a
   * fine-tuned model checkpoint.
   *
   * @example
   * ```ts
   * const permission =
   *   await client.fineTuning.checkpoints.permissions.retrieve(
   *     'ft-AF1WoRqd3aJAHsqc9NY7iL8F',
   *   );
   * ```
   */
  retrieve(fineTunedModelCheckpoint, query = {}, options2) {
    return this._client.get(path$1`/fine_tuning/checkpoints/${fineTunedModelCheckpoint}/permissions`, {
      query,
      ...options2
    });
  }
  /**
   * **NOTE:** This endpoint requires an [admin API key](../admin-api-keys).
   *
   * Organization owners can use this endpoint to delete a permission for a
   * fine-tuned model checkpoint.
   *
   * @example
   * ```ts
   * const permission =
   *   await client.fineTuning.checkpoints.permissions.delete(
   *     'cp_zc4Q7MP6XxulcVzj4MZdwsAB',
   *     {
   *       fine_tuned_model_checkpoint:
   *         'ft:gpt-4o-mini-2024-07-18:org:weather:B7R9VjQd',
   *     },
   *   );
   * ```
   */
  delete(permissionID, params, options2) {
    const { fine_tuned_model_checkpoint } = params;
    return this._client.delete(path$1`/fine_tuning/checkpoints/${fine_tuned_model_checkpoint}/permissions/${permissionID}`, options2);
  }
}
let Checkpoints$1 = class Checkpoints2 extends APIResource {
  constructor() {
    super(...arguments);
    this.permissions = new Permissions(this._client);
  }
};
Checkpoints$1.Permissions = Permissions;
class Checkpoints extends APIResource {
  /**
   * List checkpoints for a fine-tuning job.
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const fineTuningJobCheckpoint of client.fineTuning.jobs.checkpoints.list(
   *   'ft-AF1WoRqd3aJAHsqc9NY7iL8F',
   * )) {
   *   // ...
   * }
   * ```
   */
  list(fineTuningJobID, query = {}, options2) {
    return this._client.getAPIList(path$1`/fine_tuning/jobs/${fineTuningJobID}/checkpoints`, CursorPage, { query, ...options2 });
  }
}
class Jobs extends APIResource {
  constructor() {
    super(...arguments);
    this.checkpoints = new Checkpoints(this._client);
  }
  /**
   * Creates a fine-tuning job which begins the process of creating a new model from
   * a given dataset.
   *
   * Response includes details of the enqueued job including job status and the name
   * of the fine-tuned models once complete.
   *
   * [Learn more about fine-tuning](https://platform.openai.com/docs/guides/model-optimization)
   *
   * @example
   * ```ts
   * const fineTuningJob = await client.fineTuning.jobs.create({
   *   model: 'gpt-4o-mini',
   *   training_file: 'file-abc123',
   * });
   * ```
   */
  create(body, options2) {
    return this._client.post("/fine_tuning/jobs", { body, ...options2 });
  }
  /**
   * Get info about a fine-tuning job.
   *
   * [Learn more about fine-tuning](https://platform.openai.com/docs/guides/model-optimization)
   *
   * @example
   * ```ts
   * const fineTuningJob = await client.fineTuning.jobs.retrieve(
   *   'ft-AF1WoRqd3aJAHsqc9NY7iL8F',
   * );
   * ```
   */
  retrieve(fineTuningJobID, options2) {
    return this._client.get(path$1`/fine_tuning/jobs/${fineTuningJobID}`, options2);
  }
  /**
   * List your organization's fine-tuning jobs
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const fineTuningJob of client.fineTuning.jobs.list()) {
   *   // ...
   * }
   * ```
   */
  list(query = {}, options2) {
    return this._client.getAPIList("/fine_tuning/jobs", CursorPage, { query, ...options2 });
  }
  /**
   * Immediately cancel a fine-tune job.
   *
   * @example
   * ```ts
   * const fineTuningJob = await client.fineTuning.jobs.cancel(
   *   'ft-AF1WoRqd3aJAHsqc9NY7iL8F',
   * );
   * ```
   */
  cancel(fineTuningJobID, options2) {
    return this._client.post(path$1`/fine_tuning/jobs/${fineTuningJobID}/cancel`, options2);
  }
  /**
   * Get status updates for a fine-tuning job.
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const fineTuningJobEvent of client.fineTuning.jobs.listEvents(
   *   'ft-AF1WoRqd3aJAHsqc9NY7iL8F',
   * )) {
   *   // ...
   * }
   * ```
   */
  listEvents(fineTuningJobID, query = {}, options2) {
    return this._client.getAPIList(path$1`/fine_tuning/jobs/${fineTuningJobID}/events`, CursorPage, { query, ...options2 });
  }
  /**
   * Pause a fine-tune job.
   *
   * @example
   * ```ts
   * const fineTuningJob = await client.fineTuning.jobs.pause(
   *   'ft-AF1WoRqd3aJAHsqc9NY7iL8F',
   * );
   * ```
   */
  pause(fineTuningJobID, options2) {
    return this._client.post(path$1`/fine_tuning/jobs/${fineTuningJobID}/pause`, options2);
  }
  /**
   * Resume a fine-tune job.
   *
   * @example
   * ```ts
   * const fineTuningJob = await client.fineTuning.jobs.resume(
   *   'ft-AF1WoRqd3aJAHsqc9NY7iL8F',
   * );
   * ```
   */
  resume(fineTuningJobID, options2) {
    return this._client.post(path$1`/fine_tuning/jobs/${fineTuningJobID}/resume`, options2);
  }
}
Jobs.Checkpoints = Checkpoints;
class FineTuning extends APIResource {
  constructor() {
    super(...arguments);
    this.methods = new Methods(this._client);
    this.jobs = new Jobs(this._client);
    this.checkpoints = new Checkpoints$1(this._client);
    this.alpha = new Alpha(this._client);
  }
}
FineTuning.Methods = Methods;
FineTuning.Jobs = Jobs;
FineTuning.Checkpoints = Checkpoints$1;
FineTuning.Alpha = Alpha;
class GraderModels extends APIResource {
}
class Graders extends APIResource {
  constructor() {
    super(...arguments);
    this.graderModels = new GraderModels(this._client);
  }
}
Graders.GraderModels = GraderModels;
class Images extends APIResource {
  /**
   * Creates a variation of a given image. This endpoint only supports `dall-e-2`.
   *
   * @example
   * ```ts
   * const imagesResponse = await client.images.createVariation({
   *   image: fs.createReadStream('otter.png'),
   * });
   * ```
   */
  createVariation(body, options2) {
    return this._client.post("/images/variations", multipartFormRequestOptions({ body, ...options2 }, this._client));
  }
  edit(body, options2) {
    return this._client.post("/images/edits", multipartFormRequestOptions({ body, ...options2, stream: body.stream ?? false }, this._client));
  }
  generate(body, options2) {
    return this._client.post("/images/generations", { body, ...options2, stream: body.stream ?? false });
  }
}
class Models extends APIResource {
  /**
   * Retrieves a model instance, providing basic information about the model such as
   * the owner and permissioning.
   */
  retrieve(model, options2) {
    return this._client.get(path$1`/models/${model}`, options2);
  }
  /**
   * Lists the currently available models, and provides basic information about each
   * one such as the owner and availability.
   */
  list(options2) {
    return this._client.getAPIList("/models", Page, options2);
  }
  /**
   * Delete a fine-tuned model. You must have the Owner role in your organization to
   * delete a model.
   */
  delete(model, options2) {
    return this._client.delete(path$1`/models/${model}`, options2);
  }
}
class Moderations extends APIResource {
  /**
   * Classifies if text and/or image inputs are potentially harmful. Learn more in
   * the [moderation guide](https://platform.openai.com/docs/guides/moderation).
   */
  create(body, options2) {
    return this._client.post("/moderations", { body, ...options2 });
  }
}
class Calls extends APIResource {
  /**
   * Accept an incoming SIP call and configure the realtime session that will handle
   * it.
   *
   * @example
   * ```ts
   * await client.realtime.calls.accept('call_id', {
   *   type: 'realtime',
   * });
   * ```
   */
  accept(callID, body, options2) {
    return this._client.post(path$1`/realtime/calls/${callID}/accept`, {
      body,
      ...options2,
      headers: buildHeaders([{ Accept: "*/*" }, options2 == null ? void 0 : options2.headers])
    });
  }
  /**
   * End an active Realtime API call, whether it was initiated over SIP or WebRTC.
   *
   * @example
   * ```ts
   * await client.realtime.calls.hangup('call_id');
   * ```
   */
  hangup(callID, options2) {
    return this._client.post(path$1`/realtime/calls/${callID}/hangup`, {
      ...options2,
      headers: buildHeaders([{ Accept: "*/*" }, options2 == null ? void 0 : options2.headers])
    });
  }
  /**
   * Transfer an active SIP call to a new destination using the SIP REFER verb.
   *
   * @example
   * ```ts
   * await client.realtime.calls.refer('call_id', {
   *   target_uri: 'tel:+14155550123',
   * });
   * ```
   */
  refer(callID, body, options2) {
    return this._client.post(path$1`/realtime/calls/${callID}/refer`, {
      body,
      ...options2,
      headers: buildHeaders([{ Accept: "*/*" }, options2 == null ? void 0 : options2.headers])
    });
  }
  /**
   * Decline an incoming SIP call by returning a SIP status code to the caller.
   *
   * @example
   * ```ts
   * await client.realtime.calls.reject('call_id');
   * ```
   */
  reject(callID, body = {}, options2) {
    return this._client.post(path$1`/realtime/calls/${callID}/reject`, {
      body,
      ...options2,
      headers: buildHeaders([{ Accept: "*/*" }, options2 == null ? void 0 : options2.headers])
    });
  }
}
class ClientSecrets extends APIResource {
  /**
   * Create a Realtime client secret with an associated session configuration.
   *
   * @example
   * ```ts
   * const clientSecret =
   *   await client.realtime.clientSecrets.create();
   * ```
   */
  create(body, options2) {
    return this._client.post("/realtime/client_secrets", { body, ...options2 });
  }
}
class Realtime extends APIResource {
  constructor() {
    super(...arguments);
    this.clientSecrets = new ClientSecrets(this._client);
    this.calls = new Calls(this._client);
  }
}
Realtime.ClientSecrets = ClientSecrets;
Realtime.Calls = Calls;
function maybeParseResponse(response, params) {
  if (!params || !hasAutoParseableInput(params)) {
    return {
      ...response,
      output_parsed: null,
      output: response.output.map((item) => {
        if (item.type === "function_call") {
          return {
            ...item,
            parsed_arguments: null
          };
        }
        if (item.type === "message") {
          return {
            ...item,
            content: item.content.map((content) => ({
              ...content,
              parsed: null
            }))
          };
        } else {
          return item;
        }
      })
    };
  }
  return parseResponse(response, params);
}
function parseResponse(response, params) {
  const output = response.output.map((item) => {
    if (item.type === "function_call") {
      return {
        ...item,
        parsed_arguments: parseToolCall$1(params, item)
      };
    }
    if (item.type === "message") {
      const content = item.content.map((content2) => {
        if (content2.type === "output_text") {
          return {
            ...content2,
            parsed: parseTextFormat(params, content2.text)
          };
        }
        return content2;
      });
      return {
        ...item,
        content
      };
    }
    return item;
  });
  const parsed = Object.assign({}, response, { output });
  if (!Object.getOwnPropertyDescriptor(response, "output_text")) {
    addOutputText(parsed);
  }
  Object.defineProperty(parsed, "output_parsed", {
    enumerable: true,
    get() {
      for (const output2 of parsed.output) {
        if (output2.type !== "message") {
          continue;
        }
        for (const content of output2.content) {
          if (content.type === "output_text" && content.parsed !== null) {
            return content.parsed;
          }
        }
      }
      return null;
    }
  });
  return parsed;
}
function parseTextFormat(params, content) {
  var _a3, _b, _c, _d;
  if (((_b = (_a3 = params.text) == null ? void 0 : _a3.format) == null ? void 0 : _b.type) !== "json_schema") {
    return null;
  }
  if ("$parseRaw" in ((_c = params.text) == null ? void 0 : _c.format)) {
    const text_format = (_d = params.text) == null ? void 0 : _d.format;
    return text_format.$parseRaw(content);
  }
  return JSON.parse(content);
}
function hasAutoParseableInput(params) {
  var _a3;
  if (isAutoParsableResponseFormat((_a3 = params.text) == null ? void 0 : _a3.format)) {
    return true;
  }
  return false;
}
function isAutoParsableTool(tool2) {
  return (tool2 == null ? void 0 : tool2["$brand"]) === "auto-parseable-tool";
}
function getInputToolByName(input_tools, name) {
  return input_tools.find((tool2) => tool2.type === "function" && tool2.name === name);
}
function parseToolCall$1(params, toolCall) {
  const inputTool = getInputToolByName(params.tools ?? [], toolCall.name);
  return {
    ...toolCall,
    ...toolCall,
    parsed_arguments: isAutoParsableTool(inputTool) ? inputTool.$parseRaw(toolCall.arguments) : (inputTool == null ? void 0 : inputTool.strict) ? JSON.parse(toolCall.arguments) : null
  };
}
function addOutputText(rsp) {
  const texts = [];
  for (const output of rsp.output) {
    if (output.type !== "message") {
      continue;
    }
    for (const content of output.content) {
      if (content.type === "output_text") {
        texts.push(content.text);
      }
    }
  }
  rsp.output_text = texts.join("");
}
var _ResponseStream_instances, _ResponseStream_params, _ResponseStream_currentResponseSnapshot, _ResponseStream_finalResponse, _ResponseStream_beginRequest, _ResponseStream_addEvent, _ResponseStream_endRequest, _ResponseStream_accumulateResponse;
class ResponseStream extends EventStream {
  constructor(params) {
    super();
    _ResponseStream_instances.add(this);
    _ResponseStream_params.set(this, void 0);
    _ResponseStream_currentResponseSnapshot.set(this, void 0);
    _ResponseStream_finalResponse.set(this, void 0);
    __classPrivateFieldSet(this, _ResponseStream_params, params);
  }
  static createResponse(client2, params, options2) {
    const runner = new ResponseStream(params);
    runner._run(() => runner._createOrRetrieveResponse(client2, params, {
      ...options2,
      headers: { ...options2 == null ? void 0 : options2.headers, "X-Stainless-Helper-Method": "stream" }
    }));
    return runner;
  }
  async _createOrRetrieveResponse(client2, params, options2) {
    var _a3;
    const signal = options2 == null ? void 0 : options2.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    __classPrivateFieldGet(this, _ResponseStream_instances, "m", _ResponseStream_beginRequest).call(this);
    let stream;
    let starting_after = null;
    if ("response_id" in params) {
      stream = await client2.responses.retrieve(params.response_id, { stream: true }, { ...options2, signal: this.controller.signal, stream: true });
      starting_after = params.starting_after ?? null;
    } else {
      stream = await client2.responses.create({ ...params, stream: true }, { ...options2, signal: this.controller.signal });
    }
    this._connected();
    for await (const event of stream) {
      __classPrivateFieldGet(this, _ResponseStream_instances, "m", _ResponseStream_addEvent).call(this, event, starting_after);
    }
    if ((_a3 = stream.controller.signal) == null ? void 0 : _a3.aborted) {
      throw new APIUserAbortError();
    }
    return __classPrivateFieldGet(this, _ResponseStream_instances, "m", _ResponseStream_endRequest).call(this);
  }
  [(_ResponseStream_params = /* @__PURE__ */ new WeakMap(), _ResponseStream_currentResponseSnapshot = /* @__PURE__ */ new WeakMap(), _ResponseStream_finalResponse = /* @__PURE__ */ new WeakMap(), _ResponseStream_instances = /* @__PURE__ */ new WeakSet(), _ResponseStream_beginRequest = function _ResponseStream_beginRequest2() {
    if (this.ended)
      return;
    __classPrivateFieldSet(this, _ResponseStream_currentResponseSnapshot, void 0);
  }, _ResponseStream_addEvent = function _ResponseStream_addEvent2(event, starting_after) {
    if (this.ended)
      return;
    const maybeEmit = (name, event2) => {
      if (starting_after == null || event2.sequence_number > starting_after) {
        this._emit(name, event2);
      }
    };
    const response = __classPrivateFieldGet(this, _ResponseStream_instances, "m", _ResponseStream_accumulateResponse).call(this, event);
    maybeEmit("event", event);
    switch (event.type) {
      case "response.output_text.delta": {
        const output = response.output[event.output_index];
        if (!output) {
          throw new OpenAIError(`missing output at index ${event.output_index}`);
        }
        if (output.type === "message") {
          const content = output.content[event.content_index];
          if (!content) {
            throw new OpenAIError(`missing content at index ${event.content_index}`);
          }
          if (content.type !== "output_text") {
            throw new OpenAIError(`expected content to be 'output_text', got ${content.type}`);
          }
          maybeEmit("response.output_text.delta", {
            ...event,
            snapshot: content.text
          });
        }
        break;
      }
      case "response.function_call_arguments.delta": {
        const output = response.output[event.output_index];
        if (!output) {
          throw new OpenAIError(`missing output at index ${event.output_index}`);
        }
        if (output.type === "function_call") {
          maybeEmit("response.function_call_arguments.delta", {
            ...event,
            snapshot: output.arguments
          });
        }
        break;
      }
      default:
        maybeEmit(event.type, event);
        break;
    }
  }, _ResponseStream_endRequest = function _ResponseStream_endRequest2() {
    if (this.ended) {
      throw new OpenAIError(`stream has ended, this shouldn't happen`);
    }
    const snapshot = __classPrivateFieldGet(this, _ResponseStream_currentResponseSnapshot, "f");
    if (!snapshot) {
      throw new OpenAIError(`request ended without sending any events`);
    }
    __classPrivateFieldSet(this, _ResponseStream_currentResponseSnapshot, void 0);
    const parsedResponse = finalizeResponse(snapshot, __classPrivateFieldGet(this, _ResponseStream_params, "f"));
    __classPrivateFieldSet(this, _ResponseStream_finalResponse, parsedResponse);
    return parsedResponse;
  }, _ResponseStream_accumulateResponse = function _ResponseStream_accumulateResponse2(event) {
    var _a3;
    let snapshot = __classPrivateFieldGet(this, _ResponseStream_currentResponseSnapshot, "f");
    if (!snapshot) {
      if (event.type !== "response.created") {
        throw new OpenAIError(`When snapshot hasn't been set yet, expected 'response.created' event, got ${event.type}`);
      }
      snapshot = __classPrivateFieldSet(this, _ResponseStream_currentResponseSnapshot, event.response);
      return snapshot;
    }
    switch (event.type) {
      case "response.output_item.added": {
        snapshot.output.push(event.item);
        break;
      }
      case "response.content_part.added": {
        const output = snapshot.output[event.output_index];
        if (!output) {
          throw new OpenAIError(`missing output at index ${event.output_index}`);
        }
        const type = output.type;
        const part = event.part;
        if (type === "message" && part.type !== "reasoning_text") {
          output.content.push(part);
        } else if (type === "reasoning" && part.type === "reasoning_text") {
          if (!output.content) {
            output.content = [];
          }
          output.content.push(part);
        }
        break;
      }
      case "response.output_text.delta": {
        const output = snapshot.output[event.output_index];
        if (!output) {
          throw new OpenAIError(`missing output at index ${event.output_index}`);
        }
        if (output.type === "message") {
          const content = output.content[event.content_index];
          if (!content) {
            throw new OpenAIError(`missing content at index ${event.content_index}`);
          }
          if (content.type !== "output_text") {
            throw new OpenAIError(`expected content to be 'output_text', got ${content.type}`);
          }
          content.text += event.delta;
        }
        break;
      }
      case "response.function_call_arguments.delta": {
        const output = snapshot.output[event.output_index];
        if (!output) {
          throw new OpenAIError(`missing output at index ${event.output_index}`);
        }
        if (output.type === "function_call") {
          output.arguments += event.delta;
        }
        break;
      }
      case "response.reasoning_text.delta": {
        const output = snapshot.output[event.output_index];
        if (!output) {
          throw new OpenAIError(`missing output at index ${event.output_index}`);
        }
        if (output.type === "reasoning") {
          const content = (_a3 = output.content) == null ? void 0 : _a3[event.content_index];
          if (!content) {
            throw new OpenAIError(`missing content at index ${event.content_index}`);
          }
          if (content.type !== "reasoning_text") {
            throw new OpenAIError(`expected content to be 'reasoning_text', got ${content.type}`);
          }
          content.text += event.delta;
        }
        break;
      }
      case "response.completed": {
        __classPrivateFieldSet(this, _ResponseStream_currentResponseSnapshot, event.response);
        break;
      }
    }
    return snapshot;
  }, Symbol.asyncIterator)]() {
    const pushQueue = [];
    const readQueue = [];
    let done = false;
    this.on("event", (event) => {
      const reader = readQueue.shift();
      if (reader) {
        reader.resolve(event);
      } else {
        pushQueue.push(event);
      }
    });
    this.on("end", () => {
      done = true;
      for (const reader of readQueue) {
        reader.resolve(void 0);
      }
      readQueue.length = 0;
    });
    this.on("abort", (err) => {
      done = true;
      for (const reader of readQueue) {
        reader.reject(err);
      }
      readQueue.length = 0;
    });
    this.on("error", (err) => {
      done = true;
      for (const reader of readQueue) {
        reader.reject(err);
      }
      readQueue.length = 0;
    });
    return {
      next: async () => {
        if (!pushQueue.length) {
          if (done) {
            return { value: void 0, done: true };
          }
          return new Promise((resolve, reject) => readQueue.push({ resolve, reject })).then((event2) => event2 ? { value: event2, done: false } : { value: void 0, done: true });
        }
        const event = pushQueue.shift();
        return { value: event, done: false };
      },
      return: async () => {
        this.abort();
        return { value: void 0, done: true };
      }
    };
  }
  /**
   * @returns a promise that resolves with the final Response, or rejects
   * if an error occurred or the stream ended prematurely without producing a REsponse.
   */
  async finalResponse() {
    await this.done();
    const response = __classPrivateFieldGet(this, _ResponseStream_finalResponse, "f");
    if (!response)
      throw new OpenAIError("stream ended without producing a ChatCompletion");
    return response;
  }
}
function finalizeResponse(snapshot, params) {
  return maybeParseResponse(snapshot, params);
}
class InputItems extends APIResource {
  /**
   * Returns a list of input items for a given response.
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const responseItem of client.responses.inputItems.list(
   *   'response_id',
   * )) {
   *   // ...
   * }
   * ```
   */
  list(responseID, query = {}, options2) {
    return this._client.getAPIList(path$1`/responses/${responseID}/input_items`, CursorPage, { query, ...options2 });
  }
}
class InputTokens extends APIResource {
  /**
   * Get input token counts
   *
   * @example
   * ```ts
   * const response = await client.responses.inputTokens.count();
   * ```
   */
  count(body = {}, options2) {
    return this._client.post("/responses/input_tokens", { body, ...options2 });
  }
}
class Responses extends APIResource {
  constructor() {
    super(...arguments);
    this.inputItems = new InputItems(this._client);
    this.inputTokens = new InputTokens(this._client);
  }
  create(body, options2) {
    return this._client.post("/responses", { body, ...options2, stream: body.stream ?? false })._thenUnwrap((rsp) => {
      if ("object" in rsp && rsp.object === "response") {
        addOutputText(rsp);
      }
      return rsp;
    });
  }
  retrieve(responseID, query = {}, options2) {
    return this._client.get(path$1`/responses/${responseID}`, {
      query,
      ...options2,
      stream: (query == null ? void 0 : query.stream) ?? false
    })._thenUnwrap((rsp) => {
      if ("object" in rsp && rsp.object === "response") {
        addOutputText(rsp);
      }
      return rsp;
    });
  }
  /**
   * Deletes a model response with the given ID.
   *
   * @example
   * ```ts
   * await client.responses.delete(
   *   'resp_677efb5139a88190b512bc3fef8e535d',
   * );
   * ```
   */
  delete(responseID, options2) {
    return this._client.delete(path$1`/responses/${responseID}`, {
      ...options2,
      headers: buildHeaders([{ Accept: "*/*" }, options2 == null ? void 0 : options2.headers])
    });
  }
  parse(body, options2) {
    return this._client.responses.create(body, options2)._thenUnwrap((response) => parseResponse(response, body));
  }
  /**
   * Creates a model response stream
   */
  stream(body, options2) {
    return ResponseStream.createResponse(this._client, body, options2);
  }
  /**
   * Cancels a model response with the given ID. Only responses created with the
   * `background` parameter set to `true` can be cancelled.
   * [Learn more](https://platform.openai.com/docs/guides/background).
   *
   * @example
   * ```ts
   * const response = await client.responses.cancel(
   *   'resp_677efb5139a88190b512bc3fef8e535d',
   * );
   * ```
   */
  cancel(responseID, options2) {
    return this._client.post(path$1`/responses/${responseID}/cancel`, options2);
  }
  /**
   * Compact conversation
   *
   * @example
   * ```ts
   * const compactedResponse = await client.responses.compact();
   * ```
   */
  compact(body = {}, options2) {
    return this._client.post("/responses/compact", { body, ...options2 });
  }
}
Responses.InputItems = InputItems;
Responses.InputTokens = InputTokens;
class Parts extends APIResource {
  /**
   * Adds a
   * [Part](https://platform.openai.com/docs/api-reference/uploads/part-object) to an
   * [Upload](https://platform.openai.com/docs/api-reference/uploads/object) object.
   * A Part represents a chunk of bytes from the file you are trying to upload.
   *
   * Each Part can be at most 64 MB, and you can add Parts until you hit the Upload
   * maximum of 8 GB.
   *
   * It is possible to add multiple Parts in parallel. You can decide the intended
   * order of the Parts when you
   * [complete the Upload](https://platform.openai.com/docs/api-reference/uploads/complete).
   */
  create(uploadID, body, options2) {
    return this._client.post(path$1`/uploads/${uploadID}/parts`, multipartFormRequestOptions({ body, ...options2 }, this._client));
  }
}
class Uploads extends APIResource {
  constructor() {
    super(...arguments);
    this.parts = new Parts(this._client);
  }
  /**
   * Creates an intermediate
   * [Upload](https://platform.openai.com/docs/api-reference/uploads/object) object
   * that you can add
   * [Parts](https://platform.openai.com/docs/api-reference/uploads/part-object) to.
   * Currently, an Upload can accept at most 8 GB in total and expires after an hour
   * after you create it.
   *
   * Once you complete the Upload, we will create a
   * [File](https://platform.openai.com/docs/api-reference/files/object) object that
   * contains all the parts you uploaded. This File is usable in the rest of our
   * platform as a regular File object.
   *
   * For certain `purpose` values, the correct `mime_type` must be specified. Please
   * refer to documentation for the
   * [supported MIME types for your use case](https://platform.openai.com/docs/assistants/tools/file-search#supported-files).
   *
   * For guidance on the proper filename extensions for each purpose, please follow
   * the documentation on
   * [creating a File](https://platform.openai.com/docs/api-reference/files/create).
   */
  create(body, options2) {
    return this._client.post("/uploads", { body, ...options2 });
  }
  /**
   * Cancels the Upload. No Parts may be added after an Upload is cancelled.
   */
  cancel(uploadID, options2) {
    return this._client.post(path$1`/uploads/${uploadID}/cancel`, options2);
  }
  /**
   * Completes the
   * [Upload](https://platform.openai.com/docs/api-reference/uploads/object).
   *
   * Within the returned Upload object, there is a nested
   * [File](https://platform.openai.com/docs/api-reference/files/object) object that
   * is ready to use in the rest of the platform.
   *
   * You can specify the order of the Parts by passing in an ordered list of the Part
   * IDs.
   *
   * The number of bytes uploaded upon completion must match the number of bytes
   * initially specified when creating the Upload object. No Parts may be added after
   * an Upload is completed.
   */
  complete(uploadID, body, options2) {
    return this._client.post(path$1`/uploads/${uploadID}/complete`, { body, ...options2 });
  }
}
Uploads.Parts = Parts;
const allSettledWithThrow = async (promises) => {
  const results2 = await Promise.allSettled(promises);
  const rejected = results2.filter((result) => result.status === "rejected");
  if (rejected.length) {
    for (const result of rejected) {
      console.error(result.reason);
    }
    throw new Error(`${rejected.length} promise(s) failed - see the above errors`);
  }
  const values = [];
  for (const result of results2) {
    if (result.status === "fulfilled") {
      values.push(result.value);
    }
  }
  return values;
};
class FileBatches extends APIResource {
  /**
   * Create a vector store file batch.
   */
  create(vectorStoreID, body, options2) {
    return this._client.post(path$1`/vector_stores/${vectorStoreID}/file_batches`, {
      body,
      ...options2,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options2 == null ? void 0 : options2.headers])
    });
  }
  /**
   * Retrieves a vector store file batch.
   */
  retrieve(batchID, params, options2) {
    const { vector_store_id } = params;
    return this._client.get(path$1`/vector_stores/${vector_store_id}/file_batches/${batchID}`, {
      ...options2,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options2 == null ? void 0 : options2.headers])
    });
  }
  /**
   * Cancel a vector store file batch. This attempts to cancel the processing of
   * files in this batch as soon as possible.
   */
  cancel(batchID, params, options2) {
    const { vector_store_id } = params;
    return this._client.post(path$1`/vector_stores/${vector_store_id}/file_batches/${batchID}/cancel`, {
      ...options2,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options2 == null ? void 0 : options2.headers])
    });
  }
  /**
   * Create a vector store batch and poll until all files have been processed.
   */
  async createAndPoll(vectorStoreId, body, options2) {
    const batch = await this.create(vectorStoreId, body);
    return await this.poll(vectorStoreId, batch.id, options2);
  }
  /**
   * Returns a list of vector store files in a batch.
   */
  listFiles(batchID, params, options2) {
    const { vector_store_id, ...query } = params;
    return this._client.getAPIList(path$1`/vector_stores/${vector_store_id}/file_batches/${batchID}/files`, CursorPage, { query, ...options2, headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options2 == null ? void 0 : options2.headers]) });
  }
  /**
   * Wait for the given file batch to be processed.
   *
   * Note: this will return even if one of the files failed to process, you need to
   * check batch.file_counts.failed_count to handle this case.
   */
  async poll(vectorStoreID, batchID, options2) {
    var _a3;
    const headers = buildHeaders([
      options2 == null ? void 0 : options2.headers,
      {
        "X-Stainless-Poll-Helper": "true",
        "X-Stainless-Custom-Poll-Interval": ((_a3 = options2 == null ? void 0 : options2.pollIntervalMs) == null ? void 0 : _a3.toString()) ?? void 0
      }
    ]);
    while (true) {
      const { data: batch, response } = await this.retrieve(batchID, { vector_store_id: vectorStoreID }, {
        ...options2,
        headers
      }).withResponse();
      switch (batch.status) {
        case "in_progress":
          let sleepInterval = 5e3;
          if (options2 == null ? void 0 : options2.pollIntervalMs) {
            sleepInterval = options2.pollIntervalMs;
          } else {
            const headerInterval = response.headers.get("openai-poll-after-ms");
            if (headerInterval) {
              const headerIntervalMs = parseInt(headerInterval);
              if (!isNaN(headerIntervalMs)) {
                sleepInterval = headerIntervalMs;
              }
            }
          }
          await sleep(sleepInterval);
          break;
        case "failed":
        case "cancelled":
        case "completed":
          return batch;
      }
    }
  }
  /**
   * Uploads the given files concurrently and then creates a vector store file batch.
   *
   * The concurrency limit is configurable using the `maxConcurrency` parameter.
   */
  async uploadAndPoll(vectorStoreId, { files, fileIds = [] }, options2) {
    if (files == null || files.length == 0) {
      throw new Error(`No \`files\` provided to process. If you've already uploaded files you should use \`.createAndPoll()\` instead`);
    }
    const configuredConcurrency = (options2 == null ? void 0 : options2.maxConcurrency) ?? 5;
    const concurrencyLimit = Math.min(configuredConcurrency, files.length);
    const client2 = this._client;
    const fileIterator = files.values();
    const allFileIds = [...fileIds];
    async function processFiles(iterator) {
      for (let item of iterator) {
        const fileObj = await client2.files.create({ file: item, purpose: "assistants" }, options2);
        allFileIds.push(fileObj.id);
      }
    }
    const workers = Array(concurrencyLimit).fill(fileIterator).map(processFiles);
    await allSettledWithThrow(workers);
    return await this.createAndPoll(vectorStoreId, {
      file_ids: allFileIds
    });
  }
}
class Files extends APIResource {
  /**
   * Create a vector store file by attaching a
   * [File](https://platform.openai.com/docs/api-reference/files) to a
   * [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object).
   */
  create(vectorStoreID, body, options2) {
    return this._client.post(path$1`/vector_stores/${vectorStoreID}/files`, {
      body,
      ...options2,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options2 == null ? void 0 : options2.headers])
    });
  }
  /**
   * Retrieves a vector store file.
   */
  retrieve(fileID, params, options2) {
    const { vector_store_id } = params;
    return this._client.get(path$1`/vector_stores/${vector_store_id}/files/${fileID}`, {
      ...options2,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options2 == null ? void 0 : options2.headers])
    });
  }
  /**
   * Update attributes on a vector store file.
   */
  update(fileID, params, options2) {
    const { vector_store_id, ...body } = params;
    return this._client.post(path$1`/vector_stores/${vector_store_id}/files/${fileID}`, {
      body,
      ...options2,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options2 == null ? void 0 : options2.headers])
    });
  }
  /**
   * Returns a list of vector store files.
   */
  list(vectorStoreID, query = {}, options2) {
    return this._client.getAPIList(path$1`/vector_stores/${vectorStoreID}/files`, CursorPage, {
      query,
      ...options2,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options2 == null ? void 0 : options2.headers])
    });
  }
  /**
   * Delete a vector store file. This will remove the file from the vector store but
   * the file itself will not be deleted. To delete the file, use the
   * [delete file](https://platform.openai.com/docs/api-reference/files/delete)
   * endpoint.
   */
  delete(fileID, params, options2) {
    const { vector_store_id } = params;
    return this._client.delete(path$1`/vector_stores/${vector_store_id}/files/${fileID}`, {
      ...options2,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options2 == null ? void 0 : options2.headers])
    });
  }
  /**
   * Attach a file to the given vector store and wait for it to be processed.
   */
  async createAndPoll(vectorStoreId, body, options2) {
    const file = await this.create(vectorStoreId, body, options2);
    return await this.poll(vectorStoreId, file.id, options2);
  }
  /**
   * Wait for the vector store file to finish processing.
   *
   * Note: this will return even if the file failed to process, you need to check
   * file.last_error and file.status to handle these cases
   */
  async poll(vectorStoreID, fileID, options2) {
    var _a3;
    const headers = buildHeaders([
      options2 == null ? void 0 : options2.headers,
      {
        "X-Stainless-Poll-Helper": "true",
        "X-Stainless-Custom-Poll-Interval": ((_a3 = options2 == null ? void 0 : options2.pollIntervalMs) == null ? void 0 : _a3.toString()) ?? void 0
      }
    ]);
    while (true) {
      const fileResponse = await this.retrieve(fileID, {
        vector_store_id: vectorStoreID
      }, { ...options2, headers }).withResponse();
      const file = fileResponse.data;
      switch (file.status) {
        case "in_progress":
          let sleepInterval = 5e3;
          if (options2 == null ? void 0 : options2.pollIntervalMs) {
            sleepInterval = options2.pollIntervalMs;
          } else {
            const headerInterval = fileResponse.response.headers.get("openai-poll-after-ms");
            if (headerInterval) {
              const headerIntervalMs = parseInt(headerInterval);
              if (!isNaN(headerIntervalMs)) {
                sleepInterval = headerIntervalMs;
              }
            }
          }
          await sleep(sleepInterval);
          break;
        case "failed":
        case "completed":
          return file;
      }
    }
  }
  /**
   * Upload a file to the `files` API and then attach it to the given vector store.
   *
   * Note the file will be asynchronously processed (you can use the alternative
   * polling helper method to wait for processing to complete).
   */
  async upload(vectorStoreId, file, options2) {
    const fileInfo = await this._client.files.create({ file, purpose: "assistants" }, options2);
    return this.create(vectorStoreId, { file_id: fileInfo.id }, options2);
  }
  /**
   * Add a file to a vector store and poll until processing is complete.
   */
  async uploadAndPoll(vectorStoreId, file, options2) {
    const fileInfo = await this.upload(vectorStoreId, file, options2);
    return await this.poll(vectorStoreId, fileInfo.id, options2);
  }
  /**
   * Retrieve the parsed contents of a vector store file.
   */
  content(fileID, params, options2) {
    const { vector_store_id } = params;
    return this._client.getAPIList(path$1`/vector_stores/${vector_store_id}/files/${fileID}/content`, Page, { ...options2, headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options2 == null ? void 0 : options2.headers]) });
  }
}
class VectorStores extends APIResource {
  constructor() {
    super(...arguments);
    this.files = new Files(this._client);
    this.fileBatches = new FileBatches(this._client);
  }
  /**
   * Create a vector store.
   */
  create(body, options2) {
    return this._client.post("/vector_stores", {
      body,
      ...options2,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options2 == null ? void 0 : options2.headers])
    });
  }
  /**
   * Retrieves a vector store.
   */
  retrieve(vectorStoreID, options2) {
    return this._client.get(path$1`/vector_stores/${vectorStoreID}`, {
      ...options2,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options2 == null ? void 0 : options2.headers])
    });
  }
  /**
   * Modifies a vector store.
   */
  update(vectorStoreID, body, options2) {
    return this._client.post(path$1`/vector_stores/${vectorStoreID}`, {
      body,
      ...options2,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options2 == null ? void 0 : options2.headers])
    });
  }
  /**
   * Returns a list of vector stores.
   */
  list(query = {}, options2) {
    return this._client.getAPIList("/vector_stores", CursorPage, {
      query,
      ...options2,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options2 == null ? void 0 : options2.headers])
    });
  }
  /**
   * Delete a vector store.
   */
  delete(vectorStoreID, options2) {
    return this._client.delete(path$1`/vector_stores/${vectorStoreID}`, {
      ...options2,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options2 == null ? void 0 : options2.headers])
    });
  }
  /**
   * Search a vector store for relevant chunks based on a query and file attributes
   * filter.
   */
  search(vectorStoreID, body, options2) {
    return this._client.getAPIList(path$1`/vector_stores/${vectorStoreID}/search`, Page, {
      body,
      method: "post",
      ...options2,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options2 == null ? void 0 : options2.headers])
    });
  }
}
VectorStores.Files = Files;
VectorStores.FileBatches = FileBatches;
class Videos extends APIResource {
  /**
   * Create a video
   */
  create(body, options2) {
    return this._client.post("/videos", maybeMultipartFormRequestOptions({ body, ...options2 }, this._client));
  }
  /**
   * Retrieve a video
   */
  retrieve(videoID, options2) {
    return this._client.get(path$1`/videos/${videoID}`, options2);
  }
  /**
   * List videos
   */
  list(query = {}, options2) {
    return this._client.getAPIList("/videos", ConversationCursorPage, { query, ...options2 });
  }
  /**
   * Delete a video
   */
  delete(videoID, options2) {
    return this._client.delete(path$1`/videos/${videoID}`, options2);
  }
  /**
   * Download video content
   */
  downloadContent(videoID, query = {}, options2) {
    return this._client.get(path$1`/videos/${videoID}/content`, {
      query,
      ...options2,
      headers: buildHeaders([{ Accept: "application/binary" }, options2 == null ? void 0 : options2.headers]),
      __binaryResponse: true
    });
  }
  /**
   * Create a video remix
   */
  remix(videoID, body, options2) {
    return this._client.post(path$1`/videos/${videoID}/remix`, maybeMultipartFormRequestOptions({ body, ...options2 }, this._client));
  }
}
var _Webhooks_instances, _Webhooks_validateSecret, _Webhooks_getRequiredHeader;
class Webhooks extends APIResource {
  constructor() {
    super(...arguments);
    _Webhooks_instances.add(this);
  }
  /**
   * Validates that the given payload was sent by OpenAI and parses the payload.
   */
  async unwrap(payload, headers, secret = this._client.webhookSecret, tolerance = 300) {
    await this.verifySignature(payload, headers, secret, tolerance);
    return JSON.parse(payload);
  }
  /**
   * Validates whether or not the webhook payload was sent by OpenAI.
   *
   * An error will be raised if the webhook payload was not sent by OpenAI.
   *
   * @param payload - The webhook payload
   * @param headers - The webhook headers
   * @param secret - The webhook secret (optional, will use client secret if not provided)
   * @param tolerance - Maximum age of the webhook in seconds (default: 300 = 5 minutes)
   */
  async verifySignature(payload, headers, secret = this._client.webhookSecret, tolerance = 300) {
    if (typeof crypto === "undefined" || typeof crypto.subtle.importKey !== "function" || typeof crypto.subtle.verify !== "function") {
      throw new Error("Webhook signature verification is only supported when the `crypto` global is defined");
    }
    __classPrivateFieldGet(this, _Webhooks_instances, "m", _Webhooks_validateSecret).call(this, secret);
    const headersObj = buildHeaders([headers]).values;
    const signatureHeader = __classPrivateFieldGet(this, _Webhooks_instances, "m", _Webhooks_getRequiredHeader).call(this, headersObj, "webhook-signature");
    const timestamp = __classPrivateFieldGet(this, _Webhooks_instances, "m", _Webhooks_getRequiredHeader).call(this, headersObj, "webhook-timestamp");
    const webhookId = __classPrivateFieldGet(this, _Webhooks_instances, "m", _Webhooks_getRequiredHeader).call(this, headersObj, "webhook-id");
    const timestampSeconds = parseInt(timestamp, 10);
    if (isNaN(timestampSeconds)) {
      throw new InvalidWebhookSignatureError("Invalid webhook timestamp format");
    }
    const nowSeconds = Math.floor(Date.now() / 1e3);
    if (nowSeconds - timestampSeconds > tolerance) {
      throw new InvalidWebhookSignatureError("Webhook timestamp is too old");
    }
    if (timestampSeconds > nowSeconds + tolerance) {
      throw new InvalidWebhookSignatureError("Webhook timestamp is too new");
    }
    const signatures = signatureHeader.split(" ").map((part) => part.startsWith("v1,") ? part.substring(3) : part);
    const decodedSecret = secret.startsWith("whsec_") ? Buffer.from(secret.replace("whsec_", ""), "base64") : Buffer.from(secret, "utf-8");
    const signedPayload = webhookId ? `${webhookId}.${timestamp}.${payload}` : `${timestamp}.${payload}`;
    const key = await crypto.subtle.importKey("raw", decodedSecret, { name: "HMAC", hash: "SHA-256" }, false, ["verify"]);
    for (const signature of signatures) {
      try {
        const signatureBytes = Buffer.from(signature, "base64");
        const isValid2 = await crypto.subtle.verify("HMAC", key, signatureBytes, new TextEncoder().encode(signedPayload));
        if (isValid2) {
          return;
        }
      } catch {
        continue;
      }
    }
    throw new InvalidWebhookSignatureError("The given webhook signature does not match the expected signature");
  }
}
_Webhooks_instances = /* @__PURE__ */ new WeakSet(), _Webhooks_validateSecret = function _Webhooks_validateSecret2(secret) {
  if (typeof secret !== "string" || secret.length === 0) {
    throw new Error(`The webhook secret must either be set using the env var, OPENAI_WEBHOOK_SECRET, on the client class, OpenAI({ webhookSecret: '123' }), or passed to this function`);
  }
}, _Webhooks_getRequiredHeader = function _Webhooks_getRequiredHeader2(headers, name) {
  if (!headers) {
    throw new Error(`Headers are required`);
  }
  const value = headers.get(name);
  if (value === null || value === void 0) {
    throw new Error(`Missing required header: ${name}`);
  }
  return value;
};
var _OpenAI_instances, _a$1, _OpenAI_encoder, _OpenAI_baseURLOverridden;
class OpenAI {
  /**
   * API Client for interfacing with the OpenAI API.
   *
   * @param {string | undefined} [opts.apiKey=process.env['OPENAI_API_KEY'] ?? undefined]
   * @param {string | null | undefined} [opts.organization=process.env['OPENAI_ORG_ID'] ?? null]
   * @param {string | null | undefined} [opts.project=process.env['OPENAI_PROJECT_ID'] ?? null]
   * @param {string | null | undefined} [opts.webhookSecret=process.env['OPENAI_WEBHOOK_SECRET'] ?? null]
   * @param {string} [opts.baseURL=process.env['OPENAI_BASE_URL'] ?? https://api.openai.com/v1] - Override the default base URL for the API.
   * @param {number} [opts.timeout=10 minutes] - The maximum amount of time (in milliseconds) the client will wait for a response before timing out.
   * @param {MergedRequestInit} [opts.fetchOptions] - Additional `RequestInit` options to be passed to `fetch` calls.
   * @param {Fetch} [opts.fetch] - Specify a custom `fetch` function implementation.
   * @param {number} [opts.maxRetries=2] - The maximum number of times the client will retry a request.
   * @param {HeadersLike} opts.defaultHeaders - Default headers to include with every request to the API.
   * @param {Record<string, string | undefined>} opts.defaultQuery - Default query parameters to include with every request to the API.
   * @param {boolean} [opts.dangerouslyAllowBrowser=false] - By default, client-side use of this library is not allowed, as it risks exposing your secret API credentials to attackers.
   */
  constructor({ baseURL = readEnv("OPENAI_BASE_URL"), apiKey = readEnv("OPENAI_API_KEY"), organization = readEnv("OPENAI_ORG_ID") ?? null, project = readEnv("OPENAI_PROJECT_ID") ?? null, webhookSecret = readEnv("OPENAI_WEBHOOK_SECRET") ?? null, ...opts } = {}) {
    _OpenAI_instances.add(this);
    _OpenAI_encoder.set(this, void 0);
    this.completions = new Completions(this);
    this.chat = new Chat(this);
    this.embeddings = new Embeddings$1(this);
    this.files = new Files$1(this);
    this.images = new Images(this);
    this.audio = new Audio(this);
    this.moderations = new Moderations(this);
    this.models = new Models(this);
    this.fineTuning = new FineTuning(this);
    this.graders = new Graders(this);
    this.vectorStores = new VectorStores(this);
    this.webhooks = new Webhooks(this);
    this.beta = new Beta(this);
    this.batches = new Batches(this);
    this.uploads = new Uploads(this);
    this.responses = new Responses(this);
    this.realtime = new Realtime(this);
    this.conversations = new Conversations(this);
    this.evals = new Evals(this);
    this.containers = new Containers(this);
    this.videos = new Videos(this);
    if (apiKey === void 0) {
      throw new OpenAIError("Missing credentials. Please pass an `apiKey`, or set the `OPENAI_API_KEY` environment variable.");
    }
    const options2 = {
      apiKey,
      organization,
      project,
      webhookSecret,
      ...opts,
      baseURL: baseURL || `https://api.openai.com/v1`
    };
    if (!options2.dangerouslyAllowBrowser && isRunningInBrowser()) {
      throw new OpenAIError("It looks like you're running in a browser-like environment.\n\nThis is disabled by default, as it risks exposing your secret API credentials to attackers.\nIf you understand the risks and have appropriate mitigations in place,\nyou can set the `dangerouslyAllowBrowser` option to `true`, e.g.,\n\nnew OpenAI({ apiKey, dangerouslyAllowBrowser: true });\n\nhttps://help.openai.com/en/articles/5112595-best-practices-for-api-key-safety\n");
    }
    this.baseURL = options2.baseURL;
    this.timeout = options2.timeout ?? _a$1.DEFAULT_TIMEOUT;
    this.logger = options2.logger ?? console;
    const defaultLogLevel = "warn";
    this.logLevel = defaultLogLevel;
    this.logLevel = parseLogLevel(options2.logLevel, "ClientOptions.logLevel", this) ?? parseLogLevel(readEnv("OPENAI_LOG"), "process.env['OPENAI_LOG']", this) ?? defaultLogLevel;
    this.fetchOptions = options2.fetchOptions;
    this.maxRetries = options2.maxRetries ?? 2;
    this.fetch = options2.fetch ?? getDefaultFetch();
    __classPrivateFieldSet(this, _OpenAI_encoder, FallbackEncoder);
    this._options = options2;
    this.apiKey = typeof apiKey === "string" ? apiKey : "Missing Key";
    this.organization = organization;
    this.project = project;
    this.webhookSecret = webhookSecret;
  }
  /**
   * Create a new client instance re-using the same options given to the current client with optional overriding.
   */
  withOptions(options2) {
    const client2 = new this.constructor({
      ...this._options,
      baseURL: this.baseURL,
      maxRetries: this.maxRetries,
      timeout: this.timeout,
      logger: this.logger,
      logLevel: this.logLevel,
      fetch: this.fetch,
      fetchOptions: this.fetchOptions,
      apiKey: this.apiKey,
      organization: this.organization,
      project: this.project,
      webhookSecret: this.webhookSecret,
      ...options2
    });
    return client2;
  }
  defaultQuery() {
    return this._options.defaultQuery;
  }
  validateHeaders({ values, nulls }) {
    return;
  }
  async authHeaders(opts) {
    return buildHeaders([{ Authorization: `Bearer ${this.apiKey}` }]);
  }
  stringifyQuery(query) {
    return stringify(query, { arrayFormat: "brackets" });
  }
  getUserAgent() {
    return `${this.constructor.name}/JS ${VERSION}`;
  }
  defaultIdempotencyKey() {
    return `stainless-node-retry-${uuid4()}`;
  }
  makeStatusError(status, error, message, headers) {
    return APIError.generate(status, error, message, headers);
  }
  async _callApiKey() {
    const apiKey = this._options.apiKey;
    if (typeof apiKey !== "function")
      return false;
    let token;
    try {
      token = await apiKey();
    } catch (err) {
      if (err instanceof OpenAIError)
        throw err;
      throw new OpenAIError(
        `Failed to get token from 'apiKey' function: ${err.message}`,
        // @ts-ignore
        { cause: err }
      );
    }
    if (typeof token !== "string" || !token) {
      throw new OpenAIError(`Expected 'apiKey' function argument to return a string but it returned ${token}`);
    }
    this.apiKey = token;
    return true;
  }
  buildURL(path2, query, defaultBaseURL) {
    const baseURL = !__classPrivateFieldGet(this, _OpenAI_instances, "m", _OpenAI_baseURLOverridden).call(this) && defaultBaseURL || this.baseURL;
    const url = isAbsoluteURL(path2) ? new URL(path2) : new URL(baseURL + (baseURL.endsWith("/") && path2.startsWith("/") ? path2.slice(1) : path2));
    const defaultQuery = this.defaultQuery();
    if (!isEmptyObj$1(defaultQuery)) {
      query = { ...defaultQuery, ...query };
    }
    if (typeof query === "object" && query && !Array.isArray(query)) {
      url.search = this.stringifyQuery(query);
    }
    return url.toString();
  }
  /**
   * Used as a callback for mutating the given `FinalRequestOptions` object.
   */
  async prepareOptions(options2) {
    await this._callApiKey();
  }
  /**
   * Used as a callback for mutating the given `RequestInit` object.
   *
   * This is useful for cases where you want to add certain headers based off of
   * the request properties, e.g. `method` or `url`.
   */
  async prepareRequest(request, { url, options: options2 }) {
  }
  get(path2, opts) {
    return this.methodRequest("get", path2, opts);
  }
  post(path2, opts) {
    return this.methodRequest("post", path2, opts);
  }
  patch(path2, opts) {
    return this.methodRequest("patch", path2, opts);
  }
  put(path2, opts) {
    return this.methodRequest("put", path2, opts);
  }
  delete(path2, opts) {
    return this.methodRequest("delete", path2, opts);
  }
  methodRequest(method, path2, opts) {
    return this.request(Promise.resolve(opts).then((opts2) => {
      return { method, path: path2, ...opts2 };
    }));
  }
  request(options2, remainingRetries = null) {
    return new APIPromise(this, this.makeRequest(options2, remainingRetries, void 0));
  }
  async makeRequest(optionsInput, retriesRemaining, retryOfRequestLogID) {
    var _a3, _b;
    const options2 = await optionsInput;
    const maxRetries = options2.maxRetries ?? this.maxRetries;
    if (retriesRemaining == null) {
      retriesRemaining = maxRetries;
    }
    await this.prepareOptions(options2);
    const { req, url, timeout } = await this.buildRequest(options2, {
      retryCount: maxRetries - retriesRemaining
    });
    await this.prepareRequest(req, { url, options: options2 });
    const requestLogID = "log_" + (Math.random() * (1 << 24) | 0).toString(16).padStart(6, "0");
    const retryLogStr = retryOfRequestLogID === void 0 ? "" : `, retryOf: ${retryOfRequestLogID}`;
    const startTime2 = Date.now();
    loggerFor(this).debug(`[${requestLogID}] sending request`, formatRequestDetails({
      retryOfRequestLogID,
      method: options2.method,
      url,
      options: options2,
      headers: req.headers
    }));
    if ((_a3 = options2.signal) == null ? void 0 : _a3.aborted) {
      throw new APIUserAbortError();
    }
    const controller = new AbortController();
    const response = await this.fetchWithTimeout(url, req, timeout, controller).catch(castToError);
    const headersTime = Date.now();
    if (response instanceof globalThis.Error) {
      const retryMessage = `retrying, ${retriesRemaining} attempts remaining`;
      if ((_b = options2.signal) == null ? void 0 : _b.aborted) {
        throw new APIUserAbortError();
      }
      const isTimeout = isAbortError(response) || /timed? ?out/i.test(String(response) + ("cause" in response ? String(response.cause) : ""));
      if (retriesRemaining) {
        loggerFor(this).info(`[${requestLogID}] connection ${isTimeout ? "timed out" : "failed"} - ${retryMessage}`);
        loggerFor(this).debug(`[${requestLogID}] connection ${isTimeout ? "timed out" : "failed"} (${retryMessage})`, formatRequestDetails({
          retryOfRequestLogID,
          url,
          durationMs: headersTime - startTime2,
          message: response.message
        }));
        return this.retryRequest(options2, retriesRemaining, retryOfRequestLogID ?? requestLogID);
      }
      loggerFor(this).info(`[${requestLogID}] connection ${isTimeout ? "timed out" : "failed"} - error; no more retries left`);
      loggerFor(this).debug(`[${requestLogID}] connection ${isTimeout ? "timed out" : "failed"} (error; no more retries left)`, formatRequestDetails({
        retryOfRequestLogID,
        url,
        durationMs: headersTime - startTime2,
        message: response.message
      }));
      if (isTimeout) {
        throw new APIConnectionTimeoutError();
      }
      throw new APIConnectionError({ cause: response });
    }
    const specialHeaders = [...response.headers.entries()].filter(([name]) => name === "x-request-id").map(([name, value]) => ", " + name + ": " + JSON.stringify(value)).join("");
    const responseInfo = `[${requestLogID}${retryLogStr}${specialHeaders}] ${req.method} ${url} ${response.ok ? "succeeded" : "failed"} with status ${response.status} in ${headersTime - startTime2}ms`;
    if (!response.ok) {
      const shouldRetry = await this.shouldRetry(response);
      if (retriesRemaining && shouldRetry) {
        const retryMessage2 = `retrying, ${retriesRemaining} attempts remaining`;
        await CancelReadableStream(response.body);
        loggerFor(this).info(`${responseInfo} - ${retryMessage2}`);
        loggerFor(this).debug(`[${requestLogID}] response error (${retryMessage2})`, formatRequestDetails({
          retryOfRequestLogID,
          url: response.url,
          status: response.status,
          headers: response.headers,
          durationMs: headersTime - startTime2
        }));
        return this.retryRequest(options2, retriesRemaining, retryOfRequestLogID ?? requestLogID, response.headers);
      }
      const retryMessage = shouldRetry ? `error; no more retries left` : `error; not retryable`;
      loggerFor(this).info(`${responseInfo} - ${retryMessage}`);
      const errText = await response.text().catch((err2) => castToError(err2).message);
      const errJSON = safeJSON(errText);
      const errMessage = errJSON ? void 0 : errText;
      loggerFor(this).debug(`[${requestLogID}] response error (${retryMessage})`, formatRequestDetails({
        retryOfRequestLogID,
        url: response.url,
        status: response.status,
        headers: response.headers,
        message: errMessage,
        durationMs: Date.now() - startTime2
      }));
      const err = this.makeStatusError(response.status, errJSON, errMessage, response.headers);
      throw err;
    }
    loggerFor(this).info(responseInfo);
    loggerFor(this).debug(`[${requestLogID}] response start`, formatRequestDetails({
      retryOfRequestLogID,
      url: response.url,
      status: response.status,
      headers: response.headers,
      durationMs: headersTime - startTime2
    }));
    return { response, options: options2, controller, requestLogID, retryOfRequestLogID, startTime: startTime2 };
  }
  getAPIList(path2, Page2, opts) {
    return this.requestAPIList(Page2, { method: "get", path: path2, ...opts });
  }
  requestAPIList(Page2, options2) {
    const request = this.makeRequest(options2, null, void 0);
    return new PagePromise(this, request, Page2);
  }
  async fetchWithTimeout(url, init, ms, controller) {
    const { signal, method, ...options2 } = init || {};
    if (signal)
      signal.addEventListener("abort", () => controller.abort());
    const timeout = setTimeout(() => controller.abort(), ms);
    const isReadableBody = globalThis.ReadableStream && options2.body instanceof globalThis.ReadableStream || typeof options2.body === "object" && options2.body !== null && Symbol.asyncIterator in options2.body;
    const fetchOptions = {
      signal: controller.signal,
      ...isReadableBody ? { duplex: "half" } : {},
      method: "GET",
      ...options2
    };
    if (method) {
      fetchOptions.method = method.toUpperCase();
    }
    try {
      return await this.fetch.call(void 0, url, fetchOptions);
    } finally {
      clearTimeout(timeout);
    }
  }
  async shouldRetry(response) {
    const shouldRetryHeader = response.headers.get("x-should-retry");
    if (shouldRetryHeader === "true")
      return true;
    if (shouldRetryHeader === "false")
      return false;
    if (response.status === 408)
      return true;
    if (response.status === 409)
      return true;
    if (response.status === 429)
      return true;
    if (response.status >= 500)
      return true;
    return false;
  }
  async retryRequest(options2, retriesRemaining, requestLogID, responseHeaders) {
    let timeoutMillis;
    const retryAfterMillisHeader = responseHeaders == null ? void 0 : responseHeaders.get("retry-after-ms");
    if (retryAfterMillisHeader) {
      const timeoutMs = parseFloat(retryAfterMillisHeader);
      if (!Number.isNaN(timeoutMs)) {
        timeoutMillis = timeoutMs;
      }
    }
    const retryAfterHeader = responseHeaders == null ? void 0 : responseHeaders.get("retry-after");
    if (retryAfterHeader && !timeoutMillis) {
      const timeoutSeconds = parseFloat(retryAfterHeader);
      if (!Number.isNaN(timeoutSeconds)) {
        timeoutMillis = timeoutSeconds * 1e3;
      } else {
        timeoutMillis = Date.parse(retryAfterHeader) - Date.now();
      }
    }
    if (!(timeoutMillis && 0 <= timeoutMillis && timeoutMillis < 60 * 1e3)) {
      const maxRetries = options2.maxRetries ?? this.maxRetries;
      timeoutMillis = this.calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries);
    }
    await sleep(timeoutMillis);
    return this.makeRequest(options2, retriesRemaining - 1, requestLogID);
  }
  calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries) {
    const initialRetryDelay = 0.5;
    const maxRetryDelay = 8;
    const numRetries = maxRetries - retriesRemaining;
    const sleepSeconds = Math.min(initialRetryDelay * Math.pow(2, numRetries), maxRetryDelay);
    const jitter = 1 - Math.random() * 0.25;
    return sleepSeconds * jitter * 1e3;
  }
  async buildRequest(inputOptions, { retryCount = 0 } = {}) {
    const options2 = { ...inputOptions };
    const { method, path: path2, query, defaultBaseURL } = options2;
    const url = this.buildURL(path2, query, defaultBaseURL);
    if ("timeout" in options2)
      validatePositiveInteger("timeout", options2.timeout);
    options2.timeout = options2.timeout ?? this.timeout;
    const { bodyHeaders, body } = this.buildBody({ options: options2 });
    const reqHeaders = await this.buildHeaders({ options: inputOptions, method, bodyHeaders, retryCount });
    const req = {
      method,
      headers: reqHeaders,
      ...options2.signal && { signal: options2.signal },
      ...globalThis.ReadableStream && body instanceof globalThis.ReadableStream && { duplex: "half" },
      ...body && { body },
      ...this.fetchOptions ?? {},
      ...options2.fetchOptions ?? {}
    };
    return { req, url, timeout: options2.timeout };
  }
  async buildHeaders({ options: options2, method, bodyHeaders, retryCount }) {
    let idempotencyHeaders = {};
    if (this.idempotencyHeader && method !== "get") {
      if (!options2.idempotencyKey)
        options2.idempotencyKey = this.defaultIdempotencyKey();
      idempotencyHeaders[this.idempotencyHeader] = options2.idempotencyKey;
    }
    const headers = buildHeaders([
      idempotencyHeaders,
      {
        Accept: "application/json",
        "User-Agent": this.getUserAgent(),
        "X-Stainless-Retry-Count": String(retryCount),
        ...options2.timeout ? { "X-Stainless-Timeout": String(Math.trunc(options2.timeout / 1e3)) } : {},
        ...getPlatformHeaders(),
        "OpenAI-Organization": this.organization,
        "OpenAI-Project": this.project
      },
      await this.authHeaders(options2),
      this._options.defaultHeaders,
      bodyHeaders,
      options2.headers
    ]);
    this.validateHeaders(headers);
    return headers.values;
  }
  buildBody({ options: { body, headers: rawHeaders } }) {
    if (!body) {
      return { bodyHeaders: void 0, body: void 0 };
    }
    const headers = buildHeaders([rawHeaders]);
    if (
      // Pass raw type verbatim
      ArrayBuffer.isView(body) || body instanceof ArrayBuffer || body instanceof DataView || typeof body === "string" && // Preserve legacy string encoding behavior for now
      headers.values.has("content-type") || // `Blob` is superset of `File`
      globalThis.Blob && body instanceof globalThis.Blob || // `FormData` -> `multipart/form-data`
      body instanceof FormData || // `URLSearchParams` -> `application/x-www-form-urlencoded`
      body instanceof URLSearchParams || // Send chunked stream (each chunk has own `length`)
      globalThis.ReadableStream && body instanceof globalThis.ReadableStream
    ) {
      return { bodyHeaders: void 0, body };
    } else if (typeof body === "object" && (Symbol.asyncIterator in body || Symbol.iterator in body && "next" in body && typeof body.next === "function")) {
      return { bodyHeaders: void 0, body: ReadableStreamFrom(body) };
    } else {
      return __classPrivateFieldGet(this, _OpenAI_encoder, "f").call(this, { body, headers });
    }
  }
}
_a$1 = OpenAI, _OpenAI_encoder = /* @__PURE__ */ new WeakMap(), _OpenAI_instances = /* @__PURE__ */ new WeakSet(), _OpenAI_baseURLOverridden = function _OpenAI_baseURLOverridden2() {
  return this.baseURL !== "https://api.openai.com/v1";
};
OpenAI.OpenAI = _a$1;
OpenAI.DEFAULT_TIMEOUT = 6e5;
OpenAI.OpenAIError = OpenAIError;
OpenAI.APIError = APIError;
OpenAI.APIConnectionError = APIConnectionError;
OpenAI.APIConnectionTimeoutError = APIConnectionTimeoutError;
OpenAI.APIUserAbortError = APIUserAbortError;
OpenAI.NotFoundError = NotFoundError;
OpenAI.ConflictError = ConflictError;
OpenAI.RateLimitError = RateLimitError;
OpenAI.BadRequestError = BadRequestError;
OpenAI.AuthenticationError = AuthenticationError;
OpenAI.InternalServerError = InternalServerError;
OpenAI.PermissionDeniedError = PermissionDeniedError;
OpenAI.UnprocessableEntityError = UnprocessableEntityError;
OpenAI.InvalidWebhookSignatureError = InvalidWebhookSignatureError;
OpenAI.toFile = toFile;
OpenAI.Completions = Completions;
OpenAI.Chat = Chat;
OpenAI.Embeddings = Embeddings$1;
OpenAI.Files = Files$1;
OpenAI.Images = Images;
OpenAI.Audio = Audio;
OpenAI.Moderations = Moderations;
OpenAI.Models = Models;
OpenAI.FineTuning = FineTuning;
OpenAI.Graders = Graders;
OpenAI.VectorStores = VectorStores;
OpenAI.Webhooks = Webhooks;
OpenAI.Beta = Beta;
OpenAI.Batches = Batches;
OpenAI.Uploads = Uploads;
OpenAI.Responses = Responses;
OpenAI.Realtime = Realtime;
OpenAI.Conversations = Conversations;
OpenAI.Evals = Evals;
OpenAI.Containers = Containers;
OpenAI.Videos = Videos;
function wrapOpenAIClientError(e) {
  if (!e || typeof e !== "object") return e;
  let error;
  if (e.constructor.name === APIConnectionTimeoutError.name && "message" in e && typeof e.message === "string") {
    error = new Error(e.message);
    error.name = "TimeoutError";
  } else if (e.constructor.name === APIUserAbortError.name && "message" in e && typeof e.message === "string") {
    error = new Error(e.message);
    error.name = "AbortError";
  } else if ("status" in e && e.status === 400 && "message" in e && typeof e.message === "string" && e.message.includes("tool_calls")) error = addLangChainErrorFields$1(e, "INVALID_TOOL_RESULTS");
  else if ("status" in e && e.status === 401) error = addLangChainErrorFields$1(e, "MODEL_AUTHENTICATION");
  else if ("status" in e && e.status === 429) error = addLangChainErrorFields$1(e, "MODEL_RATE_LIMIT");
  else if ("status" in e && e.status === 404) error = addLangChainErrorFields$1(e, "MODEL_NOT_FOUND");
  else error = e;
  return error;
}
var __defProp$1 = Object.defineProperty;
var __export = (target, all) => {
  for (var name in all) __defProp$1(target, name, {
    get: all[name],
    enumerable: true
  });
};
function isDataContentBlock(content_block) {
  return typeof content_block === "object" && content_block !== null && "type" in content_block && typeof content_block.type === "string" && "source_type" in content_block && (content_block.source_type === "url" || content_block.source_type === "base64" || content_block.source_type === "text" || content_block.source_type === "id");
}
function isURLContentBlock(content_block) {
  return isDataContentBlock(content_block) && content_block.source_type === "url" && "url" in content_block && typeof content_block.url === "string";
}
function isBase64ContentBlock(content_block) {
  return isDataContentBlock(content_block) && content_block.source_type === "base64" && "data" in content_block && typeof content_block.data === "string";
}
function isPlainTextContentBlock(content_block) {
  return isDataContentBlock(content_block) && content_block.source_type === "text" && "text" in content_block && typeof content_block.text === "string";
}
function isIDContentBlock(content_block) {
  return isDataContentBlock(content_block) && content_block.source_type === "id" && "id" in content_block && typeof content_block.id === "string";
}
function convertToOpenAIImageBlock(content_block) {
  if (isDataContentBlock(content_block)) {
    if (content_block.source_type === "url") return {
      type: "image_url",
      image_url: { url: content_block.url }
    };
    if (content_block.source_type === "base64") {
      if (!content_block.mime_type) throw new Error("mime_type key is required for base64 data.");
      const mime_type = content_block.mime_type;
      return {
        type: "image_url",
        image_url: { url: `data:${mime_type};base64,${content_block.data}` }
      };
    }
  }
  throw new Error("Unsupported source type. Only 'url' and 'base64' are supported.");
}
function parseMimeType(mime_type) {
  const parts = mime_type.split(";")[0].split("/");
  if (parts.length !== 2) throw new Error(`Invalid mime type: "${mime_type}" - does not match type/subtype format.`);
  const type = parts[0].trim();
  const subtype = parts[1].trim();
  if (type === "" || subtype === "") throw new Error(`Invalid mime type: "${mime_type}" - type or subtype is empty.`);
  const parameters = {};
  for (const parameterKvp of mime_type.split(";").slice(1)) {
    const parameterParts = parameterKvp.split("=");
    if (parameterParts.length !== 2) throw new Error(`Invalid parameter syntax in mime type: "${mime_type}".`);
    const key = parameterParts[0].trim();
    const value = parameterParts[1].trim();
    if (key === "") throw new Error(`Invalid parameter syntax in mime type: "${mime_type}".`);
    parameters[key] = value;
  }
  return {
    type,
    subtype,
    parameters
  };
}
function parseBase64DataUrl({ dataUrl: data_url, asTypedArray = false }) {
  const formatMatch = data_url.match(/^data:(\w+\/\w+);base64,([A-Za-z0-9+/]+=*)$/);
  let mime_type;
  if (formatMatch) {
    mime_type = formatMatch[1].toLowerCase();
    const data = asTypedArray ? Uint8Array.from(atob(formatMatch[2]), (c) => c.charCodeAt(0)) : formatMatch[2];
    return {
      mime_type,
      data
    };
  }
  return void 0;
}
function convertToProviderContentBlock(block, converter) {
  if (block.type === "text") {
    if (!converter.fromStandardTextBlock) throw new Error(`Converter for ${converter.providerName} does not implement \`fromStandardTextBlock\` method.`);
    return converter.fromStandardTextBlock(block);
  }
  if (block.type === "image") {
    if (!converter.fromStandardImageBlock) throw new Error(`Converter for ${converter.providerName} does not implement \`fromStandardImageBlock\` method.`);
    return converter.fromStandardImageBlock(block);
  }
  if (block.type === "audio") {
    if (!converter.fromStandardAudioBlock) throw new Error(`Converter for ${converter.providerName} does not implement \`fromStandardAudioBlock\` method.`);
    return converter.fromStandardAudioBlock(block);
  }
  if (block.type === "file") {
    if (!converter.fromStandardFileBlock) throw new Error(`Converter for ${converter.providerName} does not implement \`fromStandardFileBlock\` method.`);
    return converter.fromStandardFileBlock(block);
  }
  throw new Error(`Unable to convert content block type '${block.type}' to provider-specific format: not recognized.`);
}
function isMessage(message) {
  return typeof message === "object" && message !== null && "type" in message && "content" in message && (typeof message.content === "string" || Array.isArray(message.content));
}
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
var decamelize = function(str2, sep) {
  if (typeof str2 !== "string") {
    throw new TypeError("Expected a string");
  }
  sep = typeof sep === "undefined" ? "_" : sep;
  return str2.replace(/([a-z\d])([A-Z])/g, "$1" + sep + "$2").replace(/([A-Z]+)([A-Z][a-z\d]+)/g, "$1" + sep + "$2").toLowerCase();
};
const snakeCase = /* @__PURE__ */ getDefaultExportFromCjs(decamelize);
var camelcase = { exports: {} };
const UPPERCASE = /[\p{Lu}]/u;
const LOWERCASE = /[\p{Ll}]/u;
const LEADING_CAPITAL = /^[\p{Lu}](?![\p{Lu}])/gu;
const IDENTIFIER = /([\p{Alpha}\p{N}_]|$)/u;
const SEPARATORS = /[_.\- ]+/;
const LEADING_SEPARATORS = new RegExp("^" + SEPARATORS.source);
const SEPARATORS_AND_IDENTIFIER = new RegExp(SEPARATORS.source + IDENTIFIER.source, "gu");
const NUMBERS_AND_IDENTIFIER = new RegExp("\\d+" + IDENTIFIER.source, "gu");
const preserveCamelCase = (string2, toLowerCase, toUpperCase) => {
  let isLastCharLower = false;
  let isLastCharUpper = false;
  let isLastLastCharUpper = false;
  for (let i2 = 0; i2 < string2.length; i2++) {
    const character = string2[i2];
    if (isLastCharLower && UPPERCASE.test(character)) {
      string2 = string2.slice(0, i2) + "-" + string2.slice(i2);
      isLastCharLower = false;
      isLastLastCharUpper = isLastCharUpper;
      isLastCharUpper = true;
      i2++;
    } else if (isLastCharUpper && isLastLastCharUpper && LOWERCASE.test(character)) {
      string2 = string2.slice(0, i2 - 1) + "-" + string2.slice(i2 - 1);
      isLastLastCharUpper = isLastCharUpper;
      isLastCharUpper = false;
      isLastCharLower = true;
    } else {
      isLastCharLower = toLowerCase(character) === character && toUpperCase(character) !== character;
      isLastLastCharUpper = isLastCharUpper;
      isLastCharUpper = toUpperCase(character) === character && toLowerCase(character) !== character;
    }
  }
  return string2;
};
const preserveConsecutiveUppercase = (input, toLowerCase) => {
  LEADING_CAPITAL.lastIndex = 0;
  return input.replace(LEADING_CAPITAL, (m1) => toLowerCase(m1));
};
const postProcess = (input, toUpperCase) => {
  SEPARATORS_AND_IDENTIFIER.lastIndex = 0;
  NUMBERS_AND_IDENTIFIER.lastIndex = 0;
  return input.replace(SEPARATORS_AND_IDENTIFIER, (_, identifier) => toUpperCase(identifier)).replace(NUMBERS_AND_IDENTIFIER, (m) => toUpperCase(m));
};
const camelCase = (input, options2) => {
  if (!(typeof input === "string" || Array.isArray(input))) {
    throw new TypeError("Expected the input to be `string | string[]`");
  }
  options2 = {
    pascalCase: false,
    preserveConsecutiveUppercase: false,
    ...options2
  };
  if (Array.isArray(input)) {
    input = input.map((x) => x.trim()).filter((x) => x.length).join("-");
  } else {
    input = input.trim();
  }
  if (input.length === 0) {
    return "";
  }
  const toLowerCase = options2.locale === false ? (string2) => string2.toLowerCase() : (string2) => string2.toLocaleLowerCase(options2.locale);
  const toUpperCase = options2.locale === false ? (string2) => string2.toUpperCase() : (string2) => string2.toLocaleUpperCase(options2.locale);
  if (input.length === 1) {
    return options2.pascalCase ? toUpperCase(input) : toLowerCase(input);
  }
  const hasUpperCase = input !== toLowerCase(input);
  if (hasUpperCase) {
    input = preserveCamelCase(input, toLowerCase, toUpperCase);
  }
  input = input.replace(LEADING_SEPARATORS, "");
  if (options2.preserveConsecutiveUppercase) {
    input = preserveConsecutiveUppercase(input, toLowerCase);
  } else {
    input = toLowerCase(input);
  }
  if (options2.pascalCase) {
    input = toUpperCase(input.charAt(0)) + input.slice(1);
  }
  return postProcess(input, toUpperCase);
};
camelcase.exports = camelCase;
camelcase.exports.default = camelCase;
function keyToJson(key, map) {
  return (map == null ? void 0 : map[key]) || snakeCase(key);
}
function mapKeys(fields, mapper, map) {
  const mapped = {};
  for (const key in fields) if (Object.hasOwn(fields, key)) mapped[mapper(key, map)] = fields[key];
  return mapped;
}
var serializable_exports = {};
__export(serializable_exports, {
  Serializable: () => Serializable,
  get_lc_unique_name: () => get_lc_unique_name
});
function shallowCopy(obj) {
  return Array.isArray(obj) ? [...obj] : { ...obj };
}
function replaceSecrets(root, secretsMap) {
  const result = shallowCopy(root);
  for (const [path2, secretId] of Object.entries(secretsMap)) {
    const [last, ...partsReverse] = path2.split(".").reverse();
    let current = result;
    for (const part of partsReverse.reverse()) {
      if (current[part] === void 0) break;
      current[part] = shallowCopy(current[part]);
      current = current[part];
    }
    if (current[last] !== void 0) current[last] = {
      lc: 1,
      type: "secret",
      id: [secretId]
    };
  }
  return result;
}
function get_lc_unique_name(serializableClass) {
  const parentClass = Object.getPrototypeOf(serializableClass);
  const lcNameIsSubclassed = typeof serializableClass.lc_name === "function" && (typeof parentClass.lc_name !== "function" || serializableClass.lc_name() !== parentClass.lc_name());
  if (lcNameIsSubclassed) return serializableClass.lc_name();
  else return serializableClass.name;
}
var Serializable = class Serializable2 {
  constructor(kwargs, ..._args) {
    __publicField2(this, "lc_serializable", false);
    __publicField2(this, "lc_kwargs");
    if (this.lc_serializable_keys !== void 0) this.lc_kwargs = Object.fromEntries(Object.entries(kwargs || {}).filter(([key]) => {
      var _a3;
      return (_a3 = this.lc_serializable_keys) == null ? void 0 : _a3.includes(key);
    }));
    else this.lc_kwargs = kwargs ?? {};
  }
  /**
  * The name of the serializable. Override to provide an alias or
  * to preserve the serialized module name in minified environments.
  *
  * Implemented as a static method to support loading logic.
  */
  static lc_name() {
    return this.name;
  }
  /**
  * The final serialized identifier for the module.
  */
  get lc_id() {
    return [...this.lc_namespace, get_lc_unique_name(this.constructor)];
  }
  /**
  * A map of secrets, which will be omitted from serialization.
  * Keys are paths to the secret in constructor args, e.g. "foo.bar.baz".
  * Values are the secret ids, which will be used when deserializing.
  */
  get lc_secrets() {
    return void 0;
  }
  /**
  * A map of additional attributes to merge with constructor args.
  * Keys are the attribute names, e.g. "foo".
  * Values are the attribute values, which will be serialized.
  * These attributes need to be accepted by the constructor as arguments.
  */
  get lc_attributes() {
    return void 0;
  }
  /**
  * A map of aliases for constructor args.
  * Keys are the attribute names, e.g. "foo".
  * Values are the alias that will replace the key in serialization.
  * This is used to eg. make argument names match Python.
  */
  get lc_aliases() {
    return void 0;
  }
  /**
  * A manual list of keys that should be serialized.
  * If not overridden, all fields passed into the constructor will be serialized.
  */
  get lc_serializable_keys() {
    return void 0;
  }
  toJSON() {
    if (!this.lc_serializable) return this.toJSONNotImplemented();
    if (this.lc_kwargs instanceof Serializable2 || typeof this.lc_kwargs !== "object" || Array.isArray(this.lc_kwargs)) return this.toJSONNotImplemented();
    const aliases = {};
    const secrets = {};
    const kwargs = Object.keys(this.lc_kwargs).reduce((acc, key) => {
      acc[key] = key in this ? this[key] : this.lc_kwargs[key];
      return acc;
    }, {});
    for (let current = Object.getPrototypeOf(this); current; current = Object.getPrototypeOf(current)) {
      Object.assign(aliases, Reflect.get(current, "lc_aliases", this));
      Object.assign(secrets, Reflect.get(current, "lc_secrets", this));
      Object.assign(kwargs, Reflect.get(current, "lc_attributes", this));
    }
    Object.keys(secrets).forEach((keyPath) => {
      let read = this;
      let write = kwargs;
      const [last, ...partsReverse] = keyPath.split(".").reverse();
      for (const key of partsReverse.reverse()) {
        if (!(key in read) || read[key] === void 0) return;
        if (!(key in write) || write[key] === void 0) {
          if (typeof read[key] === "object" && read[key] != null) write[key] = {};
          else if (Array.isArray(read[key])) write[key] = [];
        }
        read = read[key];
        write = write[key];
      }
      if (last in read && read[last] !== void 0) write[last] = write[last] || read[last];
    });
    return {
      lc: 1,
      type: "constructor",
      id: this.lc_id,
      kwargs: mapKeys(Object.keys(secrets).length ? replaceSecrets(kwargs, secrets) : kwargs, keyToJson, aliases)
    };
  }
  toJSONNotImplemented() {
    return {
      lc: 1,
      type: "not_implemented",
      id: this.lc_id
    };
  }
};
function _isContentBlock(block, type) {
  return _isObject(block) && block.type === type;
}
function _isObject(value) {
  return typeof value === "object" && value !== null;
}
function _isArray(value) {
  return Array.isArray(value);
}
function _isString(value) {
  return typeof value === "string";
}
function _isNumber(value) {
  return typeof value === "number";
}
function _isBytesArray(value) {
  return value instanceof Uint8Array;
}
function safeParseJson(value) {
  try {
    return JSON.parse(value);
  } catch {
    return void 0;
  }
}
const iife$3 = (fn) => fn();
function convertAnthropicAnnotation(citation) {
  if (citation.type === "char_location" && _isString(citation.document_title) && _isNumber(citation.start_char_index) && _isNumber(citation.end_char_index) && _isString(citation.cited_text)) {
    const { document_title, start_char_index, end_char_index, cited_text, ...rest } = citation;
    return {
      ...rest,
      type: "citation",
      source: "char",
      title: document_title ?? void 0,
      startIndex: start_char_index,
      endIndex: end_char_index,
      citedText: cited_text
    };
  }
  if (citation.type === "page_location" && _isString(citation.document_title) && _isNumber(citation.start_page_number) && _isNumber(citation.end_page_number) && _isString(citation.cited_text)) {
    const { document_title, start_page_number, end_page_number, cited_text, ...rest } = citation;
    return {
      ...rest,
      type: "citation",
      source: "page",
      title: document_title ?? void 0,
      startIndex: start_page_number,
      endIndex: end_page_number,
      citedText: cited_text
    };
  }
  if (citation.type === "content_block_location" && _isString(citation.document_title) && _isNumber(citation.start_block_index) && _isNumber(citation.end_block_index) && _isString(citation.cited_text)) {
    const { document_title, start_block_index, end_block_index, cited_text, ...rest } = citation;
    return {
      ...rest,
      type: "citation",
      source: "block",
      title: document_title ?? void 0,
      startIndex: start_block_index,
      endIndex: end_block_index,
      citedText: cited_text
    };
  }
  if (citation.type === "web_search_result_location" && _isString(citation.url) && _isString(citation.title) && _isString(citation.encrypted_index) && _isString(citation.cited_text)) {
    const { url, title, encrypted_index, cited_text, ...rest } = citation;
    return {
      ...rest,
      type: "citation",
      source: "url",
      url,
      title,
      startIndex: Number(encrypted_index),
      endIndex: Number(encrypted_index),
      citedText: cited_text
    };
  }
  if (citation.type === "search_result_location" && _isString(citation.source) && _isString(citation.title) && _isNumber(citation.start_block_index) && _isNumber(citation.end_block_index) && _isString(citation.cited_text)) {
    const { source, title, start_block_index, end_block_index, cited_text, ...rest } = citation;
    return {
      ...rest,
      type: "citation",
      source: "search",
      url: source,
      title: title ?? void 0,
      startIndex: start_block_index,
      endIndex: end_block_index,
      citedText: cited_text
    };
  }
  return void 0;
}
function convertToV1FromAnthropicContentBlock(block) {
  if (_isContentBlock(block, "document") && _isObject(block.source) && "type" in block.source) {
    if (block.source.type === "base64" && _isString(block.source.media_type) && _isString(block.source.data)) return {
      type: "file",
      mimeType: block.source.media_type,
      data: block.source.data
    };
    else if (block.source.type === "url" && _isString(block.source.url)) return {
      type: "file",
      url: block.source.url
    };
    else if (block.source.type === "file" && _isString(block.source.file_id)) return {
      type: "file",
      fileId: block.source.file_id
    };
    else if (block.source.type === "text" && _isString(block.source.data)) return {
      type: "file",
      mimeType: String(block.source.media_type ?? "text/plain"),
      data: block.source.data
    };
  } else if (_isContentBlock(block, "image") && _isObject(block.source) && "type" in block.source) {
    if (block.source.type === "base64" && _isString(block.source.media_type) && _isString(block.source.data)) return {
      type: "image",
      mimeType: block.source.media_type,
      data: block.source.data
    };
    else if (block.source.type === "url" && _isString(block.source.url)) return {
      type: "image",
      url: block.source.url
    };
    else if (block.source.type === "file" && _isString(block.source.file_id)) return {
      type: "image",
      fileId: block.source.file_id
    };
  }
  return void 0;
}
function convertToV1FromAnthropicInput(content) {
  function* iterateContent() {
    for (const block of content) {
      const stdBlock = convertToV1FromAnthropicContentBlock(block);
      if (stdBlock) yield stdBlock;
      else yield block;
    }
  }
  return Array.from(iterateContent());
}
function convertToV1FromAnthropicMessage(message) {
  function* iterateContent() {
    var _a3;
    const content = typeof message.content === "string" ? [{
      type: "text",
      text: message.content
    }] : message.content;
    for (const block of content) {
      if (_isContentBlock(block, "text") && _isString(block.text)) {
        const { text, citations, ...rest } = block;
        if (_isArray(citations) && citations.length) {
          const _citations = citations.reduce((acc, item) => {
            const citation = convertAnthropicAnnotation(item);
            if (citation) return [...acc, citation];
            return acc;
          }, []);
          yield {
            ...rest,
            type: "text",
            text,
            annotations: _citations
          };
          continue;
        } else {
          yield {
            ...rest,
            type: "text",
            text
          };
          continue;
        }
      } else if (_isContentBlock(block, "thinking") && _isString(block.thinking)) {
        const { thinking, signature, ...rest } = block;
        yield {
          ...rest,
          type: "reasoning",
          reasoning: thinking,
          signature
        };
        continue;
      } else if (_isContentBlock(block, "redacted_thinking")) {
        yield {
          type: "non_standard",
          value: block
        };
        continue;
      } else if (_isContentBlock(block, "tool_use") && _isString(block.name) && _isString(block.id)) {
        yield {
          type: "tool_call",
          id: block.id,
          name: block.name,
          args: block.input
        };
        continue;
      } else if (_isContentBlock(block, "input_json_delta")) {
        if (_isAIMessageChunk(message) && ((_a3 = message.tool_call_chunks) == null ? void 0 : _a3.length)) {
          const tool_call_chunk = message.tool_call_chunks[0];
          yield {
            type: "tool_call_chunk",
            id: tool_call_chunk.id,
            name: tool_call_chunk.name,
            args: tool_call_chunk.args,
            index: tool_call_chunk.index
          };
          continue;
        }
      } else if (_isContentBlock(block, "server_tool_use") && _isString(block.name) && _isString(block.id)) {
        const { name, id } = block;
        if (name === "web_search") {
          const query = iife$3(() => {
            if (typeof block.input === "string") return block.input;
            else if (_isObject(block.input) && _isString(block.input.query)) return block.input.query;
            else if (_isString(block.partial_json)) {
              const json = safeParseJson(block.partial_json);
              if (json == null ? void 0 : json.query) return json.query;
            }
            return "";
          });
          yield {
            id,
            type: "server_tool_call",
            name: "web_search",
            args: { query }
          };
          continue;
        } else if (block.name === "code_execution") {
          const code2 = iife$3(() => {
            if (typeof block.input === "string") return block.input;
            else if (_isObject(block.input) && _isString(block.input.code)) return block.input.code;
            else if (_isString(block.partial_json)) {
              const json = safeParseJson(block.partial_json);
              if (json == null ? void 0 : json.code) return json.code;
            }
            return "";
          });
          yield {
            id,
            type: "server_tool_call",
            name: "code_execution",
            args: { code: code2 }
          };
          continue;
        }
      } else if (_isContentBlock(block, "web_search_tool_result") && _isString(block.tool_use_id) && _isArray(block.content)) {
        const { content: content$1, tool_use_id } = block;
        const urls = content$1.reduce((acc, content$2) => {
          if (_isContentBlock(content$2, "web_search_result")) return [...acc, content$2.url];
          return acc;
        }, []);
        yield {
          type: "server_tool_call_result",
          name: "web_search",
          toolCallId: tool_use_id,
          status: "success",
          output: { urls }
        };
        continue;
      } else if (_isContentBlock(block, "code_execution_tool_result") && _isString(block.tool_use_id) && _isObject(block.content)) {
        yield {
          type: "server_tool_call_result",
          name: "code_execution",
          toolCallId: block.tool_use_id,
          status: "success",
          output: block.content
        };
        continue;
      } else if (_isContentBlock(block, "mcp_tool_use")) {
        yield {
          id: block.id,
          type: "server_tool_call",
          name: "mcp_tool_use",
          args: block.input
        };
        continue;
      } else if (_isContentBlock(block, "mcp_tool_result") && _isString(block.tool_use_id) && _isObject(block.content)) {
        yield {
          type: "server_tool_call_result",
          name: "mcp_tool_use",
          toolCallId: block.tool_use_id,
          status: "success",
          output: block.content
        };
        continue;
      } else if (_isContentBlock(block, "container_upload")) {
        yield {
          type: "server_tool_call",
          name: "container_upload",
          args: block.input
        };
        continue;
      } else if (_isContentBlock(block, "search_result")) {
        yield {
          id: block.id,
          type: "non_standard",
          value: block
        };
        continue;
      } else if (_isContentBlock(block, "tool_result")) {
        yield {
          id: block.id,
          type: "non_standard",
          value: block
        };
        continue;
      } else {
        const stdBlock = convertToV1FromAnthropicContentBlock(block);
        if (stdBlock) {
          yield stdBlock;
          continue;
        }
      }
      yield {
        type: "non_standard",
        value: block
      };
    }
  }
  return Array.from(iterateContent());
}
const ChatAnthropicTranslator = {
  translateContent: convertToV1FromAnthropicMessage,
  translateContentChunk: convertToV1FromAnthropicMessage
};
function _isAIMessageChunk(message) {
  return typeof (message == null ? void 0 : message._getType) === "function" && typeof message.concat === "function" && message._getType() === "ai";
}
function convertToV1FromDataContentBlock(block) {
  if (isURLContentBlock(block)) return {
    type: block.type,
    mimeType: block.mime_type,
    url: block.url,
    metadata: block.metadata
  };
  if (isBase64ContentBlock(block)) return {
    type: block.type,
    mimeType: block.mime_type ?? "application/octet-stream",
    data: block.data,
    metadata: block.metadata
  };
  if (isIDContentBlock(block)) return {
    type: block.type,
    mimeType: block.mime_type,
    fileId: block.id,
    metadata: block.metadata
  };
  return block;
}
function convertToV1FromDataContent(content) {
  return content.map(convertToV1FromDataContentBlock);
}
function isOpenAIDataBlock(block) {
  if (_isContentBlock(block, "image_url") && _isObject(block.image_url)) return true;
  if (_isContentBlock(block, "input_audio") && _isObject(block.input_audio)) return true;
  if (_isContentBlock(block, "file") && _isObject(block.file)) return true;
  return false;
}
function convertToV1FromOpenAIDataBlock(block) {
  if (_isContentBlock(block, "image_url") && _isObject(block.image_url) && _isString(block.image_url.url)) {
    const parsed = parseBase64DataUrl({ dataUrl: block.image_url.url });
    if (parsed) return {
      type: "image",
      mimeType: parsed.mime_type,
      data: parsed.data
    };
    else return {
      type: "image",
      url: block.image_url.url
    };
  } else if (_isContentBlock(block, "input_audio") && _isObject(block.input_audio) && _isString(block.input_audio.data) && _isString(block.input_audio.format)) return {
    type: "audio",
    data: block.input_audio.data,
    mimeType: `audio/${block.input_audio.format}`
  };
  else if (_isContentBlock(block, "file") && _isObject(block.file) && _isString(block.file.data)) {
    const parsed = parseBase64DataUrl({ dataUrl: block.file.data });
    if (parsed) return {
      type: "file",
      data: parsed.data,
      mimeType: parsed.mime_type
    };
    else if (_isString(block.file.file_id)) return {
      type: "file",
      fileId: block.file.file_id
    };
  }
  return block;
}
function convertToV1FromChatCompletions(message) {
  const blocks2 = [];
  if (typeof message.content === "string") blocks2.push({
    type: "text",
    text: message.content
  });
  else blocks2.push(...convertToV1FromChatCompletionsInput(message.content));
  for (const toolCall of message.tool_calls ?? []) blocks2.push({
    type: "tool_call",
    id: toolCall.id,
    name: toolCall.name,
    args: toolCall.args
  });
  return blocks2;
}
function convertToV1FromChatCompletionsChunk(message) {
  const blocks2 = [];
  if (typeof message.content === "string") blocks2.push({
    type: "text",
    text: message.content
  });
  else blocks2.push(...convertToV1FromChatCompletionsInput(message.content));
  for (const toolCall of message.tool_calls ?? []) blocks2.push({
    type: "tool_call",
    id: toolCall.id,
    name: toolCall.name,
    args: toolCall.args
  });
  return blocks2;
}
function convertToV1FromChatCompletionsInput(blocks2) {
  const convertedBlocks = [];
  for (const block of blocks2) if (isOpenAIDataBlock(block)) convertedBlocks.push(convertToV1FromOpenAIDataBlock(block));
  else convertedBlocks.push(block);
  return convertedBlocks;
}
function convertResponsesAnnotation(annotation) {
  if (annotation.type === "url_citation") {
    const { url, title, start_index, end_index } = annotation;
    return {
      type: "citation",
      url,
      title,
      startIndex: start_index,
      endIndex: end_index
    };
  }
  if (annotation.type === "file_citation") {
    const { file_id, filename, index } = annotation;
    return {
      type: "citation",
      title: filename,
      startIndex: index,
      endIndex: index,
      fileId: file_id
    };
  }
  return annotation;
}
function convertToV1FromResponses(message) {
  function* iterateContent() {
    var _a3;
    if (_isObject((_a3 = message.additional_kwargs) == null ? void 0 : _a3.reasoning) && _isArray(message.additional_kwargs.reasoning.summary)) {
      const summary = message.additional_kwargs.reasoning.summary.reduce((acc, item) => {
        if (_isObject(item) && _isString(item.text)) return `${acc}${item.text}`;
        return acc;
      }, "");
      yield {
        type: "reasoning",
        reasoning: summary
      };
    }
    const content = typeof message.content === "string" ? [{
      type: "text",
      text: message.content
    }] : message.content;
    for (const block of content) if (_isContentBlock(block, "text")) {
      const { text, annotations, ...rest } = block;
      if (Array.isArray(annotations)) yield {
        ...rest,
        type: "text",
        text: String(text),
        annotations: annotations.map(convertResponsesAnnotation)
      };
      else yield {
        ...rest,
        type: "text",
        text: String(text)
      };
    }
    for (const toolCall of message.tool_calls ?? []) yield {
      type: "tool_call",
      id: toolCall.id,
      name: toolCall.name,
      args: toolCall.args
    };
    if (_isObject(message.additional_kwargs) && _isArray(message.additional_kwargs.tool_outputs)) for (const toolOutput of message.additional_kwargs.tool_outputs) {
      if (_isContentBlock(toolOutput, "web_search_call")) {
        yield {
          id: toolOutput.id,
          type: "server_tool_call",
          name: "web_search",
          args: { query: toolOutput.query }
        };
        continue;
      } else if (_isContentBlock(toolOutput, "file_search_call")) {
        yield {
          id: toolOutput.id,
          type: "server_tool_call",
          name: "file_search",
          args: { query: toolOutput.query }
        };
        continue;
      } else if (_isContentBlock(toolOutput, "computer_call")) {
        yield {
          type: "non_standard",
          value: toolOutput
        };
        continue;
      } else if (_isContentBlock(toolOutput, "code_interpreter_call")) {
        if (_isString(toolOutput.code)) yield {
          id: toolOutput.id,
          type: "server_tool_call",
          name: "code_interpreter",
          args: { code: toolOutput.code }
        };
        if (_isArray(toolOutput.outputs)) {
          const returnCode = iife$3(() => {
            if (toolOutput.status === "in_progress") return void 0;
            if (toolOutput.status === "completed") return 0;
            if (toolOutput.status === "incomplete") return 127;
            if (toolOutput.status === "interpreting") return void 0;
            if (toolOutput.status === "failed") return 1;
            return void 0;
          });
          for (const output of toolOutput.outputs) if (_isContentBlock(output, "logs")) {
            yield {
              type: "server_tool_call_result",
              toolCallId: toolOutput.id ?? "",
              status: "success",
              output: {
                type: "code_interpreter_output",
                returnCode: returnCode ?? 0,
                stderr: [0, void 0].includes(returnCode) ? void 0 : String(output.logs),
                stdout: [0, void 0].includes(returnCode) ? String(output.logs) : void 0
              }
            };
            continue;
          }
        }
        continue;
      } else if (_isContentBlock(toolOutput, "mcp_call")) {
        yield {
          id: toolOutput.id,
          type: "server_tool_call",
          name: "mcp_call",
          args: toolOutput.input
        };
        continue;
      } else if (_isContentBlock(toolOutput, "mcp_list_tools")) {
        yield {
          id: toolOutput.id,
          type: "server_tool_call",
          name: "mcp_list_tools",
          args: toolOutput.input
        };
        continue;
      } else if (_isContentBlock(toolOutput, "mcp_approval_request")) {
        yield {
          type: "non_standard",
          value: toolOutput
        };
        continue;
      } else if (_isContentBlock(toolOutput, "image_generation_call")) {
        yield {
          type: "non_standard",
          value: toolOutput
        };
        continue;
      }
      if (_isObject(toolOutput)) yield {
        type: "non_standard",
        value: toolOutput
      };
    }
  }
  return Array.from(iterateContent());
}
function convertToV1FromResponsesChunk(message) {
  function* iterateContent() {
    yield* convertToV1FromResponses(message);
    for (const toolCallChunk of message.tool_call_chunks ?? []) yield {
      type: "tool_call_chunk",
      id: toolCallChunk.id,
      name: toolCallChunk.name,
      args: toolCallChunk.args
    };
  }
  return Array.from(iterateContent());
}
const ChatOpenAITranslator = {
  translateContent: (message) => {
    if (typeof message.content === "string") return convertToV1FromChatCompletions(message);
    return convertToV1FromResponses(message);
  },
  translateContentChunk: (message) => {
    if (typeof message.content === "string") return convertToV1FromChatCompletionsChunk(message);
    return convertToV1FromResponsesChunk(message);
  }
};
function convertToFormattedString(message, format2 = "pretty") {
  if (format2 === "pretty") return convertToPrettyString(message);
  return JSON.stringify(message);
}
function convertToPrettyString(message) {
  const lines = [];
  const title = ` ${message.type.charAt(0).toUpperCase() + message.type.slice(1)} Message `;
  const sepLen = Math.floor((80 - title.length) / 2);
  const sep = "=".repeat(sepLen);
  const secondSep = title.length % 2 === 0 ? sep : `${sep}=`;
  lines.push(`${sep}${title}${secondSep}`);
  if (message.type === "ai") {
    const aiMessage = message;
    if (aiMessage.tool_calls && aiMessage.tool_calls.length > 0) {
      lines.push("Tool Calls:");
      for (const tc of aiMessage.tool_calls) {
        lines.push(`  ${tc.name} (${tc.id})`);
        lines.push(` Call ID: ${tc.id}`);
        lines.push("  Args:");
        for (const [key, value] of Object.entries(tc.args)) lines.push(`    ${key}: ${value}`);
      }
    }
  }
  if (message.type === "tool") {
    const toolMessage = message;
    if (toolMessage.name) lines.push(`Name: ${toolMessage.name}`);
  }
  if (typeof message.content === "string" && message.content.trim()) {
    if (lines.length > 1) lines.push("");
    lines.push(message.content);
  }
  return lines.join("\n");
}
const MESSAGE_SYMBOL = Symbol.for("langchain.message");
function mergeContent(firstContent, secondContent) {
  if (typeof firstContent === "string") {
    if (firstContent === "") return secondContent;
    if (typeof secondContent === "string") return firstContent + secondContent;
    else if (Array.isArray(secondContent) && secondContent.length === 0) return firstContent;
    else if (Array.isArray(secondContent) && secondContent.some((c) => isDataContentBlock(c))) return [{
      type: "text",
      source_type: "text",
      text: firstContent
    }, ...secondContent];
    else return [{
      type: "text",
      text: firstContent
    }, ...secondContent];
  } else if (Array.isArray(secondContent)) return _mergeLists(firstContent, secondContent) ?? [...firstContent, ...secondContent];
  else if (secondContent === "") return firstContent;
  else if (Array.isArray(firstContent) && firstContent.some((c) => isDataContentBlock(c))) return [...firstContent, {
    type: "file",
    source_type: "text",
    text: secondContent
  }];
  else return [...firstContent, {
    type: "text",
    text: secondContent
  }];
}
function _mergeStatus(left, right) {
  if (left === "error" || right === "error") return "error";
  return "success";
}
function stringifyWithDepthLimit(obj, depthLimit) {
  function helper(obj$1, currentDepth) {
    if (typeof obj$1 !== "object" || obj$1 === null || obj$1 === void 0) return obj$1;
    if (currentDepth >= depthLimit) {
      if (Array.isArray(obj$1)) return "[Array]";
      return "[Object]";
    }
    if (Array.isArray(obj$1)) return obj$1.map((item) => helper(item, currentDepth + 1));
    const result = {};
    for (const key of Object.keys(obj$1)) result[key] = helper(obj$1[key], currentDepth + 1);
    return result;
  }
  return JSON.stringify(helper(obj, 0), null, 2);
}
var BaseMessage = class extends Serializable {
  constructor(arg) {
    const fields = typeof arg === "string" || Array.isArray(arg) ? { content: arg } : arg;
    if (!fields.additional_kwargs) fields.additional_kwargs = {};
    if (!fields.response_metadata) fields.response_metadata = {};
    super(fields);
    __publicField2(this, "lc_namespace", ["langchain_core", "messages"]);
    __publicField2(this, "lc_serializable", true);
    __publicField2(this, _a2, true);
    __publicField2(this, "id");
    __publicField2(this, "name");
    __publicField2(this, "content");
    __publicField2(this, "additional_kwargs");
    __publicField2(this, "response_metadata");
    this.name = fields.name;
    if (fields.content === void 0 && fields.contentBlocks !== void 0) {
      this.content = fields.contentBlocks;
      this.response_metadata = {
        output_version: "v1",
        ...fields.response_metadata
      };
    } else if (fields.content !== void 0) {
      this.content = fields.content ?? [];
      this.response_metadata = fields.response_metadata;
    } else {
      this.content = [];
      this.response_metadata = fields.response_metadata;
    }
    this.additional_kwargs = fields.additional_kwargs;
    this.id = fields.id;
  }
  get lc_aliases() {
    return {
      additional_kwargs: "additional_kwargs",
      response_metadata: "response_metadata"
    };
  }
  /**
  * @deprecated Use .getType() instead or import the proper typeguard.
  * For example:
  *
  * ```ts
  * import { isAIMessage } from "@langchain/core/messages";
  *
  * const message = new AIMessage("Hello!");
  * isAIMessage(message); // true
  * ```
  */
  _getType() {
    return this.type;
  }
  /**
  * @deprecated Use .type instead
  * The type of the message.
  */
  getType() {
    return this._getType();
  }
  /** Get text content of the message. */
  get text() {
    if (typeof this.content === "string") return this.content;
    if (!Array.isArray(this.content)) return "";
    return this.content.map((c) => {
      if (typeof c === "string") return c;
      if (c.type === "text") return c.text;
      return "";
    }).join("");
  }
  get contentBlocks() {
    const blocks2 = typeof this.content === "string" ? [{
      type: "text",
      text: this.content
    }] : this.content;
    const parsingSteps = [
      convertToV1FromDataContent,
      convertToV1FromChatCompletionsInput,
      convertToV1FromAnthropicInput
    ];
    const parsedBlocks = parsingSteps.reduce((blocks$1, step) => step(blocks$1), blocks2);
    return parsedBlocks;
  }
  toDict() {
    return {
      type: this.getType(),
      data: this.toJSON().kwargs
    };
  }
  static lc_name() {
    return "BaseMessage";
  }
  get _printableFields() {
    return {
      id: this.id,
      content: this.content,
      name: this.name,
      additional_kwargs: this.additional_kwargs,
      response_metadata: this.response_metadata
    };
  }
  static isInstance(obj) {
    return typeof obj === "object" && obj !== null && MESSAGE_SYMBOL in obj && obj[MESSAGE_SYMBOL] === true && isMessage(obj);
  }
  _updateId(value) {
    this.id = value;
    this.lc_kwargs.id = value;
  }
  get [(_a2 = MESSAGE_SYMBOL, Symbol.toStringTag)]() {
    return this.constructor.lc_name();
  }
  [Symbol.for("nodejs.util.inspect.custom")](depth) {
    if (depth === null) return this;
    const printable = stringifyWithDepthLimit(this._printableFields, Math.max(4, depth));
    return `${this.constructor.lc_name()} ${printable}`;
  }
  toFormattedString(format2 = "pretty") {
    return convertToFormattedString(this, format2);
  }
};
function isOpenAIToolCallArray(value) {
  return Array.isArray(value) && value.every((v) => typeof v.index === "number");
}
function _mergeDicts(left = {}, right = {}) {
  const merged = { ...left };
  for (const [key, value] of Object.entries(right)) if (merged[key] == null) merged[key] = value;
  else if (value == null) continue;
  else if (typeof merged[key] !== typeof value || Array.isArray(merged[key]) !== Array.isArray(value)) throw new Error(`field[${key}] already exists in the message chunk, but with a different type.`);
  else if (typeof merged[key] === "string") if (key === "type") continue;
  else if ([
    "id",
    "name",
    "output_version",
    "model_provider"
  ].includes(key)) {
    if (value) merged[key] = value;
  } else merged[key] += value;
  else if (typeof merged[key] === "object" && !Array.isArray(merged[key])) merged[key] = _mergeDicts(merged[key], value);
  else if (Array.isArray(merged[key])) merged[key] = _mergeLists(merged[key], value);
  else if (merged[key] === value) continue;
  else console.warn(`field[${key}] already exists in this message chunk and value has unsupported type.`);
  return merged;
}
function _mergeLists(left, right) {
  if (left === void 0 && right === void 0) return void 0;
  else if (left === void 0 || right === void 0) return left || right;
  else {
    const merged = [...left];
    for (const item of right) if (typeof item === "object" && item !== null && "index" in item && typeof item.index === "number") {
      const toMerge = merged.findIndex((leftItem) => {
        const isObject2 = typeof leftItem === "object";
        const indiciesMatch = "index" in leftItem && leftItem.index === item.index;
        const idsMatch = "id" in leftItem && "id" in item && (leftItem == null ? void 0 : leftItem.id) === (item == null ? void 0 : item.id);
        const eitherItemMissingID = !("id" in leftItem) || !(leftItem == null ? void 0 : leftItem.id) || !("id" in item) || !(item == null ? void 0 : item.id);
        return isObject2 && indiciesMatch && (idsMatch || eitherItemMissingID);
      });
      if (toMerge !== -1 && typeof merged[toMerge] === "object" && merged[toMerge] !== null) merged[toMerge] = _mergeDicts(merged[toMerge], item);
      else merged.push(item);
    } else if (typeof item === "object" && item !== null && "text" in item && item.text === "") continue;
    else merged.push(item);
    return merged;
  }
}
function _mergeObj(left, right) {
  if (!left && !right) throw new Error("Cannot merge two undefined objects.");
  if (!left || !right) return left || right;
  else if (typeof left !== typeof right) throw new Error(`Cannot merge objects of different types.
Left ${typeof left}
Right ${typeof right}`);
  else if (typeof left === "string" && typeof right === "string") return left + right;
  else if (Array.isArray(left) && Array.isArray(right)) return _mergeLists(left, right);
  else if (typeof left === "object" && typeof right === "object") return _mergeDicts(left, right);
  else if (left === right) return left;
  else throw new Error(`Can not merge objects of different types.
Left ${left}
Right ${right}`);
}
var BaseMessageChunk = class BaseMessageChunk2 extends BaseMessage {
  static isInstance(obj) {
    if (!super.isInstance(obj)) return false;
    let proto = Object.getPrototypeOf(obj);
    while (proto !== null) {
      if (proto === BaseMessageChunk2.prototype) return true;
      proto = Object.getPrototypeOf(proto);
    }
    return false;
  }
};
function _isMessageFieldWithRole(x) {
  return typeof x.role === "string";
}
function isBaseMessage(messageLike) {
  return typeof (messageLike == null ? void 0 : messageLike._getType) === "function";
}
function isBaseMessageChunk(messageLike) {
  return BaseMessageChunk.isInstance(messageLike);
}
function mergeResponseMetadata(a, b) {
  const output = _mergeDicts(a ?? {}, b ?? {});
  return output;
}
function mergeModalitiesTokenDetails(a, b) {
  const output = {};
  if ((a == null ? void 0 : a.audio) !== void 0 || (b == null ? void 0 : b.audio) !== void 0) output.audio = ((a == null ? void 0 : a.audio) ?? 0) + ((b == null ? void 0 : b.audio) ?? 0);
  if ((a == null ? void 0 : a.image) !== void 0 || (b == null ? void 0 : b.image) !== void 0) output.image = ((a == null ? void 0 : a.image) ?? 0) + ((b == null ? void 0 : b.image) ?? 0);
  if ((a == null ? void 0 : a.video) !== void 0 || (b == null ? void 0 : b.video) !== void 0) output.video = ((a == null ? void 0 : a.video) ?? 0) + ((b == null ? void 0 : b.video) ?? 0);
  if ((a == null ? void 0 : a.document) !== void 0 || (b == null ? void 0 : b.document) !== void 0) output.document = ((a == null ? void 0 : a.document) ?? 0) + ((b == null ? void 0 : b.document) ?? 0);
  if ((a == null ? void 0 : a.text) !== void 0 || (b == null ? void 0 : b.text) !== void 0) output.text = ((a == null ? void 0 : a.text) ?? 0) + ((b == null ? void 0 : b.text) ?? 0);
  return output;
}
function mergeInputTokenDetails(a, b) {
  const output = { ...mergeModalitiesTokenDetails(a, b) };
  if ((a == null ? void 0 : a.cache_read) !== void 0 || (b == null ? void 0 : b.cache_read) !== void 0) output.cache_read = ((a == null ? void 0 : a.cache_read) ?? 0) + ((b == null ? void 0 : b.cache_read) ?? 0);
  if ((a == null ? void 0 : a.cache_creation) !== void 0 || (b == null ? void 0 : b.cache_creation) !== void 0) output.cache_creation = ((a == null ? void 0 : a.cache_creation) ?? 0) + ((b == null ? void 0 : b.cache_creation) ?? 0);
  return output;
}
function mergeOutputTokenDetails(a, b) {
  const output = { ...mergeModalitiesTokenDetails(a, b) };
  if ((a == null ? void 0 : a.reasoning) !== void 0 || (b == null ? void 0 : b.reasoning) !== void 0) output.reasoning = ((a == null ? void 0 : a.reasoning) ?? 0) + ((b == null ? void 0 : b.reasoning) ?? 0);
  return output;
}
function mergeUsageMetadata(a, b) {
  return {
    input_tokens: ((a == null ? void 0 : a.input_tokens) ?? 0) + ((b == null ? void 0 : b.input_tokens) ?? 0),
    output_tokens: ((a == null ? void 0 : a.output_tokens) ?? 0) + ((b == null ? void 0 : b.output_tokens) ?? 0),
    total_tokens: ((a == null ? void 0 : a.total_tokens) ?? 0) + ((b == null ? void 0 : b.total_tokens) ?? 0),
    input_token_details: mergeInputTokenDetails(a == null ? void 0 : a.input_token_details, b == null ? void 0 : b.input_token_details),
    output_token_details: mergeOutputTokenDetails(a == null ? void 0 : a.output_token_details, b == null ? void 0 : b.output_token_details)
  };
}
var tool_exports = {};
__export(tool_exports, {
  ToolMessage: () => ToolMessage,
  ToolMessageChunk: () => ToolMessageChunk,
  defaultToolCallParser: () => defaultToolCallParser,
  isDirectToolOutput: () => isDirectToolOutput,
  isToolMessage: () => isToolMessage,
  isToolMessageChunk: () => isToolMessageChunk
});
function isDirectToolOutput(x) {
  return x != null && typeof x === "object" && "lc_direct_tool_output" in x && x.lc_direct_tool_output === true;
}
var ToolMessage = class extends BaseMessage {
  constructor(fields, tool_call_id, name) {
    const toolMessageFields = typeof fields === "string" || Array.isArray(fields) ? {
      content: fields,
      name,
      tool_call_id
    } : fields;
    super(toolMessageFields);
    __publicField2(this, "lc_direct_tool_output", true);
    __publicField2(this, "type", "tool");
    /**
    * Status of the tool invocation.
    * @version 0.2.19
    */
    __publicField2(this, "status");
    __publicField2(this, "tool_call_id");
    __publicField2(this, "metadata");
    /**
    * Artifact of the Tool execution which is not meant to be sent to the model.
    *
    * Should only be specified if it is different from the message content, e.g. if only
    * a subset of the full tool output is being passed as message content but the full
    * output is needed in other parts of the code.
    */
    __publicField2(this, "artifact");
    this.tool_call_id = toolMessageFields.tool_call_id;
    this.artifact = toolMessageFields.artifact;
    this.status = toolMessageFields.status;
    this.metadata = toolMessageFields.metadata;
  }
  static lc_name() {
    return "ToolMessage";
  }
  get lc_aliases() {
    return { tool_call_id: "tool_call_id" };
  }
  static isInstance(message) {
    return super.isInstance(message) && message.type === "tool";
  }
  get _printableFields() {
    return {
      ...super._printableFields,
      tool_call_id: this.tool_call_id,
      artifact: this.artifact
    };
  }
};
var ToolMessageChunk = class extends BaseMessageChunk {
  constructor(fields) {
    super(fields);
    __publicField2(this, "type", "tool");
    __publicField2(this, "tool_call_id");
    /**
    * Status of the tool invocation.
    * @version 0.2.19
    */
    __publicField2(this, "status");
    /**
    * Artifact of the Tool execution which is not meant to be sent to the model.
    *
    * Should only be specified if it is different from the message content, e.g. if only
    * a subset of the full tool output is being passed as message content but the full
    * output is needed in other parts of the code.
    */
    __publicField2(this, "artifact");
    this.tool_call_id = fields.tool_call_id;
    this.artifact = fields.artifact;
    this.status = fields.status;
  }
  static lc_name() {
    return "ToolMessageChunk";
  }
  concat(chunk) {
    const Cls = this.constructor;
    return new Cls({
      content: mergeContent(this.content, chunk.content),
      additional_kwargs: _mergeDicts(this.additional_kwargs, chunk.additional_kwargs),
      response_metadata: _mergeDicts(this.response_metadata, chunk.response_metadata),
      artifact: _mergeObj(this.artifact, chunk.artifact),
      tool_call_id: this.tool_call_id,
      id: this.id ?? chunk.id,
      status: _mergeStatus(this.status, chunk.status)
    });
  }
  get _printableFields() {
    return {
      ...super._printableFields,
      tool_call_id: this.tool_call_id,
      artifact: this.artifact
    };
  }
};
function defaultToolCallParser(rawToolCalls) {
  const toolCalls = [];
  const invalidToolCalls = [];
  for (const toolCall of rawToolCalls) if (!toolCall.function) continue;
  else {
    const functionName = toolCall.function.name;
    try {
      const functionArgs = JSON.parse(toolCall.function.arguments);
      toolCalls.push({
        name: functionName || "",
        args: functionArgs || {},
        id: toolCall.id
      });
    } catch {
      invalidToolCalls.push({
        name: functionName,
        args: toolCall.function.arguments,
        id: toolCall.id,
        error: "Malformed args."
      });
    }
  }
  return [toolCalls, invalidToolCalls];
}
function isToolMessage(x) {
  return typeof x === "object" && x !== null && "getType" in x && typeof x.getType === "function" && x.getType() === "tool";
}
function isToolMessageChunk(x) {
  return x._getType() === "tool";
}
var ChatMessage = class ChatMessage2 extends BaseMessage {
  constructor(fields, role) {
    if (typeof fields === "string" || Array.isArray(fields)) fields = {
      content: fields,
      role
    };
    super(fields);
    __publicField2(this, "type", "generic");
    __publicField2(this, "role");
    this.role = fields.role;
  }
  static lc_name() {
    return "ChatMessage";
  }
  static _chatMessageClass() {
    return ChatMessage2;
  }
  static isInstance(obj) {
    return super.isInstance(obj) && obj.type === "generic";
  }
  get _printableFields() {
    return {
      ...super._printableFields,
      role: this.role
    };
  }
};
var ChatMessageChunk = class extends BaseMessageChunk {
  constructor(fields, role) {
    if (typeof fields === "string" || Array.isArray(fields)) fields = {
      content: fields,
      role
    };
    super(fields);
    __publicField2(this, "type", "generic");
    __publicField2(this, "role");
    this.role = fields.role;
  }
  static lc_name() {
    return "ChatMessageChunk";
  }
  concat(chunk) {
    const Cls = this.constructor;
    return new Cls({
      content: mergeContent(this.content, chunk.content),
      additional_kwargs: _mergeDicts(this.additional_kwargs, chunk.additional_kwargs),
      response_metadata: _mergeDicts(this.response_metadata, chunk.response_metadata),
      role: this.role,
      id: this.id ?? chunk.id
    });
  }
  static isInstance(obj) {
    return super.isInstance(obj) && obj.type === "generic";
  }
  get _printableFields() {
    return {
      ...super._printableFields,
      role: this.role
    };
  }
};
function isChatMessage(x) {
  return x._getType() === "generic";
}
function isChatMessageChunk(x) {
  return x._getType() === "generic";
}
var FunctionMessage = class extends BaseMessage {
  constructor(fields) {
    super(fields);
    __publicField2(this, "type", "function");
    __publicField2(this, "name");
    this.name = fields.name;
  }
  static lc_name() {
    return "FunctionMessage";
  }
};
var FunctionMessageChunk = class extends BaseMessageChunk {
  constructor() {
    super(...arguments);
    __publicField2(this, "type", "function");
  }
  static lc_name() {
    return "FunctionMessageChunk";
  }
  concat(chunk) {
    const Cls = this.constructor;
    return new Cls({
      content: mergeContent(this.content, chunk.content),
      additional_kwargs: _mergeDicts(this.additional_kwargs, chunk.additional_kwargs),
      response_metadata: _mergeDicts(this.response_metadata, chunk.response_metadata),
      name: this.name ?? "",
      id: this.id ?? chunk.id
    });
  }
};
function isFunctionMessage(x) {
  return x._getType() === "function";
}
function isFunctionMessageChunk(x) {
  return x._getType() === "function";
}
var HumanMessage = class extends BaseMessage {
  constructor(fields) {
    super(fields);
    __publicField2(this, "type", "human");
  }
  static lc_name() {
    return "HumanMessage";
  }
  static isInstance(obj) {
    return super.isInstance(obj) && obj.type === "human";
  }
};
var HumanMessageChunk = class extends BaseMessageChunk {
  constructor(fields) {
    super(fields);
    __publicField2(this, "type", "human");
  }
  static lc_name() {
    return "HumanMessageChunk";
  }
  concat(chunk) {
    const Cls = this.constructor;
    return new Cls({
      content: mergeContent(this.content, chunk.content),
      additional_kwargs: _mergeDicts(this.additional_kwargs, chunk.additional_kwargs),
      response_metadata: _mergeDicts(this.response_metadata, chunk.response_metadata),
      id: this.id ?? chunk.id
    });
  }
  static isInstance(obj) {
    return super.isInstance(obj) && obj.type === "human";
  }
};
function isHumanMessage(x) {
  return x.getType() === "human";
}
function isHumanMessageChunk(x) {
  return x.getType() === "human";
}
var RemoveMessage = class extends BaseMessage {
  constructor(fields) {
    super({
      ...fields,
      content: []
    });
    __publicField2(this, "type", "remove");
    /**
    * The ID of the message to remove.
    */
    __publicField2(this, "id");
    this.id = fields.id;
  }
  get _printableFields() {
    return {
      ...super._printableFields,
      id: this.id
    };
  }
  static isInstance(obj) {
    return super.isInstance(obj) && obj.type === "remove";
  }
};
var SystemMessage = class SystemMessage2 extends BaseMessage {
  constructor(fields) {
    super(fields);
    __publicField2(this, "type", "system");
  }
  static lc_name() {
    return "SystemMessage";
  }
  /**
  * Concatenates a string or another system message with the current system message.
  * @param chunk - The chunk to concatenate with the system message.
  * @returns A new system message with the concatenated content.
  */
  concat(chunk) {
    if (typeof chunk === "string") return new SystemMessage2({
      ...this,
      content: mergeContent(this.content, chunk)
    });
    if (SystemMessage2.isInstance(chunk)) return new SystemMessage2({
      ...this,
      additional_kwargs: {
        ...this.additional_kwargs,
        ...chunk.additional_kwargs
      },
      response_metadata: {
        ...this.response_metadata,
        ...chunk.response_metadata
      },
      content: mergeContent(this.content, chunk.content)
    });
    throw new Error("Unexpected chunk type for system message");
  }
  static isInstance(obj) {
    return super.isInstance(obj) && obj.type === "system";
  }
};
var SystemMessageChunk = class extends BaseMessageChunk {
  constructor(fields) {
    super(fields);
    __publicField2(this, "type", "system");
  }
  static lc_name() {
    return "SystemMessageChunk";
  }
  concat(chunk) {
    const Cls = this.constructor;
    return new Cls({
      content: mergeContent(this.content, chunk.content),
      additional_kwargs: _mergeDicts(this.additional_kwargs, chunk.additional_kwargs),
      response_metadata: _mergeDicts(this.response_metadata, chunk.response_metadata),
      id: this.id ?? chunk.id
    });
  }
  static isInstance(obj) {
    return super.isInstance(obj) && obj.type === "system";
  }
};
function isSystemMessage(x) {
  return x._getType() === "system";
}
function isSystemMessageChunk(x) {
  return x._getType() === "system";
}
function addLangChainErrorFields(error, lc_error_code) {
  error.lc_error_code = lc_error_code;
  error.message = `${error.message}

Troubleshooting URL: https://docs.langchain.com/oss/javascript/langchain/errors/${lc_error_code}/
`;
  return error;
}
function _isToolCall(toolCall) {
  return !!(toolCall && typeof toolCall === "object" && "type" in toolCall && toolCall.type === "tool_call");
}
function _configHasToolCallId(config2) {
  return !!(config2 && typeof config2 === "object" && "toolCall" in config2 && config2.toolCall != null && typeof config2.toolCall === "object" && "id" in config2.toolCall && typeof config2.toolCall.id === "string");
}
var ToolInputParsingException = class extends Error {
  constructor(message, output) {
    super(message);
    __publicField2(this, "output");
    this.output = output;
  }
};
function parseJsonMarkdown(s, parser = parsePartialJson) {
  s = s.trim();
  const firstFenceIndex = s.indexOf("```");
  if (firstFenceIndex === -1) return parser(s);
  let contentAfterFence = s.substring(firstFenceIndex + 3);
  if (contentAfterFence.startsWith("json\n")) contentAfterFence = contentAfterFence.substring(5);
  else if (contentAfterFence.startsWith("json")) contentAfterFence = contentAfterFence.substring(4);
  else if (contentAfterFence.startsWith("\n")) contentAfterFence = contentAfterFence.substring(1);
  const closingFenceIndex = contentAfterFence.indexOf("```");
  let finalContent = contentAfterFence;
  if (closingFenceIndex !== -1) finalContent = contentAfterFence.substring(0, closingFenceIndex);
  return parser(finalContent.trim());
}
function strictParsePartialJson(s) {
  try {
    return JSON.parse(s);
  } catch {
  }
  const buffer = s.trim();
  if (buffer.length === 0) throw new Error("Unexpected end of JSON input");
  let pos = 0;
  function skipWhitespace() {
    while (pos < buffer.length && /\s/.test(buffer[pos])) pos += 1;
  }
  function parseString() {
    if (buffer[pos] !== '"') throw new Error(`Expected '"' at position ${pos}, got '${buffer[pos]}'`);
    pos += 1;
    let result = "";
    let escaped = false;
    while (pos < buffer.length) {
      const char = buffer[pos];
      if (escaped) {
        if (char === "n") result += "\n";
        else if (char === "t") result += "	";
        else if (char === "r") result += "\r";
        else if (char === "\\") result += "\\";
        else if (char === '"') result += '"';
        else if (char === "b") result += "\b";
        else if (char === "f") result += "\f";
        else if (char === "/") result += "/";
        else if (char === "u") {
          const hex = buffer.substring(pos + 1, pos + 5);
          if (/^[0-9A-Fa-f]{0,4}$/.test(hex)) {
            if (hex.length === 4) result += String.fromCharCode(Number.parseInt(hex, 16));
            else result += `u${hex}`;
            pos += hex.length;
          } else throw new Error(`Invalid unicode escape sequence '\\u${hex}' at position ${pos}`);
        } else throw new Error(`Invalid escape sequence '\\${char}' at position ${pos}`);
        escaped = false;
      } else if (char === "\\") escaped = true;
      else if (char === '"') {
        pos += 1;
        return result;
      } else result += char;
      pos += 1;
    }
    if (escaped) result += "\\";
    return result;
  }
  function parseNumber() {
    const start = pos;
    let numStr = "";
    if (buffer[pos] === "-") {
      numStr += "-";
      pos += 1;
    }
    if (pos < buffer.length && buffer[pos] === "0") {
      numStr += "0";
      pos += 1;
      if (buffer[pos] >= "0" && buffer[pos] <= "9") throw new Error(`Invalid number at position ${start}`);
    }
    if (pos < buffer.length && buffer[pos] >= "1" && buffer[pos] <= "9") while (pos < buffer.length && buffer[pos] >= "0" && buffer[pos] <= "9") {
      numStr += buffer[pos];
      pos += 1;
    }
    if (pos < buffer.length && buffer[pos] === ".") {
      numStr += ".";
      pos += 1;
      while (pos < buffer.length && buffer[pos] >= "0" && buffer[pos] <= "9") {
        numStr += buffer[pos];
        pos += 1;
      }
    }
    if (pos < buffer.length && (buffer[pos] === "e" || buffer[pos] === "E")) {
      numStr += buffer[pos];
      pos += 1;
      if (pos < buffer.length && (buffer[pos] === "+" || buffer[pos] === "-")) {
        numStr += buffer[pos];
        pos += 1;
      }
      while (pos < buffer.length && buffer[pos] >= "0" && buffer[pos] <= "9") {
        numStr += buffer[pos];
        pos += 1;
      }
    }
    if (numStr === "-") return -0;
    const num = Number.parseFloat(numStr);
    if (Number.isNaN(num)) {
      pos = start;
      throw new Error(`Invalid number '${numStr}' at position ${start}`);
    }
    return num;
  }
  function parseValue() {
    skipWhitespace();
    if (pos >= buffer.length) throw new Error(`Unexpected end of input at position ${pos}`);
    const char = buffer[pos];
    if (char === "{") return parseObject();
    if (char === "[") return parseArray();
    if (char === '"') return parseString();
    if ("null".startsWith(buffer.substring(pos, pos + 4))) {
      pos += Math.min(4, buffer.length - pos);
      return null;
    }
    if ("true".startsWith(buffer.substring(pos, pos + 4))) {
      pos += Math.min(4, buffer.length - pos);
      return true;
    }
    if ("false".startsWith(buffer.substring(pos, pos + 5))) {
      pos += Math.min(5, buffer.length - pos);
      return false;
    }
    if (char === "-" || char >= "0" && char <= "9") return parseNumber();
    throw new Error(`Unexpected character '${char}' at position ${pos}`);
  }
  function parseArray() {
    if (buffer[pos] !== "[") throw new Error(`Expected '[' at position ${pos}, got '${buffer[pos]}'`);
    const arr2 = [];
    pos += 1;
    skipWhitespace();
    if (pos >= buffer.length) return arr2;
    if (buffer[pos] === "]") {
      pos += 1;
      return arr2;
    }
    while (pos < buffer.length) {
      skipWhitespace();
      if (pos >= buffer.length) return arr2;
      arr2.push(parseValue());
      skipWhitespace();
      if (pos >= buffer.length) return arr2;
      if (buffer[pos] === "]") {
        pos += 1;
        return arr2;
      } else if (buffer[pos] === ",") {
        pos += 1;
        continue;
      }
      throw new Error(`Expected ',' or ']' at position ${pos}, got '${buffer[pos]}'`);
    }
    return arr2;
  }
  function parseObject() {
    if (buffer[pos] !== "{") throw new Error(`Expected '{' at position ${pos}, got '${buffer[pos]}'`);
    const obj = {};
    pos += 1;
    skipWhitespace();
    if (pos >= buffer.length) return obj;
    if (buffer[pos] === "}") {
      pos += 1;
      return obj;
    }
    while (pos < buffer.length) {
      skipWhitespace();
      if (pos >= buffer.length) return obj;
      const key = parseString();
      skipWhitespace();
      if (pos >= buffer.length) return obj;
      if (buffer[pos] !== ":") throw new Error(`Expected ':' at position ${pos}, got '${buffer[pos]}'`);
      pos += 1;
      skipWhitespace();
      if (pos >= buffer.length) return obj;
      obj[key] = parseValue();
      skipWhitespace();
      if (pos >= buffer.length) return obj;
      if (buffer[pos] === "}") {
        pos += 1;
        return obj;
      } else if (buffer[pos] === ",") {
        pos += 1;
        continue;
      }
      throw new Error(`Expected ',' or '}' at position ${pos}, got '${buffer[pos]}'`);
    }
    return obj;
  }
  const value = parseValue();
  skipWhitespace();
  if (pos < buffer.length) throw new Error(`Unexpected character '${buffer[pos]}' at position ${pos}`);
  return value;
}
function parsePartialJson(s) {
  try {
    if (typeof s === "undefined") return null;
    return strictParsePartialJson(s);
  } catch {
    return null;
  }
}
function convertFileFormatToMimeType(format2) {
  switch (format2) {
    case "csv":
      return "text/csv";
    case "doc":
      return "application/vnd.openxmlformats-officedocument.wordprocessingml.document";
    case "docx":
      return "application/vnd.openxmlformats-officedocument.wordprocessingml.document";
    case "html":
      return "text/html";
    case "md":
      return "text/markdown";
    case "pdf":
      return "application/pdf";
    case "txt":
      return "text/plain";
    case "xls":
      return "application/vnd.ms-excel";
    case "xlsx":
      return "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet";
    case "gif":
      return "image/gif";
    case "jpeg":
      return "image/jpeg";
    case "jpg":
      return "image/jpeg";
    case "png":
      return "image/png";
    case "webp":
      return "image/webp";
    case "flv":
      return "video/flv";
    case "mkv":
      return "video/mkv";
    case "mov":
      return "video/mov";
    case "mp4":
      return "video/mp4";
    case "mpeg":
      return "video/mpeg";
    case "mpg":
      return "video/mpg";
    case "three_gp":
      return "video/three_gp";
    case "webm":
      return "video/webm";
    case "wmv":
      return "video/wmv";
    default:
      return "application/octet-stream";
  }
}
function convertConverseDocumentBlock(block) {
  if (_isObject(block.document) && _isObject(block.document.source)) {
    const format2 = _isObject(block.document) && _isString(block.document.format) ? block.document.format : "";
    const mimeType = convertFileFormatToMimeType(format2);
    if (_isObject(block.document.source)) {
      if (_isObject(block.document.source.s3Location) && _isString(block.document.source.s3Location.uri)) return {
        type: "file",
        mimeType,
        fileId: block.document.source.s3Location.uri
      };
      if (_isBytesArray(block.document.source.bytes)) return {
        type: "file",
        mimeType,
        data: block.document.source.bytes
      };
      if (_isString(block.document.source.text)) return {
        type: "file",
        mimeType,
        data: Buffer.from(block.document.source.text).toString("base64")
      };
      if (_isArray(block.document.source.content)) {
        const data = block.document.source.content.reduce((acc, item) => {
          if (_isObject(item) && _isString(item.text)) return acc + item.text;
          return acc;
        }, "");
        return {
          type: "file",
          mimeType,
          data
        };
      }
    }
  }
  return {
    type: "non_standard",
    value: block
  };
}
function convertConverseImageBlock(block) {
  if (_isContentBlock(block, "image") && _isObject(block.image)) {
    const format2 = _isObject(block.image) && _isString(block.image.format) ? block.image.format : "";
    const mimeType = convertFileFormatToMimeType(format2);
    if (_isObject(block.image.source)) {
      if (_isObject(block.image.source.s3Location) && _isString(block.image.source.s3Location.uri)) return {
        type: "image",
        mimeType,
        fileId: block.image.source.s3Location.uri
      };
      if (_isBytesArray(block.image.source.bytes)) return {
        type: "image",
        mimeType,
        data: block.image.source.bytes
      };
    }
  }
  return {
    type: "non_standard",
    value: block
  };
}
function convertConverseVideoBlock(block) {
  if (_isContentBlock(block, "video") && _isObject(block.video)) {
    const format2 = _isObject(block.video) && _isString(block.video.format) ? block.video.format : "";
    const mimeType = convertFileFormatToMimeType(format2);
    if (_isObject(block.video.source)) {
      if (_isObject(block.video.source.s3Location) && _isString(block.video.source.s3Location.uri)) return {
        type: "video",
        mimeType,
        fileId: block.video.source.s3Location.uri
      };
      if (_isBytesArray(block.video.source.bytes)) return {
        type: "video",
        mimeType,
        data: block.video.source.bytes
      };
    }
  }
  return {
    type: "non_standard",
    value: block
  };
}
function convertToV1FromChatBedrockConverseMessage(message) {
  function* iterateContent() {
    const content = typeof message.content === "string" ? [{
      type: "text",
      text: message.content
    }] : message.content;
    for (const block of content) {
      if (_isContentBlock(block, "cache_point")) {
        yield {
          type: "non_standard",
          value: block
        };
        continue;
      } else if (_isContentBlock(block, "citations_content") && _isObject(block.citationsContent)) {
        const text = _isArray(block.citationsContent.content) ? block.citationsContent.content.reduce((acc, item) => {
          if (_isObject(item) && _isString(item.text)) return acc + item.text;
          return acc;
        }, "") : "";
        const annotations = _isArray(block.citationsContent.citations) ? block.citationsContent.citations.reduce((acc, item) => {
          if (_isObject(item)) {
            const citedText = _isArray(item.sourceContent) ? item.sourceContent.reduce((acc$1, item$1) => {
              if (_isObject(item$1) && _isString(item$1.text)) return acc$1 + item$1.text;
              return acc$1;
            }, "") : "";
            const properties = iife$3(() => {
              if (_isObject(item.location)) {
                const location2 = item.location.documentChar || item.location.documentPage || item.location.documentChunk;
                if (_isObject(location2)) return {
                  source: _isNumber(location2.documentIndex) ? location2.documentIndex.toString() : void 0,
                  startIndex: _isNumber(location2.start) ? location2.start : void 0,
                  endIndex: _isNumber(location2.end) ? location2.end : void 0
                };
              }
              return {};
            });
            acc.push({
              type: "citation",
              citedText,
              ...properties
            });
          }
          return acc;
        }, []) : [];
        yield {
          type: "text",
          text,
          annotations
        };
        continue;
      } else if (_isContentBlock(block, "document") && _isObject(block.document)) {
        yield convertConverseDocumentBlock(block);
        continue;
      } else if (_isContentBlock(block, "guard_content")) {
        yield {
          type: "non_standard",
          value: block
        };
        continue;
      } else if (_isContentBlock(block, "image") && _isObject(block.image)) {
        yield convertConverseImageBlock(block);
        continue;
      } else if (_isContentBlock(block, "reasoning_content") && _isString(block.reasoningText)) {
        yield {
          type: "reasoning",
          reasoning: block.reasoningText
        };
        continue;
      } else if (_isContentBlock(block, "text") && _isString(block.text)) {
        yield {
          type: "text",
          text: block.text
        };
        continue;
      } else if (_isContentBlock(block, "tool_result")) {
        yield {
          type: "non_standard",
          value: block
        };
        continue;
      } else if (_isContentBlock(block, "tool_call")) continue;
      else if (_isContentBlock(block, "video") && _isObject(block.video)) {
        yield convertConverseVideoBlock(block);
        continue;
      }
      yield {
        type: "non_standard",
        value: block
      };
    }
  }
  return Array.from(iterateContent());
}
const ChatBedrockConverseTranslator = {
  translateContent: convertToV1FromChatBedrockConverseMessage,
  translateContentChunk: convertToV1FromChatBedrockConverseMessage
};
function convertToV1FromChatGoogleMessage(message) {
  function* iterateContent() {
    const content = typeof message.content === "string" ? [{
      type: "text",
      text: message.content
    }] : message.content;
    for (const block of content) {
      if (_isContentBlock(block, "text") && _isString(block.text)) {
        yield {
          type: "text",
          text: block.text
        };
        continue;
      } else if (_isContentBlock(block, "inlineData") && _isObject(block.inlineData) && _isString(block.inlineData.mimeType) && _isString(block.inlineData.data)) {
        yield {
          type: "file",
          mimeType: block.inlineData.mimeType,
          data: block.inlineData.data
        };
        continue;
      } else if (_isContentBlock(block, "functionCall") && _isObject(block.functionCall) && _isString(block.functionCall.name) && _isObject(block.functionCall.args)) {
        yield {
          type: "tool_call",
          id: message.id,
          name: block.functionCall.name,
          args: block.functionCall.args
        };
        continue;
      } else if (_isContentBlock(block, "functionResponse")) {
        yield {
          type: "non_standard",
          value: block
        };
        continue;
      } else if (_isContentBlock(block, "fileData") && _isObject(block.fileData) && _isString(block.fileData.mimeType) && _isString(block.fileData.fileUri)) {
        yield {
          type: "file",
          mimeType: block.fileData.mimeType,
          fileId: block.fileData.fileUri
        };
        continue;
      } else if (_isContentBlock(block, "executableCode")) {
        yield {
          type: "non_standard",
          value: block
        };
        continue;
      } else if (_isContentBlock(block, "codeExecutionResult")) {
        yield {
          type: "non_standard",
          value: block
        };
        continue;
      }
      yield {
        type: "non_standard",
        value: block
      };
    }
  }
  return Array.from(iterateContent());
}
const ChatGoogleGenAITranslator = {
  translateContent: convertToV1FromChatGoogleMessage,
  translateContentChunk: convertToV1FromChatGoogleMessage
};
function convertToV1FromChatVertexMessage(message) {
  function* iterateContent() {
    const content = typeof message.content === "string" ? [{
      type: "text",
      text: message.content
    }] : message.content;
    for (const block of content) {
      if (_isContentBlock(block, "reasoning") && _isString(block.reasoning)) {
        const signature = iife$3(() => {
          var _a3;
          const reasoningIndex = content.indexOf(block);
          if (_isArray((_a3 = message.additional_kwargs) == null ? void 0 : _a3.signatures) && reasoningIndex >= 0) return message.additional_kwargs.signatures.at(reasoningIndex);
          return void 0;
        });
        if (_isString(signature)) yield {
          type: "reasoning",
          reasoning: block.reasoning,
          signature
        };
        else yield {
          type: "reasoning",
          reasoning: block.reasoning
        };
        continue;
      } else if (_isContentBlock(block, "text") && _isString(block.text)) {
        yield {
          type: "text",
          text: block.text
        };
        continue;
      } else if (_isContentBlock(block, "image_url")) {
        if (_isString(block.image_url)) if (block.image_url.startsWith("data:")) {
          const dataUrlRegex = /^data:([^;]+);base64,(.+)$/;
          const match = block.image_url.match(dataUrlRegex);
          if (match) yield {
            type: "image",
            data: match[2],
            mimeType: match[1]
          };
          else yield {
            type: "image",
            url: block.image_url
          };
        } else yield {
          type: "image",
          url: block.image_url
        };
        continue;
      } else if (_isContentBlock(block, "media") && _isString(block.mimeType) && _isString(block.data)) {
        yield {
          type: "file",
          mimeType: block.mimeType,
          data: block.data
        };
        continue;
      }
      yield {
        type: "non_standard",
        value: block
      };
    }
  }
  return Array.from(iterateContent());
}
const ChatVertexTranslator = {
  translateContent: convertToV1FromChatVertexMessage,
  translateContentChunk: convertToV1FromChatVertexMessage
};
globalThis.lc_block_translators_registry ?? (globalThis.lc_block_translators_registry = /* @__PURE__ */ new Map([
  ["anthropic", ChatAnthropicTranslator],
  ["bedrock-converse", ChatBedrockConverseTranslator],
  ["google-genai", ChatGoogleGenAITranslator],
  ["google-vertexai", ChatVertexTranslator],
  ["openai", ChatOpenAITranslator]
]));
function getTranslator(modelProvider) {
  return globalThis.lc_block_translators_registry.get(modelProvider);
}
var AIMessage = class extends BaseMessage {
  constructor(fields) {
    var _a3;
    let initParams;
    if (typeof fields === "string" || Array.isArray(fields)) initParams = {
      content: fields,
      tool_calls: [],
      invalid_tool_calls: [],
      additional_kwargs: {}
    };
    else {
      initParams = fields;
      const rawToolCalls = (_a3 = initParams.additional_kwargs) == null ? void 0 : _a3.tool_calls;
      const toolCalls = initParams.tool_calls;
      if (!(rawToolCalls == null) && rawToolCalls.length > 0 && (toolCalls === void 0 || toolCalls.length === 0)) console.warn([
        "New LangChain packages are available that more efficiently handle",
        "tool calling.\n\nPlease upgrade your packages to versions that set",
        "message tool calls. e.g., `pnpm install @langchain/anthropic`,",
        "pnpm install @langchain/openai`, etc."
      ].join(" "));
      try {
        if (!(rawToolCalls == null) && toolCalls === void 0) {
          const [toolCalls$1, invalidToolCalls] = defaultToolCallParser(rawToolCalls);
          initParams.tool_calls = toolCalls$1 ?? [];
          initParams.invalid_tool_calls = invalidToolCalls ?? [];
        } else {
          initParams.tool_calls = initParams.tool_calls ?? [];
          initParams.invalid_tool_calls = initParams.invalid_tool_calls ?? [];
        }
      } catch {
        initParams.tool_calls = [];
        initParams.invalid_tool_calls = [];
      }
      if (initParams.response_metadata !== void 0 && "output_version" in initParams.response_metadata && initParams.response_metadata.output_version === "v1") {
        initParams.contentBlocks = initParams.content;
        initParams.content = void 0;
      }
      if (initParams.contentBlocks !== void 0) {
        initParams.contentBlocks.push(...initParams.tool_calls.map((toolCall) => ({
          type: "tool_call",
          id: toolCall.id,
          name: toolCall.name,
          args: toolCall.args
        })));
        const missingToolCalls = initParams.contentBlocks.filter((block) => block.type === "tool_call").filter((block) => {
          var _a4;
          return !((_a4 = initParams.tool_calls) == null ? void 0 : _a4.some((toolCall) => toolCall.id === block.id && toolCall.name === block.name));
        });
        if (missingToolCalls.length > 0) initParams.tool_calls = missingToolCalls.map((block) => ({
          type: "tool_call",
          id: block.id,
          name: block.name,
          args: block.args
        }));
      }
    }
    super(initParams);
    __publicField2(this, "type", "ai");
    __publicField2(this, "tool_calls", []);
    __publicField2(this, "invalid_tool_calls", []);
    __publicField2(this, "usage_metadata");
    if (typeof initParams !== "string") {
      this.tool_calls = initParams.tool_calls ?? this.tool_calls;
      this.invalid_tool_calls = initParams.invalid_tool_calls ?? this.invalid_tool_calls;
    }
    this.usage_metadata = initParams.usage_metadata;
  }
  get lc_aliases() {
    return {
      ...super.lc_aliases,
      tool_calls: "tool_calls",
      invalid_tool_calls: "invalid_tool_calls"
    };
  }
  static lc_name() {
    return "AIMessage";
  }
  get contentBlocks() {
    if (this.response_metadata && "output_version" in this.response_metadata && this.response_metadata.output_version === "v1") return this.content;
    if (this.response_metadata && "model_provider" in this.response_metadata && typeof this.response_metadata.model_provider === "string") {
      const translator = getTranslator(this.response_metadata.model_provider);
      if (translator) return translator.translateContent(this);
    }
    const blocks2 = super.contentBlocks;
    if (this.tool_calls) {
      const missingToolCalls = this.tool_calls.filter((block) => !blocks2.some((b) => b.id === block.id && b.name === block.name));
      blocks2.push(...missingToolCalls.map((block) => ({
        ...block,
        type: "tool_call",
        id: block.id,
        name: block.name,
        args: block.args
      })));
    }
    return blocks2;
  }
  get _printableFields() {
    return {
      ...super._printableFields,
      tool_calls: this.tool_calls,
      invalid_tool_calls: this.invalid_tool_calls,
      usage_metadata: this.usage_metadata
    };
  }
  static isInstance(obj) {
    return super.isInstance(obj) && obj.type === "ai";
  }
};
function isAIMessage(x) {
  return x._getType() === "ai";
}
function isAIMessageChunk(x) {
  return x._getType() === "ai";
}
var AIMessageChunk = class extends BaseMessageChunk {
  constructor(fields) {
    let initParams;
    if (typeof fields === "string" || Array.isArray(fields)) initParams = {
      content: fields,
      tool_calls: [],
      invalid_tool_calls: [],
      tool_call_chunks: []
    };
    else if (fields.tool_call_chunks === void 0 || fields.tool_call_chunks.length === 0) initParams = {
      ...fields,
      tool_calls: fields.tool_calls ?? [],
      invalid_tool_calls: [],
      tool_call_chunks: [],
      usage_metadata: fields.usage_metadata !== void 0 ? fields.usage_metadata : void 0
    };
    else initParams = {
      ...fields,
      ...collapseToolCallChunks(fields.tool_call_chunks ?? []),
      usage_metadata: fields.usage_metadata !== void 0 ? fields.usage_metadata : void 0
    };
    super(initParams);
    __publicField2(this, "type", "ai");
    __publicField2(this, "tool_calls", []);
    __publicField2(this, "invalid_tool_calls", []);
    __publicField2(this, "tool_call_chunks", []);
    __publicField2(this, "usage_metadata");
    this.tool_call_chunks = initParams.tool_call_chunks ?? this.tool_call_chunks;
    this.tool_calls = initParams.tool_calls ?? this.tool_calls;
    this.invalid_tool_calls = initParams.invalid_tool_calls ?? this.invalid_tool_calls;
    this.usage_metadata = initParams.usage_metadata;
  }
  get lc_aliases() {
    return {
      ...super.lc_aliases,
      tool_calls: "tool_calls",
      invalid_tool_calls: "invalid_tool_calls",
      tool_call_chunks: "tool_call_chunks"
    };
  }
  static lc_name() {
    return "AIMessageChunk";
  }
  get contentBlocks() {
    if (this.response_metadata && "output_version" in this.response_metadata && this.response_metadata.output_version === "v1") return this.content;
    if (this.response_metadata && "model_provider" in this.response_metadata && typeof this.response_metadata.model_provider === "string") {
      const translator = getTranslator(this.response_metadata.model_provider);
      if (translator) return translator.translateContent(this);
    }
    const blocks2 = super.contentBlocks;
    if (this.tool_calls) {
      if (typeof this.content !== "string") {
        const contentToolCalls = this.content.filter((block) => block.type === "tool_call").map((block) => block.id);
        for (const toolCall of this.tool_calls) if (toolCall.id && !contentToolCalls.includes(toolCall.id)) blocks2.push({
          ...toolCall,
          type: "tool_call",
          id: toolCall.id,
          name: toolCall.name,
          args: toolCall.args
        });
      }
    }
    return blocks2;
  }
  get _printableFields() {
    return {
      ...super._printableFields,
      tool_calls: this.tool_calls,
      tool_call_chunks: this.tool_call_chunks,
      invalid_tool_calls: this.invalid_tool_calls,
      usage_metadata: this.usage_metadata
    };
  }
  concat(chunk) {
    const combinedFields = {
      content: mergeContent(this.content, chunk.content),
      additional_kwargs: _mergeDicts(this.additional_kwargs, chunk.additional_kwargs),
      response_metadata: mergeResponseMetadata(this.response_metadata, chunk.response_metadata),
      tool_call_chunks: [],
      id: this.id ?? chunk.id
    };
    if (this.tool_call_chunks !== void 0 || chunk.tool_call_chunks !== void 0) {
      const rawToolCalls = _mergeLists(this.tool_call_chunks, chunk.tool_call_chunks);
      if (rawToolCalls !== void 0 && rawToolCalls.length > 0) combinedFields.tool_call_chunks = rawToolCalls;
    }
    if (this.usage_metadata !== void 0 || chunk.usage_metadata !== void 0) combinedFields.usage_metadata = mergeUsageMetadata(this.usage_metadata, chunk.usage_metadata);
    const Cls = this.constructor;
    return new Cls(combinedFields);
  }
  static isInstance(obj) {
    return super.isInstance(obj) && obj.type === "ai";
  }
};
const iife$2 = (fn) => fn();
function _coerceToolCall(toolCall) {
  if (_isToolCall(toolCall)) return toolCall;
  else if (typeof toolCall.id === "string" && toolCall.type === "function" && typeof toolCall.function === "object" && toolCall.function !== null && "arguments" in toolCall.function && typeof toolCall.function.arguments === "string" && "name" in toolCall.function && typeof toolCall.function.name === "string") return {
    id: toolCall.id,
    args: JSON.parse(toolCall.function.arguments),
    name: toolCall.function.name,
    type: "tool_call"
  };
  else return toolCall;
}
function isSerializedConstructor(x) {
  return typeof x === "object" && x != null && x.lc === 1 && Array.isArray(x.id) && x.kwargs != null && typeof x.kwargs === "object";
}
function _constructMessageFromParams(params) {
  let type;
  let rest;
  if (isSerializedConstructor(params)) {
    const className = params.id.at(-1);
    if (className === "HumanMessage" || className === "HumanMessageChunk") type = "user";
    else if (className === "AIMessage" || className === "AIMessageChunk") type = "assistant";
    else if (className === "SystemMessage" || className === "SystemMessageChunk") type = "system";
    else if (className === "FunctionMessage" || className === "FunctionMessageChunk") type = "function";
    else if (className === "ToolMessage" || className === "ToolMessageChunk") type = "tool";
    else type = "unknown";
    rest = params.kwargs;
  } else {
    const { type: extractedType, ...otherParams } = params;
    type = extractedType;
    rest = otherParams;
  }
  if (type === "human" || type === "user") return new HumanMessage(rest);
  else if (type === "ai" || type === "assistant") {
    const { tool_calls: rawToolCalls, ...other } = rest;
    if (!Array.isArray(rawToolCalls)) return new AIMessage(rest);
    const tool_calls = rawToolCalls.map(_coerceToolCall);
    return new AIMessage({
      ...other,
      tool_calls
    });
  } else if (type === "system") return new SystemMessage(rest);
  else if (type === "developer") return new SystemMessage({
    ...rest,
    additional_kwargs: {
      ...rest.additional_kwargs,
      __openai_role__: "developer"
    }
  });
  else if (type === "tool" && "tool_call_id" in rest) return new ToolMessage({
    ...rest,
    content: rest.content,
    tool_call_id: rest.tool_call_id,
    name: rest.name
  });
  else if (type === "remove" && "id" in rest && typeof rest.id === "string") return new RemoveMessage({
    ...rest,
    id: rest.id
  });
  else {
    const error = addLangChainErrorFields(/* @__PURE__ */ new Error(`Unable to coerce message from array: only human, AI, system, developer, or tool message coercion is currently supported.

Received: ${JSON.stringify(params, null, 2)}`), "MESSAGE_COERCION_FAILURE");
    throw error;
  }
}
function coerceMessageLikeToMessage(messageLike) {
  if (typeof messageLike === "string") return new HumanMessage(messageLike);
  else if (isBaseMessage(messageLike)) return messageLike;
  if (Array.isArray(messageLike)) {
    const [type, content] = messageLike;
    return _constructMessageFromParams({
      type,
      content
    });
  } else if (_isMessageFieldWithRole(messageLike)) {
    const { role: type, ...rest } = messageLike;
    return _constructMessageFromParams({
      ...rest,
      type
    });
  } else return _constructMessageFromParams(messageLike);
}
function getBufferString(messages, humanPrefix = "Human", aiPrefix = "AI") {
  const string_messages = [];
  for (const m of messages) {
    let role;
    if (m._getType() === "human") role = humanPrefix;
    else if (m._getType() === "ai") role = aiPrefix;
    else if (m._getType() === "system") role = "System";
    else if (m._getType() === "tool") role = "Tool";
    else if (m._getType() === "generic") role = m.role;
    else throw new Error(`Got unsupported message type: ${m._getType()}`);
    const nameStr = m.name ? `${m.name}, ` : "";
    const readableContent = typeof m.content === "string" ? m.content : JSON.stringify(m.content, null, 2);
    string_messages.push(`${role}: ${nameStr}${readableContent}`);
  }
  return string_messages.join("\n");
}
function mapV1MessageToStoredMessage(message) {
  if (message.data !== void 0) return message;
  else {
    const v1Message = message;
    return {
      type: v1Message.type,
      data: {
        content: v1Message.text,
        role: v1Message.role,
        name: void 0,
        tool_call_id: void 0
      }
    };
  }
}
function mapStoredMessageToChatMessage(message) {
  const storedMessage = mapV1MessageToStoredMessage(message);
  switch (storedMessage.type) {
    case "human":
      return new HumanMessage(storedMessage.data);
    case "ai":
      return new AIMessage(storedMessage.data);
    case "system":
      return new SystemMessage(storedMessage.data);
    case "function":
      if (storedMessage.data.name === void 0) throw new Error("Name must be defined for function messages");
      return new FunctionMessage(storedMessage.data);
    case "tool":
      if (storedMessage.data.tool_call_id === void 0) throw new Error("Tool call ID must be defined for tool messages");
      return new ToolMessage(storedMessage.data);
    case "generic":
      if (storedMessage.data.role === void 0) throw new Error("Role must be defined for chat messages");
      return new ChatMessage(storedMessage.data);
    default:
      throw new Error(`Got unexpected type: ${storedMessage.type}`);
  }
}
function mapStoredMessagesToChatMessages(messages) {
  return messages.map(mapStoredMessageToChatMessage);
}
function mapChatMessagesToStoredMessages(messages) {
  return messages.map((message) => message.toDict());
}
function convertToChunk(message) {
  var _a3;
  const type = message._getType();
  if (type === "human") return new HumanMessageChunk({ ...message });
  else if (type === "ai") {
    let aiChunkFields = { ...message };
    if ("tool_calls" in aiChunkFields) aiChunkFields = {
      ...aiChunkFields,
      tool_call_chunks: (_a3 = aiChunkFields.tool_calls) == null ? void 0 : _a3.map((tc) => ({
        ...tc,
        type: "tool_call_chunk",
        index: void 0,
        args: JSON.stringify(tc.args)
      }))
    };
    return new AIMessageChunk({ ...aiChunkFields });
  } else if (type === "system") return new SystemMessageChunk({ ...message });
  else if (type === "function") return new FunctionMessageChunk({ ...message });
  else if (ChatMessage.isInstance(message)) return new ChatMessageChunk({ ...message });
  else throw new Error("Unknown message type.");
}
function collapseToolCallChunks(chunks) {
  var _a3, _b;
  const groupedToolCallChunks = chunks.reduce((acc, chunk) => {
    const matchedChunkIndex = acc.findIndex(([match]) => {
      if ("id" in chunk && chunk.id && "index" in chunk && chunk.index !== void 0) return chunk.id === match.id && chunk.index === match.index;
      if ("id" in chunk && chunk.id) return chunk.id === match.id;
      if ("index" in chunk && chunk.index !== void 0) return chunk.index === match.index;
      return false;
    });
    if (matchedChunkIndex !== -1) acc[matchedChunkIndex].push(chunk);
    else acc.push([chunk]);
    return acc;
  }, []);
  const toolCalls = [];
  const invalidToolCalls = [];
  for (const chunks$1 of groupedToolCallChunks) {
    let parsedArgs = null;
    const name = ((_a3 = chunks$1[0]) == null ? void 0 : _a3.name) ?? "";
    const joinedArgs = chunks$1.map((c) => c.args || "").join("").trim();
    const argsStr = joinedArgs.length ? joinedArgs : "{}";
    const id = (_b = chunks$1[0]) == null ? void 0 : _b.id;
    try {
      parsedArgs = parsePartialJson(argsStr);
      if (!id || parsedArgs === null || typeof parsedArgs !== "object" || Array.isArray(parsedArgs)) throw new Error("Malformed tool call chunk args.");
      toolCalls.push({
        name,
        args: parsedArgs,
        id,
        type: "tool_call"
      });
    } catch {
      invalidToolCalls.push({
        name,
        args: argsStr,
        id,
        error: "Malformed args.",
        type: "invalid_tool_call"
      });
    }
  }
  return {
    tool_call_chunks: chunks,
    tool_calls: toolCalls,
    invalid_tool_calls: invalidToolCalls
  };
}
const TRACING_ALS_KEY$1 = Symbol.for("ls:tracing_async_local_storage");
const _CONTEXT_VARIABLES_KEY = Symbol.for("lc:context_variables");
const setGlobalAsyncLocalStorageInstance = (instance) => {
  globalThis[TRACING_ALS_KEY$1] = instance;
};
const getGlobalAsyncLocalStorageInstance = () => {
  return globalThis[TRACING_ALS_KEY$1];
};
var env_exports = {};
__export(env_exports, {
  getEnv: () => getEnv$1,
  getEnvironmentVariable: () => getEnvironmentVariable$1,
  getRuntimeEnvironment: () => getRuntimeEnvironment$1,
  isBrowser: () => isBrowser$1,
  isDeno: () => isDeno$1,
  isJsDom: () => isJsDom$1,
  isNode: () => isNode$1,
  isWebWorker: () => isWebWorker$1
});
const isBrowser$1 = () => typeof window !== "undefined" && typeof window.document !== "undefined";
const isWebWorker$1 = () => typeof globalThis === "object" && globalThis.constructor && globalThis.constructor.name === "DedicatedWorkerGlobalScope";
const isJsDom$1 = () => typeof window !== "undefined" && window.name === "nodejs" || typeof navigator !== "undefined" && navigator.userAgent.includes("jsdom");
const isDeno$1 = () => typeof Deno !== "undefined";
const isNode$1 = () => typeof process !== "undefined" && typeof process.versions !== "undefined" && typeof process.versions.node !== "undefined" && !isDeno$1();
const getEnv$1 = () => {
  let env;
  if (isBrowser$1()) env = "browser";
  else if (isNode$1()) env = "node";
  else if (isWebWorker$1()) env = "webworker";
  else if (isJsDom$1()) env = "jsdom";
  else if (isDeno$1()) env = "deno";
  else env = "other";
  return env;
};
let runtimeEnvironment$1;
function getRuntimeEnvironment$1() {
  if (runtimeEnvironment$1 === void 0) {
    const env = getEnv$1();
    runtimeEnvironment$1 = {
      library: "langchain-js",
      runtime: env
    };
  }
  return runtimeEnvironment$1;
}
function getEnvironmentVariable$1(name) {
  var _a3;
  try {
    if (typeof process !== "undefined") return (_a3 = process.env) == null ? void 0 : _a3[name];
    else if (isDeno$1()) return Deno == null ? void 0 : Deno.env.get(name);
    else return void 0;
  } catch {
    return void 0;
  }
}
const REGEX$1 = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i;
function validate$3(uuid2) {
  return typeof uuid2 === "string" && REGEX$1.test(uuid2);
}
const byteToHex$1 = [];
for (let i2 = 0; i2 < 256; ++i2) {
  byteToHex$1.push((i2 + 256).toString(16).slice(1));
}
function unsafeStringify$1(arr2, offset = 0) {
  return (byteToHex$1[arr2[offset + 0]] + byteToHex$1[arr2[offset + 1]] + byteToHex$1[arr2[offset + 2]] + byteToHex$1[arr2[offset + 3]] + "-" + byteToHex$1[arr2[offset + 4]] + byteToHex$1[arr2[offset + 5]] + "-" + byteToHex$1[arr2[offset + 6]] + byteToHex$1[arr2[offset + 7]] + "-" + byteToHex$1[arr2[offset + 8]] + byteToHex$1[arr2[offset + 9]] + "-" + byteToHex$1[arr2[offset + 10]] + byteToHex$1[arr2[offset + 11]] + byteToHex$1[arr2[offset + 12]] + byteToHex$1[arr2[offset + 13]] + byteToHex$1[arr2[offset + 14]] + byteToHex$1[arr2[offset + 15]]).toLowerCase();
}
const rnds8Pool$1 = new Uint8Array(256);
let poolPtr$1 = rnds8Pool$1.length;
function rng$1() {
  if (poolPtr$1 > rnds8Pool$1.length - 16) {
    crypto$2.randomFillSync(rnds8Pool$1);
    poolPtr$1 = 0;
  }
  return rnds8Pool$1.slice(poolPtr$1, poolPtr$1 += 16);
}
const native$1 = {
  randomUUID: crypto$2.randomUUID
};
function v4$1(options2, buf, offset) {
  if (native$1.randomUUID && true && !options2) {
    return native$1.randomUUID();
  }
  options2 = options2 || {};
  const rnds = options2.random || (options2.rng || rng$1)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  return unsafeStringify$1(rnds);
}
var base_exports$2 = {};
__export(base_exports$2, {
  BaseCallbackHandler: () => BaseCallbackHandler,
  callbackHandlerPrefersStreaming: () => callbackHandlerPrefersStreaming,
  isBaseCallbackHandler: () => isBaseCallbackHandler
});
var BaseCallbackHandlerMethodsClass = class {
};
function callbackHandlerPrefersStreaming(x) {
  return "lc_prefer_streaming" in x && x.lc_prefer_streaming;
}
var BaseCallbackHandler = class extends BaseCallbackHandlerMethodsClass {
  constructor(input) {
    super();
    __publicField2(this, "lc_serializable", false);
    __publicField2(this, "lc_kwargs");
    __publicField2(this, "ignoreLLM", false);
    __publicField2(this, "ignoreChain", false);
    __publicField2(this, "ignoreAgent", false);
    __publicField2(this, "ignoreRetriever", false);
    __publicField2(this, "ignoreCustomEvent", false);
    __publicField2(this, "raiseError", false);
    __publicField2(this, "awaitHandlers", getEnvironmentVariable$1("LANGCHAIN_CALLBACKS_BACKGROUND") === "false");
    this.lc_kwargs = input || {};
    if (input) {
      this.ignoreLLM = input.ignoreLLM ?? this.ignoreLLM;
      this.ignoreChain = input.ignoreChain ?? this.ignoreChain;
      this.ignoreAgent = input.ignoreAgent ?? this.ignoreAgent;
      this.ignoreRetriever = input.ignoreRetriever ?? this.ignoreRetriever;
      this.ignoreCustomEvent = input.ignoreCustomEvent ?? this.ignoreCustomEvent;
      this.raiseError = input.raiseError ?? this.raiseError;
      this.awaitHandlers = this.raiseError || (input._awaitHandler ?? this.awaitHandlers);
    }
  }
  get lc_namespace() {
    return [
      "langchain_core",
      "callbacks",
      this.name
    ];
  }
  get lc_secrets() {
    return void 0;
  }
  get lc_attributes() {
    return void 0;
  }
  get lc_aliases() {
    return void 0;
  }
  get lc_serializable_keys() {
    return void 0;
  }
  /**
  * The name of the serializable. Override to provide an alias or
  * to preserve the serialized module name in minified environments.
  *
  * Implemented as a static method to support loading logic.
  */
  static lc_name() {
    return this.name;
  }
  /**
  * The final serialized identifier for the module.
  */
  get lc_id() {
    return [...this.lc_namespace, get_lc_unique_name(this.constructor)];
  }
  copy() {
    return new this.constructor(this);
  }
  toJSON() {
    return Serializable.prototype.toJSON.call(this);
  }
  toJSONNotImplemented() {
    return Serializable.prototype.toJSONNotImplemented.call(this);
  }
  static fromMethods(methods) {
    class Handler extends BaseCallbackHandler {
      constructor() {
        super();
        __publicField2(this, "name", v4$1());
        Object.assign(this, methods);
      }
    }
    return new Handler();
  }
};
const isBaseCallbackHandler = (x) => {
  const callbackHandler = x;
  return callbackHandler !== void 0 && typeof callbackHandler.copy === "function" && typeof callbackHandler.name === "string" && typeof callbackHandler.awaitHandlers === "boolean";
};
const REGEX = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i;
function validate$2(uuid2) {
  return typeof uuid2 === "string" && REGEX.test(uuid2);
}
function parse$3(uuid2) {
  if (!validate$2(uuid2)) {
    throw TypeError("Invalid UUID");
  }
  let v;
  const arr2 = new Uint8Array(16);
  arr2[0] = (v = parseInt(uuid2.slice(0, 8), 16)) >>> 24;
  arr2[1] = v >>> 16 & 255;
  arr2[2] = v >>> 8 & 255;
  arr2[3] = v & 255;
  arr2[4] = (v = parseInt(uuid2.slice(9, 13), 16)) >>> 8;
  arr2[5] = v & 255;
  arr2[6] = (v = parseInt(uuid2.slice(14, 18), 16)) >>> 8;
  arr2[7] = v & 255;
  arr2[8] = (v = parseInt(uuid2.slice(19, 23), 16)) >>> 8;
  arr2[9] = v & 255;
  arr2[10] = (v = parseInt(uuid2.slice(24, 36), 16)) / 1099511627776 & 255;
  arr2[11] = v / 4294967296 & 255;
  arr2[12] = v >>> 24 & 255;
  arr2[13] = v >>> 16 & 255;
  arr2[14] = v >>> 8 & 255;
  arr2[15] = v & 255;
  return arr2;
}
const byteToHex = [];
for (let i2 = 0; i2 < 256; ++i2) {
  byteToHex.push((i2 + 256).toString(16).slice(1));
}
function unsafeStringify(arr2, offset = 0) {
  return (byteToHex[arr2[offset + 0]] + byteToHex[arr2[offset + 1]] + byteToHex[arr2[offset + 2]] + byteToHex[arr2[offset + 3]] + "-" + byteToHex[arr2[offset + 4]] + byteToHex[arr2[offset + 5]] + "-" + byteToHex[arr2[offset + 6]] + byteToHex[arr2[offset + 7]] + "-" + byteToHex[arr2[offset + 8]] + byteToHex[arr2[offset + 9]] + "-" + byteToHex[arr2[offset + 10]] + byteToHex[arr2[offset + 11]] + byteToHex[arr2[offset + 12]] + byteToHex[arr2[offset + 13]] + byteToHex[arr2[offset + 14]] + byteToHex[arr2[offset + 15]]).toLowerCase();
}
const rnds8Pool = new Uint8Array(256);
let poolPtr = rnds8Pool.length;
function rng() {
  if (poolPtr > rnds8Pool.length - 16) {
    crypto$2.randomFillSync(rnds8Pool);
    poolPtr = 0;
  }
  return rnds8Pool.slice(poolPtr, poolPtr += 16);
}
function stringToBytes(str2) {
  str2 = unescape(encodeURIComponent(str2));
  const bytes = [];
  for (let i2 = 0; i2 < str2.length; ++i2) {
    bytes.push(str2.charCodeAt(i2));
  }
  return bytes;
}
const DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
const URL$1 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
function v35(name, version2, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    var _namespace;
    if (typeof value === "string") {
      value = stringToBytes(value);
    }
    if (typeof namespace === "string") {
      namespace = parse$3(namespace);
    }
    if (((_namespace = namespace) === null || _namespace === void 0 ? void 0 : _namespace.length) !== 16) {
      throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
    }
    let bytes = new Uint8Array(16 + value.length);
    bytes.set(namespace);
    bytes.set(value, namespace.length);
    bytes = hashfunc(bytes);
    bytes[6] = bytes[6] & 15 | version2;
    bytes[8] = bytes[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (let i2 = 0; i2 < 16; ++i2) {
        buf[offset + i2] = bytes[i2];
      }
      return buf;
    }
    return unsafeStringify(bytes);
  }
  try {
    generateUUID.name = name;
  } catch (err) {
  }
  generateUUID.DNS = DNS;
  generateUUID.URL = URL$1;
  return generateUUID;
}
const native = {
  randomUUID: crypto$2.randomUUID
};
function v4(options2, buf, offset) {
  if (native.randomUUID && true && !options2) {
    return native.randomUUID();
  }
  options2 = options2 || {};
  const rnds = options2.random || (options2.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  return unsafeStringify(rnds);
}
function sha1(bytes) {
  if (Array.isArray(bytes)) {
    bytes = Buffer.from(bytes);
  } else if (typeof bytes === "string") {
    bytes = Buffer.from(bytes, "utf8");
  }
  return crypto$2.createHash("sha1").update(bytes).digest();
}
const v5 = v35("v5", 80, sha1);
let _seqLow = null;
let _seqHigh = null;
let _msecs = 0;
function v7(options2, buf, offset) {
  options2 = options2 || {};
  let i2 = 0;
  const b = new Uint8Array(16);
  const rnds = options2.random || (options2.rng || rng)();
  const msecs = options2.msecs !== void 0 ? options2.msecs : Date.now();
  let seq = options2.seq !== void 0 ? options2.seq : null;
  let seqHigh = _seqHigh;
  let seqLow = _seqLow;
  if (msecs > _msecs && options2.msecs === void 0) {
    _msecs = msecs;
    if (seq !== null) {
      seqHigh = null;
      seqLow = null;
    }
  }
  if (seq !== null) {
    if (seq > 2147483647) {
      seq = 2147483647;
    }
    seqHigh = seq >>> 19 & 4095;
    seqLow = seq & 524287;
  }
  if (seqHigh === null || seqLow === null) {
    seqHigh = rnds[6] & 127;
    seqHigh = seqHigh << 8 | rnds[7];
    seqLow = rnds[8] & 63;
    seqLow = seqLow << 8 | rnds[9];
    seqLow = seqLow << 5 | rnds[10] >>> 3;
  }
  if (msecs + 1e4 > _msecs && seq === null) {
    if (++seqLow > 524287) {
      seqLow = 0;
      if (++seqHigh > 4095) {
        seqHigh = 0;
        _msecs++;
      }
    }
  } else {
    _msecs = msecs;
  }
  _seqHigh = seqHigh;
  _seqLow = seqLow;
  b[i2++] = _msecs / 1099511627776 & 255;
  b[i2++] = _msecs / 4294967296 & 255;
  b[i2++] = _msecs / 16777216 & 255;
  b[i2++] = _msecs / 65536 & 255;
  b[i2++] = _msecs / 256 & 255;
  b[i2++] = _msecs & 255;
  b[i2++] = seqHigh >>> 4 & 15 | 112;
  b[i2++] = seqHigh & 255;
  b[i2++] = seqLow >>> 13 & 63 | 128;
  b[i2++] = seqLow >>> 5 & 255;
  b[i2++] = seqLow << 3 & 255 | rnds[10] & 7;
  b[i2++] = rnds[11];
  b[i2++] = rnds[12];
  b[i2++] = rnds[13];
  b[i2++] = rnds[14];
  b[i2++] = rnds[15];
  return buf || unsafeStringify(b);
}
const GEN_AI_OPERATION_NAME = "gen_ai.operation.name";
const GEN_AI_SYSTEM = "gen_ai.system";
const GEN_AI_REQUEST_MODEL = "gen_ai.request.model";
const GEN_AI_RESPONSE_MODEL = "gen_ai.response.model";
const GEN_AI_USAGE_INPUT_TOKENS = "gen_ai.usage.input_tokens";
const GEN_AI_USAGE_OUTPUT_TOKENS = "gen_ai.usage.output_tokens";
const GEN_AI_USAGE_TOTAL_TOKENS = "gen_ai.usage.total_tokens";
const GEN_AI_REQUEST_MAX_TOKENS = "gen_ai.request.max_tokens";
const GEN_AI_REQUEST_TEMPERATURE = "gen_ai.request.temperature";
const GEN_AI_REQUEST_TOP_P = "gen_ai.request.top_p";
const GEN_AI_REQUEST_FREQUENCY_PENALTY = "gen_ai.request.frequency_penalty";
const GEN_AI_REQUEST_PRESENCE_PENALTY = "gen_ai.request.presence_penalty";
const GEN_AI_RESPONSE_FINISH_REASONS = "gen_ai.response.finish_reasons";
const GENAI_PROMPT = "gen_ai.prompt";
const GENAI_COMPLETION = "gen_ai.completion";
const GEN_AI_REQUEST_EXTRA_QUERY = "gen_ai.request.extra_query";
const GEN_AI_REQUEST_EXTRA_BODY = "gen_ai.request.extra_body";
const GEN_AI_SERIALIZED_NAME = "gen_ai.serialized.name";
const GEN_AI_SERIALIZED_SIGNATURE = "gen_ai.serialized.signature";
const GEN_AI_SERIALIZED_DOC = "gen_ai.serialized.doc";
const GEN_AI_RESPONSE_ID = "gen_ai.response.id";
const GEN_AI_RESPONSE_SERVICE_TIER = "gen_ai.response.service_tier";
const GEN_AI_RESPONSE_SYSTEM_FINGERPRINT = "gen_ai.response.system_fingerprint";
const GEN_AI_USAGE_INPUT_TOKEN_DETAILS = "gen_ai.usage.input_token_details";
const GEN_AI_USAGE_OUTPUT_TOKEN_DETAILS = "gen_ai.usage.output_token_details";
const LANGSMITH_SESSION_ID = "langsmith.trace.session_id";
const LANGSMITH_SESSION_NAME = "langsmith.trace.session_name";
const LANGSMITH_RUN_TYPE = "langsmith.span.kind";
const LANGSMITH_NAME = "langsmith.trace.name";
const LANGSMITH_METADATA = "langsmith.metadata";
const LANGSMITH_TAGS = "langsmith.span.tags";
const LANGSMITH_REQUEST_STREAMING = "langsmith.request.streaming";
const LANGSMITH_REQUEST_HEADERS = "langsmith.request.headers";
const DEFAULT_FETCH_IMPLEMENTATION = (...args) => fetch(...args);
const LANGSMITH_FETCH_IMPLEMENTATION_KEY = Symbol.for("ls:fetch_implementation");
const _globalFetchImplementationIsNodeFetch = () => {
  const fetchImpl = globalThis[LANGSMITH_FETCH_IMPLEMENTATION_KEY];
  if (!fetchImpl)
    return false;
  return typeof fetchImpl === "function" && "Headers" in fetchImpl && "Request" in fetchImpl && "Response" in fetchImpl;
};
const _getFetchImplementation = (debug2) => {
  return async (...args) => {
    if (debug2 || getLangSmithEnvironmentVariable("DEBUG") === "true") {
      const [url, options2] = args;
      console.log(`â†’ ${(options2 == null ? void 0 : options2.method) || "GET"} ${url}`);
    }
    const res = await (globalThis[LANGSMITH_FETCH_IMPLEMENTATION_KEY] ?? DEFAULT_FETCH_IMPLEMENTATION)(...args);
    if (debug2 || getLangSmithEnvironmentVariable("DEBUG") === "true") {
      console.log(`â† ${res.status} ${res.statusText} ${res.url}`);
    }
    return res;
  };
};
const getDefaultProjectName = () => {
  return getLangSmithEnvironmentVariable("PROJECT") ?? getEnvironmentVariable("LANGCHAIN_SESSION") ?? // TODO: Deprecate
  "default";
};
const warnedMessages = {};
function warnOnce(message) {
  if (!warnedMessages[message]) {
    console.warn(message);
    warnedMessages[message] = true;
  }
}
const UUID_REGEX = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
function assertUuid(str2, which) {
  if (!UUID_REGEX.test(str2)) {
    const msg = which !== void 0 ? `Invalid UUID for ${which}: ${str2}` : `Invalid UUID: ${str2}`;
    throw new Error(msg);
  }
  return str2;
}
function uuid7FromTime(timestamp) {
  const msecs = typeof timestamp === "string" ? Date.parse(timestamp) : timestamp;
  return v7({ msecs, seq: 0 });
}
const __version__ = "0.3.84";
let globalEnv;
const isBrowser = () => typeof window !== "undefined" && typeof window.document !== "undefined";
const isWebWorker = () => typeof globalThis === "object" && globalThis.constructor && globalThis.constructor.name === "DedicatedWorkerGlobalScope";
const isJsDom = () => typeof window !== "undefined" && window.name === "nodejs" || typeof navigator !== "undefined" && navigator.userAgent.includes("jsdom");
const isDeno = () => typeof Deno !== "undefined";
const isNode = () => typeof process !== "undefined" && typeof process.versions !== "undefined" && typeof process.versions.node !== "undefined" && !isDeno();
const getEnv = () => {
  if (globalEnv) {
    return globalEnv;
  }
  if (typeof Bun !== "undefined") {
    globalEnv = "bun";
  } else if (isBrowser()) {
    globalEnv = "browser";
  } else if (isNode()) {
    globalEnv = "node";
  } else if (isWebWorker()) {
    globalEnv = "webworker";
  } else if (isJsDom()) {
    globalEnv = "jsdom";
  } else if (isDeno()) {
    globalEnv = "deno";
  } else {
    globalEnv = "other";
  }
  return globalEnv;
};
let runtimeEnvironment;
function getRuntimeEnvironment() {
  if (runtimeEnvironment === void 0) {
    const env = getEnv();
    const releaseEnv = getShas();
    runtimeEnvironment = {
      library: "langsmith",
      runtime: env,
      sdk: "langsmith-js",
      sdk_version: __version__,
      ...releaseEnv
    };
  }
  return runtimeEnvironment;
}
function getLangSmithEnvVarsMetadata() {
  const allEnvVars = getLangSmithEnvironmentVariables();
  const envVars = {};
  const excluded = [
    "LANGCHAIN_API_KEY",
    "LANGCHAIN_ENDPOINT",
    "LANGCHAIN_TRACING_V2",
    "LANGCHAIN_PROJECT",
    "LANGCHAIN_SESSION",
    "LANGSMITH_API_KEY",
    "LANGSMITH_ENDPOINT",
    "LANGSMITH_TRACING_V2",
    "LANGSMITH_PROJECT",
    "LANGSMITH_SESSION"
  ];
  for (const [key, value] of Object.entries(allEnvVars)) {
    if (typeof value === "string" && !excluded.includes(key) && !key.toLowerCase().includes("key") && !key.toLowerCase().includes("secret") && !key.toLowerCase().includes("token")) {
      if (key === "LANGCHAIN_REVISION_ID") {
        envVars["revision_id"] = value;
      } else {
        envVars[key] = value;
      }
    }
  }
  return envVars;
}
function getLangSmithEnvironmentVariables() {
  const envVars = {};
  try {
    if (typeof process !== "undefined" && process.env) {
      for (const [key, value] of Object.entries(process.env)) {
        if ((key.startsWith("LANGCHAIN_") || key.startsWith("LANGSMITH_")) && value != null) {
          if ((key.toLowerCase().includes("key") || key.toLowerCase().includes("secret") || key.toLowerCase().includes("token")) && typeof value === "string") {
            envVars[key] = value.slice(0, 2) + "*".repeat(value.length - 4) + value.slice(-2);
          } else {
            envVars[key] = value;
          }
        }
      }
    }
  } catch (e) {
  }
  return envVars;
}
function getEnvironmentVariable(name) {
  var _a3;
  try {
    return typeof process !== "undefined" ? (
      // eslint-disable-next-line no-process-env
      (_a3 = process.env) == null ? void 0 : _a3[name]
    ) : void 0;
  } catch (e) {
    return void 0;
  }
}
function getLangSmithEnvironmentVariable(name) {
  return getEnvironmentVariable(`LANGSMITH_${name}`) || getEnvironmentVariable(`LANGCHAIN_${name}`);
}
let cachedCommitSHAs;
function getShas() {
  if (cachedCommitSHAs !== void 0) {
    return cachedCommitSHAs;
  }
  const common_release_envs = [
    "VERCEL_GIT_COMMIT_SHA",
    "NEXT_PUBLIC_VERCEL_GIT_COMMIT_SHA",
    "COMMIT_REF",
    "RENDER_GIT_COMMIT",
    "CI_COMMIT_SHA",
    "CIRCLE_SHA1",
    "CF_PAGES_COMMIT_SHA",
    "REACT_APP_GIT_SHA",
    "SOURCE_VERSION",
    "GITHUB_SHA",
    "TRAVIS_COMMIT",
    "GIT_COMMIT",
    "BUILD_VCS_NUMBER",
    "bamboo_planRepository_revision",
    "Build.SourceVersion",
    "BITBUCKET_COMMIT",
    "DRONE_COMMIT_SHA",
    "SEMAPHORE_GIT_SHA",
    "BUILDKITE_COMMIT"
  ];
  const shas = {};
  for (const env of common_release_envs) {
    const envVar = getEnvironmentVariable(env);
    if (envVar !== void 0) {
      shas[env] = envVar;
    }
  }
  cachedCommitSHAs = shas;
  return shas;
}
function getOtelEnabled() {
  return getEnvironmentVariable("OTEL_ENABLED") === "true" || getLangSmithEnvironmentVariable("OTEL_ENABLED") === "true";
}
class MockTracer {
  constructor() {
    Object.defineProperty(this, "hasWarned", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: false
    });
  }
  startActiveSpan(_name, ...args) {
    if (!this.hasWarned && getOtelEnabled()) {
      console.warn('You have enabled OTEL export via the `OTEL_ENABLED` or `LANGSMITH_OTEL_ENABLED` environment variable, but have not initialized the required OTEL instances. Please add:\n```\nimport { initializeOTEL } from "langsmith/experimental/otel/setup";\ninitializeOTEL();\n```\nat the beginning of your code.');
      this.hasWarned = true;
    }
    let fn;
    if (args.length === 1 && typeof args[0] === "function") {
      fn = args[0];
    } else if (args.length === 2 && typeof args[1] === "function") {
      fn = args[1];
    } else if (args.length === 3 && typeof args[2] === "function") {
      fn = args[2];
    }
    if (typeof fn === "function") {
      return fn();
    }
    return void 0;
  }
}
class MockOTELTrace {
  constructor() {
    Object.defineProperty(this, "mockTracer", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: new MockTracer()
    });
  }
  getTracer(_name, _version) {
    return this.mockTracer;
  }
  getActiveSpan() {
    return void 0;
  }
  setSpan(context, _span) {
    return context;
  }
  getSpan(_context) {
    return void 0;
  }
  setSpanContext(context, _spanContext) {
    return context;
  }
  getTracerProvider() {
    return void 0;
  }
  setGlobalTracerProvider(_tracerProvider) {
    return false;
  }
}
class MockOTELContext {
  active() {
    return {};
  }
  with(_context, fn) {
    return fn();
  }
}
const OTEL_TRACE_KEY = Symbol.for("ls:otel_trace");
const OTEL_CONTEXT_KEY = Symbol.for("ls:otel_context");
const OTEL_GET_DEFAULT_OTLP_TRACER_PROVIDER_KEY = Symbol.for("ls:otel_get_default_otlp_tracer_provider");
const mockOTELTrace = new MockOTELTrace();
const mockOTELContext = new MockOTELContext();
class OTELProvider {
  getTraceInstance() {
    return globalThis[OTEL_TRACE_KEY] ?? mockOTELTrace;
  }
  getContextInstance() {
    return globalThis[OTEL_CONTEXT_KEY] ?? mockOTELContext;
  }
  initializeGlobalInstances(otel) {
    if (globalThis[OTEL_TRACE_KEY] === void 0) {
      globalThis[OTEL_TRACE_KEY] = otel.trace;
    }
    if (globalThis[OTEL_CONTEXT_KEY] === void 0) {
      globalThis[OTEL_CONTEXT_KEY] = otel.context;
    }
  }
  setDefaultOTLPTracerComponents(components) {
    globalThis[OTEL_GET_DEFAULT_OTLP_TRACER_PROVIDER_KEY] = components;
  }
  getDefaultOTLPTracerComponents() {
    return globalThis[OTEL_GET_DEFAULT_OTLP_TRACER_PROVIDER_KEY] ?? void 0;
  }
}
const OTELProviderSingleton = new OTELProvider();
function getOTELTrace() {
  return OTELProviderSingleton.getTraceInstance();
}
function getOTELContext() {
  return OTELProviderSingleton.getContextInstance();
}
function getDefaultOTLPTracerComponents() {
  return OTELProviderSingleton.getDefaultOTLPTracerComponents();
}
const WELL_KNOWN_OPERATION_NAMES = {
  llm: "chat",
  tool: "execute_tool",
  retriever: "embeddings",
  embedding: "embeddings",
  prompt: "chat"
};
function getOperationName(runType) {
  return WELL_KNOWN_OPERATION_NAMES[runType] || runType;
}
class LangSmithToOTELTranslator {
  constructor() {
    Object.defineProperty(this, "spans", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: /* @__PURE__ */ new Map()
    });
  }
  exportBatch(operations, otelContextMap) {
    for (const op of operations) {
      try {
        if (!op.run) {
          continue;
        }
        if (op.operation === "post") {
          const span = this.createSpanForRun(op, op.run, otelContextMap.get(op.id));
          if (span && !op.run.end_time) {
            this.spans.set(op.id, span);
          }
        } else {
          this.updateSpanForRun(op, op.run);
        }
      } catch (e) {
        console.error(`Error processing operation ${op.id}:`, e);
      }
    }
  }
  createSpanForRun(op, runInfo, otelContext) {
    const activeSpan = otelContext && getOTELTrace().getSpan(otelContext);
    if (!activeSpan) {
      return;
    }
    try {
      return this.finishSpanSetup(activeSpan, runInfo, op);
    } catch (e) {
      console.error(`Failed to create span for run ${op.id}:`, e);
      return void 0;
    }
  }
  finishSpanSetup(span, runInfo, op) {
    this.setSpanAttributes(span, runInfo, op);
    if (runInfo.error) {
      span.setStatus({ code: 2 });
      span.recordException(new Error(runInfo.error));
    } else {
      span.setStatus({ code: 1 });
    }
    if (runInfo.end_time) {
      span.end(new Date(runInfo.end_time));
    }
    return span;
  }
  updateSpanForRun(op, runInfo) {
    try {
      const span = this.spans.get(op.id);
      if (!span) {
        console.debug(`No span found for run ${op.id} during update`);
        return;
      }
      this.setSpanAttributes(span, runInfo, op);
      if (runInfo.error) {
        span.setStatus({ code: 2 });
        span.recordException(new Error(runInfo.error));
      } else {
        span.setStatus({ code: 1 });
      }
      const endTime = runInfo.end_time;
      if (endTime) {
        span.end(new Date(endTime));
        this.spans.delete(op.id);
      }
    } catch (e) {
      console.error(`Failed to update span for run ${op.id}:`, e);
    }
  }
  extractModelName(runInfo) {
    var _a3;
    if ((_a3 = runInfo.extra) == null ? void 0 : _a3.metadata) {
      const metadata = runInfo.extra.metadata;
      if (metadata.ls_model_name) {
        return metadata.ls_model_name;
      }
      if (metadata.invocation_params) {
        const invocationParams = metadata.invocation_params;
        if (invocationParams.model) {
          return invocationParams.model;
        } else if (invocationParams.model_name) {
          return invocationParams.model_name;
        }
      }
    }
    return;
  }
  setSpanAttributes(span, runInfo, op) {
    var _a3;
    if ("run_type" in runInfo && runInfo.run_type) {
      span.setAttribute(LANGSMITH_RUN_TYPE, runInfo.run_type);
      const operationName = getOperationName(runInfo.run_type || "chain");
      span.setAttribute(GEN_AI_OPERATION_NAME, operationName);
    }
    if ("name" in runInfo && runInfo.name) {
      span.setAttribute(LANGSMITH_NAME, runInfo.name);
    }
    if ("session_id" in runInfo && runInfo.session_id) {
      span.setAttribute(LANGSMITH_SESSION_ID, runInfo.session_id);
    }
    if ("session_name" in runInfo && runInfo.session_name) {
      span.setAttribute(LANGSMITH_SESSION_NAME, runInfo.session_name);
    }
    this.setGenAiSystem(span, runInfo);
    const modelName = this.extractModelName(runInfo);
    if (modelName) {
      span.setAttribute(GEN_AI_REQUEST_MODEL, modelName);
    }
    if ("prompt_tokens" in runInfo && typeof runInfo.prompt_tokens === "number") {
      span.setAttribute(GEN_AI_USAGE_INPUT_TOKENS, runInfo.prompt_tokens);
    }
    if ("completion_tokens" in runInfo && typeof runInfo.completion_tokens === "number") {
      span.setAttribute(GEN_AI_USAGE_OUTPUT_TOKENS, runInfo.completion_tokens);
    }
    if ("total_tokens" in runInfo && typeof runInfo.total_tokens === "number") {
      span.setAttribute(GEN_AI_USAGE_TOTAL_TOKENS, runInfo.total_tokens);
    }
    this.setInvocationParameters(span, runInfo);
    const metadata = ((_a3 = runInfo.extra) == null ? void 0 : _a3.metadata) || {};
    for (const [key, value] of Object.entries(metadata)) {
      if (value !== null && value !== void 0) {
        span.setAttribute(`${LANGSMITH_METADATA}.${key}`, String(value));
      }
    }
    const tags = runInfo.tags;
    if (tags && Array.isArray(tags)) {
      span.setAttribute(LANGSMITH_TAGS, tags.join(", "));
    } else if (tags) {
      span.setAttribute(LANGSMITH_TAGS, String(tags));
    }
    if ("serialized" in runInfo && typeof runInfo.serialized === "object") {
      const serialized = runInfo.serialized;
      if (serialized.name) {
        span.setAttribute(GEN_AI_SERIALIZED_NAME, String(serialized.name));
      }
      if (serialized.signature) {
        span.setAttribute(GEN_AI_SERIALIZED_SIGNATURE, String(serialized.signature));
      }
      if (serialized.doc) {
        span.setAttribute(GEN_AI_SERIALIZED_DOC, String(serialized.doc));
      }
    }
    this.setIOAttributes(span, op);
  }
  setGenAiSystem(span, runInfo) {
    let system = "langchain";
    const modelName = this.extractModelName(runInfo);
    if (modelName) {
      const modelLower = modelName.toLowerCase();
      if (modelLower.includes("anthropic") || modelLower.startsWith("claude")) {
        system = "anthropic";
      } else if (modelLower.includes("bedrock")) {
        system = "aws.bedrock";
      } else if (modelLower.includes("azure") && modelLower.includes("openai")) {
        system = "az.ai.openai";
      } else if (modelLower.includes("azure") && modelLower.includes("inference")) {
        system = "az.ai.inference";
      } else if (modelLower.includes("cohere")) {
        system = "cohere";
      } else if (modelLower.includes("deepseek")) {
        system = "deepseek";
      } else if (modelLower.includes("gemini")) {
        system = "gemini";
      } else if (modelLower.includes("groq")) {
        system = "groq";
      } else if (modelLower.includes("watson") || modelLower.includes("ibm")) {
        system = "ibm.watsonx.ai";
      } else if (modelLower.includes("mistral")) {
        system = "mistral_ai";
      } else if (modelLower.includes("gpt") || modelLower.includes("openai")) {
        system = "openai";
      } else if (modelLower.includes("perplexity") || modelLower.includes("sonar")) {
        system = "perplexity";
      } else if (modelLower.includes("vertex")) {
        system = "vertex_ai";
      } else if (modelLower.includes("xai") || modelLower.includes("grok")) {
        system = "xai";
      }
    }
    span.setAttribute(GEN_AI_SYSTEM, system);
  }
  setInvocationParameters(span, runInfo) {
    var _a3, _b;
    if (!((_b = (_a3 = runInfo.extra) == null ? void 0 : _a3.metadata) == null ? void 0 : _b.invocation_params)) {
      return;
    }
    const invocationParams = runInfo.extra.metadata.invocation_params;
    if (invocationParams.max_tokens !== void 0) {
      span.setAttribute(GEN_AI_REQUEST_MAX_TOKENS, invocationParams.max_tokens);
    }
    if (invocationParams.temperature !== void 0) {
      span.setAttribute(GEN_AI_REQUEST_TEMPERATURE, invocationParams.temperature);
    }
    if (invocationParams.top_p !== void 0) {
      span.setAttribute(GEN_AI_REQUEST_TOP_P, invocationParams.top_p);
    }
    if (invocationParams.frequency_penalty !== void 0) {
      span.setAttribute(GEN_AI_REQUEST_FREQUENCY_PENALTY, invocationParams.frequency_penalty);
    }
    if (invocationParams.presence_penalty !== void 0) {
      span.setAttribute(GEN_AI_REQUEST_PRESENCE_PENALTY, invocationParams.presence_penalty);
    }
  }
  setIOAttributes(span, op) {
    if (op.run.inputs) {
      try {
        const inputs = op.run.inputs;
        if (typeof inputs === "object" && inputs !== null) {
          if (inputs.model && Array.isArray(inputs.messages)) {
            span.setAttribute(GEN_AI_REQUEST_MODEL, inputs.model);
          }
          if (inputs.stream !== void 0) {
            span.setAttribute(LANGSMITH_REQUEST_STREAMING, inputs.stream);
          }
          if (inputs.extra_headers) {
            span.setAttribute(LANGSMITH_REQUEST_HEADERS, JSON.stringify(inputs.extra_headers));
          }
          if (inputs.extra_query) {
            span.setAttribute(GEN_AI_REQUEST_EXTRA_QUERY, JSON.stringify(inputs.extra_query));
          }
          if (inputs.extra_body) {
            span.setAttribute(GEN_AI_REQUEST_EXTRA_BODY, JSON.stringify(inputs.extra_body));
          }
        }
        span.setAttribute(GENAI_PROMPT, JSON.stringify(inputs));
      } catch (e) {
        console.debug(`Failed to process inputs for run ${op.id}`, e);
      }
    }
    if (op.run.outputs) {
      try {
        const outputs = op.run.outputs;
        const tokenUsage = this.getUnifiedRunTokens(outputs);
        if (tokenUsage) {
          span.setAttribute(GEN_AI_USAGE_INPUT_TOKENS, tokenUsage[0]);
          span.setAttribute(GEN_AI_USAGE_OUTPUT_TOKENS, tokenUsage[1]);
          span.setAttribute(GEN_AI_USAGE_TOTAL_TOKENS, tokenUsage[0] + tokenUsage[1]);
        }
        if (outputs && typeof outputs === "object") {
          if (outputs.model) {
            span.setAttribute(GEN_AI_RESPONSE_MODEL, String(outputs.model));
          }
          if (outputs.id) {
            span.setAttribute(GEN_AI_RESPONSE_ID, outputs.id);
          }
          if (outputs.choices && Array.isArray(outputs.choices)) {
            const finishReasons = outputs.choices.map((choice) => choice.finish_reason).filter((reason) => reason).map(String);
            if (finishReasons.length > 0) {
              span.setAttribute(GEN_AI_RESPONSE_FINISH_REASONS, finishReasons.join(", "));
            }
          }
          if (outputs.service_tier) {
            span.setAttribute(GEN_AI_RESPONSE_SERVICE_TIER, outputs.service_tier);
          }
          if (outputs.system_fingerprint) {
            span.setAttribute(GEN_AI_RESPONSE_SYSTEM_FINGERPRINT, outputs.system_fingerprint);
          }
          if (outputs.usage_metadata && typeof outputs.usage_metadata === "object") {
            const usageMetadata = outputs.usage_metadata;
            if (usageMetadata.input_token_details) {
              span.setAttribute(GEN_AI_USAGE_INPUT_TOKEN_DETAILS, JSON.stringify(usageMetadata.input_token_details));
            }
            if (usageMetadata.output_token_details) {
              span.setAttribute(GEN_AI_USAGE_OUTPUT_TOKEN_DETAILS, JSON.stringify(usageMetadata.output_token_details));
            }
          }
        }
        span.setAttribute(GENAI_COMPLETION, JSON.stringify(outputs));
      } catch (e) {
        console.debug(`Failed to process outputs for run ${op.id}`, e);
      }
    }
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  getUnifiedRunTokens(outputs) {
    if (!outputs) {
      return null;
    }
    let tokenUsage = this.extractUnifiedRunTokens(outputs.usage_metadata);
    if (tokenUsage) {
      return tokenUsage;
    }
    const keys = Object.keys(outputs);
    for (const key of keys) {
      const haystack = outputs[key];
      if (!haystack || typeof haystack !== "object") {
        continue;
      }
      tokenUsage = this.extractUnifiedRunTokens(haystack.usage_metadata);
      if (tokenUsage) {
        return tokenUsage;
      }
      if (haystack.lc === 1 && haystack.kwargs && typeof haystack.kwargs === "object") {
        tokenUsage = this.extractUnifiedRunTokens(haystack.kwargs.usage_metadata);
        if (tokenUsage) {
          return tokenUsage;
        }
      }
    }
    const generations = outputs.generations || [];
    if (!Array.isArray(generations)) {
      return null;
    }
    const flatGenerations = Array.isArray(generations[0]) ? generations.flat() : generations;
    for (const generation of flatGenerations) {
      if (typeof generation === "object" && generation.message && typeof generation.message === "object" && generation.message.kwargs && typeof generation.message.kwargs === "object") {
        tokenUsage = this.extractUnifiedRunTokens(generation.message.kwargs.usage_metadata);
        if (tokenUsage) {
          return tokenUsage;
        }
      }
    }
    return null;
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  extractUnifiedRunTokens(outputs) {
    if (!outputs || typeof outputs !== "object") {
      return null;
    }
    if (typeof outputs.input_tokens !== "number" || typeof outputs.output_tokens !== "number") {
      return null;
    }
    return [outputs.input_tokens, outputs.output_tokens];
  }
}
const objectToString$1 = Object.prototype.toString;
const isError$1 = (value) => objectToString$1.call(value) === "[object Error]";
const errorMessages$1 = /* @__PURE__ */ new Set([
  "network error",
  // Chrome
  "Failed to fetch",
  // Chrome
  "NetworkError when attempting to fetch resource.",
  // Firefox
  "The Internet connection appears to be offline.",
  // Safari 16
  "Network request failed",
  // `cross-fetch`
  "fetch failed",
  // Undici (Node.js)
  "terminated",
  // Undici (Node.js)
  " A network error occurred.",
  // Bun (WebKit)
  "Network connection lost"
  // Cloudflare Workers (fetch)
]);
function isNetworkError$1(error) {
  const isValid2 = error && isError$1(error) && error.name === "TypeError" && typeof error.message === "string";
  if (!isValid2) {
    return false;
  }
  const { message, stack } = error;
  if (message === "Load failed") {
    return stack === void 0 || // Sentry adds its own stack trace to the fetch error, so also check for that
    "__sentry_captured__" in error;
  }
  if (message.startsWith("error sending request for url")) {
    return true;
  }
  return errorMessages$1.has(message);
}
function validateRetries$1(retries) {
  if (typeof retries === "number") {
    if (retries < 0) {
      throw new TypeError("Expected `retries` to be a non-negative number.");
    }
    if (Number.isNaN(retries)) {
      throw new TypeError("Expected `retries` to be a valid number or Infinity, got NaN.");
    }
  } else if (retries !== void 0) {
    throw new TypeError("Expected `retries` to be a number or Infinity.");
  }
}
function validateNumberOption$1(name, value, { min = 0, allowInfinity = false } = {}) {
  if (value === void 0) {
    return;
  }
  if (typeof value !== "number" || Number.isNaN(value)) {
    throw new TypeError(`Expected \`${name}\` to be a number${allowInfinity ? " or Infinity" : ""}.`);
  }
  if (!allowInfinity && !Number.isFinite(value)) {
    throw new TypeError(`Expected \`${name}\` to be a finite number.`);
  }
  if (value < min) {
    throw new TypeError(`Expected \`${name}\` to be â‰¥ ${min}.`);
  }
}
let AbortError$1 = class AbortError2 extends Error {
  constructor(message) {
    super();
    if (message instanceof Error) {
      this.originalError = message;
      ({ message } = message);
    } else {
      this.originalError = new Error(message);
      this.originalError.stack = this.stack;
    }
    this.name = "AbortError";
    this.message = message;
  }
};
function calculateDelay$1(retriesConsumed, options2) {
  const attempt = Math.max(1, retriesConsumed + 1);
  const random = options2.randomize ? Math.random() + 1 : 1;
  let timeout = Math.round(random * options2.minTimeout * options2.factor ** (attempt - 1));
  timeout = Math.min(timeout, options2.maxTimeout);
  return timeout;
}
function calculateRemainingTime$1(start, max) {
  if (!Number.isFinite(max)) {
    return max;
  }
  return max - (performance.now() - start);
}
async function onAttemptFailure$1({ error, attemptNumber, retriesConsumed, startTime: startTime2, options: options2 }) {
  var _a3, _b, _c;
  const normalizedError = error instanceof Error ? error : new TypeError(`Non-error was thrown: "${error}". You should only throw errors.`);
  if (normalizedError instanceof AbortError$1) {
    throw normalizedError.originalError;
  }
  const retriesLeft = Number.isFinite(options2.retries) ? Math.max(0, options2.retries - retriesConsumed) : options2.retries;
  const maxRetryTime = options2.maxRetryTime ?? Number.POSITIVE_INFINITY;
  const context = Object.freeze({
    error: normalizedError,
    attemptNumber,
    retriesLeft,
    retriesConsumed
  });
  await options2.onFailedAttempt(context);
  if (calculateRemainingTime$1(startTime2, maxRetryTime) <= 0) {
    throw normalizedError;
  }
  const consumeRetry = await options2.shouldConsumeRetry(context);
  const remainingTime = calculateRemainingTime$1(startTime2, maxRetryTime);
  if (remainingTime <= 0 || retriesLeft <= 0) {
    throw normalizedError;
  }
  if (normalizedError instanceof TypeError && !isNetworkError$1(normalizedError)) {
    if (consumeRetry) {
      throw normalizedError;
    }
    (_a3 = options2.signal) == null ? void 0 : _a3.throwIfAborted();
    return false;
  }
  if (!await options2.shouldRetry(context)) {
    throw normalizedError;
  }
  if (!consumeRetry) {
    (_b = options2.signal) == null ? void 0 : _b.throwIfAborted();
    return false;
  }
  const delayTime = calculateDelay$1(retriesConsumed, options2);
  const finalDelay = Math.min(delayTime, remainingTime);
  if (finalDelay > 0) {
    await new Promise((resolve, reject) => {
      var _a4, _b2;
      const onAbort = () => {
        var _a5;
        clearTimeout(timeoutToken);
        (_a5 = options2.signal) == null ? void 0 : _a5.removeEventListener("abort", onAbort);
        reject(options2.signal.reason);
      };
      const timeoutToken = setTimeout(() => {
        var _a5;
        (_a5 = options2.signal) == null ? void 0 : _a5.removeEventListener("abort", onAbort);
        resolve();
      }, finalDelay);
      if (options2.unref) {
        (_a4 = timeoutToken.unref) == null ? void 0 : _a4.call(timeoutToken);
      }
      (_b2 = options2.signal) == null ? void 0 : _b2.addEventListener("abort", onAbort, { once: true });
    });
  }
  (_c = options2.signal) == null ? void 0 : _c.throwIfAborted();
  return true;
}
async function pRetry$1(input, options2 = {}) {
  var _a3, _b, _c;
  options2 = { ...options2 };
  validateRetries$1(options2.retries);
  if (Object.hasOwn(options2, "forever")) {
    throw new Error("The `forever` option is no longer supported. For many use-cases, you can set `retries: Infinity` instead.");
  }
  options2.retries ?? (options2.retries = 10);
  options2.factor ?? (options2.factor = 2);
  options2.minTimeout ?? (options2.minTimeout = 1e3);
  options2.maxTimeout ?? (options2.maxTimeout = Number.POSITIVE_INFINITY);
  options2.maxRetryTime ?? (options2.maxRetryTime = Number.POSITIVE_INFINITY);
  options2.randomize ?? (options2.randomize = false);
  options2.onFailedAttempt ?? (options2.onFailedAttempt = () => {
  });
  options2.shouldRetry ?? (options2.shouldRetry = () => true);
  options2.shouldConsumeRetry ?? (options2.shouldConsumeRetry = () => true);
  validateNumberOption$1("factor", options2.factor, {
    min: 0,
    allowInfinity: false
  });
  validateNumberOption$1("minTimeout", options2.minTimeout, {
    min: 0,
    allowInfinity: false
  });
  validateNumberOption$1("maxTimeout", options2.maxTimeout, {
    min: 0,
    allowInfinity: true
  });
  validateNumberOption$1("maxRetryTime", options2.maxRetryTime, {
    min: 0,
    allowInfinity: true
  });
  if (!(options2.factor > 0)) {
    options2.factor = 1;
  }
  (_a3 = options2.signal) == null ? void 0 : _a3.throwIfAborted();
  let attemptNumber = 0;
  let retriesConsumed = 0;
  const startTime2 = performance.now();
  while (Number.isFinite(options2.retries) ? retriesConsumed <= options2.retries : true) {
    attemptNumber++;
    try {
      (_b = options2.signal) == null ? void 0 : _b.throwIfAborted();
      const result = await input(attemptNumber);
      (_c = options2.signal) == null ? void 0 : _c.throwIfAborted();
      return result;
    } catch (error) {
      if (await onAttemptFailure$1({
        error,
        attemptNumber,
        retriesConsumed,
        startTime: startTime2,
        options: options2
      })) {
        retriesConsumed++;
      }
    }
  }
  throw new Error("Retry attempts exhausted without throwing an error.");
}
var dist = {};
var eventemitter3 = { exports: {} };
(function(module) {
  var has2 = Object.prototype.hasOwnProperty, prefix = "~";
  function Events() {
  }
  if (Object.create) {
    Events.prototype = /* @__PURE__ */ Object.create(null);
    if (!new Events().__proto__) prefix = false;
  }
  function EE(fn, context, once) {
    this.fn = fn;
    this.context = context;
    this.once = once || false;
  }
  function addListener(emitter, event, fn, context, once) {
    if (typeof fn !== "function") {
      throw new TypeError("The listener must be a function");
    }
    var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
    if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
    else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
    else emitter._events[evt] = [emitter._events[evt], listener];
    return emitter;
  }
  function clearEvent(emitter, evt) {
    if (--emitter._eventsCount === 0) emitter._events = new Events();
    else delete emitter._events[evt];
  }
  function EventEmitter2() {
    this._events = new Events();
    this._eventsCount = 0;
  }
  EventEmitter2.prototype.eventNames = function eventNames() {
    var names = [], events, name;
    if (this._eventsCount === 0) return names;
    for (name in events = this._events) {
      if (has2.call(events, name)) names.push(prefix ? name.slice(1) : name);
    }
    if (Object.getOwnPropertySymbols) {
      return names.concat(Object.getOwnPropertySymbols(events));
    }
    return names;
  };
  EventEmitter2.prototype.listeners = function listeners(event) {
    var evt = prefix ? prefix + event : event, handlers = this._events[evt];
    if (!handlers) return [];
    if (handlers.fn) return [handlers.fn];
    for (var i2 = 0, l = handlers.length, ee = new Array(l); i2 < l; i2++) {
      ee[i2] = handlers[i2].fn;
    }
    return ee;
  };
  EventEmitter2.prototype.listenerCount = function listenerCount(event) {
    var evt = prefix ? prefix + event : event, listeners = this._events[evt];
    if (!listeners) return 0;
    if (listeners.fn) return 1;
    return listeners.length;
  };
  EventEmitter2.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt]) return false;
    var listeners = this._events[evt], len2 = arguments.length, args, i2;
    if (listeners.fn) {
      if (listeners.once) this.removeListener(event, listeners.fn, void 0, true);
      switch (len2) {
        case 1:
          return listeners.fn.call(listeners.context), true;
        case 2:
          return listeners.fn.call(listeners.context, a1), true;
        case 3:
          return listeners.fn.call(listeners.context, a1, a2), true;
        case 4:
          return listeners.fn.call(listeners.context, a1, a2, a3), true;
        case 5:
          return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
        case 6:
          return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
      }
      for (i2 = 1, args = new Array(len2 - 1); i2 < len2; i2++) {
        args[i2 - 1] = arguments[i2];
      }
      listeners.fn.apply(listeners.context, args);
    } else {
      var length = listeners.length, j;
      for (i2 = 0; i2 < length; i2++) {
        if (listeners[i2].once) this.removeListener(event, listeners[i2].fn, void 0, true);
        switch (len2) {
          case 1:
            listeners[i2].fn.call(listeners[i2].context);
            break;
          case 2:
            listeners[i2].fn.call(listeners[i2].context, a1);
            break;
          case 3:
            listeners[i2].fn.call(listeners[i2].context, a1, a2);
            break;
          case 4:
            listeners[i2].fn.call(listeners[i2].context, a1, a2, a3);
            break;
          default:
            if (!args) for (j = 1, args = new Array(len2 - 1); j < len2; j++) {
              args[j - 1] = arguments[j];
            }
            listeners[i2].fn.apply(listeners[i2].context, args);
        }
      }
    }
    return true;
  };
  EventEmitter2.prototype.on = function on(event, fn, context) {
    return addListener(this, event, fn, context, false);
  };
  EventEmitter2.prototype.once = function once(event, fn, context) {
    return addListener(this, event, fn, context, true);
  };
  EventEmitter2.prototype.removeListener = function removeListener(event, fn, context, once) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt]) return this;
    if (!fn) {
      clearEvent(this, evt);
      return this;
    }
    var listeners = this._events[evt];
    if (listeners.fn) {
      if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
        clearEvent(this, evt);
      }
    } else {
      for (var i2 = 0, events = [], length = listeners.length; i2 < length; i2++) {
        if (listeners[i2].fn !== fn || once && !listeners[i2].once || context && listeners[i2].context !== context) {
          events.push(listeners[i2]);
        }
      }
      if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
      else clearEvent(this, evt);
    }
    return this;
  };
  EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
    var evt;
    if (event) {
      evt = prefix ? prefix + event : event;
      if (this._events[evt]) clearEvent(this, evt);
    } else {
      this._events = new Events();
      this._eventsCount = 0;
    }
    return this;
  };
  EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
  EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
  EventEmitter2.prefixed = prefix;
  EventEmitter2.EventEmitter = EventEmitter2;
  {
    module.exports = EventEmitter2;
  }
})(eventemitter3);
var eventemitter3Exports = eventemitter3.exports;
var pTimeout$1 = { exports: {} };
var pFinally$1 = (promise, onFinally) => {
  onFinally = onFinally || (() => {
  });
  return promise.then(
    (val) => new Promise((resolve) => {
      resolve(onFinally());
    }).then(() => val),
    (err) => new Promise((resolve) => {
      resolve(onFinally());
    }).then(() => {
      throw err;
    })
  );
};
const pFinally = pFinally$1;
class TimeoutError extends Error {
  constructor(message) {
    super(message);
    this.name = "TimeoutError";
  }
}
const pTimeout = (promise, milliseconds, fallback) => new Promise((resolve, reject) => {
  if (typeof milliseconds !== "number" || milliseconds < 0) {
    throw new TypeError("Expected `milliseconds` to be a positive number");
  }
  if (milliseconds === Infinity) {
    resolve(promise);
    return;
  }
  const timer = setTimeout(() => {
    if (typeof fallback === "function") {
      try {
        resolve(fallback());
      } catch (error) {
        reject(error);
      }
      return;
    }
    const message = typeof fallback === "string" ? fallback : `Promise timed out after ${milliseconds} milliseconds`;
    const timeoutError2 = fallback instanceof Error ? fallback : new TimeoutError(message);
    if (typeof promise.cancel === "function") {
      promise.cancel();
    }
    reject(timeoutError2);
  }, milliseconds);
  pFinally(
    // eslint-disable-next-line promise/prefer-await-to-then
    promise.then(resolve, reject),
    () => {
      clearTimeout(timer);
    }
  );
});
pTimeout$1.exports = pTimeout;
pTimeout$1.exports.default = pTimeout;
pTimeout$1.exports.TimeoutError = TimeoutError;
var pTimeoutExports = pTimeout$1.exports;
var priorityQueue = {};
var lowerBound$1 = {};
Object.defineProperty(lowerBound$1, "__esModule", { value: true });
function lowerBound(array2, value, comparator2) {
  let first = 0;
  let count = array2.length;
  while (count > 0) {
    const step = count / 2 | 0;
    let it = first + step;
    if (comparator2(array2[it], value) <= 0) {
      first = ++it;
      count -= step + 1;
    } else {
      count = step;
    }
  }
  return first;
}
lowerBound$1.default = lowerBound;
Object.defineProperty(priorityQueue, "__esModule", { value: true });
const lower_bound_1 = lowerBound$1;
class PriorityQueue {
  constructor() {
    this._queue = [];
  }
  enqueue(run, options2) {
    options2 = Object.assign({ priority: 0 }, options2);
    const element = {
      priority: options2.priority,
      run
    };
    if (this.size && this._queue[this.size - 1].priority >= options2.priority) {
      this._queue.push(element);
      return;
    }
    const index = lower_bound_1.default(this._queue, element, (a, b) => b.priority - a.priority);
    this._queue.splice(index, 0, element);
  }
  dequeue() {
    const item = this._queue.shift();
    return item === null || item === void 0 ? void 0 : item.run;
  }
  filter(options2) {
    return this._queue.filter((element) => element.priority === options2.priority).map((element) => element.run);
  }
  get size() {
    return this._queue.length;
  }
}
priorityQueue.default = PriorityQueue;
Object.defineProperty(dist, "__esModule", { value: true });
const EventEmitter = eventemitter3Exports;
const p_timeout_1 = pTimeoutExports;
const priority_queue_1 = priorityQueue;
const empty = () => {
};
const timeoutError = new p_timeout_1.TimeoutError();
class PQueue extends EventEmitter {
  constructor(options2) {
    var _a3, _b, _c, _d;
    super();
    this._intervalCount = 0;
    this._intervalEnd = 0;
    this._pendingCount = 0;
    this._resolveEmpty = empty;
    this._resolveIdle = empty;
    options2 = Object.assign({ carryoverConcurrencyCount: false, intervalCap: Infinity, interval: 0, concurrency: Infinity, autoStart: true, queueClass: priority_queue_1.default }, options2);
    if (!(typeof options2.intervalCap === "number" && options2.intervalCap >= 1)) {
      throw new TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${(_b = (_a3 = options2.intervalCap) === null || _a3 === void 0 ? void 0 : _a3.toString()) !== null && _b !== void 0 ? _b : ""}\` (${typeof options2.intervalCap})`);
    }
    if (options2.interval === void 0 || !(Number.isFinite(options2.interval) && options2.interval >= 0)) {
      throw new TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${(_d = (_c = options2.interval) === null || _c === void 0 ? void 0 : _c.toString()) !== null && _d !== void 0 ? _d : ""}\` (${typeof options2.interval})`);
    }
    this._carryoverConcurrencyCount = options2.carryoverConcurrencyCount;
    this._isIntervalIgnored = options2.intervalCap === Infinity || options2.interval === 0;
    this._intervalCap = options2.intervalCap;
    this._interval = options2.interval;
    this._queue = new options2.queueClass();
    this._queueClass = options2.queueClass;
    this.concurrency = options2.concurrency;
    this._timeout = options2.timeout;
    this._throwOnTimeout = options2.throwOnTimeout === true;
    this._isPaused = options2.autoStart === false;
  }
  get _doesIntervalAllowAnother() {
    return this._isIntervalIgnored || this._intervalCount < this._intervalCap;
  }
  get _doesConcurrentAllowAnother() {
    return this._pendingCount < this._concurrency;
  }
  _next() {
    this._pendingCount--;
    this._tryToStartAnother();
    this.emit("next");
  }
  _resolvePromises() {
    this._resolveEmpty();
    this._resolveEmpty = empty;
    if (this._pendingCount === 0) {
      this._resolveIdle();
      this._resolveIdle = empty;
      this.emit("idle");
    }
  }
  _onResumeInterval() {
    this._onInterval();
    this._initializeIntervalIfNeeded();
    this._timeoutId = void 0;
  }
  _isIntervalPaused() {
    const now = Date.now();
    if (this._intervalId === void 0) {
      const delay = this._intervalEnd - now;
      if (delay < 0) {
        this._intervalCount = this._carryoverConcurrencyCount ? this._pendingCount : 0;
      } else {
        if (this._timeoutId === void 0) {
          this._timeoutId = setTimeout(() => {
            this._onResumeInterval();
          }, delay);
        }
        return true;
      }
    }
    return false;
  }
  _tryToStartAnother() {
    if (this._queue.size === 0) {
      if (this._intervalId) {
        clearInterval(this._intervalId);
      }
      this._intervalId = void 0;
      this._resolvePromises();
      return false;
    }
    if (!this._isPaused) {
      const canInitializeInterval = !this._isIntervalPaused();
      if (this._doesIntervalAllowAnother && this._doesConcurrentAllowAnother) {
        const job = this._queue.dequeue();
        if (!job) {
          return false;
        }
        this.emit("active");
        job();
        if (canInitializeInterval) {
          this._initializeIntervalIfNeeded();
        }
        return true;
      }
    }
    return false;
  }
  _initializeIntervalIfNeeded() {
    if (this._isIntervalIgnored || this._intervalId !== void 0) {
      return;
    }
    this._intervalId = setInterval(() => {
      this._onInterval();
    }, this._interval);
    this._intervalEnd = Date.now() + this._interval;
  }
  _onInterval() {
    if (this._intervalCount === 0 && this._pendingCount === 0 && this._intervalId) {
      clearInterval(this._intervalId);
      this._intervalId = void 0;
    }
    this._intervalCount = this._carryoverConcurrencyCount ? this._pendingCount : 0;
    this._processQueue();
  }
  /**
  Executes all queued functions until it reaches the limit.
  */
  _processQueue() {
    while (this._tryToStartAnother()) {
    }
  }
  get concurrency() {
    return this._concurrency;
  }
  set concurrency(newConcurrency) {
    if (!(typeof newConcurrency === "number" && newConcurrency >= 1)) {
      throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${newConcurrency}\` (${typeof newConcurrency})`);
    }
    this._concurrency = newConcurrency;
    this._processQueue();
  }
  /**
  Adds a sync or async task to the queue. Always returns a promise.
  */
  async add(fn, options2 = {}) {
    return new Promise((resolve, reject) => {
      const run = async () => {
        this._pendingCount++;
        this._intervalCount++;
        try {
          const operation = this._timeout === void 0 && options2.timeout === void 0 ? fn() : p_timeout_1.default(Promise.resolve(fn()), options2.timeout === void 0 ? this._timeout : options2.timeout, () => {
            if (options2.throwOnTimeout === void 0 ? this._throwOnTimeout : options2.throwOnTimeout) {
              reject(timeoutError);
            }
            return void 0;
          });
          resolve(await operation);
        } catch (error) {
          reject(error);
        }
        this._next();
      };
      this._queue.enqueue(run, options2);
      this._tryToStartAnother();
      this.emit("add");
    });
  }
  /**
      Same as `.add()`, but accepts an array of sync or async functions.
  
      @returns A promise that resolves when all functions are resolved.
      */
  async addAll(functions, options2) {
    return Promise.all(functions.map(async (function_) => this.add(function_, options2)));
  }
  /**
  Start (or resume) executing enqueued tasks within concurrency limit. No need to call this if queue is not paused (via `options.autoStart = false` or by `.pause()` method.)
  */
  start() {
    if (!this._isPaused) {
      return this;
    }
    this._isPaused = false;
    this._processQueue();
    return this;
  }
  /**
  Put queue execution on hold.
  */
  pause() {
    this._isPaused = true;
  }
  /**
  Clear the queue.
  */
  clear() {
    this._queue = new this._queueClass();
  }
  /**
      Can be called multiple times. Useful if you for example add additional items at a later time.
  
      @returns A promise that settles when the queue becomes empty.
      */
  async onEmpty() {
    if (this._queue.size === 0) {
      return;
    }
    return new Promise((resolve) => {
      const existingResolve = this._resolveEmpty;
      this._resolveEmpty = () => {
        existingResolve();
        resolve();
      };
    });
  }
  /**
      The difference with `.onEmpty` is that `.onIdle` guarantees that all work from the queue has finished. `.onEmpty` merely signals that the queue is empty, but it could mean that some promises haven't completed yet.
  
      @returns A promise that settles when the queue becomes empty, and all promises have completed; `queue.size === 0 && queue.pending === 0`.
      */
  async onIdle() {
    if (this._pendingCount === 0 && this._queue.size === 0) {
      return;
    }
    return new Promise((resolve) => {
      const existingResolve = this._resolveIdle;
      this._resolveIdle = () => {
        existingResolve();
        resolve();
      };
    });
  }
  /**
  Size of the queue.
  */
  get size() {
    return this._queue.size;
  }
  /**
      Size of the queue, filtered by the given options.
  
      For example, this can be used to find the number of items remaining in the queue with a specific priority level.
      */
  sizeBy(options2) {
    return this._queue.filter(options2).length;
  }
  /**
  Number of pending promises.
  */
  get pending() {
    return this._pendingCount;
  }
  /**
  Whether the queue is currently paused.
  */
  get isPaused() {
    return this._isPaused;
  }
  get timeout() {
    return this._timeout;
  }
  /**
  Set the timeout for future operations.
  */
  set timeout(milliseconds) {
    this._timeout = milliseconds;
  }
}
var _default$1 = dist.default = PQueue;
const STATUS_RETRYABLE = [
  408,
  // Request Timeout
  425,
  // Too Early
  429,
  // Too Many Requests
  500,
  // Internal Server Error
  502,
  // Bad Gateway
  503,
  // Service Unavailable
  504
  // Gateway Timeout
];
let AsyncCaller$1 = class AsyncCaller2 {
  constructor(params) {
    Object.defineProperty(this, "maxConcurrency", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "maxRetries", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "maxQueueSizeBytes", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "queue", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "onFailedResponseHook", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "queueSizeBytes", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 0
    });
    this.maxConcurrency = params.maxConcurrency ?? Infinity;
    this.maxRetries = params.maxRetries ?? 6;
    this.maxQueueSizeBytes = params.maxQueueSizeBytes;
    if ("default" in _default$1) {
      this.queue = new _default$1.default({
        concurrency: this.maxConcurrency
      });
    } else {
      this.queue = new _default$1({ concurrency: this.maxConcurrency });
    }
    this.onFailedResponseHook = params == null ? void 0 : params.onFailedResponseHook;
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  call(callable, ...args) {
    return this.callWithOptions({}, callable, ...args);
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  callWithOptions(options2, callable, ...args) {
    const sizeBytes = options2.sizeBytes ?? 0;
    if (this.maxQueueSizeBytes !== void 0 && sizeBytes > 0 && this.queueSizeBytes + sizeBytes > this.maxQueueSizeBytes) {
      return Promise.reject(new Error(`Queue size limit (${this.maxQueueSizeBytes} bytes) exceeded. Current queue size: ${this.queueSizeBytes} bytes, attempted addition: ${sizeBytes} bytes.`));
    }
    if (sizeBytes > 0) {
      this.queueSizeBytes += sizeBytes;
    }
    const onFailedResponseHook = this.onFailedResponseHook;
    let promise = this.queue.add(() => pRetry$1(() => callable(...args).catch((error) => {
      if (error instanceof Error) {
        throw error;
      } else {
        throw new Error(error);
      }
    }), {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      async onFailedAttempt({ error }) {
        if (error.message.startsWith("Cancel") || error.message.startsWith("TimeoutError") || error.name === "TimeoutError" || error.message.startsWith("AbortError")) {
          throw error;
        }
        if ((error == null ? void 0 : error.code) === "ECONNABORTED") {
          throw error;
        }
        const response = error == null ? void 0 : error.response;
        if (onFailedResponseHook) {
          const handled = await onFailedResponseHook(response);
          if (handled) {
            return;
          }
        }
        const status = (response == null ? void 0 : response.status) ?? (error == null ? void 0 : error.status);
        if (status) {
          if (!STATUS_RETRYABLE.includes(+status)) {
            throw error;
          }
        }
      },
      retries: this.maxRetries,
      randomize: true
    }), { throwOnTimeout: true });
    if (sizeBytes > 0) {
      promise = promise.finally(() => {
        this.queueSizeBytes -= sizeBytes;
      });
    }
    if (options2.signal) {
      return Promise.race([
        promise,
        new Promise((_, reject) => {
          var _a3;
          (_a3 = options2.signal) == null ? void 0 : _a3.addEventListener("abort", () => {
            reject(new Error("AbortError"));
          });
        })
      ]);
    }
    return promise;
  }
};
function isLangChainMessage(message) {
  return typeof (message == null ? void 0 : message._getType) === "function";
}
function convertLangChainMessageToExample(message) {
  const converted = {
    type: message._getType(),
    data: { content: message.content }
  };
  if ((message == null ? void 0 : message.additional_kwargs) && Object.keys(message.additional_kwargs).length > 0) {
    converted.data.additional_kwargs = { ...message.additional_kwargs };
  }
  return converted;
}
var re$2 = { exports: {} };
const SEMVER_SPEC_VERSION = "2.0.0";
const MAX_LENGTH$1 = 256;
const MAX_SAFE_INTEGER$1 = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
9007199254740991;
const MAX_SAFE_COMPONENT_LENGTH = 16;
const MAX_SAFE_BUILD_LENGTH = MAX_LENGTH$1 - 6;
const RELEASE_TYPES = [
  "major",
  "premajor",
  "minor",
  "preminor",
  "patch",
  "prepatch",
  "prerelease"
];
var constants$1 = {
  MAX_LENGTH: MAX_LENGTH$1,
  MAX_SAFE_COMPONENT_LENGTH,
  MAX_SAFE_BUILD_LENGTH,
  MAX_SAFE_INTEGER: MAX_SAFE_INTEGER$1,
  RELEASE_TYPES,
  SEMVER_SPEC_VERSION,
  FLAG_INCLUDE_PRERELEASE: 1,
  FLAG_LOOSE: 2
};
const debug$1 = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
};
var debug_1 = debug$1;
(function(module, exports$1) {
  const {
    MAX_SAFE_COMPONENT_LENGTH: MAX_SAFE_COMPONENT_LENGTH2,
    MAX_SAFE_BUILD_LENGTH: MAX_SAFE_BUILD_LENGTH2,
    MAX_LENGTH: MAX_LENGTH2
  } = constants$1;
  const debug2 = debug_1;
  exports$1 = module.exports = {};
  const re2 = exports$1.re = [];
  const safeRe = exports$1.safeRe = [];
  const src = exports$1.src = [];
  const safeSrc = exports$1.safeSrc = [];
  const t2 = exports$1.t = {};
  let R = 0;
  const LETTERDASHNUMBER = "[a-zA-Z0-9-]";
  const safeRegexReplacements = [
    ["\\s", 1],
    ["\\d", MAX_LENGTH2],
    [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH2]
  ];
  const makeSafeRegex = (value) => {
    for (const [token, max] of safeRegexReplacements) {
      value = value.split(`${token}*`).join(`${token}{0,${max}}`).split(`${token}+`).join(`${token}{1,${max}}`);
    }
    return value;
  };
  const createToken = (name, value, isGlobal) => {
    const safe = makeSafeRegex(value);
    const index = R++;
    debug2(name, index, value);
    t2[name] = index;
    src[index] = value;
    safeSrc[index] = safe;
    re2[index] = new RegExp(value, isGlobal ? "g" : void 0);
    safeRe[index] = new RegExp(safe, isGlobal ? "g" : void 0);
  };
  createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
  createToken("NUMERICIDENTIFIERLOOSE", "\\d+");
  createToken("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
  createToken("MAINVERSION", `(${src[t2.NUMERICIDENTIFIER]})\\.(${src[t2.NUMERICIDENTIFIER]})\\.(${src[t2.NUMERICIDENTIFIER]})`);
  createToken("MAINVERSIONLOOSE", `(${src[t2.NUMERICIDENTIFIERLOOSE]})\\.(${src[t2.NUMERICIDENTIFIERLOOSE]})\\.(${src[t2.NUMERICIDENTIFIERLOOSE]})`);
  createToken("PRERELEASEIDENTIFIER", `(?:${src[t2.NONNUMERICIDENTIFIER]}|${src[t2.NUMERICIDENTIFIER]})`);
  createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t2.NONNUMERICIDENTIFIER]}|${src[t2.NUMERICIDENTIFIERLOOSE]})`);
  createToken("PRERELEASE", `(?:-(${src[t2.PRERELEASEIDENTIFIER]}(?:\\.${src[t2.PRERELEASEIDENTIFIER]})*))`);
  createToken("PRERELEASELOOSE", `(?:-?(${src[t2.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t2.PRERELEASEIDENTIFIERLOOSE]})*))`);
  createToken("BUILDIDENTIFIER", `${LETTERDASHNUMBER}+`);
  createToken("BUILD", `(?:\\+(${src[t2.BUILDIDENTIFIER]}(?:\\.${src[t2.BUILDIDENTIFIER]})*))`);
  createToken("FULLPLAIN", `v?${src[t2.MAINVERSION]}${src[t2.PRERELEASE]}?${src[t2.BUILD]}?`);
  createToken("FULL", `^${src[t2.FULLPLAIN]}$`);
  createToken("LOOSEPLAIN", `[v=\\s]*${src[t2.MAINVERSIONLOOSE]}${src[t2.PRERELEASELOOSE]}?${src[t2.BUILD]}?`);
  createToken("LOOSE", `^${src[t2.LOOSEPLAIN]}$`);
  createToken("GTLT", "((?:<|>)?=?)");
  createToken("XRANGEIDENTIFIERLOOSE", `${src[t2.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
  createToken("XRANGEIDENTIFIER", `${src[t2.NUMERICIDENTIFIER]}|x|X|\\*`);
  createToken("XRANGEPLAIN", `[v=\\s]*(${src[t2.XRANGEIDENTIFIER]})(?:\\.(${src[t2.XRANGEIDENTIFIER]})(?:\\.(${src[t2.XRANGEIDENTIFIER]})(?:${src[t2.PRERELEASE]})?${src[t2.BUILD]}?)?)?`);
  createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t2.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t2.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t2.XRANGEIDENTIFIERLOOSE]})(?:${src[t2.PRERELEASELOOSE]})?${src[t2.BUILD]}?)?)?`);
  createToken("XRANGE", `^${src[t2.GTLT]}\\s*${src[t2.XRANGEPLAIN]}$`);
  createToken("XRANGELOOSE", `^${src[t2.GTLT]}\\s*${src[t2.XRANGEPLAINLOOSE]}$`);
  createToken("COERCEPLAIN", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH2}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH2}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH2}}))?`);
  createToken("COERCE", `${src[t2.COERCEPLAIN]}(?:$|[^\\d])`);
  createToken("COERCEFULL", src[t2.COERCEPLAIN] + `(?:${src[t2.PRERELEASE]})?(?:${src[t2.BUILD]})?(?:$|[^\\d])`);
  createToken("COERCERTL", src[t2.COERCE], true);
  createToken("COERCERTLFULL", src[t2.COERCEFULL], true);
  createToken("LONETILDE", "(?:~>?)");
  createToken("TILDETRIM", `(\\s*)${src[t2.LONETILDE]}\\s+`, true);
  exports$1.tildeTrimReplace = "$1~";
  createToken("TILDE", `^${src[t2.LONETILDE]}${src[t2.XRANGEPLAIN]}$`);
  createToken("TILDELOOSE", `^${src[t2.LONETILDE]}${src[t2.XRANGEPLAINLOOSE]}$`);
  createToken("LONECARET", "(?:\\^)");
  createToken("CARETTRIM", `(\\s*)${src[t2.LONECARET]}\\s+`, true);
  exports$1.caretTrimReplace = "$1^";
  createToken("CARET", `^${src[t2.LONECARET]}${src[t2.XRANGEPLAIN]}$`);
  createToken("CARETLOOSE", `^${src[t2.LONECARET]}${src[t2.XRANGEPLAINLOOSE]}$`);
  createToken("COMPARATORLOOSE", `^${src[t2.GTLT]}\\s*(${src[t2.LOOSEPLAIN]})$|^$`);
  createToken("COMPARATOR", `^${src[t2.GTLT]}\\s*(${src[t2.FULLPLAIN]})$|^$`);
  createToken("COMPARATORTRIM", `(\\s*)${src[t2.GTLT]}\\s*(${src[t2.LOOSEPLAIN]}|${src[t2.XRANGEPLAIN]})`, true);
  exports$1.comparatorTrimReplace = "$1$2$3";
  createToken("HYPHENRANGE", `^\\s*(${src[t2.XRANGEPLAIN]})\\s+-\\s+(${src[t2.XRANGEPLAIN]})\\s*$`);
  createToken("HYPHENRANGELOOSE", `^\\s*(${src[t2.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t2.XRANGEPLAINLOOSE]})\\s*$`);
  createToken("STAR", "(<|>)?=?\\s*\\*");
  createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
  createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
})(re$2, re$2.exports);
var reExports = re$2.exports;
const looseOption = Object.freeze({ loose: true });
const emptyOpts = Object.freeze({});
const parseOptions$1 = (options2) => {
  if (!options2) {
    return emptyOpts;
  }
  if (typeof options2 !== "object") {
    return looseOption;
  }
  return options2;
};
var parseOptions_1 = parseOptions$1;
const numeric = /^[0-9]+$/;
const compareIdentifiers$1 = (a, b) => {
  if (typeof a === "number" && typeof b === "number") {
    return a === b ? 0 : a < b ? -1 : 1;
  }
  const anum = numeric.test(a);
  const bnum = numeric.test(b);
  if (anum && bnum) {
    a = +a;
    b = +b;
  }
  return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
};
const rcompareIdentifiers = (a, b) => compareIdentifiers$1(b, a);
var identifiers$1 = {
  compareIdentifiers: compareIdentifiers$1,
  rcompareIdentifiers
};
const debug = debug_1;
const { MAX_LENGTH, MAX_SAFE_INTEGER } = constants$1;
const { safeRe: re$1, t: t$1 } = reExports;
const parseOptions = parseOptions_1;
const { compareIdentifiers } = identifiers$1;
let SemVer$1 = class SemVer2 {
  constructor(version2, options2) {
    options2 = parseOptions(options2);
    if (version2 instanceof SemVer2) {
      if (version2.loose === !!options2.loose && version2.includePrerelease === !!options2.includePrerelease) {
        return version2;
      } else {
        version2 = version2.version;
      }
    } else if (typeof version2 !== "string") {
      throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version2}".`);
    }
    if (version2.length > MAX_LENGTH) {
      throw new TypeError(
        `version is longer than ${MAX_LENGTH} characters`
      );
    }
    debug("SemVer", version2, options2);
    this.options = options2;
    this.loose = !!options2.loose;
    this.includePrerelease = !!options2.includePrerelease;
    const m = version2.trim().match(options2.loose ? re$1[t$1.LOOSE] : re$1[t$1.FULL]);
    if (!m) {
      throw new TypeError(`Invalid Version: ${version2}`);
    }
    this.raw = version2;
    this.major = +m[1];
    this.minor = +m[2];
    this.patch = +m[3];
    if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
      throw new TypeError("Invalid major version");
    }
    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
      throw new TypeError("Invalid minor version");
    }
    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
      throw new TypeError("Invalid patch version");
    }
    if (!m[4]) {
      this.prerelease = [];
    } else {
      this.prerelease = m[4].split(".").map((id) => {
        if (/^[0-9]+$/.test(id)) {
          const num = +id;
          if (num >= 0 && num < MAX_SAFE_INTEGER) {
            return num;
          }
        }
        return id;
      });
    }
    this.build = m[5] ? m[5].split(".") : [];
    this.format();
  }
  format() {
    this.version = `${this.major}.${this.minor}.${this.patch}`;
    if (this.prerelease.length) {
      this.version += `-${this.prerelease.join(".")}`;
    }
    return this.version;
  }
  toString() {
    return this.version;
  }
  compare(other) {
    debug("SemVer.compare", this.version, this.options, other);
    if (!(other instanceof SemVer2)) {
      if (typeof other === "string" && other === this.version) {
        return 0;
      }
      other = new SemVer2(other, this.options);
    }
    if (other.version === this.version) {
      return 0;
    }
    return this.compareMain(other) || this.comparePre(other);
  }
  compareMain(other) {
    if (!(other instanceof SemVer2)) {
      other = new SemVer2(other, this.options);
    }
    if (this.major < other.major) {
      return -1;
    }
    if (this.major > other.major) {
      return 1;
    }
    if (this.minor < other.minor) {
      return -1;
    }
    if (this.minor > other.minor) {
      return 1;
    }
    if (this.patch < other.patch) {
      return -1;
    }
    if (this.patch > other.patch) {
      return 1;
    }
    return 0;
  }
  comparePre(other) {
    if (!(other instanceof SemVer2)) {
      other = new SemVer2(other, this.options);
    }
    if (this.prerelease.length && !other.prerelease.length) {
      return -1;
    } else if (!this.prerelease.length && other.prerelease.length) {
      return 1;
    } else if (!this.prerelease.length && !other.prerelease.length) {
      return 0;
    }
    let i2 = 0;
    do {
      const a = this.prerelease[i2];
      const b = other.prerelease[i2];
      debug("prerelease compare", i2, a, b);
      if (a === void 0 && b === void 0) {
        return 0;
      } else if (b === void 0) {
        return 1;
      } else if (a === void 0) {
        return -1;
      } else if (a === b) {
        continue;
      } else {
        return compareIdentifiers(a, b);
      }
    } while (++i2);
  }
  compareBuild(other) {
    if (!(other instanceof SemVer2)) {
      other = new SemVer2(other, this.options);
    }
    let i2 = 0;
    do {
      const a = this.build[i2];
      const b = other.build[i2];
      debug("build compare", i2, a, b);
      if (a === void 0 && b === void 0) {
        return 0;
      } else if (b === void 0) {
        return 1;
      } else if (a === void 0) {
        return -1;
      } else if (a === b) {
        continue;
      } else {
        return compareIdentifiers(a, b);
      }
    } while (++i2);
  }
  // preminor will bump the version up to the next minor release, and immediately
  // down to pre-release. premajor and prepatch work the same way.
  inc(release, identifier, identifierBase) {
    if (release.startsWith("pre")) {
      if (!identifier && identifierBase === false) {
        throw new Error("invalid increment argument: identifier is empty");
      }
      if (identifier) {
        const match = `-${identifier}`.match(this.options.loose ? re$1[t$1.PRERELEASELOOSE] : re$1[t$1.PRERELEASE]);
        if (!match || match[1] !== identifier) {
          throw new Error(`invalid identifier: ${identifier}`);
        }
      }
    }
    switch (release) {
      case "premajor":
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor = 0;
        this.major++;
        this.inc("pre", identifier, identifierBase);
        break;
      case "preminor":
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor++;
        this.inc("pre", identifier, identifierBase);
        break;
      case "prepatch":
        this.prerelease.length = 0;
        this.inc("patch", identifier, identifierBase);
        this.inc("pre", identifier, identifierBase);
        break;
      case "prerelease":
        if (this.prerelease.length === 0) {
          this.inc("patch", identifier, identifierBase);
        }
        this.inc("pre", identifier, identifierBase);
        break;
      case "release":
        if (this.prerelease.length === 0) {
          throw new Error(`version ${this.raw} is not a prerelease`);
        }
        this.prerelease.length = 0;
        break;
      case "major":
        if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
          this.major++;
        }
        this.minor = 0;
        this.patch = 0;
        this.prerelease = [];
        break;
      case "minor":
        if (this.patch !== 0 || this.prerelease.length === 0) {
          this.minor++;
        }
        this.patch = 0;
        this.prerelease = [];
        break;
      case "patch":
        if (this.prerelease.length === 0) {
          this.patch++;
        }
        this.prerelease = [];
        break;
      case "pre": {
        const base = Number(identifierBase) ? 1 : 0;
        if (this.prerelease.length === 0) {
          this.prerelease = [base];
        } else {
          let i2 = this.prerelease.length;
          while (--i2 >= 0) {
            if (typeof this.prerelease[i2] === "number") {
              this.prerelease[i2]++;
              i2 = -2;
            }
          }
          if (i2 === -1) {
            if (identifier === this.prerelease.join(".") && identifierBase === false) {
              throw new Error("invalid increment argument: identifier already exists");
            }
            this.prerelease.push(base);
          }
        }
        if (identifier) {
          let prerelease = [identifier, base];
          if (identifierBase === false) {
            prerelease = [identifier];
          }
          if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
            if (isNaN(this.prerelease[1])) {
              this.prerelease = prerelease;
            }
          } else {
            this.prerelease = prerelease;
          }
        }
        break;
      }
      default:
        throw new Error(`invalid increment argument: ${release}`);
    }
    this.raw = this.format();
    if (this.build.length) {
      this.raw += `+${this.build.join(".")}`;
    }
    return this;
  }
};
var semver = SemVer$1;
const SemVer = semver;
const compare$7 = (a, b, loose) => new SemVer(a, loose).compare(new SemVer(b, loose));
var compare_1 = compare$7;
const compare$6 = compare_1;
const gt$1 = (a, b, loose) => compare$6(a, b, loose) > 0;
var gt_1 = gt$1;
const compare$5 = compare_1;
const lt$1 = (a, b, loose) => compare$5(a, b, loose) < 0;
var lt_1 = lt$1;
const compare$4 = compare_1;
const eq$1 = (a, b, loose) => compare$4(a, b, loose) === 0;
var eq_1 = eq$1;
const compare$3 = compare_1;
const neq$1 = (a, b, loose) => compare$3(a, b, loose) !== 0;
var neq_1 = neq$1;
const compare$2 = compare_1;
const gte$1 = (a, b, loose) => compare$2(a, b, loose) >= 0;
var gte_1 = gte$1;
const compare$1 = compare_1;
const lte$1 = (a, b, loose) => compare$1(a, b, loose) <= 0;
var lte_1 = lte$1;
const eq = eq_1;
const neq = neq_1;
const gt = gt_1;
const gte = gte_1;
const lt = lt_1;
const lte = lte_1;
const cmp = (a, op, b, loose) => {
  switch (op) {
    case "===":
      if (typeof a === "object") {
        a = a.version;
      }
      if (typeof b === "object") {
        b = b.version;
      }
      return a === b;
    case "!==":
      if (typeof a === "object") {
        a = a.version;
      }
      if (typeof b === "object") {
        b = b.version;
      }
      return a !== b;
    case "":
    case "=":
    case "==":
      return eq(a, b, loose);
    case "!=":
      return neq(a, b, loose);
    case ">":
      return gt(a, b, loose);
    case ">=":
      return gte(a, b, loose);
    case "<":
      return lt(a, b, loose);
    case "<=":
      return lte(a, b, loose);
    default:
      throw new TypeError(`Invalid operator: ${op}`);
  }
};
var cmp_1 = cmp;
const { safeRe: re, t } = reExports;
class LRUCache {
  constructor() {
    this.max = 1e3;
    this.map = /* @__PURE__ */ new Map();
  }
  get(key) {
    const value = this.map.get(key);
    if (value === void 0) {
      return void 0;
    } else {
      this.map.delete(key);
      this.map.set(key, value);
      return value;
    }
  }
  delete(key) {
    return this.map.delete(key);
  }
  set(key, value) {
    const deleted = this.delete(key);
    if (!deleted && value !== void 0) {
      if (this.map.size >= this.max) {
        const firstKey = this.map.keys().next().value;
        this.delete(firstKey);
      }
      this.map.set(key, value);
    }
    return this;
  }
}
var lrucache = LRUCache;
var range;
var hasRequiredRange;
function requireRange() {
  if (hasRequiredRange) return range;
  hasRequiredRange = 1;
  const SPACE_CHARACTERS = /\s+/g;
  class Range {
    constructor(range2, options2) {
      options2 = parseOptions2(options2);
      if (range2 instanceof Range) {
        if (range2.loose === !!options2.loose && range2.includePrerelease === !!options2.includePrerelease) {
          return range2;
        } else {
          return new Range(range2.raw, options2);
        }
      }
      if (range2 instanceof Comparator2) {
        this.raw = range2.value;
        this.set = [[range2]];
        this.formatted = void 0;
        return this;
      }
      this.options = options2;
      this.loose = !!options2.loose;
      this.includePrerelease = !!options2.includePrerelease;
      this.raw = range2.trim().replace(SPACE_CHARACTERS, " ");
      this.set = this.raw.split("||").map((r) => this.parseRange(r.trim())).filter((c) => c.length);
      if (!this.set.length) {
        throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
      }
      if (this.set.length > 1) {
        const first = this.set[0];
        this.set = this.set.filter((c) => !isNullSet(c[0]));
        if (this.set.length === 0) {
          this.set = [first];
        } else if (this.set.length > 1) {
          for (const c of this.set) {
            if (c.length === 1 && isAny(c[0])) {
              this.set = [c];
              break;
            }
          }
        }
      }
      this.formatted = void 0;
    }
    get range() {
      if (this.formatted === void 0) {
        this.formatted = "";
        for (let i2 = 0; i2 < this.set.length; i2++) {
          if (i2 > 0) {
            this.formatted += "||";
          }
          const comps = this.set[i2];
          for (let k = 0; k < comps.length; k++) {
            if (k > 0) {
              this.formatted += " ";
            }
            this.formatted += comps[k].toString().trim();
          }
        }
      }
      return this.formatted;
    }
    format() {
      return this.range;
    }
    toString() {
      return this.range;
    }
    parseRange(range2) {
      const memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);
      const memoKey = memoOpts + ":" + range2;
      const cached2 = cache2.get(memoKey);
      if (cached2) {
        return cached2;
      }
      const loose = this.options.loose;
      const hr = loose ? re2[t2.HYPHENRANGELOOSE] : re2[t2.HYPHENRANGE];
      range2 = range2.replace(hr, hyphenReplace(this.options.includePrerelease));
      debug2("hyphen replace", range2);
      range2 = range2.replace(re2[t2.COMPARATORTRIM], comparatorTrimReplace);
      debug2("comparator trim", range2);
      range2 = range2.replace(re2[t2.TILDETRIM], tildeTrimReplace);
      debug2("tilde trim", range2);
      range2 = range2.replace(re2[t2.CARETTRIM], caretTrimReplace);
      debug2("caret trim", range2);
      let rangeList = range2.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options));
      if (loose) {
        rangeList = rangeList.filter((comp) => {
          debug2("loose invalid filter", comp, this.options);
          return !!comp.match(re2[t2.COMPARATORLOOSE]);
        });
      }
      debug2("range list", rangeList);
      const rangeMap = /* @__PURE__ */ new Map();
      const comparators = rangeList.map((comp) => new Comparator2(comp, this.options));
      for (const comp of comparators) {
        if (isNullSet(comp)) {
          return [comp];
        }
        rangeMap.set(comp.value, comp);
      }
      if (rangeMap.size > 1 && rangeMap.has("")) {
        rangeMap.delete("");
      }
      const result = [...rangeMap.values()];
      cache2.set(memoKey, result);
      return result;
    }
    intersects(range2, options2) {
      if (!(range2 instanceof Range)) {
        throw new TypeError("a Range is required");
      }
      return this.set.some((thisComparators) => {
        return isSatisfiable(thisComparators, options2) && range2.set.some((rangeComparators) => {
          return isSatisfiable(rangeComparators, options2) && thisComparators.every((thisComparator) => {
            return rangeComparators.every((rangeComparator) => {
              return thisComparator.intersects(rangeComparator, options2);
            });
          });
        });
      });
    }
    // if ANY of the sets match ALL of its comparators, then pass
    test(version2) {
      if (!version2) {
        return false;
      }
      if (typeof version2 === "string") {
        try {
          version2 = new SemVer3(version2, this.options);
        } catch (er) {
          return false;
        }
      }
      for (let i2 = 0; i2 < this.set.length; i2++) {
        if (testSet(this.set[i2], version2, this.options)) {
          return true;
        }
      }
      return false;
    }
  }
  range = Range;
  const LRU = lrucache;
  const cache2 = new LRU();
  const parseOptions2 = parseOptions_1;
  const Comparator2 = requireComparator();
  const debug2 = debug_1;
  const SemVer3 = semver;
  const {
    safeRe: re2,
    t: t2,
    comparatorTrimReplace,
    tildeTrimReplace,
    caretTrimReplace
  } = reExports;
  const { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = constants$1;
  const isNullSet = (c) => c.value === "<0.0.0-0";
  const isAny = (c) => c.value === "";
  const isSatisfiable = (comparators, options2) => {
    let result = true;
    const remainingComparators = comparators.slice();
    let testComparator = remainingComparators.pop();
    while (result && remainingComparators.length) {
      result = remainingComparators.every((otherComparator) => {
        return testComparator.intersects(otherComparator, options2);
      });
      testComparator = remainingComparators.pop();
    }
    return result;
  };
  const parseComparator = (comp, options2) => {
    comp = comp.replace(re2[t2.BUILD], "");
    debug2("comp", comp, options2);
    comp = replaceCarets(comp, options2);
    debug2("caret", comp);
    comp = replaceTildes(comp, options2);
    debug2("tildes", comp);
    comp = replaceXRanges(comp, options2);
    debug2("xrange", comp);
    comp = replaceStars(comp, options2);
    debug2("stars", comp);
    return comp;
  };
  const isX = (id) => !id || id.toLowerCase() === "x" || id === "*";
  const replaceTildes = (comp, options2) => {
    return comp.trim().split(/\s+/).map((c) => replaceTilde(c, options2)).join(" ");
  };
  const replaceTilde = (comp, options2) => {
    const r = options2.loose ? re2[t2.TILDELOOSE] : re2[t2.TILDE];
    return comp.replace(r, (_, M, m, p, pr) => {
      debug2("tilde", comp, _, M, m, p, pr);
      let ret;
      if (isX(M)) {
        ret = "";
      } else if (isX(m)) {
        ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
      } else if (isX(p)) {
        ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
      } else if (pr) {
        debug2("replaceTilde pr", pr);
        ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
      } else {
        ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;
      }
      debug2("tilde return", ret);
      return ret;
    });
  };
  const replaceCarets = (comp, options2) => {
    return comp.trim().split(/\s+/).map((c) => replaceCaret(c, options2)).join(" ");
  };
  const replaceCaret = (comp, options2) => {
    debug2("caret", comp, options2);
    const r = options2.loose ? re2[t2.CARETLOOSE] : re2[t2.CARET];
    const z = options2.includePrerelease ? "-0" : "";
    return comp.replace(r, (_, M, m, p, pr) => {
      debug2("caret", comp, _, M, m, p, pr);
      let ret;
      if (isX(M)) {
        ret = "";
      } else if (isX(m)) {
        ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
      } else if (isX(p)) {
        if (M === "0") {
          ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;
        } else {
          ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;
        }
      } else if (pr) {
        debug2("replaceCaret pr", pr);
        if (M === "0") {
          if (m === "0") {
            ret = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0`;
          } else {
            ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
          }
        } else {
          ret = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;
        }
      } else {
        debug2("no pr");
        if (M === "0") {
          if (m === "0") {
            ret = `>=${M}.${m}.${p}${z} <${M}.${m}.${+p + 1}-0`;
          } else {
            ret = `>=${M}.${m}.${p}${z} <${M}.${+m + 1}.0-0`;
          }
        } else {
          ret = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;
        }
      }
      debug2("caret return", ret);
      return ret;
    });
  };
  const replaceXRanges = (comp, options2) => {
    debug2("replaceXRanges", comp, options2);
    return comp.split(/\s+/).map((c) => replaceXRange(c, options2)).join(" ");
  };
  const replaceXRange = (comp, options2) => {
    comp = comp.trim();
    const r = options2.loose ? re2[t2.XRANGELOOSE] : re2[t2.XRANGE];
    return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
      debug2("xRange", comp, ret, gtlt, M, m, p, pr);
      const xM = isX(M);
      const xm = xM || isX(m);
      const xp = xm || isX(p);
      const anyX = xp;
      if (gtlt === "=" && anyX) {
        gtlt = "";
      }
      pr = options2.includePrerelease ? "-0" : "";
      if (xM) {
        if (gtlt === ">" || gtlt === "<") {
          ret = "<0.0.0-0";
        } else {
          ret = "*";
        }
      } else if (gtlt && anyX) {
        if (xm) {
          m = 0;
        }
        p = 0;
        if (gtlt === ">") {
          gtlt = ">=";
          if (xm) {
            M = +M + 1;
            m = 0;
            p = 0;
          } else {
            m = +m + 1;
            p = 0;
          }
        } else if (gtlt === "<=") {
          gtlt = "<";
          if (xm) {
            M = +M + 1;
          } else {
            m = +m + 1;
          }
        }
        if (gtlt === "<") {
          pr = "-0";
        }
        ret = `${gtlt + M}.${m}.${p}${pr}`;
      } else if (xm) {
        ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
      } else if (xp) {
        ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;
      }
      debug2("xRange return", ret);
      return ret;
    });
  };
  const replaceStars = (comp, options2) => {
    debug2("replaceStars", comp, options2);
    return comp.trim().replace(re2[t2.STAR], "");
  };
  const replaceGTE0 = (comp, options2) => {
    debug2("replaceGTE0", comp, options2);
    return comp.trim().replace(re2[options2.includePrerelease ? t2.GTE0PRE : t2.GTE0], "");
  };
  const hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr) => {
    if (isX(fM)) {
      from = "";
    } else if (isX(fm)) {
      from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
    } else if (isX(fp)) {
      from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
    } else if (fpr) {
      from = `>=${from}`;
    } else {
      from = `>=${from}${incPr ? "-0" : ""}`;
    }
    if (isX(tM)) {
      to = "";
    } else if (isX(tm)) {
      to = `<${+tM + 1}.0.0-0`;
    } else if (isX(tp)) {
      to = `<${tM}.${+tm + 1}.0-0`;
    } else if (tpr) {
      to = `<=${tM}.${tm}.${tp}-${tpr}`;
    } else if (incPr) {
      to = `<${tM}.${tm}.${+tp + 1}-0`;
    } else {
      to = `<=${to}`;
    }
    return `${from} ${to}`.trim();
  };
  const testSet = (set, version2, options2) => {
    for (let i2 = 0; i2 < set.length; i2++) {
      if (!set[i2].test(version2)) {
        return false;
      }
    }
    if (version2.prerelease.length && !options2.includePrerelease) {
      for (let i2 = 0; i2 < set.length; i2++) {
        debug2(set[i2].semver);
        if (set[i2].semver === Comparator2.ANY) {
          continue;
        }
        if (set[i2].semver.prerelease.length > 0) {
          const allowed = set[i2].semver;
          if (allowed.major === version2.major && allowed.minor === version2.minor && allowed.patch === version2.patch) {
            return true;
          }
        }
      }
      return false;
    }
    return true;
  };
  return range;
}
var comparator;
var hasRequiredComparator;
function requireComparator() {
  if (hasRequiredComparator) return comparator;
  hasRequiredComparator = 1;
  const ANY2 = Symbol("SemVer ANY");
  class Comparator2 {
    static get ANY() {
      return ANY2;
    }
    constructor(comp, options2) {
      options2 = parseOptions2(options2);
      if (comp instanceof Comparator2) {
        if (comp.loose === !!options2.loose) {
          return comp;
        } else {
          comp = comp.value;
        }
      }
      comp = comp.trim().split(/\s+/).join(" ");
      debug2("comparator", comp, options2);
      this.options = options2;
      this.loose = !!options2.loose;
      this.parse(comp);
      if (this.semver === ANY2) {
        this.value = "";
      } else {
        this.value = this.operator + this.semver.version;
      }
      debug2("comp", this);
    }
    parse(comp) {
      const r = this.options.loose ? re2[t2.COMPARATORLOOSE] : re2[t2.COMPARATOR];
      const m = comp.match(r);
      if (!m) {
        throw new TypeError(`Invalid comparator: ${comp}`);
      }
      this.operator = m[1] !== void 0 ? m[1] : "";
      if (this.operator === "=") {
        this.operator = "";
      }
      if (!m[2]) {
        this.semver = ANY2;
      } else {
        this.semver = new SemVer3(m[2], this.options.loose);
      }
    }
    toString() {
      return this.value;
    }
    test(version2) {
      debug2("Comparator.test", version2, this.options.loose);
      if (this.semver === ANY2 || version2 === ANY2) {
        return true;
      }
      if (typeof version2 === "string") {
        try {
          version2 = new SemVer3(version2, this.options);
        } catch (er) {
          return false;
        }
      }
      return cmp2(version2, this.operator, this.semver, this.options);
    }
    intersects(comp, options2) {
      if (!(comp instanceof Comparator2)) {
        throw new TypeError("a Comparator is required");
      }
      if (this.operator === "") {
        if (this.value === "") {
          return true;
        }
        return new Range(comp.value, options2).test(this.value);
      } else if (comp.operator === "") {
        if (comp.value === "") {
          return true;
        }
        return new Range(this.value, options2).test(comp.semver);
      }
      options2 = parseOptions2(options2);
      if (options2.includePrerelease && (this.value === "<0.0.0-0" || comp.value === "<0.0.0-0")) {
        return false;
      }
      if (!options2.includePrerelease && (this.value.startsWith("<0.0.0") || comp.value.startsWith("<0.0.0"))) {
        return false;
      }
      if (this.operator.startsWith(">") && comp.operator.startsWith(">")) {
        return true;
      }
      if (this.operator.startsWith("<") && comp.operator.startsWith("<")) {
        return true;
      }
      if (this.semver.version === comp.semver.version && this.operator.includes("=") && comp.operator.includes("=")) {
        return true;
      }
      if (cmp2(this.semver, "<", comp.semver, options2) && this.operator.startsWith(">") && comp.operator.startsWith("<")) {
        return true;
      }
      if (cmp2(this.semver, ">", comp.semver, options2) && this.operator.startsWith("<") && comp.operator.startsWith(">")) {
        return true;
      }
      return false;
    }
  }
  comparator = Comparator2;
  const parseOptions2 = parseOptions_1;
  const { safeRe: re2, t: t2 } = reExports;
  const cmp2 = cmp_1;
  const debug2 = debug_1;
  const SemVer3 = semver;
  const Range = requireRange();
  return comparator;
}
requireRange();
requireRange();
requireRange();
requireRange();
requireRange();
requireRange();
const Comparator$1 = requireComparator();
const { ANY: ANY$1 } = Comparator$1;
requireRange();
requireRange();
requireRange();
const Comparator = requireComparator();
const { ANY } = Comparator;
[new Comparator(">=0.0.0-0")];
[new Comparator(">=0.0.0")];
const internalRe = reExports;
const constants = constants$1;
const identifiers = identifiers$1;
requireComparator();
requireRange();
({
  re: internalRe.re,
  src: internalRe.src,
  tokens: internalRe.t,
  SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
  RELEASE_TYPES: constants.RELEASE_TYPES,
  compareIdentifiers: identifiers.compareIdentifiers,
  rcompareIdentifiers: identifiers.rcompareIdentifiers
});
function parsePromptIdentifier(identifier) {
  if (!identifier || identifier.split("/").length > 2 || identifier.startsWith("/") || identifier.endsWith("/") || identifier.split(":").length > 2) {
    throw new Error(`Invalid identifier format: ${identifier}`);
  }
  const [ownerNamePart, commitPart] = identifier.split(":");
  const commit = commitPart || "latest";
  if (ownerNamePart.includes("/")) {
    const [owner, name] = ownerNamePart.split("/", 2);
    if (!owner || !name) {
      throw new Error(`Invalid identifier format: ${identifier}`);
    }
    return [owner, name, commit];
  } else {
    if (!ownerNamePart) {
      throw new Error(`Invalid identifier format: ${identifier}`);
    }
    return ["-", ownerNamePart, commit];
  }
}
class LangSmithConflictError extends Error {
  constructor(message) {
    super(message);
    Object.defineProperty(this, "status", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.name = "LangSmithConflictError";
    this.status = 409;
  }
}
async function raiseForStatus(response, context, consumeOnSuccess) {
  let errorBody;
  if (response.ok) {
    if (consumeOnSuccess) {
      errorBody = await response.text();
    }
    return;
  }
  if (response.status === 403) {
    try {
      const errorData = await response.json();
      const errorCode = errorData == null ? void 0 : errorData.error;
      if (errorCode === "org_scoped_key_requires_workspace") {
        errorBody = "This API key is org-scoped and requires workspace specification. Please provide 'workspaceId' parameter, or set LANGSMITH_WORKSPACE_ID environment variable.";
      }
    } catch (e) {
      const errorWithStatus = new Error(`${response.status} ${response.statusText}`);
      errorWithStatus.status = response == null ? void 0 : response.status;
      throw errorWithStatus;
    }
  }
  if (errorBody === void 0) {
    try {
      errorBody = await response.text();
    } catch (e) {
      errorBody = "";
    }
  }
  const fullMessage = `Failed to ${context}. Received status [${response.status}]: ${response.statusText}. Message: ${errorBody}`;
  if (response.status === 409) {
    throw new LangSmithConflictError(fullMessage);
  }
  const err = new Error(fullMessage);
  err.status = response.status;
  throw err;
}
const ERR_CONFLICTING_ENDPOINTS = "ERR_CONFLICTING_ENDPOINTS";
class ConflictingEndpointsError extends Error {
  constructor() {
    super("You cannot provide both LANGSMITH_ENDPOINT / LANGCHAIN_ENDPOINT and LANGSMITH_RUNS_ENDPOINTS.");
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ERR_CONFLICTING_ENDPOINTS
    });
    this.name = "ConflictingEndpointsError";
  }
}
function isConflictingEndpointsError(err) {
  return typeof err === "object" && err !== null && err.code === ERR_CONFLICTING_ENDPOINTS;
}
var LIMIT_REPLACE_NODE = "[...]";
var CIRCULAR_REPLACE_NODE = { result: "[Circular]" };
var arr = [];
var replacerStack = [];
const encoder = new TextEncoder();
function defaultOptions$2() {
  return {
    depthLimit: Number.MAX_SAFE_INTEGER,
    edgesLimit: Number.MAX_SAFE_INTEGER
  };
}
function encodeString(str2) {
  return encoder.encode(str2);
}
function serializeWellKnownTypes(val) {
  if (val && typeof val === "object" && val !== null) {
    if (val instanceof Map) {
      return Object.fromEntries(val);
    } else if (val instanceof Set) {
      return Array.from(val);
    } else if (val instanceof Date) {
      return val.toISOString();
    } else if (val instanceof RegExp) {
      return val.toString();
    } else if (val instanceof Error) {
      return {
        name: val.name,
        message: val.message
      };
    }
  } else if (typeof val === "bigint") {
    return val.toString();
  }
  return val;
}
function createDefaultReplacer(userReplacer) {
  return function(key, val) {
    return serializeWellKnownTypes(val);
  };
}
function serialize(obj, errorContext, replacer, spacer, options2) {
  var _a3;
  try {
    const str2 = JSON.stringify(obj, createDefaultReplacer(replacer), spacer);
    return encodeString(str2);
  } catch (e) {
    if (!((_a3 = e.message) == null ? void 0 : _a3.includes("Converting circular structure to JSON"))) {
      console.warn(`[WARNING]: LangSmith received unserializable value.${errorContext ? `
Context: ${errorContext}` : ""}`);
      return encodeString("[Unserializable]");
    }
    getLangSmithEnvironmentVariable("SUPPRESS_CIRCULAR_JSON_WARNINGS") !== "true" && console.warn(`[WARNING]: LangSmith received circular JSON. This will decrease tracer performance. ${errorContext ? `
Context: ${errorContext}` : ""}`);
    if (typeof options2 === "undefined") {
      options2 = defaultOptions$2();
    }
    decirc(obj, "", 0, [], void 0, 0, options2);
    let res;
    try {
      if (replacerStack.length === 0) {
        res = JSON.stringify(obj, replacer, spacer);
      } else {
        res = JSON.stringify(obj, replaceGetterValues(replacer), spacer);
      }
    } catch (_) {
      return encodeString("[unable to serialize, circular reference is too complex to analyze]");
    } finally {
      while (arr.length !== 0) {
        const part = arr.pop();
        if (part.length === 4) {
          Object.defineProperty(part[0], part[1], part[3]);
        } else {
          part[0][part[1]] = part[2];
        }
      }
    }
    return encodeString(res);
  }
}
function setReplace(replace, val, k, parent) {
  var propertyDescriptor = Object.getOwnPropertyDescriptor(parent, k);
  if (propertyDescriptor.get !== void 0) {
    if (propertyDescriptor.configurable) {
      Object.defineProperty(parent, k, { value: replace });
      arr.push([parent, k, val, propertyDescriptor]);
    } else {
      replacerStack.push([val, k, replace]);
    }
  } else {
    parent[k] = replace;
    arr.push([parent, k, val]);
  }
}
function decirc(val, k, edgeIndex, stack, parent, depth, options2) {
  depth += 1;
  var i2;
  if (typeof val === "object" && val !== null) {
    for (i2 = 0; i2 < stack.length; i2++) {
      if (stack[i2] === val) {
        setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);
        return;
      }
    }
    if (typeof options2.depthLimit !== "undefined" && depth > options2.depthLimit) {
      setReplace(LIMIT_REPLACE_NODE, val, k, parent);
      return;
    }
    if (typeof options2.edgesLimit !== "undefined" && edgeIndex + 1 > options2.edgesLimit) {
      setReplace(LIMIT_REPLACE_NODE, val, k, parent);
      return;
    }
    stack.push(val);
    if (Array.isArray(val)) {
      for (i2 = 0; i2 < val.length; i2++) {
        decirc(val[i2], i2, i2, stack, val, depth, options2);
      }
    } else {
      val = serializeWellKnownTypes(val);
      var keys = Object.keys(val);
      for (i2 = 0; i2 < keys.length; i2++) {
        var key = keys[i2];
        decirc(val[key], key, i2, stack, val, depth, options2);
      }
    }
    stack.pop();
  }
}
function replaceGetterValues(replacer) {
  replacer = typeof replacer !== "undefined" ? replacer : function(k, v) {
    return v;
  };
  return function(key, val) {
    if (replacerStack.length > 0) {
      for (var i2 = 0; i2 < replacerStack.length; i2++) {
        var part = replacerStack[i2];
        if (part[1] === key && part[0] === val) {
          val = part[2];
          replacerStack.splice(i2, 1);
          break;
        }
      }
    }
    return replacer.call(this, key, val);
  };
}
function mergeRuntimeEnvIntoRun(run, cachedEnvVars) {
  const runtimeEnv = getRuntimeEnvironment();
  const envVars = cachedEnvVars ?? getLangSmithEnvVarsMetadata();
  const extra = run.extra ?? {};
  const metadata = extra.metadata;
  run.extra = {
    ...extra,
    runtime: {
      ...runtimeEnv,
      ...extra == null ? void 0 : extra.runtime
    },
    metadata: {
      ...envVars,
      ...envVars.revision_id || "revision_id" in run && run.revision_id ? {
        revision_id: ("revision_id" in run ? run.revision_id : void 0) ?? envVars.revision_id
      } : {},
      ...metadata
    }
  };
  return run;
}
const getTracingSamplingRate = (configRate) => {
  const samplingRateStr = (configRate == null ? void 0 : configRate.toString()) ?? getLangSmithEnvironmentVariable("TRACING_SAMPLING_RATE");
  if (samplingRateStr === void 0) {
    return void 0;
  }
  const samplingRate = parseFloat(samplingRateStr);
  if (samplingRate < 0 || samplingRate > 1) {
    throw new Error(`LANGSMITH_TRACING_SAMPLING_RATE must be between 0 and 1 if set. Got: ${samplingRate}`);
  }
  return samplingRate;
};
const isLocalhost = (url) => {
  const strippedUrl = url.replace("http://", "").replace("https://", "");
  const hostname = strippedUrl.split("/")[0].split(":")[0];
  return hostname === "localhost" || hostname === "127.0.0.1" || hostname === "::1";
};
async function toArray(iterable) {
  const result = [];
  for await (const item of iterable) {
    result.push(item);
  }
  return result;
}
function trimQuotes(str2) {
  if (str2 === void 0) {
    return void 0;
  }
  return str2.trim().replace(/^"(.*)"$/, "$1").replace(/^'(.*)'$/, "$1");
}
const handle429 = async (response) => {
  if ((response == null ? void 0 : response.status) === 429) {
    const retryAfter = parseInt(response.headers.get("retry-after") ?? "10", 10) * 1e3;
    if (retryAfter > 0) {
      await new Promise((resolve) => setTimeout(resolve, retryAfter));
      return true;
    }
  }
  return false;
};
function _formatFeedbackScore(score) {
  if (typeof score === "number") {
    return Number(score.toFixed(4));
  }
  return score;
}
const DEFAULT_UNCOMPRESSED_BATCH_SIZE_LIMIT_BYTES = 24 * 1024 * 1024;
const DEFAULT_MAX_SIZE_BYTES = 1024 * 1024 * 1024;
const SERVER_INFO_REQUEST_TIMEOUT_MS = 1e4;
const DEFAULT_BATCH_SIZE_LIMIT = 100;
const DEFAULT_API_URL = "https://api.smith.langchain.com";
class AutoBatchQueue {
  constructor(maxSizeBytes) {
    Object.defineProperty(this, "items", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: []
    });
    Object.defineProperty(this, "sizeBytes", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 0
    });
    Object.defineProperty(this, "maxSizeBytes", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.maxSizeBytes = maxSizeBytes ?? DEFAULT_MAX_SIZE_BYTES;
  }
  peek() {
    return this.items[0];
  }
  push(item) {
    let itemPromiseResolve;
    const itemPromise = new Promise((resolve) => {
      itemPromiseResolve = resolve;
    });
    const size = serialize(item.item, `Serializing run with id: ${item.item.id}`).length;
    if (this.sizeBytes + size > this.maxSizeBytes && this.items.length > 0) {
      console.warn(`AutoBatchQueue size limit (${this.maxSizeBytes} bytes) exceeded. Dropping run with id: ${item.item.id}. Current queue size: ${this.sizeBytes} bytes, attempted addition: ${size} bytes.`);
      itemPromiseResolve();
      return itemPromise;
    }
    this.items.push({
      action: item.action,
      payload: item.item,
      otelContext: item.otelContext,
      apiKey: item.apiKey,
      apiUrl: item.apiUrl,
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      itemPromiseResolve,
      itemPromise,
      size
    });
    this.sizeBytes += size;
    return itemPromise;
  }
  pop({ upToSizeBytes, upToSize }) {
    var _a3;
    if (upToSizeBytes < 1) {
      throw new Error("Number of bytes to pop off may not be less than 1.");
    }
    const popped = [];
    let poppedSizeBytes = 0;
    while (poppedSizeBytes + (((_a3 = this.peek()) == null ? void 0 : _a3.size) ?? 0) < upToSizeBytes && this.items.length > 0 && popped.length < upToSize) {
      const item = this.items.shift();
      if (item) {
        popped.push(item);
        poppedSizeBytes += item.size;
        this.sizeBytes -= item.size;
      }
    }
    if (popped.length === 0 && this.items.length > 0) {
      const item = this.items.shift();
      popped.push(item);
      poppedSizeBytes += item.size;
      this.sizeBytes -= item.size;
    }
    return [
      popped.map((it) => ({
        action: it.action,
        item: it.payload,
        otelContext: it.otelContext,
        apiKey: it.apiKey,
        apiUrl: it.apiUrl,
        size: it.size
      })),
      () => popped.forEach((it) => it.itemPromiseResolve())
    ];
  }
}
class Client {
  get _fetch() {
    return this.fetchImplementation || _getFetchImplementation(this.debug);
  }
  constructor(config2 = {}) {
    var _a3;
    Object.defineProperty(this, "apiKey", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "apiUrl", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "webUrl", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "workspaceId", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "caller", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "batchIngestCaller", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "timeout_ms", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "_tenantId", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: null
    });
    Object.defineProperty(this, "hideInputs", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "hideOutputs", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "tracingSampleRate", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "filteredPostUuids", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: /* @__PURE__ */ new Set()
    });
    Object.defineProperty(this, "autoBatchTracing", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: true
    });
    Object.defineProperty(this, "autoBatchQueue", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "autoBatchTimeout", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "autoBatchAggregationDelayMs", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 250
    });
    Object.defineProperty(this, "batchSizeBytesLimit", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "batchSizeLimit", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "fetchOptions", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "settings", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "blockOnRootRunFinalization", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: getEnvironmentVariable("LANGSMITH_TRACING_BACKGROUND") === "false"
    });
    Object.defineProperty(this, "traceBatchConcurrency", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 5
    });
    Object.defineProperty(this, "_serverInfo", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "_getServerInfoPromise", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "manualFlushMode", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: false
    });
    Object.defineProperty(this, "langSmithToOTELTranslator", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "fetchImplementation", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "cachedLSEnvVarsForMetadata", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "multipartStreamingDisabled", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: false
    });
    Object.defineProperty(this, "debug", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: getEnvironmentVariable("LANGSMITH_DEBUG") === "true"
    });
    const defaultConfig = Client.getDefaultClientConfig();
    this.tracingSampleRate = getTracingSamplingRate(config2.tracingSamplingRate);
    this.apiUrl = trimQuotes(config2.apiUrl ?? defaultConfig.apiUrl) ?? "";
    if (this.apiUrl.endsWith("/")) {
      this.apiUrl = this.apiUrl.slice(0, -1);
    }
    this.apiKey = trimQuotes(config2.apiKey ?? defaultConfig.apiKey);
    this.webUrl = trimQuotes(config2.webUrl ?? defaultConfig.webUrl);
    if ((_a3 = this.webUrl) == null ? void 0 : _a3.endsWith("/")) {
      this.webUrl = this.webUrl.slice(0, -1);
    }
    this.workspaceId = trimQuotes(config2.workspaceId ?? getLangSmithEnvironmentVariable("WORKSPACE_ID"));
    this.timeout_ms = config2.timeout_ms ?? 9e4;
    this.caller = new AsyncCaller$1({
      ...config2.callerOptions ?? {},
      maxRetries: 4,
      debug: config2.debug ?? this.debug
    });
    this.traceBatchConcurrency = config2.traceBatchConcurrency ?? this.traceBatchConcurrency;
    if (this.traceBatchConcurrency < 1) {
      throw new Error("Trace batch concurrency must be positive.");
    }
    this.debug = config2.debug ?? this.debug;
    this.fetchImplementation = config2.fetchImplementation;
    const maxMemory = config2.maxIngestMemoryBytes ?? DEFAULT_MAX_SIZE_BYTES;
    this.batchIngestCaller = new AsyncCaller$1({
      maxRetries: 4,
      maxConcurrency: this.traceBatchConcurrency,
      maxQueueSizeBytes: maxMemory,
      ...config2.callerOptions ?? {},
      onFailedResponseHook: handle429,
      debug: config2.debug ?? this.debug
    });
    this.hideInputs = config2.hideInputs ?? config2.anonymizer ?? defaultConfig.hideInputs;
    this.hideOutputs = config2.hideOutputs ?? config2.anonymizer ?? defaultConfig.hideOutputs;
    this.autoBatchTracing = config2.autoBatchTracing ?? this.autoBatchTracing;
    this.autoBatchQueue = new AutoBatchQueue(maxMemory);
    this.blockOnRootRunFinalization = config2.blockOnRootRunFinalization ?? this.blockOnRootRunFinalization;
    this.batchSizeBytesLimit = config2.batchSizeBytesLimit;
    this.batchSizeLimit = config2.batchSizeLimit;
    this.fetchOptions = config2.fetchOptions || {};
    this.manualFlushMode = config2.manualFlushMode ?? this.manualFlushMode;
    if (getOtelEnabled()) {
      this.langSmithToOTELTranslator = new LangSmithToOTELTranslator();
    }
    this.cachedLSEnvVarsForMetadata = getLangSmithEnvVarsMetadata();
  }
  static getDefaultClientConfig() {
    const apiKey = getLangSmithEnvironmentVariable("API_KEY");
    const apiUrl = getLangSmithEnvironmentVariable("ENDPOINT") ?? DEFAULT_API_URL;
    const hideInputs = getLangSmithEnvironmentVariable("HIDE_INPUTS") === "true";
    const hideOutputs = getLangSmithEnvironmentVariable("HIDE_OUTPUTS") === "true";
    return {
      apiUrl,
      apiKey,
      webUrl: void 0,
      hideInputs,
      hideOutputs
    };
  }
  getHostUrl() {
    if (this.webUrl) {
      return this.webUrl;
    } else if (isLocalhost(this.apiUrl)) {
      this.webUrl = "http://localhost:3000";
      return this.webUrl;
    } else if (this.apiUrl.endsWith("/api/v1")) {
      this.webUrl = this.apiUrl.replace("/api/v1", "");
      return this.webUrl;
    } else if (this.apiUrl.includes("/api") && !this.apiUrl.split(".", 1)[0].endsWith("api")) {
      this.webUrl = this.apiUrl.replace("/api", "");
      return this.webUrl;
    } else if (this.apiUrl.split(".", 1)[0].includes("dev")) {
      this.webUrl = "https://dev.smith.langchain.com";
      return this.webUrl;
    } else if (this.apiUrl.split(".", 1)[0].includes("eu")) {
      this.webUrl = "https://eu.smith.langchain.com";
      return this.webUrl;
    } else if (this.apiUrl.split(".", 1)[0].includes("beta")) {
      this.webUrl = "https://beta.smith.langchain.com";
      return this.webUrl;
    } else {
      this.webUrl = "https://smith.langchain.com";
      return this.webUrl;
    }
  }
  get headers() {
    const headers = {
      "User-Agent": `langsmith-js/${__version__}`
    };
    if (this.apiKey) {
      headers["x-api-key"] = `${this.apiKey}`;
    }
    if (this.workspaceId) {
      headers["x-tenant-id"] = this.workspaceId;
    }
    return headers;
  }
  _getPlatformEndpointPath(path2) {
    const needsV1Prefix = this.apiUrl.slice(-3) !== "/v1" && this.apiUrl.slice(-4) !== "/v1/";
    return needsV1Prefix ? `/v1/platform/${path2}` : `/platform/${path2}`;
  }
  async processInputs(inputs) {
    if (this.hideInputs === false) {
      return inputs;
    }
    if (this.hideInputs === true) {
      return {};
    }
    if (typeof this.hideInputs === "function") {
      return this.hideInputs(inputs);
    }
    return inputs;
  }
  async processOutputs(outputs) {
    if (this.hideOutputs === false) {
      return outputs;
    }
    if (this.hideOutputs === true) {
      return {};
    }
    if (typeof this.hideOutputs === "function") {
      return this.hideOutputs(outputs);
    }
    return outputs;
  }
  async prepareRunCreateOrUpdateInputs(run) {
    const runParams = { ...run };
    if (runParams.inputs !== void 0) {
      runParams.inputs = await this.processInputs(runParams.inputs);
    }
    if (runParams.outputs !== void 0) {
      runParams.outputs = await this.processOutputs(runParams.outputs);
    }
    return runParams;
  }
  async _getResponse(path2, queryParams) {
    const paramsString = (queryParams == null ? void 0 : queryParams.toString()) ?? "";
    const url = `${this.apiUrl}${path2}?${paramsString}`;
    const response = await this.caller.call(async () => {
      const res = await this._fetch(url, {
        method: "GET",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await raiseForStatus(res, `fetch ${path2}`);
      return res;
    });
    return response;
  }
  async _get(path2, queryParams) {
    const response = await this._getResponse(path2, queryParams);
    return response.json();
  }
  async *_getPaginated(path2, queryParams = new URLSearchParams(), transform2) {
    let offset = Number(queryParams.get("offset")) || 0;
    const limit2 = Number(queryParams.get("limit")) || 100;
    while (true) {
      queryParams.set("offset", String(offset));
      queryParams.set("limit", String(limit2));
      const url = `${this.apiUrl}${path2}?${queryParams}`;
      const response = await this.caller.call(async () => {
        const res = await this._fetch(url, {
          method: "GET",
          headers: this.headers,
          signal: AbortSignal.timeout(this.timeout_ms),
          ...this.fetchOptions
        });
        await raiseForStatus(res, `fetch ${path2}`);
        return res;
      });
      const items = transform2 ? transform2(await response.json()) : await response.json();
      if (items.length === 0) {
        break;
      }
      yield items;
      if (items.length < limit2) {
        break;
      }
      offset += items.length;
    }
  }
  async *_getCursorPaginatedList(path2, body = null, requestMethod = "POST", dataKey = "runs") {
    const bodyParams = body ? { ...body } : {};
    while (true) {
      const body2 = JSON.stringify(bodyParams);
      const response = await this.caller.call(async () => {
        const res = await this._fetch(`${this.apiUrl}${path2}`, {
          method: requestMethod,
          headers: { ...this.headers, "Content-Type": "application/json" },
          signal: AbortSignal.timeout(this.timeout_ms),
          ...this.fetchOptions,
          body: body2
        });
        await raiseForStatus(res, `fetch ${path2}`);
        return res;
      });
      const responseBody = await response.json();
      if (!responseBody) {
        break;
      }
      if (!responseBody[dataKey]) {
        break;
      }
      yield responseBody[dataKey];
      const cursors = responseBody.cursors;
      if (!cursors) {
        break;
      }
      if (!cursors.next) {
        break;
      }
      bodyParams.cursor = cursors.next;
    }
  }
  // Allows mocking for tests
  _shouldSample() {
    if (this.tracingSampleRate === void 0) {
      return true;
    }
    return Math.random() < this.tracingSampleRate;
  }
  _filterForSampling(runs, patch = false) {
    if (this.tracingSampleRate === void 0) {
      return runs;
    }
    if (patch) {
      const sampled = [];
      for (const run of runs) {
        if (!this.filteredPostUuids.has(run.trace_id)) {
          sampled.push(run);
        } else if (run.id === run.trace_id) {
          this.filteredPostUuids.delete(run.trace_id);
        }
      }
      return sampled;
    } else {
      const sampled = [];
      for (const run of runs) {
        const traceId = run.trace_id ?? run.id;
        if (this.filteredPostUuids.has(traceId)) {
          continue;
        }
        if (run.id === traceId) {
          if (this._shouldSample()) {
            sampled.push(run);
          } else {
            this.filteredPostUuids.add(traceId);
          }
        } else {
          sampled.push(run);
        }
      }
      return sampled;
    }
  }
  async _getBatchSizeLimitBytes() {
    var _a3;
    const serverInfo = await this._ensureServerInfo();
    return this.batchSizeBytesLimit ?? ((_a3 = serverInfo.batch_ingest_config) == null ? void 0 : _a3.size_limit_bytes) ?? DEFAULT_UNCOMPRESSED_BATCH_SIZE_LIMIT_BYTES;
  }
  /**
   * Get the maximum number of operations to batch in a single request.
   */
  async _getBatchSizeLimit() {
    var _a3;
    const serverInfo = await this._ensureServerInfo();
    return this.batchSizeLimit ?? ((_a3 = serverInfo.batch_ingest_config) == null ? void 0 : _a3.size_limit) ?? DEFAULT_BATCH_SIZE_LIMIT;
  }
  async _getDatasetExamplesMultiPartSupport() {
    var _a3;
    const serverInfo = await this._ensureServerInfo();
    return ((_a3 = serverInfo.instance_flags) == null ? void 0 : _a3.dataset_examples_multipart_enabled) ?? false;
  }
  drainAutoBatchQueue({ batchSizeLimitBytes, batchSizeLimit }) {
    const promises = [];
    while (this.autoBatchQueue.items.length > 0) {
      const [batch, done] = this.autoBatchQueue.pop({
        upToSizeBytes: batchSizeLimitBytes,
        upToSize: batchSizeLimit
      });
      if (!batch.length) {
        done();
        break;
      }
      const batchesByDestination = batch.reduce((acc, item) => {
        const apiUrl = item.apiUrl ?? this.apiUrl;
        const apiKey = item.apiKey ?? this.apiKey;
        const isDefault = item.apiKey === this.apiKey && item.apiUrl === this.apiUrl;
        const batchKey = isDefault ? "default" : `${apiUrl}|${apiKey}`;
        if (!acc[batchKey]) {
          acc[batchKey] = [];
        }
        acc[batchKey].push(item);
        return acc;
      }, {});
      const batchPromises = [];
      for (const [batchKey, batch2] of Object.entries(batchesByDestination)) {
        const batchPromise = this._processBatch(batch2, {
          apiUrl: batchKey === "default" ? void 0 : batchKey.split("|")[0],
          apiKey: batchKey === "default" ? void 0 : batchKey.split("|")[1]
        });
        batchPromises.push(batchPromise);
      }
      const allBatchesPromise = Promise.all(batchPromises).finally(done);
      promises.push(allBatchesPromise);
    }
    return Promise.all(promises);
  }
  async _processBatch(batch, options2) {
    var _a3, _b;
    if (!batch.length) {
      return;
    }
    const batchSizeBytes = batch.reduce((sum, item) => sum + (item.size ?? 0), 0);
    try {
      if (this.langSmithToOTELTranslator !== void 0) {
        this._sendBatchToOTELTranslator(batch);
      } else {
        const ingestParams = {
          runCreates: batch.filter((item) => item.action === "create").map((item) => item.item),
          runUpdates: batch.filter((item) => item.action === "update").map((item) => item.item)
        };
        const serverInfo = await this._ensureServerInfo();
        if ((_a3 = serverInfo == null ? void 0 : serverInfo.batch_ingest_config) == null ? void 0 : _a3.use_multipart_endpoint) {
          const useGzip = (_b = serverInfo == null ? void 0 : serverInfo.instance_flags) == null ? void 0 : _b.gzip_body_enabled;
          await this.multipartIngestRuns(ingestParams, {
            ...options2,
            useGzip,
            sizeBytes: batchSizeBytes
          });
        } else {
          await this.batchIngestRuns(ingestParams, {
            ...options2,
            sizeBytes: batchSizeBytes
          });
        }
      }
    } catch (e) {
      console.error("Error exporting batch:", e);
    }
  }
  _sendBatchToOTELTranslator(batch) {
    if (this.langSmithToOTELTranslator !== void 0) {
      const otelContextMap = /* @__PURE__ */ new Map();
      const operations = [];
      for (const item of batch) {
        if (item.item.id && item.otelContext) {
          otelContextMap.set(item.item.id, item.otelContext);
          if (item.action === "create") {
            operations.push({
              operation: "post",
              id: item.item.id,
              trace_id: item.item.trace_id ?? item.item.id,
              run: item.item
            });
          } else {
            operations.push({
              operation: "patch",
              id: item.item.id,
              trace_id: item.item.trace_id ?? item.item.id,
              run: item.item
            });
          }
        }
      }
      this.langSmithToOTELTranslator.exportBatch(operations, otelContextMap);
    }
  }
  async processRunOperation(item) {
    clearTimeout(this.autoBatchTimeout);
    this.autoBatchTimeout = void 0;
    item.item = mergeRuntimeEnvIntoRun(item.item, this.cachedLSEnvVarsForMetadata);
    const itemPromise = this.autoBatchQueue.push(item);
    if (this.manualFlushMode) {
      return itemPromise;
    }
    const sizeLimitBytes = await this._getBatchSizeLimitBytes();
    const sizeLimit = await this._getBatchSizeLimit();
    if (this.autoBatchQueue.sizeBytes > sizeLimitBytes || this.autoBatchQueue.items.length > sizeLimit) {
      void this.drainAutoBatchQueue({
        batchSizeLimitBytes: sizeLimitBytes,
        batchSizeLimit: sizeLimit
      });
    }
    if (this.autoBatchQueue.items.length > 0) {
      this.autoBatchTimeout = setTimeout(() => {
        this.autoBatchTimeout = void 0;
        void this.drainAutoBatchQueue({
          batchSizeLimitBytes: sizeLimitBytes,
          batchSizeLimit: sizeLimit
        });
      }, this.autoBatchAggregationDelayMs);
    }
    return itemPromise;
  }
  async _getServerInfo() {
    const response = await this.caller.call(async () => {
      const res = await this._fetch(`${this.apiUrl}/info`, {
        method: "GET",
        headers: { Accept: "application/json" },
        signal: AbortSignal.timeout(SERVER_INFO_REQUEST_TIMEOUT_MS),
        ...this.fetchOptions
      });
      await raiseForStatus(res, "get server info");
      return res;
    });
    const json = await response.json();
    if (this.debug) {
      console.log("\n=== LangSmith Server Configuration ===\n" + JSON.stringify(json, null, 2) + "\n");
    }
    return json;
  }
  async _ensureServerInfo() {
    if (this._getServerInfoPromise === void 0) {
      this._getServerInfoPromise = (async () => {
        if (this._serverInfo === void 0) {
          try {
            this._serverInfo = await this._getServerInfo();
          } catch (e) {
            console.warn(`[LANGSMITH]: Failed to fetch info on supported operations. Falling back to batch operations and default limits. Info: ${e.status ?? "Unspecified status code"} ${e.message}`);
          }
        }
        return this._serverInfo ?? {};
      })();
    }
    return this._getServerInfoPromise.then((serverInfo) => {
      if (this._serverInfo === void 0) {
        this._getServerInfoPromise = void 0;
      }
      return serverInfo;
    });
  }
  async _getSettings() {
    if (!this.settings) {
      this.settings = this._get("/settings");
    }
    return await this.settings;
  }
  /**
   * Flushes current queued traces.
   */
  async flush() {
    const sizeLimitBytes = await this._getBatchSizeLimitBytes();
    const sizeLimit = await this._getBatchSizeLimit();
    await this.drainAutoBatchQueue({
      batchSizeLimitBytes: sizeLimitBytes,
      batchSizeLimit: sizeLimit
    });
  }
  _cloneCurrentOTELContext() {
    const otel_trace = getOTELTrace();
    const otel_context = getOTELContext();
    if (this.langSmithToOTELTranslator !== void 0) {
      const currentSpan = otel_trace.getActiveSpan();
      if (currentSpan) {
        return otel_trace.setSpan(otel_context.active(), currentSpan);
      }
    }
    return void 0;
  }
  async createRun(run, options2) {
    if (!this._filterForSampling([run]).length) {
      return;
    }
    const headers = {
      ...this.headers,
      "Content-Type": "application/json"
    };
    const session_name = run.project_name;
    delete run.project_name;
    const runCreate = await this.prepareRunCreateOrUpdateInputs({
      session_name,
      ...run,
      start_time: run.start_time ?? Date.now()
    });
    if (this.autoBatchTracing && runCreate.trace_id !== void 0 && runCreate.dotted_order !== void 0) {
      const otelContext = this._cloneCurrentOTELContext();
      void this.processRunOperation({
        action: "create",
        item: runCreate,
        otelContext,
        apiKey: options2 == null ? void 0 : options2.apiKey,
        apiUrl: options2 == null ? void 0 : options2.apiUrl
      }).catch(console.error);
      return;
    }
    const mergedRunCreateParam = mergeRuntimeEnvIntoRun(runCreate, this.cachedLSEnvVarsForMetadata);
    if ((options2 == null ? void 0 : options2.apiKey) !== void 0) {
      headers["x-api-key"] = options2.apiKey;
    }
    if ((options2 == null ? void 0 : options2.workspaceId) !== void 0) {
      headers["x-tenant-id"] = options2.workspaceId;
    }
    const body = serialize(mergedRunCreateParam, `Creating run with id: ${mergedRunCreateParam.id}`);
    await this.caller.call(async () => {
      const res = await this._fetch(`${(options2 == null ? void 0 : options2.apiUrl) ?? this.apiUrl}/runs`, {
        method: "POST",
        headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body
      });
      await raiseForStatus(res, "create run", true);
      return res;
    });
  }
  /**
   * Batch ingest/upsert multiple runs in the Langsmith system.
   * @param runs
   */
  async batchIngestRuns({ runCreates, runUpdates }, options2) {
    if (runCreates === void 0 && runUpdates === void 0) {
      return;
    }
    let preparedCreateParams = await Promise.all((runCreates == null ? void 0 : runCreates.map((create) => this.prepareRunCreateOrUpdateInputs(create))) ?? []);
    let preparedUpdateParams = await Promise.all((runUpdates == null ? void 0 : runUpdates.map((update) => this.prepareRunCreateOrUpdateInputs(update))) ?? []);
    if (preparedCreateParams.length > 0 && preparedUpdateParams.length > 0) {
      const createById = preparedCreateParams.reduce((params, run) => {
        if (!run.id) {
          return params;
        }
        params[run.id] = run;
        return params;
      }, {});
      const standaloneUpdates = [];
      for (const updateParam of preparedUpdateParams) {
        if (updateParam.id !== void 0 && createById[updateParam.id]) {
          createById[updateParam.id] = {
            ...createById[updateParam.id],
            ...updateParam
          };
        } else {
          standaloneUpdates.push(updateParam);
        }
      }
      preparedCreateParams = Object.values(createById);
      preparedUpdateParams = standaloneUpdates;
    }
    const rawBatch = {
      post: preparedCreateParams,
      patch: preparedUpdateParams
    };
    if (!rawBatch.post.length && !rawBatch.patch.length) {
      return;
    }
    const batchChunks = {
      post: [],
      patch: []
    };
    for (const k of ["post", "patch"]) {
      const key = k;
      const batchItems = rawBatch[key].reverse();
      let batchItem = batchItems.pop();
      while (batchItem !== void 0) {
        batchChunks[key].push(batchItem);
        batchItem = batchItems.pop();
      }
    }
    if (batchChunks.post.length > 0 || batchChunks.patch.length > 0) {
      const runIds = batchChunks.post.map((item) => item.id).concat(batchChunks.patch.map((item) => item.id)).join(",");
      await this._postBatchIngestRuns(serialize(batchChunks, `Ingesting runs with ids: ${runIds}`), options2);
    }
  }
  async _postBatchIngestRuns(body, options2) {
    const headers = {
      ...this.headers,
      "Content-Type": "application/json",
      Accept: "application/json"
    };
    if ((options2 == null ? void 0 : options2.apiKey) !== void 0) {
      headers["x-api-key"] = options2.apiKey;
    }
    await this.batchIngestCaller.callWithOptions({ sizeBytes: options2 == null ? void 0 : options2.sizeBytes }, async () => {
      const res = await this._fetch(`${(options2 == null ? void 0 : options2.apiUrl) ?? this.apiUrl}/runs/batch`, {
        method: "POST",
        headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body
      });
      await raiseForStatus(res, "batch create run", true);
      return res;
    });
  }
  /**
   * Batch ingest/upsert multiple runs in the Langsmith system.
   * @param runs
   */
  async multipartIngestRuns({ runCreates, runUpdates }, options2) {
    if (runCreates === void 0 && runUpdates === void 0) {
      return;
    }
    const allAttachments = {};
    let preparedCreateParams = [];
    for (const create of runCreates ?? []) {
      const preparedCreate = await this.prepareRunCreateOrUpdateInputs(create);
      if (preparedCreate.id !== void 0 && preparedCreate.attachments !== void 0) {
        allAttachments[preparedCreate.id] = preparedCreate.attachments;
      }
      delete preparedCreate.attachments;
      preparedCreateParams.push(preparedCreate);
    }
    let preparedUpdateParams = [];
    for (const update of runUpdates ?? []) {
      preparedUpdateParams.push(await this.prepareRunCreateOrUpdateInputs(update));
    }
    const invalidRunCreate = preparedCreateParams.find((runCreate) => {
      return runCreate.trace_id === void 0 || runCreate.dotted_order === void 0;
    });
    if (invalidRunCreate !== void 0) {
      throw new Error(`Multipart ingest requires "trace_id" and "dotted_order" to be set when creating a run`);
    }
    const invalidRunUpdate = preparedUpdateParams.find((runUpdate) => {
      return runUpdate.trace_id === void 0 || runUpdate.dotted_order === void 0;
    });
    if (invalidRunUpdate !== void 0) {
      throw new Error(`Multipart ingest requires "trace_id" and "dotted_order" to be set when updating a run`);
    }
    if (preparedCreateParams.length > 0 && preparedUpdateParams.length > 0) {
      const createById = preparedCreateParams.reduce((params, run) => {
        if (!run.id) {
          return params;
        }
        params[run.id] = run;
        return params;
      }, {});
      const standaloneUpdates = [];
      for (const updateParam of preparedUpdateParams) {
        if (updateParam.id !== void 0 && createById[updateParam.id]) {
          createById[updateParam.id] = {
            ...createById[updateParam.id],
            ...updateParam
          };
        } else {
          standaloneUpdates.push(updateParam);
        }
      }
      preparedCreateParams = Object.values(createById);
      preparedUpdateParams = standaloneUpdates;
    }
    if (preparedCreateParams.length === 0 && preparedUpdateParams.length === 0) {
      return;
    }
    const accumulatedContext = [];
    const accumulatedParts = [];
    for (const [method, payloads] of [
      ["post", preparedCreateParams],
      ["patch", preparedUpdateParams]
    ]) {
      for (const originalPayload of payloads) {
        const { inputs, outputs, events, extra, error, serialized, attachments, ...payload } = originalPayload;
        const fields = { inputs, outputs, events, extra, error, serialized };
        const stringifiedPayload = serialize(payload, `Serializing for multipart ingestion of run with id: ${payload.id}`);
        accumulatedParts.push({
          name: `${method}.${payload.id}`,
          payload: new Blob([stringifiedPayload], {
            type: `application/json; length=${stringifiedPayload.length}`
            // encoding=gzip
          })
        });
        for (const [key, value] of Object.entries(fields)) {
          if (value === void 0) {
            continue;
          }
          const stringifiedValue = serialize(value, `Serializing ${key} for multipart ingestion of run with id: ${payload.id}`);
          accumulatedParts.push({
            name: `${method}.${payload.id}.${key}`,
            payload: new Blob([stringifiedValue], {
              type: `application/json; length=${stringifiedValue.length}`
            })
          });
        }
        if (payload.id !== void 0) {
          const attachments2 = allAttachments[payload.id];
          if (attachments2) {
            delete allAttachments[payload.id];
            for (const [name, attachment] of Object.entries(attachments2)) {
              let contentType;
              let content;
              if (Array.isArray(attachment)) {
                [contentType, content] = attachment;
              } else {
                contentType = attachment.mimeType;
                content = attachment.data;
              }
              if (name.includes(".")) {
                console.warn(`Skipping attachment '${name}' for run ${payload.id}: Invalid attachment name. Attachment names must not contain periods ('.'). Please rename the attachment and try again.`);
                continue;
              }
              accumulatedParts.push({
                name: `attachment.${payload.id}.${name}`,
                payload: new Blob([content], {
                  type: `${contentType}; length=${content.byteLength}`
                })
              });
            }
          }
        }
        accumulatedContext.push(`trace=${payload.trace_id},id=${payload.id}`);
      }
    }
    await this._sendMultipartRequest(accumulatedParts, accumulatedContext.join("; "), options2);
  }
  async _createNodeFetchBody(parts, boundary) {
    const chunks = [];
    for (const part of parts) {
      chunks.push(new Blob([`--${boundary}\r
`]));
      chunks.push(new Blob([
        `Content-Disposition: form-data; name="${part.name}"\r
`,
        `Content-Type: ${part.payload.type}\r
\r
`
      ]));
      chunks.push(part.payload);
      chunks.push(new Blob(["\r\n"]));
    }
    chunks.push(new Blob([`--${boundary}--\r
`]));
    const body = new Blob(chunks);
    const arrayBuffer = await body.arrayBuffer();
    return arrayBuffer;
  }
  async _createMultipartStream(parts, boundary) {
    const encoder2 = new TextEncoder();
    const stream = new ReadableStream({
      async start(controller) {
        const writeChunk = async (chunk) => {
          if (typeof chunk === "string") {
            controller.enqueue(encoder2.encode(chunk));
          } else {
            controller.enqueue(chunk);
          }
        };
        for (const part of parts) {
          await writeChunk(`--${boundary}\r
`);
          await writeChunk(`Content-Disposition: form-data; name="${part.name}"\r
`);
          await writeChunk(`Content-Type: ${part.payload.type}\r
\r
`);
          const payloadStream = part.payload.stream();
          const reader = payloadStream.getReader();
          try {
            let result;
            while (!(result = await reader.read()).done) {
              controller.enqueue(result.value);
            }
          } finally {
            reader.releaseLock();
          }
          await writeChunk("\r\n");
        }
        await writeChunk(`--${boundary}--\r
`);
        controller.close();
      }
    });
    return stream;
  }
  async _sendMultipartRequest(parts, context, options2) {
    const boundary = "----LangSmithFormBoundary" + Math.random().toString(36).slice(2);
    const isNodeFetch = _globalFetchImplementationIsNodeFetch();
    const buildBuffered = () => this._createNodeFetchBody(parts, boundary);
    const buildStream = () => this._createMultipartStream(parts, boundary);
    const sendWithRetry = async (bodyFactory) => {
      return this.batchIngestCaller.callWithOptions({ sizeBytes: options2 == null ? void 0 : options2.sizeBytes }, async () => {
        const body = await bodyFactory();
        const headers = {
          ...this.headers,
          "Content-Type": `multipart/form-data; boundary=${boundary}`
        };
        if ((options2 == null ? void 0 : options2.apiKey) !== void 0) {
          headers["x-api-key"] = options2.apiKey;
        }
        let transformedBody = body;
        if ((options2 == null ? void 0 : options2.useGzip) && typeof body === "object" && "pipeThrough" in body) {
          transformedBody = body.pipeThrough(new CompressionStream("gzip"));
          headers["Content-Encoding"] = "gzip";
        }
        const response = await this._fetch(`${(options2 == null ? void 0 : options2.apiUrl) ?? this.apiUrl}/runs/multipart`, {
          method: "POST",
          headers,
          body: transformedBody,
          duplex: "half",
          signal: AbortSignal.timeout(this.timeout_ms),
          ...this.fetchOptions
        });
        await raiseForStatus(response, `Failed to send multipart request`, true);
        return response;
      });
    };
    try {
      let res;
      let streamedAttempt = false;
      if (!isNodeFetch && !this.multipartStreamingDisabled && getEnv() !== "bun") {
        streamedAttempt = true;
        res = await sendWithRetry(buildStream);
      } else {
        res = await sendWithRetry(buildBuffered);
      }
      if ((!this.multipartStreamingDisabled || streamedAttempt) && res.status === 422 && ((options2 == null ? void 0 : options2.apiUrl) ?? this.apiUrl) !== DEFAULT_API_URL) {
        console.warn(`Streaming multipart upload to ${(options2 == null ? void 0 : options2.apiUrl) ?? this.apiUrl}/runs/multipart failed. This usually means the host does not support chunked uploads. Retrying with a buffered upload for operation "${context}".`);
        this.multipartStreamingDisabled = true;
        res = await sendWithRetry(buildBuffered);
      }
    } catch (e) {
      console.warn(`${e.message.trim()}

Context: ${context}`);
    }
  }
  async updateRun(runId, run, options2) {
    assertUuid(runId);
    if (run.inputs) {
      run.inputs = await this.processInputs(run.inputs);
    }
    if (run.outputs) {
      run.outputs = await this.processOutputs(run.outputs);
    }
    const data = { ...run, id: runId };
    if (!this._filterForSampling([data], true).length) {
      return;
    }
    if (this.autoBatchTracing && data.trace_id !== void 0 && data.dotted_order !== void 0) {
      const otelContext = this._cloneCurrentOTELContext();
      if (run.end_time !== void 0 && data.parent_run_id === void 0 && this.blockOnRootRunFinalization && !this.manualFlushMode) {
        await this.processRunOperation({
          action: "update",
          item: data,
          otelContext,
          apiKey: options2 == null ? void 0 : options2.apiKey,
          apiUrl: options2 == null ? void 0 : options2.apiUrl
        }).catch(console.error);
        return;
      } else {
        void this.processRunOperation({
          action: "update",
          item: data,
          otelContext,
          apiKey: options2 == null ? void 0 : options2.apiKey,
          apiUrl: options2 == null ? void 0 : options2.apiUrl
        }).catch(console.error);
      }
      return;
    }
    const headers = {
      ...this.headers,
      "Content-Type": "application/json"
    };
    if ((options2 == null ? void 0 : options2.apiKey) !== void 0) {
      headers["x-api-key"] = options2.apiKey;
    }
    if ((options2 == null ? void 0 : options2.workspaceId) !== void 0) {
      headers["x-tenant-id"] = options2.workspaceId;
    }
    const body = serialize(run, `Serializing payload to update run with id: ${runId}`);
    await this.caller.call(async () => {
      const res = await this._fetch(`${(options2 == null ? void 0 : options2.apiUrl) ?? this.apiUrl}/runs/${runId}`, {
        method: "PATCH",
        headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body
      });
      await raiseForStatus(res, "update run", true);
      return res;
    });
  }
  async readRun(runId, { loadChildRuns } = { loadChildRuns: false }) {
    assertUuid(runId);
    let run = await this._get(`/runs/${runId}`);
    if (loadChildRuns) {
      run = await this._loadChildRuns(run);
    }
    return run;
  }
  async getRunUrl({ runId, run, projectOpts }) {
    if (run !== void 0) {
      let sessionId;
      if (run.session_id) {
        sessionId = run.session_id;
      } else if (projectOpts == null ? void 0 : projectOpts.projectName) {
        sessionId = (await this.readProject({ projectName: projectOpts == null ? void 0 : projectOpts.projectName })).id;
      } else if (projectOpts == null ? void 0 : projectOpts.projectId) {
        sessionId = projectOpts == null ? void 0 : projectOpts.projectId;
      } else {
        const project = await this.readProject({
          projectName: getLangSmithEnvironmentVariable("PROJECT") || "default"
        });
        sessionId = project.id;
      }
      const tenantId = await this._getTenantId();
      return `${this.getHostUrl()}/o/${tenantId}/projects/p/${sessionId}/r/${run.id}?poll=true`;
    } else if (runId !== void 0) {
      const run_ = await this.readRun(runId);
      if (!run_.app_path) {
        throw new Error(`Run ${runId} has no app_path`);
      }
      const baseUrl = this.getHostUrl();
      return `${baseUrl}${run_.app_path}`;
    } else {
      throw new Error("Must provide either runId or run");
    }
  }
  async _loadChildRuns(run) {
    var _a3;
    const childRuns = await toArray(this.listRuns({
      isRoot: false,
      projectId: run.session_id,
      traceId: run.trace_id
    }));
    const treemap = {};
    const runs = {};
    childRuns.sort((a, b) => ((a == null ? void 0 : a.dotted_order) ?? "").localeCompare((b == null ? void 0 : b.dotted_order) ?? ""));
    for (const childRun of childRuns) {
      if (childRun.parent_run_id === null || childRun.parent_run_id === void 0) {
        throw new Error(`Child run ${childRun.id} has no parent`);
      }
      if (((_a3 = childRun.dotted_order) == null ? void 0 : _a3.startsWith(run.dotted_order ?? "")) && childRun.id !== run.id) {
        if (!(childRun.parent_run_id in treemap)) {
          treemap[childRun.parent_run_id] = [];
        }
        treemap[childRun.parent_run_id].push(childRun);
        runs[childRun.id] = childRun;
      }
    }
    run.child_runs = treemap[run.id] || [];
    for (const runId in treemap) {
      if (runId !== run.id) {
        runs[runId].child_runs = treemap[runId];
      }
    }
    return run;
  }
  /**
   * List runs from the LangSmith server.
   * @param projectId - The ID of the project to filter by.
   * @param projectName - The name of the project to filter by.
   * @param parentRunId - The ID of the parent run to filter by.
   * @param traceId - The ID of the trace to filter by.
   * @param referenceExampleId - The ID of the reference example to filter by.
   * @param startTime - The start time to filter by.
   * @param isRoot - Indicates whether to only return root runs.
   * @param runType - The run type to filter by.
   * @param error - Indicates whether to filter by error runs.
   * @param id - The ID of the run to filter by.
   * @param query - The query string to filter by.
   * @param filter - The filter string to apply to the run spans.
   * @param traceFilter - The filter string to apply on the root run of the trace.
   * @param treeFilter - The filter string to apply on other runs in the trace.
   * @param limit - The maximum number of runs to retrieve.
   * @returns {AsyncIterable<Run>} - The runs.
   *
   * @example
   * // List all runs in a project
   * const projectRuns = client.listRuns({ projectName: "<your_project>" });
   *
   * @example
   * // List LLM and Chat runs in the last 24 hours
   * const todaysLLMRuns = client.listRuns({
   *   projectName: "<your_project>",
   *   start_time: new Date(Date.now() - 24 * 60 * 60 * 1000),
   *   run_type: "llm",
   * });
   *
   * @example
   * // List traces in a project
   * const rootRuns = client.listRuns({
   *   projectName: "<your_project>",
   *   execution_order: 1,
   * });
   *
   * @example
   * // List runs without errors
   * const correctRuns = client.listRuns({
   *   projectName: "<your_project>",
   *   error: false,
   * });
   *
   * @example
   * // List runs by run ID
   * const runIds = [
   *   "a36092d2-4ad5-4fb4-9c0d-0dba9a2ed836",
   *   "9398e6be-964f-4aa4-8ae9-ad78cd4b7074",
   * ];
   * const selectedRuns = client.listRuns({ run_ids: runIds });
   *
   * @example
   * // List all "chain" type runs that took more than 10 seconds and had `total_tokens` greater than 5000
   * const chainRuns = client.listRuns({
   *   projectName: "<your_project>",
   *   filter: 'and(eq(run_type, "chain"), gt(latency, 10), gt(total_tokens, 5000))',
   * });
   *
   * @example
   * // List all runs called "extractor" whose root of the trace was assigned feedback "user_score" score of 1
   * const goodExtractorRuns = client.listRuns({
   *   projectName: "<your_project>",
   *   filter: 'eq(name, "extractor")',
   *   traceFilter: 'and(eq(feedback_key, "user_score"), eq(feedback_score, 1))',
   * });
   *
   * @example
   * // List all runs that started after a specific timestamp and either have "error" not equal to null or a "Correctness" feedback score equal to 0
   * const complexRuns = client.listRuns({
   *   projectName: "<your_project>",
   *   filter: 'and(gt(start_time, "2023-07-15T12:34:56Z"), or(neq(error, null), and(eq(feedback_key, "Correctness"), eq(feedback_score, 0.0))))',
   * });
   *
   * @example
   * // List all runs where `tags` include "experimental" or "beta" and `latency` is greater than 2 seconds
   * const taggedRuns = client.listRuns({
   *   projectName: "<your_project>",
   *   filter: 'and(or(has(tags, "experimental"), has(tags, "beta")), gt(latency, 2))',
   * });
   */
  async *listRuns(props) {
    const { projectId, projectName, parentRunId, traceId, referenceExampleId, startTime: startTime2, executionOrder, isRoot, runType, error, id, query, filter, traceFilter, treeFilter, limit: limit2, select, order } = props;
    let projectIds = [];
    if (projectId) {
      projectIds = Array.isArray(projectId) ? projectId : [projectId];
    }
    if (projectName) {
      const projectNames = Array.isArray(projectName) ? projectName : [projectName];
      const projectIds_ = await Promise.all(projectNames.map((name) => this.readProject({ projectName: name }).then((project) => project.id)));
      projectIds.push(...projectIds_);
    }
    const default_select = [
      "app_path",
      "completion_cost",
      "completion_tokens",
      "dotted_order",
      "end_time",
      "error",
      "events",
      "extra",
      "feedback_stats",
      "first_token_time",
      "id",
      "inputs",
      "name",
      "outputs",
      "parent_run_id",
      "parent_run_ids",
      "prompt_cost",
      "prompt_tokens",
      "reference_example_id",
      "run_type",
      "session_id",
      "start_time",
      "status",
      "tags",
      "total_cost",
      "total_tokens",
      "trace_id"
    ];
    const body = {
      session: projectIds.length ? projectIds : null,
      run_type: runType,
      reference_example: referenceExampleId,
      query,
      filter,
      trace_filter: traceFilter,
      tree_filter: treeFilter,
      execution_order: executionOrder,
      parent_run: parentRunId,
      start_time: startTime2 ? startTime2.toISOString() : null,
      error,
      id,
      limit: limit2,
      trace: traceId,
      select: select ? select : default_select,
      is_root: isRoot,
      order
    };
    if (body.select.includes("child_run_ids")) {
      warnOnce("Deprecated: 'child_run_ids' in the listRuns select parameter is deprecated and will be removed in a future version.");
    }
    let runsYielded = 0;
    for await (const runs of this._getCursorPaginatedList("/runs/query", body)) {
      if (limit2) {
        if (runsYielded >= limit2) {
          break;
        }
        if (runs.length + runsYielded > limit2) {
          const newRuns = runs.slice(0, limit2 - runsYielded);
          yield* newRuns;
          break;
        }
        runsYielded += runs.length;
        yield* runs;
      } else {
        yield* runs;
      }
    }
  }
  async *listGroupRuns(props) {
    const { projectId, projectName, groupBy, filter, startTime: startTime2, endTime, limit: limit2, offset } = props;
    const sessionId = projectId || (await this.readProject({ projectName })).id;
    const baseBody = {
      session_id: sessionId,
      group_by: groupBy,
      filter,
      start_time: startTime2 ? startTime2.toISOString() : null,
      end_time: endTime ? endTime.toISOString() : null,
      limit: Number(limit2) || 100
    };
    let currentOffset = Number(offset) || 0;
    const path2 = "/runs/group";
    const url = `${this.apiUrl}${path2}`;
    while (true) {
      const currentBody = {
        ...baseBody,
        offset: currentOffset
      };
      const filteredPayload = Object.fromEntries(Object.entries(currentBody).filter(([_, value]) => value !== void 0));
      const body = JSON.stringify(filteredPayload);
      const response = await this.caller.call(async () => {
        const res = await this._fetch(url, {
          method: "POST",
          headers: { ...this.headers, "Content-Type": "application/json" },
          signal: AbortSignal.timeout(this.timeout_ms),
          ...this.fetchOptions,
          body
        });
        await raiseForStatus(res, `Failed to fetch ${path2}`);
        return res;
      });
      const items = await response.json();
      const { groups, total } = items;
      if (groups.length === 0) {
        break;
      }
      for (const thread of groups) {
        yield thread;
      }
      currentOffset += groups.length;
      if (currentOffset >= total) {
        break;
      }
    }
  }
  async getRunStats({ id, trace, parentRun, runType, projectNames, projectIds, referenceExampleIds, startTime: startTime2, endTime, error, query, filter, traceFilter, treeFilter, isRoot, dataSourceType }) {
    let projectIds_ = projectIds || [];
    if (projectNames) {
      projectIds_ = [
        ...projectIds || [],
        ...await Promise.all(projectNames.map((name) => this.readProject({ projectName: name }).then((project) => project.id)))
      ];
    }
    const payload = {
      id,
      trace,
      parent_run: parentRun,
      run_type: runType,
      session: projectIds_,
      reference_example: referenceExampleIds,
      start_time: startTime2,
      end_time: endTime,
      error,
      query,
      filter,
      trace_filter: traceFilter,
      tree_filter: treeFilter,
      is_root: isRoot,
      data_source_type: dataSourceType
    };
    const filteredPayload = Object.fromEntries(Object.entries(payload).filter(([_, value]) => value !== void 0));
    const body = JSON.stringify(filteredPayload);
    const response = await this.caller.call(async () => {
      const res = await this._fetch(`${this.apiUrl}/runs/stats`, {
        method: "POST",
        headers: { ...this.headers, "Content-Type": "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body
      });
      await raiseForStatus(res, "get run stats");
      return res;
    });
    const result = await response.json();
    return result;
  }
  async shareRun(runId, { shareId } = {}) {
    const data = {
      run_id: runId,
      share_token: shareId || v4()
    };
    assertUuid(runId);
    const body = JSON.stringify(data);
    const response = await this.caller.call(async () => {
      const res = await this._fetch(`${this.apiUrl}/runs/${runId}/share`, {
        method: "PUT",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body
      });
      await raiseForStatus(res, "share run");
      return res;
    });
    const result = await response.json();
    if (result === null || !("share_token" in result)) {
      throw new Error("Invalid response from server");
    }
    return `${this.getHostUrl()}/public/${result["share_token"]}/r`;
  }
  async unshareRun(runId) {
    assertUuid(runId);
    await this.caller.call(async () => {
      const res = await this._fetch(`${this.apiUrl}/runs/${runId}/share`, {
        method: "DELETE",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await raiseForStatus(res, "unshare run", true);
      return res;
    });
  }
  async readRunSharedLink(runId) {
    assertUuid(runId);
    const response = await this.caller.call(async () => {
      const res = await this._fetch(`${this.apiUrl}/runs/${runId}/share`, {
        method: "GET",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await raiseForStatus(res, "read run shared link");
      return res;
    });
    const result = await response.json();
    if (result === null || !("share_token" in result)) {
      return void 0;
    }
    return `${this.getHostUrl()}/public/${result["share_token"]}/r`;
  }
  async listSharedRuns(shareToken, { runIds } = {}) {
    const queryParams = new URLSearchParams({
      share_token: shareToken
    });
    if (runIds !== void 0) {
      for (const runId of runIds) {
        queryParams.append("id", runId);
      }
    }
    assertUuid(shareToken);
    const response = await this.caller.call(async () => {
      const res = await this._fetch(`${this.apiUrl}/public/${shareToken}/runs${queryParams}`, {
        method: "GET",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await raiseForStatus(res, "list shared runs");
      return res;
    });
    const runs = await response.json();
    return runs;
  }
  async readDatasetSharedSchema(datasetId, datasetName) {
    if (!datasetId && !datasetName) {
      throw new Error("Either datasetId or datasetName must be given");
    }
    if (!datasetId) {
      const dataset = await this.readDataset({ datasetName });
      datasetId = dataset.id;
    }
    assertUuid(datasetId);
    const response = await this.caller.call(async () => {
      const res = await this._fetch(`${this.apiUrl}/datasets/${datasetId}/share`, {
        method: "GET",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await raiseForStatus(res, "read dataset shared schema");
      return res;
    });
    const shareSchema = await response.json();
    shareSchema.url = `${this.getHostUrl()}/public/${shareSchema.share_token}/d`;
    return shareSchema;
  }
  async shareDataset(datasetId, datasetName) {
    if (!datasetId && !datasetName) {
      throw new Error("Either datasetId or datasetName must be given");
    }
    if (!datasetId) {
      const dataset = await this.readDataset({ datasetName });
      datasetId = dataset.id;
    }
    const data = {
      dataset_id: datasetId
    };
    assertUuid(datasetId);
    const body = JSON.stringify(data);
    const response = await this.caller.call(async () => {
      const res = await this._fetch(`${this.apiUrl}/datasets/${datasetId}/share`, {
        method: "PUT",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body
      });
      await raiseForStatus(res, "share dataset");
      return res;
    });
    const shareSchema = await response.json();
    shareSchema.url = `${this.getHostUrl()}/public/${shareSchema.share_token}/d`;
    return shareSchema;
  }
  async unshareDataset(datasetId) {
    assertUuid(datasetId);
    await this.caller.call(async () => {
      const res = await this._fetch(`${this.apiUrl}/datasets/${datasetId}/share`, {
        method: "DELETE",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await raiseForStatus(res, "unshare dataset", true);
      return res;
    });
  }
  async readSharedDataset(shareToken) {
    assertUuid(shareToken);
    const response = await this.caller.call(async () => {
      const res = await this._fetch(`${this.apiUrl}/public/${shareToken}/datasets`, {
        method: "GET",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await raiseForStatus(res, "read shared dataset");
      return res;
    });
    const dataset = await response.json();
    return dataset;
  }
  /**
   * Get shared examples.
   *
   * @param {string} shareToken The share token to get examples for. A share token is the UUID (or LangSmith URL, including UUID) generated when explicitly marking an example as public.
   * @param {Object} [options] Additional options for listing the examples.
   * @param {string[] | undefined} [options.exampleIds] A list of example IDs to filter by.
   * @returns {Promise<Example[]>} The shared examples.
   */
  async listSharedExamples(shareToken, options2) {
    const params = {};
    if (options2 == null ? void 0 : options2.exampleIds) {
      params.id = options2.exampleIds;
    }
    const urlParams = new URLSearchParams();
    Object.entries(params).forEach(([key, value]) => {
      if (Array.isArray(value)) {
        value.forEach((v) => urlParams.append(key, v));
      } else {
        urlParams.append(key, value);
      }
    });
    const response = await this.caller.call(async () => {
      const res = await this._fetch(`${this.apiUrl}/public/${shareToken}/examples?${urlParams.toString()}`, {
        method: "GET",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await raiseForStatus(res, "list shared examples");
      return res;
    });
    const result = await response.json();
    if (!response.ok) {
      if ("detail" in result) {
        throw new Error(`Failed to list shared examples.
Status: ${response.status}
Message: ${Array.isArray(result.detail) ? result.detail.join("\n") : "Unspecified error"}`);
      }
      throw new Error(`Failed to list shared examples: ${response.status} ${response.statusText}`);
    }
    return result.map((example) => ({
      ...example,
      _hostUrl: this.getHostUrl()
    }));
  }
  async createProject({ projectName, description = null, metadata = null, upsert = false, projectExtra = null, referenceDatasetId = null }) {
    const upsert_ = upsert ? `?upsert=true` : "";
    const endpoint = `${this.apiUrl}/sessions${upsert_}`;
    const extra = projectExtra || {};
    if (metadata) {
      extra["metadata"] = metadata;
    }
    const body = {
      name: projectName,
      extra,
      description
    };
    if (referenceDatasetId !== null) {
      body["reference_dataset_id"] = referenceDatasetId;
    }
    const serializedBody = JSON.stringify(body);
    const response = await this.caller.call(async () => {
      const res = await this._fetch(endpoint, {
        method: "POST",
        headers: { ...this.headers, "Content-Type": "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: serializedBody
      });
      await raiseForStatus(res, "create project");
      return res;
    });
    const result = await response.json();
    return result;
  }
  async updateProject(projectId, { name = null, description = null, metadata = null, projectExtra = null, endTime = null }) {
    const endpoint = `${this.apiUrl}/sessions/${projectId}`;
    let extra = projectExtra;
    if (metadata) {
      extra = { ...extra || {}, metadata };
    }
    const body = JSON.stringify({
      name,
      extra,
      description,
      end_time: endTime ? new Date(endTime).toISOString() : null
    });
    const response = await this.caller.call(async () => {
      const res = await this._fetch(endpoint, {
        method: "PATCH",
        headers: { ...this.headers, "Content-Type": "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body
      });
      await raiseForStatus(res, "update project");
      return res;
    });
    const result = await response.json();
    return result;
  }
  async hasProject({ projectId, projectName }) {
    let path2 = "/sessions";
    const params = new URLSearchParams();
    if (projectId !== void 0 && projectName !== void 0) {
      throw new Error("Must provide either projectName or projectId, not both");
    } else if (projectId !== void 0) {
      assertUuid(projectId);
      path2 += `/${projectId}`;
    } else if (projectName !== void 0) {
      params.append("name", projectName);
    } else {
      throw new Error("Must provide projectName or projectId");
    }
    const response = await this.caller.call(async () => {
      const res = await this._fetch(`${this.apiUrl}${path2}?${params}`, {
        method: "GET",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await raiseForStatus(res, "has project");
      return res;
    });
    try {
      const result = await response.json();
      if (!response.ok) {
        return false;
      }
      if (Array.isArray(result)) {
        return result.length > 0;
      }
      return true;
    } catch (e) {
      return false;
    }
  }
  async readProject({ projectId, projectName, includeStats }) {
    let path2 = "/sessions";
    const params = new URLSearchParams();
    if (projectId !== void 0 && projectName !== void 0) {
      throw new Error("Must provide either projectName or projectId, not both");
    } else if (projectId !== void 0) {
      assertUuid(projectId);
      path2 += `/${projectId}`;
    } else if (projectName !== void 0) {
      params.append("name", projectName);
    } else {
      throw new Error("Must provide projectName or projectId");
    }
    if (includeStats !== void 0) {
      params.append("include_stats", includeStats.toString());
    }
    const response = await this._get(path2, params);
    let result;
    if (Array.isArray(response)) {
      if (response.length === 0) {
        throw new Error(`Project[id=${projectId}, name=${projectName}] not found`);
      }
      result = response[0];
    } else {
      result = response;
    }
    return result;
  }
  async getProjectUrl({ projectId, projectName }) {
    if (projectId === void 0 && projectName === void 0) {
      throw new Error("Must provide either projectName or projectId");
    }
    const project = await this.readProject({ projectId, projectName });
    const tenantId = await this._getTenantId();
    return `${this.getHostUrl()}/o/${tenantId}/projects/p/${project.id}`;
  }
  async getDatasetUrl({ datasetId, datasetName }) {
    if (datasetId === void 0 && datasetName === void 0) {
      throw new Error("Must provide either datasetName or datasetId");
    }
    const dataset = await this.readDataset({ datasetId, datasetName });
    const tenantId = await this._getTenantId();
    return `${this.getHostUrl()}/o/${tenantId}/datasets/${dataset.id}`;
  }
  async _getTenantId() {
    if (this._tenantId !== null) {
      return this._tenantId;
    }
    const queryParams = new URLSearchParams({ limit: "1" });
    for await (const projects of this._getPaginated("/sessions", queryParams)) {
      this._tenantId = projects[0].tenant_id;
      return projects[0].tenant_id;
    }
    throw new Error("No projects found to resolve tenant.");
  }
  async *listProjects({ projectIds, name, nameContains, referenceDatasetId, referenceDatasetName, includeStats, datasetVersion, referenceFree, metadata } = {}) {
    const params = new URLSearchParams();
    if (projectIds !== void 0) {
      for (const projectId of projectIds) {
        params.append("id", projectId);
      }
    }
    if (name !== void 0) {
      params.append("name", name);
    }
    if (nameContains !== void 0) {
      params.append("name_contains", nameContains);
    }
    if (referenceDatasetId !== void 0) {
      params.append("reference_dataset", referenceDatasetId);
    } else if (referenceDatasetName !== void 0) {
      const dataset = await this.readDataset({
        datasetName: referenceDatasetName
      });
      params.append("reference_dataset", dataset.id);
    }
    if (includeStats !== void 0) {
      params.append("include_stats", includeStats.toString());
    }
    if (datasetVersion !== void 0) {
      params.append("dataset_version", datasetVersion);
    }
    if (referenceFree !== void 0) {
      params.append("reference_free", referenceFree.toString());
    }
    if (metadata !== void 0) {
      params.append("metadata", JSON.stringify(metadata));
    }
    for await (const projects of this._getPaginated("/sessions", params)) {
      yield* projects;
    }
  }
  async deleteProject({ projectId, projectName }) {
    let projectId_;
    if (projectId === void 0 && projectName === void 0) {
      throw new Error("Must provide projectName or projectId");
    } else if (projectId !== void 0 && projectName !== void 0) {
      throw new Error("Must provide either projectName or projectId, not both");
    } else if (projectId === void 0) {
      projectId_ = (await this.readProject({ projectName })).id;
    } else {
      projectId_ = projectId;
    }
    assertUuid(projectId_);
    await this.caller.call(async () => {
      const res = await this._fetch(`${this.apiUrl}/sessions/${projectId_}`, {
        method: "DELETE",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await raiseForStatus(res, `delete session ${projectId_} (${projectName})`, true);
      return res;
    });
  }
  async uploadCsv({ csvFile, fileName, inputKeys, outputKeys, description, dataType, name }) {
    const url = `${this.apiUrl}/datasets/upload`;
    const formData = new FormData();
    formData.append("file", csvFile, fileName);
    inputKeys.forEach((key) => {
      formData.append("input_keys", key);
    });
    outputKeys.forEach((key) => {
      formData.append("output_keys", key);
    });
    if (description) {
      formData.append("description", description);
    }
    if (dataType) {
      formData.append("data_type", dataType);
    }
    if (name) {
      formData.append("name", name);
    }
    const response = await this.caller.call(async () => {
      const res = await this._fetch(url, {
        method: "POST",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: formData
      });
      await raiseForStatus(res, "upload CSV");
      return res;
    });
    const result = await response.json();
    return result;
  }
  async createDataset(name, { description, dataType, inputsSchema, outputsSchema, metadata } = {}) {
    const body = {
      name,
      description,
      extra: metadata ? { metadata } : void 0
    };
    if (dataType) {
      body.data_type = dataType;
    }
    if (inputsSchema) {
      body.inputs_schema_definition = inputsSchema;
    }
    if (outputsSchema) {
      body.outputs_schema_definition = outputsSchema;
    }
    const serializedBody = JSON.stringify(body);
    const response = await this.caller.call(async () => {
      const res = await this._fetch(`${this.apiUrl}/datasets`, {
        method: "POST",
        headers: { ...this.headers, "Content-Type": "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: serializedBody
      });
      await raiseForStatus(res, "create dataset");
      return res;
    });
    const result = await response.json();
    return result;
  }
  async readDataset({ datasetId, datasetName }) {
    let path2 = "/datasets";
    const params = new URLSearchParams({ limit: "1" });
    if (datasetId && datasetName) {
      throw new Error("Must provide either datasetName or datasetId, not both");
    } else if (datasetId) {
      assertUuid(datasetId);
      path2 += `/${datasetId}`;
    } else if (datasetName) {
      params.append("name", datasetName);
    } else {
      throw new Error("Must provide datasetName or datasetId");
    }
    const response = await this._get(path2, params);
    let result;
    if (Array.isArray(response)) {
      if (response.length === 0) {
        throw new Error(`Dataset[id=${datasetId}, name=${datasetName}] not found`);
      }
      result = response[0];
    } else {
      result = response;
    }
    return result;
  }
  async hasDataset({ datasetId, datasetName }) {
    try {
      await this.readDataset({ datasetId, datasetName });
      return true;
    } catch (e) {
      if (
        // eslint-disable-next-line no-instanceof/no-instanceof
        e instanceof Error && e.message.toLocaleLowerCase().includes("not found")
      ) {
        return false;
      }
      throw e;
    }
  }
  async diffDatasetVersions({ datasetId, datasetName, fromVersion, toVersion }) {
    let datasetId_ = datasetId;
    if (datasetId_ === void 0 && datasetName === void 0) {
      throw new Error("Must provide either datasetName or datasetId");
    } else if (datasetId_ !== void 0 && datasetName !== void 0) {
      throw new Error("Must provide either datasetName or datasetId, not both");
    } else if (datasetId_ === void 0) {
      const dataset = await this.readDataset({ datasetName });
      datasetId_ = dataset.id;
    }
    const urlParams = new URLSearchParams({
      from_version: typeof fromVersion === "string" ? fromVersion : fromVersion.toISOString(),
      to_version: typeof toVersion === "string" ? toVersion : toVersion.toISOString()
    });
    const response = await this._get(`/datasets/${datasetId_}/versions/diff`, urlParams);
    return response;
  }
  async readDatasetOpenaiFinetuning({ datasetId, datasetName }) {
    const path2 = "/datasets";
    if (datasetId !== void 0) ;
    else if (datasetName !== void 0) {
      datasetId = (await this.readDataset({ datasetName })).id;
    } else {
      throw new Error("Must provide either datasetName or datasetId");
    }
    const response = await this._getResponse(`${path2}/${datasetId}/openai_ft`);
    const datasetText = await response.text();
    const dataset = datasetText.trim().split("\n").map((line) => JSON.parse(line));
    return dataset;
  }
  async *listDatasets({ limit: limit2 = 100, offset = 0, datasetIds, datasetName, datasetNameContains, metadata } = {}) {
    const path2 = "/datasets";
    const params = new URLSearchParams({
      limit: limit2.toString(),
      offset: offset.toString()
    });
    if (datasetIds !== void 0) {
      for (const id_ of datasetIds) {
        params.append("id", id_);
      }
    }
    if (datasetName !== void 0) {
      params.append("name", datasetName);
    }
    if (datasetNameContains !== void 0) {
      params.append("name_contains", datasetNameContains);
    }
    if (metadata !== void 0) {
      params.append("metadata", JSON.stringify(metadata));
    }
    for await (const datasets of this._getPaginated(path2, params)) {
      yield* datasets;
    }
  }
  /**
   * Update a dataset
   * @param props The dataset details to update
   * @returns The updated dataset
   */
  async updateDataset(props) {
    const { datasetId, datasetName, ...update } = props;
    if (!datasetId && !datasetName) {
      throw new Error("Must provide either datasetName or datasetId");
    }
    const _datasetId = datasetId ?? (await this.readDataset({ datasetName })).id;
    assertUuid(_datasetId);
    const body = JSON.stringify(update);
    const response = await this.caller.call(async () => {
      const res = await this._fetch(`${this.apiUrl}/datasets/${_datasetId}`, {
        method: "PATCH",
        headers: { ...this.headers, "Content-Type": "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body
      });
      await raiseForStatus(res, "update dataset");
      return res;
    });
    return await response.json();
  }
  /**
   * Updates a tag on a dataset.
   *
   * If the tag is already assigned to a different version of this dataset,
   * the tag will be moved to the new version. The as_of parameter is used to
   * determine which version of the dataset to apply the new tags to.
   *
   * It must be an exact version of the dataset to succeed. You can
   * use the "readDatasetVersion" method to find the exact version
   * to apply the tags to.
   * @param params.datasetId The ID of the dataset to update. Must be provided if "datasetName" is not provided.
   * @param params.datasetName The name of the dataset to update. Must be provided if "datasetId" is not provided.
   * @param params.asOf The timestamp of the dataset to apply the new tags to.
   * @param params.tag The new tag to apply to the dataset.
   */
  async updateDatasetTag(props) {
    const { datasetId, datasetName, asOf, tag } = props;
    if (!datasetId && !datasetName) {
      throw new Error("Must provide either datasetName or datasetId");
    }
    const _datasetId = datasetId ?? (await this.readDataset({ datasetName })).id;
    assertUuid(_datasetId);
    const body = JSON.stringify({
      as_of: typeof asOf === "string" ? asOf : asOf.toISOString(),
      tag
    });
    await this.caller.call(async () => {
      const res = await this._fetch(`${this.apiUrl}/datasets/${_datasetId}/tags`, {
        method: "PUT",
        headers: { ...this.headers, "Content-Type": "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body
      });
      await raiseForStatus(res, "update dataset tags", true);
      return res;
    });
  }
  async deleteDataset({ datasetId, datasetName }) {
    let path2 = "/datasets";
    let datasetId_ = datasetId;
    if (datasetId !== void 0 && datasetName !== void 0) {
      throw new Error("Must provide either datasetName or datasetId, not both");
    } else if (datasetName !== void 0) {
      const dataset = await this.readDataset({ datasetName });
      datasetId_ = dataset.id;
    }
    if (datasetId_ !== void 0) {
      assertUuid(datasetId_);
      path2 += `/${datasetId_}`;
    } else {
      throw new Error("Must provide datasetName or datasetId");
    }
    await this.caller.call(async () => {
      const res = await this._fetch(this.apiUrl + path2, {
        method: "DELETE",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await raiseForStatus(res, `delete ${path2}`, true);
      return res;
    });
  }
  async indexDataset({ datasetId, datasetName, tag }) {
    let datasetId_ = datasetId;
    if (!datasetId_ && !datasetName) {
      throw new Error("Must provide either datasetName or datasetId");
    } else if (datasetId_ && datasetName) {
      throw new Error("Must provide either datasetName or datasetId, not both");
    } else if (!datasetId_) {
      const dataset = await this.readDataset({ datasetName });
      datasetId_ = dataset.id;
    }
    assertUuid(datasetId_);
    const data = {
      tag
    };
    const body = JSON.stringify(data);
    const response = await this.caller.call(async () => {
      const res = await this._fetch(`${this.apiUrl}/datasets/${datasetId_}/index`, {
        method: "POST",
        headers: { ...this.headers, "Content-Type": "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body
      });
      await raiseForStatus(res, "index dataset");
      return res;
    });
    await response.json();
  }
  /**
   * Lets you run a similarity search query on a dataset.
   *
   * Requires the dataset to be indexed. Please see the `indexDataset` method to set up indexing.
   *
   * @param inputs      The input on which to run the similarity search. Must have the
   *                    same schema as the dataset.
   *
   * @param datasetId   The dataset to search for similar examples.
   *
   * @param limit       The maximum number of examples to return. Will return the top `limit` most
   *                    similar examples in order of most similar to least similar. If no similar
   *                    examples are found, random examples will be returned.
   *
   * @param filter      A filter string to apply to the search. Only examples will be returned that
   *                    match the filter string. Some examples of filters
   *
   *                    - eq(metadata.mykey, "value")
   *                    - and(neq(metadata.my.nested.key, "value"), neq(metadata.mykey, "value"))
   *                    - or(eq(metadata.mykey, "value"), eq(metadata.mykey, "othervalue"))
   *
   * @returns           A list of similar examples.
   *
   *
   * @example
   * dataset_id = "123e4567-e89b-12d3-a456-426614174000"
   * inputs = {"text": "How many people live in Berlin?"}
   * limit = 5
   * examples = await client.similarExamples(inputs, dataset_id, limit)
   */
  async similarExamples(inputs, datasetId, limit2, { filter } = {}) {
    const data = {
      limit: limit2,
      inputs
    };
    if (filter !== void 0) {
      data["filter"] = filter;
    }
    assertUuid(datasetId);
    const body = JSON.stringify(data);
    const response = await this.caller.call(async () => {
      const res = await this._fetch(`${this.apiUrl}/datasets/${datasetId}/search`, {
        headers: { ...this.headers, "Content-Type": "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        method: "POST",
        body
      });
      await raiseForStatus(res, "fetch similar examples");
      return res;
    });
    const result = await response.json();
    return result["examples"];
  }
  async createExample(inputsOrUpdate, outputs, options2) {
    var _a3;
    if (isExampleCreate(inputsOrUpdate)) {
      if (outputs !== void 0 || options2 !== void 0) {
        throw new Error("Cannot provide outputs or options when using ExampleCreate object");
      }
    }
    let datasetId_ = outputs ? options2 == null ? void 0 : options2.datasetId : inputsOrUpdate.dataset_id;
    const datasetName_ = outputs ? options2 == null ? void 0 : options2.datasetName : inputsOrUpdate.dataset_name;
    if (datasetId_ === void 0 && datasetName_ === void 0) {
      throw new Error("Must provide either datasetName or datasetId");
    } else if (datasetId_ !== void 0 && datasetName_ !== void 0) {
      throw new Error("Must provide either datasetName or datasetId, not both");
    } else if (datasetId_ === void 0) {
      const dataset = await this.readDataset({ datasetName: datasetName_ });
      datasetId_ = dataset.id;
    }
    const createdAt_ = (outputs ? options2 == null ? void 0 : options2.createdAt : inputsOrUpdate.created_at) || /* @__PURE__ */ new Date();
    let data;
    if (!isExampleCreate(inputsOrUpdate)) {
      data = {
        inputs: inputsOrUpdate,
        outputs,
        created_at: createdAt_ == null ? void 0 : createdAt_.toISOString(),
        id: options2 == null ? void 0 : options2.exampleId,
        metadata: options2 == null ? void 0 : options2.metadata,
        split: options2 == null ? void 0 : options2.split,
        source_run_id: options2 == null ? void 0 : options2.sourceRunId,
        use_source_run_io: options2 == null ? void 0 : options2.useSourceRunIO,
        use_source_run_attachments: options2 == null ? void 0 : options2.useSourceRunAttachments,
        attachments: options2 == null ? void 0 : options2.attachments
      };
    } else {
      data = inputsOrUpdate;
    }
    const response = await this._uploadExamplesMultipart(datasetId_, [data]);
    const example = await this.readExample(((_a3 = response.example_ids) == null ? void 0 : _a3[0]) ?? v4());
    return example;
  }
  async createExamples(propsOrUploads) {
    if (Array.isArray(propsOrUploads)) {
      if (propsOrUploads.length === 0) {
        return [];
      }
      const uploads = propsOrUploads;
      let datasetId_2 = uploads[0].dataset_id;
      const datasetName_2 = uploads[0].dataset_name;
      if (datasetId_2 === void 0 && datasetName_2 === void 0) {
        throw new Error("Must provide either datasetName or datasetId");
      } else if (datasetId_2 !== void 0 && datasetName_2 !== void 0) {
        throw new Error("Must provide either datasetName or datasetId, not both");
      } else if (datasetId_2 === void 0) {
        const dataset = await this.readDataset({ datasetName: datasetName_2 });
        datasetId_2 = dataset.id;
      }
      const response2 = await this._uploadExamplesMultipart(datasetId_2, uploads);
      const examples2 = await Promise.all(response2.example_ids.map((id) => this.readExample(id)));
      return examples2;
    }
    const { inputs, outputs, metadata, splits, sourceRunIds, useSourceRunIOs, useSourceRunAttachments, attachments, exampleIds, datasetId, datasetName } = propsOrUploads;
    if (inputs === void 0) {
      throw new Error("Must provide inputs when using legacy parameters");
    }
    let datasetId_ = datasetId;
    const datasetName_ = datasetName;
    if (datasetId_ === void 0 && datasetName_ === void 0) {
      throw new Error("Must provide either datasetName or datasetId");
    } else if (datasetId_ !== void 0 && datasetName_ !== void 0) {
      throw new Error("Must provide either datasetName or datasetId, not both");
    } else if (datasetId_ === void 0) {
      const dataset = await this.readDataset({ datasetName: datasetName_ });
      datasetId_ = dataset.id;
    }
    const formattedExamples = inputs.map((input, idx) => {
      return {
        dataset_id: datasetId_,
        inputs: input,
        outputs: outputs == null ? void 0 : outputs[idx],
        metadata: metadata == null ? void 0 : metadata[idx],
        split: splits == null ? void 0 : splits[idx],
        id: exampleIds == null ? void 0 : exampleIds[idx],
        attachments: attachments == null ? void 0 : attachments[idx],
        source_run_id: sourceRunIds == null ? void 0 : sourceRunIds[idx],
        use_source_run_io: useSourceRunIOs == null ? void 0 : useSourceRunIOs[idx],
        use_source_run_attachments: useSourceRunAttachments == null ? void 0 : useSourceRunAttachments[idx]
      };
    });
    const response = await this._uploadExamplesMultipart(datasetId_, formattedExamples);
    const examples = await Promise.all(response.example_ids.map((id) => this.readExample(id)));
    return examples;
  }
  async createLLMExample(input, generation, options2) {
    return this.createExample({ input }, { output: generation }, options2);
  }
  async createChatExample(input, generations, options2) {
    const finalInput = input.map((message) => {
      if (isLangChainMessage(message)) {
        return convertLangChainMessageToExample(message);
      }
      return message;
    });
    const finalOutput = isLangChainMessage(generations) ? convertLangChainMessageToExample(generations) : generations;
    return this.createExample({ input: finalInput }, { output: finalOutput }, options2);
  }
  async readExample(exampleId) {
    assertUuid(exampleId);
    const path2 = `/examples/${exampleId}`;
    const rawExample = await this._get(path2);
    const { attachment_urls, ...rest } = rawExample;
    const example = rest;
    if (attachment_urls) {
      example.attachments = Object.entries(attachment_urls).reduce((acc, [key, value]) => {
        acc[key.slice("attachment.".length)] = {
          presigned_url: value.presigned_url,
          mime_type: value.mime_type
        };
        return acc;
      }, {});
    }
    return example;
  }
  async *listExamples({ datasetId, datasetName, exampleIds, asOf, splits, inlineS3Urls, metadata, limit: limit2, offset, filter, includeAttachments } = {}) {
    let datasetId_;
    if (datasetId !== void 0 && datasetName !== void 0) {
      throw new Error("Must provide either datasetName or datasetId, not both");
    } else if (datasetId !== void 0) {
      datasetId_ = datasetId;
    } else if (datasetName !== void 0) {
      const dataset = await this.readDataset({ datasetName });
      datasetId_ = dataset.id;
    } else {
      throw new Error("Must provide a datasetName or datasetId");
    }
    const params = new URLSearchParams({ dataset: datasetId_ });
    const dataset_version = asOf ? typeof asOf === "string" ? asOf : asOf == null ? void 0 : asOf.toISOString() : void 0;
    if (dataset_version) {
      params.append("as_of", dataset_version);
    }
    const inlineS3Urls_ = inlineS3Urls ?? true;
    params.append("inline_s3_urls", inlineS3Urls_.toString());
    if (exampleIds !== void 0) {
      for (const id_ of exampleIds) {
        params.append("id", id_);
      }
    }
    if (splits !== void 0) {
      for (const split of splits) {
        params.append("splits", split);
      }
    }
    if (metadata !== void 0) {
      const serializedMetadata = JSON.stringify(metadata);
      params.append("metadata", serializedMetadata);
    }
    if (limit2 !== void 0) {
      params.append("limit", limit2.toString());
    }
    if (offset !== void 0) {
      params.append("offset", offset.toString());
    }
    if (filter !== void 0) {
      params.append("filter", filter);
    }
    if (includeAttachments === true) {
      ["attachment_urls", "outputs", "metadata"].forEach((field) => params.append("select", field));
    }
    let i2 = 0;
    for await (const rawExamples of this._getPaginated("/examples", params)) {
      for (const rawExample of rawExamples) {
        const { attachment_urls, ...rest } = rawExample;
        const example = rest;
        if (attachment_urls) {
          example.attachments = Object.entries(attachment_urls).reduce((acc, [key, value]) => {
            acc[key.slice("attachment.".length)] = {
              presigned_url: value.presigned_url,
              mime_type: value.mime_type || void 0
            };
            return acc;
          }, {});
        }
        yield example;
        i2++;
      }
      if (limit2 !== void 0 && i2 >= limit2) {
        break;
      }
    }
  }
  async deleteExample(exampleId) {
    assertUuid(exampleId);
    const path2 = `/examples/${exampleId}`;
    await this.caller.call(async () => {
      const res = await this._fetch(this.apiUrl + path2, {
        method: "DELETE",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await raiseForStatus(res, `delete ${path2}`, true);
      return res;
    });
  }
  /**
   * Delete multiple examples by ID.
   * @param exampleIds - The IDs of the examples to delete
   * @param options - Optional settings for deletion
   * @param options.hardDelete - If true, permanently delete examples. If false (default), soft delete them.
   */
  async deleteExamples(exampleIds, options2) {
    exampleIds.forEach((id) => assertUuid(id));
    if (options2 == null ? void 0 : options2.hardDelete) {
      const path2 = this._getPlatformEndpointPath("datasets/examples/delete");
      await this.caller.call(async () => {
        const res = await this._fetch(`${this.apiUrl}${path2}`, {
          method: "POST",
          headers: { ...this.headers, "Content-Type": "application/json" },
          body: JSON.stringify({
            example_ids: exampleIds,
            hard_delete: true
          }),
          signal: AbortSignal.timeout(this.timeout_ms),
          ...this.fetchOptions
        });
        await raiseForStatus(res, "hard delete examples", true);
        return res;
      });
    } else {
      const params = new URLSearchParams();
      exampleIds.forEach((id) => params.append("example_ids", id));
      await this.caller.call(async () => {
        const res = await this._fetch(`${this.apiUrl}/examples?${params.toString()}`, {
          method: "DELETE",
          headers: this.headers,
          signal: AbortSignal.timeout(this.timeout_ms),
          ...this.fetchOptions
        });
        await raiseForStatus(res, "delete examples", true);
        return res;
      });
    }
  }
  async updateExample(exampleIdOrUpdate, update) {
    let exampleId;
    if (update) {
      exampleId = exampleIdOrUpdate;
    } else {
      exampleId = exampleIdOrUpdate.id;
    }
    assertUuid(exampleId);
    let updateToUse;
    if (update) {
      updateToUse = { id: exampleId, ...update };
    } else {
      updateToUse = exampleIdOrUpdate;
    }
    let datasetId;
    if (updateToUse.dataset_id !== void 0) {
      datasetId = updateToUse.dataset_id;
    } else {
      const example = await this.readExample(exampleId);
      datasetId = example.dataset_id;
    }
    return this._updateExamplesMultipart(datasetId, [updateToUse]);
  }
  async updateExamples(update) {
    let datasetId;
    if (update[0].dataset_id === void 0) {
      const example = await this.readExample(update[0].id);
      datasetId = example.dataset_id;
    } else {
      datasetId = update[0].dataset_id;
    }
    return this._updateExamplesMultipart(datasetId, update);
  }
  /**
   * Get dataset version by closest date or exact tag.
   *
   * Use this to resolve the nearest version to a given timestamp or for a given tag.
   *
   * @param options The options for getting the dataset version
   * @param options.datasetId The ID of the dataset
   * @param options.datasetName The name of the dataset
   * @param options.asOf The timestamp of the dataset to retrieve
   * @param options.tag The tag of the dataset to retrieve
   * @returns The dataset version
   */
  async readDatasetVersion({ datasetId, datasetName, asOf, tag }) {
    let resolvedDatasetId;
    if (!datasetId) {
      const dataset = await this.readDataset({ datasetName });
      resolvedDatasetId = dataset.id;
    } else {
      resolvedDatasetId = datasetId;
    }
    assertUuid(resolvedDatasetId);
    if (asOf && tag || !asOf && !tag) {
      throw new Error("Exactly one of asOf and tag must be specified.");
    }
    const params = new URLSearchParams();
    if (asOf !== void 0) {
      params.append("as_of", typeof asOf === "string" ? asOf : asOf.toISOString());
    }
    if (tag !== void 0) {
      params.append("tag", tag);
    }
    const response = await this.caller.call(async () => {
      const res = await this._fetch(`${this.apiUrl}/datasets/${resolvedDatasetId}/version?${params.toString()}`, {
        method: "GET",
        headers: { ...this.headers },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await raiseForStatus(res, "read dataset version");
      return res;
    });
    return await response.json();
  }
  async listDatasetSplits({ datasetId, datasetName, asOf }) {
    let datasetId_;
    if (datasetId === void 0 && datasetName === void 0) {
      throw new Error("Must provide dataset name or ID");
    } else if (datasetId !== void 0 && datasetName !== void 0) {
      throw new Error("Must provide either datasetName or datasetId, not both");
    } else if (datasetId === void 0) {
      const dataset = await this.readDataset({ datasetName });
      datasetId_ = dataset.id;
    } else {
      datasetId_ = datasetId;
    }
    assertUuid(datasetId_);
    const params = new URLSearchParams();
    const dataset_version = asOf ? typeof asOf === "string" ? asOf : asOf == null ? void 0 : asOf.toISOString() : void 0;
    if (dataset_version) {
      params.append("as_of", dataset_version);
    }
    const response = await this._get(`/datasets/${datasetId_}/splits`, params);
    return response;
  }
  async updateDatasetSplits({ datasetId, datasetName, splitName, exampleIds, remove = false }) {
    let datasetId_;
    if (datasetId === void 0 && datasetName === void 0) {
      throw new Error("Must provide dataset name or ID");
    } else if (datasetId !== void 0 && datasetName !== void 0) {
      throw new Error("Must provide either datasetName or datasetId, not both");
    } else if (datasetId === void 0) {
      const dataset = await this.readDataset({ datasetName });
      datasetId_ = dataset.id;
    } else {
      datasetId_ = datasetId;
    }
    assertUuid(datasetId_);
    const data = {
      split_name: splitName,
      examples: exampleIds.map((id) => {
        assertUuid(id);
        return id;
      }),
      remove
    };
    const body = JSON.stringify(data);
    await this.caller.call(async () => {
      const res = await this._fetch(`${this.apiUrl}/datasets/${datasetId_}/splits`, {
        method: "PUT",
        headers: { ...this.headers, "Content-Type": "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body
      });
      await raiseForStatus(res, "update dataset splits", true);
      return res;
    });
  }
  /**
   * @deprecated This method is deprecated and will be removed in future LangSmith versions, use `evaluate` from `langsmith/evaluation` instead.
   */
  async evaluateRun(run, evaluator, { sourceInfo, loadChildRuns, referenceExample } = { loadChildRuns: false }) {
    warnOnce("This method is deprecated and will be removed in future LangSmith versions, use `evaluate` from `langsmith/evaluation` instead.");
    let run_;
    if (typeof run === "string") {
      run_ = await this.readRun(run, { loadChildRuns });
    } else if (typeof run === "object" && "id" in run) {
      run_ = run;
    } else {
      throw new Error(`Invalid run type: ${typeof run}`);
    }
    if (run_.reference_example_id !== null && run_.reference_example_id !== void 0) {
      referenceExample = await this.readExample(run_.reference_example_id);
    }
    const feedbackResult = await evaluator.evaluateRun(run_, referenceExample);
    const [_, feedbacks] = await this._logEvaluationFeedback(feedbackResult, run_, sourceInfo);
    return feedbacks[0];
  }
  async createFeedback(runId, key, { score, value, correction, comment, sourceInfo, feedbackSourceType = "api", sourceRunId, feedbackId, feedbackConfig, projectId, comparativeExperimentId }) {
    var _a3;
    if (!runId && !projectId) {
      throw new Error("One of runId or projectId must be provided");
    }
    if (runId && projectId) {
      throw new Error("Only one of runId or projectId can be provided");
    }
    const feedback_source = {
      type: feedbackSourceType ?? "api",
      metadata: sourceInfo ?? {}
    };
    if (sourceRunId !== void 0 && (feedback_source == null ? void 0 : feedback_source.metadata) !== void 0 && !feedback_source.metadata["__run"]) {
      feedback_source.metadata["__run"] = { run_id: sourceRunId };
    }
    if ((feedback_source == null ? void 0 : feedback_source.metadata) !== void 0 && ((_a3 = feedback_source.metadata["__run"]) == null ? void 0 : _a3.run_id) !== void 0) {
      assertUuid(feedback_source.metadata["__run"].run_id);
    }
    const feedback = {
      id: feedbackId ?? v4(),
      run_id: runId,
      key,
      score: _formatFeedbackScore(score),
      value,
      correction,
      comment,
      feedback_source,
      comparative_experiment_id: comparativeExperimentId,
      feedbackConfig,
      session_id: projectId
    };
    const body = JSON.stringify(feedback);
    const url = `${this.apiUrl}/feedback`;
    await this.caller.call(async () => {
      const res = await this._fetch(url, {
        method: "POST",
        headers: { ...this.headers, "Content-Type": "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body
      });
      await raiseForStatus(res, "create feedback", true);
      return res;
    });
    return feedback;
  }
  async updateFeedback(feedbackId, { score, value, correction, comment }) {
    const feedbackUpdate = {};
    if (score !== void 0 && score !== null) {
      feedbackUpdate["score"] = _formatFeedbackScore(score);
    }
    if (value !== void 0 && value !== null) {
      feedbackUpdate["value"] = value;
    }
    if (correction !== void 0 && correction !== null) {
      feedbackUpdate["correction"] = correction;
    }
    if (comment !== void 0 && comment !== null) {
      feedbackUpdate["comment"] = comment;
    }
    assertUuid(feedbackId);
    const body = JSON.stringify(feedbackUpdate);
    await this.caller.call(async () => {
      const res = await this._fetch(`${this.apiUrl}/feedback/${feedbackId}`, {
        method: "PATCH",
        headers: { ...this.headers, "Content-Type": "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body
      });
      await raiseForStatus(res, "update feedback", true);
      return res;
    });
  }
  async readFeedback(feedbackId) {
    assertUuid(feedbackId);
    const path2 = `/feedback/${feedbackId}`;
    const response = await this._get(path2);
    return response;
  }
  async deleteFeedback(feedbackId) {
    assertUuid(feedbackId);
    const path2 = `/feedback/${feedbackId}`;
    await this.caller.call(async () => {
      const res = await this._fetch(this.apiUrl + path2, {
        method: "DELETE",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await raiseForStatus(res, `delete ${path2}`, true);
      return res;
    });
  }
  async *listFeedback({ runIds, feedbackKeys, feedbackSourceTypes } = {}) {
    const queryParams = new URLSearchParams();
    if (runIds) {
      for (const runId of runIds) {
        assertUuid(runId);
        queryParams.append("run", runId);
      }
    }
    if (feedbackKeys) {
      for (const key of feedbackKeys) {
        queryParams.append("key", key);
      }
    }
    if (feedbackSourceTypes) {
      for (const type of feedbackSourceTypes) {
        queryParams.append("source", type);
      }
    }
    for await (const feedbacks of this._getPaginated("/feedback", queryParams)) {
      yield* feedbacks;
    }
  }
  /**
   * Creates a presigned feedback token and URL.
   *
   * The token can be used to authorize feedback metrics without
   * needing an API key. This is useful for giving browser-based
   * applications the ability to submit feedback without needing
   * to expose an API key.
   *
   * @param runId The ID of the run.
   * @param feedbackKey The feedback key.
   * @param options Additional options for the token.
   * @param options.expiration The expiration time for the token.
   *
   * @returns A promise that resolves to a FeedbackIngestToken.
   */
  async createPresignedFeedbackToken(runId, feedbackKey, { expiration, feedbackConfig } = {}) {
    const body = {
      run_id: runId,
      feedback_key: feedbackKey,
      feedback_config: feedbackConfig
    };
    if (expiration) {
      if (typeof expiration === "string") {
        body["expires_at"] = expiration;
      } else if ((expiration == null ? void 0 : expiration.hours) || (expiration == null ? void 0 : expiration.minutes) || (expiration == null ? void 0 : expiration.days)) {
        body["expires_in"] = expiration;
      }
    } else {
      body["expires_in"] = {
        hours: 3
      };
    }
    const serializedBody = JSON.stringify(body);
    const response = await this.caller.call(async () => {
      const res = await this._fetch(`${this.apiUrl}/feedback/tokens`, {
        method: "POST",
        headers: { ...this.headers, "Content-Type": "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: serializedBody
      });
      await raiseForStatus(res, "create presigned feedback token");
      return res;
    });
    return await response.json();
  }
  async createComparativeExperiment({ name, experimentIds, referenceDatasetId, createdAt, description, metadata, id }) {
    var _a3;
    if (experimentIds.length === 0) {
      throw new Error("At least one experiment is required");
    }
    if (!referenceDatasetId) {
      referenceDatasetId = (await this.readProject({
        projectId: experimentIds[0]
      })).reference_dataset_id;
    }
    if (!referenceDatasetId == null) {
      throw new Error("A reference dataset is required");
    }
    const body = {
      id,
      name,
      experiment_ids: experimentIds,
      reference_dataset_id: referenceDatasetId,
      description,
      created_at: (_a3 = createdAt ?? /* @__PURE__ */ new Date()) == null ? void 0 : _a3.toISOString(),
      extra: {}
    };
    if (metadata)
      body.extra["metadata"] = metadata;
    const serializedBody = JSON.stringify(body);
    const response = await this.caller.call(async () => {
      const res = await this._fetch(`${this.apiUrl}/datasets/comparative`, {
        method: "POST",
        headers: { ...this.headers, "Content-Type": "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: serializedBody
      });
      await raiseForStatus(res, "create comparative experiment");
      return res;
    });
    return response.json();
  }
  /**
   * Retrieves a list of presigned feedback tokens for a given run ID.
   * @param runId The ID of the run.
   * @returns An async iterable of FeedbackIngestToken objects.
   */
  async *listPresignedFeedbackTokens(runId) {
    assertUuid(runId);
    const params = new URLSearchParams({ run_id: runId });
    for await (const tokens of this._getPaginated("/feedback/tokens", params)) {
      yield* tokens;
    }
  }
  _selectEvalResults(results2) {
    let results_;
    if ("results" in results2) {
      results_ = results2.results;
    } else if (Array.isArray(results2)) {
      results_ = results2;
    } else {
      results_ = [results2];
    }
    return results_;
  }
  async _logEvaluationFeedback(evaluatorResponse, run, sourceInfo) {
    const evalResults = this._selectEvalResults(evaluatorResponse);
    const feedbacks = [];
    for (const res of evalResults) {
      let sourceInfo_ = sourceInfo || {};
      if (res.evaluatorInfo) {
        sourceInfo_ = { ...res.evaluatorInfo, ...sourceInfo_ };
      }
      let runId_ = null;
      if (res.targetRunId) {
        runId_ = res.targetRunId;
      } else if (run) {
        runId_ = run.id;
      }
      feedbacks.push(await this.createFeedback(runId_, res.key, {
        score: res.score,
        value: res.value,
        comment: res.comment,
        correction: res.correction,
        sourceInfo: sourceInfo_,
        sourceRunId: res.sourceRunId,
        feedbackConfig: res.feedbackConfig,
        feedbackSourceType: "model"
      }));
    }
    return [evalResults, feedbacks];
  }
  async logEvaluationFeedback(evaluatorResponse, run, sourceInfo) {
    const [results2] = await this._logEvaluationFeedback(evaluatorResponse, run, sourceInfo);
    return results2;
  }
  /**
   * API for managing annotation queues
   */
  /**
   * List the annotation queues on the LangSmith API.
   * @param options - The options for listing annotation queues
   * @param options.queueIds - The IDs of the queues to filter by
   * @param options.name - The name of the queue to filter by
   * @param options.nameContains - The substring that the queue name should contain
   * @param options.limit - The maximum number of queues to return
   * @returns An iterator of AnnotationQueue objects
   */
  async *listAnnotationQueues(options2 = {}) {
    const { queueIds, name, nameContains, limit: limit2 } = options2;
    const params = new URLSearchParams();
    if (queueIds) {
      queueIds.forEach((id, i2) => {
        assertUuid(id, `queueIds[${i2}]`);
        params.append("ids", id);
      });
    }
    if (name)
      params.append("name", name);
    if (nameContains)
      params.append("name_contains", nameContains);
    params.append("limit", (limit2 !== void 0 ? Math.min(limit2, 100) : 100).toString());
    let count = 0;
    for await (const queues of this._getPaginated("/annotation-queues", params)) {
      yield* queues;
      count++;
      if (limit2 !== void 0 && count >= limit2)
        break;
    }
  }
  /**
   * Create an annotation queue on the LangSmith API.
   * @param options - The options for creating an annotation queue
   * @param options.name - The name of the annotation queue
   * @param options.description - The description of the annotation queue
   * @param options.queueId - The ID of the annotation queue
   * @returns The created AnnotationQueue object
   */
  async createAnnotationQueue(options2) {
    const { name, description, queueId, rubricInstructions } = options2;
    const body = {
      name,
      description,
      id: queueId || v4(),
      rubric_instructions: rubricInstructions
    };
    const serializedBody = JSON.stringify(Object.fromEntries(Object.entries(body).filter(([_, v]) => v !== void 0)));
    const response = await this.caller.call(async () => {
      const res = await this._fetch(`${this.apiUrl}/annotation-queues`, {
        method: "POST",
        headers: { ...this.headers, "Content-Type": "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: serializedBody
      });
      await raiseForStatus(res, "create annotation queue");
      return res;
    });
    return response.json();
  }
  /**
   * Read an annotation queue with the specified queue ID.
   * @param queueId - The ID of the annotation queue to read
   * @returns The AnnotationQueueWithDetails object
   */
  async readAnnotationQueue(queueId) {
    const response = await this.caller.call(async () => {
      const res = await this._fetch(`${this.apiUrl}/annotation-queues/${assertUuid(queueId, "queueId")}`, {
        method: "GET",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await raiseForStatus(res, "read annotation queue");
      return res;
    });
    return response.json();
  }
  /**
   * Update an annotation queue with the specified queue ID.
   * @param queueId - The ID of the annotation queue to update
   * @param options - The options for updating the annotation queue
   * @param options.name - The new name for the annotation queue
   * @param options.description - The new description for the annotation queue
   */
  async updateAnnotationQueue(queueId, options2) {
    const { name, description, rubricInstructions } = options2;
    const body = JSON.stringify({
      name,
      description,
      rubric_instructions: rubricInstructions
    });
    await this.caller.call(async () => {
      const res = await this._fetch(`${this.apiUrl}/annotation-queues/${assertUuid(queueId, "queueId")}`, {
        method: "PATCH",
        headers: { ...this.headers, "Content-Type": "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body
      });
      await raiseForStatus(res, "update annotation queue", true);
      return res;
    });
  }
  /**
   * Delete an annotation queue with the specified queue ID.
   * @param queueId - The ID of the annotation queue to delete
   */
  async deleteAnnotationQueue(queueId) {
    await this.caller.call(async () => {
      const res = await this._fetch(`${this.apiUrl}/annotation-queues/${assertUuid(queueId, "queueId")}`, {
        method: "DELETE",
        headers: { ...this.headers, Accept: "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await raiseForStatus(res, "delete annotation queue", true);
      return res;
    });
  }
  /**
   * Add runs to an annotation queue with the specified queue ID.
   * @param queueId - The ID of the annotation queue
   * @param runIds - The IDs of the runs to be added to the annotation queue
   */
  async addRunsToAnnotationQueue(queueId, runIds) {
    const body = JSON.stringify(runIds.map((id, i2) => assertUuid(id, `runIds[${i2}]`).toString()));
    await this.caller.call(async () => {
      const res = await this._fetch(`${this.apiUrl}/annotation-queues/${assertUuid(queueId, "queueId")}/runs`, {
        method: "POST",
        headers: { ...this.headers, "Content-Type": "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body
      });
      await raiseForStatus(res, "add runs to annotation queue", true);
      return res;
    });
  }
  /**
   * Get a run from an annotation queue at the specified index.
   * @param queueId - The ID of the annotation queue
   * @param index - The index of the run to retrieve
   * @returns A Promise that resolves to a RunWithAnnotationQueueInfo object
   * @throws {Error} If the run is not found at the given index or for other API-related errors
   */
  async getRunFromAnnotationQueue(queueId, index) {
    const baseUrl = `/annotation-queues/${assertUuid(queueId, "queueId")}/run`;
    const response = await this.caller.call(async () => {
      const res = await this._fetch(`${this.apiUrl}${baseUrl}/${index}`, {
        method: "GET",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await raiseForStatus(res, "get run from annotation queue");
      return res;
    });
    return response.json();
  }
  /**
   * Delete a run from an an annotation queue.
   * @param queueId - The ID of the annotation queue to delete the run from
   * @param queueRunId - The ID of the run to delete from the annotation queue
   */
  async deleteRunFromAnnotationQueue(queueId, queueRunId) {
    await this.caller.call(async () => {
      const res = await this._fetch(`${this.apiUrl}/annotation-queues/${assertUuid(queueId, "queueId")}/runs/${assertUuid(queueRunId, "queueRunId")}`, {
        method: "DELETE",
        headers: { ...this.headers, Accept: "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await raiseForStatus(res, "delete run from annotation queue", true);
      return res;
    });
  }
  /**
   * Get the size of an annotation queue.
   * @param queueId - The ID of the annotation queue
   */
  async getSizeFromAnnotationQueue(queueId) {
    const response = await this.caller.call(async () => {
      const res = await this._fetch(`${this.apiUrl}/annotation-queues/${assertUuid(queueId, "queueId")}/size`, {
        method: "GET",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await raiseForStatus(res, "get size from annotation queue");
      return res;
    });
    return response.json();
  }
  async _currentTenantIsOwner(owner) {
    const settings = await this._getSettings();
    return owner == "-" || settings.tenant_handle === owner;
  }
  async _ownerConflictError(action, owner) {
    const settings = await this._getSettings();
    return new Error(`Cannot ${action} for another tenant.

      Current tenant: ${settings.tenant_handle}

      Requested tenant: ${owner}`);
  }
  async _getLatestCommitHash(promptOwnerAndName) {
    const response = await this.caller.call(async () => {
      const res = await this._fetch(`${this.apiUrl}/commits/${promptOwnerAndName}/?limit=${1}&offset=${0}`, {
        method: "GET",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await raiseForStatus(res, "get latest commit hash");
      return res;
    });
    const json = await response.json();
    if (json.commits.length === 0) {
      return void 0;
    }
    return json.commits[0].commit_hash;
  }
  async _likeOrUnlikePrompt(promptIdentifier, like) {
    const [owner, promptName, _] = parsePromptIdentifier(promptIdentifier);
    const body = JSON.stringify({ like });
    const response = await this.caller.call(async () => {
      const res = await this._fetch(`${this.apiUrl}/likes/${owner}/${promptName}`, {
        method: "POST",
        headers: { ...this.headers, "Content-Type": "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body
      });
      await raiseForStatus(res, `${like ? "like" : "unlike"} prompt`);
      return res;
    });
    return response.json();
  }
  async _getPromptUrl(promptIdentifier) {
    const [owner, promptName, commitHash] = parsePromptIdentifier(promptIdentifier);
    if (!await this._currentTenantIsOwner(owner)) {
      if (commitHash !== "latest") {
        return `${this.getHostUrl()}/hub/${owner}/${promptName}/${commitHash.substring(0, 8)}`;
      } else {
        return `${this.getHostUrl()}/hub/${owner}/${promptName}`;
      }
    } else {
      const settings = await this._getSettings();
      if (commitHash !== "latest") {
        return `${this.getHostUrl()}/prompts/${promptName}/${commitHash.substring(0, 8)}?organizationId=${settings.id}`;
      } else {
        return `${this.getHostUrl()}/prompts/${promptName}?organizationId=${settings.id}`;
      }
    }
  }
  async promptExists(promptIdentifier) {
    const prompt = await this.getPrompt(promptIdentifier);
    return !!prompt;
  }
  async likePrompt(promptIdentifier) {
    return this._likeOrUnlikePrompt(promptIdentifier, true);
  }
  async unlikePrompt(promptIdentifier) {
    return this._likeOrUnlikePrompt(promptIdentifier, false);
  }
  async *listCommits(promptOwnerAndName) {
    for await (const commits of this._getPaginated(`/commits/${promptOwnerAndName}/`, new URLSearchParams(), (res) => res.commits)) {
      yield* commits;
    }
  }
  async *listPrompts(options2) {
    const params = new URLSearchParams();
    params.append("sort_field", (options2 == null ? void 0 : options2.sortField) ?? "updated_at");
    params.append("sort_direction", "desc");
    params.append("is_archived", (!!(options2 == null ? void 0 : options2.isArchived)).toString());
    if ((options2 == null ? void 0 : options2.isPublic) !== void 0) {
      params.append("is_public", options2.isPublic.toString());
    }
    if (options2 == null ? void 0 : options2.query) {
      params.append("query", options2.query);
    }
    for await (const prompts of this._getPaginated("/repos", params, (res) => res.repos)) {
      yield* prompts;
    }
  }
  async getPrompt(promptIdentifier) {
    const [owner, promptName, _] = parsePromptIdentifier(promptIdentifier);
    const response = await this.caller.call(async () => {
      const res = await this._fetch(`${this.apiUrl}/repos/${owner}/${promptName}`, {
        method: "GET",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      if ((res == null ? void 0 : res.status) === 404) {
        return null;
      }
      await raiseForStatus(res, "get prompt");
      return res;
    });
    const result = await (response == null ? void 0 : response.json());
    if (result == null ? void 0 : result.repo) {
      return result.repo;
    } else {
      return null;
    }
  }
  async createPrompt(promptIdentifier, options2) {
    const settings = await this._getSettings();
    if ((options2 == null ? void 0 : options2.isPublic) && !settings.tenant_handle) {
      throw new Error(`Cannot create a public prompt without first

        creating a LangChain Hub handle.
        You can add a handle by creating a public prompt at:

        https://smith.langchain.com/prompts`);
    }
    const [owner, promptName, _] = parsePromptIdentifier(promptIdentifier);
    if (!await this._currentTenantIsOwner(owner)) {
      throw await this._ownerConflictError("create a prompt", owner);
    }
    const data = {
      repo_handle: promptName,
      ...(options2 == null ? void 0 : options2.description) && { description: options2.description },
      ...(options2 == null ? void 0 : options2.readme) && { readme: options2.readme },
      ...(options2 == null ? void 0 : options2.tags) && { tags: options2.tags },
      is_public: !!(options2 == null ? void 0 : options2.isPublic)
    };
    const body = JSON.stringify(data);
    const response = await this.caller.call(async () => {
      const res = await this._fetch(`${this.apiUrl}/repos/`, {
        method: "POST",
        headers: { ...this.headers, "Content-Type": "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body
      });
      await raiseForStatus(res, "create prompt");
      return res;
    });
    const { repo } = await response.json();
    return repo;
  }
  async createCommit(promptIdentifier, object2, options2) {
    if (!await this.promptExists(promptIdentifier)) {
      throw new Error("Prompt does not exist, you must create it first.");
    }
    const [owner, promptName, _] = parsePromptIdentifier(promptIdentifier);
    const resolvedParentCommitHash = (options2 == null ? void 0 : options2.parentCommitHash) === "latest" || !(options2 == null ? void 0 : options2.parentCommitHash) ? await this._getLatestCommitHash(`${owner}/${promptName}`) : options2 == null ? void 0 : options2.parentCommitHash;
    const payload = {
      manifest: JSON.parse(JSON.stringify(object2)),
      parent_commit: resolvedParentCommitHash
    };
    const body = JSON.stringify(payload);
    const response = await this.caller.call(async () => {
      const res = await this._fetch(`${this.apiUrl}/commits/${owner}/${promptName}`, {
        method: "POST",
        headers: { ...this.headers, "Content-Type": "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body
      });
      await raiseForStatus(res, "create commit");
      return res;
    });
    const result = await response.json();
    return this._getPromptUrl(`${owner}/${promptName}${result.commit_hash ? `:${result.commit_hash}` : ""}`);
  }
  /**
   * Update examples with attachments using multipart form data.
   * @param updates List of ExampleUpdateWithAttachments objects to upsert
   * @returns Promise with the update response
   */
  async updateExamplesMultipart(datasetId, updates = []) {
    return this._updateExamplesMultipart(datasetId, updates);
  }
  async _updateExamplesMultipart(datasetId, updates = []) {
    var _a3;
    if (!await this._getDatasetExamplesMultiPartSupport()) {
      throw new Error("Your LangSmith deployment does not allow using the multipart examples endpoint, please upgrade your deployment to the latest version.");
    }
    const formData = new FormData();
    for (const example of updates) {
      const exampleId = example.id;
      const exampleBody = {
        ...example.metadata && { metadata: example.metadata },
        ...example.split && { split: example.split }
      };
      const stringifiedExample = serialize(exampleBody, `Serializing body for example with id: ${exampleId}`);
      const exampleBlob = new Blob([stringifiedExample], {
        type: "application/json"
      });
      formData.append(exampleId, exampleBlob);
      if (example.inputs) {
        const stringifiedInputs = serialize(example.inputs, `Serializing inputs for example with id: ${exampleId}`);
        const inputsBlob = new Blob([stringifiedInputs], {
          type: "application/json"
        });
        formData.append(`${exampleId}.inputs`, inputsBlob);
      }
      if (example.outputs) {
        const stringifiedOutputs = serialize(example.outputs, `Serializing outputs whle updating example with id: ${exampleId}`);
        const outputsBlob = new Blob([stringifiedOutputs], {
          type: "application/json"
        });
        formData.append(`${exampleId}.outputs`, outputsBlob);
      }
      if (example.attachments) {
        for (const [name, attachment] of Object.entries(example.attachments)) {
          let mimeType;
          let data;
          if (Array.isArray(attachment)) {
            [mimeType, data] = attachment;
          } else {
            mimeType = attachment.mimeType;
            data = attachment.data;
          }
          const attachmentBlob = new Blob([data], {
            type: `${mimeType}; length=${data.byteLength}`
          });
          formData.append(`${exampleId}.attachment.${name}`, attachmentBlob);
        }
      }
      if (example.attachments_operations) {
        const stringifiedAttachmentsOperations = serialize(example.attachments_operations, `Serializing attachments while updating example with id: ${exampleId}`);
        const attachmentsOperationsBlob = new Blob([stringifiedAttachmentsOperations], {
          type: "application/json"
        });
        formData.append(`${exampleId}.attachments_operations`, attachmentsOperationsBlob);
      }
    }
    const datasetIdToUse = datasetId ?? ((_a3 = updates[0]) == null ? void 0 : _a3.dataset_id);
    const response = await this.caller.call(async () => {
      const res = await this._fetch(`${this.apiUrl}${this._getPlatformEndpointPath(`datasets/${datasetIdToUse}/examples`)}`, {
        method: "PATCH",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: formData
      });
      await raiseForStatus(res, "update examples");
      return res;
    });
    return response.json();
  }
  /**
   * Upload examples with attachments using multipart form data.
   * @param uploads List of ExampleUploadWithAttachments objects to upload
   * @returns Promise with the upload response
   * @deprecated This method is deprecated and will be removed in future LangSmith versions, please use `createExamples` instead
   */
  async uploadExamplesMultipart(datasetId, uploads = []) {
    return this._uploadExamplesMultipart(datasetId, uploads);
  }
  async _uploadExamplesMultipart(datasetId, uploads = []) {
    if (!await this._getDatasetExamplesMultiPartSupport()) {
      throw new Error("Your LangSmith deployment does not allow using the multipart examples endpoint, please upgrade your deployment to the latest version.");
    }
    const formData = new FormData();
    for (const example of uploads) {
      const exampleId = (example.id ?? v4()).toString();
      const exampleBody = {
        created_at: example.created_at,
        ...example.metadata && { metadata: example.metadata },
        ...example.split && { split: example.split },
        ...example.source_run_id && { source_run_id: example.source_run_id },
        ...example.use_source_run_io && {
          use_source_run_io: example.use_source_run_io
        },
        ...example.use_source_run_attachments && {
          use_source_run_attachments: example.use_source_run_attachments
        }
      };
      const stringifiedExample = serialize(exampleBody, `Serializing body for uploaded example with id: ${exampleId}`);
      const exampleBlob = new Blob([stringifiedExample], {
        type: "application/json"
      });
      formData.append(exampleId, exampleBlob);
      if (example.inputs) {
        const stringifiedInputs = serialize(example.inputs, `Serializing inputs for uploaded example with id: ${exampleId}`);
        const inputsBlob = new Blob([stringifiedInputs], {
          type: "application/json"
        });
        formData.append(`${exampleId}.inputs`, inputsBlob);
      }
      if (example.outputs) {
        const stringifiedOutputs = serialize(example.outputs, `Serializing outputs for uploaded example with id: ${exampleId}`);
        const outputsBlob = new Blob([stringifiedOutputs], {
          type: "application/json"
        });
        formData.append(`${exampleId}.outputs`, outputsBlob);
      }
      if (example.attachments) {
        for (const [name, attachment] of Object.entries(example.attachments)) {
          let mimeType;
          let data;
          if (Array.isArray(attachment)) {
            [mimeType, data] = attachment;
          } else {
            mimeType = attachment.mimeType;
            data = attachment.data;
          }
          const attachmentBlob = new Blob([data], {
            type: `${mimeType}; length=${data.byteLength}`
          });
          formData.append(`${exampleId}.attachment.${name}`, attachmentBlob);
        }
      }
    }
    const response = await this.caller.call(async () => {
      const res = await this._fetch(`${this.apiUrl}${this._getPlatformEndpointPath(`datasets/${datasetId}/examples`)}`, {
        method: "POST",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: formData
      });
      await raiseForStatus(res, "upload examples");
      return res;
    });
    return response.json();
  }
  async updatePrompt(promptIdentifier, options2) {
    if (!await this.promptExists(promptIdentifier)) {
      throw new Error("Prompt does not exist, you must create it first.");
    }
    const [owner, promptName] = parsePromptIdentifier(promptIdentifier);
    if (!await this._currentTenantIsOwner(owner)) {
      throw await this._ownerConflictError("update a prompt", owner);
    }
    const payload = {};
    if ((options2 == null ? void 0 : options2.description) !== void 0)
      payload.description = options2.description;
    if ((options2 == null ? void 0 : options2.readme) !== void 0)
      payload.readme = options2.readme;
    if ((options2 == null ? void 0 : options2.tags) !== void 0)
      payload.tags = options2.tags;
    if ((options2 == null ? void 0 : options2.isPublic) !== void 0)
      payload.is_public = options2.isPublic;
    if ((options2 == null ? void 0 : options2.isArchived) !== void 0)
      payload.is_archived = options2.isArchived;
    if (Object.keys(payload).length === 0) {
      throw new Error("No valid update options provided");
    }
    const body = JSON.stringify(payload);
    const response = await this.caller.call(async () => {
      const res = await this._fetch(`${this.apiUrl}/repos/${owner}/${promptName}`, {
        method: "PATCH",
        headers: {
          ...this.headers,
          "Content-Type": "application/json"
        },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body
      });
      await raiseForStatus(res, "update prompt");
      return res;
    });
    return response.json();
  }
  async deletePrompt(promptIdentifier) {
    if (!await this.promptExists(promptIdentifier)) {
      throw new Error("Prompt does not exist, you must create it first.");
    }
    const [owner, promptName, _] = parsePromptIdentifier(promptIdentifier);
    if (!await this._currentTenantIsOwner(owner)) {
      throw await this._ownerConflictError("delete a prompt", owner);
    }
    const response = await this.caller.call(async () => {
      const res = await this._fetch(`${this.apiUrl}/repos/${owner}/${promptName}`, {
        method: "DELETE",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await raiseForStatus(res, "delete prompt");
      return res;
    });
    return response.json();
  }
  async pullPromptCommit(promptIdentifier, options2) {
    const [owner, promptName, commitHash] = parsePromptIdentifier(promptIdentifier);
    const response = await this.caller.call(async () => {
      const res = await this._fetch(`${this.apiUrl}/commits/${owner}/${promptName}/${commitHash}${(options2 == null ? void 0 : options2.includeModel) ? "?include_model=true" : ""}`, {
        method: "GET",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await raiseForStatus(res, "pull prompt commit");
      return res;
    });
    const result = await response.json();
    return {
      owner,
      repo: promptName,
      commit_hash: result.commit_hash,
      manifest: result.manifest,
      examples: result.examples
    };
  }
  /**
   * This method should not be used directly, use `import { pull } from "langchain/hub"` instead.
   * Using this method directly returns the JSON string of the prompt rather than a LangChain object.
   * @private
   */
  async _pullPrompt(promptIdentifier, options2) {
    const promptObject = await this.pullPromptCommit(promptIdentifier, {
      includeModel: options2 == null ? void 0 : options2.includeModel
    });
    const prompt = JSON.stringify(promptObject.manifest);
    return prompt;
  }
  async pushPrompt(promptIdentifier, options2) {
    if (await this.promptExists(promptIdentifier)) {
      if (options2 && Object.keys(options2).some((key) => key !== "object")) {
        await this.updatePrompt(promptIdentifier, {
          description: options2 == null ? void 0 : options2.description,
          readme: options2 == null ? void 0 : options2.readme,
          tags: options2 == null ? void 0 : options2.tags,
          isPublic: options2 == null ? void 0 : options2.isPublic
        });
      }
    } else {
      await this.createPrompt(promptIdentifier, {
        description: options2 == null ? void 0 : options2.description,
        readme: options2 == null ? void 0 : options2.readme,
        tags: options2 == null ? void 0 : options2.tags,
        isPublic: options2 == null ? void 0 : options2.isPublic
      });
    }
    if (!(options2 == null ? void 0 : options2.object)) {
      return await this._getPromptUrl(promptIdentifier);
    }
    const url = await this.createCommit(promptIdentifier, options2 == null ? void 0 : options2.object, {
      parentCommitHash: options2 == null ? void 0 : options2.parentCommitHash
    });
    return url;
  }
  /**
     * Clone a public dataset to your own langsmith tenant.
     * This operation is idempotent. If you already have a dataset with the given name,
     * this function will do nothing.
  
     * @param {string} tokenOrUrl The token of the public dataset to clone.
     * @param {Object} [options] Additional options for cloning the dataset.
     * @param {string} [options.sourceApiUrl] The URL of the langsmith server where the data is hosted. Defaults to the API URL of your current client.
     * @param {string} [options.datasetName] The name of the dataset to create in your tenant. Defaults to the name of the public dataset.
     * @returns {Promise<void>}
     */
  async clonePublicDataset(tokenOrUrl, options2 = {}) {
    const { sourceApiUrl = this.apiUrl, datasetName } = options2;
    const [parsedApiUrl, tokenUuid] = this.parseTokenOrUrl(tokenOrUrl, sourceApiUrl);
    const sourceClient = new Client({
      apiUrl: parsedApiUrl,
      // Placeholder API key not needed anymore in most cases, but
      // some private deployments may have API key-based rate limiting
      // that would cause this to fail if we provide no value.
      apiKey: "placeholder"
    });
    const ds = await sourceClient.readSharedDataset(tokenUuid);
    const finalDatasetName = datasetName || ds.name;
    try {
      if (await this.hasDataset({ datasetId: finalDatasetName })) {
        console.log(`Dataset ${finalDatasetName} already exists in your tenant. Skipping.`);
        return;
      }
    } catch (_) {
    }
    const examples = await sourceClient.listSharedExamples(tokenUuid);
    const dataset = await this.createDataset(finalDatasetName, {
      description: ds.description,
      dataType: ds.data_type || "kv",
      inputsSchema: ds.inputs_schema_definition ?? void 0,
      outputsSchema: ds.outputs_schema_definition ?? void 0
    });
    try {
      await this.createExamples({
        inputs: examples.map((e) => e.inputs),
        outputs: examples.flatMap((e) => e.outputs ? [e.outputs] : []),
        datasetId: dataset.id
      });
    } catch (e) {
      console.error(`An error occurred while creating dataset ${finalDatasetName}. You should delete it manually.`);
      throw e;
    }
  }
  parseTokenOrUrl(urlOrToken, apiUrl, numParts = 2, kind = "dataset") {
    try {
      assertUuid(urlOrToken);
      return [apiUrl, urlOrToken];
    } catch (_) {
    }
    try {
      const parsedUrl = new URL(urlOrToken);
      const pathParts = parsedUrl.pathname.split("/").filter((part) => part !== "");
      if (pathParts.length >= numParts) {
        const tokenUuid = pathParts[pathParts.length - numParts];
        return [apiUrl, tokenUuid];
      } else {
        throw new Error(`Invalid public ${kind} URL: ${urlOrToken}`);
      }
    } catch (error) {
      throw new Error(`Invalid public ${kind} URL or token: ${urlOrToken}`);
    }
  }
  /**
   * Awaits all pending trace batches. Useful for environments where
   * you need to be sure that all tracing requests finish before execution ends,
   * such as serverless environments.
   *
   * @example
   * ```
   * import { Client } from "langsmith";
   *
   * const client = new Client();
   *
   * try {
   *   // Tracing happens here
   *   ...
   * } finally {
   *   await client.awaitPendingTraceBatches();
   * }
   * ```
   *
   * @returns A promise that resolves once all currently pending traces have sent.
   */
  async awaitPendingTraceBatches() {
    var _a3, _b;
    if (this.manualFlushMode) {
      console.warn("[WARNING]: When tracing in manual flush mode, you must call `await client.flush()` manually to submit trace batches.");
      return Promise.resolve();
    }
    await Promise.all([
      ...this.autoBatchQueue.items.map(({ itemPromise }) => itemPromise),
      this.batchIngestCaller.queue.onIdle()
    ]);
    if (this.langSmithToOTELTranslator !== void 0) {
      await ((_b = (_a3 = getDefaultOTLPTracerComponents()) == null ? void 0 : _a3.DEFAULT_LANGSMITH_SPAN_PROCESSOR) == null ? void 0 : _b.forceFlush());
    }
  }
}
function isExampleCreate(input) {
  return "dataset_id" in input || "dataset_name" in input;
}
const isTracingEnabled$1 = (tracingEnabled) => {
  const envVars = ["TRACING_V2", "TRACING"];
  return !!envVars.find((envVar) => getLangSmithEnvironmentVariable(envVar) === "true");
};
const _LC_CONTEXT_VARIABLES_KEY = Symbol.for("lc:context_variables");
const _REPLICA_TRACE_ROOTS_KEY = Symbol.for("langsmith:replica_trace_roots");
function getContextVar(runTree, key) {
  if (_LC_CONTEXT_VARIABLES_KEY in runTree) {
    const contextVars = runTree[_LC_CONTEXT_VARIABLES_KEY];
    return contextVars[key];
  }
  return void 0;
}
function setContextVar(runTree, key, value) {
  const contextVars = _LC_CONTEXT_VARIABLES_KEY in runTree ? (
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    runTree[_LC_CONTEXT_VARIABLES_KEY]
  ) : {};
  contextVars[key] = value;
  runTree[_LC_CONTEXT_VARIABLES_KEY] = contextVars;
}
const UUID_NAMESPACE_DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
function getReplicaKey(replica) {
  const sortedKeys = Object.keys(replica).sort();
  const keyData = sortedKeys.map((key) => `${key}:${replica[key] ?? ""}`).join("|");
  return v5(keyData, UUID_NAMESPACE_DNS);
}
function stripNonAlphanumeric(input) {
  return input.replace(/[-:.]/g, "");
}
function getMicrosecondPrecisionDatestring(epoch, executionOrder = 1) {
  const paddedOrder = executionOrder.toFixed(0).slice(0, 3).padStart(3, "0");
  return `${new Date(epoch).toISOString().slice(0, -1)}${paddedOrder}Z`;
}
function convertToDottedOrderFormat(epoch, runId, executionOrder = 1) {
  const microsecondPrecisionDatestring = getMicrosecondPrecisionDatestring(epoch, executionOrder);
  return {
    dottedOrder: stripNonAlphanumeric(microsecondPrecisionDatestring) + runId,
    microsecondPrecisionDatestring
  };
}
class Baggage {
  constructor(metadata, tags, project_name, replicas) {
    Object.defineProperty(this, "metadata", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "tags", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "project_name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "replicas", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.metadata = metadata;
    this.tags = tags;
    this.project_name = project_name;
    this.replicas = replicas;
  }
  static fromHeader(value) {
    const items = value.split(",");
    let metadata = {};
    let tags = [];
    let project_name;
    let replicas;
    for (const item of items) {
      const [key, uriValue] = item.split("=");
      const value2 = decodeURIComponent(uriValue);
      if (key === "langsmith-metadata") {
        metadata = JSON.parse(value2);
      } else if (key === "langsmith-tags") {
        tags = value2.split(",");
      } else if (key === "langsmith-project") {
        project_name = value2;
      } else if (key === "langsmith-replicas") {
        replicas = JSON.parse(value2);
      }
    }
    return new Baggage(metadata, tags, project_name, replicas);
  }
  toHeader() {
    const items = [];
    if (this.metadata && Object.keys(this.metadata).length > 0) {
      items.push(`langsmith-metadata=${encodeURIComponent(JSON.stringify(this.metadata))}`);
    }
    if (this.tags && this.tags.length > 0) {
      items.push(`langsmith-tags=${encodeURIComponent(this.tags.join(","))}`);
    }
    if (this.project_name) {
      items.push(`langsmith-project=${encodeURIComponent(this.project_name)}`);
    }
    return items.join(",");
  }
}
class RunTree {
  constructor(originalConfig) {
    var _a3;
    Object.defineProperty(this, "id", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "run_type", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "project_name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "parent_run", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "parent_run_id", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "child_runs", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "start_time", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "end_time", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "extra", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "tags", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "error", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "serialized", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "inputs", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "outputs", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "reference_example_id", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "client", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "events", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "trace_id", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "dotted_order", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "tracingEnabled", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "execution_order", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "child_execution_order", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "attachments", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "replicas", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "distributedParentId", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "_serialized_start_time", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    if (isRunTree(originalConfig)) {
      Object.assign(this, { ...originalConfig });
      return;
    }
    const defaultConfig = RunTree.getDefaultConfig();
    const { metadata, ...config2 } = originalConfig;
    const client2 = config2.client ?? RunTree.getSharedClient();
    const dedupedMetadata = {
      ...metadata,
      ...(_a3 = config2 == null ? void 0 : config2.extra) == null ? void 0 : _a3.metadata
    };
    config2.extra = { ...config2.extra, metadata: dedupedMetadata };
    if ("id" in config2 && config2.id == null) {
      delete config2.id;
    }
    Object.assign(this, { ...defaultConfig, ...config2, client: client2 });
    this.execution_order ?? (this.execution_order = 1);
    this.child_execution_order ?? (this.child_execution_order = 1);
    if (!this.dotted_order) {
      this._serialized_start_time = getMicrosecondPrecisionDatestring(this.start_time, this.execution_order);
    }
    if (!this.id) {
      this.id = uuid7FromTime(this._serialized_start_time ?? this.start_time);
    }
    if (!this.trace_id) {
      if (this.parent_run) {
        this.trace_id = this.parent_run.trace_id ?? this.id;
      } else {
        this.trace_id = this.id;
      }
    }
    this.replicas = _ensureWriteReplicas(this.replicas);
    if (!this.dotted_order) {
      const { dottedOrder } = convertToDottedOrderFormat(this.start_time, this.id, this.execution_order);
      if (this.parent_run) {
        this.dotted_order = this.parent_run.dotted_order + "." + dottedOrder;
      } else {
        this.dotted_order = dottedOrder;
      }
    }
  }
  set metadata(metadata) {
    var _a3;
    this.extra = {
      ...this.extra,
      metadata: {
        ...(_a3 = this.extra) == null ? void 0 : _a3.metadata,
        ...metadata
      }
    };
  }
  get metadata() {
    var _a3;
    return (_a3 = this.extra) == null ? void 0 : _a3.metadata;
  }
  static getDefaultConfig() {
    const start_time = Date.now();
    return {
      run_type: "chain",
      project_name: getDefaultProjectName(),
      child_runs: [],
      api_url: getEnvironmentVariable("LANGCHAIN_ENDPOINT") ?? "http://localhost:1984",
      api_key: getEnvironmentVariable("LANGCHAIN_API_KEY"),
      caller_options: {},
      start_time,
      serialized: {},
      inputs: {},
      extra: {}
    };
  }
  static getSharedClient() {
    if (!RunTree.sharedClient) {
      RunTree.sharedClient = new Client();
    }
    return RunTree.sharedClient;
  }
  createChild(config2) {
    var _a3, _b, _c, _d, _e, _f, _g;
    const child_execution_order = this.child_execution_order + 1;
    const inheritedReplicas = (_a3 = this.replicas) == null ? void 0 : _a3.map((replica) => {
      const { reroot, ...rest } = replica;
      return rest;
    });
    const childReplicas = config2.replicas ?? inheritedReplicas;
    const child = new RunTree({
      ...config2,
      parent_run: this,
      project_name: this.project_name,
      replicas: childReplicas,
      client: this.client,
      tracingEnabled: this.tracingEnabled,
      execution_order: child_execution_order,
      child_execution_order
    });
    if (_LC_CONTEXT_VARIABLES_KEY in this) {
      child[_LC_CONTEXT_VARIABLES_KEY] = this[_LC_CONTEXT_VARIABLES_KEY];
    }
    const LC_CHILD = Symbol.for("lc:child_config");
    const presentConfig = ((_b = config2.extra) == null ? void 0 : _b[LC_CHILD]) ?? this.extra[LC_CHILD];
    if (isRunnableConfigLike(presentConfig)) {
      const newConfig = { ...presentConfig };
      const callbacks = isCallbackManagerLike(newConfig.callbacks) ? (_d = (_c = newConfig.callbacks).copy) == null ? void 0 : _d.call(_c) : void 0;
      if (callbacks) {
        Object.assign(callbacks, { _parentRunId: child.id });
        (_g = (_f = (_e = callbacks.handlers) == null ? void 0 : _e.find(isLangChainTracerLike)) == null ? void 0 : _f.updateFromRunTree) == null ? void 0 : _g.call(_f, child);
        newConfig.callbacks = callbacks;
      }
      child.extra[LC_CHILD] = newConfig;
    }
    const visited = /* @__PURE__ */ new Set();
    let current = this;
    while (current != null && !visited.has(current.id)) {
      visited.add(current.id);
      current.child_execution_order = Math.max(current.child_execution_order, child_execution_order);
      current = current.parent_run;
    }
    this.child_runs.push(child);
    return child;
  }
  async end(outputs, error, endTime = Date.now(), metadata) {
    this.outputs = this.outputs ?? outputs;
    this.error = this.error ?? error;
    this.end_time = this.end_time ?? endTime;
    if (metadata && Object.keys(metadata).length > 0) {
      this.extra = this.extra ? { ...this.extra, metadata: { ...this.extra.metadata, ...metadata } } : { metadata };
    }
  }
  _convertToCreate(run, runtimeEnv, excludeChildRuns = true) {
    var _a3, _b;
    const runExtra = run.extra ?? {};
    if (((_a3 = runExtra == null ? void 0 : runExtra.runtime) == null ? void 0 : _a3.library) === void 0) {
      if (!runExtra.runtime) {
        runExtra.runtime = {};
      }
      if (runtimeEnv) {
        for (const [k, v] of Object.entries(runtimeEnv)) {
          if (!runExtra.runtime[k]) {
            runExtra.runtime[k] = v;
          }
        }
      }
    }
    let child_runs;
    let parent_run_id;
    if (!excludeChildRuns) {
      child_runs = run.child_runs.map((child_run) => this._convertToCreate(child_run, runtimeEnv, excludeChildRuns));
      parent_run_id = void 0;
    } else {
      parent_run_id = ((_b = run.parent_run) == null ? void 0 : _b.id) ?? run.parent_run_id;
      child_runs = [];
    }
    return {
      id: run.id,
      name: run.name,
      start_time: run._serialized_start_time ?? run.start_time,
      end_time: run.end_time,
      run_type: run.run_type,
      reference_example_id: run.reference_example_id,
      extra: runExtra,
      serialized: run.serialized,
      error: run.error,
      inputs: run.inputs,
      outputs: run.outputs,
      session_name: run.project_name,
      child_runs,
      parent_run_id,
      trace_id: run.trace_id,
      dotted_order: run.dotted_order,
      tags: run.tags,
      attachments: run.attachments,
      events: run.events
    };
  }
  _sliceParentId(parentId, run) {
    if (run.dotted_order) {
      const segs = run.dotted_order.split(".");
      let startIdx = null;
      for (let idx = 0; idx < segs.length; idx++) {
        const segId = segs[idx].slice(-36);
        if (segId === parentId) {
          startIdx = idx;
          break;
        }
      }
      if (startIdx !== null) {
        const trimmedSegs = segs.slice(startIdx + 1);
        run.dotted_order = trimmedSegs.join(".");
        if (trimmedSegs.length > 0) {
          run.trace_id = trimmedSegs[0].slice(-36);
        } else {
          run.trace_id = run.id;
        }
      }
    }
    if (run.parent_run_id === parentId) {
      run.parent_run_id = void 0;
    }
  }
  _setReplicaTraceRoot(replicaKey, traceRootId) {
    const replicaTraceRoots = getContextVar(this, _REPLICA_TRACE_ROOTS_KEY) ?? {};
    replicaTraceRoots[replicaKey] = traceRootId;
    setContextVar(this, _REPLICA_TRACE_ROOTS_KEY, replicaTraceRoots);
    for (const child of this.child_runs) {
      child._setReplicaTraceRoot(replicaKey, traceRootId);
    }
  }
  _remapForProject(params) {
    const { projectName, runtimeEnv, excludeChildRuns = true, reroot = false, distributedParentId, apiUrl, apiKey, workspaceId } = params;
    const baseRun = this._convertToCreate(this, runtimeEnv, excludeChildRuns);
    if (projectName === this.project_name) {
      return {
        ...baseRun,
        session_name: projectName
      };
    }
    if (reroot) {
      if (distributedParentId) {
        this._sliceParentId(distributedParentId, baseRun);
      } else {
        baseRun.parent_run_id = void 0;
        if (baseRun.dotted_order) {
          const segs = baseRun.dotted_order.split(".");
          if (segs.length > 0) {
            baseRun.dotted_order = segs[segs.length - 1];
            baseRun.trace_id = baseRun.id;
          }
        }
      }
      const replicaKey = getReplicaKey({
        projectName,
        apiUrl,
        apiKey,
        workspaceId
      });
      this._setReplicaTraceRoot(replicaKey, baseRun.id);
    }
    let ancestorRerootedTraceId;
    if (!reroot) {
      const replicaTraceRoots = getContextVar(this, _REPLICA_TRACE_ROOTS_KEY) ?? {};
      const replicaKey = getReplicaKey({
        projectName,
        apiUrl,
        apiKey,
        workspaceId
      });
      ancestorRerootedTraceId = replicaTraceRoots[replicaKey];
      if (ancestorRerootedTraceId) {
        baseRun.trace_id = ancestorRerootedTraceId;
        if (baseRun.dotted_order) {
          const segs = baseRun.dotted_order.split(".");
          let rootIdx = null;
          for (let idx = 0; idx < segs.length; idx++) {
            const segId = segs[idx].slice(-36);
            if (segId === ancestorRerootedTraceId) {
              rootIdx = idx;
              break;
            }
          }
          if (rootIdx !== null) {
            const trimmedSegs = segs.slice(rootIdx);
            baseRun.dotted_order = trimmedSegs.join(".");
          }
        }
      }
    }
    const oldId = baseRun.id;
    const newId = v5(`${oldId}:${projectName}`, UUID_NAMESPACE_DNS);
    let newTraceId;
    if (baseRun.trace_id) {
      newTraceId = v5(`${baseRun.trace_id}:${projectName}`, UUID_NAMESPACE_DNS);
    } else {
      newTraceId = newId;
    }
    let newParentId;
    if (baseRun.parent_run_id) {
      newParentId = v5(`${baseRun.parent_run_id}:${projectName}`, UUID_NAMESPACE_DNS);
    }
    let newDottedOrder;
    if (baseRun.dotted_order) {
      const segs = baseRun.dotted_order.split(".");
      const remappedSegs = segs.map((seg) => {
        const segId = seg.slice(-36);
        const remappedId = v5(`${segId}:${projectName}`, UUID_NAMESPACE_DNS);
        return seg.slice(0, -36) + remappedId;
      });
      newDottedOrder = remappedSegs.join(".");
    }
    return {
      ...baseRun,
      id: newId,
      trace_id: newTraceId,
      parent_run_id: newParentId,
      dotted_order: newDottedOrder,
      session_name: projectName
    };
  }
  async postRun(excludeChildRuns = true) {
    try {
      const runtimeEnv = getRuntimeEnvironment();
      if (this.replicas && this.replicas.length > 0) {
        for (const { projectName, apiKey, apiUrl, workspaceId, reroot } of this.replicas) {
          const runCreate = this._remapForProject({
            projectName: projectName ?? this.project_name,
            runtimeEnv,
            excludeChildRuns: true,
            reroot,
            distributedParentId: this.distributedParentId,
            apiUrl,
            apiKey,
            workspaceId
          });
          await this.client.createRun(runCreate, {
            apiKey,
            apiUrl,
            workspaceId
          });
        }
      } else {
        const runCreate = this._convertToCreate(this, runtimeEnv, excludeChildRuns);
        await this.client.createRun(runCreate);
      }
      if (!excludeChildRuns) {
        warnOnce("Posting with excludeChildRuns=false is deprecated and will be removed in a future version.");
        for (const childRun of this.child_runs) {
          await childRun.postRun(false);
        }
      }
    } catch (error) {
      console.error(`Error in postRun for run ${this.id}:`, error);
    }
  }
  async patchRun(options2) {
    var _a3;
    if (this.replicas && this.replicas.length > 0) {
      for (const { projectName, apiKey, apiUrl, workspaceId, updates, reroot } of this.replicas) {
        const runData = this._remapForProject({
          projectName: projectName ?? this.project_name,
          runtimeEnv: void 0,
          excludeChildRuns: true,
          reroot,
          distributedParentId: this.distributedParentId,
          apiUrl,
          apiKey,
          workspaceId
        });
        const updatePayload = {
          id: runData.id,
          name: runData.name,
          run_type: runData.run_type,
          start_time: runData.start_time,
          outputs: runData.outputs,
          error: runData.error,
          parent_run_id: runData.parent_run_id,
          session_name: runData.session_name,
          reference_example_id: runData.reference_example_id,
          end_time: runData.end_time,
          dotted_order: runData.dotted_order,
          trace_id: runData.trace_id,
          events: runData.events,
          tags: runData.tags,
          extra: runData.extra,
          attachments: this.attachments,
          ...updates
        };
        if (!(options2 == null ? void 0 : options2.excludeInputs)) {
          updatePayload.inputs = runData.inputs;
        }
        await this.client.updateRun(runData.id, updatePayload, {
          apiKey,
          apiUrl,
          workspaceId
        });
      }
    } else {
      try {
        const runUpdate = {
          name: this.name,
          run_type: this.run_type,
          start_time: this._serialized_start_time ?? this.start_time,
          end_time: this.end_time,
          error: this.error,
          outputs: this.outputs,
          parent_run_id: ((_a3 = this.parent_run) == null ? void 0 : _a3.id) ?? this.parent_run_id,
          reference_example_id: this.reference_example_id,
          extra: this.extra,
          events: this.events,
          dotted_order: this.dotted_order,
          trace_id: this.trace_id,
          tags: this.tags,
          attachments: this.attachments,
          session_name: this.project_name
        };
        if (!(options2 == null ? void 0 : options2.excludeInputs)) {
          runUpdate.inputs = this.inputs;
        }
        await this.client.updateRun(this.id, runUpdate);
      } catch (error) {
        console.error(`Error in patchRun for run ${this.id}`, error);
      }
    }
  }
  toJSON() {
    return this._convertToCreate(this, void 0, false);
  }
  /**
   * Add an event to the run tree.
   * @param event - A single event or string to add
   */
  addEvent(event) {
    if (!this.events) {
      this.events = [];
    }
    if (typeof event === "string") {
      this.events.push({
        name: "event",
        time: (/* @__PURE__ */ new Date()).toISOString(),
        message: event
      });
    } else {
      this.events.push({
        ...event,
        time: event.time ?? (/* @__PURE__ */ new Date()).toISOString()
      });
    }
  }
  static fromRunnableConfig(parentConfig, props) {
    var _a3, _b, _c, _d;
    const callbackManager = parentConfig == null ? void 0 : parentConfig.callbacks;
    let parentRun;
    let projectName;
    let client2;
    let tracingEnabled = isTracingEnabled$1();
    if (callbackManager) {
      const parentRunId = ((_a3 = callbackManager == null ? void 0 : callbackManager.getParentRunId) == null ? void 0 : _a3.call(callbackManager)) ?? "";
      const langChainTracer = (_b = callbackManager == null ? void 0 : callbackManager.handlers) == null ? void 0 : _b.find((handler) => (handler == null ? void 0 : handler.name) == "langchain_tracer");
      parentRun = (_c = langChainTracer == null ? void 0 : langChainTracer.getRun) == null ? void 0 : _c.call(langChainTracer, parentRunId);
      projectName = langChainTracer == null ? void 0 : langChainTracer.projectName;
      client2 = langChainTracer == null ? void 0 : langChainTracer.client;
      tracingEnabled = tracingEnabled || !!langChainTracer;
    }
    if (!parentRun) {
      return new RunTree({
        ...props,
        client: client2,
        tracingEnabled,
        project_name: projectName
      });
    }
    const parentRunTree = new RunTree({
      name: parentRun.name,
      id: parentRun.id,
      trace_id: parentRun.trace_id,
      dotted_order: parentRun.dotted_order,
      client: client2,
      tracingEnabled,
      project_name: projectName,
      tags: [
        ...new Set(((parentRun == null ? void 0 : parentRun.tags) ?? []).concat((parentConfig == null ? void 0 : parentConfig.tags) ?? []))
      ],
      extra: {
        metadata: {
          ...(_d = parentRun == null ? void 0 : parentRun.extra) == null ? void 0 : _d.metadata,
          ...parentConfig == null ? void 0 : parentConfig.metadata
        }
      }
    });
    return parentRunTree.createChild(props);
  }
  static fromDottedOrder(dottedOrder) {
    return this.fromHeaders({ "langsmith-trace": dottedOrder });
  }
  static fromHeaders(headers, inheritArgs) {
    var _a3;
    const rawHeaders = "get" in headers && typeof headers.get === "function" ? {
      "langsmith-trace": headers.get("langsmith-trace"),
      baggage: headers.get("baggage")
    } : headers;
    const headerTrace = rawHeaders["langsmith-trace"];
    if (!headerTrace || typeof headerTrace !== "string")
      return void 0;
    const parentDottedOrder = headerTrace.trim();
    const parsedDottedOrder = parentDottedOrder.split(".").map((part) => {
      const [strTime, uuid2] = part.split("Z");
      return { strTime, time: Date.parse(strTime + "Z"), uuid: uuid2 };
    });
    const traceId = parsedDottedOrder[0].uuid;
    const config2 = {
      ...inheritArgs,
      name: (inheritArgs == null ? void 0 : inheritArgs["name"]) ?? "parent",
      run_type: (inheritArgs == null ? void 0 : inheritArgs["run_type"]) ?? "chain",
      start_time: (inheritArgs == null ? void 0 : inheritArgs["start_time"]) ?? Date.now(),
      id: (_a3 = parsedDottedOrder.at(-1)) == null ? void 0 : _a3.uuid,
      trace_id: traceId,
      dotted_order: parentDottedOrder
    };
    if (rawHeaders["baggage"] && typeof rawHeaders["baggage"] === "string") {
      const baggage = Baggage.fromHeader(rawHeaders["baggage"]);
      config2.metadata = baggage.metadata;
      config2.tags = baggage.tags;
      config2.project_name = baggage.project_name;
      config2.replicas = baggage.replicas;
    }
    const runTree = new RunTree(config2);
    runTree.distributedParentId = runTree.id;
    return runTree;
  }
  toHeaders(headers) {
    var _a3;
    const result = {
      "langsmith-trace": this.dotted_order,
      baggage: new Baggage((_a3 = this.extra) == null ? void 0 : _a3.metadata, this.tags, this.project_name, this.replicas).toHeader()
    };
    if (headers) {
      for (const [key, value] of Object.entries(result)) {
        headers.set(key, value);
      }
    }
    return result;
  }
}
Object.defineProperty(RunTree, "sharedClient", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: null
});
function isRunTree(x) {
  return x != null && typeof x.createChild === "function" && typeof x.postRun === "function";
}
function isLangChainTracerLike(x) {
  return typeof x === "object" && x != null && typeof x.name === "string" && x.name === "langchain_tracer";
}
function containsLangChainTracerLike(x) {
  return Array.isArray(x) && x.some((callback) => isLangChainTracerLike(callback));
}
function isCallbackManagerLike(x) {
  return typeof x === "object" && x != null && Array.isArray(x.handlers);
}
function isRunnableConfigLike(x) {
  var _a3;
  return x != null && typeof x.callbacks === "object" && // Callback manager with a langchain tracer
  (containsLangChainTracerLike((_a3 = x.callbacks) == null ? void 0 : _a3.handlers) || // Or it's an array with a LangChainTracerLike object within it
  containsLangChainTracerLike(x.callbacks));
}
function _getWriteReplicasFromEnv() {
  const envVar = getEnvironmentVariable("LANGSMITH_RUNS_ENDPOINTS");
  if (!envVar)
    return [];
  try {
    const parsed = JSON.parse(envVar);
    if (Array.isArray(parsed)) {
      const replicas = [];
      for (const item of parsed) {
        if (typeof item !== "object" || item === null) {
          console.warn(`Invalid item type in LANGSMITH_RUNS_ENDPOINTS: expected object, got ${typeof item}`);
          continue;
        }
        if (typeof item.api_url !== "string") {
          console.warn(`Invalid api_url type in LANGSMITH_RUNS_ENDPOINTS: expected string, got ${typeof item.api_url}`);
          continue;
        }
        if (typeof item.api_key !== "string") {
          console.warn(`Invalid api_key type in LANGSMITH_RUNS_ENDPOINTS: expected string, got ${typeof item.api_key}`);
          continue;
        }
        replicas.push({
          apiUrl: item.api_url.replace(/\/$/, ""),
          apiKey: item.api_key
        });
      }
      return replicas;
    } else if (typeof parsed === "object" && parsed !== null) {
      _checkEndpointEnvUnset(parsed);
      const replicas = [];
      for (const [url, key] of Object.entries(parsed)) {
        const cleanUrl = url.replace(/\/$/, "");
        if (typeof key === "string") {
          replicas.push({
            apiUrl: cleanUrl,
            apiKey: key
          });
        } else {
          console.warn(`Invalid value type in LANGSMITH_RUNS_ENDPOINTS for URL ${url}: expected string, got ${typeof key}`);
          continue;
        }
      }
      return replicas;
    } else {
      console.warn(`Invalid LANGSMITH_RUNS_ENDPOINTS â€“ must be valid JSON array of objects with api_url and api_key properties, or object mapping url->apiKey, got ${typeof parsed}`);
      return [];
    }
  } catch (e) {
    if (isConflictingEndpointsError(e)) {
      throw e;
    }
    console.warn("Invalid LANGSMITH_RUNS_ENDPOINTS â€“ must be valid JSON array of objects with api_url and api_key properties, or object mapping url->apiKey");
    return [];
  }
}
function _ensureWriteReplicas(replicas) {
  if (replicas) {
    return replicas.map((replica) => {
      if (Array.isArray(replica)) {
        return {
          projectName: replica[0],
          updates: replica[1]
        };
      }
      return replica;
    });
  }
  return _getWriteReplicasFromEnv();
}
function _checkEndpointEnvUnset(parsed) {
  if (Object.keys(parsed).length > 0 && getLangSmithEnvironmentVariable("ENDPOINT")) {
    throw new ConflictingEndpointsError();
  }
}
var base_exports$1 = {};
__export(base_exports$1, {
  BaseTracer: () => BaseTracer,
  isBaseTracer: () => isBaseTracer
});
const convertRunTreeToRun = (runTree) => {
  if (!runTree) return void 0;
  runTree.events = runTree.events ?? [];
  runTree.child_runs = runTree.child_runs ?? [];
  return runTree;
};
function convertRunToRunTree(run, parentRun) {
  if (!run) return void 0;
  return new RunTree({
    ...run,
    start_time: run._serialized_start_time ?? run.start_time,
    parent_run: convertRunToRunTree(parentRun),
    child_runs: run.child_runs.map((r) => convertRunToRunTree(r)).filter((r) => r !== void 0),
    extra: {
      ...run.extra,
      runtime: getRuntimeEnvironment$1()
    },
    tracingEnabled: false
  });
}
function _coerceToDict$1(value, defaultKey) {
  return value && !Array.isArray(value) && typeof value === "object" ? value : { [defaultKey]: value };
}
function isBaseTracer(x) {
  return typeof x._addRunToRunMap === "function";
}
var BaseTracer = class extends BaseCallbackHandler {
  constructor(_fields) {
    super(...arguments);
    /** @deprecated Use `runTreeMap` instead. */
    __publicField2(this, "runMap", /* @__PURE__ */ new Map());
    __publicField2(this, "runTreeMap", /* @__PURE__ */ new Map());
    __publicField2(this, "usesRunTreeMap", false);
  }
  copy() {
    return this;
  }
  getRunById(runId) {
    if (runId === void 0) return void 0;
    return this.usesRunTreeMap ? convertRunTreeToRun(this.runTreeMap.get(runId)) : this.runMap.get(runId);
  }
  stringifyError(error) {
    if (error instanceof Error) return error.message + ((error == null ? void 0 : error.stack) ? `

${error.stack}` : "");
    if (typeof error === "string") return error;
    return `${error}`;
  }
  _addChildRun(parentRun, childRun) {
    parentRun.child_runs.push(childRun);
  }
  _addRunToRunMap(run) {
    const { dottedOrder: currentDottedOrder, microsecondPrecisionDatestring } = convertToDottedOrderFormat(new Date(run.start_time).getTime(), run.id, run.execution_order);
    const storedRun = { ...run };
    const parentRun = this.getRunById(storedRun.parent_run_id);
    if (storedRun.parent_run_id !== void 0) {
      if (parentRun) {
        this._addChildRun(parentRun, storedRun);
        parentRun.child_execution_order = Math.max(parentRun.child_execution_order, storedRun.child_execution_order);
        storedRun.trace_id = parentRun.trace_id;
        if (parentRun.dotted_order !== void 0) {
          storedRun.dotted_order = [parentRun.dotted_order, currentDottedOrder].join(".");
          storedRun._serialized_start_time = microsecondPrecisionDatestring;
        }
      }
    } else {
      storedRun.trace_id = storedRun.id;
      storedRun.dotted_order = currentDottedOrder;
      storedRun._serialized_start_time = microsecondPrecisionDatestring;
    }
    if (this.usesRunTreeMap) {
      const runTree = convertRunToRunTree(storedRun, parentRun);
      if (runTree !== void 0) this.runTreeMap.set(storedRun.id, runTree);
    } else this.runMap.set(storedRun.id, storedRun);
    return storedRun;
  }
  async _endTrace(run) {
    var _a3;
    const parentRun = run.parent_run_id !== void 0 && this.getRunById(run.parent_run_id);
    if (parentRun) parentRun.child_execution_order = Math.max(parentRun.child_execution_order, run.child_execution_order);
    else await this.persistRun(run);
    await ((_a3 = this.onRunUpdate) == null ? void 0 : _a3.call(this, run));
    if (this.usesRunTreeMap) this.runTreeMap.delete(run.id);
    else this.runMap.delete(run.id);
  }
  _getExecutionOrder(parentRunId) {
    const parentRun = parentRunId !== void 0 && this.getRunById(parentRunId);
    if (!parentRun) return 1;
    return parentRun.child_execution_order + 1;
  }
  /**
  * Create and add a run to the run map for LLM start events.
  * This must sometimes be done synchronously to avoid race conditions
  * when callbacks are backgrounded, so we expose it as a separate method here.
  */
  _createRunForLLMStart(llm, prompts, runId, parentRunId, extraParams, tags, metadata, name) {
    const execution_order = this._getExecutionOrder(parentRunId);
    const start_time = Date.now();
    const finalExtraParams = metadata ? {
      ...extraParams,
      metadata
    } : extraParams;
    const run = {
      id: runId,
      name: name ?? llm.id[llm.id.length - 1],
      parent_run_id: parentRunId,
      start_time,
      serialized: llm,
      events: [{
        name: "start",
        time: new Date(start_time).toISOString()
      }],
      inputs: { prompts },
      execution_order,
      child_runs: [],
      child_execution_order: execution_order,
      run_type: "llm",
      extra: finalExtraParams ?? {},
      tags: tags || []
    };
    return this._addRunToRunMap(run);
  }
  async handleLLMStart(llm, prompts, runId, parentRunId, extraParams, tags, metadata, name) {
    var _a3, _b;
    const run = this.getRunById(runId) ?? this._createRunForLLMStart(llm, prompts, runId, parentRunId, extraParams, tags, metadata, name);
    await ((_a3 = this.onRunCreate) == null ? void 0 : _a3.call(this, run));
    await ((_b = this.onLLMStart) == null ? void 0 : _b.call(this, run));
    return run;
  }
  /**
  * Create and add a run to the run map for chat model start events.
  * This must sometimes be done synchronously to avoid race conditions
  * when callbacks are backgrounded, so we expose it as a separate method here.
  */
  _createRunForChatModelStart(llm, messages, runId, parentRunId, extraParams, tags, metadata, name) {
    const execution_order = this._getExecutionOrder(parentRunId);
    const start_time = Date.now();
    const finalExtraParams = metadata ? {
      ...extraParams,
      metadata
    } : extraParams;
    const run = {
      id: runId,
      name: name ?? llm.id[llm.id.length - 1],
      parent_run_id: parentRunId,
      start_time,
      serialized: llm,
      events: [{
        name: "start",
        time: new Date(start_time).toISOString()
      }],
      inputs: { messages },
      execution_order,
      child_runs: [],
      child_execution_order: execution_order,
      run_type: "llm",
      extra: finalExtraParams ?? {},
      tags: tags || []
    };
    return this._addRunToRunMap(run);
  }
  async handleChatModelStart(llm, messages, runId, parentRunId, extraParams, tags, metadata, name) {
    var _a3, _b;
    const run = this.getRunById(runId) ?? this._createRunForChatModelStart(llm, messages, runId, parentRunId, extraParams, tags, metadata, name);
    await ((_a3 = this.onRunCreate) == null ? void 0 : _a3.call(this, run));
    await ((_b = this.onLLMStart) == null ? void 0 : _b.call(this, run));
    return run;
  }
  async handleLLMEnd(output, runId, _parentRunId, _tags, extraParams) {
    var _a3;
    const run = this.getRunById(runId);
    if (!run || (run == null ? void 0 : run.run_type) !== "llm") throw new Error("No LLM run to end.");
    run.end_time = Date.now();
    run.outputs = output;
    run.events.push({
      name: "end",
      time: new Date(run.end_time).toISOString()
    });
    run.extra = {
      ...run.extra,
      ...extraParams
    };
    await ((_a3 = this.onLLMEnd) == null ? void 0 : _a3.call(this, run));
    await this._endTrace(run);
    return run;
  }
  async handleLLMError(error, runId, _parentRunId, _tags, extraParams) {
    var _a3;
    const run = this.getRunById(runId);
    if (!run || (run == null ? void 0 : run.run_type) !== "llm") throw new Error("No LLM run to end.");
    run.end_time = Date.now();
    run.error = this.stringifyError(error);
    run.events.push({
      name: "error",
      time: new Date(run.end_time).toISOString()
    });
    run.extra = {
      ...run.extra,
      ...extraParams
    };
    await ((_a3 = this.onLLMError) == null ? void 0 : _a3.call(this, run));
    await this._endTrace(run);
    return run;
  }
  /**
  * Create and add a run to the run map for chain start events.
  * This must sometimes be done synchronously to avoid race conditions
  * when callbacks are backgrounded, so we expose it as a separate method here.
  */
  _createRunForChainStart(chain, inputs, runId, parentRunId, tags, metadata, runType, name) {
    const execution_order = this._getExecutionOrder(parentRunId);
    const start_time = Date.now();
    const run = {
      id: runId,
      name: name ?? chain.id[chain.id.length - 1],
      parent_run_id: parentRunId,
      start_time,
      serialized: chain,
      events: [{
        name: "start",
        time: new Date(start_time).toISOString()
      }],
      inputs,
      execution_order,
      child_execution_order: execution_order,
      run_type: runType ?? "chain",
      child_runs: [],
      extra: metadata ? { metadata } : {},
      tags: tags || []
    };
    return this._addRunToRunMap(run);
  }
  async handleChainStart(chain, inputs, runId, parentRunId, tags, metadata, runType, name) {
    var _a3, _b;
    const run = this.getRunById(runId) ?? this._createRunForChainStart(chain, inputs, runId, parentRunId, tags, metadata, runType, name);
    await ((_a3 = this.onRunCreate) == null ? void 0 : _a3.call(this, run));
    await ((_b = this.onChainStart) == null ? void 0 : _b.call(this, run));
    return run;
  }
  async handleChainEnd(outputs, runId, _parentRunId, _tags, kwargs) {
    var _a3;
    const run = this.getRunById(runId);
    if (!run) throw new Error("No chain run to end.");
    run.end_time = Date.now();
    run.outputs = _coerceToDict$1(outputs, "output");
    run.events.push({
      name: "end",
      time: new Date(run.end_time).toISOString()
    });
    if ((kwargs == null ? void 0 : kwargs.inputs) !== void 0) run.inputs = _coerceToDict$1(kwargs.inputs, "input");
    await ((_a3 = this.onChainEnd) == null ? void 0 : _a3.call(this, run));
    await this._endTrace(run);
    return run;
  }
  async handleChainError(error, runId, _parentRunId, _tags, kwargs) {
    var _a3;
    const run = this.getRunById(runId);
    if (!run) throw new Error("No chain run to end.");
    run.end_time = Date.now();
    run.error = this.stringifyError(error);
    run.events.push({
      name: "error",
      time: new Date(run.end_time).toISOString()
    });
    if ((kwargs == null ? void 0 : kwargs.inputs) !== void 0) run.inputs = _coerceToDict$1(kwargs.inputs, "input");
    await ((_a3 = this.onChainError) == null ? void 0 : _a3.call(this, run));
    await this._endTrace(run);
    return run;
  }
  /**
  * Create and add a run to the run map for tool start events.
  * This must sometimes be done synchronously to avoid race conditions
  * when callbacks are backgrounded, so we expose it as a separate method here.
  */
  _createRunForToolStart(tool2, input, runId, parentRunId, tags, metadata, name) {
    const execution_order = this._getExecutionOrder(parentRunId);
    const start_time = Date.now();
    const run = {
      id: runId,
      name: name ?? tool2.id[tool2.id.length - 1],
      parent_run_id: parentRunId,
      start_time,
      serialized: tool2,
      events: [{
        name: "start",
        time: new Date(start_time).toISOString()
      }],
      inputs: { input },
      execution_order,
      child_execution_order: execution_order,
      run_type: "tool",
      child_runs: [],
      extra: metadata ? { metadata } : {},
      tags: tags || []
    };
    return this._addRunToRunMap(run);
  }
  async handleToolStart(tool2, input, runId, parentRunId, tags, metadata, name) {
    var _a3, _b;
    const run = this.getRunById(runId) ?? this._createRunForToolStart(tool2, input, runId, parentRunId, tags, metadata, name);
    await ((_a3 = this.onRunCreate) == null ? void 0 : _a3.call(this, run));
    await ((_b = this.onToolStart) == null ? void 0 : _b.call(this, run));
    return run;
  }
  async handleToolEnd(output, runId) {
    var _a3;
    const run = this.getRunById(runId);
    if (!run || (run == null ? void 0 : run.run_type) !== "tool") throw new Error("No tool run to end");
    run.end_time = Date.now();
    run.outputs = { output };
    run.events.push({
      name: "end",
      time: new Date(run.end_time).toISOString()
    });
    await ((_a3 = this.onToolEnd) == null ? void 0 : _a3.call(this, run));
    await this._endTrace(run);
    return run;
  }
  async handleToolError(error, runId) {
    var _a3;
    const run = this.getRunById(runId);
    if (!run || (run == null ? void 0 : run.run_type) !== "tool") throw new Error("No tool run to end");
    run.end_time = Date.now();
    run.error = this.stringifyError(error);
    run.events.push({
      name: "error",
      time: new Date(run.end_time).toISOString()
    });
    await ((_a3 = this.onToolError) == null ? void 0 : _a3.call(this, run));
    await this._endTrace(run);
    return run;
  }
  async handleAgentAction(action, runId) {
    var _a3;
    const run = this.getRunById(runId);
    if (!run || (run == null ? void 0 : run.run_type) !== "chain") return;
    const agentRun = run;
    agentRun.actions = agentRun.actions || [];
    agentRun.actions.push(action);
    agentRun.events.push({
      name: "agent_action",
      time: (/* @__PURE__ */ new Date()).toISOString(),
      kwargs: { action }
    });
    await ((_a3 = this.onAgentAction) == null ? void 0 : _a3.call(this, run));
  }
  async handleAgentEnd(action, runId) {
    var _a3;
    const run = this.getRunById(runId);
    if (!run || (run == null ? void 0 : run.run_type) !== "chain") return;
    run.events.push({
      name: "agent_end",
      time: (/* @__PURE__ */ new Date()).toISOString(),
      kwargs: { action }
    });
    await ((_a3 = this.onAgentEnd) == null ? void 0 : _a3.call(this, run));
  }
  /**
  * Create and add a run to the run map for retriever start events.
  * This must sometimes be done synchronously to avoid race conditions
  * when callbacks are backgrounded, so we expose it as a separate method here.
  */
  _createRunForRetrieverStart(retriever, query, runId, parentRunId, tags, metadata, name) {
    const execution_order = this._getExecutionOrder(parentRunId);
    const start_time = Date.now();
    const run = {
      id: runId,
      name: name ?? retriever.id[retriever.id.length - 1],
      parent_run_id: parentRunId,
      start_time,
      serialized: retriever,
      events: [{
        name: "start",
        time: new Date(start_time).toISOString()
      }],
      inputs: { query },
      execution_order,
      child_execution_order: execution_order,
      run_type: "retriever",
      child_runs: [],
      extra: metadata ? { metadata } : {},
      tags: tags || []
    };
    return this._addRunToRunMap(run);
  }
  async handleRetrieverStart(retriever, query, runId, parentRunId, tags, metadata, name) {
    var _a3, _b;
    const run = this.getRunById(runId) ?? this._createRunForRetrieverStart(retriever, query, runId, parentRunId, tags, metadata, name);
    await ((_a3 = this.onRunCreate) == null ? void 0 : _a3.call(this, run));
    await ((_b = this.onRetrieverStart) == null ? void 0 : _b.call(this, run));
    return run;
  }
  async handleRetrieverEnd(documents, runId) {
    var _a3;
    const run = this.getRunById(runId);
    if (!run || (run == null ? void 0 : run.run_type) !== "retriever") throw new Error("No retriever run to end");
    run.end_time = Date.now();
    run.outputs = { documents };
    run.events.push({
      name: "end",
      time: new Date(run.end_time).toISOString()
    });
    await ((_a3 = this.onRetrieverEnd) == null ? void 0 : _a3.call(this, run));
    await this._endTrace(run);
    return run;
  }
  async handleRetrieverError(error, runId) {
    var _a3;
    const run = this.getRunById(runId);
    if (!run || (run == null ? void 0 : run.run_type) !== "retriever") throw new Error("No retriever run to end");
    run.end_time = Date.now();
    run.error = this.stringifyError(error);
    run.events.push({
      name: "error",
      time: new Date(run.end_time).toISOString()
    });
    await ((_a3 = this.onRetrieverError) == null ? void 0 : _a3.call(this, run));
    await this._endTrace(run);
    return run;
  }
  async handleText(text, runId) {
    var _a3;
    const run = this.getRunById(runId);
    if (!run || (run == null ? void 0 : run.run_type) !== "chain") return;
    run.events.push({
      name: "text",
      time: (/* @__PURE__ */ new Date()).toISOString(),
      kwargs: { text }
    });
    await ((_a3 = this.onText) == null ? void 0 : _a3.call(this, run));
  }
  async handleLLMNewToken(token, idx, runId, _parentRunId, _tags, fields) {
    var _a3;
    const run = this.getRunById(runId);
    if (!run || (run == null ? void 0 : run.run_type) !== "llm") throw new Error(`Invalid "runId" provided to "handleLLMNewToken" callback.`);
    run.events.push({
      name: "new_token",
      time: (/* @__PURE__ */ new Date()).toISOString(),
      kwargs: {
        token,
        idx,
        chunk: fields == null ? void 0 : fields.chunk
      }
    });
    await ((_a3 = this.onLLMNewToken) == null ? void 0 : _a3.call(this, run, token, { chunk: fields == null ? void 0 : fields.chunk }));
    return run;
  }
};
var ansiStyles = { exports: {} };
ansiStyles.exports;
(function(module) {
  const ANSI_BACKGROUND_OFFSET = 10;
  const wrapAnsi256 = (offset = 0) => (code2) => `\x1B[${38 + offset};5;${code2}m`;
  const wrapAnsi16m = (offset = 0) => (red, green, blue) => `\x1B[${38 + offset};2;${red};${green};${blue}m`;
  function assembleStyles() {
    const codes = /* @__PURE__ */ new Map();
    const styles2 = {
      modifier: {
        reset: [0, 0],
        // 21 isn't widely supported and 22 does the same thing
        bold: [1, 22],
        dim: [2, 22],
        italic: [3, 23],
        underline: [4, 24],
        overline: [53, 55],
        inverse: [7, 27],
        hidden: [8, 28],
        strikethrough: [9, 29]
      },
      color: {
        black: [30, 39],
        red: [31, 39],
        green: [32, 39],
        yellow: [33, 39],
        blue: [34, 39],
        magenta: [35, 39],
        cyan: [36, 39],
        white: [37, 39],
        // Bright color
        blackBright: [90, 39],
        redBright: [91, 39],
        greenBright: [92, 39],
        yellowBright: [93, 39],
        blueBright: [94, 39],
        magentaBright: [95, 39],
        cyanBright: [96, 39],
        whiteBright: [97, 39]
      },
      bgColor: {
        bgBlack: [40, 49],
        bgRed: [41, 49],
        bgGreen: [42, 49],
        bgYellow: [43, 49],
        bgBlue: [44, 49],
        bgMagenta: [45, 49],
        bgCyan: [46, 49],
        bgWhite: [47, 49],
        // Bright color
        bgBlackBright: [100, 49],
        bgRedBright: [101, 49],
        bgGreenBright: [102, 49],
        bgYellowBright: [103, 49],
        bgBlueBright: [104, 49],
        bgMagentaBright: [105, 49],
        bgCyanBright: [106, 49],
        bgWhiteBright: [107, 49]
      }
    };
    styles2.color.gray = styles2.color.blackBright;
    styles2.bgColor.bgGray = styles2.bgColor.bgBlackBright;
    styles2.color.grey = styles2.color.blackBright;
    styles2.bgColor.bgGrey = styles2.bgColor.bgBlackBright;
    for (const [groupName, group] of Object.entries(styles2)) {
      for (const [styleName, style] of Object.entries(group)) {
        styles2[styleName] = {
          open: `\x1B[${style[0]}m`,
          close: `\x1B[${style[1]}m`
        };
        group[styleName] = styles2[styleName];
        codes.set(style[0], style[1]);
      }
      Object.defineProperty(styles2, groupName, {
        value: group,
        enumerable: false
      });
    }
    Object.defineProperty(styles2, "codes", {
      value: codes,
      enumerable: false
    });
    styles2.color.close = "\x1B[39m";
    styles2.bgColor.close = "\x1B[49m";
    styles2.color.ansi256 = wrapAnsi256();
    styles2.color.ansi16m = wrapAnsi16m();
    styles2.bgColor.ansi256 = wrapAnsi256(ANSI_BACKGROUND_OFFSET);
    styles2.bgColor.ansi16m = wrapAnsi16m(ANSI_BACKGROUND_OFFSET);
    Object.defineProperties(styles2, {
      rgbToAnsi256: {
        value: (red, green, blue) => {
          if (red === green && green === blue) {
            if (red < 8) {
              return 16;
            }
            if (red > 248) {
              return 231;
            }
            return Math.round((red - 8) / 247 * 24) + 232;
          }
          return 16 + 36 * Math.round(red / 255 * 5) + 6 * Math.round(green / 255 * 5) + Math.round(blue / 255 * 5);
        },
        enumerable: false
      },
      hexToRgb: {
        value: (hex) => {
          const matches = /(?<colorString>[a-f\d]{6}|[a-f\d]{3})/i.exec(hex.toString(16));
          if (!matches) {
            return [0, 0, 0];
          }
          let { colorString } = matches.groups;
          if (colorString.length === 3) {
            colorString = colorString.split("").map((character) => character + character).join("");
          }
          const integer2 = Number.parseInt(colorString, 16);
          return [
            integer2 >> 16 & 255,
            integer2 >> 8 & 255,
            integer2 & 255
          ];
        },
        enumerable: false
      },
      hexToAnsi256: {
        value: (hex) => styles2.rgbToAnsi256(...styles2.hexToRgb(hex)),
        enumerable: false
      }
    });
    return styles2;
  }
  Object.defineProperty(module, "exports", {
    enumerable: true,
    get: assembleStyles
  });
})(ansiStyles);
var ansiStylesExports = ansiStyles.exports;
const styles = /* @__PURE__ */ getDefaultExportFromCjs(ansiStylesExports);
var console_exports = {};
__export(console_exports, { ConsoleCallbackHandler: () => ConsoleCallbackHandler });
function wrap(style, text) {
  return `${style.open}${text}${style.close}`;
}
function tryJsonStringify(obj, fallback) {
  try {
    return JSON.stringify(obj, null, 2);
  } catch {
    return fallback;
  }
}
function formatKVMapItem(value) {
  if (typeof value === "string") return value.trim();
  if (value === null || value === void 0) return value;
  return tryJsonStringify(value, value.toString());
}
function elapsed(run) {
  if (!run.end_time) return "";
  const elapsed$1 = run.end_time - run.start_time;
  if (elapsed$1 < 1e3) return `${elapsed$1}ms`;
  return `${(elapsed$1 / 1e3).toFixed(2)}s`;
}
const { color } = styles;
var ConsoleCallbackHandler = class extends BaseTracer {
  constructor() {
    super(...arguments);
    __publicField2(this, "name", "console_callback_handler");
  }
  /**
  * Method used to persist the run. In this case, it simply returns a
  * resolved promise as there's no persistence logic.
  * @param _run The run to persist.
  * @returns A resolved promise.
  */
  persistRun(_run) {
    return Promise.resolve();
  }
  /**
  * Method used to get all the parent runs of a given run.
  * @param run The run whose parents are to be retrieved.
  * @returns An array of parent runs.
  */
  getParents(run) {
    const parents = [];
    let currentRun = run;
    while (currentRun.parent_run_id) {
      const parent = this.runMap.get(currentRun.parent_run_id);
      if (parent) {
        parents.push(parent);
        currentRun = parent;
      } else break;
    }
    return parents;
  }
  /**
  * Method used to get a string representation of the run's lineage, which
  * is used in logging.
  * @param run The run whose lineage is to be retrieved.
  * @returns A string representation of the run's lineage.
  */
  getBreadcrumbs(run) {
    const parents = this.getParents(run).reverse();
    const string2 = [...parents, run].map((parent, i2, arr2) => {
      const name = `${parent.execution_order}:${parent.run_type}:${parent.name}`;
      return i2 === arr2.length - 1 ? wrap(styles.bold, name) : name;
    }).join(" > ");
    return wrap(color.grey, string2);
  }
  /**
  * Method used to log the start of a chain run.
  * @param run The chain run that has started.
  * @returns void
  */
  onChainStart(run) {
    const crumbs = this.getBreadcrumbs(run);
    console.log(`${wrap(color.green, "[chain/start]")} [${crumbs}] Entering Chain run with input: ${tryJsonStringify(run.inputs, "[inputs]")}`);
  }
  /**
  * Method used to log the end of a chain run.
  * @param run The chain run that has ended.
  * @returns void
  */
  onChainEnd(run) {
    const crumbs = this.getBreadcrumbs(run);
    console.log(`${wrap(color.cyan, "[chain/end]")} [${crumbs}] [${elapsed(run)}] Exiting Chain run with output: ${tryJsonStringify(run.outputs, "[outputs]")}`);
  }
  /**
  * Method used to log any errors of a chain run.
  * @param run The chain run that has errored.
  * @returns void
  */
  onChainError(run) {
    const crumbs = this.getBreadcrumbs(run);
    console.log(`${wrap(color.red, "[chain/error]")} [${crumbs}] [${elapsed(run)}] Chain run errored with error: ${tryJsonStringify(run.error, "[error]")}`);
  }
  /**
  * Method used to log the start of an LLM run.
  * @param run The LLM run that has started.
  * @returns void
  */
  onLLMStart(run) {
    const crumbs = this.getBreadcrumbs(run);
    const inputs = "prompts" in run.inputs ? { prompts: run.inputs.prompts.map((p) => p.trim()) } : run.inputs;
    console.log(`${wrap(color.green, "[llm/start]")} [${crumbs}] Entering LLM run with input: ${tryJsonStringify(inputs, "[inputs]")}`);
  }
  /**
  * Method used to log the end of an LLM run.
  * @param run The LLM run that has ended.
  * @returns void
  */
  onLLMEnd(run) {
    const crumbs = this.getBreadcrumbs(run);
    console.log(`${wrap(color.cyan, "[llm/end]")} [${crumbs}] [${elapsed(run)}] Exiting LLM run with output: ${tryJsonStringify(run.outputs, "[response]")}`);
  }
  /**
  * Method used to log any errors of an LLM run.
  * @param run The LLM run that has errored.
  * @returns void
  */
  onLLMError(run) {
    const crumbs = this.getBreadcrumbs(run);
    console.log(`${wrap(color.red, "[llm/error]")} [${crumbs}] [${elapsed(run)}] LLM run errored with error: ${tryJsonStringify(run.error, "[error]")}`);
  }
  /**
  * Method used to log the start of a tool run.
  * @param run The tool run that has started.
  * @returns void
  */
  onToolStart(run) {
    const crumbs = this.getBreadcrumbs(run);
    console.log(`${wrap(color.green, "[tool/start]")} [${crumbs}] Entering Tool run with input: "${formatKVMapItem(run.inputs.input)}"`);
  }
  /**
  * Method used to log the end of a tool run.
  * @param run The tool run that has ended.
  * @returns void
  */
  onToolEnd(run) {
    var _a3;
    const crumbs = this.getBreadcrumbs(run);
    console.log(`${wrap(color.cyan, "[tool/end]")} [${crumbs}] [${elapsed(run)}] Exiting Tool run with output: "${formatKVMapItem((_a3 = run.outputs) == null ? void 0 : _a3.output)}"`);
  }
  /**
  * Method used to log any errors of a tool run.
  * @param run The tool run that has errored.
  * @returns void
  */
  onToolError(run) {
    const crumbs = this.getBreadcrumbs(run);
    console.log(`${wrap(color.red, "[tool/error]")} [${crumbs}] [${elapsed(run)}] Tool run errored with error: ${tryJsonStringify(run.error, "[error]")}`);
  }
  /**
  * Method used to log the start of a retriever run.
  * @param run The retriever run that has started.
  * @returns void
  */
  onRetrieverStart(run) {
    const crumbs = this.getBreadcrumbs(run);
    console.log(`${wrap(color.green, "[retriever/start]")} [${crumbs}] Entering Retriever run with input: ${tryJsonStringify(run.inputs, "[inputs]")}`);
  }
  /**
  * Method used to log the end of a retriever run.
  * @param run The retriever run that has ended.
  * @returns void
  */
  onRetrieverEnd(run) {
    const crumbs = this.getBreadcrumbs(run);
    console.log(`${wrap(color.cyan, "[retriever/end]")} [${crumbs}] [${elapsed(run)}] Exiting Retriever run with output: ${tryJsonStringify(run.outputs, "[outputs]")}`);
  }
  /**
  * Method used to log any errors of a retriever run.
  * @param run The retriever run that has errored.
  * @returns void
  */
  onRetrieverError(run) {
    const crumbs = this.getBreadcrumbs(run);
    console.log(`${wrap(color.red, "[retriever/error]")} [${crumbs}] [${elapsed(run)}] Retriever run errored with error: ${tryJsonStringify(run.error, "[error]")}`);
  }
  /**
  * Method used to log the action selected by the agent.
  * @param run The run in which the agent action occurred.
  * @returns void
  */
  onAgentAction(run) {
    const agentRun = run;
    const crumbs = this.getBreadcrumbs(run);
    console.log(`${wrap(color.blue, "[agent/action]")} [${crumbs}] Agent selected action: ${tryJsonStringify(agentRun.actions[agentRun.actions.length - 1], "[action]")}`);
  }
};
let client;
const getDefaultLangChainClientSingleton = () => {
  if (client === void 0) {
    const clientParams = getEnvironmentVariable$1("LANGCHAIN_CALLBACKS_BACKGROUND") === "false" ? { blockOnRootRunFinalization: true } : {};
    client = new Client(clientParams);
  }
  return client;
};
let MockAsyncLocalStorage$1 = class MockAsyncLocalStorage2 {
  getStore() {
    return void 0;
  }
  run(_, callback) {
    return callback();
  }
};
const TRACING_ALS_KEY = Symbol.for("ls:tracing_async_local_storage");
const mockAsyncLocalStorage$1 = new MockAsyncLocalStorage$1();
let AsyncLocalStorageProvider$1 = class AsyncLocalStorageProvider2 {
  getInstance() {
    return globalThis[TRACING_ALS_KEY] ?? mockAsyncLocalStorage$1;
  }
  initializeGlobalInstance(instance) {
    if (globalThis[TRACING_ALS_KEY] === void 0) {
      globalThis[TRACING_ALS_KEY] = instance;
    }
  }
};
const AsyncLocalStorageProviderSingleton$1 = new AsyncLocalStorageProvider$1();
function getCurrentRunTree(permitAbsentRunTree = false) {
  const runTree = AsyncLocalStorageProviderSingleton$1.getInstance().getStore();
  if (!permitAbsentRunTree && runTree === void 0) {
    throw new Error("Could not get the current run tree.\n\nPlease make sure you are calling this method within a traceable function and that tracing is enabled.");
  }
  return runTree;
}
function isTraceableFunction(x) {
  return typeof x === "function" && "langsmith:traceable" in x;
}
var tracer_langchain_exports = {};
__export(tracer_langchain_exports, { LangChainTracer: () => LangChainTracer });
var LangChainTracer = class LangChainTracer2 extends BaseTracer {
  constructor(fields = {}) {
    super(fields);
    __publicField2(this, "name", "langchain_tracer");
    __publicField2(this, "projectName");
    __publicField2(this, "exampleId");
    __publicField2(this, "client");
    __publicField2(this, "replicas");
    __publicField2(this, "usesRunTreeMap", true);
    const { exampleId, projectName, client: client2, replicas } = fields;
    this.projectName = projectName ?? getDefaultProjectName();
    this.replicas = replicas;
    this.exampleId = exampleId;
    this.client = client2 ?? getDefaultLangChainClientSingleton();
    const traceableTree = LangChainTracer2.getTraceableRunTree();
    if (traceableTree) this.updateFromRunTree(traceableTree);
  }
  async persistRun(_run) {
  }
  async onRunCreate(run) {
    const runTree = this.getRunTreeWithTracingConfig(run.id);
    await (runTree == null ? void 0 : runTree.postRun());
  }
  async onRunUpdate(run) {
    const runTree = this.getRunTreeWithTracingConfig(run.id);
    await (runTree == null ? void 0 : runTree.patchRun());
  }
  getRun(id) {
    return this.runTreeMap.get(id);
  }
  updateFromRunTree(runTree) {
    this.runTreeMap.set(runTree.id, runTree);
    let rootRun = runTree;
    const visited = /* @__PURE__ */ new Set();
    while (rootRun.parent_run) {
      if (visited.has(rootRun.id)) break;
      visited.add(rootRun.id);
      if (!rootRun.parent_run) break;
      rootRun = rootRun.parent_run;
    }
    visited.clear();
    const queue2 = [rootRun];
    while (queue2.length > 0) {
      const current = queue2.shift();
      if (!current || visited.has(current.id)) continue;
      visited.add(current.id);
      this.runTreeMap.set(current.id, current);
      if (current.child_runs) queue2.push(...current.child_runs);
    }
    this.client = runTree.client ?? this.client;
    this.replicas = runTree.replicas ?? this.replicas;
    this.projectName = runTree.project_name ?? this.projectName;
    this.exampleId = runTree.reference_example_id ?? this.exampleId;
  }
  getRunTreeWithTracingConfig(id) {
    const runTree = this.runTreeMap.get(id);
    if (!runTree) return void 0;
    return new RunTree({
      ...runTree,
      client: this.client,
      project_name: this.projectName,
      replicas: this.replicas,
      reference_example_id: this.exampleId,
      tracingEnabled: true
    });
  }
  static getTraceableRunTree() {
    try {
      return getCurrentRunTree(true);
    } catch {
      return void 0;
    }
  }
};
let queue;
function createQueue() {
  const PQueue2 = "default" in _default$1 ? _default$1.default : _default$1;
  return new PQueue2({
    autoStart: true,
    concurrency: 1
  });
}
function getQueue() {
  if (typeof queue === "undefined") queue = createQueue();
  return queue;
}
async function consumeCallback(promiseFn, wait) {
  if (wait === true) {
    const asyncLocalStorageInstance = getGlobalAsyncLocalStorageInstance();
    if (asyncLocalStorageInstance !== void 0) await asyncLocalStorageInstance.run(void 0, async () => promiseFn());
    else await promiseFn();
  } else {
    queue = getQueue();
    queue.add(async () => {
      const asyncLocalStorageInstance = getGlobalAsyncLocalStorageInstance();
      if (asyncLocalStorageInstance !== void 0) await asyncLocalStorageInstance.run(void 0, async () => promiseFn());
      else await promiseFn();
    });
  }
}
async function awaitAllCallbacks() {
  const defaultClient = getDefaultLangChainClientSingleton();
  await Promise.allSettled([typeof queue !== "undefined" ? queue.onIdle() : Promise.resolve(), defaultClient.awaitPendingTraceBatches()]);
}
var promises_exports = {};
__export(promises_exports, {
  awaitAllCallbacks: () => awaitAllCallbacks,
  consumeCallback: () => consumeCallback
});
const isTracingEnabled = (tracingEnabled) => {
  const envVars = [
    "LANGSMITH_TRACING_V2",
    "LANGCHAIN_TRACING_V2",
    "LANGSMITH_TRACING",
    "LANGCHAIN_TRACING"
  ];
  return !!envVars.find((envVar) => getEnvironmentVariable$1(envVar) === "true");
};
function getContextVariable(name) {
  var _a3;
  const asyncLocalStorageInstance = getGlobalAsyncLocalStorageInstance();
  if (asyncLocalStorageInstance === void 0) return void 0;
  const runTree = asyncLocalStorageInstance.getStore();
  return (_a3 = runTree == null ? void 0 : runTree[_CONTEXT_VARIABLES_KEY]) == null ? void 0 : _a3[name];
}
const LC_CONFIGURE_HOOKS_KEY = Symbol("lc:configure_hooks");
const _getConfigureHooks = () => getContextVariable(LC_CONFIGURE_HOOKS_KEY) || [];
var manager_exports = {};
__export(manager_exports, {
  BaseCallbackManager: () => BaseCallbackManager,
  BaseRunManager: () => BaseRunManager,
  CallbackManager: () => CallbackManager,
  CallbackManagerForChainRun: () => CallbackManagerForChainRun,
  CallbackManagerForLLMRun: () => CallbackManagerForLLMRun,
  CallbackManagerForRetrieverRun: () => CallbackManagerForRetrieverRun,
  CallbackManagerForToolRun: () => CallbackManagerForToolRun,
  ensureHandler: () => ensureHandler,
  parseCallbackConfigArg: () => parseCallbackConfigArg
});
function parseCallbackConfigArg(arg) {
  if (!arg) return {};
  else if (Array.isArray(arg) || "name" in arg) return { callbacks: arg };
  else return arg;
}
var BaseCallbackManager = class {
  setHandler(handler) {
    return this.setHandlers([handler]);
  }
};
var BaseRunManager = class {
  constructor(runId, handlers, inheritableHandlers, tags, inheritableTags, metadata, inheritableMetadata, _parentRunId) {
    this.runId = runId;
    this.handlers = handlers;
    this.inheritableHandlers = inheritableHandlers;
    this.tags = tags;
    this.inheritableTags = inheritableTags;
    this.metadata = metadata;
    this.inheritableMetadata = inheritableMetadata;
    this._parentRunId = _parentRunId;
  }
  get parentRunId() {
    return this._parentRunId;
  }
  async handleText(text) {
    await Promise.all(this.handlers.map((handler) => consumeCallback(async () => {
      var _a3;
      try {
        await ((_a3 = handler.handleText) == null ? void 0 : _a3.call(handler, text, this.runId, this._parentRunId, this.tags));
      } catch (err) {
        const logFunction = handler.raiseError ? console.error : console.warn;
        logFunction(`Error in handler ${handler.constructor.name}, handleText: ${err}`);
        if (handler.raiseError) throw err;
      }
    }, handler.awaitHandlers)));
  }
  async handleCustomEvent(eventName, data, _runId, _tags, _metadata) {
    await Promise.all(this.handlers.map((handler) => consumeCallback(async () => {
      var _a3;
      try {
        await ((_a3 = handler.handleCustomEvent) == null ? void 0 : _a3.call(handler, eventName, data, this.runId, this.tags, this.metadata));
      } catch (err) {
        const logFunction = handler.raiseError ? console.error : console.warn;
        logFunction(`Error in handler ${handler.constructor.name}, handleCustomEvent: ${err}`);
        if (handler.raiseError) throw err;
      }
    }, handler.awaitHandlers)));
  }
};
var CallbackManagerForRetrieverRun = class extends BaseRunManager {
  getChild(tag) {
    const manager = new CallbackManager(this.runId);
    manager.setHandlers(this.inheritableHandlers);
    manager.addTags(this.inheritableTags);
    manager.addMetadata(this.inheritableMetadata);
    if (tag) manager.addTags([tag], false);
    return manager;
  }
  async handleRetrieverEnd(documents) {
    await Promise.all(this.handlers.map((handler) => consumeCallback(async () => {
      var _a3;
      if (!handler.ignoreRetriever) try {
        await ((_a3 = handler.handleRetrieverEnd) == null ? void 0 : _a3.call(handler, documents, this.runId, this._parentRunId, this.tags));
      } catch (err) {
        const logFunction = handler.raiseError ? console.error : console.warn;
        logFunction(`Error in handler ${handler.constructor.name}, handleRetriever`);
        if (handler.raiseError) throw err;
      }
    }, handler.awaitHandlers)));
  }
  async handleRetrieverError(err) {
    await Promise.all(this.handlers.map((handler) => consumeCallback(async () => {
      var _a3;
      if (!handler.ignoreRetriever) try {
        await ((_a3 = handler.handleRetrieverError) == null ? void 0 : _a3.call(handler, err, this.runId, this._parentRunId, this.tags));
      } catch (error) {
        const logFunction = handler.raiseError ? console.error : console.warn;
        logFunction(`Error in handler ${handler.constructor.name}, handleRetrieverError: ${error}`);
        if (handler.raiseError) throw err;
      }
    }, handler.awaitHandlers)));
  }
};
var CallbackManagerForLLMRun = class extends BaseRunManager {
  async handleLLMNewToken(token, idx, _runId, _parentRunId, _tags, fields) {
    await Promise.all(this.handlers.map((handler) => consumeCallback(async () => {
      var _a3;
      if (!handler.ignoreLLM) try {
        await ((_a3 = handler.handleLLMNewToken) == null ? void 0 : _a3.call(handler, token, idx ?? {
          prompt: 0,
          completion: 0
        }, this.runId, this._parentRunId, this.tags, fields));
      } catch (err) {
        const logFunction = handler.raiseError ? console.error : console.warn;
        logFunction(`Error in handler ${handler.constructor.name}, handleLLMNewToken: ${err}`);
        if (handler.raiseError) throw err;
      }
    }, handler.awaitHandlers)));
  }
  async handleLLMError(err, _runId, _parentRunId, _tags, extraParams) {
    await Promise.all(this.handlers.map((handler) => consumeCallback(async () => {
      var _a3;
      if (!handler.ignoreLLM) try {
        await ((_a3 = handler.handleLLMError) == null ? void 0 : _a3.call(handler, err, this.runId, this._parentRunId, this.tags, extraParams));
      } catch (err$1) {
        const logFunction = handler.raiseError ? console.error : console.warn;
        logFunction(`Error in handler ${handler.constructor.name}, handleLLMError: ${err$1}`);
        if (handler.raiseError) throw err$1;
      }
    }, handler.awaitHandlers)));
  }
  async handleLLMEnd(output, _runId, _parentRunId, _tags, extraParams) {
    await Promise.all(this.handlers.map((handler) => consumeCallback(async () => {
      var _a3;
      if (!handler.ignoreLLM) try {
        await ((_a3 = handler.handleLLMEnd) == null ? void 0 : _a3.call(handler, output, this.runId, this._parentRunId, this.tags, extraParams));
      } catch (err) {
        const logFunction = handler.raiseError ? console.error : console.warn;
        logFunction(`Error in handler ${handler.constructor.name}, handleLLMEnd: ${err}`);
        if (handler.raiseError) throw err;
      }
    }, handler.awaitHandlers)));
  }
};
var CallbackManagerForChainRun = class extends BaseRunManager {
  getChild(tag) {
    const manager = new CallbackManager(this.runId);
    manager.setHandlers(this.inheritableHandlers);
    manager.addTags(this.inheritableTags);
    manager.addMetadata(this.inheritableMetadata);
    if (tag) manager.addTags([tag], false);
    return manager;
  }
  async handleChainError(err, _runId, _parentRunId, _tags, kwargs) {
    await Promise.all(this.handlers.map((handler) => consumeCallback(async () => {
      var _a3;
      if (!handler.ignoreChain) try {
        await ((_a3 = handler.handleChainError) == null ? void 0 : _a3.call(handler, err, this.runId, this._parentRunId, this.tags, kwargs));
      } catch (err$1) {
        const logFunction = handler.raiseError ? console.error : console.warn;
        logFunction(`Error in handler ${handler.constructor.name}, handleChainError: ${err$1}`);
        if (handler.raiseError) throw err$1;
      }
    }, handler.awaitHandlers)));
  }
  async handleChainEnd(output, _runId, _parentRunId, _tags, kwargs) {
    await Promise.all(this.handlers.map((handler) => consumeCallback(async () => {
      var _a3;
      if (!handler.ignoreChain) try {
        await ((_a3 = handler.handleChainEnd) == null ? void 0 : _a3.call(handler, output, this.runId, this._parentRunId, this.tags, kwargs));
      } catch (err) {
        const logFunction = handler.raiseError ? console.error : console.warn;
        logFunction(`Error in handler ${handler.constructor.name}, handleChainEnd: ${err}`);
        if (handler.raiseError) throw err;
      }
    }, handler.awaitHandlers)));
  }
  async handleAgentAction(action) {
    await Promise.all(this.handlers.map((handler) => consumeCallback(async () => {
      var _a3;
      if (!handler.ignoreAgent) try {
        await ((_a3 = handler.handleAgentAction) == null ? void 0 : _a3.call(handler, action, this.runId, this._parentRunId, this.tags));
      } catch (err) {
        const logFunction = handler.raiseError ? console.error : console.warn;
        logFunction(`Error in handler ${handler.constructor.name}, handleAgentAction: ${err}`);
        if (handler.raiseError) throw err;
      }
    }, handler.awaitHandlers)));
  }
  async handleAgentEnd(action) {
    await Promise.all(this.handlers.map((handler) => consumeCallback(async () => {
      var _a3;
      if (!handler.ignoreAgent) try {
        await ((_a3 = handler.handleAgentEnd) == null ? void 0 : _a3.call(handler, action, this.runId, this._parentRunId, this.tags));
      } catch (err) {
        const logFunction = handler.raiseError ? console.error : console.warn;
        logFunction(`Error in handler ${handler.constructor.name}, handleAgentEnd: ${err}`);
        if (handler.raiseError) throw err;
      }
    }, handler.awaitHandlers)));
  }
};
var CallbackManagerForToolRun = class extends BaseRunManager {
  getChild(tag) {
    const manager = new CallbackManager(this.runId);
    manager.setHandlers(this.inheritableHandlers);
    manager.addTags(this.inheritableTags);
    manager.addMetadata(this.inheritableMetadata);
    if (tag) manager.addTags([tag], false);
    return manager;
  }
  async handleToolError(err) {
    await Promise.all(this.handlers.map((handler) => consumeCallback(async () => {
      var _a3;
      if (!handler.ignoreAgent) try {
        await ((_a3 = handler.handleToolError) == null ? void 0 : _a3.call(handler, err, this.runId, this._parentRunId, this.tags));
      } catch (err$1) {
        const logFunction = handler.raiseError ? console.error : console.warn;
        logFunction(`Error in handler ${handler.constructor.name}, handleToolError: ${err$1}`);
        if (handler.raiseError) throw err$1;
      }
    }, handler.awaitHandlers)));
  }
  async handleToolEnd(output) {
    await Promise.all(this.handlers.map((handler) => consumeCallback(async () => {
      var _a3;
      if (!handler.ignoreAgent) try {
        await ((_a3 = handler.handleToolEnd) == null ? void 0 : _a3.call(handler, output, this.runId, this._parentRunId, this.tags));
      } catch (err) {
        const logFunction = handler.raiseError ? console.error : console.warn;
        logFunction(`Error in handler ${handler.constructor.name}, handleToolEnd: ${err}`);
        if (handler.raiseError) throw err;
      }
    }, handler.awaitHandlers)));
  }
};
var CallbackManager = class CallbackManager2 extends BaseCallbackManager {
  constructor(parentRunId, options2) {
    super();
    __publicField2(this, "handlers", []);
    __publicField2(this, "inheritableHandlers", []);
    __publicField2(this, "tags", []);
    __publicField2(this, "inheritableTags", []);
    __publicField2(this, "metadata", {});
    __publicField2(this, "inheritableMetadata", {});
    __publicField2(this, "name", "callback_manager");
    __publicField2(this, "_parentRunId");
    this.handlers = (options2 == null ? void 0 : options2.handlers) ?? this.handlers;
    this.inheritableHandlers = (options2 == null ? void 0 : options2.inheritableHandlers) ?? this.inheritableHandlers;
    this.tags = (options2 == null ? void 0 : options2.tags) ?? this.tags;
    this.inheritableTags = (options2 == null ? void 0 : options2.inheritableTags) ?? this.inheritableTags;
    this.metadata = (options2 == null ? void 0 : options2.metadata) ?? this.metadata;
    this.inheritableMetadata = (options2 == null ? void 0 : options2.inheritableMetadata) ?? this.inheritableMetadata;
    this._parentRunId = parentRunId;
  }
  /**
  * Gets the parent run ID, if any.
  *
  * @returns The parent run ID.
  */
  getParentRunId() {
    return this._parentRunId;
  }
  async handleLLMStart(llm, prompts, runId = void 0, _parentRunId = void 0, extraParams = void 0, _tags = void 0, _metadata = void 0, runName = void 0) {
    return Promise.all(prompts.map(async (prompt, idx) => {
      const runId_ = idx === 0 && runId ? runId : v4$1();
      await Promise.all(this.handlers.map((handler) => {
        if (handler.ignoreLLM) return;
        if (isBaseTracer(handler)) handler._createRunForLLMStart(llm, [prompt], runId_, this._parentRunId, extraParams, this.tags, this.metadata, runName);
        return consumeCallback(async () => {
          var _a3;
          try {
            await ((_a3 = handler.handleLLMStart) == null ? void 0 : _a3.call(handler, llm, [prompt], runId_, this._parentRunId, extraParams, this.tags, this.metadata, runName));
          } catch (err) {
            const logFunction = handler.raiseError ? console.error : console.warn;
            logFunction(`Error in handler ${handler.constructor.name}, handleLLMStart: ${err}`);
            if (handler.raiseError) throw err;
          }
        }, handler.awaitHandlers);
      }));
      return new CallbackManagerForLLMRun(runId_, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);
    }));
  }
  async handleChatModelStart(llm, messages, runId = void 0, _parentRunId = void 0, extraParams = void 0, _tags = void 0, _metadata = void 0, runName = void 0) {
    return Promise.all(messages.map(async (messageGroup, idx) => {
      const runId_ = idx === 0 && runId ? runId : v4$1();
      await Promise.all(this.handlers.map((handler) => {
        if (handler.ignoreLLM) return;
        if (isBaseTracer(handler)) handler._createRunForChatModelStart(llm, [messageGroup], runId_, this._parentRunId, extraParams, this.tags, this.metadata, runName);
        return consumeCallback(async () => {
          var _a3, _b;
          try {
            if (handler.handleChatModelStart) await ((_a3 = handler.handleChatModelStart) == null ? void 0 : _a3.call(handler, llm, [messageGroup], runId_, this._parentRunId, extraParams, this.tags, this.metadata, runName));
            else if (handler.handleLLMStart) {
              const messageString = getBufferString(messageGroup);
              await ((_b = handler.handleLLMStart) == null ? void 0 : _b.call(handler, llm, [messageString], runId_, this._parentRunId, extraParams, this.tags, this.metadata, runName));
            }
          } catch (err) {
            const logFunction = handler.raiseError ? console.error : console.warn;
            logFunction(`Error in handler ${handler.constructor.name}, handleLLMStart: ${err}`);
            if (handler.raiseError) throw err;
          }
        }, handler.awaitHandlers);
      }));
      return new CallbackManagerForLLMRun(runId_, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);
    }));
  }
  async handleChainStart(chain, inputs, runId = v4$1(), runType = void 0, _tags = void 0, _metadata = void 0, runName = void 0) {
    await Promise.all(this.handlers.map((handler) => {
      if (handler.ignoreChain) return;
      if (isBaseTracer(handler)) handler._createRunForChainStart(chain, inputs, runId, this._parentRunId, this.tags, this.metadata, runType, runName);
      return consumeCallback(async () => {
        var _a3;
        try {
          await ((_a3 = handler.handleChainStart) == null ? void 0 : _a3.call(handler, chain, inputs, runId, this._parentRunId, this.tags, this.metadata, runType, runName));
        } catch (err) {
          const logFunction = handler.raiseError ? console.error : console.warn;
          logFunction(`Error in handler ${handler.constructor.name}, handleChainStart: ${err}`);
          if (handler.raiseError) throw err;
        }
      }, handler.awaitHandlers);
    }));
    return new CallbackManagerForChainRun(runId, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);
  }
  async handleToolStart(tool2, input, runId = v4$1(), _parentRunId = void 0, _tags = void 0, _metadata = void 0, runName = void 0) {
    await Promise.all(this.handlers.map((handler) => {
      if (handler.ignoreAgent) return;
      if (isBaseTracer(handler)) handler._createRunForToolStart(tool2, input, runId, this._parentRunId, this.tags, this.metadata, runName);
      return consumeCallback(async () => {
        var _a3;
        try {
          await ((_a3 = handler.handleToolStart) == null ? void 0 : _a3.call(handler, tool2, input, runId, this._parentRunId, this.tags, this.metadata, runName));
        } catch (err) {
          const logFunction = handler.raiseError ? console.error : console.warn;
          logFunction(`Error in handler ${handler.constructor.name}, handleToolStart: ${err}`);
          if (handler.raiseError) throw err;
        }
      }, handler.awaitHandlers);
    }));
    return new CallbackManagerForToolRun(runId, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);
  }
  async handleRetrieverStart(retriever, query, runId = v4$1(), _parentRunId = void 0, _tags = void 0, _metadata = void 0, runName = void 0) {
    await Promise.all(this.handlers.map((handler) => {
      if (handler.ignoreRetriever) return;
      if (isBaseTracer(handler)) handler._createRunForRetrieverStart(retriever, query, runId, this._parentRunId, this.tags, this.metadata, runName);
      return consumeCallback(async () => {
        var _a3;
        try {
          await ((_a3 = handler.handleRetrieverStart) == null ? void 0 : _a3.call(handler, retriever, query, runId, this._parentRunId, this.tags, this.metadata, runName));
        } catch (err) {
          const logFunction = handler.raiseError ? console.error : console.warn;
          logFunction(`Error in handler ${handler.constructor.name}, handleRetrieverStart: ${err}`);
          if (handler.raiseError) throw err;
        }
      }, handler.awaitHandlers);
    }));
    return new CallbackManagerForRetrieverRun(runId, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);
  }
  async handleCustomEvent(eventName, data, runId, _tags, _metadata) {
    await Promise.all(this.handlers.map((handler) => consumeCallback(async () => {
      var _a3;
      if (!handler.ignoreCustomEvent) try {
        await ((_a3 = handler.handleCustomEvent) == null ? void 0 : _a3.call(handler, eventName, data, runId, this.tags, this.metadata));
      } catch (err) {
        const logFunction = handler.raiseError ? console.error : console.warn;
        logFunction(`Error in handler ${handler.constructor.name}, handleCustomEvent: ${err}`);
        if (handler.raiseError) throw err;
      }
    }, handler.awaitHandlers)));
  }
  addHandler(handler, inherit = true) {
    this.handlers.push(handler);
    if (inherit) this.inheritableHandlers.push(handler);
  }
  removeHandler(handler) {
    this.handlers = this.handlers.filter((_handler) => _handler !== handler);
    this.inheritableHandlers = this.inheritableHandlers.filter((_handler) => _handler !== handler);
  }
  setHandlers(handlers, inherit = true) {
    this.handlers = [];
    this.inheritableHandlers = [];
    for (const handler of handlers) this.addHandler(handler, inherit);
  }
  addTags(tags, inherit = true) {
    this.removeTags(tags);
    this.tags.push(...tags);
    if (inherit) this.inheritableTags.push(...tags);
  }
  removeTags(tags) {
    this.tags = this.tags.filter((tag) => !tags.includes(tag));
    this.inheritableTags = this.inheritableTags.filter((tag) => !tags.includes(tag));
  }
  addMetadata(metadata, inherit = true) {
    this.metadata = {
      ...this.metadata,
      ...metadata
    };
    if (inherit) this.inheritableMetadata = {
      ...this.inheritableMetadata,
      ...metadata
    };
  }
  removeMetadata(metadata) {
    for (const key of Object.keys(metadata)) {
      delete this.metadata[key];
      delete this.inheritableMetadata[key];
    }
  }
  copy(additionalHandlers = [], inherit = true) {
    const manager = new CallbackManager2(this._parentRunId);
    for (const handler of this.handlers) {
      const inheritable = this.inheritableHandlers.includes(handler);
      manager.addHandler(handler, inheritable);
    }
    for (const tag of this.tags) {
      const inheritable = this.inheritableTags.includes(tag);
      manager.addTags([tag], inheritable);
    }
    for (const key of Object.keys(this.metadata)) {
      const inheritable = Object.keys(this.inheritableMetadata).includes(key);
      manager.addMetadata({ [key]: this.metadata[key] }, inheritable);
    }
    for (const handler of additionalHandlers) {
      if (manager.handlers.filter((h) => h.name === "console_callback_handler").some((h) => h.name === handler.name)) continue;
      manager.addHandler(handler, inherit);
    }
    return manager;
  }
  static fromHandlers(handlers) {
    class Handler extends BaseCallbackHandler {
      constructor() {
        super();
        __publicField2(this, "name", v4$1());
        Object.assign(this, handlers);
      }
    }
    const manager = new this();
    manager.addHandler(new Handler());
    return manager;
  }
  static configure(inheritableHandlers, localHandlers, inheritableTags, localTags, inheritableMetadata, localMetadata, options2) {
    return this._configureSync(inheritableHandlers, localHandlers, inheritableTags, localTags, inheritableMetadata, localMetadata, options2);
  }
  static _configureSync(inheritableHandlers, localHandlers, inheritableTags, localTags, inheritableMetadata, localMetadata, options2) {
    var _a3;
    let callbackManager;
    if (inheritableHandlers || localHandlers) {
      if (Array.isArray(inheritableHandlers) || !inheritableHandlers) {
        callbackManager = new CallbackManager2();
        callbackManager.setHandlers((inheritableHandlers == null ? void 0 : inheritableHandlers.map(ensureHandler)) ?? [], true);
      } else callbackManager = inheritableHandlers;
      callbackManager = callbackManager.copy(Array.isArray(localHandlers) ? localHandlers.map(ensureHandler) : localHandlers == null ? void 0 : localHandlers.handlers, false);
    }
    const verboseEnabled = getEnvironmentVariable$1("LANGCHAIN_VERBOSE") === "true" || (options2 == null ? void 0 : options2.verbose);
    const tracingV2Enabled = ((_a3 = LangChainTracer.getTraceableRunTree()) == null ? void 0 : _a3.tracingEnabled) || isTracingEnabled();
    const tracingEnabled = tracingV2Enabled || (getEnvironmentVariable$1("LANGCHAIN_TRACING") ?? false);
    if (verboseEnabled || tracingEnabled) {
      if (!callbackManager) callbackManager = new CallbackManager2();
      if (verboseEnabled && !callbackManager.handlers.some((handler) => handler.name === ConsoleCallbackHandler.prototype.name)) {
        const consoleHandler = new ConsoleCallbackHandler();
        callbackManager.addHandler(consoleHandler, true);
      }
      if (tracingEnabled && !callbackManager.handlers.some((handler) => handler.name === "langchain_tracer")) {
        if (tracingV2Enabled) {
          const tracerV2 = new LangChainTracer();
          callbackManager.addHandler(tracerV2, true);
        }
      }
      if (tracingV2Enabled) {
        const implicitRunTree = LangChainTracer.getTraceableRunTree();
        if (implicitRunTree && callbackManager._parentRunId === void 0) {
          callbackManager._parentRunId = implicitRunTree.id;
          const tracerV2 = callbackManager.handlers.find((handler) => handler.name === "langchain_tracer");
          tracerV2 == null ? void 0 : tracerV2.updateFromRunTree(implicitRunTree);
        }
      }
    }
    for (const { contextVar, inheritable = true, handlerClass, envVar } of _getConfigureHooks()) {
      const createIfNotInContext = envVar && getEnvironmentVariable$1(envVar) === "true" && handlerClass;
      let handler;
      const contextVarValue = contextVar !== void 0 ? getContextVariable(contextVar) : void 0;
      if (contextVarValue && isBaseCallbackHandler(contextVarValue)) handler = contextVarValue;
      else if (createIfNotInContext) handler = new handlerClass({});
      if (handler !== void 0) {
        if (!callbackManager) callbackManager = new CallbackManager2();
        if (!callbackManager.handlers.some((h) => h.name === handler.name)) callbackManager.addHandler(handler, inheritable);
      }
    }
    if (inheritableTags || localTags) {
      if (callbackManager) {
        callbackManager.addTags(inheritableTags ?? []);
        callbackManager.addTags(localTags ?? [], false);
      }
    }
    if (inheritableMetadata || localMetadata) {
      if (callbackManager) {
        callbackManager.addMetadata(inheritableMetadata ?? {});
        callbackManager.addMetadata(localMetadata ?? {}, false);
      }
    }
    return callbackManager;
  }
};
function ensureHandler(handler) {
  if ("name" in handler) return handler;
  return BaseCallbackHandler.fromMethods(handler);
}
var MockAsyncLocalStorage = class {
  getStore() {
    return void 0;
  }
  run(_store, callback) {
    return callback();
  }
  enterWith(_store) {
    return void 0;
  }
};
const mockAsyncLocalStorage = new MockAsyncLocalStorage();
const LC_CHILD_KEY = Symbol.for("lc:child_config");
var AsyncLocalStorageProvider = class {
  getInstance() {
    return getGlobalAsyncLocalStorageInstance() ?? mockAsyncLocalStorage;
  }
  getRunnableConfig() {
    var _a3, _b;
    const storage = this.getInstance();
    return (_b = (_a3 = storage.getStore()) == null ? void 0 : _a3.extra) == null ? void 0 : _b[LC_CHILD_KEY];
  }
  runWithConfig(config2, callback, avoidCreatingRootRunTree) {
    var _a3;
    const callbackManager = CallbackManager._configureSync(config2 == null ? void 0 : config2.callbacks, void 0, config2 == null ? void 0 : config2.tags, void 0, config2 == null ? void 0 : config2.metadata);
    const storage = this.getInstance();
    const previousValue = storage.getStore();
    const parentRunId = callbackManager == null ? void 0 : callbackManager.getParentRunId();
    const langChainTracer = (_a3 = callbackManager == null ? void 0 : callbackManager.handlers) == null ? void 0 : _a3.find((handler) => (handler == null ? void 0 : handler.name) === "langchain_tracer");
    let runTree;
    if (langChainTracer && parentRunId) runTree = langChainTracer.getRunTreeWithTracingConfig(parentRunId);
    else if (!avoidCreatingRootRunTree) runTree = new RunTree({
      name: "<runnable_lambda>",
      tracingEnabled: false
    });
    if (runTree) runTree.extra = {
      ...runTree.extra,
      [LC_CHILD_KEY]: config2
    };
    if (previousValue !== void 0 && previousValue[_CONTEXT_VARIABLES_KEY] !== void 0) {
      if (runTree === void 0) runTree = {};
      runTree[_CONTEXT_VARIABLES_KEY] = previousValue[_CONTEXT_VARIABLES_KEY];
    }
    return storage.run(runTree, callback);
  }
  initializeGlobalInstance(instance) {
    if (getGlobalAsyncLocalStorageInstance() === void 0) setGlobalAsyncLocalStorageInstance(instance);
  }
};
const AsyncLocalStorageProviderSingleton = new AsyncLocalStorageProvider();
var singletons_exports = {};
__export(singletons_exports, {
  AsyncLocalStorageProviderSingleton: () => AsyncLocalStorageProviderSingleton,
  MockAsyncLocalStorage: () => MockAsyncLocalStorage,
  _CONTEXT_VARIABLES_KEY: () => _CONTEXT_VARIABLES_KEY
});
const DEFAULT_RECURSION_LIMIT = 25;
async function getCallbackManagerForConfig(config2) {
  return CallbackManager._configureSync(config2 == null ? void 0 : config2.callbacks, void 0, config2 == null ? void 0 : config2.tags, void 0, config2 == null ? void 0 : config2.metadata);
}
function mergeConfigs(...configs) {
  const copy = {};
  for (const options2 of configs.filter((c) => !!c)) for (const key of Object.keys(options2)) if (key === "metadata") copy[key] = {
    ...copy[key],
    ...options2[key]
  };
  else if (key === "tags") {
    const baseKeys = copy[key] ?? [];
    copy[key] = [...new Set(baseKeys.concat(options2[key] ?? []))];
  } else if (key === "configurable") copy[key] = {
    ...copy[key],
    ...options2[key]
  };
  else if (key === "timeout") {
    if (copy.timeout === void 0) copy.timeout = options2.timeout;
    else if (options2.timeout !== void 0) copy.timeout = Math.min(copy.timeout, options2.timeout);
  } else if (key === "signal") {
    if (copy.signal === void 0) copy.signal = options2.signal;
    else if (options2.signal !== void 0) if ("any" in AbortSignal) copy.signal = AbortSignal.any([copy.signal, options2.signal]);
    else copy.signal = options2.signal;
  } else if (key === "callbacks") {
    const baseCallbacks = copy.callbacks;
    const providedCallbacks = options2.callbacks;
    if (Array.isArray(providedCallbacks)) if (!baseCallbacks) copy.callbacks = providedCallbacks;
    else if (Array.isArray(baseCallbacks)) copy.callbacks = baseCallbacks.concat(providedCallbacks);
    else {
      const manager = baseCallbacks.copy();
      for (const callback of providedCallbacks) manager.addHandler(ensureHandler(callback), true);
      copy.callbacks = manager;
    }
    else if (providedCallbacks) if (!baseCallbacks) copy.callbacks = providedCallbacks;
    else if (Array.isArray(baseCallbacks)) {
      const manager = providedCallbacks.copy();
      for (const callback of baseCallbacks) manager.addHandler(ensureHandler(callback), true);
      copy.callbacks = manager;
    } else copy.callbacks = new CallbackManager(providedCallbacks._parentRunId, {
      handlers: baseCallbacks.handlers.concat(providedCallbacks.handlers),
      inheritableHandlers: baseCallbacks.inheritableHandlers.concat(providedCallbacks.inheritableHandlers),
      tags: Array.from(new Set(baseCallbacks.tags.concat(providedCallbacks.tags))),
      inheritableTags: Array.from(new Set(baseCallbacks.inheritableTags.concat(providedCallbacks.inheritableTags))),
      metadata: {
        ...baseCallbacks.metadata,
        ...providedCallbacks.metadata
      }
    });
  } else {
    const typedKey = key;
    copy[typedKey] = options2[typedKey] ?? copy[typedKey];
  }
  return copy;
}
const PRIMITIVES = /* @__PURE__ */ new Set([
  "string",
  "number",
  "boolean"
]);
function ensureConfig(config2) {
  var _a3;
  const implicitConfig = AsyncLocalStorageProviderSingleton.getRunnableConfig();
  let empty2 = {
    tags: [],
    metadata: {},
    recursionLimit: 25,
    runId: void 0
  };
  if (implicitConfig) {
    const { runId, runName, ...rest } = implicitConfig;
    empty2 = Object.entries(rest).reduce((currentConfig, [key, value]) => {
      if (value !== void 0) currentConfig[key] = value;
      return currentConfig;
    }, empty2);
  }
  if (config2) empty2 = Object.entries(config2).reduce((currentConfig, [key, value]) => {
    if (value !== void 0) currentConfig[key] = value;
    return currentConfig;
  }, empty2);
  if (empty2 == null ? void 0 : empty2.configurable) {
    for (const key of Object.keys(empty2.configurable)) if (PRIMITIVES.has(typeof empty2.configurable[key]) && !((_a3 = empty2.metadata) == null ? void 0 : _a3[key])) {
      if (!empty2.metadata) empty2.metadata = {};
      empty2.metadata[key] = empty2.configurable[key];
    }
  }
  if (empty2.timeout !== void 0) {
    if (empty2.timeout <= 0) throw new Error("Timeout must be a positive number");
    const timeoutSignal = AbortSignal.timeout(empty2.timeout);
    if (empty2.signal !== void 0) {
      if ("any" in AbortSignal) empty2.signal = AbortSignal.any([empty2.signal, timeoutSignal]);
    } else empty2.signal = timeoutSignal;
    delete empty2.timeout;
  }
  return empty2;
}
function patchConfig(config2 = {}, { callbacks, maxConcurrency, recursionLimit, runName, configurable, runId } = {}) {
  const newConfig = ensureConfig(config2);
  if (callbacks !== void 0) {
    delete newConfig.runName;
    newConfig.callbacks = callbacks;
  }
  if (recursionLimit !== void 0) newConfig.recursionLimit = recursionLimit;
  if (maxConcurrency !== void 0) newConfig.maxConcurrency = maxConcurrency;
  if (runName !== void 0) newConfig.runName = runName;
  if (configurable !== void 0) newConfig.configurable = {
    ...newConfig.configurable,
    ...configurable
  };
  if (runId !== void 0) delete newConfig.runId;
  return newConfig;
}
function pickRunnableConfigKeys(config2) {
  if (!config2) return void 0;
  return {
    configurable: config2.configurable,
    recursionLimit: config2.recursionLimit,
    callbacks: config2.callbacks,
    tags: config2.tags,
    metadata: config2.metadata,
    maxConcurrency: config2.maxConcurrency,
    timeout: config2.timeout,
    signal: config2.signal,
    store: config2.store
  };
}
async function raceWithSignal(promise, signal) {
  if (signal === void 0) return promise;
  let listener;
  return Promise.race([promise.catch((err) => {
    if (!(signal == null ? void 0 : signal.aborted)) throw err;
    else return void 0;
  }), new Promise((_, reject) => {
    listener = () => {
      reject(getAbortSignalError(signal));
    };
    signal.addEventListener("abort", listener);
    if (signal.aborted) reject(getAbortSignalError(signal));
  })]).finally(() => signal.removeEventListener("abort", listener));
}
function getAbortSignalError(signal) {
  if ((signal == null ? void 0 : signal.reason) instanceof Error) return signal.reason;
  if (typeof (signal == null ? void 0 : signal.reason) === "string") return new Error(signal.reason);
  return /* @__PURE__ */ new Error("Aborted");
}
var stream_exports = {};
__export(stream_exports, {
  AsyncGeneratorWithSetup: () => AsyncGeneratorWithSetup,
  IterableReadableStream: () => IterableReadableStream,
  atee: () => atee,
  concat: () => concat,
  pipeGeneratorWithSetup: () => pipeGeneratorWithSetup
});
var IterableReadableStream = class IterableReadableStream2 extends ReadableStream {
  constructor() {
    super(...arguments);
    __publicField2(this, "reader");
  }
  ensureReader() {
    if (!this.reader) this.reader = this.getReader();
  }
  async next() {
    this.ensureReader();
    try {
      const result = await this.reader.read();
      if (result.done) {
        this.reader.releaseLock();
        return {
          done: true,
          value: void 0
        };
      } else return {
        done: false,
        value: result.value
      };
    } catch (e) {
      this.reader.releaseLock();
      throw e;
    }
  }
  async return() {
    this.ensureReader();
    if (this.locked) {
      const cancelPromise = this.reader.cancel();
      this.reader.releaseLock();
      await cancelPromise;
    }
    return {
      done: true,
      value: void 0
    };
  }
  async throw(e) {
    this.ensureReader();
    if (this.locked) {
      const cancelPromise = this.reader.cancel();
      this.reader.releaseLock();
      await cancelPromise;
    }
    throw e;
  }
  [Symbol.asyncIterator]() {
    return this;
  }
  async [Symbol.asyncDispose]() {
    await this.return();
  }
  static fromReadableStream(stream) {
    const reader = stream.getReader();
    return new IterableReadableStream2({
      start(controller) {
        return pump();
        function pump() {
          return reader.read().then(({ done, value }) => {
            if (done) {
              controller.close();
              return;
            }
            controller.enqueue(value);
            return pump();
          });
        }
      },
      cancel() {
        reader.releaseLock();
      }
    });
  }
  static fromAsyncGenerator(generator) {
    return new IterableReadableStream2({
      async pull(controller) {
        const { value, done } = await generator.next();
        if (done) controller.close();
        controller.enqueue(value);
      },
      async cancel(reason) {
        await generator.return(reason);
      }
    });
  }
};
function atee(iter, length = 2) {
  const buffers = Array.from({ length }, () => []);
  return buffers.map(async function* makeIter(buffer) {
    while (true) if (buffer.length === 0) {
      const result = await iter.next();
      for (const buffer$1 of buffers) buffer$1.push(result);
    } else if (buffer[0].done) return;
    else yield buffer.shift().value;
  });
}
function concat(first, second) {
  if (Array.isArray(first) && Array.isArray(second)) return first.concat(second);
  else if (typeof first === "string" && typeof second === "string") return first + second;
  else if (typeof first === "number" && typeof second === "number") return first + second;
  else if ("concat" in first && typeof first.concat === "function") return first.concat(second);
  else if (typeof first === "object" && typeof second === "object") {
    const chunk = { ...first };
    for (const [key, value] of Object.entries(second)) if (key in chunk && !Array.isArray(chunk[key])) chunk[key] = concat(chunk[key], value);
    else chunk[key] = value;
    return chunk;
  } else throw new Error(`Cannot concat ${typeof first} and ${typeof second}`);
}
var AsyncGeneratorWithSetup = class {
  constructor(params) {
    __publicField2(this, "generator");
    __publicField2(this, "setup");
    __publicField2(this, "config");
    __publicField2(this, "signal");
    __publicField2(this, "firstResult");
    __publicField2(this, "firstResultUsed", false);
    var _a3;
    this.generator = params.generator;
    this.config = params.config;
    this.signal = params.signal ?? ((_a3 = this.config) == null ? void 0 : _a3.signal);
    this.setup = new Promise((resolve, reject) => {
      AsyncLocalStorageProviderSingleton.runWithConfig(pickRunnableConfigKeys(params.config), async () => {
        this.firstResult = params.generator.next();
        if (params.startSetup) this.firstResult.then(params.startSetup).then(resolve, reject);
        else this.firstResult.then((_result) => resolve(void 0), reject);
      }, true);
    });
  }
  async next(...args) {
    var _a3;
    (_a3 = this.signal) == null ? void 0 : _a3.throwIfAborted();
    if (!this.firstResultUsed) {
      this.firstResultUsed = true;
      return this.firstResult;
    }
    return AsyncLocalStorageProviderSingleton.runWithConfig(pickRunnableConfigKeys(this.config), this.signal ? async () => {
      return raceWithSignal(this.generator.next(...args), this.signal);
    } : async () => {
      return this.generator.next(...args);
    }, true);
  }
  async return(value) {
    return this.generator.return(value);
  }
  async throw(e) {
    return this.generator.throw(e);
  }
  [Symbol.asyncIterator]() {
    return this;
  }
  async [Symbol.asyncDispose]() {
    await this.return();
  }
};
async function pipeGeneratorWithSetup(to, generator, startSetup, signal, ...args) {
  const gen = new AsyncGeneratorWithSetup({
    generator,
    startSetup,
    signal
  });
  const setup = await gen.setup;
  return {
    output: to(gen, setup, ...args),
    setup
  };
}
/*!
* https://github.com/Starcounter-Jack/JSON-Patch
* (c) 2017-2022 Joachim Wester
* MIT licensed
*/
const _hasOwnProperty = Object.prototype.hasOwnProperty;
function hasOwnProperty(obj, key) {
  return _hasOwnProperty.call(obj, key);
}
function _objectKeys(obj) {
  if (Array.isArray(obj)) {
    const keys$1 = new Array(obj.length);
    for (let k = 0; k < keys$1.length; k++) keys$1[k] = "" + k;
    return keys$1;
  }
  if (Object.keys) return Object.keys(obj);
  let keys = [];
  for (let i2 in obj) if (hasOwnProperty(obj, i2)) keys.push(i2);
  return keys;
}
function _deepClone(obj) {
  switch (typeof obj) {
    case "object":
      return JSON.parse(JSON.stringify(obj));
    case "undefined":
      return null;
    default:
      return obj;
  }
}
function isInteger(str2) {
  let i2 = 0;
  const len2 = str2.length;
  let charCode;
  while (i2 < len2) {
    charCode = str2.charCodeAt(i2);
    if (charCode >= 48 && charCode <= 57) {
      i2++;
      continue;
    }
    return false;
  }
  return true;
}
function escapePathComponent(path2) {
  if (path2.indexOf("/") === -1 && path2.indexOf("~") === -1) return path2;
  return path2.replace(/~/g, "~0").replace(/\//g, "~1");
}
function unescapePathComponent(path2) {
  return path2.replace(/~1/g, "/").replace(/~0/g, "~");
}
function hasUndefined(obj) {
  if (obj === void 0) return true;
  if (obj) {
    if (Array.isArray(obj)) {
      for (let i$1 = 0, len2 = obj.length; i$1 < len2; i$1++) if (hasUndefined(obj[i$1])) return true;
    } else if (typeof obj === "object") {
      const objKeys = _objectKeys(obj);
      const objKeysLength = objKeys.length;
      for (var i2 = 0; i2 < objKeysLength; i2++) if (hasUndefined(obj[objKeys[i2]])) return true;
    }
  }
  return false;
}
function patchErrorMessageFormatter(message, args) {
  const messageParts = [message];
  for (const key in args) {
    const value = typeof args[key] === "object" ? JSON.stringify(args[key], null, 2) : args[key];
    if (typeof value !== "undefined") messageParts.push(`${key}: ${value}`);
  }
  return messageParts.join("\n");
}
var PatchError = class extends Error {
  constructor(message, name, index, operation, tree) {
    super(patchErrorMessageFormatter(message, {
      name,
      index,
      operation,
      tree
    }));
    this.name = name;
    this.index = index;
    this.operation = operation;
    this.tree = tree;
    Object.setPrototypeOf(this, new.target.prototype);
    this.message = patchErrorMessageFormatter(message, {
      name,
      index,
      operation,
      tree
    });
  }
};
var core_exports = {};
__export(core_exports, {
  JsonPatchError: () => JsonPatchError,
  _areEquals: () => _areEquals,
  applyOperation: () => applyOperation,
  applyPatch: () => applyPatch,
  applyReducer: () => applyReducer,
  deepClone: () => deepClone,
  getValueByPointer: () => getValueByPointer,
  validate: () => validate$1,
  validator: () => validator
});
const JsonPatchError = PatchError;
const deepClone = _deepClone;
const objOps = {
  add: function(obj, key, document) {
    obj[key] = this.value;
    return { newDocument: document };
  },
  remove: function(obj, key, document) {
    var removed = obj[key];
    delete obj[key];
    return {
      newDocument: document,
      removed
    };
  },
  replace: function(obj, key, document) {
    var removed = obj[key];
    obj[key] = this.value;
    return {
      newDocument: document,
      removed
    };
  },
  move: function(obj, key, document) {
    let removed = getValueByPointer(document, this.path);
    if (removed) removed = _deepClone(removed);
    const originalValue = applyOperation(document, {
      op: "remove",
      path: this.from
    }).removed;
    applyOperation(document, {
      op: "add",
      path: this.path,
      value: originalValue
    });
    return {
      newDocument: document,
      removed
    };
  },
  copy: function(obj, key, document) {
    const valueToCopy = getValueByPointer(document, this.from);
    applyOperation(document, {
      op: "add",
      path: this.path,
      value: _deepClone(valueToCopy)
    });
    return { newDocument: document };
  },
  test: function(obj, key, document) {
    return {
      newDocument: document,
      test: _areEquals(obj[key], this.value)
    };
  },
  _get: function(obj, key, document) {
    this.value = obj[key];
    return { newDocument: document };
  }
};
var arrOps = {
  add: function(arr2, i2, document) {
    if (isInteger(i2)) arr2.splice(i2, 0, this.value);
    else arr2[i2] = this.value;
    return {
      newDocument: document,
      index: i2
    };
  },
  remove: function(arr2, i2, document) {
    var removedList = arr2.splice(i2, 1);
    return {
      newDocument: document,
      removed: removedList[0]
    };
  },
  replace: function(arr2, i2, document) {
    var removed = arr2[i2];
    arr2[i2] = this.value;
    return {
      newDocument: document,
      removed
    };
  },
  move: objOps.move,
  copy: objOps.copy,
  test: objOps.test,
  _get: objOps._get
};
function getValueByPointer(document, pointer) {
  if (pointer == "") return document;
  var getOriginalDestination = {
    op: "_get",
    path: pointer
  };
  applyOperation(document, getOriginalDestination);
  return getOriginalDestination.value;
}
function applyOperation(document, operation, validateOperation = false, mutateDocument = true, banPrototypeModifications = true, index = 0) {
  if (validateOperation) if (typeof validateOperation == "function") validateOperation(operation, 0, document, operation.path);
  else validator(operation, 0);
  if (operation.path === "") {
    let returnValue = { newDocument: document };
    if (operation.op === "add") {
      returnValue.newDocument = operation.value;
      return returnValue;
    } else if (operation.op === "replace") {
      returnValue.newDocument = operation.value;
      returnValue.removed = document;
      return returnValue;
    } else if (operation.op === "move" || operation.op === "copy") {
      returnValue.newDocument = getValueByPointer(document, operation.from);
      if (operation.op === "move") returnValue.removed = document;
      return returnValue;
    } else if (operation.op === "test") {
      returnValue.test = _areEquals(document, operation.value);
      if (returnValue.test === false) throw new JsonPatchError("Test operation failed", "TEST_OPERATION_FAILED", index, operation, document);
      returnValue.newDocument = document;
      return returnValue;
    } else if (operation.op === "remove") {
      returnValue.removed = document;
      returnValue.newDocument = null;
      return returnValue;
    } else if (operation.op === "_get") {
      operation.value = document;
      return returnValue;
    } else if (validateOperation) throw new JsonPatchError("Operation `op` property is not one of operations defined in RFC-6902", "OPERATION_OP_INVALID", index, operation, document);
    else return returnValue;
  } else {
    if (!mutateDocument) document = _deepClone(document);
    const path2 = operation.path || "";
    const keys = path2.split("/");
    let obj = document;
    let t2 = 1;
    let len2 = keys.length;
    let existingPathFragment = void 0;
    let key;
    let validateFunction;
    if (typeof validateOperation == "function") validateFunction = validateOperation;
    else validateFunction = validator;
    while (true) {
      key = keys[t2];
      if (key && key.indexOf("~") != -1) key = unescapePathComponent(key);
      if (banPrototypeModifications && (key == "__proto__" || key == "prototype" && t2 > 0 && keys[t2 - 1] == "constructor")) throw new TypeError("JSON-Patch: modifying `__proto__` or `constructor/prototype` prop is banned for security reasons, if this was on purpose, please set `banPrototypeModifications` flag false and pass it to this function. More info in fast-json-patch README");
      if (validateOperation) {
        if (existingPathFragment === void 0) {
          if (obj[key] === void 0) existingPathFragment = keys.slice(0, t2).join("/");
          else if (t2 == len2 - 1) existingPathFragment = operation.path;
          if (existingPathFragment !== void 0) validateFunction(operation, 0, document, existingPathFragment);
        }
      }
      t2++;
      if (Array.isArray(obj)) {
        if (key === "-") key = obj.length;
        else if (validateOperation && !isInteger(key)) throw new JsonPatchError("Expected an unsigned base-10 integer value, making the new referenced value the array element with the zero-based index", "OPERATION_PATH_ILLEGAL_ARRAY_INDEX", index, operation, document);
        else if (isInteger(key)) key = ~~key;
        if (t2 >= len2) {
          if (validateOperation && operation.op === "add" && key > obj.length) throw new JsonPatchError("The specified index MUST NOT be greater than the number of elements in the array", "OPERATION_VALUE_OUT_OF_BOUNDS", index, operation, document);
          const returnValue = arrOps[operation.op].call(operation, obj, key, document);
          if (returnValue.test === false) throw new JsonPatchError("Test operation failed", "TEST_OPERATION_FAILED", index, operation, document);
          return returnValue;
        }
      } else if (t2 >= len2) {
        const returnValue = objOps[operation.op].call(operation, obj, key, document);
        if (returnValue.test === false) throw new JsonPatchError("Test operation failed", "TEST_OPERATION_FAILED", index, operation, document);
        return returnValue;
      }
      obj = obj[key];
      if (validateOperation && t2 < len2 && (!obj || typeof obj !== "object")) throw new JsonPatchError("Cannot perform operation at the desired path", "OPERATION_PATH_UNRESOLVABLE", index, operation, document);
    }
  }
}
function applyPatch(document, patch, validateOperation, mutateDocument = true, banPrototypeModifications = true) {
  if (validateOperation) {
    if (!Array.isArray(patch)) throw new JsonPatchError("Patch sequence must be an array", "SEQUENCE_NOT_AN_ARRAY");
  }
  if (!mutateDocument) document = _deepClone(document);
  const results2 = new Array(patch.length);
  for (let i2 = 0, length = patch.length; i2 < length; i2++) {
    results2[i2] = applyOperation(document, patch[i2], validateOperation, true, banPrototypeModifications, i2);
    document = results2[i2].newDocument;
  }
  results2.newDocument = document;
  return results2;
}
function applyReducer(document, operation, index) {
  const operationResult = applyOperation(document, operation);
  if (operationResult.test === false) throw new JsonPatchError("Test operation failed", "TEST_OPERATION_FAILED", index, operation, document);
  return operationResult.newDocument;
}
function validator(operation, index, document, existingPathFragment) {
  if (typeof operation !== "object" || operation === null || Array.isArray(operation)) throw new JsonPatchError("Operation is not an object", "OPERATION_NOT_AN_OBJECT", index, operation, document);
  else if (!objOps[operation.op]) throw new JsonPatchError("Operation `op` property is not one of operations defined in RFC-6902", "OPERATION_OP_INVALID", index, operation, document);
  else if (typeof operation.path !== "string") throw new JsonPatchError("Operation `path` property is not a string", "OPERATION_PATH_INVALID", index, operation, document);
  else if (operation.path.indexOf("/") !== 0 && operation.path.length > 0) throw new JsonPatchError('Operation `path` property must start with "/"', "OPERATION_PATH_INVALID", index, operation, document);
  else if ((operation.op === "move" || operation.op === "copy") && typeof operation.from !== "string") throw new JsonPatchError("Operation `from` property is not present (applicable in `move` and `copy` operations)", "OPERATION_FROM_REQUIRED", index, operation, document);
  else if ((operation.op === "add" || operation.op === "replace" || operation.op === "test") && operation.value === void 0) throw new JsonPatchError("Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)", "OPERATION_VALUE_REQUIRED", index, operation, document);
  else if ((operation.op === "add" || operation.op === "replace" || operation.op === "test") && hasUndefined(operation.value)) throw new JsonPatchError("Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)", "OPERATION_VALUE_CANNOT_CONTAIN_UNDEFINED", index, operation, document);
  else if (document) {
    if (operation.op == "add") {
      var pathLen = operation.path.split("/").length;
      var existingPathLen = existingPathFragment.split("/").length;
      if (pathLen !== existingPathLen + 1 && pathLen !== existingPathLen) throw new JsonPatchError("Cannot perform an `add` operation at the desired path", "OPERATION_PATH_CANNOT_ADD", index, operation, document);
    } else if (operation.op === "replace" || operation.op === "remove" || operation.op === "_get") {
      if (operation.path !== existingPathFragment) throw new JsonPatchError("Cannot perform the operation at a path that does not exist", "OPERATION_PATH_UNRESOLVABLE", index, operation, document);
    } else if (operation.op === "move" || operation.op === "copy") {
      var existingValue = {
        op: "_get",
        path: operation.from,
        value: void 0
      };
      var error = validate$1([existingValue], document);
      if (error && error.name === "OPERATION_PATH_UNRESOLVABLE") throw new JsonPatchError("Cannot perform the operation from a path that does not exist", "OPERATION_FROM_UNRESOLVABLE", index, operation, document);
    }
  }
}
function validate$1(sequence, document, externalValidator) {
  try {
    if (!Array.isArray(sequence)) throw new JsonPatchError("Patch sequence must be an array", "SEQUENCE_NOT_AN_ARRAY");
    if (document) applyPatch(_deepClone(document), _deepClone(sequence), externalValidator || true);
    else {
      externalValidator = externalValidator || validator;
      for (var i2 = 0; i2 < sequence.length; i2++) externalValidator(sequence[i2], i2, document, void 0);
    }
  } catch (e) {
    if (e instanceof JsonPatchError) return e;
    else throw e;
  }
}
function _areEquals(a, b) {
  if (a === b) return true;
  if (a && b && typeof a == "object" && typeof b == "object") {
    var arrA = Array.isArray(a), arrB = Array.isArray(b), i2, length, key;
    if (arrA && arrB) {
      length = a.length;
      if (length != b.length) return false;
      for (i2 = length; i2-- !== 0; ) if (!_areEquals(a[i2], b[i2])) return false;
      return true;
    }
    if (arrA != arrB) return false;
    var keys = Object.keys(a);
    length = keys.length;
    if (length !== Object.keys(b).length) return false;
    for (i2 = length; i2-- !== 0; ) if (!b.hasOwnProperty(keys[i2])) return false;
    for (i2 = length; i2-- !== 0; ) {
      key = keys[i2];
      if (!_areEquals(a[key], b[key])) return false;
    }
    return true;
  }
  return a !== a && b !== b;
}
function _generate(mirror, obj, patches, path2, invertible) {
  if (obj === mirror) return;
  if (typeof obj.toJSON === "function") obj = obj.toJSON();
  var newKeys = _objectKeys(obj);
  var oldKeys = _objectKeys(mirror);
  var deleted = false;
  for (var t2 = oldKeys.length - 1; t2 >= 0; t2--) {
    var key = oldKeys[t2];
    var oldVal = mirror[key];
    if (hasOwnProperty(obj, key) && !(obj[key] === void 0 && oldVal !== void 0 && Array.isArray(obj) === false)) {
      var newVal = obj[key];
      if (typeof oldVal == "object" && oldVal != null && typeof newVal == "object" && newVal != null && Array.isArray(oldVal) === Array.isArray(newVal)) _generate(oldVal, newVal, patches, path2 + "/" + escapePathComponent(key), invertible);
      else if (oldVal !== newVal) {
        if (invertible) patches.push({
          op: "test",
          path: path2 + "/" + escapePathComponent(key),
          value: _deepClone(oldVal)
        });
        patches.push({
          op: "replace",
          path: path2 + "/" + escapePathComponent(key),
          value: _deepClone(newVal)
        });
      }
    } else if (Array.isArray(mirror) === Array.isArray(obj)) {
      if (invertible) patches.push({
        op: "test",
        path: path2 + "/" + escapePathComponent(key),
        value: _deepClone(oldVal)
      });
      patches.push({
        op: "remove",
        path: path2 + "/" + escapePathComponent(key)
      });
      deleted = true;
    } else {
      if (invertible) patches.push({
        op: "test",
        path: path2,
        value: mirror
      });
      patches.push({
        op: "replace",
        path: path2,
        value: obj
      });
    }
  }
  if (!deleted && newKeys.length == oldKeys.length) return;
  for (var t2 = 0; t2 < newKeys.length; t2++) {
    var key = newKeys[t2];
    if (!hasOwnProperty(mirror, key) && obj[key] !== void 0) patches.push({
      op: "add",
      path: path2 + "/" + escapePathComponent(key),
      value: _deepClone(obj[key])
    });
  }
}
function compare(tree1, tree2, invertible = false) {
  var patches = [];
  _generate(tree1, tree2, patches, "", invertible);
  return patches;
}
({
  ...core_exports
});
var log_stream_exports = {};
__export(log_stream_exports, {
  LogStreamCallbackHandler: () => LogStreamCallbackHandler,
  RunLog: () => RunLog,
  RunLogPatch: () => RunLogPatch,
  isLogStreamHandler: () => isLogStreamHandler
});
var RunLogPatch = class {
  constructor(fields) {
    __publicField2(this, "ops");
    this.ops = fields.ops ?? [];
  }
  concat(other) {
    const ops = this.ops.concat(other.ops);
    const states = applyPatch({}, ops);
    return new RunLog({
      ops,
      state: states[states.length - 1].newDocument
    });
  }
};
var RunLog = class RunLog2 extends RunLogPatch {
  constructor(fields) {
    super(fields);
    __publicField2(this, "state");
    this.state = fields.state;
  }
  concat(other) {
    const ops = this.ops.concat(other.ops);
    const states = applyPatch(this.state, other.ops);
    return new RunLog2({
      ops,
      state: states[states.length - 1].newDocument
    });
  }
  static fromRunLogPatch(patch) {
    const states = applyPatch({}, patch.ops);
    return new RunLog2({
      ops: patch.ops,
      state: states[states.length - 1].newDocument
    });
  }
};
const isLogStreamHandler = (handler) => handler.name === "log_stream_tracer";
async function _getStandardizedInputs(run, schemaFormat) {
  if (schemaFormat === "original") throw new Error("Do not assign inputs with original schema drop the key for now. When inputs are added to streamLog they should be added with standardized schema for streaming events.");
  const { inputs } = run;
  if ([
    "retriever",
    "llm",
    "prompt"
  ].includes(run.run_type)) return inputs;
  if (Object.keys(inputs).length === 1 && (inputs == null ? void 0 : inputs.input) === "") return void 0;
  return inputs.input;
}
async function _getStandardizedOutputs(run, schemaFormat) {
  const { outputs } = run;
  if (schemaFormat === "original") return outputs;
  if ([
    "retriever",
    "llm",
    "prompt"
  ].includes(run.run_type)) return outputs;
  if (outputs !== void 0 && Object.keys(outputs).length === 1 && (outputs == null ? void 0 : outputs.output) !== void 0) return outputs.output;
  return outputs;
}
function isChatGenerationChunk(x) {
  return x !== void 0 && x.message !== void 0;
}
var LogStreamCallbackHandler = class extends BaseTracer {
  constructor(fields) {
    super({
      _awaitHandler: true,
      ...fields
    });
    __publicField2(this, "autoClose", true);
    __publicField2(this, "includeNames");
    __publicField2(this, "includeTypes");
    __publicField2(this, "includeTags");
    __publicField2(this, "excludeNames");
    __publicField2(this, "excludeTypes");
    __publicField2(this, "excludeTags");
    __publicField2(this, "_schemaFormat", "original");
    __publicField2(this, "rootId");
    __publicField2(this, "keyMapByRunId", {});
    __publicField2(this, "counterMapByRunName", {});
    __publicField2(this, "transformStream");
    __publicField2(this, "writer");
    __publicField2(this, "receiveStream");
    __publicField2(this, "name", "log_stream_tracer");
    __publicField2(this, "lc_prefer_streaming", true);
    this.autoClose = (fields == null ? void 0 : fields.autoClose) ?? true;
    this.includeNames = fields == null ? void 0 : fields.includeNames;
    this.includeTypes = fields == null ? void 0 : fields.includeTypes;
    this.includeTags = fields == null ? void 0 : fields.includeTags;
    this.excludeNames = fields == null ? void 0 : fields.excludeNames;
    this.excludeTypes = fields == null ? void 0 : fields.excludeTypes;
    this.excludeTags = fields == null ? void 0 : fields.excludeTags;
    this._schemaFormat = (fields == null ? void 0 : fields._schemaFormat) ?? this._schemaFormat;
    this.transformStream = new TransformStream();
    this.writer = this.transformStream.writable.getWriter();
    this.receiveStream = IterableReadableStream.fromReadableStream(this.transformStream.readable);
  }
  [Symbol.asyncIterator]() {
    return this.receiveStream;
  }
  async persistRun(_run) {
  }
  _includeRun(run) {
    if (run.id === this.rootId) return false;
    const runTags = run.tags ?? [];
    let include = this.includeNames === void 0 && this.includeTags === void 0 && this.includeTypes === void 0;
    if (this.includeNames !== void 0) include = include || this.includeNames.includes(run.name);
    if (this.includeTypes !== void 0) include = include || this.includeTypes.includes(run.run_type);
    if (this.includeTags !== void 0) include = include || runTags.find((tag) => {
      var _a3;
      return (_a3 = this.includeTags) == null ? void 0 : _a3.includes(tag);
    }) !== void 0;
    if (this.excludeNames !== void 0) include = include && !this.excludeNames.includes(run.name);
    if (this.excludeTypes !== void 0) include = include && !this.excludeTypes.includes(run.run_type);
    if (this.excludeTags !== void 0) include = include && runTags.every((tag) => {
      var _a3;
      return !((_a3 = this.excludeTags) == null ? void 0 : _a3.includes(tag));
    });
    return include;
  }
  async *tapOutputIterable(runId, output) {
    for await (const chunk of output) {
      if (runId !== this.rootId) {
        const key = this.keyMapByRunId[runId];
        if (key) await this.writer.write(new RunLogPatch({ ops: [{
          op: "add",
          path: `/logs/${key}/streamed_output/-`,
          value: chunk
        }] }));
      }
      yield chunk;
    }
  }
  async onRunCreate(run) {
    var _a3;
    if (this.rootId === void 0) {
      this.rootId = run.id;
      await this.writer.write(new RunLogPatch({ ops: [{
        op: "replace",
        path: "",
        value: {
          id: run.id,
          name: run.name,
          type: run.run_type,
          streamed_output: [],
          final_output: void 0,
          logs: {}
        }
      }] }));
    }
    if (!this._includeRun(run)) return;
    if (this.counterMapByRunName[run.name] === void 0) this.counterMapByRunName[run.name] = 0;
    this.counterMapByRunName[run.name] += 1;
    const count = this.counterMapByRunName[run.name];
    this.keyMapByRunId[run.id] = count === 1 ? run.name : `${run.name}:${count}`;
    const logEntry = {
      id: run.id,
      name: run.name,
      type: run.run_type,
      tags: run.tags ?? [],
      metadata: ((_a3 = run.extra) == null ? void 0 : _a3.metadata) ?? {},
      start_time: new Date(run.start_time).toISOString(),
      streamed_output: [],
      streamed_output_str: [],
      final_output: void 0,
      end_time: void 0
    };
    if (this._schemaFormat === "streaming_events") logEntry.inputs = await _getStandardizedInputs(run, this._schemaFormat);
    await this.writer.write(new RunLogPatch({ ops: [{
      op: "add",
      path: `/logs/${this.keyMapByRunId[run.id]}`,
      value: logEntry
    }] }));
  }
  async onRunUpdate(run) {
    try {
      const runName = this.keyMapByRunId[run.id];
      if (runName === void 0) return;
      const ops = [];
      if (this._schemaFormat === "streaming_events") ops.push({
        op: "replace",
        path: `/logs/${runName}/inputs`,
        value: await _getStandardizedInputs(run, this._schemaFormat)
      });
      ops.push({
        op: "add",
        path: `/logs/${runName}/final_output`,
        value: await _getStandardizedOutputs(run, this._schemaFormat)
      });
      if (run.end_time !== void 0) ops.push({
        op: "add",
        path: `/logs/${runName}/end_time`,
        value: new Date(run.end_time).toISOString()
      });
      const patch = new RunLogPatch({ ops });
      await this.writer.write(patch);
    } finally {
      if (run.id === this.rootId) {
        const patch = new RunLogPatch({ ops: [{
          op: "replace",
          path: "/final_output",
          value: await _getStandardizedOutputs(run, this._schemaFormat)
        }] });
        await this.writer.write(patch);
        if (this.autoClose) await this.writer.close();
      }
    }
  }
  async onLLMNewToken(run, token, kwargs) {
    const runName = this.keyMapByRunId[run.id];
    if (runName === void 0) return;
    const isChatModel = run.inputs.messages !== void 0;
    let streamedOutputValue;
    if (isChatModel) if (isChatGenerationChunk(kwargs == null ? void 0 : kwargs.chunk)) streamedOutputValue = kwargs == null ? void 0 : kwargs.chunk;
    else streamedOutputValue = new AIMessageChunk({
      id: `run-${run.id}`,
      content: token
    });
    else streamedOutputValue = token;
    const patch = new RunLogPatch({ ops: [{
      op: "add",
      path: `/logs/${runName}/streamed_output_str/-`,
      value: token
    }, {
      op: "add",
      path: `/logs/${runName}/streamed_output/-`,
      value: streamedOutputValue
    }] });
    await this.writer.write(patch);
  }
};
var outputs_exports = {};
__export(outputs_exports, {
  ChatGenerationChunk: () => ChatGenerationChunk,
  GenerationChunk: () => GenerationChunk,
  RUN_KEY: () => RUN_KEY
});
const RUN_KEY = "__run";
var GenerationChunk = class GenerationChunk2 {
  constructor(fields) {
    __publicField2(this, "text");
    __publicField2(this, "generationInfo");
    this.text = fields.text;
    this.generationInfo = fields.generationInfo;
  }
  concat(chunk) {
    return new GenerationChunk2({
      text: this.text + chunk.text,
      generationInfo: {
        ...this.generationInfo,
        ...chunk.generationInfo
      }
    });
  }
};
var ChatGenerationChunk = class ChatGenerationChunk2 extends GenerationChunk {
  constructor(fields) {
    super(fields);
    __publicField2(this, "message");
    this.message = fields.message;
  }
  concat(chunk) {
    return new ChatGenerationChunk2({
      text: this.text + chunk.text,
      generationInfo: {
        ...this.generationInfo,
        ...chunk.generationInfo
      },
      message: this.message.concat(chunk.message)
    });
  }
};
function assignName({ name, serialized }) {
  if (name !== void 0) return name;
  if ((serialized == null ? void 0 : serialized.name) !== void 0) return serialized.name;
  else if ((serialized == null ? void 0 : serialized.id) !== void 0 && Array.isArray(serialized == null ? void 0 : serialized.id)) return serialized.id[serialized.id.length - 1];
  return "Unnamed";
}
const isStreamEventsHandler = (handler) => handler.name === "event_stream_tracer";
var EventStreamCallbackHandler = class extends BaseTracer {
  constructor(fields) {
    super({
      _awaitHandler: true,
      ...fields
    });
    __publicField2(this, "autoClose", true);
    __publicField2(this, "includeNames");
    __publicField2(this, "includeTypes");
    __publicField2(this, "includeTags");
    __publicField2(this, "excludeNames");
    __publicField2(this, "excludeTypes");
    __publicField2(this, "excludeTags");
    __publicField2(this, "runInfoMap", /* @__PURE__ */ new Map());
    __publicField2(this, "tappedPromises", /* @__PURE__ */ new Map());
    __publicField2(this, "transformStream");
    __publicField2(this, "writer");
    __publicField2(this, "receiveStream");
    __publicField2(this, "name", "event_stream_tracer");
    __publicField2(this, "lc_prefer_streaming", true);
    this.autoClose = (fields == null ? void 0 : fields.autoClose) ?? true;
    this.includeNames = fields == null ? void 0 : fields.includeNames;
    this.includeTypes = fields == null ? void 0 : fields.includeTypes;
    this.includeTags = fields == null ? void 0 : fields.includeTags;
    this.excludeNames = fields == null ? void 0 : fields.excludeNames;
    this.excludeTypes = fields == null ? void 0 : fields.excludeTypes;
    this.excludeTags = fields == null ? void 0 : fields.excludeTags;
    this.transformStream = new TransformStream();
    this.writer = this.transformStream.writable.getWriter();
    this.receiveStream = IterableReadableStream.fromReadableStream(this.transformStream.readable);
  }
  [Symbol.asyncIterator]() {
    return this.receiveStream;
  }
  async persistRun(_run) {
  }
  _includeRun(run) {
    const runTags = run.tags ?? [];
    let include = this.includeNames === void 0 && this.includeTags === void 0 && this.includeTypes === void 0;
    if (this.includeNames !== void 0) include = include || this.includeNames.includes(run.name);
    if (this.includeTypes !== void 0) include = include || this.includeTypes.includes(run.runType);
    if (this.includeTags !== void 0) include = include || runTags.find((tag) => {
      var _a3;
      return (_a3 = this.includeTags) == null ? void 0 : _a3.includes(tag);
    }) !== void 0;
    if (this.excludeNames !== void 0) include = include && !this.excludeNames.includes(run.name);
    if (this.excludeTypes !== void 0) include = include && !this.excludeTypes.includes(run.runType);
    if (this.excludeTags !== void 0) include = include && runTags.every((tag) => {
      var _a3;
      return !((_a3 = this.excludeTags) == null ? void 0 : _a3.includes(tag));
    });
    return include;
  }
  async *tapOutputIterable(runId, outputStream) {
    const firstChunk = await outputStream.next();
    if (firstChunk.done) return;
    const runInfo = this.runInfoMap.get(runId);
    if (runInfo === void 0) {
      yield firstChunk.value;
      return;
    }
    function _formatOutputChunk(eventType, data) {
      if (eventType === "llm" && typeof data === "string") return new GenerationChunk({ text: data });
      return data;
    }
    let tappedPromise = this.tappedPromises.get(runId);
    if (tappedPromise === void 0) {
      let tappedPromiseResolver;
      tappedPromise = new Promise((resolve) => {
        tappedPromiseResolver = resolve;
      });
      this.tappedPromises.set(runId, tappedPromise);
      try {
        const event = {
          event: `on_${runInfo.runType}_stream`,
          run_id: runId,
          name: runInfo.name,
          tags: runInfo.tags,
          metadata: runInfo.metadata,
          data: {}
        };
        await this.send({
          ...event,
          data: { chunk: _formatOutputChunk(runInfo.runType, firstChunk.value) }
        }, runInfo);
        yield firstChunk.value;
        for await (const chunk of outputStream) {
          if (runInfo.runType !== "tool" && runInfo.runType !== "retriever") await this.send({
            ...event,
            data: { chunk: _formatOutputChunk(runInfo.runType, chunk) }
          }, runInfo);
          yield chunk;
        }
      } finally {
        tappedPromiseResolver == null ? void 0 : tappedPromiseResolver();
      }
    } else {
      yield firstChunk.value;
      for await (const chunk of outputStream) yield chunk;
    }
  }
  async send(payload, run) {
    if (this._includeRun(run)) await this.writer.write(payload);
  }
  async sendEndEvent(payload, run) {
    const tappedPromise = this.tappedPromises.get(payload.run_id);
    if (tappedPromise !== void 0) tappedPromise.then(() => {
      this.send(payload, run);
    });
    else await this.send(payload, run);
  }
  async onLLMStart(run) {
    var _a3, _b;
    const runName = assignName(run);
    const runType = run.inputs.messages !== void 0 ? "chat_model" : "llm";
    const runInfo = {
      tags: run.tags ?? [],
      metadata: ((_a3 = run.extra) == null ? void 0 : _a3.metadata) ?? {},
      name: runName,
      runType,
      inputs: run.inputs
    };
    this.runInfoMap.set(run.id, runInfo);
    const eventName = `on_${runType}_start`;
    await this.send({
      event: eventName,
      data: { input: run.inputs },
      name: runName,
      tags: run.tags ?? [],
      run_id: run.id,
      metadata: ((_b = run.extra) == null ? void 0 : _b.metadata) ?? {}
    }, runInfo);
  }
  async onLLMNewToken(run, token, kwargs) {
    const runInfo = this.runInfoMap.get(run.id);
    let chunk;
    let eventName;
    if (runInfo === void 0) throw new Error(`onLLMNewToken: Run ID ${run.id} not found in run map.`);
    if (this.runInfoMap.size === 1) return;
    if (runInfo.runType === "chat_model") {
      eventName = "on_chat_model_stream";
      if ((kwargs == null ? void 0 : kwargs.chunk) === void 0) chunk = new AIMessageChunk({
        content: token,
        id: `run-${run.id}`
      });
      else chunk = kwargs.chunk.message;
    } else if (runInfo.runType === "llm") {
      eventName = "on_llm_stream";
      if ((kwargs == null ? void 0 : kwargs.chunk) === void 0) chunk = new GenerationChunk({ text: token });
      else chunk = kwargs.chunk;
    } else throw new Error(`Unexpected run type ${runInfo.runType}`);
    await this.send({
      event: eventName,
      data: { chunk },
      run_id: run.id,
      name: runInfo.name,
      tags: runInfo.tags,
      metadata: runInfo.metadata
    }, runInfo);
  }
  async onLLMEnd(run) {
    var _a3, _b, _c;
    const runInfo = this.runInfoMap.get(run.id);
    this.runInfoMap.delete(run.id);
    let eventName;
    if (runInfo === void 0) throw new Error(`onLLMEnd: Run ID ${run.id} not found in run map.`);
    const generations = (_a3 = run.outputs) == null ? void 0 : _a3.generations;
    let output;
    if (runInfo.runType === "chat_model") {
      for (const generation of generations ?? []) {
        if (output !== void 0) break;
        output = (_b = generation[0]) == null ? void 0 : _b.message;
      }
      eventName = "on_chat_model_end";
    } else if (runInfo.runType === "llm") {
      output = {
        generations: generations == null ? void 0 : generations.map((generation) => {
          return generation.map((chunk) => {
            return {
              text: chunk.text,
              generationInfo: chunk.generationInfo
            };
          });
        }),
        llmOutput: ((_c = run.outputs) == null ? void 0 : _c.llmOutput) ?? {}
      };
      eventName = "on_llm_end";
    } else throw new Error(`onLLMEnd: Unexpected run type: ${runInfo.runType}`);
    await this.sendEndEvent({
      event: eventName,
      data: {
        output,
        input: runInfo.inputs
      },
      run_id: run.id,
      name: runInfo.name,
      tags: runInfo.tags,
      metadata: runInfo.metadata
    }, runInfo);
  }
  async onChainStart(run) {
    var _a3, _b;
    const runName = assignName(run);
    const runType = run.run_type ?? "chain";
    const runInfo = {
      tags: run.tags ?? [],
      metadata: ((_a3 = run.extra) == null ? void 0 : _a3.metadata) ?? {},
      name: runName,
      runType: run.run_type
    };
    let eventData = {};
    if (run.inputs.input === "" && Object.keys(run.inputs).length === 1) {
      eventData = {};
      runInfo.inputs = {};
    } else if (run.inputs.input !== void 0) {
      eventData.input = run.inputs.input;
      runInfo.inputs = run.inputs.input;
    } else {
      eventData.input = run.inputs;
      runInfo.inputs = run.inputs;
    }
    this.runInfoMap.set(run.id, runInfo);
    await this.send({
      event: `on_${runType}_start`,
      data: eventData,
      name: runName,
      tags: run.tags ?? [],
      run_id: run.id,
      metadata: ((_b = run.extra) == null ? void 0 : _b.metadata) ?? {}
    }, runInfo);
  }
  async onChainEnd(run) {
    var _a3;
    const runInfo = this.runInfoMap.get(run.id);
    this.runInfoMap.delete(run.id);
    if (runInfo === void 0) throw new Error(`onChainEnd: Run ID ${run.id} not found in run map.`);
    const eventName = `on_${run.run_type}_end`;
    const inputs = run.inputs ?? runInfo.inputs ?? {};
    const outputs = ((_a3 = run.outputs) == null ? void 0 : _a3.output) ?? run.outputs;
    const data = {
      output: outputs,
      input: inputs
    };
    if (inputs.input && Object.keys(inputs).length === 1) {
      data.input = inputs.input;
      runInfo.inputs = inputs.input;
    }
    await this.sendEndEvent({
      event: eventName,
      data,
      run_id: run.id,
      name: runInfo.name,
      tags: runInfo.tags,
      metadata: runInfo.metadata ?? {}
    }, runInfo);
  }
  async onToolStart(run) {
    var _a3, _b;
    const runName = assignName(run);
    const runInfo = {
      tags: run.tags ?? [],
      metadata: ((_a3 = run.extra) == null ? void 0 : _a3.metadata) ?? {},
      name: runName,
      runType: "tool",
      inputs: run.inputs ?? {}
    };
    this.runInfoMap.set(run.id, runInfo);
    await this.send({
      event: "on_tool_start",
      data: { input: run.inputs ?? {} },
      name: runName,
      run_id: run.id,
      tags: run.tags ?? [],
      metadata: ((_b = run.extra) == null ? void 0 : _b.metadata) ?? {}
    }, runInfo);
  }
  async onToolEnd(run) {
    var _a3;
    const runInfo = this.runInfoMap.get(run.id);
    this.runInfoMap.delete(run.id);
    if (runInfo === void 0) throw new Error(`onToolEnd: Run ID ${run.id} not found in run map.`);
    if (runInfo.inputs === void 0) throw new Error(`onToolEnd: Run ID ${run.id} is a tool call, and is expected to have traced inputs.`);
    const output = ((_a3 = run.outputs) == null ? void 0 : _a3.output) === void 0 ? run.outputs : run.outputs.output;
    await this.sendEndEvent({
      event: "on_tool_end",
      data: {
        output,
        input: runInfo.inputs
      },
      run_id: run.id,
      name: runInfo.name,
      tags: runInfo.tags,
      metadata: runInfo.metadata
    }, runInfo);
  }
  async onRetrieverStart(run) {
    var _a3, _b;
    const runName = assignName(run);
    const runType = "retriever";
    const runInfo = {
      tags: run.tags ?? [],
      metadata: ((_a3 = run.extra) == null ? void 0 : _a3.metadata) ?? {},
      name: runName,
      runType,
      inputs: { query: run.inputs.query }
    };
    this.runInfoMap.set(run.id, runInfo);
    await this.send({
      event: "on_retriever_start",
      data: { input: { query: run.inputs.query } },
      name: runName,
      tags: run.tags ?? [],
      run_id: run.id,
      metadata: ((_b = run.extra) == null ? void 0 : _b.metadata) ?? {}
    }, runInfo);
  }
  async onRetrieverEnd(run) {
    var _a3;
    const runInfo = this.runInfoMap.get(run.id);
    this.runInfoMap.delete(run.id);
    if (runInfo === void 0) throw new Error(`onRetrieverEnd: Run ID ${run.id} not found in run map.`);
    await this.sendEndEvent({
      event: "on_retriever_end",
      data: {
        output: ((_a3 = run.outputs) == null ? void 0 : _a3.documents) ?? run.outputs,
        input: runInfo.inputs
      },
      run_id: run.id,
      name: runInfo.name,
      tags: runInfo.tags,
      metadata: runInfo.metadata
    }, runInfo);
  }
  async handleCustomEvent(eventName, data, runId) {
    const runInfo = this.runInfoMap.get(runId);
    if (runInfo === void 0) throw new Error(`handleCustomEvent: Run ID ${runId} not found in run map.`);
    await this.send({
      event: "on_custom_event",
      run_id: runId,
      name: eventName,
      tags: runInfo.tags,
      metadata: runInfo.metadata,
      data
    }, runInfo);
  }
  async finish() {
    const pendingPromises = [...this.tappedPromises.values()];
    Promise.all(pendingPromises).finally(() => {
      this.writer.close();
    });
  }
};
const objectToString = Object.prototype.toString;
const isError = (value) => objectToString.call(value) === "[object Error]";
const errorMessages = /* @__PURE__ */ new Set([
  "network error",
  "Failed to fetch",
  "NetworkError when attempting to fetch resource.",
  "The Internet connection appears to be offline.",
  "Network request failed",
  "fetch failed",
  "terminated",
  " A network error occurred.",
  "Network connection lost"
]);
function isNetworkError(error) {
  const isValid2 = error && isError(error) && error.name === "TypeError" && typeof error.message === "string";
  if (!isValid2) return false;
  const { message, stack } = error;
  if (message === "Load failed") return stack === void 0 || "__sentry_captured__" in error;
  if (message.startsWith("error sending request for url")) return true;
  return errorMessages.has(message);
}
function validateRetries(retries) {
  if (typeof retries === "number") {
    if (retries < 0) throw new TypeError("Expected `retries` to be a non-negative number.");
    if (Number.isNaN(retries)) throw new TypeError("Expected `retries` to be a valid number or Infinity, got NaN.");
  } else if (retries !== void 0) throw new TypeError("Expected `retries` to be a number or Infinity.");
}
function validateNumberOption(name, value, { min = 0, allowInfinity = false } = {}) {
  if (value === void 0) return;
  if (typeof value !== "number" || Number.isNaN(value)) throw new TypeError(`Expected \`${name}\` to be a number${allowInfinity ? " or Infinity" : ""}.`);
  if (!allowInfinity && !Number.isFinite(value)) throw new TypeError(`Expected \`${name}\` to be a finite number.`);
  if (value < min) throw new TypeError(`Expected \`${name}\` to be â‰¥ ${min}.`);
}
var AbortError = class extends Error {
  constructor(message) {
    super();
    if (message instanceof Error) {
      this.originalError = message;
      ({ message } = message);
    } else {
      this.originalError = new Error(message);
      this.originalError.stack = this.stack;
    }
    this.name = "AbortError";
    this.message = message;
  }
};
function calculateDelay(retriesConsumed, options2) {
  const attempt = Math.max(1, retriesConsumed + 1);
  const random = options2.randomize ? Math.random() + 1 : 1;
  let timeout = Math.round(random * options2.minTimeout * options2.factor ** (attempt - 1));
  timeout = Math.min(timeout, options2.maxTimeout);
  return timeout;
}
function calculateRemainingTime(start, max) {
  if (!Number.isFinite(max)) return max;
  return max - (performance.now() - start);
}
async function onAttemptFailure({ error, attemptNumber, retriesConsumed, startTime: startTime2, options: options2 }) {
  var _a3, _b, _c;
  const normalizedError = error instanceof Error ? error : /* @__PURE__ */ new TypeError(`Non-error was thrown: "${error}". You should only throw errors.`);
  if (normalizedError instanceof AbortError) throw normalizedError.originalError;
  const retriesLeft = Number.isFinite(options2.retries) ? Math.max(0, options2.retries - retriesConsumed) : options2.retries;
  const maxRetryTime = options2.maxRetryTime ?? Number.POSITIVE_INFINITY;
  const context = Object.freeze({
    error: normalizedError,
    attemptNumber,
    retriesLeft,
    retriesConsumed
  });
  await options2.onFailedAttempt(context);
  if (calculateRemainingTime(startTime2, maxRetryTime) <= 0) throw normalizedError;
  const consumeRetry = await options2.shouldConsumeRetry(context);
  const remainingTime = calculateRemainingTime(startTime2, maxRetryTime);
  if (remainingTime <= 0 || retriesLeft <= 0) throw normalizedError;
  if (normalizedError instanceof TypeError && !isNetworkError(normalizedError)) {
    if (consumeRetry) throw normalizedError;
    (_a3 = options2.signal) == null ? void 0 : _a3.throwIfAborted();
    return false;
  }
  if (!await options2.shouldRetry(context)) throw normalizedError;
  if (!consumeRetry) {
    (_b = options2.signal) == null ? void 0 : _b.throwIfAborted();
    return false;
  }
  const delayTime = calculateDelay(retriesConsumed, options2);
  const finalDelay = Math.min(delayTime, remainingTime);
  if (finalDelay > 0) await new Promise((resolve, reject) => {
    var _a4, _b2;
    const onAbort = () => {
      var _a5;
      clearTimeout(timeoutToken);
      (_a5 = options2.signal) == null ? void 0 : _a5.removeEventListener("abort", onAbort);
      reject(options2.signal.reason);
    };
    const timeoutToken = setTimeout(() => {
      var _a5;
      (_a5 = options2.signal) == null ? void 0 : _a5.removeEventListener("abort", onAbort);
      resolve();
    }, finalDelay);
    if (options2.unref) (_a4 = timeoutToken.unref) == null ? void 0 : _a4.call(timeoutToken);
    (_b2 = options2.signal) == null ? void 0 : _b2.addEventListener("abort", onAbort, { once: true });
  });
  (_c = options2.signal) == null ? void 0 : _c.throwIfAborted();
  return true;
}
async function pRetry(input, options2 = {}) {
  var _a3, _b, _c;
  options2 = { ...options2 };
  validateRetries(options2.retries);
  if (Object.hasOwn(options2, "forever")) throw new Error("The `forever` option is no longer supported. For many use-cases, you can set `retries: Infinity` instead.");
  options2.retries ?? (options2.retries = 10);
  options2.factor ?? (options2.factor = 2);
  options2.minTimeout ?? (options2.minTimeout = 1e3);
  options2.maxTimeout ?? (options2.maxTimeout = Number.POSITIVE_INFINITY);
  options2.maxRetryTime ?? (options2.maxRetryTime = Number.POSITIVE_INFINITY);
  options2.randomize ?? (options2.randomize = false);
  options2.onFailedAttempt ?? (options2.onFailedAttempt = () => {
  });
  options2.shouldRetry ?? (options2.shouldRetry = () => true);
  options2.shouldConsumeRetry ?? (options2.shouldConsumeRetry = () => true);
  validateNumberOption("factor", options2.factor, {
    min: 0,
    allowInfinity: false
  });
  validateNumberOption("minTimeout", options2.minTimeout, {
    min: 0,
    allowInfinity: false
  });
  validateNumberOption("maxTimeout", options2.maxTimeout, {
    min: 0,
    allowInfinity: true
  });
  validateNumberOption("maxRetryTime", options2.maxRetryTime, {
    min: 0,
    allowInfinity: true
  });
  if (!(options2.factor > 0)) options2.factor = 1;
  (_a3 = options2.signal) == null ? void 0 : _a3.throwIfAborted();
  let attemptNumber = 0;
  let retriesConsumed = 0;
  const startTime2 = performance.now();
  while (Number.isFinite(options2.retries) ? retriesConsumed <= options2.retries : true) {
    attemptNumber++;
    try {
      (_b = options2.signal) == null ? void 0 : _b.throwIfAborted();
      const result = await input(attemptNumber);
      (_c = options2.signal) == null ? void 0 : _c.throwIfAborted();
      return result;
    } catch (error) {
      if (await onAttemptFailure({
        error,
        attemptNumber,
        retriesConsumed,
        startTime: startTime2,
        options: options2
      })) retriesConsumed++;
    }
  }
  throw new Error("Retry attempts exhausted without throwing an error.");
}
var async_caller_exports = {};
__export(async_caller_exports, { AsyncCaller: () => AsyncCaller });
const STATUS_NO_RETRY = [
  400,
  401,
  402,
  403,
  404,
  405,
  406,
  407,
  409
];
const defaultFailedAttemptHandler = (error) => {
  var _a3, _b;
  if (error.message.startsWith("Cancel") || error.message.startsWith("AbortError") || error.name === "AbortError") throw error;
  if ((error == null ? void 0 : error.code) === "ECONNABORTED") throw error;
  const status = ((_a3 = error == null ? void 0 : error.response) == null ? void 0 : _a3.status) ?? (error == null ? void 0 : error.status);
  if (status && STATUS_NO_RETRY.includes(+status)) throw error;
  if (((_b = error == null ? void 0 : error.error) == null ? void 0 : _b.code) === "insufficient_quota") {
    const err = new Error(error == null ? void 0 : error.message);
    err.name = "InsufficientQuotaError";
    throw err;
  }
};
var AsyncCaller = class {
  constructor(params) {
    __publicField2(this, "maxConcurrency");
    __publicField2(this, "maxRetries");
    __publicField2(this, "onFailedAttempt");
    __publicField2(this, "queue");
    this.maxConcurrency = params.maxConcurrency ?? Infinity;
    this.maxRetries = params.maxRetries ?? 6;
    this.onFailedAttempt = params.onFailedAttempt ?? defaultFailedAttemptHandler;
    const PQueue2 = "default" in _default$1 ? _default$1.default : _default$1;
    this.queue = new PQueue2({ concurrency: this.maxConcurrency });
  }
  async call(callable, ...args) {
    return this.queue.add(() => pRetry(() => callable(...args).catch((error) => {
      if (error instanceof Error) throw error;
      else throw new Error(error);
    }), {
      onFailedAttempt: ({ error }) => {
        var _a3;
        return (_a3 = this.onFailedAttempt) == null ? void 0 : _a3.call(this, error);
      },
      retries: this.maxRetries,
      randomize: true
    }), { throwOnTimeout: true });
  }
  callWithOptions(options2, callable, ...args) {
    if (options2.signal) {
      let listener;
      return Promise.race([this.call(callable, ...args), new Promise((_, reject) => {
        var _a3;
        listener = () => {
          reject(getAbortSignalError(options2.signal));
        };
        (_a3 = options2.signal) == null ? void 0 : _a3.addEventListener("abort", listener);
      })]).finally(() => {
        if (options2.signal && listener) options2.signal.removeEventListener("abort", listener);
      });
    }
    return this.call(callable, ...args);
  }
  fetch(...args) {
    return this.call(() => fetch(...args).then((res) => res.ok ? res : Promise.reject(res)));
  }
};
var RootListenersTracer = class extends BaseTracer {
  constructor({ config: config2, onStart, onEnd, onError }) {
    super({ _awaitHandler: true });
    __publicField2(this, "name", "RootListenersTracer");
    /** The Run's ID. Type UUID */
    __publicField2(this, "rootId");
    __publicField2(this, "config");
    __publicField2(this, "argOnStart");
    __publicField2(this, "argOnEnd");
    __publicField2(this, "argOnError");
    this.config = config2;
    this.argOnStart = onStart;
    this.argOnEnd = onEnd;
    this.argOnError = onError;
  }
  /**
  * This is a legacy method only called once for an entire run tree
  * therefore not useful here
  * @param {Run} _ Not used
  */
  persistRun(_) {
    return Promise.resolve();
  }
  async onRunCreate(run) {
    if (this.rootId) return;
    this.rootId = run.id;
    if (this.argOnStart) await this.argOnStart(run, this.config);
  }
  async onRunUpdate(run) {
    if (run.id !== this.rootId) return;
    if (!run.error) {
      if (this.argOnEnd) await this.argOnEnd(run, this.config);
    } else if (this.argOnError) await this.argOnError(run, this.config);
  }
};
function isRunnableInterface(thing) {
  return thing ? thing.lc_runnable : false;
}
var _RootEventFilter = class {
  constructor(fields) {
    __publicField2(this, "includeNames");
    __publicField2(this, "includeTypes");
    __publicField2(this, "includeTags");
    __publicField2(this, "excludeNames");
    __publicField2(this, "excludeTypes");
    __publicField2(this, "excludeTags");
    this.includeNames = fields.includeNames;
    this.includeTypes = fields.includeTypes;
    this.includeTags = fields.includeTags;
    this.excludeNames = fields.excludeNames;
    this.excludeTypes = fields.excludeTypes;
    this.excludeTags = fields.excludeTags;
  }
  includeEvent(event, rootType) {
    let include = this.includeNames === void 0 && this.includeTypes === void 0 && this.includeTags === void 0;
    const eventTags = event.tags ?? [];
    if (this.includeNames !== void 0) include = include || this.includeNames.includes(event.name);
    if (this.includeTypes !== void 0) include = include || this.includeTypes.includes(rootType);
    if (this.includeTags !== void 0) include = include || eventTags.some((tag) => {
      var _a3;
      return (_a3 = this.includeTags) == null ? void 0 : _a3.includes(tag);
    });
    if (this.excludeNames !== void 0) include = include && !this.excludeNames.includes(event.name);
    if (this.excludeTypes !== void 0) include = include && !this.excludeTypes.includes(rootType);
    if (this.excludeTags !== void 0) include = include && eventTags.every((tag) => {
      var _a3;
      return !((_a3 = this.excludeTags) == null ? void 0 : _a3.includes(tag));
    });
    return include;
  }
};
const toBase64Url = (str2) => {
  const encoded = btoa(str2);
  return encoded.replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
};
function $constructor(name, initializer2, params) {
  function init(inst, def) {
    if (!inst._zod) {
      Object.defineProperty(inst, "_zod", {
        value: {
          def,
          constr: _,
          traits: /* @__PURE__ */ new Set()
        },
        enumerable: false
      });
    }
    if (inst._zod.traits.has(name)) {
      return;
    }
    inst._zod.traits.add(name);
    initializer2(inst, def);
    const proto = _.prototype;
    const keys = Object.keys(proto);
    for (let i2 = 0; i2 < keys.length; i2++) {
      const k = keys[i2];
      if (!(k in inst)) {
        inst[k] = proto[k].bind(inst);
      }
    }
  }
  const Parent = (params == null ? void 0 : params.Parent) ?? Object;
  class Definition extends Parent {
  }
  Object.defineProperty(Definition, "name", { value: name });
  function _(def) {
    var _a3;
    const inst = (params == null ? void 0 : params.Parent) ? new Definition() : this;
    init(inst, def);
    (_a3 = inst._zod).deferred ?? (_a3.deferred = []);
    for (const fn of inst._zod.deferred) {
      fn();
    }
    return inst;
  }
  Object.defineProperty(_, "init", { value: init });
  Object.defineProperty(_, Symbol.hasInstance, {
    value: (inst) => {
      var _a3, _b;
      if ((params == null ? void 0 : params.Parent) && inst instanceof params.Parent)
        return true;
      return (_b = (_a3 = inst == null ? void 0 : inst._zod) == null ? void 0 : _a3.traits) == null ? void 0 : _b.has(name);
    }
  });
  Object.defineProperty(_, "name", { value: name });
  return _;
}
class $ZodAsyncError extends Error {
  constructor() {
    super(`Encountered Promise during synchronous parse. Use .parseAsync() instead.`);
  }
}
class $ZodEncodeError extends Error {
  constructor(name) {
    super(`Encountered unidirectional transform during encode: ${name}`);
    this.name = "ZodEncodeError";
  }
}
const globalConfig = {};
function config$1(newConfig) {
  return globalConfig;
}
function getEnumValues(entries) {
  const numericValues = Object.values(entries).filter((v) => typeof v === "number");
  const values = Object.entries(entries).filter(([k, _]) => numericValues.indexOf(+k) === -1).map(([_, v]) => v);
  return values;
}
function jsonStringifyReplacer(_, value) {
  if (typeof value === "bigint")
    return value.toString();
  return value;
}
function cached(getter) {
  return {
    get value() {
      {
        const value = getter();
        Object.defineProperty(this, "value", { value });
        return value;
      }
    }
  };
}
function nullish(input) {
  return input === null || input === void 0;
}
function cleanRegex(source) {
  const start = source.startsWith("^") ? 1 : 0;
  const end = source.endsWith("$") ? source.length - 1 : source.length;
  return source.slice(start, end);
}
function floatSafeRemainder$1(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepString = step.toString();
  let stepDecCount = (stepString.split(".")[1] || "").length;
  if (stepDecCount === 0 && /\d?e-\d?/.test(stepString)) {
    const match = stepString.match(/\d?e-(\d?)/);
    if (match == null ? void 0 : match[1]) {
      stepDecCount = Number.parseInt(match[1]);
    }
  }
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}
const EVALUATING = Symbol("evaluating");
function defineLazy(object2, key, getter) {
  let value = void 0;
  Object.defineProperty(object2, key, {
    get() {
      if (value === EVALUATING) {
        return void 0;
      }
      if (value === void 0) {
        value = EVALUATING;
        value = getter();
      }
      return value;
    },
    set(v) {
      Object.defineProperty(object2, key, {
        value: v
        // configurable: true,
      });
    },
    configurable: true
  });
}
function assignProp(target, prop, value) {
  Object.defineProperty(target, prop, {
    value,
    writable: true,
    enumerable: true,
    configurable: true
  });
}
function mergeDefs(...defs) {
  const mergedDescriptors = {};
  for (const def of defs) {
    const descriptors = Object.getOwnPropertyDescriptors(def);
    Object.assign(mergedDescriptors, descriptors);
  }
  return Object.defineProperties({}, mergedDescriptors);
}
function esc(str2) {
  return JSON.stringify(str2);
}
function slugify(input) {
  return input.toLowerCase().trim().replace(/[^\w\s-]/g, "").replace(/[\s_-]+/g, "-").replace(/^-+|-+$/g, "");
}
const captureStackTrace = "captureStackTrace" in Error ? Error.captureStackTrace : (..._args) => {
};
function isObject$1(data) {
  return typeof data === "object" && data !== null && !Array.isArray(data);
}
const allowsEval = cached(() => {
  var _a3;
  if (typeof navigator !== "undefined" && ((_a3 = navigator == null ? void 0 : navigator.userAgent) == null ? void 0 : _a3.includes("Cloudflare"))) {
    return false;
  }
  try {
    const F = Function;
    new F("");
    return true;
  } catch (_) {
    return false;
  }
});
function isPlainObject(o) {
  if (isObject$1(o) === false)
    return false;
  const ctor = o.constructor;
  if (ctor === void 0)
    return true;
  if (typeof ctor !== "function")
    return true;
  const prot = ctor.prototype;
  if (isObject$1(prot) === false)
    return false;
  if (Object.prototype.hasOwnProperty.call(prot, "isPrototypeOf") === false) {
    return false;
  }
  return true;
}
function shallowClone(o) {
  if (isPlainObject(o))
    return { ...o };
  if (Array.isArray(o))
    return [...o];
  return o;
}
const propertyKeyTypes = /* @__PURE__ */ new Set(["string", "number", "symbol"]);
function escapeRegex$1(str2) {
  return str2.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function clone(inst, def, params) {
  const cl = new inst._zod.constr(def ?? inst._zod.def);
  if (!def || (params == null ? void 0 : params.parent))
    cl._zod.parent = inst;
  return cl;
}
function normalizeParams(_params) {
  const params = _params;
  if (!params)
    return {};
  if (typeof params === "string")
    return { error: () => params };
  if ((params == null ? void 0 : params.message) !== void 0) {
    if ((params == null ? void 0 : params.error) !== void 0)
      throw new Error("Cannot specify both `message` and `error` params");
    params.error = params.message;
  }
  delete params.message;
  if (typeof params.error === "string")
    return { ...params, error: () => params.error };
  return params;
}
function optionalKeys(shape) {
  return Object.keys(shape).filter((k) => {
    return shape[k]._zod.optin === "optional" && shape[k]._zod.optout === "optional";
  });
}
const NUMBER_FORMAT_RANGES = {
  safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],
  int32: [-2147483648, 2147483647],
  uint32: [0, 4294967295],
  float32: [-34028234663852886e22, 34028234663852886e22],
  float64: [-Number.MAX_VALUE, Number.MAX_VALUE]
};
function pick(schema, mask) {
  const currDef = schema._zod.def;
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const newShape = {};
      for (const key in mask) {
        if (!(key in currDef.shape)) {
          throw new Error(`Unrecognized key: "${key}"`);
        }
        if (!mask[key])
          continue;
        newShape[key] = currDef.shape[key];
      }
      assignProp(this, "shape", newShape);
      return newShape;
    },
    checks: []
  });
  return clone(schema, def);
}
function omit(schema, mask) {
  const currDef = schema._zod.def;
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const newShape = { ...schema._zod.def.shape };
      for (const key in mask) {
        if (!(key in currDef.shape)) {
          throw new Error(`Unrecognized key: "${key}"`);
        }
        if (!mask[key])
          continue;
        delete newShape[key];
      }
      assignProp(this, "shape", newShape);
      return newShape;
    },
    checks: []
  });
  return clone(schema, def);
}
function extend(schema, shape) {
  if (!isPlainObject(shape)) {
    throw new Error("Invalid input to extend: expected a plain object");
  }
  const checks = schema._zod.def.checks;
  const hasChecks = checks && checks.length > 0;
  if (hasChecks) {
    throw new Error("Object schemas containing refinements cannot be extended. Use `.safeExtend()` instead.");
  }
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const _shape = { ...schema._zod.def.shape, ...shape };
      assignProp(this, "shape", _shape);
      return _shape;
    },
    checks: []
  });
  return clone(schema, def);
}
function safeExtend(schema, shape) {
  if (!isPlainObject(shape)) {
    throw new Error("Invalid input to safeExtend: expected a plain object");
  }
  const def = {
    ...schema._zod.def,
    get shape() {
      const _shape = { ...schema._zod.def.shape, ...shape };
      assignProp(this, "shape", _shape);
      return _shape;
    },
    checks: schema._zod.def.checks
  };
  return clone(schema, def);
}
function merge(a, b) {
  const def = mergeDefs(a._zod.def, {
    get shape() {
      const _shape = { ...a._zod.def.shape, ...b._zod.def.shape };
      assignProp(this, "shape", _shape);
      return _shape;
    },
    get catchall() {
      return b._zod.def.catchall;
    },
    checks: []
    // delete existing checks
  });
  return clone(a, def);
}
function partial(Class, schema, mask) {
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const oldShape = schema._zod.def.shape;
      const shape = { ...oldShape };
      if (mask) {
        for (const key in mask) {
          if (!(key in oldShape)) {
            throw new Error(`Unrecognized key: "${key}"`);
          }
          if (!mask[key])
            continue;
          shape[key] = Class ? new Class({
            type: "optional",
            innerType: oldShape[key]
          }) : oldShape[key];
        }
      } else {
        for (const key in oldShape) {
          shape[key] = Class ? new Class({
            type: "optional",
            innerType: oldShape[key]
          }) : oldShape[key];
        }
      }
      assignProp(this, "shape", shape);
      return shape;
    },
    checks: []
  });
  return clone(schema, def);
}
function required(Class, schema, mask) {
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const oldShape = schema._zod.def.shape;
      const shape = { ...oldShape };
      if (mask) {
        for (const key in mask) {
          if (!(key in shape)) {
            throw new Error(`Unrecognized key: "${key}"`);
          }
          if (!mask[key])
            continue;
          shape[key] = new Class({
            type: "nonoptional",
            innerType: oldShape[key]
          });
        }
      } else {
        for (const key in oldShape) {
          shape[key] = new Class({
            type: "nonoptional",
            innerType: oldShape[key]
          });
        }
      }
      assignProp(this, "shape", shape);
      return shape;
    },
    checks: []
  });
  return clone(schema, def);
}
function aborted(x, startIndex = 0) {
  var _a3;
  if (x.aborted === true)
    return true;
  for (let i2 = startIndex; i2 < x.issues.length; i2++) {
    if (((_a3 = x.issues[i2]) == null ? void 0 : _a3.continue) !== true) {
      return true;
    }
  }
  return false;
}
function prefixIssues(path2, issues) {
  return issues.map((iss) => {
    var _a3;
    (_a3 = iss).path ?? (_a3.path = []);
    iss.path.unshift(path2);
    return iss;
  });
}
function unwrapMessage(message) {
  return typeof message === "string" ? message : message == null ? void 0 : message.message;
}
function finalizeIssue(iss, ctx, config2) {
  var _a3, _b, _c, _d, _e, _f;
  const full = { ...iss, path: iss.path ?? [] };
  if (!iss.message) {
    const message = unwrapMessage((_c = (_b = (_a3 = iss.inst) == null ? void 0 : _a3._zod.def) == null ? void 0 : _b.error) == null ? void 0 : _c.call(_b, iss)) ?? unwrapMessage((_d = ctx == null ? void 0 : ctx.error) == null ? void 0 : _d.call(ctx, iss)) ?? unwrapMessage((_e = config2.customError) == null ? void 0 : _e.call(config2, iss)) ?? unwrapMessage((_f = config2.localeError) == null ? void 0 : _f.call(config2, iss)) ?? "Invalid input";
    full.message = message;
  }
  delete full.inst;
  delete full.continue;
  if (!(ctx == null ? void 0 : ctx.reportInput)) {
    delete full.input;
  }
  return full;
}
function getLengthableOrigin(input) {
  if (Array.isArray(input))
    return "array";
  if (typeof input === "string")
    return "string";
  return "unknown";
}
function issue(...args) {
  const [iss, input, inst] = args;
  if (typeof iss === "string") {
    return {
      message: iss,
      code: "custom",
      input,
      inst
    };
  }
  return { ...iss };
}
const initializer$1 = (inst, def) => {
  inst.name = "$ZodError";
  Object.defineProperty(inst, "_zod", {
    value: inst._zod,
    enumerable: false
  });
  Object.defineProperty(inst, "issues", {
    value: def,
    enumerable: false
  });
  inst.message = JSON.stringify(def, jsonStringifyReplacer, 2);
  Object.defineProperty(inst, "toString", {
    value: () => inst.message,
    enumerable: false
  });
};
const $ZodError = $constructor("$ZodError", initializer$1);
const $ZodRealError = $constructor("$ZodError", initializer$1, { Parent: Error });
function flattenError(error, mapper = (issue2) => issue2.message) {
  const fieldErrors = {};
  const formErrors = [];
  for (const sub of error.issues) {
    if (sub.path.length > 0) {
      fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
      fieldErrors[sub.path[0]].push(mapper(sub));
    } else {
      formErrors.push(mapper(sub));
    }
  }
  return { formErrors, fieldErrors };
}
function formatError(error, mapper = (issue2) => issue2.message) {
  const fieldErrors = { _errors: [] };
  const processError = (error2) => {
    for (const issue2 of error2.issues) {
      if (issue2.code === "invalid_union" && issue2.errors.length) {
        issue2.errors.map((issues) => processError({ issues }));
      } else if (issue2.code === "invalid_key") {
        processError({ issues: issue2.issues });
      } else if (issue2.code === "invalid_element") {
        processError({ issues: issue2.issues });
      } else if (issue2.path.length === 0) {
        fieldErrors._errors.push(mapper(issue2));
      } else {
        let curr = fieldErrors;
        let i2 = 0;
        while (i2 < issue2.path.length) {
          const el = issue2.path[i2];
          const terminal = i2 === issue2.path.length - 1;
          if (!terminal) {
            curr[el] = curr[el] || { _errors: [] };
          } else {
            curr[el] = curr[el] || { _errors: [] };
            curr[el]._errors.push(mapper(issue2));
          }
          curr = curr[el];
          i2++;
        }
      }
    }
  };
  processError(error);
  return fieldErrors;
}
function toDotPath(_path) {
  const segs = [];
  const path2 = _path.map((seg) => typeof seg === "object" ? seg.key : seg);
  for (const seg of path2) {
    if (typeof seg === "number")
      segs.push(`[${seg}]`);
    else if (typeof seg === "symbol")
      segs.push(`[${JSON.stringify(String(seg))}]`);
    else if (/[^\w$]/.test(seg))
      segs.push(`[${JSON.stringify(seg)}]`);
    else {
      if (segs.length)
        segs.push(".");
      segs.push(seg);
    }
  }
  return segs.join("");
}
function prettifyError(error) {
  var _a3;
  const lines = [];
  const issues = [...error.issues].sort((a, b) => (a.path ?? []).length - (b.path ?? []).length);
  for (const issue2 of issues) {
    lines.push(`âœ– ${issue2.message}`);
    if ((_a3 = issue2.path) == null ? void 0 : _a3.length)
      lines.push(`  â†’ at ${toDotPath(issue2.path)}`);
  }
  return lines.join("\n");
}
const _parse = (_Err) => (schema, value, _ctx, _params) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: false }) : { async: false };
  const result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise) {
    throw new $ZodAsyncError();
  }
  if (result.issues.length) {
    const e = new ((_params == null ? void 0 : _params.Err) ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config$1())));
    captureStackTrace(e, _params == null ? void 0 : _params.callee);
    throw e;
  }
  return result.value;
};
const parse$2 = /* @__PURE__ */ _parse($ZodRealError);
const _parseAsync = (_Err) => async (schema, value, _ctx, params) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
  let result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise)
    result = await result;
  if (result.issues.length) {
    const e = new ((params == null ? void 0 : params.Err) ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config$1())));
    captureStackTrace(e, params == null ? void 0 : params.callee);
    throw e;
  }
  return result.value;
};
const parseAsync$1 = /* @__PURE__ */ _parseAsync($ZodRealError);
const _safeParse = (_Err) => (schema, value, _ctx) => {
  const ctx = _ctx ? { ..._ctx, async: false } : { async: false };
  const result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise) {
    throw new $ZodAsyncError();
  }
  return result.issues.length ? {
    success: false,
    error: new (_Err ?? $ZodError)(result.issues.map((iss) => finalizeIssue(iss, ctx, config$1())))
  } : { success: true, data: result.value };
};
const safeParse$1 = /* @__PURE__ */ _safeParse($ZodRealError);
const _safeParseAsync = (_Err) => async (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
  let result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise)
    result = await result;
  return result.issues.length ? {
    success: false,
    error: new _Err(result.issues.map((iss) => finalizeIssue(iss, ctx, config$1())))
  } : { success: true, data: result.value };
};
const safeParseAsync$1 = /* @__PURE__ */ _safeParseAsync($ZodRealError);
const _encode = (_Err) => (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _parse(_Err)(schema, value, ctx);
};
const _decode = (_Err) => (schema, value, _ctx) => {
  return _parse(_Err)(schema, value, _ctx);
};
const _encodeAsync = (_Err) => async (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _parseAsync(_Err)(schema, value, ctx);
};
const _decodeAsync = (_Err) => async (schema, value, _ctx) => {
  return _parseAsync(_Err)(schema, value, _ctx);
};
const _safeEncode = (_Err) => (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _safeParse(_Err)(schema, value, ctx);
};
const _safeDecode = (_Err) => (schema, value, _ctx) => {
  return _safeParse(_Err)(schema, value, _ctx);
};
const _safeEncodeAsync = (_Err) => async (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _safeParseAsync(_Err)(schema, value, ctx);
};
const _safeDecodeAsync = (_Err) => async (schema, value, _ctx) => {
  return _safeParseAsync(_Err)(schema, value, _ctx);
};
const cuid = /^[cC][^\s-]{8,}$/;
const cuid2 = /^[0-9a-z]+$/;
const ulid = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/;
const xid = /^[0-9a-vA-V]{20}$/;
const ksuid = /^[A-Za-z0-9]{27}$/;
const nanoid = /^[a-zA-Z0-9_-]{21}$/;
const duration$1 = /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/;
const guid = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/;
const uuid = (version2) => {
  if (!version2)
    return /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/;
  return new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${version2}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`);
};
const email = /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/;
const _emoji$1 = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
function emoji() {
  return new RegExp(_emoji$1, "u");
}
const ipv4 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
const ipv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$/;
const cidrv4 = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/;
const cidrv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
const base64 = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/;
const base64url = /^[A-Za-z0-9_-]*$/;
const e164 = /^\+(?:[0-9]){6,14}[0-9]$/;
const dateSource = `(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))`;
const date$2 = /* @__PURE__ */ new RegExp(`^${dateSource}$`);
function timeSource(args) {
  const hhmm = `(?:[01]\\d|2[0-3]):[0-5]\\d`;
  const regex2 = typeof args.precision === "number" ? args.precision === -1 ? `${hhmm}` : args.precision === 0 ? `${hhmm}:[0-5]\\d` : `${hhmm}:[0-5]\\d\\.\\d{${args.precision}}` : `${hhmm}(?::[0-5]\\d(?:\\.\\d+)?)?`;
  return regex2;
}
function time$2(args) {
  return new RegExp(`^${timeSource(args)}$`);
}
function datetime$1(args) {
  const time2 = timeSource({ precision: args.precision });
  const opts = ["Z"];
  if (args.local)
    opts.push("");
  if (args.offset)
    opts.push(`([+-](?:[01]\\d|2[0-3]):[0-5]\\d)`);
  const timeRegex2 = `${time2}(?:${opts.join("|")})`;
  return new RegExp(`^${dateSource}T(?:${timeRegex2})$`);
}
const string$1 = (params) => {
  const regex2 = params ? `[\\s\\S]{${(params == null ? void 0 : params.minimum) ?? 0},${(params == null ? void 0 : params.maximum) ?? ""}}` : `[\\s\\S]*`;
  return new RegExp(`^${regex2}$`);
};
const integer = /^-?\d+$/;
const number$1 = /^-?\d+(?:\.\d+)?/;
const boolean$1 = /^(?:true|false)$/i;
const lowercase = /^[^A-Z]*$/;
const uppercase = /^[^a-z]*$/;
const $ZodCheck = /* @__PURE__ */ $constructor("$ZodCheck", (inst, def) => {
  var _a3;
  inst._zod ?? (inst._zod = {});
  inst._zod.def = def;
  (_a3 = inst._zod).onattach ?? (_a3.onattach = []);
});
const numericOriginMap = {
  number: "number",
  bigint: "bigint",
  object: "date"
};
const $ZodCheckLessThan = /* @__PURE__ */ $constructor("$ZodCheckLessThan", (inst, def) => {
  $ZodCheck.init(inst, def);
  const origin = numericOriginMap[typeof def.value];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    const curr = (def.inclusive ? bag.maximum : bag.exclusiveMaximum) ?? Number.POSITIVE_INFINITY;
    if (def.value < curr) {
      if (def.inclusive)
        bag.maximum = def.value;
      else
        bag.exclusiveMaximum = def.value;
    }
  });
  inst._zod.check = (payload) => {
    if (def.inclusive ? payload.value <= def.value : payload.value < def.value) {
      return;
    }
    payload.issues.push({
      origin,
      code: "too_big",
      maximum: def.value,
      input: payload.value,
      inclusive: def.inclusive,
      inst,
      continue: !def.abort
    });
  };
});
const $ZodCheckGreaterThan = /* @__PURE__ */ $constructor("$ZodCheckGreaterThan", (inst, def) => {
  $ZodCheck.init(inst, def);
  const origin = numericOriginMap[typeof def.value];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    const curr = (def.inclusive ? bag.minimum : bag.exclusiveMinimum) ?? Number.NEGATIVE_INFINITY;
    if (def.value > curr) {
      if (def.inclusive)
        bag.minimum = def.value;
      else
        bag.exclusiveMinimum = def.value;
    }
  });
  inst._zod.check = (payload) => {
    if (def.inclusive ? payload.value >= def.value : payload.value > def.value) {
      return;
    }
    payload.issues.push({
      origin,
      code: "too_small",
      minimum: def.value,
      input: payload.value,
      inclusive: def.inclusive,
      inst,
      continue: !def.abort
    });
  };
});
const $ZodCheckMultipleOf = /* @__PURE__ */ $constructor("$ZodCheckMultipleOf", (inst, def) => {
  $ZodCheck.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    var _a3;
    (_a3 = inst2._zod.bag).multipleOf ?? (_a3.multipleOf = def.value);
  });
  inst._zod.check = (payload) => {
    if (typeof payload.value !== typeof def.value)
      throw new Error("Cannot mix number and bigint in multiple_of check.");
    const isMultiple = typeof payload.value === "bigint" ? payload.value % def.value === BigInt(0) : floatSafeRemainder$1(payload.value, def.value) === 0;
    if (isMultiple)
      return;
    payload.issues.push({
      origin: typeof payload.value,
      code: "not_multiple_of",
      divisor: def.value,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
const $ZodCheckNumberFormat = /* @__PURE__ */ $constructor("$ZodCheckNumberFormat", (inst, def) => {
  var _a3;
  $ZodCheck.init(inst, def);
  def.format = def.format || "float64";
  const isInt = (_a3 = def.format) == null ? void 0 : _a3.includes("int");
  const origin = isInt ? "int" : "number";
  const [minimum, maximum] = NUMBER_FORMAT_RANGES[def.format];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = def.format;
    bag.minimum = minimum;
    bag.maximum = maximum;
    if (isInt)
      bag.pattern = integer;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    if (isInt) {
      if (!Number.isInteger(input)) {
        payload.issues.push({
          expected: origin,
          format: def.format,
          code: "invalid_type",
          continue: false,
          input,
          inst
        });
        return;
      }
      if (!Number.isSafeInteger(input)) {
        if (input > 0) {
          payload.issues.push({
            input,
            code: "too_big",
            maximum: Number.MAX_SAFE_INTEGER,
            note: "Integers must be within the safe integer range.",
            inst,
            origin,
            continue: !def.abort
          });
        } else {
          payload.issues.push({
            input,
            code: "too_small",
            minimum: Number.MIN_SAFE_INTEGER,
            note: "Integers must be within the safe integer range.",
            inst,
            origin,
            continue: !def.abort
          });
        }
        return;
      }
    }
    if (input < minimum) {
      payload.issues.push({
        origin: "number",
        input,
        code: "too_small",
        minimum,
        inclusive: true,
        inst,
        continue: !def.abort
      });
    }
    if (input > maximum) {
      payload.issues.push({
        origin: "number",
        input,
        code: "too_big",
        maximum,
        inst
      });
    }
  };
});
const $ZodCheckMaxLength = /* @__PURE__ */ $constructor("$ZodCheckMaxLength", (inst, def) => {
  var _a3;
  $ZodCheck.init(inst, def);
  (_a3 = inst._zod.def).when ?? (_a3.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.length !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    if (def.maximum < curr)
      inst2._zod.bag.maximum = def.maximum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length = input.length;
    if (length <= def.maximum)
      return;
    const origin = getLengthableOrigin(input);
    payload.issues.push({
      origin,
      code: "too_big",
      maximum: def.maximum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
const $ZodCheckMinLength = /* @__PURE__ */ $constructor("$ZodCheckMinLength", (inst, def) => {
  var _a3;
  $ZodCheck.init(inst, def);
  (_a3 = inst._zod.def).when ?? (_a3.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.length !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    if (def.minimum > curr)
      inst2._zod.bag.minimum = def.minimum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length = input.length;
    if (length >= def.minimum)
      return;
    const origin = getLengthableOrigin(input);
    payload.issues.push({
      origin,
      code: "too_small",
      minimum: def.minimum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
const $ZodCheckLengthEquals = /* @__PURE__ */ $constructor("$ZodCheckLengthEquals", (inst, def) => {
  var _a3;
  $ZodCheck.init(inst, def);
  (_a3 = inst._zod.def).when ?? (_a3.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.length !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.minimum = def.length;
    bag.maximum = def.length;
    bag.length = def.length;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length = input.length;
    if (length === def.length)
      return;
    const origin = getLengthableOrigin(input);
    const tooBig = length > def.length;
    payload.issues.push({
      origin,
      ...tooBig ? { code: "too_big", maximum: def.length } : { code: "too_small", minimum: def.length },
      inclusive: true,
      exact: true,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
const $ZodCheckStringFormat = /* @__PURE__ */ $constructor("$ZodCheckStringFormat", (inst, def) => {
  var _a3, _b;
  $ZodCheck.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = def.format;
    if (def.pattern) {
      bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
      bag.patterns.add(def.pattern);
    }
  });
  if (def.pattern)
    (_a3 = inst._zod).check ?? (_a3.check = (payload) => {
      def.pattern.lastIndex = 0;
      if (def.pattern.test(payload.value))
        return;
      payload.issues.push({
        origin: "string",
        code: "invalid_format",
        format: def.format,
        input: payload.value,
        ...def.pattern ? { pattern: def.pattern.toString() } : {},
        inst,
        continue: !def.abort
      });
    });
  else
    (_b = inst._zod).check ?? (_b.check = () => {
    });
});
const $ZodCheckRegex = /* @__PURE__ */ $constructor("$ZodCheckRegex", (inst, def) => {
  $ZodCheckStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    def.pattern.lastIndex = 0;
    if (def.pattern.test(payload.value))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "regex",
      input: payload.value,
      pattern: def.pattern.toString(),
      inst,
      continue: !def.abort
    });
  };
});
const $ZodCheckLowerCase = /* @__PURE__ */ $constructor("$ZodCheckLowerCase", (inst, def) => {
  def.pattern ?? (def.pattern = lowercase);
  $ZodCheckStringFormat.init(inst, def);
});
const $ZodCheckUpperCase = /* @__PURE__ */ $constructor("$ZodCheckUpperCase", (inst, def) => {
  def.pattern ?? (def.pattern = uppercase);
  $ZodCheckStringFormat.init(inst, def);
});
const $ZodCheckIncludes = /* @__PURE__ */ $constructor("$ZodCheckIncludes", (inst, def) => {
  $ZodCheck.init(inst, def);
  const escapedRegex = escapeRegex$1(def.includes);
  const pattern = new RegExp(typeof def.position === "number" ? `^.{${def.position}}${escapedRegex}` : escapedRegex);
  def.pattern = pattern;
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
    bag.patterns.add(pattern);
  });
  inst._zod.check = (payload) => {
    if (payload.value.includes(def.includes, def.position))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "includes",
      includes: def.includes,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
const $ZodCheckStartsWith = /* @__PURE__ */ $constructor("$ZodCheckStartsWith", (inst, def) => {
  $ZodCheck.init(inst, def);
  const pattern = new RegExp(`^${escapeRegex$1(def.prefix)}.*`);
  def.pattern ?? (def.pattern = pattern);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
    bag.patterns.add(pattern);
  });
  inst._zod.check = (payload) => {
    if (payload.value.startsWith(def.prefix))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "starts_with",
      prefix: def.prefix,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
const $ZodCheckEndsWith = /* @__PURE__ */ $constructor("$ZodCheckEndsWith", (inst, def) => {
  $ZodCheck.init(inst, def);
  const pattern = new RegExp(`.*${escapeRegex$1(def.suffix)}$`);
  def.pattern ?? (def.pattern = pattern);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
    bag.patterns.add(pattern);
  });
  inst._zod.check = (payload) => {
    if (payload.value.endsWith(def.suffix))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "ends_with",
      suffix: def.suffix,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
const $ZodCheckOverwrite = /* @__PURE__ */ $constructor("$ZodCheckOverwrite", (inst, def) => {
  $ZodCheck.init(inst, def);
  inst._zod.check = (payload) => {
    payload.value = def.tx(payload.value);
  };
});
class Doc {
  constructor(args = []) {
    this.content = [];
    this.indent = 0;
    if (this)
      this.args = args;
  }
  indented(fn) {
    this.indent += 1;
    fn(this);
    this.indent -= 1;
  }
  write(arg) {
    if (typeof arg === "function") {
      arg(this, { execution: "sync" });
      arg(this, { execution: "async" });
      return;
    }
    const content = arg;
    const lines = content.split("\n").filter((x) => x);
    const minIndent = Math.min(...lines.map((x) => x.length - x.trimStart().length));
    const dedented = lines.map((x) => x.slice(minIndent)).map((x) => " ".repeat(this.indent * 2) + x);
    for (const line of dedented) {
      this.content.push(line);
    }
  }
  compile() {
    const F = Function;
    const args = this == null ? void 0 : this.args;
    const content = (this == null ? void 0 : this.content) ?? [``];
    const lines = [...content.map((x) => `  ${x}`)];
    return new F(...args, lines.join("\n"));
  }
}
const version$2 = {
  major: 4,
  minor: 1,
  patch: 13
};
const $ZodType = /* @__PURE__ */ $constructor("$ZodType", (inst, def) => {
  var _a4;
  var _a3;
  inst ?? (inst = {});
  inst._zod.def = def;
  inst._zod.bag = inst._zod.bag || {};
  inst._zod.version = version$2;
  const checks = [...inst._zod.def.checks ?? []];
  if (inst._zod.traits.has("$ZodCheck")) {
    checks.unshift(inst);
  }
  for (const ch of checks) {
    for (const fn of ch._zod.onattach) {
      fn(inst);
    }
  }
  if (checks.length === 0) {
    (_a3 = inst._zod).deferred ?? (_a3.deferred = []);
    (_a4 = inst._zod.deferred) == null ? void 0 : _a4.push(() => {
      inst._zod.run = inst._zod.parse;
    });
  } else {
    const runChecks = (payload, checks2, ctx) => {
      let isAborted2 = aborted(payload);
      let asyncResult;
      for (const ch of checks2) {
        if (ch._zod.def.when) {
          const shouldRun = ch._zod.def.when(payload);
          if (!shouldRun)
            continue;
        } else if (isAborted2) {
          continue;
        }
        const currLen = payload.issues.length;
        const _ = ch._zod.check(payload);
        if (_ instanceof Promise && (ctx == null ? void 0 : ctx.async) === false) {
          throw new $ZodAsyncError();
        }
        if (asyncResult || _ instanceof Promise) {
          asyncResult = (asyncResult ?? Promise.resolve()).then(async () => {
            await _;
            const nextLen = payload.issues.length;
            if (nextLen === currLen)
              return;
            if (!isAborted2)
              isAborted2 = aborted(payload, currLen);
          });
        } else {
          const nextLen = payload.issues.length;
          if (nextLen === currLen)
            continue;
          if (!isAborted2)
            isAborted2 = aborted(payload, currLen);
        }
      }
      if (asyncResult) {
        return asyncResult.then(() => {
          return payload;
        });
      }
      return payload;
    };
    const handleCanaryResult = (canary, payload, ctx) => {
      if (aborted(canary)) {
        canary.aborted = true;
        return canary;
      }
      const checkResult = runChecks(payload, checks, ctx);
      if (checkResult instanceof Promise) {
        if (ctx.async === false)
          throw new $ZodAsyncError();
        return checkResult.then((checkResult2) => inst._zod.parse(checkResult2, ctx));
      }
      return inst._zod.parse(checkResult, ctx);
    };
    inst._zod.run = (payload, ctx) => {
      if (ctx.skipChecks) {
        return inst._zod.parse(payload, ctx);
      }
      if (ctx.direction === "backward") {
        const canary = inst._zod.parse({ value: payload.value, issues: [] }, { ...ctx, skipChecks: true });
        if (canary instanceof Promise) {
          return canary.then((canary2) => {
            return handleCanaryResult(canary2, payload, ctx);
          });
        }
        return handleCanaryResult(canary, payload, ctx);
      }
      const result = inst._zod.parse(payload, ctx);
      if (result instanceof Promise) {
        if (ctx.async === false)
          throw new $ZodAsyncError();
        return result.then((result2) => runChecks(result2, checks, ctx));
      }
      return runChecks(result, checks, ctx);
    };
  }
  inst["~standard"] = {
    validate: (value) => {
      var _a5;
      try {
        const r = safeParse$1(inst, value);
        return r.success ? { value: r.data } : { issues: (_a5 = r.error) == null ? void 0 : _a5.issues };
      } catch (_) {
        return safeParseAsync$1(inst, value).then((r) => {
          var _a6;
          return r.success ? { value: r.data } : { issues: (_a6 = r.error) == null ? void 0 : _a6.issues };
        });
      }
    },
    vendor: "zod",
    version: 1
  };
});
const $ZodString = /* @__PURE__ */ $constructor("$ZodString", (inst, def) => {
  var _a3;
  $ZodType.init(inst, def);
  inst._zod.pattern = [...((_a3 = inst == null ? void 0 : inst._zod.bag) == null ? void 0 : _a3.patterns) ?? []].pop() ?? string$1(inst._zod.bag);
  inst._zod.parse = (payload, _) => {
    if (def.coerce)
      try {
        payload.value = String(payload.value);
      } catch (_2) {
      }
    if (typeof payload.value === "string")
      return payload;
    payload.issues.push({
      expected: "string",
      code: "invalid_type",
      input: payload.value,
      inst
    });
    return payload;
  };
});
const $ZodStringFormat = /* @__PURE__ */ $constructor("$ZodStringFormat", (inst, def) => {
  $ZodCheckStringFormat.init(inst, def);
  $ZodString.init(inst, def);
});
const $ZodGUID = /* @__PURE__ */ $constructor("$ZodGUID", (inst, def) => {
  def.pattern ?? (def.pattern = guid);
  $ZodStringFormat.init(inst, def);
});
const $ZodUUID = /* @__PURE__ */ $constructor("$ZodUUID", (inst, def) => {
  if (def.version) {
    const versionMap = {
      v1: 1,
      v2: 2,
      v3: 3,
      v4: 4,
      v5: 5,
      v6: 6,
      v7: 7,
      v8: 8
    };
    const v = versionMap[def.version];
    if (v === void 0)
      throw new Error(`Invalid UUID version: "${def.version}"`);
    def.pattern ?? (def.pattern = uuid(v));
  } else
    def.pattern ?? (def.pattern = uuid());
  $ZodStringFormat.init(inst, def);
});
const $ZodEmail = /* @__PURE__ */ $constructor("$ZodEmail", (inst, def) => {
  def.pattern ?? (def.pattern = email);
  $ZodStringFormat.init(inst, def);
});
const $ZodURL = /* @__PURE__ */ $constructor("$ZodURL", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    try {
      const trimmed = payload.value.trim();
      const url = new URL(trimmed);
      if (def.hostname) {
        def.hostname.lastIndex = 0;
        if (!def.hostname.test(url.hostname)) {
          payload.issues.push({
            code: "invalid_format",
            format: "url",
            note: "Invalid hostname",
            pattern: def.hostname.source,
            input: payload.value,
            inst,
            continue: !def.abort
          });
        }
      }
      if (def.protocol) {
        def.protocol.lastIndex = 0;
        if (!def.protocol.test(url.protocol.endsWith(":") ? url.protocol.slice(0, -1) : url.protocol)) {
          payload.issues.push({
            code: "invalid_format",
            format: "url",
            note: "Invalid protocol",
            pattern: def.protocol.source,
            input: payload.value,
            inst,
            continue: !def.abort
          });
        }
      }
      if (def.normalize) {
        payload.value = url.href;
      } else {
        payload.value = trimmed;
      }
      return;
    } catch (_) {
      payload.issues.push({
        code: "invalid_format",
        format: "url",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
const $ZodEmoji = /* @__PURE__ */ $constructor("$ZodEmoji", (inst, def) => {
  def.pattern ?? (def.pattern = emoji());
  $ZodStringFormat.init(inst, def);
});
const $ZodNanoID = /* @__PURE__ */ $constructor("$ZodNanoID", (inst, def) => {
  def.pattern ?? (def.pattern = nanoid);
  $ZodStringFormat.init(inst, def);
});
const $ZodCUID = /* @__PURE__ */ $constructor("$ZodCUID", (inst, def) => {
  def.pattern ?? (def.pattern = cuid);
  $ZodStringFormat.init(inst, def);
});
const $ZodCUID2 = /* @__PURE__ */ $constructor("$ZodCUID2", (inst, def) => {
  def.pattern ?? (def.pattern = cuid2);
  $ZodStringFormat.init(inst, def);
});
const $ZodULID = /* @__PURE__ */ $constructor("$ZodULID", (inst, def) => {
  def.pattern ?? (def.pattern = ulid);
  $ZodStringFormat.init(inst, def);
});
const $ZodXID = /* @__PURE__ */ $constructor("$ZodXID", (inst, def) => {
  def.pattern ?? (def.pattern = xid);
  $ZodStringFormat.init(inst, def);
});
const $ZodKSUID = /* @__PURE__ */ $constructor("$ZodKSUID", (inst, def) => {
  def.pattern ?? (def.pattern = ksuid);
  $ZodStringFormat.init(inst, def);
});
const $ZodISODateTime = /* @__PURE__ */ $constructor("$ZodISODateTime", (inst, def) => {
  def.pattern ?? (def.pattern = datetime$1(def));
  $ZodStringFormat.init(inst, def);
});
const $ZodISODate = /* @__PURE__ */ $constructor("$ZodISODate", (inst, def) => {
  def.pattern ?? (def.pattern = date$2);
  $ZodStringFormat.init(inst, def);
});
const $ZodISOTime = /* @__PURE__ */ $constructor("$ZodISOTime", (inst, def) => {
  def.pattern ?? (def.pattern = time$2(def));
  $ZodStringFormat.init(inst, def);
});
const $ZodISODuration = /* @__PURE__ */ $constructor("$ZodISODuration", (inst, def) => {
  def.pattern ?? (def.pattern = duration$1);
  $ZodStringFormat.init(inst, def);
});
const $ZodIPv4 = /* @__PURE__ */ $constructor("$ZodIPv4", (inst, def) => {
  def.pattern ?? (def.pattern = ipv4);
  $ZodStringFormat.init(inst, def);
  inst._zod.bag.format = `ipv4`;
});
const $ZodIPv6 = /* @__PURE__ */ $constructor("$ZodIPv6", (inst, def) => {
  def.pattern ?? (def.pattern = ipv6);
  $ZodStringFormat.init(inst, def);
  inst._zod.bag.format = `ipv6`;
  inst._zod.check = (payload) => {
    try {
      new URL(`http://[${payload.value}]`);
    } catch {
      payload.issues.push({
        code: "invalid_format",
        format: "ipv6",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
const $ZodCIDRv4 = /* @__PURE__ */ $constructor("$ZodCIDRv4", (inst, def) => {
  def.pattern ?? (def.pattern = cidrv4);
  $ZodStringFormat.init(inst, def);
});
const $ZodCIDRv6 = /* @__PURE__ */ $constructor("$ZodCIDRv6", (inst, def) => {
  def.pattern ?? (def.pattern = cidrv6);
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    const parts = payload.value.split("/");
    try {
      if (parts.length !== 2)
        throw new Error();
      const [address, prefix] = parts;
      if (!prefix)
        throw new Error();
      const prefixNum = Number(prefix);
      if (`${prefixNum}` !== prefix)
        throw new Error();
      if (prefixNum < 0 || prefixNum > 128)
        throw new Error();
      new URL(`http://[${address}]`);
    } catch {
      payload.issues.push({
        code: "invalid_format",
        format: "cidrv6",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
function isValidBase64(data) {
  if (data === "")
    return true;
  if (data.length % 4 !== 0)
    return false;
  try {
    atob(data);
    return true;
  } catch {
    return false;
  }
}
const $ZodBase64 = /* @__PURE__ */ $constructor("$ZodBase64", (inst, def) => {
  def.pattern ?? (def.pattern = base64);
  $ZodStringFormat.init(inst, def);
  inst._zod.bag.contentEncoding = "base64";
  inst._zod.check = (payload) => {
    if (isValidBase64(payload.value))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "base64",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
function isValidBase64URL(data) {
  if (!base64url.test(data))
    return false;
  const base642 = data.replace(/[-_]/g, (c) => c === "-" ? "+" : "/");
  const padded = base642.padEnd(Math.ceil(base642.length / 4) * 4, "=");
  return isValidBase64(padded);
}
const $ZodBase64URL = /* @__PURE__ */ $constructor("$ZodBase64URL", (inst, def) => {
  def.pattern ?? (def.pattern = base64url);
  $ZodStringFormat.init(inst, def);
  inst._zod.bag.contentEncoding = "base64url";
  inst._zod.check = (payload) => {
    if (isValidBase64URL(payload.value))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "base64url",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
const $ZodE164 = /* @__PURE__ */ $constructor("$ZodE164", (inst, def) => {
  def.pattern ?? (def.pattern = e164);
  $ZodStringFormat.init(inst, def);
});
function isValidJWT$1(token, algorithm = null) {
  try {
    const tokensParts = token.split(".");
    if (tokensParts.length !== 3)
      return false;
    const [header] = tokensParts;
    if (!header)
      return false;
    const parsedHeader = JSON.parse(atob(header));
    if ("typ" in parsedHeader && (parsedHeader == null ? void 0 : parsedHeader.typ) !== "JWT")
      return false;
    if (!parsedHeader.alg)
      return false;
    if (algorithm && (!("alg" in parsedHeader) || parsedHeader.alg !== algorithm))
      return false;
    return true;
  } catch {
    return false;
  }
}
const $ZodJWT = /* @__PURE__ */ $constructor("$ZodJWT", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    if (isValidJWT$1(payload.value, def.alg))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "jwt",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
const $ZodNumber = /* @__PURE__ */ $constructor("$ZodNumber", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = inst._zod.bag.pattern ?? number$1;
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = Number(payload.value);
      } catch (_) {
      }
    const input = payload.value;
    if (typeof input === "number" && !Number.isNaN(input) && Number.isFinite(input)) {
      return payload;
    }
    const received = typeof input === "number" ? Number.isNaN(input) ? "NaN" : !Number.isFinite(input) ? "Infinity" : void 0 : void 0;
    payload.issues.push({
      expected: "number",
      code: "invalid_type",
      input,
      inst,
      ...received ? { received } : {}
    });
    return payload;
  };
});
const $ZodNumberFormat = /* @__PURE__ */ $constructor("$ZodNumberFormat", (inst, def) => {
  $ZodCheckNumberFormat.init(inst, def);
  $ZodNumber.init(inst, def);
});
const $ZodBoolean = /* @__PURE__ */ $constructor("$ZodBoolean", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = boolean$1;
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = Boolean(payload.value);
      } catch (_) {
      }
    const input = payload.value;
    if (typeof input === "boolean")
      return payload;
    payload.issues.push({
      expected: "boolean",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
const $ZodAny = /* @__PURE__ */ $constructor("$ZodAny", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload) => payload;
});
const $ZodUnknown = /* @__PURE__ */ $constructor("$ZodUnknown", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload) => payload;
});
const $ZodNever = /* @__PURE__ */ $constructor("$ZodNever", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    payload.issues.push({
      expected: "never",
      code: "invalid_type",
      input: payload.value,
      inst
    });
    return payload;
  };
});
function handleArrayResult(result, final, index) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues(index, result.issues));
  }
  final.value[index] = result.value;
}
const $ZodArray = /* @__PURE__ */ $constructor("$ZodArray", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!Array.isArray(input)) {
      payload.issues.push({
        expected: "array",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    payload.value = Array(input.length);
    const proms = [];
    for (let i2 = 0; i2 < input.length; i2++) {
      const item = input[i2];
      const result = def.element._zod.run({
        value: item,
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        proms.push(result.then((result2) => handleArrayResult(result2, payload, i2)));
      } else {
        handleArrayResult(result, payload, i2);
      }
    }
    if (proms.length) {
      return Promise.all(proms).then(() => payload);
    }
    return payload;
  };
});
function handlePropertyResult(result, final, key, input) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues(key, result.issues));
  }
  if (result.value === void 0) {
    if (key in input) {
      final.value[key] = void 0;
    }
  } else {
    final.value[key] = result.value;
  }
}
function normalizeDef(def) {
  var _a3, _b, _c, _d;
  const keys = Object.keys(def.shape);
  for (const k of keys) {
    if (!((_d = (_c = (_b = (_a3 = def.shape) == null ? void 0 : _a3[k]) == null ? void 0 : _b._zod) == null ? void 0 : _c.traits) == null ? void 0 : _d.has("$ZodType"))) {
      throw new Error(`Invalid element at key "${k}": expected a Zod schema`);
    }
  }
  const okeys = optionalKeys(def.shape);
  return {
    ...def,
    keys,
    keySet: new Set(keys),
    numKeys: keys.length,
    optionalKeys: new Set(okeys)
  };
}
function handleCatchall(proms, input, payload, ctx, def, inst) {
  const unrecognized = [];
  const keySet = def.keySet;
  const _catchall = def.catchall._zod;
  const t2 = _catchall.def.type;
  for (const key in input) {
    if (keySet.has(key))
      continue;
    if (t2 === "never") {
      unrecognized.push(key);
      continue;
    }
    const r = _catchall.run({ value: input[key], issues: [] }, ctx);
    if (r instanceof Promise) {
      proms.push(r.then((r2) => handlePropertyResult(r2, payload, key, input)));
    } else {
      handlePropertyResult(r, payload, key, input);
    }
  }
  if (unrecognized.length) {
    payload.issues.push({
      code: "unrecognized_keys",
      keys: unrecognized,
      input,
      inst
    });
  }
  if (!proms.length)
    return payload;
  return Promise.all(proms).then(() => {
    return payload;
  });
}
const $ZodObject = /* @__PURE__ */ $constructor("$ZodObject", (inst, def) => {
  $ZodType.init(inst, def);
  const desc = Object.getOwnPropertyDescriptor(def, "shape");
  if (!(desc == null ? void 0 : desc.get)) {
    const sh = def.shape;
    Object.defineProperty(def, "shape", {
      get: () => {
        const newSh = { ...sh };
        Object.defineProperty(def, "shape", {
          value: newSh
        });
        return newSh;
      }
    });
  }
  const _normalized = cached(() => normalizeDef(def));
  defineLazy(inst._zod, "propValues", () => {
    const shape = def.shape;
    const propValues = {};
    for (const key in shape) {
      const field = shape[key]._zod;
      if (field.values) {
        propValues[key] ?? (propValues[key] = /* @__PURE__ */ new Set());
        for (const v of field.values)
          propValues[key].add(v);
      }
    }
    return propValues;
  });
  const isObject2 = isObject$1;
  const catchall = def.catchall;
  let value;
  inst._zod.parse = (payload, ctx) => {
    value ?? (value = _normalized.value);
    const input = payload.value;
    if (!isObject2(input)) {
      payload.issues.push({
        expected: "object",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    payload.value = {};
    const proms = [];
    const shape = value.shape;
    for (const key of value.keys) {
      const el = shape[key];
      const r = el._zod.run({ value: input[key], issues: [] }, ctx);
      if (r instanceof Promise) {
        proms.push(r.then((r2) => handlePropertyResult(r2, payload, key, input)));
      } else {
        handlePropertyResult(r, payload, key, input);
      }
    }
    if (!catchall) {
      return proms.length ? Promise.all(proms).then(() => payload) : payload;
    }
    return handleCatchall(proms, input, payload, ctx, _normalized.value, inst);
  };
});
const $ZodObjectJIT = /* @__PURE__ */ $constructor("$ZodObjectJIT", (inst, def) => {
  $ZodObject.init(inst, def);
  const superParse = inst._zod.parse;
  const _normalized = cached(() => normalizeDef(def));
  const generateFastpass = (shape) => {
    const doc = new Doc(["shape", "payload", "ctx"]);
    const normalized = _normalized.value;
    const parseStr = (key) => {
      const k = esc(key);
      return `shape[${k}]._zod.run({ value: input[${k}], issues: [] }, ctx)`;
    };
    doc.write(`const input = payload.value;`);
    const ids = /* @__PURE__ */ Object.create(null);
    let counter = 0;
    for (const key of normalized.keys) {
      ids[key] = `key_${counter++}`;
    }
    doc.write(`const newResult = {};`);
    for (const key of normalized.keys) {
      const id = ids[key];
      const k = esc(key);
      doc.write(`const ${id} = ${parseStr(key)};`);
      doc.write(`
        if (${id}.issues.length) {
          payload.issues = payload.issues.concat(${id}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${k}, ...iss.path] : [${k}]
          })));
        }
        
        
        if (${id}.value === undefined) {
          if (${k} in input) {
            newResult[${k}] = undefined;
          }
        } else {
          newResult[${k}] = ${id}.value;
        }
        
      `);
    }
    doc.write(`payload.value = newResult;`);
    doc.write(`return payload;`);
    const fn = doc.compile();
    return (payload, ctx) => fn(shape, payload, ctx);
  };
  let fastpass;
  const isObject2 = isObject$1;
  const jit = !globalConfig.jitless;
  const allowsEval$1 = allowsEval;
  const fastEnabled = jit && allowsEval$1.value;
  const catchall = def.catchall;
  let value;
  inst._zod.parse = (payload, ctx) => {
    value ?? (value = _normalized.value);
    const input = payload.value;
    if (!isObject2(input)) {
      payload.issues.push({
        expected: "object",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    if (jit && fastEnabled && (ctx == null ? void 0 : ctx.async) === false && ctx.jitless !== true) {
      if (!fastpass)
        fastpass = generateFastpass(def.shape);
      payload = fastpass(payload, ctx);
      if (!catchall)
        return payload;
      return handleCatchall([], input, payload, ctx, value, inst);
    }
    return superParse(payload, ctx);
  };
});
function handleUnionResults(results2, final, inst, ctx) {
  for (const result of results2) {
    if (result.issues.length === 0) {
      final.value = result.value;
      return final;
    }
  }
  const nonaborted = results2.filter((r) => !aborted(r));
  if (nonaborted.length === 1) {
    final.value = nonaborted[0].value;
    return nonaborted[0];
  }
  final.issues.push({
    code: "invalid_union",
    input: final.value,
    inst,
    errors: results2.map((result) => result.issues.map((iss) => finalizeIssue(iss, ctx, config$1())))
  });
  return final;
}
const $ZodUnion = /* @__PURE__ */ $constructor("$ZodUnion", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "optin", () => def.options.some((o) => o._zod.optin === "optional") ? "optional" : void 0);
  defineLazy(inst._zod, "optout", () => def.options.some((o) => o._zod.optout === "optional") ? "optional" : void 0);
  defineLazy(inst._zod, "values", () => {
    if (def.options.every((o) => o._zod.values)) {
      return new Set(def.options.flatMap((option) => Array.from(option._zod.values)));
    }
    return void 0;
  });
  defineLazy(inst._zod, "pattern", () => {
    if (def.options.every((o) => o._zod.pattern)) {
      const patterns = def.options.map((o) => o._zod.pattern);
      return new RegExp(`^(${patterns.map((p) => cleanRegex(p.source)).join("|")})$`);
    }
    return void 0;
  });
  const single = def.options.length === 1;
  const first = def.options[0]._zod.run;
  inst._zod.parse = (payload, ctx) => {
    if (single) {
      return first(payload, ctx);
    }
    let async = false;
    const results2 = [];
    for (const option of def.options) {
      const result = option._zod.run({
        value: payload.value,
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        results2.push(result);
        async = true;
      } else {
        if (result.issues.length === 0)
          return result;
        results2.push(result);
      }
    }
    if (!async)
      return handleUnionResults(results2, payload, inst, ctx);
    return Promise.all(results2).then((results3) => {
      return handleUnionResults(results3, payload, inst, ctx);
    });
  };
});
const $ZodIntersection = /* @__PURE__ */ $constructor("$ZodIntersection", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    const left = def.left._zod.run({ value: input, issues: [] }, ctx);
    const right = def.right._zod.run({ value: input, issues: [] }, ctx);
    const async = left instanceof Promise || right instanceof Promise;
    if (async) {
      return Promise.all([left, right]).then(([left2, right2]) => {
        return handleIntersectionResults(payload, left2, right2);
      });
    }
    return handleIntersectionResults(payload, left, right);
  };
});
function mergeValues$1(a, b) {
  if (a === b) {
    return { valid: true, data: a };
  }
  if (a instanceof Date && b instanceof Date && +a === +b) {
    return { valid: true, data: a };
  }
  if (isPlainObject(a) && isPlainObject(b)) {
    const bKeys = Object.keys(b);
    const sharedKeys = Object.keys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues$1(a[key], b[key]);
      if (!sharedValue.valid) {
        return {
          valid: false,
          mergeErrorPath: [key, ...sharedValue.mergeErrorPath]
        };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  }
  if (Array.isArray(a) && Array.isArray(b)) {
    if (a.length !== b.length) {
      return { valid: false, mergeErrorPath: [] };
    }
    const newArray = [];
    for (let index = 0; index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues$1(itemA, itemB);
      if (!sharedValue.valid) {
        return {
          valid: false,
          mergeErrorPath: [index, ...sharedValue.mergeErrorPath]
        };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  }
  return { valid: false, mergeErrorPath: [] };
}
function handleIntersectionResults(result, left, right) {
  if (left.issues.length) {
    result.issues.push(...left.issues);
  }
  if (right.issues.length) {
    result.issues.push(...right.issues);
  }
  if (aborted(result))
    return result;
  const merged = mergeValues$1(left.value, right.value);
  if (!merged.valid) {
    throw new Error(`Unmergable intersection. Error path: ${JSON.stringify(merged.mergeErrorPath)}`);
  }
  result.value = merged.data;
  return result;
}
const $ZodRecord = /* @__PURE__ */ $constructor("$ZodRecord", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!isPlainObject(input)) {
      payload.issues.push({
        expected: "record",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    const proms = [];
    const values = def.keyType._zod.values;
    if (values) {
      payload.value = {};
      const recordKeys = /* @__PURE__ */ new Set();
      for (const key of values) {
        if (typeof key === "string" || typeof key === "number" || typeof key === "symbol") {
          recordKeys.add(typeof key === "number" ? key.toString() : key);
          const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
          if (result instanceof Promise) {
            proms.push(result.then((result2) => {
              if (result2.issues.length) {
                payload.issues.push(...prefixIssues(key, result2.issues));
              }
              payload.value[key] = result2.value;
            }));
          } else {
            if (result.issues.length) {
              payload.issues.push(...prefixIssues(key, result.issues));
            }
            payload.value[key] = result.value;
          }
        }
      }
      let unrecognized;
      for (const key in input) {
        if (!recordKeys.has(key)) {
          unrecognized = unrecognized ?? [];
          unrecognized.push(key);
        }
      }
      if (unrecognized && unrecognized.length > 0) {
        payload.issues.push({
          code: "unrecognized_keys",
          input,
          inst,
          keys: unrecognized
        });
      }
    } else {
      payload.value = {};
      for (const key of Reflect.ownKeys(input)) {
        if (key === "__proto__")
          continue;
        const keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);
        if (keyResult instanceof Promise) {
          throw new Error("Async schemas not supported in object keys currently");
        }
        if (keyResult.issues.length) {
          payload.issues.push({
            code: "invalid_key",
            origin: "record",
            issues: keyResult.issues.map((iss) => finalizeIssue(iss, ctx, config$1())),
            input: key,
            path: [key],
            inst
          });
          payload.value[keyResult.value] = keyResult.value;
          continue;
        }
        const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
        if (result instanceof Promise) {
          proms.push(result.then((result2) => {
            if (result2.issues.length) {
              payload.issues.push(...prefixIssues(key, result2.issues));
            }
            payload.value[keyResult.value] = result2.value;
          }));
        } else {
          if (result.issues.length) {
            payload.issues.push(...prefixIssues(key, result.issues));
          }
          payload.value[keyResult.value] = result.value;
        }
      }
    }
    if (proms.length) {
      return Promise.all(proms).then(() => payload);
    }
    return payload;
  };
});
const $ZodEnum = /* @__PURE__ */ $constructor("$ZodEnum", (inst, def) => {
  $ZodType.init(inst, def);
  const values = getEnumValues(def.entries);
  const valuesSet = new Set(values);
  inst._zod.values = valuesSet;
  inst._zod.pattern = new RegExp(`^(${values.filter((k) => propertyKeyTypes.has(typeof k)).map((o) => typeof o === "string" ? escapeRegex$1(o) : o.toString()).join("|")})$`);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (valuesSet.has(input)) {
      return payload;
    }
    payload.issues.push({
      code: "invalid_value",
      values,
      input,
      inst
    });
    return payload;
  };
});
const $ZodTransform = /* @__PURE__ */ $constructor("$ZodTransform", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      throw new $ZodEncodeError(inst.constructor.name);
    }
    const _out = def.transform(payload.value, payload);
    if (ctx.async) {
      const output = _out instanceof Promise ? _out : Promise.resolve(_out);
      return output.then((output2) => {
        payload.value = output2;
        return payload;
      });
    }
    if (_out instanceof Promise) {
      throw new $ZodAsyncError();
    }
    payload.value = _out;
    return payload;
  };
});
function handleOptionalResult(result, input) {
  if (result.issues.length && input === void 0) {
    return { issues: [], value: void 0 };
  }
  return result;
}
const $ZodOptional = /* @__PURE__ */ $constructor("$ZodOptional", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  inst._zod.optout = "optional";
  defineLazy(inst._zod, "values", () => {
    return def.innerType._zod.values ? /* @__PURE__ */ new Set([...def.innerType._zod.values, void 0]) : void 0;
  });
  defineLazy(inst._zod, "pattern", () => {
    const pattern = def.innerType._zod.pattern;
    return pattern ? new RegExp(`^(${cleanRegex(pattern.source)})?$`) : void 0;
  });
  inst._zod.parse = (payload, ctx) => {
    if (def.innerType._zod.optin === "optional") {
      const result = def.innerType._zod.run(payload, ctx);
      if (result instanceof Promise)
        return result.then((r) => handleOptionalResult(r, payload.value));
      return handleOptionalResult(result, payload.value);
    }
    if (payload.value === void 0) {
      return payload;
    }
    return def.innerType._zod.run(payload, ctx);
  };
});
const $ZodNullable = /* @__PURE__ */ $constructor("$ZodNullable", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
  defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
  defineLazy(inst._zod, "pattern", () => {
    const pattern = def.innerType._zod.pattern;
    return pattern ? new RegExp(`^(${cleanRegex(pattern.source)}|null)$`) : void 0;
  });
  defineLazy(inst._zod, "values", () => {
    return def.innerType._zod.values ? /* @__PURE__ */ new Set([...def.innerType._zod.values, null]) : void 0;
  });
  inst._zod.parse = (payload, ctx) => {
    if (payload.value === null)
      return payload;
    return def.innerType._zod.run(payload, ctx);
  };
});
const $ZodDefault = /* @__PURE__ */ $constructor("$ZodDefault", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      return def.innerType._zod.run(payload, ctx);
    }
    if (payload.value === void 0) {
      payload.value = def.defaultValue;
      return payload;
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => handleDefaultResult(result2, def));
    }
    return handleDefaultResult(result, def);
  };
});
function handleDefaultResult(payload, def) {
  if (payload.value === void 0) {
    payload.value = def.defaultValue;
  }
  return payload;
}
const $ZodPrefault = /* @__PURE__ */ $constructor("$ZodPrefault", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      return def.innerType._zod.run(payload, ctx);
    }
    if (payload.value === void 0) {
      payload.value = def.defaultValue;
    }
    return def.innerType._zod.run(payload, ctx);
  };
});
const $ZodNonOptional = /* @__PURE__ */ $constructor("$ZodNonOptional", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "values", () => {
    const v = def.innerType._zod.values;
    return v ? new Set([...v].filter((x) => x !== void 0)) : void 0;
  });
  inst._zod.parse = (payload, ctx) => {
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => handleNonOptionalResult(result2, inst));
    }
    return handleNonOptionalResult(result, inst);
  };
});
function handleNonOptionalResult(payload, inst) {
  if (!payload.issues.length && payload.value === void 0) {
    payload.issues.push({
      code: "invalid_type",
      expected: "nonoptional",
      input: payload.value,
      inst
    });
  }
  return payload;
}
const $ZodCatch = /* @__PURE__ */ $constructor("$ZodCatch", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
  defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      return def.innerType._zod.run(payload, ctx);
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => {
        payload.value = result2.value;
        if (result2.issues.length) {
          payload.value = def.catchValue({
            ...payload,
            error: {
              issues: result2.issues.map((iss) => finalizeIssue(iss, ctx, config$1()))
            },
            input: payload.value
          });
          payload.issues = [];
        }
        return payload;
      });
    }
    payload.value = result.value;
    if (result.issues.length) {
      payload.value = def.catchValue({
        ...payload,
        error: {
          issues: result.issues.map((iss) => finalizeIssue(iss, ctx, config$1()))
        },
        input: payload.value
      });
      payload.issues = [];
    }
    return payload;
  };
});
const $ZodPipe = /* @__PURE__ */ $constructor("$ZodPipe", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "values", () => def.in._zod.values);
  defineLazy(inst._zod, "optin", () => def.in._zod.optin);
  defineLazy(inst._zod, "optout", () => def.out._zod.optout);
  defineLazy(inst._zod, "propValues", () => def.in._zod.propValues);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      const right = def.out._zod.run(payload, ctx);
      if (right instanceof Promise) {
        return right.then((right2) => handlePipeResult(right2, def.in, ctx));
      }
      return handlePipeResult(right, def.in, ctx);
    }
    const left = def.in._zod.run(payload, ctx);
    if (left instanceof Promise) {
      return left.then((left2) => handlePipeResult(left2, def.out, ctx));
    }
    return handlePipeResult(left, def.out, ctx);
  };
});
function handlePipeResult(left, next, ctx) {
  if (left.issues.length) {
    left.aborted = true;
    return left;
  }
  return next._zod.run({ value: left.value, issues: left.issues }, ctx);
}
const $ZodReadonly = /* @__PURE__ */ $constructor("$ZodReadonly", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "propValues", () => def.innerType._zod.propValues);
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  defineLazy(inst._zod, "optin", () => {
    var _a3, _b;
    return (_b = (_a3 = def.innerType) == null ? void 0 : _a3._zod) == null ? void 0 : _b.optin;
  });
  defineLazy(inst._zod, "optout", () => {
    var _a3, _b;
    return (_b = (_a3 = def.innerType) == null ? void 0 : _a3._zod) == null ? void 0 : _b.optout;
  });
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      return def.innerType._zod.run(payload, ctx);
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then(handleReadonlyResult);
    }
    return handleReadonlyResult(result);
  };
});
function handleReadonlyResult(payload) {
  payload.value = Object.freeze(payload.value);
  return payload;
}
const $ZodCustom = /* @__PURE__ */ $constructor("$ZodCustom", (inst, def) => {
  $ZodCheck.init(inst, def);
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _) => {
    return payload;
  };
  inst._zod.check = (payload) => {
    const input = payload.value;
    const r = def.fn(input);
    if (r instanceof Promise) {
      return r.then((r2) => handleRefineResult(r2, payload, input, inst));
    }
    handleRefineResult(r, payload, input, inst);
    return;
  };
});
function handleRefineResult(result, payload, input, inst) {
  if (!result) {
    const _iss = {
      code: "custom",
      input,
      inst,
      // incorporates params.error into issue reporting
      path: [...inst._zod.def.path ?? []],
      // incorporates params.error into issue reporting
      continue: !inst._zod.def.abort
      // params: inst._zod.def.params,
    };
    if (inst._zod.def.params)
      _iss.params = inst._zod.def.params;
    payload.issues.push(issue(_iss));
  }
}
var _a;
class $ZodRegistry {
  constructor() {
    this._map = /* @__PURE__ */ new WeakMap();
    this._idmap = /* @__PURE__ */ new Map();
  }
  add(schema, ..._meta) {
    const meta = _meta[0];
    this._map.set(schema, meta);
    if (meta && typeof meta === "object" && "id" in meta) {
      if (this._idmap.has(meta.id)) {
        throw new Error(`ID ${meta.id} already exists in the registry`);
      }
      this._idmap.set(meta.id, schema);
    }
    return this;
  }
  clear() {
    this._map = /* @__PURE__ */ new WeakMap();
    this._idmap = /* @__PURE__ */ new Map();
    return this;
  }
  remove(schema) {
    const meta = this._map.get(schema);
    if (meta && typeof meta === "object" && "id" in meta) {
      this._idmap.delete(meta.id);
    }
    this._map.delete(schema);
    return this;
  }
  get(schema) {
    const p = schema._zod.parent;
    if (p) {
      const pm = { ...this.get(p) ?? {} };
      delete pm.id;
      const f = { ...pm, ...this._map.get(schema) };
      return Object.keys(f).length ? f : void 0;
    }
    return this._map.get(schema);
  }
  has(schema) {
    return this._map.has(schema);
  }
}
function registry() {
  return new $ZodRegistry();
}
(_a = globalThis).__zod_globalRegistry ?? (_a.__zod_globalRegistry = registry());
const globalRegistry = globalThis.__zod_globalRegistry;
function _string(Class, params) {
  return new Class({
    type: "string",
    ...normalizeParams(params)
  });
}
function _email(Class, params) {
  return new Class({
    type: "string",
    format: "email",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _guid(Class, params) {
  return new Class({
    type: "string",
    format: "guid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _uuid(Class, params) {
  return new Class({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _uuidv4(Class, params) {
  return new Class({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v4",
    ...normalizeParams(params)
  });
}
function _uuidv6(Class, params) {
  return new Class({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v6",
    ...normalizeParams(params)
  });
}
function _uuidv7(Class, params) {
  return new Class({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v7",
    ...normalizeParams(params)
  });
}
function _url(Class, params) {
  return new Class({
    type: "string",
    format: "url",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _emoji(Class, params) {
  return new Class({
    type: "string",
    format: "emoji",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _nanoid(Class, params) {
  return new Class({
    type: "string",
    format: "nanoid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cuid(Class, params) {
  return new Class({
    type: "string",
    format: "cuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cuid2(Class, params) {
  return new Class({
    type: "string",
    format: "cuid2",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ulid(Class, params) {
  return new Class({
    type: "string",
    format: "ulid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _xid(Class, params) {
  return new Class({
    type: "string",
    format: "xid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ksuid(Class, params) {
  return new Class({
    type: "string",
    format: "ksuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ipv4(Class, params) {
  return new Class({
    type: "string",
    format: "ipv4",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ipv6(Class, params) {
  return new Class({
    type: "string",
    format: "ipv6",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cidrv4(Class, params) {
  return new Class({
    type: "string",
    format: "cidrv4",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cidrv6(Class, params) {
  return new Class({
    type: "string",
    format: "cidrv6",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _base64(Class, params) {
  return new Class({
    type: "string",
    format: "base64",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _base64url(Class, params) {
  return new Class({
    type: "string",
    format: "base64url",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _e164(Class, params) {
  return new Class({
    type: "string",
    format: "e164",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _jwt(Class, params) {
  return new Class({
    type: "string",
    format: "jwt",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _isoDateTime(Class, params) {
  return new Class({
    type: "string",
    format: "datetime",
    check: "string_format",
    offset: false,
    local: false,
    precision: null,
    ...normalizeParams(params)
  });
}
function _isoDate(Class, params) {
  return new Class({
    type: "string",
    format: "date",
    check: "string_format",
    ...normalizeParams(params)
  });
}
function _isoTime(Class, params) {
  return new Class({
    type: "string",
    format: "time",
    check: "string_format",
    precision: null,
    ...normalizeParams(params)
  });
}
function _isoDuration(Class, params) {
  return new Class({
    type: "string",
    format: "duration",
    check: "string_format",
    ...normalizeParams(params)
  });
}
function _number(Class, params) {
  return new Class({
    type: "number",
    checks: [],
    ...normalizeParams(params)
  });
}
function _int(Class, params) {
  return new Class({
    type: "number",
    check: "number_format",
    abort: false,
    format: "safeint",
    ...normalizeParams(params)
  });
}
function _boolean(Class, params) {
  return new Class({
    type: "boolean",
    ...normalizeParams(params)
  });
}
function _any(Class) {
  return new Class({
    type: "any"
  });
}
function _unknown(Class) {
  return new Class({
    type: "unknown"
  });
}
function _never(Class, params) {
  return new Class({
    type: "never",
    ...normalizeParams(params)
  });
}
function _lt(value, params) {
  return new $ZodCheckLessThan({
    check: "less_than",
    ...normalizeParams(params),
    value,
    inclusive: false
  });
}
function _lte(value, params) {
  return new $ZodCheckLessThan({
    check: "less_than",
    ...normalizeParams(params),
    value,
    inclusive: true
  });
}
function _gt(value, params) {
  return new $ZodCheckGreaterThan({
    check: "greater_than",
    ...normalizeParams(params),
    value,
    inclusive: false
  });
}
function _gte(value, params) {
  return new $ZodCheckGreaterThan({
    check: "greater_than",
    ...normalizeParams(params),
    value,
    inclusive: true
  });
}
function _multipleOf(value, params) {
  return new $ZodCheckMultipleOf({
    check: "multiple_of",
    ...normalizeParams(params),
    value
  });
}
function _maxLength(maximum, params) {
  const ch = new $ZodCheckMaxLength({
    check: "max_length",
    ...normalizeParams(params),
    maximum
  });
  return ch;
}
function _minLength(minimum, params) {
  return new $ZodCheckMinLength({
    check: "min_length",
    ...normalizeParams(params),
    minimum
  });
}
function _length(length, params) {
  return new $ZodCheckLengthEquals({
    check: "length_equals",
    ...normalizeParams(params),
    length
  });
}
function _regex(pattern, params) {
  return new $ZodCheckRegex({
    check: "string_format",
    format: "regex",
    ...normalizeParams(params),
    pattern
  });
}
function _lowercase(params) {
  return new $ZodCheckLowerCase({
    check: "string_format",
    format: "lowercase",
    ...normalizeParams(params)
  });
}
function _uppercase(params) {
  return new $ZodCheckUpperCase({
    check: "string_format",
    format: "uppercase",
    ...normalizeParams(params)
  });
}
function _includes(includes, params) {
  return new $ZodCheckIncludes({
    check: "string_format",
    format: "includes",
    ...normalizeParams(params),
    includes
  });
}
function _startsWith(prefix, params) {
  return new $ZodCheckStartsWith({
    check: "string_format",
    format: "starts_with",
    ...normalizeParams(params),
    prefix
  });
}
function _endsWith(suffix, params) {
  return new $ZodCheckEndsWith({
    check: "string_format",
    format: "ends_with",
    ...normalizeParams(params),
    suffix
  });
}
function _overwrite(tx) {
  return new $ZodCheckOverwrite({
    check: "overwrite",
    tx
  });
}
function _normalize(form) {
  return _overwrite((input) => input.normalize(form));
}
function _trim() {
  return _overwrite((input) => input.trim());
}
function _toLowerCase() {
  return _overwrite((input) => input.toLowerCase());
}
function _toUpperCase() {
  return _overwrite((input) => input.toUpperCase());
}
function _slugify() {
  return _overwrite((input) => slugify(input));
}
function _array(Class, element, params) {
  return new Class({
    type: "array",
    element,
    // get element() {
    //   return element;
    // },
    ...normalizeParams(params)
  });
}
function _refine(Class, fn, _params) {
  const schema = new Class({
    type: "custom",
    check: "custom",
    fn,
    ...normalizeParams(_params)
  });
  return schema;
}
function _superRefine(fn) {
  const ch = _check((payload) => {
    payload.addIssue = (issue$1) => {
      if (typeof issue$1 === "string") {
        payload.issues.push(issue(issue$1, payload.value, ch._zod.def));
      } else {
        const _issue = issue$1;
        if (_issue.fatal)
          _issue.continue = false;
        _issue.code ?? (_issue.code = "custom");
        _issue.input ?? (_issue.input = payload.value);
        _issue.inst ?? (_issue.inst = ch);
        _issue.continue ?? (_issue.continue = !ch._zod.def.abort);
        payload.issues.push(issue(_issue));
      }
    };
    return fn(payload.value, payload);
  });
  return ch;
}
function _check(fn, params) {
  const ch = new $ZodCheck({
    check: "custom",
    ...normalizeParams(params)
  });
  ch._zod.check = fn;
  return ch;
}
class JSONSchemaGenerator {
  constructor(params) {
    this.counter = 0;
    this.metadataRegistry = (params == null ? void 0 : params.metadata) ?? globalRegistry;
    this.target = (params == null ? void 0 : params.target) ?? "draft-2020-12";
    this.unrepresentable = (params == null ? void 0 : params.unrepresentable) ?? "throw";
    this.override = (params == null ? void 0 : params.override) ?? (() => {
    });
    this.io = (params == null ? void 0 : params.io) ?? "output";
    this.seen = /* @__PURE__ */ new Map();
  }
  process(schema, _params = { path: [], schemaPath: [] }) {
    var _a4, _b, _c;
    var _a3;
    const def = schema._zod.def;
    const formatMap = {
      guid: "uuid",
      url: "uri",
      datetime: "date-time",
      json_string: "json-string",
      regex: ""
      // do not set
    };
    const seen = this.seen.get(schema);
    if (seen) {
      seen.count++;
      const isCycle = _params.schemaPath.includes(schema);
      if (isCycle) {
        seen.cycle = _params.path;
      }
      return seen.schema;
    }
    const result = { schema: {}, count: 1, cycle: void 0, path: _params.path };
    this.seen.set(schema, result);
    const overrideSchema = (_b = (_a4 = schema._zod).toJSONSchema) == null ? void 0 : _b.call(_a4);
    if (overrideSchema) {
      result.schema = overrideSchema;
    } else {
      const params = {
        ..._params,
        schemaPath: [..._params.schemaPath, schema],
        path: _params.path
      };
      const parent = schema._zod.parent;
      if (parent) {
        result.ref = parent;
        this.process(parent, params);
        this.seen.get(parent).isParent = true;
      } else {
        const _json = result.schema;
        switch (def.type) {
          case "string": {
            const json = _json;
            json.type = "string";
            const { minimum, maximum, format: format2, patterns, contentEncoding } = schema._zod.bag;
            if (typeof minimum === "number")
              json.minLength = minimum;
            if (typeof maximum === "number")
              json.maxLength = maximum;
            if (format2) {
              json.format = formatMap[format2] ?? format2;
              if (json.format === "")
                delete json.format;
            }
            if (contentEncoding)
              json.contentEncoding = contentEncoding;
            if (patterns && patterns.size > 0) {
              const regexes = [...patterns];
              if (regexes.length === 1)
                json.pattern = regexes[0].source;
              else if (regexes.length > 1) {
                result.schema.allOf = [
                  ...regexes.map((regex2) => ({
                    ...this.target === "draft-7" || this.target === "draft-4" || this.target === "openapi-3.0" ? { type: "string" } : {},
                    pattern: regex2.source
                  }))
                ];
              }
            }
            break;
          }
          case "number": {
            const json = _json;
            const { minimum, maximum, format: format2, multipleOf, exclusiveMaximum, exclusiveMinimum } = schema._zod.bag;
            if (typeof format2 === "string" && format2.includes("int"))
              json.type = "integer";
            else
              json.type = "number";
            if (typeof exclusiveMinimum === "number") {
              if (this.target === "draft-4" || this.target === "openapi-3.0") {
                json.minimum = exclusiveMinimum;
                json.exclusiveMinimum = true;
              } else {
                json.exclusiveMinimum = exclusiveMinimum;
              }
            }
            if (typeof minimum === "number") {
              json.minimum = minimum;
              if (typeof exclusiveMinimum === "number" && this.target !== "draft-4") {
                if (exclusiveMinimum >= minimum)
                  delete json.minimum;
                else
                  delete json.exclusiveMinimum;
              }
            }
            if (typeof exclusiveMaximum === "number") {
              if (this.target === "draft-4" || this.target === "openapi-3.0") {
                json.maximum = exclusiveMaximum;
                json.exclusiveMaximum = true;
              } else {
                json.exclusiveMaximum = exclusiveMaximum;
              }
            }
            if (typeof maximum === "number") {
              json.maximum = maximum;
              if (typeof exclusiveMaximum === "number" && this.target !== "draft-4") {
                if (exclusiveMaximum <= maximum)
                  delete json.maximum;
                else
                  delete json.exclusiveMaximum;
              }
            }
            if (typeof multipleOf === "number")
              json.multipleOf = multipleOf;
            break;
          }
          case "boolean": {
            const json = _json;
            json.type = "boolean";
            break;
          }
          case "bigint": {
            if (this.unrepresentable === "throw") {
              throw new Error("BigInt cannot be represented in JSON Schema");
            }
            break;
          }
          case "symbol": {
            if (this.unrepresentable === "throw") {
              throw new Error("Symbols cannot be represented in JSON Schema");
            }
            break;
          }
          case "null": {
            if (this.target === "openapi-3.0") {
              _json.type = "string";
              _json.nullable = true;
              _json.enum = [null];
            } else
              _json.type = "null";
            break;
          }
          case "any": {
            break;
          }
          case "unknown": {
            break;
          }
          case "undefined": {
            if (this.unrepresentable === "throw") {
              throw new Error("Undefined cannot be represented in JSON Schema");
            }
            break;
          }
          case "void": {
            if (this.unrepresentable === "throw") {
              throw new Error("Void cannot be represented in JSON Schema");
            }
            break;
          }
          case "never": {
            _json.not = {};
            break;
          }
          case "date": {
            if (this.unrepresentable === "throw") {
              throw new Error("Date cannot be represented in JSON Schema");
            }
            break;
          }
          case "array": {
            const json = _json;
            const { minimum, maximum } = schema._zod.bag;
            if (typeof minimum === "number")
              json.minItems = minimum;
            if (typeof maximum === "number")
              json.maxItems = maximum;
            json.type = "array";
            json.items = this.process(def.element, { ...params, path: [...params.path, "items"] });
            break;
          }
          case "object": {
            const json = _json;
            json.type = "object";
            json.properties = {};
            const shape = def.shape;
            for (const key in shape) {
              json.properties[key] = this.process(shape[key], {
                ...params,
                path: [...params.path, "properties", key]
              });
            }
            const allKeys = new Set(Object.keys(shape));
            const requiredKeys = new Set([...allKeys].filter((key) => {
              const v = def.shape[key]._zod;
              if (this.io === "input") {
                return v.optin === void 0;
              } else {
                return v.optout === void 0;
              }
            }));
            if (requiredKeys.size > 0) {
              json.required = Array.from(requiredKeys);
            }
            if (((_c = def.catchall) == null ? void 0 : _c._zod.def.type) === "never") {
              json.additionalProperties = false;
            } else if (!def.catchall) {
              if (this.io === "output")
                json.additionalProperties = false;
            } else if (def.catchall) {
              json.additionalProperties = this.process(def.catchall, {
                ...params,
                path: [...params.path, "additionalProperties"]
              });
            }
            break;
          }
          case "union": {
            const json = _json;
            const isDiscriminated = def.discriminator !== void 0;
            const options2 = def.options.map((x, i2) => this.process(x, {
              ...params,
              path: [...params.path, isDiscriminated ? "oneOf" : "anyOf", i2]
            }));
            if (isDiscriminated) {
              json.oneOf = options2;
            } else {
              json.anyOf = options2;
            }
            break;
          }
          case "intersection": {
            const json = _json;
            const a = this.process(def.left, {
              ...params,
              path: [...params.path, "allOf", 0]
            });
            const b = this.process(def.right, {
              ...params,
              path: [...params.path, "allOf", 1]
            });
            const isSimpleIntersection = (val) => "allOf" in val && Object.keys(val).length === 1;
            const allOf = [
              ...isSimpleIntersection(a) ? a.allOf : [a],
              ...isSimpleIntersection(b) ? b.allOf : [b]
            ];
            json.allOf = allOf;
            break;
          }
          case "tuple": {
            const json = _json;
            json.type = "array";
            const prefixPath = this.target === "draft-2020-12" ? "prefixItems" : "items";
            const restPath = this.target === "draft-2020-12" ? "items" : this.target === "openapi-3.0" ? "items" : "additionalItems";
            const prefixItems = def.items.map((x, i2) => this.process(x, {
              ...params,
              path: [...params.path, prefixPath, i2]
            }));
            const rest = def.rest ? this.process(def.rest, {
              ...params,
              path: [...params.path, restPath, ...this.target === "openapi-3.0" ? [def.items.length] : []]
            }) : null;
            if (this.target === "draft-2020-12") {
              json.prefixItems = prefixItems;
              if (rest) {
                json.items = rest;
              }
            } else if (this.target === "openapi-3.0") {
              json.items = {
                anyOf: prefixItems
              };
              if (rest) {
                json.items.anyOf.push(rest);
              }
              json.minItems = prefixItems.length;
              if (!rest) {
                json.maxItems = prefixItems.length;
              }
            } else {
              json.items = prefixItems;
              if (rest) {
                json.additionalItems = rest;
              }
            }
            const { minimum, maximum } = schema._zod.bag;
            if (typeof minimum === "number")
              json.minItems = minimum;
            if (typeof maximum === "number")
              json.maxItems = maximum;
            break;
          }
          case "record": {
            const json = _json;
            json.type = "object";
            if (this.target === "draft-7" || this.target === "draft-2020-12") {
              json.propertyNames = this.process(def.keyType, {
                ...params,
                path: [...params.path, "propertyNames"]
              });
            }
            json.additionalProperties = this.process(def.valueType, {
              ...params,
              path: [...params.path, "additionalProperties"]
            });
            break;
          }
          case "map": {
            if (this.unrepresentable === "throw") {
              throw new Error("Map cannot be represented in JSON Schema");
            }
            break;
          }
          case "set": {
            if (this.unrepresentable === "throw") {
              throw new Error("Set cannot be represented in JSON Schema");
            }
            break;
          }
          case "enum": {
            const json = _json;
            const values = getEnumValues(def.entries);
            if (values.every((v) => typeof v === "number"))
              json.type = "number";
            if (values.every((v) => typeof v === "string"))
              json.type = "string";
            json.enum = values;
            break;
          }
          case "literal": {
            const json = _json;
            const vals = [];
            for (const val of def.values) {
              if (val === void 0) {
                if (this.unrepresentable === "throw") {
                  throw new Error("Literal `undefined` cannot be represented in JSON Schema");
                }
              } else if (typeof val === "bigint") {
                if (this.unrepresentable === "throw") {
                  throw new Error("BigInt literals cannot be represented in JSON Schema");
                } else {
                  vals.push(Number(val));
                }
              } else {
                vals.push(val);
              }
            }
            if (vals.length === 0) ;
            else if (vals.length === 1) {
              const val = vals[0];
              json.type = val === null ? "null" : typeof val;
              if (this.target === "draft-4" || this.target === "openapi-3.0") {
                json.enum = [val];
              } else {
                json.const = val;
              }
            } else {
              if (vals.every((v) => typeof v === "number"))
                json.type = "number";
              if (vals.every((v) => typeof v === "string"))
                json.type = "string";
              if (vals.every((v) => typeof v === "boolean"))
                json.type = "string";
              if (vals.every((v) => v === null))
                json.type = "null";
              json.enum = vals;
            }
            break;
          }
          case "file": {
            const json = _json;
            const file = {
              type: "string",
              format: "binary",
              contentEncoding: "binary"
            };
            const { minimum, maximum, mime } = schema._zod.bag;
            if (minimum !== void 0)
              file.minLength = minimum;
            if (maximum !== void 0)
              file.maxLength = maximum;
            if (mime) {
              if (mime.length === 1) {
                file.contentMediaType = mime[0];
                Object.assign(json, file);
              } else {
                json.anyOf = mime.map((m) => {
                  const mFile = { ...file, contentMediaType: m };
                  return mFile;
                });
              }
            } else {
              Object.assign(json, file);
            }
            break;
          }
          case "transform": {
            if (this.unrepresentable === "throw") {
              throw new Error("Transforms cannot be represented in JSON Schema");
            }
            break;
          }
          case "nullable": {
            const inner = this.process(def.innerType, params);
            if (this.target === "openapi-3.0") {
              result.ref = def.innerType;
              _json.nullable = true;
            } else {
              _json.anyOf = [inner, { type: "null" }];
            }
            break;
          }
          case "nonoptional": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            break;
          }
          case "success": {
            const json = _json;
            json.type = "boolean";
            break;
          }
          case "default": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            _json.default = JSON.parse(JSON.stringify(def.defaultValue));
            break;
          }
          case "prefault": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            if (this.io === "input")
              _json._prefault = JSON.parse(JSON.stringify(def.defaultValue));
            break;
          }
          case "catch": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            let catchValue;
            try {
              catchValue = def.catchValue(void 0);
            } catch {
              throw new Error("Dynamic catch values are not supported in JSON Schema");
            }
            _json.default = catchValue;
            break;
          }
          case "nan": {
            if (this.unrepresentable === "throw") {
              throw new Error("NaN cannot be represented in JSON Schema");
            }
            break;
          }
          case "template_literal": {
            const json = _json;
            const pattern = schema._zod.pattern;
            if (!pattern)
              throw new Error("Pattern not found in template literal");
            json.type = "string";
            json.pattern = pattern.source;
            break;
          }
          case "pipe": {
            const innerType = this.io === "input" ? def.in._zod.def.type === "transform" ? def.out : def.in : def.out;
            this.process(innerType, params);
            result.ref = innerType;
            break;
          }
          case "readonly": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            _json.readOnly = true;
            break;
          }
          case "promise": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            break;
          }
          case "optional": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            break;
          }
          case "lazy": {
            const innerType = schema._zod.innerType;
            this.process(innerType, params);
            result.ref = innerType;
            break;
          }
          case "custom": {
            if (this.unrepresentable === "throw") {
              throw new Error("Custom types cannot be represented in JSON Schema");
            }
            break;
          }
          case "function": {
            if (this.unrepresentable === "throw") {
              throw new Error("Function types cannot be represented in JSON Schema");
            }
            break;
          }
        }
      }
    }
    const meta = this.metadataRegistry.get(schema);
    if (meta)
      Object.assign(result.schema, meta);
    if (this.io === "input" && isTransforming(schema)) {
      delete result.schema.examples;
      delete result.schema.default;
    }
    if (this.io === "input" && result.schema._prefault)
      (_a3 = result.schema).default ?? (_a3.default = result.schema._prefault);
    delete result.schema._prefault;
    const _result = this.seen.get(schema);
    return _result.schema;
  }
  emit(schema, _params) {
    var _a3, _b, _c, _d, _e, _f;
    const params = {
      cycles: (_params == null ? void 0 : _params.cycles) ?? "ref",
      reused: (_params == null ? void 0 : _params.reused) ?? "inline",
      // unrepresentable: _params?.unrepresentable ?? "throw",
      // uri: _params?.uri ?? ((id) => `${id}`),
      external: (_params == null ? void 0 : _params.external) ?? void 0
    };
    const root = this.seen.get(schema);
    if (!root)
      throw new Error("Unprocessed schema. This is a bug in Zod.");
    const makeURI = (entry) => {
      var _a4;
      const defsSegment = this.target === "draft-2020-12" ? "$defs" : "definitions";
      if (params.external) {
        const externalId = (_a4 = params.external.registry.get(entry[0])) == null ? void 0 : _a4.id;
        const uriGenerator = params.external.uri ?? ((id2) => id2);
        if (externalId) {
          return { ref: uriGenerator(externalId) };
        }
        const id = entry[1].defId ?? entry[1].schema.id ?? `schema${this.counter++}`;
        entry[1].defId = id;
        return { defId: id, ref: `${uriGenerator("__shared")}#/${defsSegment}/${id}` };
      }
      if (entry[1] === root) {
        return { ref: "#" };
      }
      const uriPrefix = `#`;
      const defUriPrefix = `${uriPrefix}/${defsSegment}/`;
      const defId = entry[1].schema.id ?? `__schema${this.counter++}`;
      return { defId, ref: defUriPrefix + defId };
    };
    const extractToDef = (entry) => {
      if (entry[1].schema.$ref) {
        return;
      }
      const seen = entry[1];
      const { ref, defId } = makeURI(entry);
      seen.def = { ...seen.schema };
      if (defId)
        seen.defId = defId;
      const schema2 = seen.schema;
      for (const key in schema2) {
        delete schema2[key];
      }
      schema2.$ref = ref;
    };
    if (params.cycles === "throw") {
      for (const entry of this.seen.entries()) {
        const seen = entry[1];
        if (seen.cycle) {
          throw new Error(`Cycle detected: #/${(_a3 = seen.cycle) == null ? void 0 : _a3.join("/")}/<root>

Set the \`cycles\` parameter to \`"ref"\` to resolve cyclical schemas with defs.`);
        }
      }
    }
    for (const entry of this.seen.entries()) {
      const seen = entry[1];
      if (schema === entry[0]) {
        extractToDef(entry);
        continue;
      }
      if (params.external) {
        const ext = (_b = params.external.registry.get(entry[0])) == null ? void 0 : _b.id;
        if (schema !== entry[0] && ext) {
          extractToDef(entry);
          continue;
        }
      }
      const id = (_c = this.metadataRegistry.get(entry[0])) == null ? void 0 : _c.id;
      if (id) {
        extractToDef(entry);
        continue;
      }
      if (seen.cycle) {
        extractToDef(entry);
        continue;
      }
      if (seen.count > 1) {
        if (params.reused === "ref") {
          extractToDef(entry);
          continue;
        }
      }
    }
    const flattenRef = (zodSchema, params2) => {
      const seen = this.seen.get(zodSchema);
      const schema2 = seen.def ?? seen.schema;
      const _cached = { ...schema2 };
      if (seen.ref === null) {
        return;
      }
      const ref = seen.ref;
      seen.ref = null;
      if (ref) {
        flattenRef(ref, params2);
        const refSchema = this.seen.get(ref).schema;
        if (refSchema.$ref && (params2.target === "draft-7" || params2.target === "draft-4" || params2.target === "openapi-3.0")) {
          schema2.allOf = schema2.allOf ?? [];
          schema2.allOf.push(refSchema);
        } else {
          Object.assign(schema2, refSchema);
          Object.assign(schema2, _cached);
        }
      }
      if (!seen.isParent)
        this.override({
          zodSchema,
          jsonSchema: schema2,
          path: seen.path ?? []
        });
    };
    for (const entry of [...this.seen.entries()].reverse()) {
      flattenRef(entry[0], { target: this.target });
    }
    const result = {};
    if (this.target === "draft-2020-12") {
      result.$schema = "https://json-schema.org/draft/2020-12/schema";
    } else if (this.target === "draft-7") {
      result.$schema = "http://json-schema.org/draft-07/schema#";
    } else if (this.target === "draft-4") {
      result.$schema = "http://json-schema.org/draft-04/schema#";
    } else if (this.target === "openapi-3.0") ;
    else {
      console.warn(`Invalid target: ${this.target}`);
    }
    if ((_d = params.external) == null ? void 0 : _d.uri) {
      const id = (_e = params.external.registry.get(schema)) == null ? void 0 : _e.id;
      if (!id)
        throw new Error("Schema is missing an `id` property");
      result.$id = params.external.uri(id);
    }
    Object.assign(result, root.def);
    const defs = ((_f = params.external) == null ? void 0 : _f.defs) ?? {};
    for (const entry of this.seen.entries()) {
      const seen = entry[1];
      if (seen.def && seen.defId) {
        defs[seen.defId] = seen.def;
      }
    }
    if (params.external) ;
    else {
      if (Object.keys(defs).length > 0) {
        if (this.target === "draft-2020-12") {
          result.$defs = defs;
        } else {
          result.definitions = defs;
        }
      }
    }
    try {
      return JSON.parse(JSON.stringify(result));
    } catch (_err) {
      throw new Error("Error converting schema to JSON.");
    }
  }
}
function toJSONSchema(input, _params) {
  if (input instanceof $ZodRegistry) {
    const gen2 = new JSONSchemaGenerator(_params);
    const defs = {};
    for (const entry of input._idmap.entries()) {
      const [_, schema] = entry;
      gen2.process(schema);
    }
    const schemas = {};
    const external = {
      registry: input,
      uri: _params == null ? void 0 : _params.uri,
      defs
    };
    for (const entry of input._idmap.entries()) {
      const [key, schema] = entry;
      schemas[key] = gen2.emit(schema, {
        ..._params,
        external
      });
    }
    if (Object.keys(defs).length > 0) {
      const defsSegment = gen2.target === "draft-2020-12" ? "$defs" : "definitions";
      schemas.__shared = {
        [defsSegment]: defs
      };
    }
    return { schemas };
  }
  const gen = new JSONSchemaGenerator(_params);
  gen.process(input);
  return gen.emit(input, _params);
}
function isTransforming(_schema, _ctx) {
  const ctx = _ctx ?? { seen: /* @__PURE__ */ new Set() };
  if (ctx.seen.has(_schema))
    return false;
  ctx.seen.add(_schema);
  const def = _schema._zod.def;
  if (def.type === "transform")
    return true;
  if (def.type === "array")
    return isTransforming(def.element, ctx);
  if (def.type === "set")
    return isTransforming(def.valueType, ctx);
  if (def.type === "lazy")
    return isTransforming(def.getter(), ctx);
  if (def.type === "promise" || def.type === "optional" || def.type === "nonoptional" || def.type === "nullable" || def.type === "readonly" || def.type === "default" || def.type === "prefault") {
    return isTransforming(def.innerType, ctx);
  }
  if (def.type === "intersection") {
    return isTransforming(def.left, ctx) || isTransforming(def.right, ctx);
  }
  if (def.type === "record" || def.type === "map") {
    return isTransforming(def.keyType, ctx) || isTransforming(def.valueType, ctx);
  }
  if (def.type === "pipe") {
    return isTransforming(def.in, ctx) || isTransforming(def.out, ctx);
  }
  if (def.type === "object") {
    for (const key in def.shape) {
      if (isTransforming(def.shape[key], ctx))
        return true;
    }
    return false;
  }
  if (def.type === "union") {
    for (const option of def.options) {
      if (isTransforming(option, ctx))
        return true;
    }
    return false;
  }
  if (def.type === "tuple") {
    for (const item of def.items) {
      if (isTransforming(item, ctx))
        return true;
    }
    if (def.rest && isTransforming(def.rest, ctx))
      return true;
    return false;
  }
  return false;
}
function isZodSchemaV4(schema) {
  if (typeof schema !== "object" || schema === null) return false;
  const obj = schema;
  if (!("_zod" in obj)) return false;
  const zod = obj._zod;
  return typeof zod === "object" && zod !== null && "def" in zod;
}
function isZodSchemaV3(schema) {
  if (typeof schema !== "object" || schema === null) return false;
  const obj = schema;
  if (!("_def" in obj) || "_zod" in obj) return false;
  const def = obj._def;
  return typeof def === "object" && def != null && "typeName" in def;
}
function isZodSchema(schema) {
  if (isZodSchemaV4(schema)) console.warn("[WARNING] Attempting to use Zod 4 schema in a context where Zod 3 schema is expected. This may cause unexpected behavior.");
  return isZodSchemaV3(schema);
}
function isInteropZodSchema(input) {
  if (!input) return false;
  if (typeof input !== "object") return false;
  if (Array.isArray(input)) return false;
  if (isZodSchemaV4(input) || isZodSchemaV3(input)) return true;
  return false;
}
function isZodLiteralV3(obj) {
  if (typeof obj === "object" && obj !== null && "_def" in obj && typeof obj._def === "object" && obj._def !== null && "typeName" in obj._def && obj._def.typeName === "ZodLiteral") return true;
  return false;
}
function isZodLiteralV4(obj) {
  if (!isZodSchemaV4(obj)) return false;
  if (typeof obj === "object" && obj !== null && "_zod" in obj && typeof obj._zod === "object" && obj._zod !== null && "def" in obj._zod && typeof obj._zod.def === "object" && obj._zod.def !== null && "type" in obj._zod.def && obj._zod.def.type === "literal") return true;
  return false;
}
function isInteropZodLiteral(obj) {
  if (isZodLiteralV3(obj)) return true;
  if (isZodLiteralV4(obj)) return true;
  return false;
}
async function interopSafeParseAsync(schema, input) {
  if (isZodSchemaV4(schema)) try {
    const data = await parseAsync$1(schema, input);
    return {
      success: true,
      data
    };
  } catch (error) {
    return {
      success: false,
      error
    };
  }
  if (isZodSchemaV3(schema)) return await schema.safeParseAsync(input);
  throw new Error("Schema must be an instance of z3.ZodType or z4.$ZodType");
}
async function interopParseAsync(schema, input) {
  if (isZodSchemaV4(schema)) return await parseAsync$1(schema, input);
  if (isZodSchemaV3(schema)) return await schema.parseAsync(input);
  throw new Error("Schema must be an instance of z3.ZodType or z4.$ZodType");
}
function interopSafeParse(schema, input) {
  if (isZodSchemaV4(schema)) try {
    const data = parse$2(schema, input);
    return {
      success: true,
      data
    };
  } catch (error) {
    return {
      success: false,
      error
    };
  }
  if (isZodSchemaV3(schema)) return schema.safeParse(input);
  throw new Error("Schema must be an instance of z3.ZodType or z4.$ZodType");
}
function interopParse(schema, input) {
  if (isZodSchemaV4(schema)) return parse$2(schema, input);
  if (isZodSchemaV3(schema)) return schema.parse(input);
  throw new Error("Schema must be an instance of z3.ZodType or z4.$ZodType");
}
function getSchemaDescription(schema) {
  var _a3;
  if (isZodSchemaV4(schema)) return (_a3 = globalRegistry.get(schema)) == null ? void 0 : _a3.description;
  if (isZodSchemaV3(schema)) return schema.description;
  if ("description" in schema && typeof schema.description === "string") return schema.description;
  return void 0;
}
function isShapelessZodSchema(schema) {
  if (!isInteropZodSchema(schema)) return false;
  if (isZodSchemaV3(schema)) {
    const def = schema._def;
    if (def.typeName === "ZodObject") {
      const obj = schema;
      return !obj.shape || Object.keys(obj.shape).length === 0;
    }
    if (def.typeName === "ZodRecord") return true;
  }
  if (isZodSchemaV4(schema)) {
    const def = schema._zod.def;
    if (def.type === "object") {
      const obj = schema;
      return !obj.shape || Object.keys(obj.shape).length === 0;
    }
    if (def.type === "record") return true;
  }
  if (typeof schema === "object" && schema !== null && !("shape" in schema)) return true;
  return false;
}
function isSimpleStringZodSchema(schema) {
  if (!isInteropZodSchema(schema)) return false;
  if (isZodSchemaV3(schema)) {
    const def = schema._def;
    return def.typeName === "ZodString";
  }
  if (isZodSchemaV4(schema)) {
    const def = schema._zod.def;
    return def.type === "string";
  }
  return false;
}
function isZodObjectV3(obj) {
  if (typeof obj === "object" && obj !== null && "_def" in obj && typeof obj._def === "object" && obj._def !== null && "typeName" in obj._def && obj._def.typeName === "ZodObject") return true;
  return false;
}
function isZodObjectV4(obj) {
  if (!isZodSchemaV4(obj)) return false;
  if (typeof obj === "object" && obj !== null && "_zod" in obj && typeof obj._zod === "object" && obj._zod !== null && "def" in obj._zod && typeof obj._zod.def === "object" && obj._zod.def !== null && "type" in obj._zod.def && obj._zod.def.type === "object") return true;
  return false;
}
function isZodArrayV4(obj) {
  if (!isZodSchemaV4(obj)) return false;
  if (typeof obj === "object" && obj !== null && "_zod" in obj && typeof obj._zod === "object" && obj._zod !== null && "def" in obj._zod && typeof obj._zod.def === "object" && obj._zod.def !== null && "type" in obj._zod.def && obj._zod.def.type === "array") return true;
  return false;
}
function isZodOptionalV4(obj) {
  if (!isZodSchemaV4(obj)) return false;
  if (typeof obj === "object" && obj !== null && "_zod" in obj && typeof obj._zod === "object" && obj._zod !== null && "def" in obj._zod && typeof obj._zod.def === "object" && obj._zod.def !== null && "type" in obj._zod.def && obj._zod.def.type === "optional") return true;
  return false;
}
function isZodNullableV4(obj) {
  if (!isZodSchemaV4(obj)) return false;
  if (typeof obj === "object" && obj !== null && "_zod" in obj && typeof obj._zod === "object" && obj._zod !== null && "def" in obj._zod && typeof obj._zod.def === "object" && obj._zod.def !== null && "type" in obj._zod.def && obj._zod.def.type === "nullable") return true;
  return false;
}
function isInteropZodObject(obj) {
  if (isZodObjectV3(obj)) return true;
  if (isZodObjectV4(obj)) return true;
  return false;
}
function getInteropZodObjectShape(schema) {
  if (isZodSchemaV3(schema)) return schema.shape;
  if (isZodSchemaV4(schema)) return schema._zod.def.shape;
  throw new Error("Schema must be an instance of z3.ZodObject or z4.$ZodObject");
}
function extendInteropZodObject(schema, extension) {
  if (isZodSchemaV3(schema)) return schema.extend(extension);
  if (isZodSchemaV4(schema)) return extend(schema, extension);
  throw new Error("Schema must be an instance of z3.ZodObject or z4.$ZodObject");
}
function interopZodObjectPartial(schema) {
  if (isZodSchemaV3(schema)) return schema.partial();
  if (isZodSchemaV4(schema)) return partial($ZodOptional, schema, void 0);
  throw new Error("Schema must be an instance of z3.ZodObject or z4.$ZodObject");
}
function interopZodObjectStrict(schema, recursive = false) {
  if (isZodSchemaV3(schema)) return schema.strict();
  if (isZodObjectV4(schema)) {
    const outputShape = schema._zod.def.shape;
    if (recursive) for (const [key, keySchema] of Object.entries(schema._zod.def.shape)) {
      if (isZodObjectV4(keySchema)) {
        const outputSchema = interopZodObjectStrict(keySchema, recursive);
        outputShape[key] = outputSchema;
      } else if (isZodArrayV4(keySchema)) {
        let elementSchema = keySchema._zod.def.element;
        if (isZodObjectV4(elementSchema)) elementSchema = interopZodObjectStrict(elementSchema, recursive);
        outputShape[key] = clone(keySchema, {
          ...keySchema._zod.def,
          element: elementSchema
        });
      } else outputShape[key] = keySchema;
      const meta$1 = globalRegistry.get(keySchema);
      if (meta$1) globalRegistry.add(outputShape[key], meta$1);
    }
    const modifiedSchema = clone(schema, {
      ...schema._zod.def,
      shape: outputShape,
      catchall: _never($ZodNever)
    });
    const meta = globalRegistry.get(schema);
    if (meta) globalRegistry.add(modifiedSchema, meta);
    return modifiedSchema;
  }
  throw new Error("Schema must be an instance of z3.ZodObject or z4.$ZodObject");
}
function interopZodObjectPassthrough(schema, recursive = false) {
  if (isZodObjectV3(schema)) return schema.passthrough();
  if (isZodObjectV4(schema)) {
    const outputShape = schema._zod.def.shape;
    if (recursive) for (const [key, keySchema] of Object.entries(schema._zod.def.shape)) {
      if (isZodObjectV4(keySchema)) {
        const outputSchema = interopZodObjectPassthrough(keySchema, recursive);
        outputShape[key] = outputSchema;
      } else if (isZodArrayV4(keySchema)) {
        let elementSchema = keySchema._zod.def.element;
        if (isZodObjectV4(elementSchema)) elementSchema = interopZodObjectPassthrough(elementSchema, recursive);
        outputShape[key] = clone(keySchema, {
          ...keySchema._zod.def,
          element: elementSchema
        });
      } else outputShape[key] = keySchema;
      const meta$1 = globalRegistry.get(keySchema);
      if (meta$1) globalRegistry.add(outputShape[key], meta$1);
    }
    const modifiedSchema = clone(schema, {
      ...schema._zod.def,
      shape: outputShape,
      catchall: _unknown($ZodUnknown)
    });
    const meta = globalRegistry.get(schema);
    if (meta) globalRegistry.add(modifiedSchema, meta);
    return modifiedSchema;
  }
  throw new Error("Schema must be an instance of z3.ZodObject or z4.$ZodObject");
}
function getInteropZodDefaultGetter(schema) {
  if (isZodSchemaV3(schema)) try {
    const defaultValue = schema.parse(void 0);
    return () => defaultValue;
  } catch {
    return void 0;
  }
  if (isZodSchemaV4(schema)) try {
    const defaultValue = parse$2(schema, void 0);
    return () => defaultValue;
  } catch {
    return void 0;
  }
  return void 0;
}
function isZodTransformV3(schema) {
  return isZodSchemaV3(schema) && "typeName" in schema._def && schema._def.typeName === "ZodEffects";
}
function isZodTransformV4(schema) {
  return isZodSchemaV4(schema) && schema._zod.def.type === "pipe";
}
function interopZodTransformInputSchemaImpl(schema, recursive, cache2) {
  const cached2 = cache2.get(schema);
  if (cached2 !== void 0) return cached2;
  if (isZodSchemaV3(schema)) {
    if (isZodTransformV3(schema)) return interopZodTransformInputSchemaImpl(schema._def.schema, recursive, cache2);
    return schema;
  }
  if (isZodSchemaV4(schema)) {
    let outputSchema = schema;
    if (isZodTransformV4(schema)) outputSchema = interopZodTransformInputSchemaImpl(schema._zod.def.in, recursive, cache2);
    if (recursive) {
      if (isZodObjectV4(outputSchema)) {
        const outputShape = outputSchema._zod.def.shape;
        for (const [key, keySchema] of Object.entries(outputSchema._zod.def.shape)) outputShape[key] = interopZodTransformInputSchemaImpl(keySchema, recursive, cache2);
        outputSchema = clone(outputSchema, {
          ...outputSchema._zod.def,
          shape: outputShape
        });
      } else if (isZodArrayV4(outputSchema)) {
        const elementSchema = interopZodTransformInputSchemaImpl(outputSchema._zod.def.element, recursive, cache2);
        outputSchema = clone(outputSchema, {
          ...outputSchema._zod.def,
          element: elementSchema
        });
      } else if (isZodOptionalV4(outputSchema)) {
        const innerSchema = interopZodTransformInputSchemaImpl(outputSchema._zod.def.innerType, recursive, cache2);
        outputSchema = clone(outputSchema, {
          ...outputSchema._zod.def,
          innerType: innerSchema
        });
      } else if (isZodNullableV4(outputSchema)) {
        const innerSchema = interopZodTransformInputSchemaImpl(outputSchema._zod.def.innerType, recursive, cache2);
        outputSchema = clone(outputSchema, {
          ...outputSchema._zod.def,
          innerType: innerSchema
        });
      }
    }
    const meta = globalRegistry.get(schema);
    if (meta) globalRegistry.add(outputSchema, meta);
    cache2.set(schema, outputSchema);
    return outputSchema;
  }
  throw new Error("Schema must be an instance of z3.ZodType or z4.$ZodType");
}
function interopZodTransformInputSchema(schema, recursive = false) {
  const cache2 = /* @__PURE__ */ new WeakMap();
  return interopZodTransformInputSchemaImpl(schema, recursive, cache2);
}
function interopZodObjectMakeFieldsOptional(schema, predicate) {
  if (isZodSchemaV3(schema)) {
    const shape = getInteropZodObjectShape(schema);
    const modifiedShape = {};
    for (const [key, value] of Object.entries(shape)) if (predicate(key, value)) modifiedShape[key] = value.optional();
    else modifiedShape[key] = value;
    return schema.extend(modifiedShape);
  }
  if (isZodSchemaV4(schema)) {
    const shape = getInteropZodObjectShape(schema);
    const outputShape = { ...schema._zod.def.shape };
    for (const [key, value] of Object.entries(shape)) if (predicate(key, value)) outputShape[key] = new $ZodOptional({
      type: "optional",
      innerType: value
    });
    const modifiedSchema = clone(schema, {
      ...schema._zod.def,
      shape: outputShape
    });
    const meta = globalRegistry.get(schema);
    if (meta) globalRegistry.add(modifiedSchema, meta);
    return modifiedSchema;
  }
  throw new Error("Schema must be an instance of z3.ZodObject or z4.$ZodObject");
}
function isInteropZodError(e) {
  return e instanceof Error && (e.constructor.name === "ZodError" || e.constructor.name === "$ZodError");
}
function _escapeNodeLabel(nodeLabel) {
  return nodeLabel.replace(/[^a-zA-Z-_0-9]/g, "_");
}
const MARKDOWN_SPECIAL_CHARS = [
  "*",
  "_",
  "`"
];
function _generateMermaidGraphStyles(nodeColors) {
  let styles2 = "";
  for (const [className, color2] of Object.entries(nodeColors)) styles2 += `	classDef ${className} ${color2};
`;
  return styles2;
}
function drawMermaid(nodes, edges, config2) {
  const { firstNode, lastNode, nodeColors, withStyles = true, curveStyle = "linear", wrapLabelNWords = 9 } = config2 ?? {};
  let mermaidGraph = withStyles ? `%%{init: {'flowchart': {'curve': '${curveStyle}'}}}%%
graph TD;
` : "graph TD;\n";
  if (withStyles) {
    const defaultClassLabel = "default";
    const formatDict = { [defaultClassLabel]: "{0}({1})" };
    if (firstNode !== void 0) formatDict[firstNode] = "{0}([{1}]):::first";
    if (lastNode !== void 0) formatDict[lastNode] = "{0}([{1}]):::last";
    for (const [key, node] of Object.entries(nodes)) {
      const nodeName = node.name.split(":").pop() ?? "";
      const label = MARKDOWN_SPECIAL_CHARS.some((char) => nodeName.startsWith(char) && nodeName.endsWith(char)) ? `<p>${nodeName}</p>` : nodeName;
      let finalLabel = label;
      if (Object.keys(node.metadata ?? {}).length) finalLabel += `<hr/><small><em>${Object.entries(node.metadata ?? {}).map(([k, v]) => `${k} = ${v}`).join("\n")}</em></small>`;
      const nodeLabel = (formatDict[key] ?? formatDict[defaultClassLabel]).replace("{0}", _escapeNodeLabel(key)).replace("{1}", finalLabel);
      mermaidGraph += `	${nodeLabel}
`;
    }
  }
  const edgeGroups = {};
  for (const edge of edges) {
    const srcParts = edge.source.split(":");
    const tgtParts = edge.target.split(":");
    const commonPrefix = srcParts.filter((src, i2) => src === tgtParts[i2]).join(":");
    if (!edgeGroups[commonPrefix]) edgeGroups[commonPrefix] = [];
    edgeGroups[commonPrefix].push(edge);
  }
  const seenSubgraphs = /* @__PURE__ */ new Set();
  function addSubgraph(edges$1, prefix) {
    const selfLoop = edges$1.length === 1 && edges$1[0].source === edges$1[0].target;
    if (prefix && !selfLoop) {
      const subgraph = prefix.split(":").pop();
      if (seenSubgraphs.has(subgraph)) throw new Error(`Found duplicate subgraph '${subgraph}' -- this likely means that you're reusing a subgraph node with the same name. Please adjust your graph to have subgraph nodes with unique names.`);
      seenSubgraphs.add(subgraph);
      mermaidGraph += `	subgraph ${subgraph}
`;
    }
    for (const edge of edges$1) {
      const { source, target, data, conditional } = edge;
      let edgeLabel = "";
      if (data !== void 0) {
        let edgeData = data;
        const words = edgeData.split(" ");
        if (words.length > wrapLabelNWords) edgeData = Array.from({ length: Math.ceil(words.length / wrapLabelNWords) }, (_, i2) => words.slice(i2 * wrapLabelNWords, (i2 + 1) * wrapLabelNWords).join(" ")).join("&nbsp;<br>&nbsp;");
        edgeLabel = conditional ? ` -. &nbsp;${edgeData}&nbsp; .-> ` : ` -- &nbsp;${edgeData}&nbsp; --> `;
      } else edgeLabel = conditional ? " -.-> " : " --> ";
      mermaidGraph += `	${_escapeNodeLabel(source)}${edgeLabel}${_escapeNodeLabel(target)};
`;
    }
    for (const nestedPrefix in edgeGroups) if (nestedPrefix.startsWith(`${prefix}:`) && nestedPrefix !== prefix) addSubgraph(edgeGroups[nestedPrefix], nestedPrefix);
    if (prefix && !selfLoop) mermaidGraph += "	end\n";
  }
  addSubgraph(edgeGroups[""] ?? [], "");
  for (const prefix in edgeGroups) if (!prefix.includes(":") && prefix !== "") addSubgraph(edgeGroups[prefix], prefix);
  if (withStyles) mermaidGraph += _generateMermaidGraphStyles(nodeColors ?? {});
  return mermaidGraph;
}
async function drawMermaidImage(mermaidSyntax, config2) {
  let backgroundColor = (config2 == null ? void 0 : config2.backgroundColor) ?? "white";
  const imageType = (config2 == null ? void 0 : config2.imageType) ?? "png";
  const mermaidSyntaxEncoded = toBase64Url(mermaidSyntax);
  if (backgroundColor !== void 0) {
    const hexColorPattern = /^#(?:[0-9a-fA-F]{3}){1,2}$/;
    if (!hexColorPattern.test(backgroundColor)) backgroundColor = `!${backgroundColor}`;
  }
  const imageUrl = `https://mermaid.ink/img/${mermaidSyntaxEncoded}?bgColor=${backgroundColor}&type=${imageType}`;
  const res = await fetch(imageUrl);
  if (!res.ok) throw new Error([
    `Failed to render the graph using the Mermaid.INK API.`,
    `Status code: ${res.status}`,
    `Status text: ${res.statusText}`
  ].join("\n"));
  const content = await res.blob();
  return content;
}
const ignoreOverride$1 = Symbol("Let zodToJsonSchema decide on which parser to use");
const defaultOptions$1 = {
  name: void 0,
  $refStrategy: "root",
  basePath: ["#"],
  effectStrategy: "input",
  pipeStrategy: "all",
  dateStrategy: "format:date-time",
  mapStrategy: "entries",
  removeAdditionalStrategy: "passthrough",
  allowedAdditionalProperties: true,
  rejectedAdditionalProperties: false,
  definitionPath: "definitions",
  target: "jsonSchema7",
  strictUnions: false,
  definitions: {},
  errorMessages: false,
  markdownDescription: false,
  patternStrategy: "escape",
  applyRegexFlags: false,
  emailStrategy: "format:email",
  base64Strategy: "contentEncoding:base64",
  nameStrategy: "ref",
  openAiAnyTypeName: "OpenAiAnyType"
};
const getDefaultOptions$1 = (options2) => ({
  ...defaultOptions$1,
  ...options2
});
const getRefs$1 = (options2) => {
  const _options = getDefaultOptions$1(options2);
  const currentPath = _options.name !== void 0 ? [
    ..._options.basePath,
    _options.definitionPath,
    _options.name
  ] : _options.basePath;
  return {
    ..._options,
    flags: { hasReferencedOpenAiAnyType: false },
    currentPath,
    propertyPath: void 0,
    seen: new Map(Object.entries(_options.definitions).map(([name, def]) => [def._def, {
      def: def._def,
      path: [
        ..._options.basePath,
        _options.definitionPath,
        name
      ],
      jsonSchema: void 0
    }]))
  };
};
const getRelativePath$1 = (pathA, pathB) => {
  let i2 = 0;
  for (; i2 < pathA.length && i2 < pathB.length; i2++) if (pathA[i2] !== pathB[i2]) break;
  return [(pathA.length - i2).toString(), ...pathB.slice(i2)].join("/");
};
function parseAnyDef$1(refs) {
  if (refs.target !== "openAi") return {};
  const anyDefinitionPath = [
    ...refs.basePath,
    refs.definitionPath,
    refs.openAiAnyTypeName
  ];
  refs.flags.hasReferencedOpenAiAnyType = true;
  return { $ref: refs.$refStrategy === "relative" ? getRelativePath$1(anyDefinitionPath, refs.currentPath) : anyDefinitionPath.join("/") };
}
function addErrorMessage$1(res, key, errorMessage, refs) {
  if (!(refs == null ? void 0 : refs.errorMessages)) return;
  if (errorMessage) res.errorMessage = {
    ...res.errorMessage,
    [key]: errorMessage
  };
}
function setResponseValueAndErrors$1(res, key, value, errorMessage, refs) {
  res[key] = value;
  addErrorMessage$1(res, key, errorMessage, refs);
}
var util;
(function(util2) {
  util2.assertEqual = (_) => {
  };
  function assertIs(_arg) {
  }
  util2.assertIs = assertIs;
  function assertNever2(_x) {
    throw new Error();
  }
  util2.assertNever = assertNever2;
  util2.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
    const filtered = {};
    for (const k of validKeys) {
      filtered[k] = obj[k];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e) {
      return obj[e];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object2) => {
    const keys = [];
    for (const key in object2) {
      if (Object.prototype.hasOwnProperty.call(object2, key)) {
        keys.push(key);
      }
    }
    return keys;
  };
  util2.find = (arr2, checker) => {
    for (const item of arr2) {
      if (checker(item))
        return item;
    }
    return void 0;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && Number.isFinite(val) && Math.floor(val) === val;
  function joinValues(array2, separator = " | ") {
    return array2.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util2.joinValues = joinValues;
  util2.jsonStringifyReplacer = (_, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };
})(util || (util = {}));
var objectUtil;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => {
    return {
      ...first,
      ...second
      // second overwrites first
    };
  };
})(objectUtil || (objectUtil = {}));
const ZodParsedType = util.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
const getParsedType = (data) => {
  const t2 = typeof data;
  switch (t2) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return Number.isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType.array;
      }
      if (data === null) {
        return ZodParsedType.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
};
const ZodIssueCode = util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
class ZodError extends Error {
  get errors() {
    return this.issues;
  }
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue2) {
      return issue2.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = (error) => {
      for (const issue2 of error.issues) {
        if (issue2.code === "invalid_union") {
          issue2.unionErrors.map(processError);
        } else if (issue2.code === "invalid_return_type") {
          processError(issue2.returnTypeError);
        } else if (issue2.code === "invalid_arguments") {
          processError(issue2.argumentsError);
        } else if (issue2.path.length === 0) {
          fieldErrors._errors.push(mapper(issue2));
        } else {
          let curr = fieldErrors;
          let i2 = 0;
          while (i2 < issue2.path.length) {
            const el = issue2.path[i2];
            const terminal = i2 === issue2.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue2));
            }
            curr = curr[el];
            i2++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  static assert(value) {
    if (!(value instanceof ZodError)) {
      throw new Error(`Not a ZodError: ${value}`);
    }
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue2) => issue2.message) {
    const fieldErrors = /* @__PURE__ */ Object.create(null);
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        const firstEl = sub.path[0];
        fieldErrors[firstEl] = fieldErrors[firstEl] || [];
        fieldErrors[firstEl].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
}
ZodError.create = (issues) => {
  const error = new ZodError(issues);
  return error;
};
const errorMap = (issue2, _ctx) => {
  let message;
  switch (issue2.code) {
    case ZodIssueCode.invalid_type:
      if (issue2.received === ZodParsedType.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue2.expected}, received ${issue2.received}`;
      }
      break;
    case ZodIssueCode.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue2.expected, util.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util.joinValues(issue2.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util.joinValues(issue2.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message = `Invalid enum value. Expected ${util.joinValues(issue2.options)}, received '${issue2.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode.invalid_string:
      if (typeof issue2.validation === "object") {
        if ("includes" in issue2.validation) {
          message = `Invalid input: must include "${issue2.validation.includes}"`;
          if (typeof issue2.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue2.validation.position}`;
          }
        } else if ("startsWith" in issue2.validation) {
          message = `Invalid input: must start with "${issue2.validation.startsWith}"`;
        } else if ("endsWith" in issue2.validation) {
          message = `Invalid input: must end with "${issue2.validation.endsWith}"`;
        } else {
          util.assertNever(issue2.validation);
        }
      } else if (issue2.validation !== "regex") {
        message = `Invalid ${issue2.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode.too_small:
      if (issue2.type === "array")
        message = `Array must contain ${issue2.exact ? "exactly" : issue2.inclusive ? `at least` : `more than`} ${issue2.minimum} element(s)`;
      else if (issue2.type === "string")
        message = `String must contain ${issue2.exact ? "exactly" : issue2.inclusive ? `at least` : `over`} ${issue2.minimum} character(s)`;
      else if (issue2.type === "number")
        message = `Number must be ${issue2.exact ? `exactly equal to ` : issue2.inclusive ? `greater than or equal to ` : `greater than `}${issue2.minimum}`;
      else if (issue2.type === "bigint")
        message = `Number must be ${issue2.exact ? `exactly equal to ` : issue2.inclusive ? `greater than or equal to ` : `greater than `}${issue2.minimum}`;
      else if (issue2.type === "date")
        message = `Date must be ${issue2.exact ? `exactly equal to ` : issue2.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue2.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      if (issue2.type === "array")
        message = `Array must contain ${issue2.exact ? `exactly` : issue2.inclusive ? `at most` : `less than`} ${issue2.maximum} element(s)`;
      else if (issue2.type === "string")
        message = `String must contain ${issue2.exact ? `exactly` : issue2.inclusive ? `at most` : `under`} ${issue2.maximum} character(s)`;
      else if (issue2.type === "number")
        message = `Number must be ${issue2.exact ? `exactly` : issue2.inclusive ? `less than or equal to` : `less than`} ${issue2.maximum}`;
      else if (issue2.type === "bigint")
        message = `BigInt must be ${issue2.exact ? `exactly` : issue2.inclusive ? `less than or equal to` : `less than`} ${issue2.maximum}`;
      else if (issue2.type === "date")
        message = `Date must be ${issue2.exact ? `exactly` : issue2.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue2.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode.not_multiple_of:
      message = `Number must be a multiple of ${issue2.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util.assertNever(issue2);
  }
  return { message };
};
let overrideErrorMap = errorMap;
function getErrorMap() {
  return overrideErrorMap;
}
const makeIssue = (params) => {
  const { data, path: path2, errorMaps, issueData } = params;
  const fullPath = [...path2, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  if (issueData.message !== void 0) {
    return {
      ...issueData,
      path: fullPath,
      message: issueData.message
    };
  }
  let errorMessage = "";
  const maps = errorMaps.filter((m) => !!m).slice().reverse();
  for (const map of maps) {
    errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: errorMessage
  };
};
function addIssueToContext(ctx, issueData) {
  const overrideMap = getErrorMap();
  const issue2 = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      // contextual error map is first priority
      ctx.schemaErrorMap,
      // then schema-bound map if available
      overrideMap,
      // then global override map
      overrideMap === errorMap ? void 0 : errorMap
      // then global default map
    ].filter((x) => !!x)
  });
  ctx.common.issues.push(issue2);
}
class ParseStatus {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results2) {
    const arrayValue = [];
    for (const s of results2) {
      if (s.status === "aborted")
        return INVALID;
      if (s.status === "dirty")
        status.dirty();
      arrayValue.push(s.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      const key = await pair.key;
      const value = await pair.value;
      syncPairs.push({
        key,
        value
      });
    }
    return ParseStatus.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key, value } = pair;
      if (key.status === "aborted")
        return INVALID;
      if (value.status === "aborted")
        return INVALID;
      if (key.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
}
const INVALID = Object.freeze({
  status: "aborted"
});
const DIRTY = (value) => ({ status: "dirty", value });
const OK = (value) => ({ status: "valid", value });
const isAborted = (x) => x.status === "aborted";
const isDirty = (x) => x.status === "dirty";
const isValid = (x) => x.status === "valid";
const isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;
var errorUtil;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message == null ? void 0 : message.message;
})(errorUtil || (errorUtil = {}));
class ParseInputLazyPath {
  constructor(parent, value, path2, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path2;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (Array.isArray(this._key)) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
}
const handleResult = (ctx, result) => {
  if (isValid(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error = new ZodError(ctx.common.issues);
        this._error = error;
        return this._error;
      }
    };
  }
};
function processCreateParams(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = (iss, ctx) => {
    const { message } = params;
    if (iss.code === "invalid_enum_value") {
      return { message: message ?? ctx.defaultError };
    }
    if (typeof ctx.data === "undefined") {
      return { message: message ?? required_error ?? ctx.defaultError };
    }
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    return { message: message ?? invalid_type_error ?? ctx.defaultError };
  };
  return { errorMap: customMap, description };
}
let ZodType$1 = class ZodType2 {
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus(),
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    const ctx = {
      common: {
        issues: [],
        async: (params == null ? void 0 : params.async) ?? false,
        contextualErrorMap: params == null ? void 0 : params.errorMap
      },
      path: (params == null ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult(ctx, result);
  }
  "~validate"(data) {
    var _a3, _b;
    const ctx = {
      common: {
        issues: [],
        async: !!this["~standard"].async
      },
      path: [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    if (!this["~standard"].async) {
      try {
        const result = this._parseSync({ data, path: [], parent: ctx });
        return isValid(result) ? {
          value: result.value
        } : {
          issues: ctx.common.issues
        };
      } catch (err) {
        if ((_b = (_a3 = err == null ? void 0 : err.message) == null ? void 0 : _a3.toLowerCase()) == null ? void 0 : _b.includes("encountered")) {
          this["~standard"].async = true;
        }
        ctx.common = {
          issues: [],
          async: true
        };
      }
    }
    return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid(result) ? {
      value: result.value
    } : {
      issues: ctx.common.issues
    });
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params == null ? void 0 : params.errorMap,
        async: true
      },
      path: (params == null ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult(ctx, result);
  }
  refine(check, message) {
    const getIssueProperties = (val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  constructor(def) {
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
    this["~standard"] = {
      version: 1,
      vendor: "zod",
      validate: (data) => this["~validate"](data)
    };
  }
  optional() {
    return ZodOptional$1.create(this, this._def);
  }
  nullable() {
    return ZodNullable$1.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray$1.create(this);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or(option) {
    return ZodUnion$1.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection$1.create(this, incoming, this._def);
  }
  transform(transform2) {
    return new ZodEffects({
      ...processCreateParams(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform: transform2 }
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault$1({
      ...processCreateParams(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    });
  }
  brand() {
    return new ZodBranded({
      typeName: ZodFirstPartyTypeKind.ZodBranded,
      type: this,
      ...processCreateParams(this._def)
    });
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch$1({
      ...processCreateParams(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline.create(this, target);
  }
  readonly() {
    return ZodReadonly$1.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
};
const cuidRegex = /^c[^\s-]{8,}$/i;
const cuid2Regex = /^[0-9a-z]+$/;
const ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
const uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
const nanoidRegex = /^[a-z0-9_-]{21}$/i;
const jwtRegex = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
const durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
const emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
const _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
let emojiRegex$2;
const ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
const ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
const ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
const ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
const base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
const base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
const dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
const dateRegex = new RegExp(`^${dateRegexSource}$`);
function timeRegexSource(args) {
  let secondsRegexSource = `[0-5]\\d`;
  if (args.precision) {
    secondsRegexSource = `${secondsRegexSource}\\.\\d{${args.precision}}`;
  } else if (args.precision == null) {
    secondsRegexSource = `${secondsRegexSource}(\\.\\d+)?`;
  }
  const secondsQuantifier = args.precision ? "+" : "?";
  return `([01]\\d|2[0-3]):[0-5]\\d(:${secondsRegexSource})${secondsQuantifier}`;
}
function timeRegex(args) {
  return new RegExp(`^${timeRegexSource(args)}$`);
}
function datetimeRegex(args) {
  let regex2 = `${dateRegexSource}T${timeRegexSource(args)}`;
  const opts = [];
  opts.push(args.local ? `Z?` : `Z`);
  if (args.offset)
    opts.push(`([+-]\\d{2}:?\\d{2})`);
  regex2 = `${regex2}(${opts.join("|")})`;
  return new RegExp(`^${regex2}$`);
}
function isValidIP(ip, version2) {
  if ((version2 === "v4" || !version2) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version2 === "v6" || !version2) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
}
function isValidJWT(jwt, alg) {
  if (!jwtRegex.test(jwt))
    return false;
  try {
    const [header] = jwt.split(".");
    if (!header)
      return false;
    const base642 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
    const decoded = JSON.parse(atob(base642));
    if (typeof decoded !== "object" || decoded === null)
      return false;
    if ("typ" in decoded && (decoded == null ? void 0 : decoded.typ) !== "JWT")
      return false;
    if (!decoded.alg)
      return false;
    if (alg && decoded.alg !== alg)
      return false;
    return true;
  } catch {
    return false;
  }
}
function isValidCidr(ip, version2) {
  if ((version2 === "v4" || !version2) && ipv4CidrRegex.test(ip)) {
    return true;
  }
  if ((version2 === "v6" || !version2) && ipv6CidrRegex.test(ip)) {
    return true;
  }
  return false;
}
let ZodString$1 = class ZodString2 extends ZodType$1 {
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.string,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.length < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.length > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "length") {
        const tooBig = input.data.length > check.value;
        const tooSmall = input.data.length < check.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          } else if (tooSmall) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          }
          status.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "email",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "emoji") {
        if (!emojiRegex$2) {
          emojiRegex$2 = new RegExp(_emojiRegex, "u");
        }
        if (!emojiRegex$2.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "emoji",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "uuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "nanoid") {
        if (!nanoidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "nanoid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid2") {
        if (!cuid2Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid2",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ulid") {
        if (!ulidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ulid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input.data);
        } catch {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "regex",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "trim") {
        input.data = input.data.trim();
      } else if (check.kind === "includes") {
        if (!input.data.includes(check.value, check.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { includes: check.value, position: check.position },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check.kind === "startsWith") {
        if (!input.data.startsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { startsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "endsWith") {
        if (!input.data.endsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { endsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "datetime") {
        const regex2 = datetimeRegex(check);
        if (!regex2.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "datetime",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "date") {
        const regex2 = dateRegex;
        if (!regex2.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "date",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "time") {
        const regex2 = timeRegex(check);
        if (!regex2.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "time",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "duration") {
        if (!durationRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "duration",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ip") {
        if (!isValidIP(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ip",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "jwt") {
        if (!isValidJWT(input.data, check.alg)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "jwt",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cidr") {
        if (!isValidCidr(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cidr",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64") {
        if (!base64Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "base64",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64url") {
        if (!base64urlRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "base64url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _regex(regex2, validation, message) {
    return this.refinement((data) => regex2.test(data), {
      validation,
      code: ZodIssueCode.invalid_string,
      ...errorUtil.errToObj(message)
    });
  }
  _addCheck(check) {
    return new ZodString2({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
  }
  nanoid(message) {
    return this._addCheck({ kind: "nanoid", ...errorUtil.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
  }
  base64(message) {
    return this._addCheck({ kind: "base64", ...errorUtil.errToObj(message) });
  }
  base64url(message) {
    return this._addCheck({
      kind: "base64url",
      ...errorUtil.errToObj(message)
    });
  }
  jwt(options2) {
    return this._addCheck({ kind: "jwt", ...errorUtil.errToObj(options2) });
  }
  ip(options2) {
    return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options2) });
  }
  cidr(options2) {
    return this._addCheck({ kind: "cidr", ...errorUtil.errToObj(options2) });
  }
  datetime(options2) {
    if (typeof options2 === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        local: false,
        message: options2
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof (options2 == null ? void 0 : options2.precision) === "undefined" ? null : options2 == null ? void 0 : options2.precision,
      offset: (options2 == null ? void 0 : options2.offset) ?? false,
      local: (options2 == null ? void 0 : options2.local) ?? false,
      ...errorUtil.errToObj(options2 == null ? void 0 : options2.message)
    });
  }
  date(message) {
    return this._addCheck({ kind: "date", message });
  }
  time(options2) {
    if (typeof options2 === "string") {
      return this._addCheck({
        kind: "time",
        precision: null,
        message: options2
      });
    }
    return this._addCheck({
      kind: "time",
      precision: typeof (options2 == null ? void 0 : options2.precision) === "undefined" ? null : options2 == null ? void 0 : options2.precision,
      ...errorUtil.errToObj(options2 == null ? void 0 : options2.message)
    });
  }
  duration(message) {
    return this._addCheck({ kind: "duration", ...errorUtil.errToObj(message) });
  }
  regex(regex2, message) {
    return this._addCheck({
      kind: "regex",
      regex: regex2,
      ...errorUtil.errToObj(message)
    });
  }
  includes(value, options2) {
    return this._addCheck({
      kind: "includes",
      value,
      position: options2 == null ? void 0 : options2.position,
      ...errorUtil.errToObj(options2 == null ? void 0 : options2.message)
    });
  }
  startsWith(value, message) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  endsWith(value, message) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil.errToObj(message)
    });
  }
  length(len2, message) {
    return this._addCheck({
      kind: "length",
      value: len2,
      ...errorUtil.errToObj(message)
    });
  }
  /**
   * Equivalent to `.min(1)`
   */
  nonempty(message) {
    return this.min(1, errorUtil.errToObj(message));
  }
  trim() {
    return new ZodString2({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new ZodString2({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new ZodString2({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((ch) => ch.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((ch) => ch.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((ch) => ch.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((ch) => ch.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get isCIDR() {
    return !!this._def.checks.find((ch) => ch.kind === "cidr");
  }
  get isBase64() {
    return !!this._def.checks.find((ch) => ch.kind === "base64");
  }
  get isBase64url() {
    return !!this._def.checks.find((ch) => ch.kind === "base64url");
  }
  get minLength() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxLength() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodString$1.create = (params) => {
  return new ZodString$1({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodString,
    coerce: (params == null ? void 0 : params.coerce) ?? false,
    ...processCreateParams(params)
  });
};
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}
let ZodNumber$1 = class ZodNumber2 extends ZodType$1 {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder(input.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_finite,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodNumber2({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodNumber2({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
  }
  get isFinite() {
    let max = null;
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true;
      } else if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      } else if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return Number.isFinite(min) && Number.isFinite(max);
  }
};
ZodNumber$1.create = (params) => {
  return new ZodNumber$1({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodNumber,
    coerce: (params == null ? void 0 : params.coerce) || false,
    ...processCreateParams(params)
  });
};
class ZodBigInt extends ZodType$1 {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      try {
        input.data = BigInt(input.data);
      } catch {
        return this._getInvalidInput(input);
      }
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.bigint) {
      return this._getInvalidInput(input);
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            type: "bigint",
            minimum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            type: "bigint",
            maximum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (input.data % check.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _getInvalidInput(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.bigint,
      received: ctx.parsedType
    });
    return INVALID;
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodBigInt({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodBigInt({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
}
ZodBigInt.create = (params) => {
  return new ZodBigInt({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodBigInt,
    coerce: (params == null ? void 0 : params.coerce) ?? false,
    ...processCreateParams(params)
  });
};
let ZodBoolean$1 = class ZodBoolean2 extends ZodType$1 {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodBoolean$1.create = (params) => {
  return new ZodBoolean$1({
    typeName: ZodFirstPartyTypeKind.ZodBoolean,
    coerce: (params == null ? void 0 : params.coerce) || false,
    ...processCreateParams(params)
  });
};
class ZodDate extends ZodType$1 {
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    if (Number.isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_date
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.getTime() < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            message: check.message,
            inclusive: true,
            exact: false,
            minimum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.getTime() > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            message: check.message,
            inclusive: true,
            exact: false,
            maximum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check) {
    return new ZodDate({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  get minDate() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min != null ? new Date(min) : null;
  }
  get maxDate() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max != null ? new Date(max) : null;
  }
}
ZodDate.create = (params) => {
  return new ZodDate({
    checks: [],
    coerce: (params == null ? void 0 : params.coerce) || false,
    typeName: ZodFirstPartyTypeKind.ZodDate,
    ...processCreateParams(params)
  });
};
class ZodSymbol extends ZodType$1 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.symbol,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodSymbol.create = (params) => {
  return new ZodSymbol({
    typeName: ZodFirstPartyTypeKind.ZodSymbol,
    ...processCreateParams(params)
  });
};
class ZodUndefined extends ZodType$1 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodUndefined.create = (params) => {
  return new ZodUndefined({
    typeName: ZodFirstPartyTypeKind.ZodUndefined,
    ...processCreateParams(params)
  });
};
class ZodNull extends ZodType$1 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodNull.create = (params) => {
  return new ZodNull({
    typeName: ZodFirstPartyTypeKind.ZodNull,
    ...processCreateParams(params)
  });
};
let ZodAny$1 = class ZodAny2 extends ZodType$1 {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK(input.data);
  }
};
ZodAny$1.create = (params) => {
  return new ZodAny$1({
    typeName: ZodFirstPartyTypeKind.ZodAny,
    ...processCreateParams(params)
  });
};
let ZodUnknown$1 = class ZodUnknown2 extends ZodType$1 {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK(input.data);
  }
};
ZodUnknown$1.create = (params) => {
  return new ZodUnknown$1({
    typeName: ZodFirstPartyTypeKind.ZodUnknown,
    ...processCreateParams(params)
  });
};
let ZodNever$1 = class ZodNever2 extends ZodType$1 {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: ctx.parsedType
    });
    return INVALID;
  }
};
ZodNever$1.create = (params) => {
  return new ZodNever$1({
    typeName: ZodFirstPartyTypeKind.ZodNever,
    ...processCreateParams(params)
  });
};
class ZodVoid extends ZodType$1 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodVoid.create = (params) => {
  return new ZodVoid({
    typeName: ZodFirstPartyTypeKind.ZodVoid,
    ...processCreateParams(params)
  });
};
let ZodArray$1 = class ZodArray2 extends ZodType$1 {
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def = this._def;
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (def.exactLength !== null) {
      const tooBig = ctx.data.length > def.exactLength.value;
      const tooSmall = ctx.data.length < def.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext(ctx, {
          code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
          minimum: tooSmall ? def.exactLength.value : void 0,
          maximum: tooBig ? def.exactLength.value : void 0,
          type: "array",
          inclusive: true,
          exact: true,
          message: def.exactLength.message
        });
        status.dirty();
      }
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.minLength.message
        });
        status.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i2) => {
        return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i2));
      })).then((result2) => {
        return ParseStatus.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i2) => {
      return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i2));
    });
    return ParseStatus.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new ZodArray2({
      ...this._def,
      minLength: { value: minLength, message: errorUtil.toString(message) }
    });
  }
  max(maxLength, message) {
    return new ZodArray2({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil.toString(message) }
    });
  }
  length(len2, message) {
    return new ZodArray2({
      ...this._def,
      exactLength: { value: len2, message: errorUtil.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodArray$1.create = (schema, params) => {
  return new ZodArray$1({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind.ZodArray,
    ...processCreateParams(params)
  });
};
function deepPartialify(schema) {
  if (schema instanceof ZodObject$1) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional$1.create(deepPartialify(fieldSchema));
    }
    return new ZodObject$1({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray$1) {
    return new ZodArray$1({
      ...schema._def,
      type: deepPartialify(schema.element)
    });
  } else if (schema instanceof ZodOptional$1) {
    return ZodOptional$1.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable$1) {
    return ZodNullable$1.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple) {
    return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
  } else {
    return schema;
  }
}
let ZodObject$1 = class ZodObject2 extends ZodType$1 {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys = util.objectKeys(shape);
    this._cached = { shape, keys };
    return this._cached;
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever$1 && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever$1) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip") ;
      else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(
            new ParseInputLazyPath(ctx, value, ctx.path, key)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          syncPairs.push({
            key,
            value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil.errToObj;
    return new ZodObject2({
      ...this._def,
      unknownKeys: "strict",
      ...message !== void 0 ? {
        errorMap: (issue2, ctx) => {
          var _a3, _b;
          const defaultError = ((_b = (_a3 = this._def).errorMap) == null ? void 0 : _b.call(_a3, issue2, ctx).message) ?? ctx.defaultError;
          if (issue2.code === "unrecognized_keys")
            return {
              message: errorUtil.errToObj(message).message ?? defaultError
            };
          return {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new ZodObject2({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new ZodObject2({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(augmentation) {
    return new ZodObject2({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(merging) {
    const merged = new ZodObject2({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind.ZodObject
    });
    return merged;
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(key, schema) {
    return this.augment({ [key]: schema });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(index) {
    return new ZodObject2({
      ...this._def,
      catchall: index
    });
  }
  pick(mask) {
    const shape = {};
    for (const key of util.objectKeys(mask)) {
      if (mask[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    }
    return new ZodObject2({
      ...this._def,
      shape: () => shape
    });
  }
  omit(mask) {
    const shape = {};
    for (const key of util.objectKeys(this.shape)) {
      if (!mask[key]) {
        shape[key] = this.shape[key];
      }
    }
    return new ZodObject2({
      ...this._def,
      shape: () => shape
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return deepPartialify(this);
  }
  partial(mask) {
    const newShape = {};
    for (const key of util.objectKeys(this.shape)) {
      const fieldSchema = this.shape[key];
      if (mask && !mask[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema.optional();
      }
    }
    return new ZodObject2({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask) {
    const newShape = {};
    for (const key of util.objectKeys(this.shape)) {
      if (mask && !mask[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional$1) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    }
    return new ZodObject2({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum(util.objectKeys(this.shape));
  }
};
ZodObject$1.create = (shape, params) => {
  return new ZodObject$1({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever$1.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject$1.strictCreate = (shape, params) => {
  return new ZodObject$1({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever$1.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject$1.lazycreate = (shape, params) => {
  return new ZodObject$1({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever$1.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
let ZodUnion$1 = class ZodUnion2 extends ZodType$1 {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options2 = this._def.options;
    function handleResults(results2) {
      for (const result of results2) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results2) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results2.map((result) => new ZodError(result.ctx.common.issues));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return Promise.all(options2.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = void 0;
      const issues = [];
      for (const option of options2) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError(issues2));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
};
ZodUnion$1.create = (types, params) => {
  return new ZodUnion$1({
    options: types,
    typeName: ZodFirstPartyTypeKind.ZodUnion,
    ...processCreateParams(params)
  });
};
function mergeValues(a, b) {
  const aType = getParsedType(a);
  const bType = getParsedType(b);
  if (a === b) {
    return { valid: true, data: a };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b);
    const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a[key], b[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a.length !== b.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index = 0; index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {
    return { valid: true, data: a };
  } else {
    return { valid: false };
  }
}
let ZodIntersection$1 = class ZodIntersection2 extends ZodType$1 {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
        return INVALID;
      }
      const merged = mergeValues(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_intersection_types
        });
        return INVALID;
      }
      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    };
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
};
ZodIntersection$1.create = (left, right, params) => {
  return new ZodIntersection$1({
    left,
    right,
    typeName: ZodFirstPartyTypeKind.ZodIntersection,
    ...processCreateParams(params)
  });
};
class ZodTuple extends ZodType$1 {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
    }).filter((x) => !!x);
    if (ctx.common.async) {
      return Promise.all(items).then((results2) => {
        return ParseStatus.mergeArray(status, results2);
      });
    } else {
      return ParseStatus.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new ZodTuple({
      ...this._def,
      rest
    });
  }
}
ZodTuple.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple({
    items: schemas,
    typeName: ZodFirstPartyTypeKind.ZodTuple,
    rest: null,
    ...processCreateParams(params)
  });
};
class ZodMap extends ZodType$1 {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.map) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key, value], index) => {
      return {
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
        value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = /* @__PURE__ */ new Map();
      for (const pair of pairs) {
        const key = pair.key;
        const value = pair.value;
        if (key.status === "aborted" || value.status === "aborted") {
          return INVALID;
        }
        if (key.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
}
ZodMap.create = (keyType, valueType, params) => {
  return new ZodMap({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind.ZodMap,
    ...processCreateParams(params)
  });
};
class ZodSet extends ZodType$1 {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.set) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.minSize.message
        });
        status.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = /* @__PURE__ */ new Set();
      for (const element of elements2) {
        if (element.status === "aborted")
          return INVALID;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    const elements = [...ctx.data.values()].map((item, i2) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i2)));
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message) {
    return new ZodSet({
      ...this._def,
      minSize: { value: minSize, message: errorUtil.toString(message) }
    });
  }
  max(maxSize, message) {
    return new ZodSet({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil.toString(message) }
    });
  }
  size(size, message) {
    return this.min(size, message).max(size, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
}
ZodSet.create = (valueType, params) => {
  return new ZodSet({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind.ZodSet,
    ...processCreateParams(params)
  });
};
class ZodLazy extends ZodType$1 {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
}
ZodLazy.create = (getter, params) => {
  return new ZodLazy({
    getter,
    typeName: ZodFirstPartyTypeKind.ZodLazy,
    ...processCreateParams(params)
  });
};
class ZodLiteral extends ZodType$1 {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
}
ZodLiteral.create = (value, params) => {
  return new ZodLiteral({
    value,
    typeName: ZodFirstPartyTypeKind.ZodLiteral,
    ...processCreateParams(params)
  });
};
function createZodEnum(values, params) {
  return new ZodEnum$1({
    values,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
}
let ZodEnum$1 = class ZodEnum2 extends ZodType$1 {
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!this._cache) {
      this._cache = new Set(this._def.values);
    }
    if (!this._cache.has(input.data)) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values, newDef = this._def) {
    return ZodEnum2.create(values, {
      ...this._def,
      ...newDef
    });
  }
  exclude(values, newDef = this._def) {
    return ZodEnum2.create(this.options.filter((opt) => !values.includes(opt)), {
      ...this._def,
      ...newDef
    });
  }
};
ZodEnum$1.create = createZodEnum;
class ZodNativeEnum extends ZodType$1 {
  _parse(input) {
    const nativeEnumValues = util.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!this._cache) {
      this._cache = new Set(util.getValidEnumValues(this._def.values));
    }
    if (!this._cache.has(input.data)) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get enum() {
    return this._def.values;
  }
}
ZodNativeEnum.create = (values, params) => {
  return new ZodNativeEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
    ...processCreateParams(params)
  });
};
class ZodPromise extends ZodType$1 {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
}
ZodPromise.create = (schema, params) => {
  return new ZodPromise({
    type: schema,
    typeName: ZodFirstPartyTypeKind.ZodPromise,
    ...processCreateParams(params)
  });
};
class ZodEffects extends ZodType$1 {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.async) {
        return Promise.resolve(processed).then(async (processed2) => {
          if (status.value === "aborted")
            return INVALID;
          const result = await this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
          if (result.status === "aborted")
            return INVALID;
          if (result.status === "dirty")
            return DIRTY(result.value);
          if (status.value === "dirty")
            return DIRTY(result.value);
          return result;
        });
      } else {
        if (status.value === "aborted")
          return INVALID;
        const result = this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
        if (result.status === "aborted")
          return INVALID;
        if (result.status === "dirty")
          return DIRTY(result.value);
        if (status.value === "dirty")
          return DIRTY(result.value);
        return result;
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = (acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      };
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid(base))
          return INVALID;
        const result = effect.transform(base.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
          if (!isValid(base))
            return INVALID;
          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({
            status: status.value,
            value: result
          }));
        });
      }
    }
    util.assertNever(effect);
  }
}
ZodEffects.create = (schema, effect, params) => {
  return new ZodEffects({
    schema,
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    effect,
    ...processCreateParams(params)
  });
};
ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
  return new ZodEffects({
    schema,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    ...processCreateParams(params)
  });
};
let ZodOptional$1 = class ZodOptional2 extends ZodType$1 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.undefined) {
      return OK(void 0);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodOptional$1.create = (type, params) => {
  return new ZodOptional$1({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodOptional,
    ...processCreateParams(params)
  });
};
let ZodNullable$1 = class ZodNullable2 extends ZodType$1 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.null) {
      return OK(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodNullable$1.create = (type, params) => {
  return new ZodNullable$1({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodNullable,
    ...processCreateParams(params)
  });
};
let ZodDefault$1 = class ZodDefault2 extends ZodType$1 {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
};
ZodDefault$1.create = (type, params) => {
  return new ZodDefault$1({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams(params)
  });
};
let ZodCatch$1 = class ZodCatch2 extends ZodType$1 {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
};
ZodCatch$1.create = (type, params) => {
  return new ZodCatch$1({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams(params)
  });
};
class ZodNaN extends ZodType$1 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
}
ZodNaN.create = (params) => {
  return new ZodNaN({
    typeName: ZodFirstPartyTypeKind.ZodNaN,
    ...processCreateParams(params)
  });
};
class ZodBranded extends ZodType$1 {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
}
class ZodPipeline extends ZodType$1 {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      };
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a, b) {
    return new ZodPipeline({
      in: a,
      out: b,
      typeName: ZodFirstPartyTypeKind.ZodPipeline
    });
  }
}
let ZodReadonly$1 = class ZodReadonly2 extends ZodType$1 {
  _parse(input) {
    const result = this._def.innerType._parse(input);
    const freeze = (data) => {
      if (isValid(data)) {
        data.value = Object.freeze(data.value);
      }
      return data;
    };
    return isAsync(result) ? result.then((data) => freeze(data)) : freeze(result);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodReadonly$1.create = (type, params) => {
  return new ZodReadonly$1({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodReadonly,
    ...processCreateParams(params)
  });
};
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
const stringType = ZodString$1.create;
const anyType = ZodAny$1.create;
ZodNever$1.create;
ZodArray$1.create;
const objectType = ZodObject$1.create;
ZodUnion$1.create;
ZodIntersection$1.create;
ZodTuple.create;
ZodEnum$1.create;
ZodPromise.create;
ZodOptional$1.create;
ZodNullable$1.create;
function parseArrayDef$1(def, refs) {
  var _a3, _b, _c;
  const res = { type: "array" };
  if (((_a3 = def.type) == null ? void 0 : _a3._def) && ((_c = (_b = def.type) == null ? void 0 : _b._def) == null ? void 0 : _c.typeName) !== ZodFirstPartyTypeKind.ZodAny) res.items = parseDef$1(def.type._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items"]
  });
  if (def.minLength) setResponseValueAndErrors$1(res, "minItems", def.minLength.value, def.minLength.message, refs);
  if (def.maxLength) setResponseValueAndErrors$1(res, "maxItems", def.maxLength.value, def.maxLength.message, refs);
  if (def.exactLength) {
    setResponseValueAndErrors$1(res, "minItems", def.exactLength.value, def.exactLength.message, refs);
    setResponseValueAndErrors$1(res, "maxItems", def.exactLength.value, def.exactLength.message, refs);
  }
  return res;
}
function parseBigintDef$1(def, refs) {
  const res = {
    type: "integer",
    format: "int64"
  };
  if (!def.checks) return res;
  for (const check of def.checks) switch (check.kind) {
    case "min":
      if (refs.target === "jsonSchema7") if (check.inclusive) setResponseValueAndErrors$1(res, "minimum", check.value, check.message, refs);
      else setResponseValueAndErrors$1(res, "exclusiveMinimum", check.value, check.message, refs);
      else {
        if (!check.inclusive) res.exclusiveMinimum = true;
        setResponseValueAndErrors$1(res, "minimum", check.value, check.message, refs);
      }
      break;
    case "max":
      if (refs.target === "jsonSchema7") if (check.inclusive) setResponseValueAndErrors$1(res, "maximum", check.value, check.message, refs);
      else setResponseValueAndErrors$1(res, "exclusiveMaximum", check.value, check.message, refs);
      else {
        if (!check.inclusive) res.exclusiveMaximum = true;
        setResponseValueAndErrors$1(res, "maximum", check.value, check.message, refs);
      }
      break;
    case "multipleOf":
      setResponseValueAndErrors$1(res, "multipleOf", check.value, check.message, refs);
      break;
  }
  return res;
}
function parseBooleanDef$1() {
  return { type: "boolean" };
}
function parseBrandedDef$1(_def, refs) {
  return parseDef$1(_def.type._def, refs);
}
const parseCatchDef$1 = (def, refs) => {
  return parseDef$1(def.innerType._def, refs);
};
function parseDateDef$1(def, refs, overrideDateStrategy) {
  const strategy = overrideDateStrategy ?? refs.dateStrategy;
  if (Array.isArray(strategy)) return { anyOf: strategy.map((item) => parseDateDef$1(def, refs, item)) };
  switch (strategy) {
    case "string":
    case "format:date-time":
      return {
        type: "string",
        format: "date-time"
      };
    case "format:date":
      return {
        type: "string",
        format: "date"
      };
    case "integer":
      return integerDateParser$1(def, refs);
  }
}
const integerDateParser$1 = (def, refs) => {
  const res = {
    type: "integer",
    format: "unix-time"
  };
  if (refs.target === "openApi3") return res;
  for (const check of def.checks) switch (check.kind) {
    case "min":
      setResponseValueAndErrors$1(res, "minimum", check.value, check.message, refs);
      break;
    case "max":
      setResponseValueAndErrors$1(res, "maximum", check.value, check.message, refs);
      break;
  }
  return res;
};
function parseDefaultDef$1(_def, refs) {
  return {
    ...parseDef$1(_def.innerType._def, refs),
    default: _def.defaultValue()
  };
}
function parseEffectsDef$1(_def, refs) {
  return refs.effectStrategy === "input" ? parseDef$1(_def.schema._def, refs) : parseAnyDef$1(refs);
}
function parseEnumDef$1(def) {
  return {
    type: "string",
    enum: Array.from(def.values)
  };
}
const isJsonSchema7AllOfType$1 = (type) => {
  if ("type" in type && type.type === "string") return false;
  return "allOf" in type;
};
function parseIntersectionDef$1(def, refs) {
  const allOf = [parseDef$1(def.left._def, {
    ...refs,
    currentPath: [
      ...refs.currentPath,
      "allOf",
      "0"
    ]
  }), parseDef$1(def.right._def, {
    ...refs,
    currentPath: [
      ...refs.currentPath,
      "allOf",
      "1"
    ]
  })].filter((x) => !!x);
  let unevaluatedProperties = refs.target === "jsonSchema2019-09" ? { unevaluatedProperties: false } : void 0;
  const mergedAllOf = [];
  allOf.forEach((schema) => {
    if (isJsonSchema7AllOfType$1(schema)) {
      mergedAllOf.push(...schema.allOf);
      if (schema.unevaluatedProperties === void 0) unevaluatedProperties = void 0;
    } else {
      let nestedSchema = schema;
      if ("additionalProperties" in schema && schema.additionalProperties === false) {
        const { additionalProperties, ...rest } = schema;
        nestedSchema = rest;
      } else unevaluatedProperties = void 0;
      mergedAllOf.push(nestedSchema);
    }
  });
  return mergedAllOf.length ? {
    allOf: mergedAllOf,
    ...unevaluatedProperties
  } : void 0;
}
function parseLiteralDef$1(def, refs) {
  const parsedType = typeof def.value;
  if (parsedType !== "bigint" && parsedType !== "number" && parsedType !== "boolean" && parsedType !== "string") return { type: Array.isArray(def.value) ? "array" : "object" };
  if (refs.target === "openApi3") return {
    type: parsedType === "bigint" ? "integer" : parsedType,
    enum: [def.value]
  };
  return {
    type: parsedType === "bigint" ? "integer" : parsedType,
    const: def.value
  };
}
let emojiRegex$1 = void 0;
const zodPatterns$1 = {
  cuid: /^[cC][^\s-]{8,}$/,
  cuid2: /^[0-9a-z]+$/,
  ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,
  email: /^(?!\.)(?!.*\.\.)([a-zA-Z0-9_'+\-\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\-]*\.)+[a-zA-Z]{2,}$/,
  emoji: () => {
    if (emojiRegex$1 === void 0) emojiRegex$1 = RegExp("^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$", "u");
    return emojiRegex$1;
  },
  uuid: /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/,
  ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
  ipv4Cidr: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/,
  ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,
  ipv6Cidr: /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,
  base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
  base64url: /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,
  nanoid: /^[a-zA-Z0-9_-]{21}$/,
  jwt: /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/
};
function parseStringDef$1(def, refs) {
  const res = { type: "string" };
  if (def.checks) for (const check of def.checks) switch (check.kind) {
    case "min":
      setResponseValueAndErrors$1(res, "minLength", typeof res.minLength === "number" ? Math.max(res.minLength, check.value) : check.value, check.message, refs);
      break;
    case "max":
      setResponseValueAndErrors$1(res, "maxLength", typeof res.maxLength === "number" ? Math.min(res.maxLength, check.value) : check.value, check.message, refs);
      break;
    case "email":
      switch (refs.emailStrategy) {
        case "format:email":
          addFormat$1(res, "email", check.message, refs);
          break;
        case "format:idn-email":
          addFormat$1(res, "idn-email", check.message, refs);
          break;
        case "pattern:zod":
          addPattern$1(res, zodPatterns$1.email, check.message, refs);
          break;
      }
      break;
    case "url":
      addFormat$1(res, "uri", check.message, refs);
      break;
    case "uuid":
      addFormat$1(res, "uuid", check.message, refs);
      break;
    case "regex":
      addPattern$1(res, check.regex, check.message, refs);
      break;
    case "cuid":
      addPattern$1(res, zodPatterns$1.cuid, check.message, refs);
      break;
    case "cuid2":
      addPattern$1(res, zodPatterns$1.cuid2, check.message, refs);
      break;
    case "startsWith":
      addPattern$1(res, RegExp(`^${escapeLiteralCheckValue(check.value, refs)}`), check.message, refs);
      break;
    case "endsWith":
      addPattern$1(res, RegExp(`${escapeLiteralCheckValue(check.value, refs)}$`), check.message, refs);
      break;
    case "datetime":
      addFormat$1(res, "date-time", check.message, refs);
      break;
    case "date":
      addFormat$1(res, "date", check.message, refs);
      break;
    case "time":
      addFormat$1(res, "time", check.message, refs);
      break;
    case "duration":
      addFormat$1(res, "duration", check.message, refs);
      break;
    case "length":
      setResponseValueAndErrors$1(res, "minLength", typeof res.minLength === "number" ? Math.max(res.minLength, check.value) : check.value, check.message, refs);
      setResponseValueAndErrors$1(res, "maxLength", typeof res.maxLength === "number" ? Math.min(res.maxLength, check.value) : check.value, check.message, refs);
      break;
    case "includes":
      addPattern$1(res, RegExp(escapeLiteralCheckValue(check.value, refs)), check.message, refs);
      break;
    case "ip":
      if (check.version !== "v6") addFormat$1(res, "ipv4", check.message, refs);
      if (check.version !== "v4") addFormat$1(res, "ipv6", check.message, refs);
      break;
    case "base64url":
      addPattern$1(res, zodPatterns$1.base64url, check.message, refs);
      break;
    case "jwt":
      addPattern$1(res, zodPatterns$1.jwt, check.message, refs);
      break;
    case "cidr":
      if (check.version !== "v6") addPattern$1(res, zodPatterns$1.ipv4Cidr, check.message, refs);
      if (check.version !== "v4") addPattern$1(res, zodPatterns$1.ipv6Cidr, check.message, refs);
      break;
    case "emoji":
      addPattern$1(res, zodPatterns$1.emoji(), check.message, refs);
      break;
    case "ulid":
      addPattern$1(res, zodPatterns$1.ulid, check.message, refs);
      break;
    case "base64":
      switch (refs.base64Strategy) {
        case "format:binary":
          addFormat$1(res, "binary", check.message, refs);
          break;
        case "contentEncoding:base64":
          setResponseValueAndErrors$1(res, "contentEncoding", "base64", check.message, refs);
          break;
        case "pattern:zod":
          addPattern$1(res, zodPatterns$1.base64, check.message, refs);
          break;
      }
      break;
    case "nanoid":
      addPattern$1(res, zodPatterns$1.nanoid, check.message, refs);
      break;
  }
  return res;
}
function escapeLiteralCheckValue(literal, refs) {
  return refs.patternStrategy === "escape" ? escapeNonAlphaNumeric$1(literal) : literal;
}
const ALPHA_NUMERIC = /* @__PURE__ */ new Set("ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789");
function escapeNonAlphaNumeric$1(source) {
  let result = "";
  for (let i2 = 0; i2 < source.length; i2++) {
    if (!ALPHA_NUMERIC.has(source[i2])) result += "\\";
    result += source[i2];
  }
  return result;
}
function addFormat$1(schema, value, message, refs) {
  var _a3;
  if (schema.format || ((_a3 = schema.anyOf) == null ? void 0 : _a3.some((x) => x.format))) {
    if (!schema.anyOf) schema.anyOf = [];
    if (schema.format) {
      schema.anyOf.push({
        format: schema.format,
        ...schema.errorMessage && refs.errorMessages && { errorMessage: { format: schema.errorMessage.format } }
      });
      delete schema.format;
      if (schema.errorMessage) {
        delete schema.errorMessage.format;
        if (Object.keys(schema.errorMessage).length === 0) delete schema.errorMessage;
      }
    }
    schema.anyOf.push({
      format: value,
      ...message && refs.errorMessages && { errorMessage: { format: message } }
    });
  } else setResponseValueAndErrors$1(schema, "format", value, message, refs);
}
function addPattern$1(schema, regex2, message, refs) {
  var _a3;
  if (schema.pattern || ((_a3 = schema.allOf) == null ? void 0 : _a3.some((x) => x.pattern))) {
    if (!schema.allOf) schema.allOf = [];
    if (schema.pattern) {
      schema.allOf.push({
        pattern: schema.pattern,
        ...schema.errorMessage && refs.errorMessages && { errorMessage: { pattern: schema.errorMessage.pattern } }
      });
      delete schema.pattern;
      if (schema.errorMessage) {
        delete schema.errorMessage.pattern;
        if (Object.keys(schema.errorMessage).length === 0) delete schema.errorMessage;
      }
    }
    schema.allOf.push({
      pattern: stringifyRegExpWithFlags(regex2, refs),
      ...message && refs.errorMessages && { errorMessage: { pattern: message } }
    });
  } else setResponseValueAndErrors$1(schema, "pattern", stringifyRegExpWithFlags(regex2, refs), message, refs);
}
function stringifyRegExpWithFlags(regex2, refs) {
  var _a3;
  if (!refs.applyRegexFlags || !regex2.flags) return regex2.source;
  const flags = {
    i: regex2.flags.includes("i"),
    m: regex2.flags.includes("m"),
    s: regex2.flags.includes("s")
  };
  const source = flags.i ? regex2.source.toLowerCase() : regex2.source;
  let pattern = "";
  let isEscaped = false;
  let inCharGroup = false;
  let inCharRange = false;
  for (let i2 = 0; i2 < source.length; i2++) {
    if (isEscaped) {
      pattern += source[i2];
      isEscaped = false;
      continue;
    }
    if (flags.i) {
      if (inCharGroup) {
        if (source[i2].match(/[a-z]/)) {
          if (inCharRange) {
            pattern += source[i2];
            pattern += `${source[i2 - 2]}-${source[i2]}`.toUpperCase();
            inCharRange = false;
          } else if (source[i2 + 1] === "-" && ((_a3 = source[i2 + 2]) == null ? void 0 : _a3.match(/[a-z]/))) {
            pattern += source[i2];
            inCharRange = true;
          } else pattern += `${source[i2]}${source[i2].toUpperCase()}`;
          continue;
        }
      } else if (source[i2].match(/[a-z]/)) {
        pattern += `[${source[i2]}${source[i2].toUpperCase()}]`;
        continue;
      }
    }
    if (flags.m) {
      if (source[i2] === "^") {
        pattern += `(^|(?<=[\r
]))`;
        continue;
      } else if (source[i2] === "$") {
        pattern += `($|(?=[\r
]))`;
        continue;
      }
    }
    if (flags.s && source[i2] === ".") {
      pattern += inCharGroup ? `${source[i2]}\r
` : `[${source[i2]}\r
]`;
      continue;
    }
    pattern += source[i2];
    if (source[i2] === "\\") isEscaped = true;
    else if (inCharGroup && source[i2] === "]") inCharGroup = false;
    else if (!inCharGroup && source[i2] === "[") inCharGroup = true;
  }
  try {
    new RegExp(pattern);
  } catch {
    console.warn(`Could not convert regex pattern at ${refs.currentPath.join("/")} to a flag-independent form! Falling back to the flag-ignorant source`);
    return regex2.source;
  }
  return pattern;
}
function parseRecordDef$1(def, refs) {
  var _a3, _b, _c, _d, _e, _f;
  if (refs.target === "openAi") console.warn("Warning: OpenAI may not support records in schemas! Try an array of key-value pairs instead.");
  if (refs.target === "openApi3" && ((_a3 = def.keyType) == null ? void 0 : _a3._def.typeName) === ZodFirstPartyTypeKind.ZodEnum) return {
    type: "object",
    required: def.keyType._def.values,
    properties: def.keyType._def.values.reduce((acc, key) => ({
      ...acc,
      [key]: parseDef$1(def.valueType._def, {
        ...refs,
        currentPath: [
          ...refs.currentPath,
          "properties",
          key
        ]
      }) ?? parseAnyDef$1(refs)
    }), {}),
    additionalProperties: refs.rejectedAdditionalProperties
  };
  const schema = {
    type: "object",
    additionalProperties: parseDef$1(def.valueType._def, {
      ...refs,
      currentPath: [...refs.currentPath, "additionalProperties"]
    }) ?? refs.allowedAdditionalProperties
  };
  if (refs.target === "openApi3") return schema;
  if (((_b = def.keyType) == null ? void 0 : _b._def.typeName) === ZodFirstPartyTypeKind.ZodString && ((_c = def.keyType._def.checks) == null ? void 0 : _c.length)) {
    const { type, ...keyType } = parseStringDef$1(def.keyType._def, refs);
    return {
      ...schema,
      propertyNames: keyType
    };
  } else if (((_d = def.keyType) == null ? void 0 : _d._def.typeName) === ZodFirstPartyTypeKind.ZodEnum) return {
    ...schema,
    propertyNames: { enum: def.keyType._def.values }
  };
  else if (((_e = def.keyType) == null ? void 0 : _e._def.typeName) === ZodFirstPartyTypeKind.ZodBranded && def.keyType._def.type._def.typeName === ZodFirstPartyTypeKind.ZodString && ((_f = def.keyType._def.type._def.checks) == null ? void 0 : _f.length)) {
    const { type, ...keyType } = parseBrandedDef$1(def.keyType._def, refs);
    return {
      ...schema,
      propertyNames: keyType
    };
  }
  return schema;
}
function parseMapDef$1(def, refs) {
  if (refs.mapStrategy === "record") return parseRecordDef$1(def, refs);
  const keys = parseDef$1(def.keyType._def, {
    ...refs,
    currentPath: [
      ...refs.currentPath,
      "items",
      "items",
      "0"
    ]
  }) || parseAnyDef$1(refs);
  const values = parseDef$1(def.valueType._def, {
    ...refs,
    currentPath: [
      ...refs.currentPath,
      "items",
      "items",
      "1"
    ]
  }) || parseAnyDef$1(refs);
  return {
    type: "array",
    maxItems: 125,
    items: {
      type: "array",
      items: [keys, values],
      minItems: 2,
      maxItems: 2
    }
  };
}
function parseNativeEnumDef$1(def) {
  const object2 = def.values;
  const actualKeys = Object.keys(def.values).filter((key) => {
    return typeof object2[object2[key]] !== "number";
  });
  const actualValues = actualKeys.map((key) => object2[key]);
  const parsedTypes = Array.from(new Set(actualValues.map((values) => typeof values)));
  return {
    type: parsedTypes.length === 1 ? parsedTypes[0] === "string" ? "string" : "number" : ["string", "number"],
    enum: actualValues
  };
}
function parseNeverDef$1(refs) {
  return refs.target === "openAi" ? void 0 : { not: parseAnyDef$1({
    ...refs,
    currentPath: [...refs.currentPath, "not"]
  }) };
}
function parseNullDef$1(refs) {
  return refs.target === "openApi3" ? {
    enum: ["null"],
    nullable: true
  } : { type: "null" };
}
const primitiveMappings$1 = {
  ZodString: "string",
  ZodNumber: "number",
  ZodBigInt: "integer",
  ZodBoolean: "boolean",
  ZodNull: "null"
};
function parseUnionDef$1(def, refs) {
  if (refs.target === "openApi3") return asAnyOf$1(def, refs);
  const options2 = def.options instanceof Map ? Array.from(def.options.values()) : def.options;
  if (options2.every((x) => x._def.typeName in primitiveMappings$1 && (!x._def.checks || !x._def.checks.length))) {
    const types = options2.reduce((types$1, x) => {
      const type = primitiveMappings$1[x._def.typeName];
      return type && !types$1.includes(type) ? [...types$1, type] : types$1;
    }, []);
    return { type: types.length > 1 ? types : types[0] };
  } else if (options2.every((x) => x._def.typeName === "ZodLiteral" && !x.description)) {
    const types = options2.reduce((acc, x) => {
      const type = typeof x._def.value;
      switch (type) {
        case "string":
        case "number":
        case "boolean":
          return [...acc, type];
        case "bigint":
          return [...acc, "integer"];
        case "object":
          if (x._def.value === null) return [...acc, "null"];
          return acc;
        case "symbol":
        case "undefined":
        case "function":
        default:
          return acc;
      }
    }, []);
    if (types.length === options2.length) {
      const uniqueTypes = types.filter((x, i2, a) => a.indexOf(x) === i2);
      return {
        type: uniqueTypes.length > 1 ? uniqueTypes : uniqueTypes[0],
        enum: options2.reduce((acc, x) => {
          return acc.includes(x._def.value) ? acc : [...acc, x._def.value];
        }, [])
      };
    }
  } else if (options2.every((x) => x._def.typeName === "ZodEnum")) return {
    type: "string",
    enum: options2.reduce((acc, x) => [...acc, ...x._def.values.filter((x$1) => !acc.includes(x$1))], [])
  };
  return asAnyOf$1(def, refs);
}
const asAnyOf$1 = (def, refs) => {
  const anyOf = (def.options instanceof Map ? Array.from(def.options.values()) : def.options).map((x, i2) => parseDef$1(x._def, {
    ...refs,
    currentPath: [
      ...refs.currentPath,
      "anyOf",
      `${i2}`
    ]
  })).filter((x) => !!x && (!refs.strictUnions || typeof x === "object" && Object.keys(x).length > 0));
  return anyOf.length ? { anyOf } : void 0;
};
function parseNullableDef$1(def, refs) {
  if ([
    "ZodString",
    "ZodNumber",
    "ZodBigInt",
    "ZodBoolean",
    "ZodNull"
  ].includes(def.innerType._def.typeName) && (!def.innerType._def.checks || !def.innerType._def.checks.length)) {
    if (refs.target === "openApi3") return {
      type: primitiveMappings$1[def.innerType._def.typeName],
      nullable: true
    };
    return { type: [primitiveMappings$1[def.innerType._def.typeName], "null"] };
  }
  if (refs.target === "openApi3") {
    const base$1 = parseDef$1(def.innerType._def, {
      ...refs,
      currentPath: [...refs.currentPath]
    });
    if (base$1 && "$ref" in base$1) return {
      allOf: [base$1],
      nullable: true
    };
    return base$1 && {
      ...base$1,
      nullable: true
    };
  }
  const base = parseDef$1(def.innerType._def, {
    ...refs,
    currentPath: [
      ...refs.currentPath,
      "anyOf",
      "0"
    ]
  });
  return base && { anyOf: [base, { type: "null" }] };
}
function parseNumberDef$1(def, refs) {
  const res = { type: "number" };
  if (!def.checks) return res;
  for (const check of def.checks) switch (check.kind) {
    case "int":
      res.type = "integer";
      addErrorMessage$1(res, "type", check.message, refs);
      break;
    case "min":
      if (refs.target === "jsonSchema7") if (check.inclusive) setResponseValueAndErrors$1(res, "minimum", check.value, check.message, refs);
      else setResponseValueAndErrors$1(res, "exclusiveMinimum", check.value, check.message, refs);
      else {
        if (!check.inclusive) res.exclusiveMinimum = true;
        setResponseValueAndErrors$1(res, "minimum", check.value, check.message, refs);
      }
      break;
    case "max":
      if (refs.target === "jsonSchema7") if (check.inclusive) setResponseValueAndErrors$1(res, "maximum", check.value, check.message, refs);
      else setResponseValueAndErrors$1(res, "exclusiveMaximum", check.value, check.message, refs);
      else {
        if (!check.inclusive) res.exclusiveMaximum = true;
        setResponseValueAndErrors$1(res, "maximum", check.value, check.message, refs);
      }
      break;
    case "multipleOf":
      setResponseValueAndErrors$1(res, "multipleOf", check.value, check.message, refs);
      break;
  }
  return res;
}
function parseObjectDef$1(def, refs) {
  const forceOptionalIntoNullable = refs.target === "openAi";
  const result = {
    type: "object",
    properties: {}
  };
  const required2 = [];
  const shape = def.shape();
  for (const propName in shape) {
    let propDef = shape[propName];
    if (propDef === void 0 || propDef._def === void 0) continue;
    let propOptional = safeIsOptional(propDef);
    if (propOptional && forceOptionalIntoNullable) {
      if (propDef._def.typeName === "ZodOptional") propDef = propDef._def.innerType;
      if (!propDef.isNullable()) propDef = propDef.nullable();
      propOptional = false;
    }
    const parsedDef = parseDef$1(propDef._def, {
      ...refs,
      currentPath: [
        ...refs.currentPath,
        "properties",
        propName
      ],
      propertyPath: [
        ...refs.currentPath,
        "properties",
        propName
      ]
    });
    if (parsedDef === void 0) continue;
    result.properties[propName] = parsedDef;
    if (!propOptional) required2.push(propName);
  }
  if (required2.length) result.required = required2;
  const additionalProperties = decideAdditionalProperties$1(def, refs);
  if (additionalProperties !== void 0) result.additionalProperties = additionalProperties;
  return result;
}
function decideAdditionalProperties$1(def, refs) {
  if (def.catchall._def.typeName !== "ZodNever") return parseDef$1(def.catchall._def, {
    ...refs,
    currentPath: [...refs.currentPath, "additionalProperties"]
  });
  switch (def.unknownKeys) {
    case "passthrough":
      return refs.allowedAdditionalProperties;
    case "strict":
      return refs.rejectedAdditionalProperties;
    case "strip":
      return refs.removeAdditionalStrategy === "strict" ? refs.allowedAdditionalProperties : refs.rejectedAdditionalProperties;
  }
}
function safeIsOptional(schema) {
  try {
    return schema.isOptional();
  } catch {
    return true;
  }
}
const parseOptionalDef$1 = (def, refs) => {
  var _a3;
  if (refs.currentPath.toString() === ((_a3 = refs.propertyPath) == null ? void 0 : _a3.toString())) return parseDef$1(def.innerType._def, refs);
  const innerSchema = parseDef$1(def.innerType._def, {
    ...refs,
    currentPath: [
      ...refs.currentPath,
      "anyOf",
      "1"
    ]
  });
  return innerSchema ? { anyOf: [{ not: parseAnyDef$1(refs) }, innerSchema] } : parseAnyDef$1(refs);
};
const parsePipelineDef$1 = (def, refs) => {
  if (refs.pipeStrategy === "input") return parseDef$1(def.in._def, refs);
  else if (refs.pipeStrategy === "output") return parseDef$1(def.out._def, refs);
  const a = parseDef$1(def.in._def, {
    ...refs,
    currentPath: [
      ...refs.currentPath,
      "allOf",
      "0"
    ]
  });
  const b = parseDef$1(def.out._def, {
    ...refs,
    currentPath: [
      ...refs.currentPath,
      "allOf",
      a ? "1" : "0"
    ]
  });
  return { allOf: [a, b].filter((x) => x !== void 0) };
};
function parsePromiseDef$1(def, refs) {
  return parseDef$1(def.type._def, refs);
}
function parseSetDef$1(def, refs) {
  const items = parseDef$1(def.valueType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items"]
  });
  const schema = {
    type: "array",
    uniqueItems: true,
    items
  };
  if (def.minSize) setResponseValueAndErrors$1(schema, "minItems", def.minSize.value, def.minSize.message, refs);
  if (def.maxSize) setResponseValueAndErrors$1(schema, "maxItems", def.maxSize.value, def.maxSize.message, refs);
  return schema;
}
function parseTupleDef$1(def, refs) {
  if (def.rest) return {
    type: "array",
    minItems: def.items.length,
    items: def.items.map((x, i2) => parseDef$1(x._def, {
      ...refs,
      currentPath: [
        ...refs.currentPath,
        "items",
        `${i2}`
      ]
    })).reduce((acc, x) => x === void 0 ? acc : [...acc, x], []),
    additionalItems: parseDef$1(def.rest._def, {
      ...refs,
      currentPath: [...refs.currentPath, "additionalItems"]
    })
  };
  else return {
    type: "array",
    minItems: def.items.length,
    maxItems: def.items.length,
    items: def.items.map((x, i2) => parseDef$1(x._def, {
      ...refs,
      currentPath: [
        ...refs.currentPath,
        "items",
        `${i2}`
      ]
    })).reduce((acc, x) => x === void 0 ? acc : [...acc, x], [])
  };
}
function parseUndefinedDef$1(refs) {
  return { not: parseAnyDef$1(refs) };
}
function parseUnknownDef$1(refs) {
  return parseAnyDef$1(refs);
}
const parseReadonlyDef$1 = (def, refs) => {
  return parseDef$1(def.innerType._def, refs);
};
const selectParser$1 = (def, typeName, refs) => {
  switch (typeName) {
    case ZodFirstPartyTypeKind.ZodString:
      return parseStringDef$1(def, refs);
    case ZodFirstPartyTypeKind.ZodNumber:
      return parseNumberDef$1(def, refs);
    case ZodFirstPartyTypeKind.ZodObject:
      return parseObjectDef$1(def, refs);
    case ZodFirstPartyTypeKind.ZodBigInt:
      return parseBigintDef$1(def, refs);
    case ZodFirstPartyTypeKind.ZodBoolean:
      return parseBooleanDef$1();
    case ZodFirstPartyTypeKind.ZodDate:
      return parseDateDef$1(def, refs);
    case ZodFirstPartyTypeKind.ZodUndefined:
      return parseUndefinedDef$1(refs);
    case ZodFirstPartyTypeKind.ZodNull:
      return parseNullDef$1(refs);
    case ZodFirstPartyTypeKind.ZodArray:
      return parseArrayDef$1(def, refs);
    case ZodFirstPartyTypeKind.ZodUnion:
    case ZodFirstPartyTypeKind.ZodDiscriminatedUnion:
      return parseUnionDef$1(def, refs);
    case ZodFirstPartyTypeKind.ZodIntersection:
      return parseIntersectionDef$1(def, refs);
    case ZodFirstPartyTypeKind.ZodTuple:
      return parseTupleDef$1(def, refs);
    case ZodFirstPartyTypeKind.ZodRecord:
      return parseRecordDef$1(def, refs);
    case ZodFirstPartyTypeKind.ZodLiteral:
      return parseLiteralDef$1(def, refs);
    case ZodFirstPartyTypeKind.ZodEnum:
      return parseEnumDef$1(def);
    case ZodFirstPartyTypeKind.ZodNativeEnum:
      return parseNativeEnumDef$1(def);
    case ZodFirstPartyTypeKind.ZodNullable:
      return parseNullableDef$1(def, refs);
    case ZodFirstPartyTypeKind.ZodOptional:
      return parseOptionalDef$1(def, refs);
    case ZodFirstPartyTypeKind.ZodMap:
      return parseMapDef$1(def, refs);
    case ZodFirstPartyTypeKind.ZodSet:
      return parseSetDef$1(def, refs);
    case ZodFirstPartyTypeKind.ZodLazy:
      return () => def.getter()._def;
    case ZodFirstPartyTypeKind.ZodPromise:
      return parsePromiseDef$1(def, refs);
    case ZodFirstPartyTypeKind.ZodNaN:
    case ZodFirstPartyTypeKind.ZodNever:
      return parseNeverDef$1(refs);
    case ZodFirstPartyTypeKind.ZodEffects:
      return parseEffectsDef$1(def, refs);
    case ZodFirstPartyTypeKind.ZodAny:
      return parseAnyDef$1(refs);
    case ZodFirstPartyTypeKind.ZodUnknown:
      return parseUnknownDef$1(refs);
    case ZodFirstPartyTypeKind.ZodDefault:
      return parseDefaultDef$1(def, refs);
    case ZodFirstPartyTypeKind.ZodBranded:
      return parseBrandedDef$1(def, refs);
    case ZodFirstPartyTypeKind.ZodReadonly:
      return parseReadonlyDef$1(def, refs);
    case ZodFirstPartyTypeKind.ZodCatch:
      return parseCatchDef$1(def, refs);
    case ZodFirstPartyTypeKind.ZodPipeline:
      return parsePipelineDef$1(def, refs);
    case ZodFirstPartyTypeKind.ZodFunction:
    case ZodFirstPartyTypeKind.ZodVoid:
    case ZodFirstPartyTypeKind.ZodSymbol:
      return void 0;
    default:
      return /* @__PURE__ */ ((_) => void 0)();
  }
};
function parseDef$1(def, refs, forceResolution = false) {
  var _a3;
  const seenItem = refs.seen.get(def);
  if (refs.override) {
    const overrideResult = (_a3 = refs.override) == null ? void 0 : _a3.call(refs, def, refs, seenItem, forceResolution);
    if (overrideResult !== ignoreOverride$1) return overrideResult;
  }
  if (seenItem && !forceResolution) {
    const seenSchema = get$ref$1(seenItem, refs);
    if (seenSchema !== void 0) return seenSchema;
  }
  const newItem = {
    def,
    path: refs.currentPath,
    jsonSchema: void 0
  };
  refs.seen.set(def, newItem);
  const jsonSchemaOrGetter = selectParser$1(def, def.typeName, refs);
  const jsonSchema = typeof jsonSchemaOrGetter === "function" ? parseDef$1(jsonSchemaOrGetter(), refs) : jsonSchemaOrGetter;
  if (jsonSchema) addMeta$1(def, refs, jsonSchema);
  if (refs.postProcess) {
    const postProcessResult = refs.postProcess(jsonSchema, def, refs);
    newItem.jsonSchema = jsonSchema;
    return postProcessResult;
  }
  newItem.jsonSchema = jsonSchema;
  return jsonSchema;
}
const get$ref$1 = (item, refs) => {
  switch (refs.$refStrategy) {
    case "root":
      return { $ref: item.path.join("/") };
    case "relative":
      return { $ref: getRelativePath$1(refs.currentPath, item.path) };
    case "none":
    case "seen":
      if (item.path.length < refs.currentPath.length && item.path.every((value, index) => refs.currentPath[index] === value)) {
        console.warn(`Recursive reference detected at ${refs.currentPath.join("/")}! Defaulting to any`);
        return parseAnyDef$1(refs);
      }
      return refs.$refStrategy === "seen" ? parseAnyDef$1(refs) : void 0;
  }
};
const addMeta$1 = (def, refs, jsonSchema) => {
  if (def.description) {
    jsonSchema.description = def.description;
    if (refs.markdownDescription) jsonSchema.markdownDescription = def.description;
  }
  return jsonSchema;
};
const zodToJsonSchema$1 = (schema, options2) => {
  const refs = getRefs$1(options2);
  let definitions = void 0;
  const main2 = parseDef$1(schema._def, refs, false) ?? parseAnyDef$1(refs);
  if (refs.flags.hasReferencedOpenAiAnyType) {
    if (!definitions) definitions = {};
    if (!definitions[refs.openAiAnyTypeName]) definitions[refs.openAiAnyTypeName] = {
      type: [
        "string",
        "number",
        "integer",
        "boolean",
        "array",
        "null"
      ],
      items: { $ref: refs.$refStrategy === "relative" ? "1" : [
        ...refs.basePath,
        refs.definitionPath,
        refs.openAiAnyTypeName
      ].join("/") }
    };
  }
  const combined = definitions ? {
    ...main2,
    [refs.definitionPath]: definitions
  } : main2;
  if (refs.target === "jsonSchema7") combined.$schema = "http://json-schema.org/draft-07/schema#";
  else if (refs.target === "jsonSchema2019-09" || refs.target === "openAi") combined.$schema = "https://json-schema.org/draft/2019-09/schema#";
  if (refs.target === "openAi" && ("anyOf" in combined || "oneOf" in combined || "allOf" in combined || "type" in combined && Array.isArray(combined.type))) console.warn("Warning: OpenAI may not support schemas with unions as roots! Try wrapping it in an object property.");
  return combined;
};
function deepCompareStrict(a, b) {
  const typeofa = typeof a;
  if (typeofa !== typeof b) {
    return false;
  }
  if (Array.isArray(a)) {
    if (!Array.isArray(b)) {
      return false;
    }
    const length = a.length;
    if (length !== b.length) {
      return false;
    }
    for (let i2 = 0; i2 < length; i2++) {
      if (!deepCompareStrict(a[i2], b[i2])) {
        return false;
      }
    }
    return true;
  }
  if (typeofa === "object") {
    if (!a || !b) {
      return a === b;
    }
    const aKeys = Object.keys(a);
    const bKeys = Object.keys(b);
    const length = aKeys.length;
    if (length !== bKeys.length) {
      return false;
    }
    for (const k of aKeys) {
      if (!deepCompareStrict(a[k], b[k])) {
        return false;
      }
    }
    return true;
  }
  return a === b;
}
function encodePointer(p) {
  return encodeURI(escapePointer(p));
}
function escapePointer(p) {
  return p.replace(/~/g, "~0").replace(/\//g, "~1");
}
const schemaArrayKeyword = {
  prefixItems: true,
  items: true,
  allOf: true,
  anyOf: true,
  oneOf: true
};
const schemaMapKeyword = {
  $defs: true,
  definitions: true,
  properties: true,
  patternProperties: true,
  dependentSchemas: true
};
const ignoredKeyword = {
  id: true,
  $id: true,
  $ref: true,
  $schema: true,
  $anchor: true,
  $vocabulary: true,
  $comment: true,
  default: true,
  enum: true,
  const: true,
  required: true,
  type: true,
  maximum: true,
  minimum: true,
  exclusiveMaximum: true,
  exclusiveMinimum: true,
  multipleOf: true,
  maxLength: true,
  minLength: true,
  pattern: true,
  format: true,
  maxItems: true,
  minItems: true,
  uniqueItems: true,
  maxProperties: true,
  minProperties: true
};
let initialBaseURI = typeof self !== "undefined" && self.location && self.location.origin !== "null" ? new URL(self.location.origin + self.location.pathname + location.search) : new URL("https://github.com/cfworker");
function dereference(schema, lookup2 = /* @__PURE__ */ Object.create(null), baseURI = initialBaseURI, basePointer = "") {
  if (schema && typeof schema === "object" && !Array.isArray(schema)) {
    const id = schema.$id || schema.id;
    if (id) {
      const url = new URL(id, baseURI.href);
      if (url.hash.length > 1) {
        lookup2[url.href] = schema;
      } else {
        url.hash = "";
        if (basePointer === "") {
          baseURI = url;
        } else {
          dereference(schema, lookup2, baseURI);
        }
      }
    }
  } else if (schema !== true && schema !== false) {
    return lookup2;
  }
  const schemaURI = baseURI.href + (basePointer ? "#" + basePointer : "");
  if (lookup2[schemaURI] !== void 0) {
    throw new Error(`Duplicate schema URI "${schemaURI}".`);
  }
  lookup2[schemaURI] = schema;
  if (schema === true || schema === false) {
    return lookup2;
  }
  if (schema.__absolute_uri__ === void 0) {
    Object.defineProperty(schema, "__absolute_uri__", {
      enumerable: false,
      value: schemaURI
    });
  }
  if (schema.$ref && schema.__absolute_ref__ === void 0) {
    const url = new URL(schema.$ref, baseURI.href);
    url.hash = url.hash;
    Object.defineProperty(schema, "__absolute_ref__", {
      enumerable: false,
      value: url.href
    });
  }
  if (schema.$recursiveRef && schema.__absolute_recursive_ref__ === void 0) {
    const url = new URL(schema.$recursiveRef, baseURI.href);
    url.hash = url.hash;
    Object.defineProperty(schema, "__absolute_recursive_ref__", {
      enumerable: false,
      value: url.href
    });
  }
  if (schema.$anchor) {
    const url = new URL("#" + schema.$anchor, baseURI.href);
    lookup2[url.href] = schema;
  }
  for (let key in schema) {
    if (ignoredKeyword[key]) {
      continue;
    }
    const keyBase = `${basePointer}/${encodePointer(key)}`;
    const subSchema = schema[key];
    if (Array.isArray(subSchema)) {
      if (schemaArrayKeyword[key]) {
        const length = subSchema.length;
        for (let i2 = 0; i2 < length; i2++) {
          dereference(subSchema[i2], lookup2, baseURI, `${keyBase}/${i2}`);
        }
      }
    } else if (schemaMapKeyword[key]) {
      for (let subKey in subSchema) {
        dereference(subSchema[subKey], lookup2, baseURI, `${keyBase}/${encodePointer(subKey)}`);
      }
    } else {
      dereference(subSchema, lookup2, baseURI, keyBase);
    }
  }
  return lookup2;
}
const DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
const DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
const TIME = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d(?::?\d\d)?)?$/i;
const HOSTNAME = /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i;
const URIREF = /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
const URITEMPLATE = /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i;
const URL_ = /^(?:(?:https?|ftp):\/\/)(?:\S+(?::\S*)?@)?(?:(?!10(?:\.\d{1,3}){3})(?!127(?:\.\d{1,3}){3})(?!169\.254(?:\.\d{1,3}){2})(?!192\.168(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z\u{00a1}-\u{ffff}0-9]+-?)*[a-z\u{00a1}-\u{ffff}0-9]+)(?:\.(?:[a-z\u{00a1}-\u{ffff}0-9]+-?)*[a-z\u{00a1}-\u{ffff}0-9]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu;
const UUID = /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i;
const JSON_POINTER = /^(?:\/(?:[^~/]|~0|~1)*)*$/;
const JSON_POINTER_URI_FRAGMENT = /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i;
const RELATIVE_JSON_POINTER = /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/;
const EMAIL = (input) => {
  if (input[0] === '"')
    return false;
  const [name, host, ...rest] = input.split("@");
  if (!name || !host || rest.length !== 0 || name.length > 64 || host.length > 253)
    return false;
  if (name[0] === "." || name.endsWith(".") || name.includes(".."))
    return false;
  if (!/^[a-z0-9.-]+$/i.test(host) || !/^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+$/i.test(name))
    return false;
  return host.split(".").every((part) => /^[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?$/i.test(part));
};
const IPV4 = /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/;
const IPV6 = /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i;
const DURATION = (input) => input.length > 1 && input.length < 80 && (/^P\d+([.,]\d+)?W$/.test(input) || /^P[\dYMDTHS]*(\d[.,]\d+)?[YMDHS]$/.test(input) && /^P([.,\d]+Y)?([.,\d]+M)?([.,\d]+D)?(T([.,\d]+H)?([.,\d]+M)?([.,\d]+S)?)?$/.test(input));
function bind(r) {
  return r.test.bind(r);
}
const format = {
  date: date$1,
  time: time$1.bind(void 0, false),
  "date-time": date_time,
  duration: DURATION,
  uri,
  "uri-reference": bind(URIREF),
  "uri-template": bind(URITEMPLATE),
  url: bind(URL_),
  email: EMAIL,
  hostname: bind(HOSTNAME),
  ipv4: bind(IPV4),
  ipv6: bind(IPV6),
  regex,
  uuid: bind(UUID),
  "json-pointer": bind(JSON_POINTER),
  "json-pointer-uri-fragment": bind(JSON_POINTER_URI_FRAGMENT),
  "relative-json-pointer": bind(RELATIVE_JSON_POINTER)
};
function isLeapYear(year) {
  return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
}
function date$1(str2) {
  const matches = str2.match(DATE);
  if (!matches)
    return false;
  const year = +matches[1];
  const month = +matches[2];
  const day = +matches[3];
  return month >= 1 && month <= 12 && day >= 1 && day <= (month == 2 && isLeapYear(year) ? 29 : DAYS[month]);
}
function time$1(full, str2) {
  const matches = str2.match(TIME);
  if (!matches)
    return false;
  const hour = +matches[1];
  const minute = +matches[2];
  const second = +matches[3];
  const timeZone = !!matches[5];
  return (hour <= 23 && minute <= 59 && second <= 59 || hour == 23 && minute == 59 && second == 60) && (!full || timeZone);
}
const DATE_TIME_SEPARATOR = /t|\s/i;
function date_time(str2) {
  const dateTime = str2.split(DATE_TIME_SEPARATOR);
  return dateTime.length == 2 && date$1(dateTime[0]) && time$1(true, dateTime[1]);
}
const NOT_URI_FRAGMENT = /\/|:/;
const URI_PATTERN = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
function uri(str2) {
  return NOT_URI_FRAGMENT.test(str2) && URI_PATTERN.test(str2);
}
const Z_ANCHOR = /[^\\]\\Z/;
function regex(str2) {
  if (Z_ANCHOR.test(str2))
    return false;
  try {
    new RegExp(str2, "u");
    return true;
  } catch (e) {
    return false;
  }
}
function ucs2length(s) {
  let result = 0;
  let length = s.length;
  let index = 0;
  let charCode;
  while (index < length) {
    result++;
    charCode = s.charCodeAt(index++);
    if (charCode >= 55296 && charCode <= 56319 && index < length) {
      charCode = s.charCodeAt(index);
      if ((charCode & 64512) == 56320) {
        index++;
      }
    }
  }
  return result;
}
function validate(instance, schema, draft = "2019-09", lookup2 = dereference(schema), shortCircuit = true, recursiveAnchor = null, instanceLocation = "#", schemaLocation = "#", evaluated = /* @__PURE__ */ Object.create(null)) {
  if (schema === true) {
    return { valid: true, errors: [] };
  }
  if (schema === false) {
    return {
      valid: false,
      errors: [
        {
          instanceLocation,
          keyword: "false",
          keywordLocation: instanceLocation,
          error: "False boolean schema."
        }
      ]
    };
  }
  const rawInstanceType = typeof instance;
  let instanceType;
  switch (rawInstanceType) {
    case "boolean":
    case "number":
    case "string":
      instanceType = rawInstanceType;
      break;
    case "object":
      if (instance === null) {
        instanceType = "null";
      } else if (Array.isArray(instance)) {
        instanceType = "array";
      } else {
        instanceType = "object";
      }
      break;
    default:
      throw new Error(`Instances of "${rawInstanceType}" type are not supported.`);
  }
  const { $ref, $recursiveRef, $recursiveAnchor, type: $type, const: $const, enum: $enum, required: $required, not: $not, anyOf: $anyOf, allOf: $allOf, oneOf: $oneOf, if: $if, then: $then, else: $else, format: $format, properties: $properties, patternProperties: $patternProperties, additionalProperties: $additionalProperties, unevaluatedProperties: $unevaluatedProperties, minProperties: $minProperties, maxProperties: $maxProperties, propertyNames: $propertyNames, dependentRequired: $dependentRequired, dependentSchemas: $dependentSchemas, dependencies: $dependencies, prefixItems: $prefixItems, items: $items, additionalItems: $additionalItems, unevaluatedItems: $unevaluatedItems, contains: $contains, minContains: $minContains, maxContains: $maxContains, minItems: $minItems, maxItems: $maxItems, uniqueItems: $uniqueItems, minimum: $minimum, maximum: $maximum, exclusiveMinimum: $exclusiveMinimum, exclusiveMaximum: $exclusiveMaximum, multipleOf: $multipleOf, minLength: $minLength, maxLength: $maxLength, pattern: $pattern, __absolute_ref__, __absolute_recursive_ref__ } = schema;
  const errors = [];
  if ($recursiveAnchor === true && recursiveAnchor === null) {
    recursiveAnchor = schema;
  }
  if ($recursiveRef === "#") {
    const refSchema = recursiveAnchor === null ? lookup2[__absolute_recursive_ref__] : recursiveAnchor;
    const keywordLocation = `${schemaLocation}/$recursiveRef`;
    const result = validate(instance, recursiveAnchor === null ? schema : recursiveAnchor, draft, lookup2, shortCircuit, refSchema, instanceLocation, keywordLocation, evaluated);
    if (!result.valid) {
      errors.push({
        instanceLocation,
        keyword: "$recursiveRef",
        keywordLocation,
        error: "A subschema had errors."
      }, ...result.errors);
    }
  }
  if ($ref !== void 0) {
    const uri2 = __absolute_ref__ || $ref;
    const refSchema = lookup2[uri2];
    if (refSchema === void 0) {
      let message = `Unresolved $ref "${$ref}".`;
      if (__absolute_ref__ && __absolute_ref__ !== $ref) {
        message += `  Absolute URI "${__absolute_ref__}".`;
      }
      message += `
Known schemas:
- ${Object.keys(lookup2).join("\n- ")}`;
      throw new Error(message);
    }
    const keywordLocation = `${schemaLocation}/$ref`;
    const result = validate(instance, refSchema, draft, lookup2, shortCircuit, recursiveAnchor, instanceLocation, keywordLocation, evaluated);
    if (!result.valid) {
      errors.push({
        instanceLocation,
        keyword: "$ref",
        keywordLocation,
        error: "A subschema had errors."
      }, ...result.errors);
    }
    if (draft === "4" || draft === "7") {
      return { valid: errors.length === 0, errors };
    }
  }
  if (Array.isArray($type)) {
    let length = $type.length;
    let valid = false;
    for (let i2 = 0; i2 < length; i2++) {
      if (instanceType === $type[i2] || $type[i2] === "integer" && instanceType === "number" && instance % 1 === 0 && instance === instance) {
        valid = true;
        break;
      }
    }
    if (!valid) {
      errors.push({
        instanceLocation,
        keyword: "type",
        keywordLocation: `${schemaLocation}/type`,
        error: `Instance type "${instanceType}" is invalid. Expected "${$type.join('", "')}".`
      });
    }
  } else if ($type === "integer") {
    if (instanceType !== "number" || instance % 1 || instance !== instance) {
      errors.push({
        instanceLocation,
        keyword: "type",
        keywordLocation: `${schemaLocation}/type`,
        error: `Instance type "${instanceType}" is invalid. Expected "${$type}".`
      });
    }
  } else if ($type !== void 0 && instanceType !== $type) {
    errors.push({
      instanceLocation,
      keyword: "type",
      keywordLocation: `${schemaLocation}/type`,
      error: `Instance type "${instanceType}" is invalid. Expected "${$type}".`
    });
  }
  if ($const !== void 0) {
    if (instanceType === "object" || instanceType === "array") {
      if (!deepCompareStrict(instance, $const)) {
        errors.push({
          instanceLocation,
          keyword: "const",
          keywordLocation: `${schemaLocation}/const`,
          error: `Instance does not match ${JSON.stringify($const)}.`
        });
      }
    } else if (instance !== $const) {
      errors.push({
        instanceLocation,
        keyword: "const",
        keywordLocation: `${schemaLocation}/const`,
        error: `Instance does not match ${JSON.stringify($const)}.`
      });
    }
  }
  if ($enum !== void 0) {
    if (instanceType === "object" || instanceType === "array") {
      if (!$enum.some((value) => deepCompareStrict(instance, value))) {
        errors.push({
          instanceLocation,
          keyword: "enum",
          keywordLocation: `${schemaLocation}/enum`,
          error: `Instance does not match any of ${JSON.stringify($enum)}.`
        });
      }
    } else if (!$enum.some((value) => instance === value)) {
      errors.push({
        instanceLocation,
        keyword: "enum",
        keywordLocation: `${schemaLocation}/enum`,
        error: `Instance does not match any of ${JSON.stringify($enum)}.`
      });
    }
  }
  if ($not !== void 0) {
    const keywordLocation = `${schemaLocation}/not`;
    const result = validate(instance, $not, draft, lookup2, shortCircuit, recursiveAnchor, instanceLocation, keywordLocation);
    if (result.valid) {
      errors.push({
        instanceLocation,
        keyword: "not",
        keywordLocation,
        error: 'Instance matched "not" schema.'
      });
    }
  }
  let subEvaluateds = [];
  if ($anyOf !== void 0) {
    const keywordLocation = `${schemaLocation}/anyOf`;
    const errorsLength = errors.length;
    let anyValid = false;
    for (let i2 = 0; i2 < $anyOf.length; i2++) {
      const subSchema = $anyOf[i2];
      const subEvaluated = Object.create(evaluated);
      const result = validate(instance, subSchema, draft, lookup2, shortCircuit, $recursiveAnchor === true ? recursiveAnchor : null, instanceLocation, `${keywordLocation}/${i2}`, subEvaluated);
      errors.push(...result.errors);
      anyValid = anyValid || result.valid;
      if (result.valid) {
        subEvaluateds.push(subEvaluated);
      }
    }
    if (anyValid) {
      errors.length = errorsLength;
    } else {
      errors.splice(errorsLength, 0, {
        instanceLocation,
        keyword: "anyOf",
        keywordLocation,
        error: "Instance does not match any subschemas."
      });
    }
  }
  if ($allOf !== void 0) {
    const keywordLocation = `${schemaLocation}/allOf`;
    const errorsLength = errors.length;
    let allValid = true;
    for (let i2 = 0; i2 < $allOf.length; i2++) {
      const subSchema = $allOf[i2];
      const subEvaluated = Object.create(evaluated);
      const result = validate(instance, subSchema, draft, lookup2, shortCircuit, $recursiveAnchor === true ? recursiveAnchor : null, instanceLocation, `${keywordLocation}/${i2}`, subEvaluated);
      errors.push(...result.errors);
      allValid = allValid && result.valid;
      if (result.valid) {
        subEvaluateds.push(subEvaluated);
      }
    }
    if (allValid) {
      errors.length = errorsLength;
    } else {
      errors.splice(errorsLength, 0, {
        instanceLocation,
        keyword: "allOf",
        keywordLocation,
        error: `Instance does not match every subschema.`
      });
    }
  }
  if ($oneOf !== void 0) {
    const keywordLocation = `${schemaLocation}/oneOf`;
    const errorsLength = errors.length;
    const matches = $oneOf.filter((subSchema, i2) => {
      const subEvaluated = Object.create(evaluated);
      const result = validate(instance, subSchema, draft, lookup2, shortCircuit, $recursiveAnchor === true ? recursiveAnchor : null, instanceLocation, `${keywordLocation}/${i2}`, subEvaluated);
      errors.push(...result.errors);
      if (result.valid) {
        subEvaluateds.push(subEvaluated);
      }
      return result.valid;
    }).length;
    if (matches === 1) {
      errors.length = errorsLength;
    } else {
      errors.splice(errorsLength, 0, {
        instanceLocation,
        keyword: "oneOf",
        keywordLocation,
        error: `Instance does not match exactly one subschema (${matches} matches).`
      });
    }
  }
  if (instanceType === "object" || instanceType === "array") {
    Object.assign(evaluated, ...subEvaluateds);
  }
  if ($if !== void 0) {
    const keywordLocation = `${schemaLocation}/if`;
    const conditionResult = validate(instance, $if, draft, lookup2, shortCircuit, recursiveAnchor, instanceLocation, keywordLocation, evaluated).valid;
    if (conditionResult) {
      if ($then !== void 0) {
        const thenResult = validate(instance, $then, draft, lookup2, shortCircuit, recursiveAnchor, instanceLocation, `${schemaLocation}/then`, evaluated);
        if (!thenResult.valid) {
          errors.push({
            instanceLocation,
            keyword: "if",
            keywordLocation,
            error: `Instance does not match "then" schema.`
          }, ...thenResult.errors);
        }
      }
    } else if ($else !== void 0) {
      const elseResult = validate(instance, $else, draft, lookup2, shortCircuit, recursiveAnchor, instanceLocation, `${schemaLocation}/else`, evaluated);
      if (!elseResult.valid) {
        errors.push({
          instanceLocation,
          keyword: "if",
          keywordLocation,
          error: `Instance does not match "else" schema.`
        }, ...elseResult.errors);
      }
    }
  }
  if (instanceType === "object") {
    if ($required !== void 0) {
      for (const key of $required) {
        if (!(key in instance)) {
          errors.push({
            instanceLocation,
            keyword: "required",
            keywordLocation: `${schemaLocation}/required`,
            error: `Instance does not have required property "${key}".`
          });
        }
      }
    }
    const keys = Object.keys(instance);
    if ($minProperties !== void 0 && keys.length < $minProperties) {
      errors.push({
        instanceLocation,
        keyword: "minProperties",
        keywordLocation: `${schemaLocation}/minProperties`,
        error: `Instance does not have at least ${$minProperties} properties.`
      });
    }
    if ($maxProperties !== void 0 && keys.length > $maxProperties) {
      errors.push({
        instanceLocation,
        keyword: "maxProperties",
        keywordLocation: `${schemaLocation}/maxProperties`,
        error: `Instance does not have at least ${$maxProperties} properties.`
      });
    }
    if ($propertyNames !== void 0) {
      const keywordLocation = `${schemaLocation}/propertyNames`;
      for (const key in instance) {
        const subInstancePointer = `${instanceLocation}/${encodePointer(key)}`;
        const result = validate(key, $propertyNames, draft, lookup2, shortCircuit, recursiveAnchor, subInstancePointer, keywordLocation);
        if (!result.valid) {
          errors.push({
            instanceLocation,
            keyword: "propertyNames",
            keywordLocation,
            error: `Property name "${key}" does not match schema.`
          }, ...result.errors);
        }
      }
    }
    if ($dependentRequired !== void 0) {
      const keywordLocation = `${schemaLocation}/dependantRequired`;
      for (const key in $dependentRequired) {
        if (key in instance) {
          const required2 = $dependentRequired[key];
          for (const dependantKey of required2) {
            if (!(dependantKey in instance)) {
              errors.push({
                instanceLocation,
                keyword: "dependentRequired",
                keywordLocation,
                error: `Instance has "${key}" but does not have "${dependantKey}".`
              });
            }
          }
        }
      }
    }
    if ($dependentSchemas !== void 0) {
      for (const key in $dependentSchemas) {
        const keywordLocation = `${schemaLocation}/dependentSchemas`;
        if (key in instance) {
          const result = validate(instance, $dependentSchemas[key], draft, lookup2, shortCircuit, recursiveAnchor, instanceLocation, `${keywordLocation}/${encodePointer(key)}`, evaluated);
          if (!result.valid) {
            errors.push({
              instanceLocation,
              keyword: "dependentSchemas",
              keywordLocation,
              error: `Instance has "${key}" but does not match dependant schema.`
            }, ...result.errors);
          }
        }
      }
    }
    if ($dependencies !== void 0) {
      const keywordLocation = `${schemaLocation}/dependencies`;
      for (const key in $dependencies) {
        if (key in instance) {
          const propsOrSchema = $dependencies[key];
          if (Array.isArray(propsOrSchema)) {
            for (const dependantKey of propsOrSchema) {
              if (!(dependantKey in instance)) {
                errors.push({
                  instanceLocation,
                  keyword: "dependencies",
                  keywordLocation,
                  error: `Instance has "${key}" but does not have "${dependantKey}".`
                });
              }
            }
          } else {
            const result = validate(instance, propsOrSchema, draft, lookup2, shortCircuit, recursiveAnchor, instanceLocation, `${keywordLocation}/${encodePointer(key)}`);
            if (!result.valid) {
              errors.push({
                instanceLocation,
                keyword: "dependencies",
                keywordLocation,
                error: `Instance has "${key}" but does not match dependant schema.`
              }, ...result.errors);
            }
          }
        }
      }
    }
    const thisEvaluated = /* @__PURE__ */ Object.create(null);
    let stop = false;
    if ($properties !== void 0) {
      const keywordLocation = `${schemaLocation}/properties`;
      for (const key in $properties) {
        if (!(key in instance)) {
          continue;
        }
        const subInstancePointer = `${instanceLocation}/${encodePointer(key)}`;
        const result = validate(instance[key], $properties[key], draft, lookup2, shortCircuit, recursiveAnchor, subInstancePointer, `${keywordLocation}/${encodePointer(key)}`);
        if (result.valid) {
          evaluated[key] = thisEvaluated[key] = true;
        } else {
          stop = shortCircuit;
          errors.push({
            instanceLocation,
            keyword: "properties",
            keywordLocation,
            error: `Property "${key}" does not match schema.`
          }, ...result.errors);
          if (stop)
            break;
        }
      }
    }
    if (!stop && $patternProperties !== void 0) {
      const keywordLocation = `${schemaLocation}/patternProperties`;
      for (const pattern in $patternProperties) {
        const regex2 = new RegExp(pattern, "u");
        const subSchema = $patternProperties[pattern];
        for (const key in instance) {
          if (!regex2.test(key)) {
            continue;
          }
          const subInstancePointer = `${instanceLocation}/${encodePointer(key)}`;
          const result = validate(instance[key], subSchema, draft, lookup2, shortCircuit, recursiveAnchor, subInstancePointer, `${keywordLocation}/${encodePointer(pattern)}`);
          if (result.valid) {
            evaluated[key] = thisEvaluated[key] = true;
          } else {
            stop = shortCircuit;
            errors.push({
              instanceLocation,
              keyword: "patternProperties",
              keywordLocation,
              error: `Property "${key}" matches pattern "${pattern}" but does not match associated schema.`
            }, ...result.errors);
          }
        }
      }
    }
    if (!stop && $additionalProperties !== void 0) {
      const keywordLocation = `${schemaLocation}/additionalProperties`;
      for (const key in instance) {
        if (thisEvaluated[key]) {
          continue;
        }
        const subInstancePointer = `${instanceLocation}/${encodePointer(key)}`;
        const result = validate(instance[key], $additionalProperties, draft, lookup2, shortCircuit, recursiveAnchor, subInstancePointer, keywordLocation);
        if (result.valid) {
          evaluated[key] = true;
        } else {
          stop = shortCircuit;
          errors.push({
            instanceLocation,
            keyword: "additionalProperties",
            keywordLocation,
            error: `Property "${key}" does not match additional properties schema.`
          }, ...result.errors);
        }
      }
    } else if (!stop && $unevaluatedProperties !== void 0) {
      const keywordLocation = `${schemaLocation}/unevaluatedProperties`;
      for (const key in instance) {
        if (!evaluated[key]) {
          const subInstancePointer = `${instanceLocation}/${encodePointer(key)}`;
          const result = validate(instance[key], $unevaluatedProperties, draft, lookup2, shortCircuit, recursiveAnchor, subInstancePointer, keywordLocation);
          if (result.valid) {
            evaluated[key] = true;
          } else {
            errors.push({
              instanceLocation,
              keyword: "unevaluatedProperties",
              keywordLocation,
              error: `Property "${key}" does not match unevaluated properties schema.`
            }, ...result.errors);
          }
        }
      }
    }
  } else if (instanceType === "array") {
    if ($maxItems !== void 0 && instance.length > $maxItems) {
      errors.push({
        instanceLocation,
        keyword: "maxItems",
        keywordLocation: `${schemaLocation}/maxItems`,
        error: `Array has too many items (${instance.length} > ${$maxItems}).`
      });
    }
    if ($minItems !== void 0 && instance.length < $minItems) {
      errors.push({
        instanceLocation,
        keyword: "minItems",
        keywordLocation: `${schemaLocation}/minItems`,
        error: `Array has too few items (${instance.length} < ${$minItems}).`
      });
    }
    const length = instance.length;
    let i2 = 0;
    let stop = false;
    if ($prefixItems !== void 0) {
      const keywordLocation = `${schemaLocation}/prefixItems`;
      const length2 = Math.min($prefixItems.length, length);
      for (; i2 < length2; i2++) {
        const result = validate(instance[i2], $prefixItems[i2], draft, lookup2, shortCircuit, recursiveAnchor, `${instanceLocation}/${i2}`, `${keywordLocation}/${i2}`);
        evaluated[i2] = true;
        if (!result.valid) {
          stop = shortCircuit;
          errors.push({
            instanceLocation,
            keyword: "prefixItems",
            keywordLocation,
            error: `Items did not match schema.`
          }, ...result.errors);
          if (stop)
            break;
        }
      }
    }
    if ($items !== void 0) {
      const keywordLocation = `${schemaLocation}/items`;
      if (Array.isArray($items)) {
        const length2 = Math.min($items.length, length);
        for (; i2 < length2; i2++) {
          const result = validate(instance[i2], $items[i2], draft, lookup2, shortCircuit, recursiveAnchor, `${instanceLocation}/${i2}`, `${keywordLocation}/${i2}`);
          evaluated[i2] = true;
          if (!result.valid) {
            stop = shortCircuit;
            errors.push({
              instanceLocation,
              keyword: "items",
              keywordLocation,
              error: `Items did not match schema.`
            }, ...result.errors);
            if (stop)
              break;
          }
        }
      } else {
        for (; i2 < length; i2++) {
          const result = validate(instance[i2], $items, draft, lookup2, shortCircuit, recursiveAnchor, `${instanceLocation}/${i2}`, keywordLocation);
          evaluated[i2] = true;
          if (!result.valid) {
            stop = shortCircuit;
            errors.push({
              instanceLocation,
              keyword: "items",
              keywordLocation,
              error: `Items did not match schema.`
            }, ...result.errors);
            if (stop)
              break;
          }
        }
      }
      if (!stop && $additionalItems !== void 0) {
        const keywordLocation2 = `${schemaLocation}/additionalItems`;
        for (; i2 < length; i2++) {
          const result = validate(instance[i2], $additionalItems, draft, lookup2, shortCircuit, recursiveAnchor, `${instanceLocation}/${i2}`, keywordLocation2);
          evaluated[i2] = true;
          if (!result.valid) {
            stop = shortCircuit;
            errors.push({
              instanceLocation,
              keyword: "additionalItems",
              keywordLocation: keywordLocation2,
              error: `Items did not match additional items schema.`
            }, ...result.errors);
          }
        }
      }
    }
    if ($contains !== void 0) {
      if (length === 0 && $minContains === void 0) {
        errors.push({
          instanceLocation,
          keyword: "contains",
          keywordLocation: `${schemaLocation}/contains`,
          error: `Array is empty. It must contain at least one item matching the schema.`
        });
      } else if ($minContains !== void 0 && length < $minContains) {
        errors.push({
          instanceLocation,
          keyword: "minContains",
          keywordLocation: `${schemaLocation}/minContains`,
          error: `Array has less items (${length}) than minContains (${$minContains}).`
        });
      } else {
        const keywordLocation = `${schemaLocation}/contains`;
        const errorsLength = errors.length;
        let contained = 0;
        for (let j = 0; j < length; j++) {
          const result = validate(instance[j], $contains, draft, lookup2, shortCircuit, recursiveAnchor, `${instanceLocation}/${j}`, keywordLocation);
          if (result.valid) {
            evaluated[j] = true;
            contained++;
          } else {
            errors.push(...result.errors);
          }
        }
        if (contained >= ($minContains || 0)) {
          errors.length = errorsLength;
        }
        if ($minContains === void 0 && $maxContains === void 0 && contained === 0) {
          errors.splice(errorsLength, 0, {
            instanceLocation,
            keyword: "contains",
            keywordLocation,
            error: `Array does not contain item matching schema.`
          });
        } else if ($minContains !== void 0 && contained < $minContains) {
          errors.push({
            instanceLocation,
            keyword: "minContains",
            keywordLocation: `${schemaLocation}/minContains`,
            error: `Array must contain at least ${$minContains} items matching schema. Only ${contained} items were found.`
          });
        } else if ($maxContains !== void 0 && contained > $maxContains) {
          errors.push({
            instanceLocation,
            keyword: "maxContains",
            keywordLocation: `${schemaLocation}/maxContains`,
            error: `Array may contain at most ${$maxContains} items matching schema. ${contained} items were found.`
          });
        }
      }
    }
    if (!stop && $unevaluatedItems !== void 0) {
      const keywordLocation = `${schemaLocation}/unevaluatedItems`;
      for (i2; i2 < length; i2++) {
        if (evaluated[i2]) {
          continue;
        }
        const result = validate(instance[i2], $unevaluatedItems, draft, lookup2, shortCircuit, recursiveAnchor, `${instanceLocation}/${i2}`, keywordLocation);
        evaluated[i2] = true;
        if (!result.valid) {
          errors.push({
            instanceLocation,
            keyword: "unevaluatedItems",
            keywordLocation,
            error: `Items did not match unevaluated items schema.`
          }, ...result.errors);
        }
      }
    }
    if ($uniqueItems) {
      for (let j = 0; j < length; j++) {
        const a = instance[j];
        const ao = typeof a === "object" && a !== null;
        for (let k = 0; k < length; k++) {
          if (j === k) {
            continue;
          }
          const b = instance[k];
          const bo = typeof b === "object" && b !== null;
          if (a === b || ao && bo && deepCompareStrict(a, b)) {
            errors.push({
              instanceLocation,
              keyword: "uniqueItems",
              keywordLocation: `${schemaLocation}/uniqueItems`,
              error: `Duplicate items at indexes ${j} and ${k}.`
            });
            j = Number.MAX_SAFE_INTEGER;
            k = Number.MAX_SAFE_INTEGER;
          }
        }
      }
    }
  } else if (instanceType === "number") {
    if (draft === "4") {
      if ($minimum !== void 0 && ($exclusiveMinimum === true && instance <= $minimum || instance < $minimum)) {
        errors.push({
          instanceLocation,
          keyword: "minimum",
          keywordLocation: `${schemaLocation}/minimum`,
          error: `${instance} is less than ${$exclusiveMinimum ? "or equal to " : ""} ${$minimum}.`
        });
      }
      if ($maximum !== void 0 && ($exclusiveMaximum === true && instance >= $maximum || instance > $maximum)) {
        errors.push({
          instanceLocation,
          keyword: "maximum",
          keywordLocation: `${schemaLocation}/maximum`,
          error: `${instance} is greater than ${$exclusiveMaximum ? "or equal to " : ""} ${$maximum}.`
        });
      }
    } else {
      if ($minimum !== void 0 && instance < $minimum) {
        errors.push({
          instanceLocation,
          keyword: "minimum",
          keywordLocation: `${schemaLocation}/minimum`,
          error: `${instance} is less than ${$minimum}.`
        });
      }
      if ($maximum !== void 0 && instance > $maximum) {
        errors.push({
          instanceLocation,
          keyword: "maximum",
          keywordLocation: `${schemaLocation}/maximum`,
          error: `${instance} is greater than ${$maximum}.`
        });
      }
      if ($exclusiveMinimum !== void 0 && instance <= $exclusiveMinimum) {
        errors.push({
          instanceLocation,
          keyword: "exclusiveMinimum",
          keywordLocation: `${schemaLocation}/exclusiveMinimum`,
          error: `${instance} is less than ${$exclusiveMinimum}.`
        });
      }
      if ($exclusiveMaximum !== void 0 && instance >= $exclusiveMaximum) {
        errors.push({
          instanceLocation,
          keyword: "exclusiveMaximum",
          keywordLocation: `${schemaLocation}/exclusiveMaximum`,
          error: `${instance} is greater than or equal to ${$exclusiveMaximum}.`
        });
      }
    }
    if ($multipleOf !== void 0) {
      const remainder = instance % $multipleOf;
      if (Math.abs(0 - remainder) >= 11920929e-14 && Math.abs($multipleOf - remainder) >= 11920929e-14) {
        errors.push({
          instanceLocation,
          keyword: "multipleOf",
          keywordLocation: `${schemaLocation}/multipleOf`,
          error: `${instance} is not a multiple of ${$multipleOf}.`
        });
      }
    }
  } else if (instanceType === "string") {
    const length = $minLength === void 0 && $maxLength === void 0 ? 0 : ucs2length(instance);
    if ($minLength !== void 0 && length < $minLength) {
      errors.push({
        instanceLocation,
        keyword: "minLength",
        keywordLocation: `${schemaLocation}/minLength`,
        error: `String is too short (${length} < ${$minLength}).`
      });
    }
    if ($maxLength !== void 0 && length > $maxLength) {
      errors.push({
        instanceLocation,
        keyword: "maxLength",
        keywordLocation: `${schemaLocation}/maxLength`,
        error: `String is too long (${length} > ${$maxLength}).`
      });
    }
    if ($pattern !== void 0 && !new RegExp($pattern, "u").test(instance)) {
      errors.push({
        instanceLocation,
        keyword: "pattern",
        keywordLocation: `${schemaLocation}/pattern`,
        error: `String does not match pattern.`
      });
    }
    if ($format !== void 0 && format[$format] && !format[$format](instance)) {
      errors.push({
        instanceLocation,
        keyword: "format",
        keywordLocation: `${schemaLocation}/format`,
        error: `String does not match format "${$format}".`
      });
    }
  }
  return { valid: errors.length === 0, errors };
}
class Validator {
  constructor(schema, draft = "2019-09", shortCircuit = true) {
    __publicField2(this, "schema");
    __publicField2(this, "draft");
    __publicField2(this, "shortCircuit");
    __publicField2(this, "lookup");
    this.schema = schema;
    this.draft = draft;
    this.shortCircuit = shortCircuit;
    this.lookup = dereference(schema);
  }
  validate(instance) {
    return validate(instance, this.schema, this.draft, this.lookup, this.shortCircuit);
  }
  addSchema(schema, id) {
    if (id) {
      schema = { ...schema, $id: id };
    }
    dereference(schema, this.lookup);
  }
}
var json_schema_exports = {};
__export(json_schema_exports, {
  Validator: () => Validator,
  deepCompareStrict: () => deepCompareStrict,
  toJsonSchema: () => toJsonSchema,
  validatesOnlyStrings: () => validatesOnlyStrings
});
function toJsonSchema(schema) {
  if (isZodSchemaV4(schema)) {
    const inputSchema = interopZodTransformInputSchema(schema, true);
    if (isZodObjectV4(inputSchema)) {
      const strictSchema = interopZodObjectStrict(inputSchema, true);
      return toJSONSchema(strictSchema);
    } else return toJSONSchema(schema);
  }
  if (isZodSchemaV3(schema)) return zodToJsonSchema$1(schema);
  return schema;
}
function validatesOnlyStrings(schema) {
  if (!schema || typeof schema !== "object" || Object.keys(schema).length === 0 || Array.isArray(schema)) return false;
  if ("type" in schema) {
    if (typeof schema.type === "string") return schema.type === "string";
    if (Array.isArray(schema.type)) return schema.type.every((t2) => t2 === "string");
    return false;
  }
  if ("enum" in schema) return Array.isArray(schema.enum) && schema.enum.length > 0 && schema.enum.every((val) => typeof val === "string");
  if ("const" in schema) return typeof schema.const === "string";
  if ("allOf" in schema && Array.isArray(schema.allOf)) return schema.allOf.some((subschema) => validatesOnlyStrings(subschema));
  if ("anyOf" in schema && Array.isArray(schema.anyOf) || "oneOf" in schema && Array.isArray(schema.oneOf)) {
    const subschemas = "anyOf" in schema ? schema.anyOf : schema.oneOf;
    return subschemas.length > 0 && subschemas.every((subschema) => validatesOnlyStrings(subschema));
  }
  if ("not" in schema) return false;
  if ("$ref" in schema && typeof schema.$ref === "string") {
    const ref = schema.$ref;
    const resolved = dereference(schema);
    if (resolved[ref]) return validatesOnlyStrings(resolved[ref]);
    return false;
  }
  return false;
}
var graph_exports = {};
__export(graph_exports, { Graph: () => Graph });
function nodeDataStr(id, data) {
  if (id !== void 0 && !validate$3(id)) return id;
  else if (isRunnableInterface(data)) try {
    let dataStr = data.getName();
    dataStr = dataStr.startsWith("Runnable") ? dataStr.slice(8) : dataStr;
    return dataStr;
  } catch {
    return data.getName();
  }
  else return data.name ?? "UnknownSchema";
}
function nodeDataJson(node) {
  if (isRunnableInterface(node.data)) return {
    type: "runnable",
    data: {
      id: node.data.lc_id,
      name: node.data.getName()
    }
  };
  else return {
    type: "schema",
    data: {
      ...toJsonSchema(node.data.schema),
      title: node.data.name
    }
  };
}
var Graph = class Graph2 {
  constructor(params) {
    __publicField2(this, "nodes", {});
    __publicField2(this, "edges", []);
    this.nodes = (params == null ? void 0 : params.nodes) ?? this.nodes;
    this.edges = (params == null ? void 0 : params.edges) ?? this.edges;
  }
  toJSON() {
    const stableNodeIds = {};
    Object.values(this.nodes).forEach((node, i2) => {
      stableNodeIds[node.id] = validate$3(node.id) ? i2 : node.id;
    });
    return {
      nodes: Object.values(this.nodes).map((node) => ({
        id: stableNodeIds[node.id],
        ...nodeDataJson(node)
      })),
      edges: this.edges.map((edge) => {
        const item = {
          source: stableNodeIds[edge.source],
          target: stableNodeIds[edge.target]
        };
        if (typeof edge.data !== "undefined") item.data = edge.data;
        if (typeof edge.conditional !== "undefined") item.conditional = edge.conditional;
        return item;
      })
    };
  }
  addNode(data, id, metadata) {
    if (id !== void 0 && this.nodes[id] !== void 0) throw new Error(`Node with id ${id} already exists`);
    const nodeId = id ?? v4$1();
    const node = {
      id: nodeId,
      data,
      name: nodeDataStr(id, data),
      metadata
    };
    this.nodes[nodeId] = node;
    return node;
  }
  removeNode(node) {
    delete this.nodes[node.id];
    this.edges = this.edges.filter((edge) => edge.source !== node.id && edge.target !== node.id);
  }
  addEdge(source, target, data, conditional) {
    if (this.nodes[source.id] === void 0) throw new Error(`Source node ${source.id} not in graph`);
    if (this.nodes[target.id] === void 0) throw new Error(`Target node ${target.id} not in graph`);
    const edge = {
      source: source.id,
      target: target.id,
      data,
      conditional
    };
    this.edges.push(edge);
    return edge;
  }
  firstNode() {
    return _firstNode(this);
  }
  lastNode() {
    return _lastNode(this);
  }
  /**
  * Add all nodes and edges from another graph.
  * Note this doesn't check for duplicates, nor does it connect the graphs.
  */
  extend(graph, prefix = "") {
    let finalPrefix = prefix;
    const nodeIds = Object.values(graph.nodes).map((node) => node.id);
    if (nodeIds.every(validate$3)) finalPrefix = "";
    const prefixed = (id) => {
      return finalPrefix ? `${finalPrefix}:${id}` : id;
    };
    Object.entries(graph.nodes).forEach(([key, value]) => {
      this.nodes[prefixed(key)] = {
        ...value,
        id: prefixed(key)
      };
    });
    const newEdges = graph.edges.map((edge) => {
      return {
        ...edge,
        source: prefixed(edge.source),
        target: prefixed(edge.target)
      };
    });
    this.edges = [...this.edges, ...newEdges];
    const first = graph.firstNode();
    const last = graph.lastNode();
    return [first ? {
      id: prefixed(first.id),
      data: first.data
    } : void 0, last ? {
      id: prefixed(last.id),
      data: last.data
    } : void 0];
  }
  trimFirstNode() {
    const firstNode = this.firstNode();
    if (firstNode && _firstNode(this, [firstNode.id])) this.removeNode(firstNode);
  }
  trimLastNode() {
    const lastNode = this.lastNode();
    if (lastNode && _lastNode(this, [lastNode.id])) this.removeNode(lastNode);
  }
  /**
  * Return a new graph with all nodes re-identified,
  * using their unique, readable names where possible.
  */
  reid() {
    const nodeLabels = Object.fromEntries(Object.values(this.nodes).map((node) => [node.id, node.name]));
    const nodeLabelCounts = /* @__PURE__ */ new Map();
    Object.values(nodeLabels).forEach((label) => {
      nodeLabelCounts.set(label, (nodeLabelCounts.get(label) || 0) + 1);
    });
    const getNodeId = (nodeId) => {
      const label = nodeLabels[nodeId];
      if (validate$3(nodeId) && nodeLabelCounts.get(label) === 1) return label;
      else return nodeId;
    };
    return new Graph2({
      nodes: Object.fromEntries(Object.entries(this.nodes).map(([id, node]) => [getNodeId(id), {
        ...node,
        id: getNodeId(id)
      }])),
      edges: this.edges.map((edge) => ({
        ...edge,
        source: getNodeId(edge.source),
        target: getNodeId(edge.target)
      }))
    });
  }
  drawMermaid(params) {
    const { withStyles, curveStyle, nodeColors = {
      default: "fill:#f2f0ff,line-height:1.2",
      first: "fill-opacity:0",
      last: "fill:#bfb6fc"
    }, wrapLabelNWords } = params ?? {};
    const graph = this.reid();
    const firstNode = graph.firstNode();
    const lastNode = graph.lastNode();
    return drawMermaid(graph.nodes, graph.edges, {
      firstNode: firstNode == null ? void 0 : firstNode.id,
      lastNode: lastNode == null ? void 0 : lastNode.id,
      withStyles,
      curveStyle,
      nodeColors,
      wrapLabelNWords
    });
  }
  async drawMermaidPng(params) {
    const mermaidSyntax = this.drawMermaid(params);
    return drawMermaidImage(mermaidSyntax, { backgroundColor: params == null ? void 0 : params.backgroundColor });
  }
};
function _firstNode(graph, exclude = []) {
  const targets = new Set(graph.edges.filter((edge) => !exclude.includes(edge.source)).map((edge) => edge.target));
  const found = [];
  for (const node of Object.values(graph.nodes)) if (!exclude.includes(node.id) && !targets.has(node.id)) found.push(node);
  return found.length === 1 ? found[0] : void 0;
}
function _lastNode(graph, exclude = []) {
  const sources = new Set(graph.edges.filter((edge) => !exclude.includes(edge.target)).map((edge) => edge.source));
  const found = [];
  for (const node of Object.values(graph.nodes)) if (!exclude.includes(node.id) && !sources.has(node.id)) found.push(node);
  return found.length === 1 ? found[0] : void 0;
}
function convertToHttpEventStream(stream) {
  const encoder2 = new TextEncoder();
  const finalStream = new ReadableStream({ async start(controller) {
    for await (const chunk of stream) controller.enqueue(encoder2.encode(`event: data
data: ${JSON.stringify(chunk)}

`));
    controller.enqueue(encoder2.encode("event: end\n\n"));
    controller.close();
  } });
  return IterableReadableStream.fromReadableStream(finalStream);
}
function isIterableIterator(thing) {
  return typeof thing === "object" && thing !== null && typeof thing[Symbol.iterator] === "function" && typeof thing.next === "function";
}
const isIterator = (x) => x != null && typeof x === "object" && "next" in x && typeof x.next === "function";
function isAsyncIterable(thing) {
  return typeof thing === "object" && thing !== null && typeof thing[Symbol.asyncIterator] === "function";
}
function* consumeIteratorInContext(context, iter) {
  while (true) {
    const { value, done } = AsyncLocalStorageProviderSingleton.runWithConfig(pickRunnableConfigKeys(context), iter.next.bind(iter), true);
    if (done) break;
    else yield value;
  }
}
async function* consumeAsyncIterableInContext(context, iter) {
  const iterator = iter[Symbol.asyncIterator]();
  while (true) {
    const { value, done } = await AsyncLocalStorageProviderSingleton.runWithConfig(pickRunnableConfigKeys(context), iterator.next.bind(iter), true);
    if (done) break;
    else yield value;
  }
}
function _coerceToDict(value, defaultKey) {
  return value && !Array.isArray(value) && !(value instanceof Date) && typeof value === "object" ? value : { [defaultKey]: value };
}
var Runnable = class extends Serializable {
  constructor() {
    super(...arguments);
    __publicField2(this, "lc_runnable", true);
    __publicField2(this, "name");
  }
  getName(suffix) {
    const name = this.name ?? this.constructor.lc_name() ?? this.constructor.name;
    return suffix ? `${name}${suffix}` : name;
  }
  /**
  * Add retry logic to an existing runnable.
  * @param fields.stopAfterAttempt The number of attempts to retry.
  * @param fields.onFailedAttempt A function that is called when a retry fails.
  * @returns A new RunnableRetry that, when invoked, will retry according to the parameters.
  */
  withRetry(fields) {
    return new RunnableRetry({
      bound: this,
      kwargs: {},
      config: {},
      maxAttemptNumber: fields == null ? void 0 : fields.stopAfterAttempt,
      ...fields
    });
  }
  /**
  * Bind config to a Runnable, returning a new Runnable.
  * @param config New configuration parameters to attach to the new runnable.
  * @returns A new RunnableBinding with a config matching what's passed.
  */
  withConfig(config2) {
    return new RunnableBinding({
      bound: this,
      config: config2,
      kwargs: {}
    });
  }
  /**
  * Create a new runnable from the current one that will try invoking
  * other passed fallback runnables if the initial invocation fails.
  * @param fields.fallbacks Other runnables to call if the runnable errors.
  * @returns A new RunnableWithFallbacks.
  */
  withFallbacks(fields) {
    const fallbacks = Array.isArray(fields) ? fields : fields.fallbacks;
    return new RunnableWithFallbacks({
      runnable: this,
      fallbacks
    });
  }
  _getOptionsList(options2, length = 0) {
    if (Array.isArray(options2) && options2.length !== length) throw new Error(`Passed "options" must be an array with the same length as the inputs, but got ${options2.length} options for ${length} inputs`);
    if (Array.isArray(options2)) return options2.map(ensureConfig);
    if (length > 1 && !Array.isArray(options2) && options2.runId) {
      console.warn("Provided runId will be used only for the first element of the batch.");
      const subsequent = Object.fromEntries(Object.entries(options2).filter(([key]) => key !== "runId"));
      return Array.from({ length }, (_, i2) => ensureConfig(i2 === 0 ? options2 : subsequent));
    }
    return Array.from({ length }, () => ensureConfig(options2));
  }
  async batch(inputs, options2, batchOptions) {
    var _a3;
    const configList = this._getOptionsList(options2 ?? {}, inputs.length);
    const maxConcurrency = ((_a3 = configList[0]) == null ? void 0 : _a3.maxConcurrency) ?? (batchOptions == null ? void 0 : batchOptions.maxConcurrency);
    const caller2 = new AsyncCaller({
      maxConcurrency,
      onFailedAttempt: (e) => {
        throw e;
      }
    });
    const batchCalls = inputs.map((input, i2) => caller2.call(async () => {
      try {
        const result = await this.invoke(input, configList[i2]);
        return result;
      } catch (e) {
        if (batchOptions == null ? void 0 : batchOptions.returnExceptions) return e;
        throw e;
      }
    }));
    return Promise.all(batchCalls);
  }
  /**
  * Default streaming implementation.
  * Subclasses should override this method if they support streaming output.
  * @param input
  * @param options
  */
  async *_streamIterator(input, options2) {
    yield this.invoke(input, options2);
  }
  /**
  * Stream output in chunks.
  * @param input
  * @param options
  * @returns A readable stream that is also an iterable.
  */
  async stream(input, options2) {
    const config2 = ensureConfig(options2);
    const wrappedGenerator = new AsyncGeneratorWithSetup({
      generator: this._streamIterator(input, config2),
      config: config2
    });
    await wrappedGenerator.setup;
    return IterableReadableStream.fromAsyncGenerator(wrappedGenerator);
  }
  _separateRunnableConfigFromCallOptions(options2) {
    let runnableConfig;
    if (options2 === void 0) runnableConfig = ensureConfig(options2);
    else runnableConfig = ensureConfig({
      callbacks: options2.callbacks,
      tags: options2.tags,
      metadata: options2.metadata,
      runName: options2.runName,
      configurable: options2.configurable,
      recursionLimit: options2.recursionLimit,
      maxConcurrency: options2.maxConcurrency,
      runId: options2.runId,
      timeout: options2.timeout,
      signal: options2.signal
    });
    const callOptions = { ...options2 };
    delete callOptions.callbacks;
    delete callOptions.tags;
    delete callOptions.metadata;
    delete callOptions.runName;
    delete callOptions.configurable;
    delete callOptions.recursionLimit;
    delete callOptions.maxConcurrency;
    delete callOptions.runId;
    delete callOptions.timeout;
    delete callOptions.signal;
    return [runnableConfig, callOptions];
  }
  async _callWithConfig(func, input, options2) {
    const config2 = ensureConfig(options2);
    const callbackManager_ = await getCallbackManagerForConfig(config2);
    const runManager = await (callbackManager_ == null ? void 0 : callbackManager_.handleChainStart(this.toJSON(), _coerceToDict(input, "input"), config2.runId, config2 == null ? void 0 : config2.runType, void 0, void 0, (config2 == null ? void 0 : config2.runName) ?? this.getName()));
    delete config2.runId;
    let output;
    try {
      const promise = func.call(this, input, config2, runManager);
      output = await raceWithSignal(promise, options2 == null ? void 0 : options2.signal);
    } catch (e) {
      await (runManager == null ? void 0 : runManager.handleChainError(e));
      throw e;
    }
    await (runManager == null ? void 0 : runManager.handleChainEnd(_coerceToDict(output, "output")));
    return output;
  }
  /**
  * Internal method that handles batching and configuration for a runnable
  * It takes a function, input values, and optional configuration, and
  * returns a promise that resolves to the output values.
  * @param func The function to be executed for each input value.
  * @param input The input values to be processed.
  * @param config Optional configuration for the function execution.
  * @returns A promise that resolves to the output values.
  */
  async _batchWithConfig(func, inputs, options2, batchOptions) {
    var _a3;
    const optionsList = this._getOptionsList(options2 ?? {}, inputs.length);
    const callbackManagers = await Promise.all(optionsList.map(getCallbackManagerForConfig));
    const runManagers = await Promise.all(callbackManagers.map(async (callbackManager, i2) => {
      const handleStartRes = await (callbackManager == null ? void 0 : callbackManager.handleChainStart(this.toJSON(), _coerceToDict(inputs[i2], "input"), optionsList[i2].runId, optionsList[i2].runType, void 0, void 0, optionsList[i2].runName ?? this.getName()));
      delete optionsList[i2].runId;
      return handleStartRes;
    }));
    let outputs;
    try {
      const promise = func.call(this, inputs, optionsList, runManagers, batchOptions);
      outputs = await raceWithSignal(promise, (_a3 = optionsList == null ? void 0 : optionsList[0]) == null ? void 0 : _a3.signal);
    } catch (e) {
      await Promise.all(runManagers.map((runManager) => runManager == null ? void 0 : runManager.handleChainError(e)));
      throw e;
    }
    await Promise.all(runManagers.map((runManager) => runManager == null ? void 0 : runManager.handleChainEnd(_coerceToDict(outputs, "output"))));
    return outputs;
  }
  /** @internal */
  _concatOutputChunks(first, second) {
    return concat(first, second);
  }
  /**
  * Helper method to transform an Iterator of Input values into an Iterator of
  * Output values, with callbacks.
  * Use this to implement `stream()` or `transform()` in Runnable subclasses.
  */
  async *_transformStreamWithConfig(inputGenerator, transformer, options2) {
    let finalInput;
    let finalInputSupported = true;
    let finalOutput;
    let finalOutputSupported = true;
    const config2 = ensureConfig(options2);
    const callbackManager_ = await getCallbackManagerForConfig(config2);
    const outerThis = this;
    async function* wrapInputForTracing() {
      for await (const chunk of inputGenerator) {
        if (finalInputSupported) if (finalInput === void 0) finalInput = chunk;
        else try {
          finalInput = outerThis._concatOutputChunks(finalInput, chunk);
        } catch {
          finalInput = void 0;
          finalInputSupported = false;
        }
        yield chunk;
      }
    }
    let runManager;
    try {
      const pipe2 = await pipeGeneratorWithSetup(transformer.bind(this), wrapInputForTracing(), async () => callbackManager_ == null ? void 0 : callbackManager_.handleChainStart(this.toJSON(), { input: "" }, config2.runId, config2.runType, void 0, void 0, config2.runName ?? this.getName()), options2 == null ? void 0 : options2.signal, config2);
      delete config2.runId;
      runManager = pipe2.setup;
      const streamEventsHandler = runManager == null ? void 0 : runManager.handlers.find(isStreamEventsHandler);
      let iterator = pipe2.output;
      if (streamEventsHandler !== void 0 && runManager !== void 0) iterator = streamEventsHandler.tapOutputIterable(runManager.runId, iterator);
      const streamLogHandler = runManager == null ? void 0 : runManager.handlers.find(isLogStreamHandler);
      if (streamLogHandler !== void 0 && runManager !== void 0) iterator = streamLogHandler.tapOutputIterable(runManager.runId, iterator);
      for await (const chunk of iterator) {
        yield chunk;
        if (finalOutputSupported) if (finalOutput === void 0) finalOutput = chunk;
        else try {
          finalOutput = this._concatOutputChunks(finalOutput, chunk);
        } catch {
          finalOutput = void 0;
          finalOutputSupported = false;
        }
      }
    } catch (e) {
      await (runManager == null ? void 0 : runManager.handleChainError(e, void 0, void 0, void 0, { inputs: _coerceToDict(finalInput, "input") }));
      throw e;
    }
    await (runManager == null ? void 0 : runManager.handleChainEnd(finalOutput ?? {}, void 0, void 0, void 0, { inputs: _coerceToDict(finalInput, "input") }));
  }
  getGraph(_) {
    const graph = new Graph();
    const inputNode = graph.addNode({
      name: `${this.getName()}Input`,
      schema: anyType()
    });
    const runnableNode = graph.addNode(this);
    const outputNode = graph.addNode({
      name: `${this.getName()}Output`,
      schema: anyType()
    });
    graph.addEdge(inputNode, runnableNode);
    graph.addEdge(runnableNode, outputNode);
    return graph;
  }
  /**
  * Create a new runnable sequence that runs each individual runnable in series,
  * piping the output of one runnable into another runnable or runnable-like.
  * @param coerceable A runnable, function, or object whose values are functions or runnables.
  * @returns A new runnable sequence.
  */
  pipe(coerceable) {
    return new RunnableSequence({
      first: this,
      last: _coerceToRunnable(coerceable)
    });
  }
  /**
  * Pick keys from the dict output of this runnable. Returns a new runnable.
  */
  pick(keys) {
    return this.pipe(new RunnablePick(keys));
  }
  /**
  * Assigns new fields to the dict output of this runnable. Returns a new runnable.
  */
  assign(mapping) {
    return this.pipe(new RunnableAssign(new RunnableMap({ steps: mapping })));
  }
  /**
  * Default implementation of transform, which buffers input and then calls stream.
  * Subclasses should override this method if they can start producing output while
  * input is still being generated.
  * @param generator
  * @param options
  */
  async *transform(generator, options2) {
    let finalChunk;
    for await (const chunk of generator) if (finalChunk === void 0) finalChunk = chunk;
    else finalChunk = this._concatOutputChunks(finalChunk, chunk);
    yield* this._streamIterator(finalChunk, ensureConfig(options2));
  }
  /**
  * Stream all output from a runnable, as reported to the callback system.
  * This includes all inner runs of LLMs, Retrievers, Tools, etc.
  * Output is streamed as Log objects, which include a list of
  * jsonpatch ops that describe how the state of the run has changed in each
  * step, and the final state of the run.
  * The jsonpatch ops can be applied in order to construct state.
  * @param input
  * @param options
  * @param streamOptions
  */
  async *streamLog(input, options2, streamOptions) {
    const logStreamCallbackHandler = new LogStreamCallbackHandler({
      ...streamOptions,
      autoClose: false,
      _schemaFormat: "original"
    });
    const config2 = ensureConfig(options2);
    yield* this._streamLog(input, logStreamCallbackHandler, config2);
  }
  async *_streamLog(input, logStreamCallbackHandler, config2) {
    const { callbacks } = config2;
    if (callbacks === void 0) config2.callbacks = [logStreamCallbackHandler];
    else if (Array.isArray(callbacks)) config2.callbacks = callbacks.concat([logStreamCallbackHandler]);
    else {
      const copiedCallbacks = callbacks.copy();
      copiedCallbacks.addHandler(logStreamCallbackHandler, true);
      config2.callbacks = copiedCallbacks;
    }
    const runnableStreamPromise = this.stream(input, config2);
    async function consumeRunnableStream() {
      try {
        const runnableStream = await runnableStreamPromise;
        for await (const chunk of runnableStream) {
          const patch = new RunLogPatch({ ops: [{
            op: "add",
            path: "/streamed_output/-",
            value: chunk
          }] });
          await logStreamCallbackHandler.writer.write(patch);
        }
      } finally {
        await logStreamCallbackHandler.writer.close();
      }
    }
    const runnableStreamConsumePromise = consumeRunnableStream();
    try {
      for await (const log of logStreamCallbackHandler) yield log;
    } finally {
      await runnableStreamConsumePromise;
    }
  }
  streamEvents(input, options2, streamOptions) {
    let stream;
    if (options2.version === "v1") stream = this._streamEventsV1(input, options2, streamOptions);
    else if (options2.version === "v2") stream = this._streamEventsV2(input, options2, streamOptions);
    else throw new Error(`Only versions "v1" and "v2" of the schema are currently supported.`);
    if (options2.encoding === "text/event-stream") return convertToHttpEventStream(stream);
    else return IterableReadableStream.fromAsyncGenerator(stream);
  }
  async *_streamEventsV2(input, options2, streamOptions) {
    var _a3;
    const eventStreamer = new EventStreamCallbackHandler({
      ...streamOptions,
      autoClose: false
    });
    const config2 = ensureConfig(options2);
    const runId = config2.runId ?? v4$1();
    config2.runId = runId;
    const callbacks = config2.callbacks;
    if (callbacks === void 0) config2.callbacks = [eventStreamer];
    else if (Array.isArray(callbacks)) config2.callbacks = callbacks.concat(eventStreamer);
    else {
      const copiedCallbacks = callbacks.copy();
      copiedCallbacks.addHandler(eventStreamer, true);
      config2.callbacks = copiedCallbacks;
    }
    const abortController = new AbortController();
    const outerThis = this;
    async function consumeRunnableStream() {
      let signal;
      let listener = null;
      try {
        if (options2 == null ? void 0 : options2.signal) if ("any" in AbortSignal) signal = AbortSignal.any([abortController.signal, options2.signal]);
        else {
          signal = options2.signal;
          listener = () => {
            abortController.abort();
          };
          options2.signal.addEventListener("abort", listener, { once: true });
        }
        else signal = abortController.signal;
        const runnableStream = await outerThis.stream(input, {
          ...config2,
          signal
        });
        const tappedStream = eventStreamer.tapOutputIterable(runId, runnableStream);
        for await (const _ of tappedStream) if (abortController.signal.aborted) break;
      } finally {
        await eventStreamer.finish();
        if (signal && listener) signal.removeEventListener("abort", listener);
      }
    }
    const runnableStreamConsumePromise = consumeRunnableStream();
    let firstEventSent = false;
    let firstEventRunId;
    try {
      for await (const event of eventStreamer) {
        if (!firstEventSent) {
          event.data.input = input;
          firstEventSent = true;
          firstEventRunId = event.run_id;
          yield event;
          continue;
        }
        if (event.run_id === firstEventRunId && event.event.endsWith("_end")) {
          if ((_a3 = event.data) == null ? void 0 : _a3.input) delete event.data.input;
        }
        yield event;
      }
    } finally {
      abortController.abort();
      await runnableStreamConsumePromise;
    }
  }
  async *_streamEventsV1(input, options2, streamOptions) {
    let runLog;
    let hasEncounteredStartEvent = false;
    const config2 = ensureConfig(options2);
    const rootTags = config2.tags ?? [];
    const rootMetadata = config2.metadata ?? {};
    const rootName = config2.runName ?? this.getName();
    const logStreamCallbackHandler = new LogStreamCallbackHandler({
      ...streamOptions,
      autoClose: false,
      _schemaFormat: "streaming_events"
    });
    const rootEventFilter = new _RootEventFilter({ ...streamOptions });
    const logStream = this._streamLog(input, logStreamCallbackHandler, config2);
    for await (const log of logStream) {
      if (!runLog) runLog = RunLog.fromRunLogPatch(log);
      else runLog = runLog.concat(log);
      if (runLog.state === void 0) throw new Error(`Internal error: "streamEvents" state is missing. Please open a bug report.`);
      if (!hasEncounteredStartEvent) {
        hasEncounteredStartEvent = true;
        const state$2 = { ...runLog.state };
        const event = {
          run_id: state$2.id,
          event: `on_${state$2.type}_start`,
          name: rootName,
          tags: rootTags,
          metadata: rootMetadata,
          data: { input }
        };
        if (rootEventFilter.includeEvent(event, state$2.type)) yield event;
      }
      const paths = log.ops.filter((op) => op.path.startsWith("/logs/")).map((op) => op.path.split("/")[2]);
      const dedupedPaths = [...new Set(paths)];
      for (const path2 of dedupedPaths) {
        let eventType;
        let data = {};
        const logEntry = runLog.state.logs[path2];
        if (logEntry.end_time === void 0) if (logEntry.streamed_output.length > 0) eventType = "stream";
        else eventType = "start";
        else eventType = "end";
        if (eventType === "start") {
          if (logEntry.inputs !== void 0) data.input = logEntry.inputs;
        } else if (eventType === "end") {
          if (logEntry.inputs !== void 0) data.input = logEntry.inputs;
          data.output = logEntry.final_output;
        } else if (eventType === "stream") {
          const chunkCount = logEntry.streamed_output.length;
          if (chunkCount !== 1) throw new Error(`Expected exactly one chunk of streamed output, got ${chunkCount} instead. Encountered in: "${logEntry.name}"`);
          data = { chunk: logEntry.streamed_output[0] };
          logEntry.streamed_output = [];
        }
        yield {
          event: `on_${logEntry.type}_${eventType}`,
          name: logEntry.name,
          run_id: logEntry.id,
          tags: logEntry.tags,
          metadata: logEntry.metadata,
          data
        };
      }
      const { state: state$1 } = runLog;
      if (state$1.streamed_output.length > 0) {
        const chunkCount = state$1.streamed_output.length;
        if (chunkCount !== 1) throw new Error(`Expected exactly one chunk of streamed output, got ${chunkCount} instead. Encountered in: "${state$1.name}"`);
        const data = { chunk: state$1.streamed_output[0] };
        state$1.streamed_output = [];
        const event = {
          event: `on_${state$1.type}_stream`,
          run_id: state$1.id,
          tags: rootTags,
          metadata: rootMetadata,
          name: rootName,
          data
        };
        if (rootEventFilter.includeEvent(event, state$1.type)) yield event;
      }
    }
    const state = runLog == null ? void 0 : runLog.state;
    if (state !== void 0) {
      const event = {
        event: `on_${state.type}_end`,
        name: rootName,
        run_id: state.id,
        tags: rootTags,
        metadata: rootMetadata,
        data: { output: state.final_output }
      };
      if (rootEventFilter.includeEvent(event, state.type)) yield event;
    }
  }
  static isRunnable(thing) {
    return isRunnableInterface(thing);
  }
  /**
  * Bind lifecycle listeners to a Runnable, returning a new Runnable.
  * The Run object contains information about the run, including its id,
  * type, input, output, error, startTime, endTime, and any tags or metadata
  * added to the run.
  *
  * @param {Object} params - The object containing the callback functions.
  * @param {(run: Run) => void} params.onStart - Called before the runnable starts running, with the Run object.
  * @param {(run: Run) => void} params.onEnd - Called after the runnable finishes running, with the Run object.
  * @param {(run: Run) => void} params.onError - Called if the runnable throws an error, with the Run object.
  */
  withListeners({ onStart, onEnd, onError }) {
    return new RunnableBinding({
      bound: this,
      config: {},
      configFactories: [(config2) => ({ callbacks: [new RootListenersTracer({
        config: config2,
        onStart,
        onEnd,
        onError
      })] })]
    });
  }
  /**
  * Convert a runnable to a tool. Return a new instance of `RunnableToolLike`
  * which contains the runnable, name, description and schema.
  *
  * @template {T extends RunInput = RunInput} RunInput - The input type of the runnable. Should be the same as the `RunInput` type of the runnable.
  *
  * @param fields
  * @param {string | undefined} [fields.name] The name of the tool. If not provided, it will default to the name of the runnable.
  * @param {string | undefined} [fields.description] The description of the tool. Falls back to the description on the Zod schema if not provided, or undefined if neither are provided.
  * @param {z.ZodType<T>} [fields.schema] The Zod schema for the input of the tool. Infers the Zod type from the input type of the runnable.
  * @returns {RunnableToolLike<z.ZodType<T>, RunOutput>} An instance of `RunnableToolLike` which is a runnable that can be used as a tool.
  */
  asTool(fields) {
    return convertRunnableToTool(this, fields);
  }
};
var RunnableBinding = class RunnableBinding2 extends Runnable {
  constructor(fields) {
    super(fields);
    __publicField2(this, "lc_namespace", ["langchain_core", "runnables"]);
    __publicField2(this, "lc_serializable", true);
    __publicField2(this, "bound");
    __publicField2(this, "config");
    __publicField2(this, "kwargs");
    __publicField2(this, "configFactories");
    this.bound = fields.bound;
    this.kwargs = fields.kwargs;
    this.config = fields.config;
    this.configFactories = fields.configFactories;
  }
  static lc_name() {
    return "RunnableBinding";
  }
  getName(suffix) {
    return this.bound.getName(suffix);
  }
  async _mergeConfig(...options2) {
    const config2 = mergeConfigs(this.config, ...options2);
    return mergeConfigs(config2, ...this.configFactories ? await Promise.all(this.configFactories.map(async (configFactory) => await configFactory(config2))) : []);
  }
  withConfig(config2) {
    return new this.constructor({
      bound: this.bound,
      kwargs: this.kwargs,
      config: {
        ...this.config,
        ...config2
      }
    });
  }
  withRetry(fields) {
    return new RunnableRetry({
      bound: this.bound,
      kwargs: this.kwargs,
      config: this.config,
      maxAttemptNumber: fields == null ? void 0 : fields.stopAfterAttempt,
      ...fields
    });
  }
  async invoke(input, options2) {
    return this.bound.invoke(input, await this._mergeConfig(options2, this.kwargs));
  }
  async batch(inputs, options2, batchOptions) {
    const mergedOptions = Array.isArray(options2) ? await Promise.all(options2.map(async (individualOption) => this._mergeConfig(ensureConfig(individualOption), this.kwargs))) : await this._mergeConfig(ensureConfig(options2), this.kwargs);
    return this.bound.batch(inputs, mergedOptions, batchOptions);
  }
  /** @internal */
  _concatOutputChunks(first, second) {
    return this.bound._concatOutputChunks(first, second);
  }
  async *_streamIterator(input, options2) {
    yield* this.bound._streamIterator(input, await this._mergeConfig(ensureConfig(options2), this.kwargs));
  }
  async stream(input, options2) {
    return this.bound.stream(input, await this._mergeConfig(ensureConfig(options2), this.kwargs));
  }
  async *transform(generator, options2) {
    yield* this.bound.transform(generator, await this._mergeConfig(ensureConfig(options2), this.kwargs));
  }
  streamEvents(input, options2, streamOptions) {
    const outerThis = this;
    const generator = async function* () {
      yield* outerThis.bound.streamEvents(input, {
        ...await outerThis._mergeConfig(ensureConfig(options2), outerThis.kwargs),
        version: options2.version
      }, streamOptions);
    };
    return IterableReadableStream.fromAsyncGenerator(generator());
  }
  static isRunnableBinding(thing) {
    return thing.bound && Runnable.isRunnable(thing.bound);
  }
  /**
  * Bind lifecycle listeners to a Runnable, returning a new Runnable.
  * The Run object contains information about the run, including its id,
  * type, input, output, error, startTime, endTime, and any tags or metadata
  * added to the run.
  *
  * @param {Object} params - The object containing the callback functions.
  * @param {(run: Run) => void} params.onStart - Called before the runnable starts running, with the Run object.
  * @param {(run: Run) => void} params.onEnd - Called after the runnable finishes running, with the Run object.
  * @param {(run: Run) => void} params.onError - Called if the runnable throws an error, with the Run object.
  */
  withListeners({ onStart, onEnd, onError }) {
    return new RunnableBinding2({
      bound: this.bound,
      kwargs: this.kwargs,
      config: this.config,
      configFactories: [(config2) => ({ callbacks: [new RootListenersTracer({
        config: config2,
        onStart,
        onEnd,
        onError
      })] })]
    });
  }
};
var RunnableEach = class RunnableEach2 extends Runnable {
  constructor(fields) {
    super(fields);
    __publicField2(this, "lc_serializable", true);
    __publicField2(this, "lc_namespace", ["langchain_core", "runnables"]);
    __publicField2(this, "bound");
    this.bound = fields.bound;
  }
  static lc_name() {
    return "RunnableEach";
  }
  /**
  * Invokes the runnable with the specified input and configuration.
  * @param input The input to invoke the runnable with.
  * @param config The configuration to invoke the runnable with.
  * @returns A promise that resolves to the output of the runnable.
  */
  async invoke(inputs, config2) {
    return this._callWithConfig(this._invoke.bind(this), inputs, config2);
  }
  /**
  * A helper method that is used to invoke the runnable with the specified input and configuration.
  * @param input The input to invoke the runnable with.
  * @param config The configuration to invoke the runnable with.
  * @returns A promise that resolves to the output of the runnable.
  */
  async _invoke(inputs, config2, runManager) {
    return this.bound.batch(inputs, patchConfig(config2, { callbacks: runManager == null ? void 0 : runManager.getChild() }));
  }
  /**
  * Bind lifecycle listeners to a Runnable, returning a new Runnable.
  * The Run object contains information about the run, including its id,
  * type, input, output, error, startTime, endTime, and any tags or metadata
  * added to the run.
  *
  * @param {Object} params - The object containing the callback functions.
  * @param {(run: Run) => void} params.onStart - Called before the runnable starts running, with the Run object.
  * @param {(run: Run) => void} params.onEnd - Called after the runnable finishes running, with the Run object.
  * @param {(run: Run) => void} params.onError - Called if the runnable throws an error, with the Run object.
  */
  withListeners({ onStart, onEnd, onError }) {
    return new RunnableEach2({ bound: this.bound.withListeners({
      onStart,
      onEnd,
      onError
    }) });
  }
};
var RunnableRetry = class extends RunnableBinding {
  constructor(fields) {
    super(fields);
    __publicField2(this, "lc_namespace", ["langchain_core", "runnables"]);
    __publicField2(this, "maxAttemptNumber", 3);
    __publicField2(this, "onFailedAttempt", () => {
    });
    this.maxAttemptNumber = fields.maxAttemptNumber ?? this.maxAttemptNumber;
    this.onFailedAttempt = fields.onFailedAttempt ?? this.onFailedAttempt;
  }
  static lc_name() {
    return "RunnableRetry";
  }
  _patchConfigForRetry(attempt, config2, runManager) {
    const tag = attempt > 1 ? `retry:attempt:${attempt}` : void 0;
    return patchConfig(config2, { callbacks: runManager == null ? void 0 : runManager.getChild(tag) });
  }
  async _invoke(input, config2, runManager) {
    return pRetry((attemptNumber) => super.invoke(input, this._patchConfigForRetry(attemptNumber, config2, runManager)), {
      onFailedAttempt: ({ error }) => this.onFailedAttempt(error, input),
      retries: Math.max(this.maxAttemptNumber - 1, 0),
      randomize: true
    });
  }
  /**
  * Method that invokes the runnable with the specified input, run manager,
  * and config. It handles the retry logic by catching any errors and
  * recursively invoking itself with the updated config for the next retry
  * attempt.
  * @param input The input for the runnable.
  * @param runManager The run manager for the runnable.
  * @param config The config for the runnable.
  * @returns A promise that resolves to the output of the runnable.
  */
  async invoke(input, config2) {
    return this._callWithConfig(this._invoke.bind(this), input, config2);
  }
  async _batch(inputs, configs, runManagers, batchOptions) {
    const resultsMap = {};
    try {
      await pRetry(async (attemptNumber) => {
        const remainingIndexes = inputs.map((_, i2) => i2).filter((i2) => resultsMap[i2.toString()] === void 0 || resultsMap[i2.toString()] instanceof Error);
        const remainingInputs = remainingIndexes.map((i2) => inputs[i2]);
        const patchedConfigs = remainingIndexes.map((i2) => this._patchConfigForRetry(attemptNumber, configs == null ? void 0 : configs[i2], runManagers == null ? void 0 : runManagers[i2]));
        const results2 = await super.batch(remainingInputs, patchedConfigs, {
          ...batchOptions,
          returnExceptions: true
        });
        let firstException;
        for (let i2 = 0; i2 < results2.length; i2 += 1) {
          const result = results2[i2];
          const resultMapIndex = remainingIndexes[i2];
          if (result instanceof Error) {
            if (firstException === void 0) {
              firstException = result;
              firstException.input = remainingInputs[i2];
            }
          }
          resultsMap[resultMapIndex.toString()] = result;
        }
        if (firstException) throw firstException;
        return results2;
      }, {
        onFailedAttempt: ({ error }) => this.onFailedAttempt(error, error.input),
        retries: Math.max(this.maxAttemptNumber - 1, 0),
        randomize: true
      });
    } catch (e) {
      if ((batchOptions == null ? void 0 : batchOptions.returnExceptions) !== true) throw e;
    }
    return Object.keys(resultsMap).sort((a, b) => parseInt(a, 10) - parseInt(b, 10)).map((key) => resultsMap[parseInt(key, 10)]);
  }
  async batch(inputs, options2, batchOptions) {
    return this._batchWithConfig(this._batch.bind(this), inputs, options2, batchOptions);
  }
};
var RunnableSequence = class RunnableSequence2 extends Runnable {
  constructor(fields) {
    super(fields);
    __publicField2(this, "first");
    __publicField2(this, "middle", []);
    __publicField2(this, "last");
    __publicField2(this, "omitSequenceTags", false);
    __publicField2(this, "lc_serializable", true);
    __publicField2(this, "lc_namespace", ["langchain_core", "runnables"]);
    this.first = fields.first;
    this.middle = fields.middle ?? this.middle;
    this.last = fields.last;
    this.name = fields.name;
    this.omitSequenceTags = fields.omitSequenceTags ?? this.omitSequenceTags;
  }
  static lc_name() {
    return "RunnableSequence";
  }
  get steps() {
    return [
      this.first,
      ...this.middle,
      this.last
    ];
  }
  async invoke(input, options2) {
    var _a3;
    const config2 = ensureConfig(options2);
    const callbackManager_ = await getCallbackManagerForConfig(config2);
    const runManager = await (callbackManager_ == null ? void 0 : callbackManager_.handleChainStart(this.toJSON(), _coerceToDict(input, "input"), config2.runId, void 0, void 0, void 0, config2 == null ? void 0 : config2.runName));
    delete config2.runId;
    let nextStepInput = input;
    let finalOutput;
    try {
      const initialSteps = [this.first, ...this.middle];
      for (let i2 = 0; i2 < initialSteps.length; i2 += 1) {
        const step = initialSteps[i2];
        const promise = step.invoke(nextStepInput, patchConfig(config2, { callbacks: runManager == null ? void 0 : runManager.getChild(this.omitSequenceTags ? void 0 : `seq:step:${i2 + 1}`) }));
        nextStepInput = await raceWithSignal(promise, options2 == null ? void 0 : options2.signal);
      }
      if ((_a3 = options2 == null ? void 0 : options2.signal) == null ? void 0 : _a3.aborted) throw getAbortSignalError(options2.signal);
      finalOutput = await this.last.invoke(nextStepInput, patchConfig(config2, { callbacks: runManager == null ? void 0 : runManager.getChild(this.omitSequenceTags ? void 0 : `seq:step:${this.steps.length}`) }));
    } catch (e) {
      await (runManager == null ? void 0 : runManager.handleChainError(e));
      throw e;
    }
    await (runManager == null ? void 0 : runManager.handleChainEnd(_coerceToDict(finalOutput, "output")));
    return finalOutput;
  }
  async batch(inputs, options2, batchOptions) {
    var _a3;
    const configList = this._getOptionsList(options2 ?? {}, inputs.length);
    const callbackManagers = await Promise.all(configList.map(getCallbackManagerForConfig));
    const runManagers = await Promise.all(callbackManagers.map(async (callbackManager, i2) => {
      const handleStartRes = await (callbackManager == null ? void 0 : callbackManager.handleChainStart(this.toJSON(), _coerceToDict(inputs[i2], "input"), configList[i2].runId, void 0, void 0, void 0, configList[i2].runName));
      delete configList[i2].runId;
      return handleStartRes;
    }));
    let nextStepInputs = inputs;
    try {
      for (let i2 = 0; i2 < this.steps.length; i2 += 1) {
        const step = this.steps[i2];
        const promise = step.batch(nextStepInputs, runManagers.map((runManager, j) => {
          const childRunManager = runManager == null ? void 0 : runManager.getChild(this.omitSequenceTags ? void 0 : `seq:step:${i2 + 1}`);
          return patchConfig(configList[j], { callbacks: childRunManager });
        }), batchOptions);
        nextStepInputs = await raceWithSignal(promise, (_a3 = configList[0]) == null ? void 0 : _a3.signal);
      }
    } catch (e) {
      await Promise.all(runManagers.map((runManager) => runManager == null ? void 0 : runManager.handleChainError(e)));
      throw e;
    }
    await Promise.all(runManagers.map((runManager) => runManager == null ? void 0 : runManager.handleChainEnd(_coerceToDict(nextStepInputs, "output"))));
    return nextStepInputs;
  }
  /** @internal */
  _concatOutputChunks(first, second) {
    return this.last._concatOutputChunks(first, second);
  }
  async *_streamIterator(input, options2) {
    var _a3;
    const callbackManager_ = await getCallbackManagerForConfig(options2);
    const { runId, ...otherOptions } = options2 ?? {};
    const runManager = await (callbackManager_ == null ? void 0 : callbackManager_.handleChainStart(this.toJSON(), _coerceToDict(input, "input"), runId, void 0, void 0, void 0, otherOptions == null ? void 0 : otherOptions.runName));
    const steps = [
      this.first,
      ...this.middle,
      this.last
    ];
    let concatSupported = true;
    let finalOutput;
    async function* inputGenerator() {
      yield input;
    }
    try {
      let finalGenerator = steps[0].transform(inputGenerator(), patchConfig(otherOptions, { callbacks: runManager == null ? void 0 : runManager.getChild(this.omitSequenceTags ? void 0 : `seq:step:1`) }));
      for (let i2 = 1; i2 < steps.length; i2 += 1) {
        const step = steps[i2];
        finalGenerator = await step.transform(finalGenerator, patchConfig(otherOptions, { callbacks: runManager == null ? void 0 : runManager.getChild(this.omitSequenceTags ? void 0 : `seq:step:${i2 + 1}`) }));
      }
      for await (const chunk of finalGenerator) {
        (_a3 = options2 == null ? void 0 : options2.signal) == null ? void 0 : _a3.throwIfAborted();
        yield chunk;
        if (concatSupported) if (finalOutput === void 0) finalOutput = chunk;
        else try {
          finalOutput = this._concatOutputChunks(finalOutput, chunk);
        } catch {
          finalOutput = void 0;
          concatSupported = false;
        }
      }
    } catch (e) {
      await (runManager == null ? void 0 : runManager.handleChainError(e));
      throw e;
    }
    await (runManager == null ? void 0 : runManager.handleChainEnd(_coerceToDict(finalOutput, "output")));
  }
  getGraph(config2) {
    const graph = new Graph();
    let currentLastNode = null;
    this.steps.forEach((step, index) => {
      const stepGraph = step.getGraph(config2);
      if (index !== 0) stepGraph.trimFirstNode();
      if (index !== this.steps.length - 1) stepGraph.trimLastNode();
      graph.extend(stepGraph);
      const stepFirstNode = stepGraph.firstNode();
      if (!stepFirstNode) throw new Error(`Runnable ${step} has no first node`);
      if (currentLastNode) graph.addEdge(currentLastNode, stepFirstNode);
      currentLastNode = stepGraph.lastNode();
    });
    return graph;
  }
  pipe(coerceable) {
    if (RunnableSequence2.isRunnableSequence(coerceable)) return new RunnableSequence2({
      first: this.first,
      middle: this.middle.concat([
        this.last,
        coerceable.first,
        ...coerceable.middle
      ]),
      last: coerceable.last,
      name: this.name ?? coerceable.name
    });
    else return new RunnableSequence2({
      first: this.first,
      middle: [...this.middle, this.last],
      last: _coerceToRunnable(coerceable),
      name: this.name
    });
  }
  static isRunnableSequence(thing) {
    return Array.isArray(thing.middle) && Runnable.isRunnable(thing);
  }
  static from([first, ...runnables], nameOrFields) {
    let extra = {};
    if (typeof nameOrFields === "string") extra.name = nameOrFields;
    else if (nameOrFields !== void 0) extra = nameOrFields;
    return new RunnableSequence2({
      ...extra,
      first: _coerceToRunnable(first),
      middle: runnables.slice(0, -1).map(_coerceToRunnable),
      last: _coerceToRunnable(runnables[runnables.length - 1])
    });
  }
};
var RunnableMap = class RunnableMap2 extends Runnable {
  constructor(fields) {
    super(fields);
    __publicField2(this, "lc_namespace", ["langchain_core", "runnables"]);
    __publicField2(this, "lc_serializable", true);
    __publicField2(this, "steps");
    this.steps = {};
    for (const [key, value] of Object.entries(fields.steps)) this.steps[key] = _coerceToRunnable(value);
  }
  static lc_name() {
    return "RunnableMap";
  }
  getStepsKeys() {
    return Object.keys(this.steps);
  }
  static from(steps) {
    return new RunnableMap2({ steps });
  }
  async invoke(input, options2) {
    const config2 = ensureConfig(options2);
    const callbackManager_ = await getCallbackManagerForConfig(config2);
    const runManager = await (callbackManager_ == null ? void 0 : callbackManager_.handleChainStart(this.toJSON(), { input }, config2.runId, void 0, void 0, void 0, config2 == null ? void 0 : config2.runName));
    delete config2.runId;
    const output = {};
    try {
      const promises = Object.entries(this.steps).map(async ([key, runnable]) => {
        output[key] = await runnable.invoke(input, patchConfig(config2, { callbacks: runManager == null ? void 0 : runManager.getChild(`map:key:${key}`) }));
      });
      await raceWithSignal(Promise.all(promises), options2 == null ? void 0 : options2.signal);
    } catch (e) {
      await (runManager == null ? void 0 : runManager.handleChainError(e));
      throw e;
    }
    await (runManager == null ? void 0 : runManager.handleChainEnd(output));
    return output;
  }
  async *_transform(generator, runManager, options2) {
    const steps = { ...this.steps };
    const inputCopies = atee(generator, Object.keys(steps).length);
    const tasks = new Map(Object.entries(steps).map(([key, runnable], i2) => {
      const gen = runnable.transform(inputCopies[i2], patchConfig(options2, { callbacks: runManager == null ? void 0 : runManager.getChild(`map:key:${key}`) }));
      return [key, gen.next().then((result) => ({
        key,
        gen,
        result
      }))];
    }));
    while (tasks.size) {
      const promise = Promise.race(tasks.values());
      const { key, result, gen } = await raceWithSignal(promise, options2 == null ? void 0 : options2.signal);
      tasks.delete(key);
      if (!result.done) {
        yield { [key]: result.value };
        tasks.set(key, gen.next().then((result$1) => ({
          key,
          gen,
          result: result$1
        })));
      }
    }
  }
  transform(generator, options2) {
    return this._transformStreamWithConfig(generator, this._transform.bind(this), options2);
  }
  async stream(input, options2) {
    async function* generator() {
      yield input;
    }
    const config2 = ensureConfig(options2);
    const wrappedGenerator = new AsyncGeneratorWithSetup({
      generator: this.transform(generator(), config2),
      config: config2
    });
    await wrappedGenerator.setup;
    return IterableReadableStream.fromAsyncGenerator(wrappedGenerator);
  }
};
var RunnableTraceable = class RunnableTraceable2 extends Runnable {
  constructor(fields) {
    super(fields);
    __publicField2(this, "lc_serializable", false);
    __publicField2(this, "lc_namespace", ["langchain_core", "runnables"]);
    __publicField2(this, "func");
    if (!isTraceableFunction(fields.func)) throw new Error("RunnableTraceable requires a function that is wrapped in traceable higher-order function");
    this.func = fields.func;
  }
  async invoke(input, options2) {
    const [config2] = this._getOptionsList(options2 ?? {}, 1);
    const callbacks = await getCallbackManagerForConfig(config2);
    const promise = this.func(patchConfig(config2, { callbacks }), input);
    return raceWithSignal(promise, config2 == null ? void 0 : config2.signal);
  }
  async *_streamIterator(input, options2) {
    var _a3, _b;
    const [config2] = this._getOptionsList(options2 ?? {}, 1);
    const result = await this.invoke(input, options2);
    if (isAsyncIterable(result)) {
      for await (const item of result) {
        (_a3 = config2 == null ? void 0 : config2.signal) == null ? void 0 : _a3.throwIfAborted();
        yield item;
      }
      return;
    }
    if (isIterator(result)) {
      while (true) {
        (_b = config2 == null ? void 0 : config2.signal) == null ? void 0 : _b.throwIfAborted();
        const state = result.next();
        if (state.done) break;
        yield state.value;
      }
      return;
    }
    yield result;
  }
  static from(func) {
    return new RunnableTraceable2({ func });
  }
};
function assertNonTraceableFunction(func) {
  if (isTraceableFunction(func)) throw new Error("RunnableLambda requires a function that is not wrapped in traceable higher-order function. This shouldn't happen.");
}
var RunnableLambda = class RunnableLambda2 extends Runnable {
  constructor(fields) {
    if (isTraceableFunction(fields.func)) return RunnableTraceable.from(fields.func);
    super(fields);
    __publicField2(this, "lc_namespace", ["langchain_core", "runnables"]);
    __publicField2(this, "func");
    assertNonTraceableFunction(fields.func);
    this.func = fields.func;
  }
  static lc_name() {
    return "RunnableLambda";
  }
  static from(func) {
    return new RunnableLambda2({ func });
  }
  async _invoke(input, config2, runManager) {
    return new Promise((resolve, reject) => {
      const childConfig = patchConfig(config2, {
        callbacks: runManager == null ? void 0 : runManager.getChild(),
        recursionLimit: ((config2 == null ? void 0 : config2.recursionLimit) ?? DEFAULT_RECURSION_LIMIT) - 1
      });
      AsyncLocalStorageProviderSingleton.runWithConfig(pickRunnableConfigKeys(childConfig), async () => {
        var _a3, _b;
        try {
          let output = await this.func(input, { ...childConfig });
          if (output && Runnable.isRunnable(output)) {
            if ((config2 == null ? void 0 : config2.recursionLimit) === 0) throw new Error("Recursion limit reached.");
            output = await output.invoke(input, {
              ...childConfig,
              recursionLimit: (childConfig.recursionLimit ?? DEFAULT_RECURSION_LIMIT) - 1
            });
          } else if (isAsyncIterable(output)) {
            let finalOutput;
            for await (const chunk of consumeAsyncIterableInContext(childConfig, output)) {
              (_a3 = config2 == null ? void 0 : config2.signal) == null ? void 0 : _a3.throwIfAborted();
              if (finalOutput === void 0) finalOutput = chunk;
              else try {
                finalOutput = this._concatOutputChunks(finalOutput, chunk);
              } catch {
                finalOutput = chunk;
              }
            }
            output = finalOutput;
          } else if (isIterableIterator(output)) {
            let finalOutput;
            for (const chunk of consumeIteratorInContext(childConfig, output)) {
              (_b = config2 == null ? void 0 : config2.signal) == null ? void 0 : _b.throwIfAborted();
              if (finalOutput === void 0) finalOutput = chunk;
              else try {
                finalOutput = this._concatOutputChunks(finalOutput, chunk);
              } catch {
                finalOutput = chunk;
              }
            }
            output = finalOutput;
          }
          resolve(output);
        } catch (e) {
          reject(e);
        }
      });
    });
  }
  async invoke(input, options2) {
    return this._callWithConfig(this._invoke.bind(this), input, options2);
  }
  async *_transform(generator, runManager, config2) {
    var _a3, _b;
    let finalChunk;
    for await (const chunk of generator) if (finalChunk === void 0) finalChunk = chunk;
    else try {
      finalChunk = this._concatOutputChunks(finalChunk, chunk);
    } catch {
      finalChunk = chunk;
    }
    const childConfig = patchConfig(config2, {
      callbacks: runManager == null ? void 0 : runManager.getChild(),
      recursionLimit: ((config2 == null ? void 0 : config2.recursionLimit) ?? DEFAULT_RECURSION_LIMIT) - 1
    });
    const output = await new Promise((resolve, reject) => {
      AsyncLocalStorageProviderSingleton.runWithConfig(pickRunnableConfigKeys(childConfig), async () => {
        try {
          const res = await this.func(finalChunk, {
            ...childConfig,
            config: childConfig
          });
          resolve(res);
        } catch (e) {
          reject(e);
        }
      });
    });
    if (output && Runnable.isRunnable(output)) {
      if ((config2 == null ? void 0 : config2.recursionLimit) === 0) throw new Error("Recursion limit reached.");
      const stream = await output.stream(finalChunk, childConfig);
      for await (const chunk of stream) yield chunk;
    } else if (isAsyncIterable(output)) for await (const chunk of consumeAsyncIterableInContext(childConfig, output)) {
      (_a3 = config2 == null ? void 0 : config2.signal) == null ? void 0 : _a3.throwIfAborted();
      yield chunk;
    }
    else if (isIterableIterator(output)) for (const chunk of consumeIteratorInContext(childConfig, output)) {
      (_b = config2 == null ? void 0 : config2.signal) == null ? void 0 : _b.throwIfAborted();
      yield chunk;
    }
    else yield output;
  }
  transform(generator, options2) {
    return this._transformStreamWithConfig(generator, this._transform.bind(this), options2);
  }
  async stream(input, options2) {
    async function* generator() {
      yield input;
    }
    const config2 = ensureConfig(options2);
    const wrappedGenerator = new AsyncGeneratorWithSetup({
      generator: this.transform(generator(), config2),
      config: config2
    });
    await wrappedGenerator.setup;
    return IterableReadableStream.fromAsyncGenerator(wrappedGenerator);
  }
};
var RunnableParallel = class extends RunnableMap {
};
var RunnableWithFallbacks = class extends Runnable {
  constructor(fields) {
    super(fields);
    __publicField2(this, "lc_namespace", ["langchain_core", "runnables"]);
    __publicField2(this, "lc_serializable", true);
    __publicField2(this, "runnable");
    __publicField2(this, "fallbacks");
    this.runnable = fields.runnable;
    this.fallbacks = fields.fallbacks;
  }
  static lc_name() {
    return "RunnableWithFallbacks";
  }
  *runnables() {
    yield this.runnable;
    for (const fallback of this.fallbacks) yield fallback;
  }
  async invoke(input, options2) {
    const config2 = ensureConfig(options2);
    const callbackManager_ = await getCallbackManagerForConfig(config2);
    const { runId, ...otherConfigFields } = config2;
    const runManager = await (callbackManager_ == null ? void 0 : callbackManager_.handleChainStart(this.toJSON(), _coerceToDict(input, "input"), runId, void 0, void 0, void 0, otherConfigFields == null ? void 0 : otherConfigFields.runName));
    const childConfig = patchConfig(otherConfigFields, { callbacks: runManager == null ? void 0 : runManager.getChild() });
    const res = await AsyncLocalStorageProviderSingleton.runWithConfig(childConfig, async () => {
      var _a3;
      let firstError;
      for (const runnable of this.runnables()) {
        (_a3 = config2 == null ? void 0 : config2.signal) == null ? void 0 : _a3.throwIfAborted();
        try {
          const output = await runnable.invoke(input, childConfig);
          await (runManager == null ? void 0 : runManager.handleChainEnd(_coerceToDict(output, "output")));
          return output;
        } catch (e) {
          if (firstError === void 0) firstError = e;
        }
      }
      if (firstError === void 0) throw new Error("No error stored at end of fallback.");
      await (runManager == null ? void 0 : runManager.handleChainError(firstError));
      throw firstError;
    });
    return res;
  }
  async *_streamIterator(input, options2) {
    var _a3;
    const config2 = ensureConfig(options2);
    const callbackManager_ = await getCallbackManagerForConfig(config2);
    const { runId, ...otherConfigFields } = config2;
    const runManager = await (callbackManager_ == null ? void 0 : callbackManager_.handleChainStart(this.toJSON(), _coerceToDict(input, "input"), runId, void 0, void 0, void 0, otherConfigFields == null ? void 0 : otherConfigFields.runName));
    let firstError;
    let stream;
    for (const runnable of this.runnables()) {
      (_a3 = config2 == null ? void 0 : config2.signal) == null ? void 0 : _a3.throwIfAborted();
      const childConfig = patchConfig(otherConfigFields, { callbacks: runManager == null ? void 0 : runManager.getChild() });
      try {
        const originalStream = await runnable.stream(input, childConfig);
        stream = consumeAsyncIterableInContext(childConfig, originalStream);
        break;
      } catch (e) {
        if (firstError === void 0) firstError = e;
      }
    }
    if (stream === void 0) {
      const error = firstError ?? /* @__PURE__ */ new Error("No error stored at end of fallback.");
      await (runManager == null ? void 0 : runManager.handleChainError(error));
      throw error;
    }
    let output;
    try {
      for await (const chunk of stream) {
        yield chunk;
        try {
          output = output === void 0 ? output : this._concatOutputChunks(output, chunk);
        } catch {
          output = void 0;
        }
      }
    } catch (e) {
      await (runManager == null ? void 0 : runManager.handleChainError(e));
      throw e;
    }
    await (runManager == null ? void 0 : runManager.handleChainEnd(_coerceToDict(output, "output")));
  }
  async batch(inputs, options2, batchOptions) {
    var _a3;
    if (batchOptions == null ? void 0 : batchOptions.returnExceptions) throw new Error("Not implemented.");
    const configList = this._getOptionsList(options2 ?? {}, inputs.length);
    const callbackManagers = await Promise.all(configList.map((config2) => getCallbackManagerForConfig(config2)));
    const runManagers = await Promise.all(callbackManagers.map(async (callbackManager, i2) => {
      const handleStartRes = await (callbackManager == null ? void 0 : callbackManager.handleChainStart(this.toJSON(), _coerceToDict(inputs[i2], "input"), configList[i2].runId, void 0, void 0, void 0, configList[i2].runName));
      delete configList[i2].runId;
      return handleStartRes;
    }));
    let firstError;
    for (const runnable of this.runnables()) {
      (_a3 = configList[0].signal) == null ? void 0 : _a3.throwIfAborted();
      try {
        const outputs = await runnable.batch(inputs, runManagers.map((runManager, j) => patchConfig(configList[j], { callbacks: runManager == null ? void 0 : runManager.getChild() })), batchOptions);
        await Promise.all(runManagers.map((runManager, i2) => runManager == null ? void 0 : runManager.handleChainEnd(_coerceToDict(outputs[i2], "output"))));
        return outputs;
      } catch (e) {
        if (firstError === void 0) firstError = e;
      }
    }
    if (!firstError) throw new Error("No error stored at end of fallbacks.");
    await Promise.all(runManagers.map((runManager) => runManager == null ? void 0 : runManager.handleChainError(firstError)));
    throw firstError;
  }
};
function _coerceToRunnable(coerceable) {
  if (typeof coerceable === "function") return new RunnableLambda({ func: coerceable });
  else if (Runnable.isRunnable(coerceable)) return coerceable;
  else if (!Array.isArray(coerceable) && typeof coerceable === "object") {
    const runnables = {};
    for (const [key, value] of Object.entries(coerceable)) runnables[key] = _coerceToRunnable(value);
    return new RunnableMap({ steps: runnables });
  } else throw new Error(`Expected a Runnable, function or object.
Instead got an unsupported type.`);
}
var RunnableAssign = class extends Runnable {
  constructor(fields) {
    if (fields instanceof RunnableMap) fields = { mapper: fields };
    super(fields);
    __publicField2(this, "lc_namespace", ["langchain_core", "runnables"]);
    __publicField2(this, "lc_serializable", true);
    __publicField2(this, "mapper");
    this.mapper = fields.mapper;
  }
  static lc_name() {
    return "RunnableAssign";
  }
  async invoke(input, options2) {
    const mapperResult = await this.mapper.invoke(input, options2);
    return {
      ...input,
      ...mapperResult
    };
  }
  async *_transform(generator, runManager, options2) {
    const mapperKeys = this.mapper.getStepsKeys();
    const [forPassthrough, forMapper] = atee(generator);
    const mapperOutput = this.mapper.transform(forMapper, patchConfig(options2, { callbacks: runManager == null ? void 0 : runManager.getChild() }));
    const firstMapperChunkPromise = mapperOutput.next();
    for await (const chunk of forPassthrough) {
      if (typeof chunk !== "object" || Array.isArray(chunk)) throw new Error(`RunnableAssign can only be used with objects as input, got ${typeof chunk}`);
      const filtered = Object.fromEntries(Object.entries(chunk).filter(([key]) => !mapperKeys.includes(key)));
      if (Object.keys(filtered).length > 0) yield filtered;
    }
    yield (await firstMapperChunkPromise).value;
    for await (const chunk of mapperOutput) yield chunk;
  }
  transform(generator, options2) {
    return this._transformStreamWithConfig(generator, this._transform.bind(this), options2);
  }
  async stream(input, options2) {
    async function* generator() {
      yield input;
    }
    const config2 = ensureConfig(options2);
    const wrappedGenerator = new AsyncGeneratorWithSetup({
      generator: this.transform(generator(), config2),
      config: config2
    });
    await wrappedGenerator.setup;
    return IterableReadableStream.fromAsyncGenerator(wrappedGenerator);
  }
};
var RunnablePick = class extends Runnable {
  constructor(fields) {
    if (typeof fields === "string" || Array.isArray(fields)) fields = { keys: fields };
    super(fields);
    __publicField2(this, "lc_namespace", ["langchain_core", "runnables"]);
    __publicField2(this, "lc_serializable", true);
    __publicField2(this, "keys");
    this.keys = fields.keys;
  }
  static lc_name() {
    return "RunnablePick";
  }
  async _pick(input) {
    if (typeof this.keys === "string") return input[this.keys];
    else {
      const picked = this.keys.map((key) => [key, input[key]]).filter((v) => v[1] !== void 0);
      return picked.length === 0 ? void 0 : Object.fromEntries(picked);
    }
  }
  async invoke(input, options2) {
    return this._callWithConfig(this._pick.bind(this), input, options2);
  }
  async *_transform(generator) {
    for await (const chunk of generator) {
      const picked = await this._pick(chunk);
      if (picked !== void 0) yield picked;
    }
  }
  transform(generator, options2) {
    return this._transformStreamWithConfig(generator, this._transform.bind(this), options2);
  }
  async stream(input, options2) {
    async function* generator() {
      yield input;
    }
    const config2 = ensureConfig(options2);
    const wrappedGenerator = new AsyncGeneratorWithSetup({
      generator: this.transform(generator(), config2),
      config: config2
    });
    await wrappedGenerator.setup;
    return IterableReadableStream.fromAsyncGenerator(wrappedGenerator);
  }
};
var RunnableToolLike = class extends RunnableBinding {
  constructor(fields) {
    const sequence = RunnableSequence.from([RunnableLambda.from(async (input) => {
      let toolInput;
      if (_isToolCall(input)) try {
        toolInput = await interopParseAsync(this.schema, input.args);
      } catch {
        throw new ToolInputParsingException(`Received tool input did not match expected schema`, JSON.stringify(input.args));
      }
      else toolInput = input;
      return toolInput;
    }).withConfig({ runName: `${fields.name}:parse_input` }), fields.bound]).withConfig({ runName: fields.name });
    super({
      bound: sequence,
      config: fields.config ?? {}
    });
    __publicField2(this, "name");
    __publicField2(this, "description");
    __publicField2(this, "schema");
    this.name = fields.name;
    this.description = fields.description;
    this.schema = fields.schema;
  }
  static lc_name() {
    return "RunnableToolLike";
  }
};
function convertRunnableToTool(runnable, fields) {
  const name = fields.name ?? runnable.getName();
  const description = fields.description ?? getSchemaDescription(fields.schema);
  if (isSimpleStringZodSchema(fields.schema)) return new RunnableToolLike({
    name,
    description,
    schema: objectType({ input: stringType() }).transform((input) => input.input),
    bound: runnable
  });
  return new RunnableToolLike({
    name,
    description,
    schema: fields.schema,
    bound: runnable
  });
}
const _isMessageType = (msg, types) => {
  const typesAsStrings = [...new Set(types == null ? void 0 : types.map((t2) => {
    if (typeof t2 === "string") return t2;
    const instantiatedMsgClass = new t2({});
    if (!("getType" in instantiatedMsgClass) || typeof instantiatedMsgClass.getType !== "function") throw new Error("Invalid type provided.");
    return instantiatedMsgClass.getType();
  }))];
  const msgType = msg.getType();
  return typesAsStrings.some((t2) => t2 === msgType);
};
function filterMessages(messagesOrOptions, options2) {
  if (Array.isArray(messagesOrOptions)) return _filterMessages(messagesOrOptions, options2);
  return RunnableLambda.from((input) => {
    return _filterMessages(input, messagesOrOptions);
  });
}
function _filterMessages(messages, options2 = {}) {
  const { includeNames, excludeNames, includeTypes, excludeTypes, includeIds, excludeIds } = options2;
  const filtered = [];
  for (const msg of messages) {
    if (excludeNames && msg.name && excludeNames.includes(msg.name)) continue;
    else if (excludeTypes && _isMessageType(msg, excludeTypes)) continue;
    else if (excludeIds && msg.id && excludeIds.includes(msg.id)) continue;
    if (!(includeTypes || includeIds || includeNames)) filtered.push(msg);
    else if (includeNames && msg.name && includeNames.some((iName) => iName === msg.name)) filtered.push(msg);
    else if (includeTypes && _isMessageType(msg, includeTypes)) filtered.push(msg);
    else if (includeIds && msg.id && includeIds.some((id) => id === msg.id)) filtered.push(msg);
  }
  return filtered;
}
function mergeMessageRuns(messages) {
  if (Array.isArray(messages)) return _mergeMessageRuns(messages);
  return RunnableLambda.from(_mergeMessageRuns);
}
function _mergeMessageRuns(messages) {
  if (!messages.length) return [];
  const merged = [];
  for (const msg of messages) {
    const curr = msg;
    const last = merged.pop();
    if (!last) merged.push(curr);
    else if (curr.getType() === "tool" || !(curr.getType() === last.getType())) merged.push(last, curr);
    else {
      const lastChunk = convertToChunk(last);
      const currChunk = convertToChunk(curr);
      const mergedChunks = lastChunk.concat(currChunk);
      if (typeof lastChunk.content === "string" && typeof currChunk.content === "string") mergedChunks.content = `${lastChunk.content}
${currChunk.content}`;
      merged.push(_chunkToMsg(mergedChunks));
    }
  }
  return merged;
}
function trimMessages(messagesOrOptions, options2) {
  if (Array.isArray(messagesOrOptions)) {
    const messages = messagesOrOptions;
    if (!options2) throw new Error("Options parameter is required when providing messages.");
    return _trimMessagesHelper(messages, options2);
  } else {
    const trimmerOptions = messagesOrOptions;
    return RunnableLambda.from((input) => _trimMessagesHelper(input, trimmerOptions)).withConfig({ runName: "trim_messages" });
  }
}
async function _trimMessagesHelper(messages, options2) {
  const { maxTokens, tokenCounter, strategy = "last", allowPartial = false, endOn, startOn, includeSystem = false, textSplitter } = options2;
  if (startOn && strategy === "first") throw new Error("`startOn` should only be specified if `strategy` is 'last'.");
  if (includeSystem && strategy === "first") throw new Error("`includeSystem` should only be specified if `strategy` is 'last'.");
  let listTokenCounter;
  if ("getNumTokens" in tokenCounter) listTokenCounter = async (msgs) => {
    const tokenCounts = await Promise.all(msgs.map((msg) => tokenCounter.getNumTokens(msg.content)));
    return tokenCounts.reduce((sum, count) => sum + count, 0);
  };
  else listTokenCounter = async (msgs) => tokenCounter(msgs);
  let textSplitterFunc = defaultTextSplitter;
  if (textSplitter) if ("splitText" in textSplitter) textSplitterFunc = textSplitter.splitText;
  else textSplitterFunc = async (text) => textSplitter(text);
  if (strategy === "first") return _firstMaxTokens(messages, {
    maxTokens,
    tokenCounter: listTokenCounter,
    textSplitter: textSplitterFunc,
    partialStrategy: allowPartial ? "first" : void 0,
    endOn
  });
  else if (strategy === "last") return _lastMaxTokens(messages, {
    maxTokens,
    tokenCounter: listTokenCounter,
    textSplitter: textSplitterFunc,
    allowPartial,
    includeSystem,
    startOn,
    endOn
  });
  else throw new Error(`Unrecognized strategy: '${strategy}'. Must be one of 'first' or 'last'.`);
}
async function _firstMaxTokens(messages, options2) {
  const { maxTokens, tokenCounter, textSplitter, partialStrategy, endOn } = options2;
  let messagesCopy = [...messages];
  let idx = 0;
  for (let i2 = 0; i2 < messagesCopy.length; i2 += 1) {
    const remainingMessages = i2 > 0 ? messagesCopy.slice(0, -i2) : messagesCopy;
    if (await tokenCounter(remainingMessages) <= maxTokens) {
      idx = messagesCopy.length - i2;
      break;
    }
  }
  if (idx < messagesCopy.length && partialStrategy) {
    let includedPartial = false;
    if (Array.isArray(messagesCopy[idx].content)) {
      const excluded = messagesCopy[idx];
      if (typeof excluded.content === "string") throw new Error("Expected content to be an array.");
      const numBlock = excluded.content.length;
      const reversedContent = partialStrategy === "last" ? [...excluded.content].reverse() : excluded.content;
      for (let i2 = 1; i2 <= numBlock; i2 += 1) {
        const partialContent = partialStrategy === "first" ? reversedContent.slice(0, i2) : reversedContent.slice(-i2);
        const fields = Object.fromEntries(Object.entries(excluded).filter(([k]) => k !== "type" && !k.startsWith("lc_")));
        const updatedMessage = _switchTypeToMessage(excluded.getType(), {
          ...fields,
          content: partialContent
        });
        const slicedMessages = [...messagesCopy.slice(0, idx), updatedMessage];
        if (await tokenCounter(slicedMessages) <= maxTokens) {
          messagesCopy = slicedMessages;
          idx += 1;
          includedPartial = true;
        } else break;
      }
      if (includedPartial && partialStrategy === "last") excluded.content = [...reversedContent].reverse();
    }
    if (!includedPartial) {
      const excluded = messagesCopy[idx];
      let text;
      if (Array.isArray(excluded.content) && excluded.content.some((block) => typeof block === "string" || block.type === "text")) {
        const textBlock = excluded.content.find((block) => block.type === "text" && block.text);
        text = textBlock == null ? void 0 : textBlock.text;
      } else if (typeof excluded.content === "string") text = excluded.content;
      if (text) {
        const splitTexts = await textSplitter(text);
        const numSplits = splitTexts.length;
        if (partialStrategy === "last") splitTexts.reverse();
        for (let _ = 0; _ < numSplits - 1; _ += 1) {
          splitTexts.pop();
          excluded.content = splitTexts.join("");
          if (await tokenCounter([...messagesCopy.slice(0, idx), excluded]) <= maxTokens) {
            if (partialStrategy === "last") excluded.content = [...splitTexts].reverse().join("");
            messagesCopy = [...messagesCopy.slice(0, idx), excluded];
            idx += 1;
            break;
          }
        }
      }
    }
  }
  if (endOn) {
    const endOnArr = Array.isArray(endOn) ? endOn : [endOn];
    while (idx > 0 && !_isMessageType(messagesCopy[idx - 1], endOnArr)) idx -= 1;
  }
  return messagesCopy.slice(0, idx);
}
async function _lastMaxTokens(messages, options2) {
  var _a3;
  const { allowPartial = false, includeSystem = false, endOn, startOn, ...rest } = options2;
  let messagesCopy = messages.map((message) => {
    const fields = Object.fromEntries(Object.entries(message).filter(([k]) => k !== "type" && !k.startsWith("lc_")));
    return _switchTypeToMessage(message.getType(), fields, isBaseMessageChunk(message));
  });
  if (endOn) {
    const endOnArr = Array.isArray(endOn) ? endOn : [endOn];
    while (messagesCopy.length > 0 && !_isMessageType(messagesCopy[messagesCopy.length - 1], endOnArr)) messagesCopy = messagesCopy.slice(0, -1);
  }
  const swappedSystem = includeSystem && ((_a3 = messagesCopy[0]) == null ? void 0 : _a3.getType()) === "system";
  let reversed_ = swappedSystem ? messagesCopy.slice(0, 1).concat(messagesCopy.slice(1).reverse()) : messagesCopy.reverse();
  reversed_ = await _firstMaxTokens(reversed_, {
    ...rest,
    partialStrategy: allowPartial ? "last" : void 0,
    endOn: startOn
  });
  if (swappedSystem) return [reversed_[0], ...reversed_.slice(1).reverse()];
  else return reversed_.reverse();
}
const _MSG_CHUNK_MAP = {
  human: {
    message: HumanMessage,
    messageChunk: HumanMessageChunk
  },
  ai: {
    message: AIMessage,
    messageChunk: AIMessageChunk
  },
  system: {
    message: SystemMessage,
    messageChunk: SystemMessageChunk
  },
  developer: {
    message: SystemMessage,
    messageChunk: SystemMessageChunk
  },
  tool: {
    message: ToolMessage,
    messageChunk: ToolMessageChunk
  },
  function: {
    message: FunctionMessage,
    messageChunk: FunctionMessageChunk
  },
  generic: {
    message: ChatMessage,
    messageChunk: ChatMessageChunk
  },
  remove: {
    message: RemoveMessage,
    messageChunk: RemoveMessage
  }
};
function _switchTypeToMessage(messageType, fields, returnChunk) {
  var _a3;
  let chunk;
  let msg;
  switch (messageType) {
    case "human":
      if (returnChunk) chunk = new HumanMessageChunk(fields);
      else msg = new HumanMessage(fields);
      break;
    case "ai":
      if (returnChunk) {
        let aiChunkFields = { ...fields };
        if ("tool_calls" in aiChunkFields) aiChunkFields = {
          ...aiChunkFields,
          tool_call_chunks: (_a3 = aiChunkFields.tool_calls) == null ? void 0 : _a3.map((tc) => ({
            ...tc,
            type: "tool_call_chunk",
            index: void 0,
            args: JSON.stringify(tc.args)
          }))
        };
        chunk = new AIMessageChunk(aiChunkFields);
      } else msg = new AIMessage(fields);
      break;
    case "system":
      if (returnChunk) chunk = new SystemMessageChunk(fields);
      else msg = new SystemMessage(fields);
      break;
    case "developer":
      if (returnChunk) chunk = new SystemMessageChunk({
        ...fields,
        additional_kwargs: {
          ...fields.additional_kwargs,
          __openai_role__: "developer"
        }
      });
      else msg = new SystemMessage({
        ...fields,
        additional_kwargs: {
          ...fields.additional_kwargs,
          __openai_role__: "developer"
        }
      });
      break;
    case "tool":
      if ("tool_call_id" in fields) if (returnChunk) chunk = new ToolMessageChunk(fields);
      else msg = new ToolMessage(fields);
      else throw new Error("Can not convert ToolMessage to ToolMessageChunk if 'tool_call_id' field is not defined.");
      break;
    case "function":
      if (returnChunk) chunk = new FunctionMessageChunk(fields);
      else {
        if (!fields.name) throw new Error("FunctionMessage must have a 'name' field");
        msg = new FunctionMessage(fields);
      }
      break;
    case "generic":
      if ("role" in fields) if (returnChunk) chunk = new ChatMessageChunk(fields);
      else msg = new ChatMessage(fields);
      else throw new Error("Can not convert ChatMessage to ChatMessageChunk if 'role' field is not defined.");
      break;
    default:
      throw new Error(`Unrecognized message type ${messageType}`);
  }
  if (returnChunk && chunk) return chunk;
  if (msg) return msg;
  throw new Error(`Unrecognized message type ${messageType}`);
}
function _chunkToMsg(chunk) {
  const chunkType = chunk.getType();
  let msg;
  const fields = Object.fromEntries(Object.entries(chunk).filter(([k]) => !["type", "tool_call_chunks"].includes(k) && !k.startsWith("lc_")));
  if (chunkType in _MSG_CHUNK_MAP) msg = _switchTypeToMessage(chunkType, fields);
  if (!msg) throw new Error(`Unrecognized message chunk class ${chunkType}. Supported classes are ${Object.keys(_MSG_CHUNK_MAP)}`);
  return msg;
}
function defaultTextSplitter(text) {
  const splits = text.split("\n");
  return Promise.resolve([...splits.slice(0, -1).map((s) => `${s}
`), splits[splits.length - 1]]);
}
const KNOWN_BLOCK_TYPES$1 = [
  "tool_call",
  "tool_call_chunk",
  "invalid_tool_call",
  "server_tool_call",
  "server_tool_call_chunk",
  "server_tool_call_result"
];
const KNOWN_BLOCK_TYPES = [
  "image",
  "video",
  "audio",
  "text-plain",
  "file"
];
const KNOWN_BLOCK_TYPES$2 = [
  "text",
  "reasoning",
  ...KNOWN_BLOCK_TYPES$1,
  ...KNOWN_BLOCK_TYPES
];
var messages_exports = {};
__export(messages_exports, {
  AIMessage: () => AIMessage,
  AIMessageChunk: () => AIMessageChunk,
  BaseMessage: () => BaseMessage,
  BaseMessageChunk: () => BaseMessageChunk,
  ChatMessage: () => ChatMessage,
  ChatMessageChunk: () => ChatMessageChunk,
  FunctionMessage: () => FunctionMessage,
  FunctionMessageChunk: () => FunctionMessageChunk,
  HumanMessage: () => HumanMessage,
  HumanMessageChunk: () => HumanMessageChunk,
  KNOWN_BLOCK_TYPES: () => KNOWN_BLOCK_TYPES$2,
  RemoveMessage: () => RemoveMessage,
  SystemMessage: () => SystemMessage,
  SystemMessageChunk: () => SystemMessageChunk,
  ToolMessage: () => ToolMessage,
  ToolMessageChunk: () => ToolMessageChunk,
  _isMessageFieldWithRole: () => _isMessageFieldWithRole,
  _mergeDicts: () => _mergeDicts,
  _mergeLists: () => _mergeLists,
  _mergeObj: () => _mergeObj,
  _mergeStatus: () => _mergeStatus,
  coerceMessageLikeToMessage: () => coerceMessageLikeToMessage,
  collapseToolCallChunks: () => collapseToolCallChunks,
  convertToChunk: () => convertToChunk,
  convertToOpenAIImageBlock: () => convertToOpenAIImageBlock,
  convertToProviderContentBlock: () => convertToProviderContentBlock,
  defaultTextSplitter: () => defaultTextSplitter,
  defaultToolCallParser: () => defaultToolCallParser,
  filterMessages: () => filterMessages,
  getBufferString: () => getBufferString,
  iife: () => iife$2,
  isAIMessage: () => isAIMessage,
  isAIMessageChunk: () => isAIMessageChunk,
  isBase64ContentBlock: () => isBase64ContentBlock,
  isBaseMessage: () => isBaseMessage,
  isBaseMessageChunk: () => isBaseMessageChunk,
  isChatMessage: () => isChatMessage,
  isChatMessageChunk: () => isChatMessageChunk,
  isDataContentBlock: () => isDataContentBlock,
  isDirectToolOutput: () => isDirectToolOutput,
  isFunctionMessage: () => isFunctionMessage,
  isFunctionMessageChunk: () => isFunctionMessageChunk,
  isHumanMessage: () => isHumanMessage,
  isHumanMessageChunk: () => isHumanMessageChunk,
  isIDContentBlock: () => isIDContentBlock,
  isMessage: () => isMessage,
  isOpenAIToolCallArray: () => isOpenAIToolCallArray,
  isPlainTextContentBlock: () => isPlainTextContentBlock,
  isSystemMessage: () => isSystemMessage,
  isSystemMessageChunk: () => isSystemMessageChunk,
  isToolMessage: () => isToolMessage,
  isToolMessageChunk: () => isToolMessageChunk,
  isURLContentBlock: () => isURLContentBlock,
  mapChatMessagesToStoredMessages: () => mapChatMessagesToStoredMessages,
  mapStoredMessageToChatMessage: () => mapStoredMessageToChatMessage,
  mapStoredMessagesToChatMessages: () => mapStoredMessagesToChatMessages,
  mergeContent: () => mergeContent,
  mergeMessageRuns: () => mergeMessageRuns,
  mergeResponseMetadata: () => mergeResponseMetadata,
  mergeUsageMetadata: () => mergeUsageMetadata,
  parseBase64DataUrl: () => parseBase64DataUrl,
  parseMimeType: () => parseMimeType,
  trimMessages: () => trimMessages
});
const iife$1 = (fn) => fn();
function isReasoningModel(model) {
  if (!model) return false;
  if (/^o\d/.test(model ?? "")) return true;
  if (model.startsWith("gpt-5") && !model.startsWith("gpt-5-chat")) return true;
  return false;
}
function extractGenericMessageCustomRole(message) {
  if (message.role !== "system" && message.role !== "developer" && message.role !== "assistant" && message.role !== "user" && message.role !== "function" && message.role !== "tool") console.warn(`Unknown message role: ${message.role}`);
  return message.role;
}
function messageToOpenAIRole(message) {
  const type = message._getType();
  switch (type) {
    case "system":
      return "system";
    case "ai":
      return "assistant";
    case "human":
      return "user";
    case "function":
      return "function";
    case "tool":
      return "tool";
    case "generic":
      if (!ChatMessage.isInstance(message)) throw new Error("Invalid generic chat message");
      return extractGenericMessageCustomRole(message);
    default:
      throw new Error(`Unknown message type: ${type}`);
  }
}
function getEndpoint(config2) {
  const { azureOpenAIApiDeploymentName, azureOpenAIApiInstanceName, azureOpenAIApiKey, azureOpenAIBasePath, baseURL, azureADTokenProvider, azureOpenAIEndpoint } = config2;
  if ((azureOpenAIApiKey || azureADTokenProvider) && azureOpenAIBasePath && azureOpenAIApiDeploymentName) return `${azureOpenAIBasePath}/${azureOpenAIApiDeploymentName}`;
  if ((azureOpenAIApiKey || azureADTokenProvider) && azureOpenAIEndpoint && azureOpenAIApiDeploymentName) return `${azureOpenAIEndpoint}/openai/deployments/${azureOpenAIApiDeploymentName}`;
  if (azureOpenAIApiKey || azureADTokenProvider) {
    if (!azureOpenAIApiInstanceName) throw new Error("azureOpenAIApiInstanceName is required when using azureOpenAIApiKey");
    if (!azureOpenAIApiDeploymentName) throw new Error("azureOpenAIApiDeploymentName is a required parameter when using azureOpenAIApiKey");
    return `https://${azureOpenAIApiInstanceName}.openai.azure.com/openai/deployments/${azureOpenAIApiDeploymentName}`;
  }
  return baseURL;
}
function isHeaders(headers) {
  return typeof Headers !== "undefined" && headers !== null && typeof headers === "object" && Object.prototype.toString.call(headers) === "[object Headers]";
}
function normalizeHeaders(headers) {
  const output = iife$1(() => {
    if (isHeaders(headers)) return headers;
    else if (Array.isArray(headers)) return new Headers(headers);
    else if (typeof headers === "object" && headers !== null && "values" in headers && isHeaders(headers.values)) return headers.values;
    else if (typeof headers === "object" && headers !== null) {
      const entries = Object.entries(headers).filter(([, v]) => typeof v === "string").map(([k, v]) => [k, v]);
      return new Headers(entries);
    }
    return new Headers();
  });
  return Object.fromEntries(output.entries());
}
function getFormattedEnv() {
  let env = getEnv$1();
  if (env === "node" || env === "deno") env = `(${env}/${process.version}; ${process.platform}; ${process.arch})`;
  return env;
}
function getHeadersWithUserAgent(headers, isAzure = false, version2 = "1.0.0") {
  const normalizedHeaders = normalizeHeaders(headers);
  const env = getFormattedEnv();
  const library = `langchainjs${isAzure ? "-azure" : ""}-openai`;
  return {
    ...normalizedHeaders,
    "User-Agent": normalizedHeaders["User-Agent"] ? `${library}/${version2} (${env})${normalizedHeaders["User-Agent"]}` : `${library}/${version2} (${env})`
  };
}
function isStructuredTool(tool2) {
  return tool2 !== void 0 && Array.isArray(tool2.lc_namespace);
}
function isRunnableToolLike(tool2) {
  return tool2 !== void 0 && Runnable.isRunnable(tool2) && "lc_name" in tool2.constructor && typeof tool2.constructor.lc_name === "function" && tool2.constructor.lc_name() === "RunnableToolLike";
}
function isStructuredToolParams(tool2) {
  return !!tool2 && typeof tool2 === "object" && "name" in tool2 && "schema" in tool2 && (isInteropZodSchema(tool2.schema) || tool2.schema != null && typeof tool2.schema === "object" && "type" in tool2.schema && typeof tool2.schema.type === "string" && [
    "null",
    "boolean",
    "object",
    "array",
    "number",
    "string"
  ].includes(tool2.schema.type));
}
function isLangChainTool(tool2) {
  return isStructuredToolParams(tool2) || isRunnableToolLike(tool2) || isStructuredTool(tool2);
}
var function_calling_exports = {};
__export(function_calling_exports, {
  convertToOpenAIFunction: () => convertToOpenAIFunction,
  convertToOpenAITool: () => convertToOpenAITool,
  isLangChainTool: () => isLangChainTool,
  isRunnableToolLike: () => isRunnableToolLike,
  isStructuredTool: () => isStructuredTool,
  isStructuredToolParams: () => isStructuredToolParams
});
function convertToOpenAIFunction(tool2, fields) {
  const fieldsCopy = typeof fields === "number" ? void 0 : fields;
  return {
    name: tool2.name,
    description: tool2.description,
    parameters: toJsonSchema(tool2.schema),
    ...(fieldsCopy == null ? void 0 : fieldsCopy.strict) !== void 0 ? { strict: fieldsCopy.strict } : {}
  };
}
function convertToOpenAITool(tool2, fields) {
  const fieldsCopy = typeof fields === "number" ? void 0 : fields;
  let toolDef;
  if (isLangChainTool(tool2)) toolDef = {
    type: "function",
    function: convertToOpenAIFunction(tool2)
  };
  else toolDef = tool2;
  if ((fieldsCopy == null ? void 0 : fieldsCopy.strict) !== void 0) toolDef.function.strict = fieldsCopy.strict;
  return toolDef;
}
var types_exports = {};
__export(types_exports, {
  extendInteropZodObject: () => extendInteropZodObject,
  getInteropZodDefaultGetter: () => getInteropZodDefaultGetter,
  getInteropZodObjectShape: () => getInteropZodObjectShape,
  getSchemaDescription: () => getSchemaDescription,
  interopParse: () => interopParse,
  interopParseAsync: () => interopParseAsync,
  interopSafeParse: () => interopSafeParse,
  interopSafeParseAsync: () => interopSafeParseAsync,
  interopZodObjectMakeFieldsOptional: () => interopZodObjectMakeFieldsOptional,
  interopZodObjectPartial: () => interopZodObjectPartial,
  interopZodObjectPassthrough: () => interopZodObjectPassthrough,
  interopZodObjectStrict: () => interopZodObjectStrict,
  interopZodTransformInputSchema: () => interopZodTransformInputSchema,
  isInteropZodError: () => isInteropZodError,
  isInteropZodLiteral: () => isInteropZodLiteral,
  isInteropZodObject: () => isInteropZodObject,
  isInteropZodSchema: () => isInteropZodSchema,
  isShapelessZodSchema: () => isShapelessZodSchema,
  isSimpleStringZodSchema: () => isSimpleStringZodSchema,
  isZodArrayV4: () => isZodArrayV4,
  isZodLiteralV3: () => isZodLiteralV3,
  isZodLiteralV4: () => isZodLiteralV4,
  isZodNullableV4: () => isZodNullableV4,
  isZodObjectV3: () => isZodObjectV3,
  isZodObjectV4: () => isZodObjectV4,
  isZodOptionalV4: () => isZodOptionalV4,
  isZodSchema: () => isZodSchema,
  isZodSchemaV3: () => isZodSchemaV3,
  isZodSchemaV4: () => isZodSchemaV4
});
function _convertToOpenAITool(tool2, fields) {
  let toolDef;
  if (isLangChainTool(tool2)) toolDef = convertToOpenAITool(tool2);
  else toolDef = tool2;
  if ((fields == null ? void 0 : fields.strict) !== void 0) toolDef.function.strict = fields.strict;
  return toolDef;
}
function isAnyOfProp(prop) {
  return prop.anyOf !== void 0 && Array.isArray(prop.anyOf);
}
function formatFunctionDefinitions(functions) {
  const lines = ["namespace functions {", ""];
  for (const f of functions) {
    if (f.description) lines.push(`// ${f.description}`);
    if (Object.keys(f.parameters.properties ?? {}).length > 0) {
      lines.push(`type ${f.name} = (_: {`);
      lines.push(formatObjectProperties(f.parameters, 0));
      lines.push("}) => any;");
    } else lines.push(`type ${f.name} = () => any;`);
    lines.push("");
  }
  lines.push("} // namespace functions");
  return lines.join("\n");
}
function formatObjectProperties(obj, indent) {
  var _a3;
  const lines = [];
  for (const [name, param] of Object.entries(obj.properties ?? {})) {
    if (param.description && indent < 2) lines.push(`// ${param.description}`);
    if ((_a3 = obj.required) == null ? void 0 : _a3.includes(name)) lines.push(`${name}: ${formatType(param, indent)},`);
    else lines.push(`${name}?: ${formatType(param, indent)},`);
  }
  return lines.map((line) => " ".repeat(indent) + line).join("\n");
}
function formatType(param, indent) {
  if (isAnyOfProp(param)) return param.anyOf.map((v) => formatType(v, indent)).join(" | ");
  switch (param.type) {
    case "string":
      if (param.enum) return param.enum.map((v) => `"${v}"`).join(" | ");
      return "string";
    case "number":
      if (param.enum) return param.enum.map((v) => `${v}`).join(" | ");
      return "number";
    case "integer":
      if (param.enum) return param.enum.map((v) => `${v}`).join(" | ");
      return "number";
    case "boolean":
      return "boolean";
    case "null":
      return "null";
    case "object":
      return [
        "{",
        formatObjectProperties(param, indent + 2),
        "}"
      ].join("\n");
    case "array":
      if (param.items) return `${formatType(param.items, indent)}[]`;
      return "any[]";
    default:
      return "";
  }
}
function formatToOpenAIToolChoice(toolChoice) {
  if (!toolChoice) return void 0;
  else if (toolChoice === "any" || toolChoice === "required") return "required";
  else if (toolChoice === "auto") return "auto";
  else if (toolChoice === "none") return "none";
  else if (typeof toolChoice === "string") return {
    type: "function",
    function: { name: toolChoice }
  };
  else return toolChoice;
}
function isBuiltInTool(tool2) {
  return "type" in tool2 && tool2.type !== "function";
}
function isBuiltInToolChoice(tool_choice) {
  return tool_choice != null && typeof tool_choice === "object" && "type" in tool_choice && tool_choice.type !== "function";
}
function isCustomTool(tool2) {
  return typeof tool2 === "object" && tool2 !== null && "metadata" in tool2 && typeof tool2.metadata === "object" && tool2.metadata !== null && "customTool" in tool2.metadata && typeof tool2.metadata.customTool === "object" && tool2.metadata.customTool !== null;
}
function isOpenAICustomTool(tool2) {
  return "type" in tool2 && tool2.type === "custom" && "custom" in tool2 && typeof tool2.custom === "object" && tool2.custom !== null;
}
function parseCustomToolCall(rawToolCall) {
  if (rawToolCall.type !== "custom_tool_call") return void 0;
  return {
    ...rawToolCall,
    type: "tool_call",
    call_id: rawToolCall.id,
    id: rawToolCall.call_id,
    name: rawToolCall.name,
    isCustomTool: true,
    args: { input: rawToolCall.input }
  };
}
function isCustomToolCall(toolCall) {
  return toolCall.type === "tool_call" && "isCustomTool" in toolCall && toolCall.isCustomTool === true;
}
function convertCompletionsCustomTool(tool2) {
  const getFormat = () => {
    if (!tool2.custom.format) return void 0;
    if (tool2.custom.format.type === "grammar") return {
      type: "grammar",
      definition: tool2.custom.format.grammar.definition,
      syntax: tool2.custom.format.grammar.syntax
    };
    if (tool2.custom.format.type === "text") return { type: "text" };
    return void 0;
  };
  return {
    type: "custom",
    name: tool2.custom.name,
    description: tool2.custom.description,
    format: getFormat()
  };
}
function convertResponsesCustomTool(tool2) {
  const getFormat = () => {
    if (!tool2.format) return void 0;
    if (tool2.format.type === "grammar") return {
      type: "grammar",
      grammar: {
        definition: tool2.format.definition,
        syntax: tool2.format.syntax
      }
    };
    if (tool2.format.type === "text") return { type: "text" };
    return void 0;
  };
  return {
    type: "custom",
    custom: {
      name: tool2.name,
      description: tool2.description,
      format: getFormat()
    }
  };
}
const ZodISODateTime = /* @__PURE__ */ $constructor("ZodISODateTime", (inst, def) => {
  $ZodISODateTime.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function datetime(params) {
  return _isoDateTime(ZodISODateTime, params);
}
const ZodISODate = /* @__PURE__ */ $constructor("ZodISODate", (inst, def) => {
  $ZodISODate.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function date(params) {
  return _isoDate(ZodISODate, params);
}
const ZodISOTime = /* @__PURE__ */ $constructor("ZodISOTime", (inst, def) => {
  $ZodISOTime.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function time(params) {
  return _isoTime(ZodISOTime, params);
}
const ZodISODuration = /* @__PURE__ */ $constructor("ZodISODuration", (inst, def) => {
  $ZodISODuration.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function duration(params) {
  return _isoDuration(ZodISODuration, params);
}
const initializer = (inst, issues) => {
  $ZodError.init(inst, issues);
  inst.name = "ZodError";
  Object.defineProperties(inst, {
    format: {
      value: (mapper) => formatError(inst, mapper)
      // enumerable: false,
    },
    flatten: {
      value: (mapper) => flattenError(inst, mapper)
      // enumerable: false,
    },
    addIssue: {
      value: (issue2) => {
        inst.issues.push(issue2);
        inst.message = JSON.stringify(inst.issues, jsonStringifyReplacer, 2);
      }
      // enumerable: false,
    },
    addIssues: {
      value: (issues2) => {
        inst.issues.push(...issues2);
        inst.message = JSON.stringify(inst.issues, jsonStringifyReplacer, 2);
      }
      // enumerable: false,
    },
    isEmpty: {
      get() {
        return inst.issues.length === 0;
      }
      // enumerable: false,
    }
  });
};
const ZodRealError = $constructor("ZodError", initializer, {
  Parent: Error
});
const parse$1 = /* @__PURE__ */ _parse(ZodRealError);
const parseAsync = /* @__PURE__ */ _parseAsync(ZodRealError);
const safeParse = /* @__PURE__ */ _safeParse(ZodRealError);
const safeParseAsync = /* @__PURE__ */ _safeParseAsync(ZodRealError);
const encode = /* @__PURE__ */ _encode(ZodRealError);
const decode$1 = /* @__PURE__ */ _decode(ZodRealError);
const encodeAsync = /* @__PURE__ */ _encodeAsync(ZodRealError);
const decodeAsync = /* @__PURE__ */ _decodeAsync(ZodRealError);
const safeEncode = /* @__PURE__ */ _safeEncode(ZodRealError);
const safeDecode = /* @__PURE__ */ _safeDecode(ZodRealError);
const safeEncodeAsync = /* @__PURE__ */ _safeEncodeAsync(ZodRealError);
const safeDecodeAsync = /* @__PURE__ */ _safeDecodeAsync(ZodRealError);
const ZodType = /* @__PURE__ */ $constructor("ZodType", (inst, def) => {
  $ZodType.init(inst, def);
  inst.def = def;
  inst.type = def.type;
  Object.defineProperty(inst, "_def", { value: def });
  inst.check = (...checks) => {
    return inst.clone(mergeDefs(def, {
      checks: [
        ...def.checks ?? [],
        ...checks.map((ch) => typeof ch === "function" ? { _zod: { check: ch, def: { check: "custom" }, onattach: [] } } : ch)
      ]
    }));
  };
  inst.clone = (def2, params) => clone(inst, def2, params);
  inst.brand = () => inst;
  inst.register = (reg, meta) => {
    reg.add(inst, meta);
    return inst;
  };
  inst.parse = (data, params) => parse$1(inst, data, params, { callee: inst.parse });
  inst.safeParse = (data, params) => safeParse(inst, data, params);
  inst.parseAsync = async (data, params) => parseAsync(inst, data, params, { callee: inst.parseAsync });
  inst.safeParseAsync = async (data, params) => safeParseAsync(inst, data, params);
  inst.spa = inst.safeParseAsync;
  inst.encode = (data, params) => encode(inst, data, params);
  inst.decode = (data, params) => decode$1(inst, data, params);
  inst.encodeAsync = async (data, params) => encodeAsync(inst, data, params);
  inst.decodeAsync = async (data, params) => decodeAsync(inst, data, params);
  inst.safeEncode = (data, params) => safeEncode(inst, data, params);
  inst.safeDecode = (data, params) => safeDecode(inst, data, params);
  inst.safeEncodeAsync = async (data, params) => safeEncodeAsync(inst, data, params);
  inst.safeDecodeAsync = async (data, params) => safeDecodeAsync(inst, data, params);
  inst.refine = (check, params) => inst.check(refine(check, params));
  inst.superRefine = (refinement) => inst.check(superRefine(refinement));
  inst.overwrite = (fn) => inst.check(_overwrite(fn));
  inst.optional = () => optional(inst);
  inst.nullable = () => nullable(inst);
  inst.nullish = () => optional(nullable(inst));
  inst.nonoptional = (params) => nonoptional(inst, params);
  inst.array = () => array(inst);
  inst.or = (arg) => union([inst, arg]);
  inst.and = (arg) => intersection(inst, arg);
  inst.transform = (tx) => pipe(inst, transform(tx));
  inst.default = (def2) => _default(inst, def2);
  inst.prefault = (def2) => prefault(inst, def2);
  inst.catch = (params) => _catch(inst, params);
  inst.pipe = (target) => pipe(inst, target);
  inst.readonly = () => readonly(inst);
  inst.describe = (description) => {
    const cl = inst.clone();
    globalRegistry.add(cl, { description });
    return cl;
  };
  Object.defineProperty(inst, "description", {
    get() {
      var _a3;
      return (_a3 = globalRegistry.get(inst)) == null ? void 0 : _a3.description;
    },
    configurable: true
  });
  inst.meta = (...args) => {
    if (args.length === 0) {
      return globalRegistry.get(inst);
    }
    const cl = inst.clone();
    globalRegistry.add(cl, args[0]);
    return cl;
  };
  inst.isOptional = () => inst.safeParse(void 0).success;
  inst.isNullable = () => inst.safeParse(null).success;
  return inst;
});
const _ZodString = /* @__PURE__ */ $constructor("_ZodString", (inst, def) => {
  $ZodString.init(inst, def);
  ZodType.init(inst, def);
  const bag = inst._zod.bag;
  inst.format = bag.format ?? null;
  inst.minLength = bag.minimum ?? null;
  inst.maxLength = bag.maximum ?? null;
  inst.regex = (...args) => inst.check(_regex(...args));
  inst.includes = (...args) => inst.check(_includes(...args));
  inst.startsWith = (...args) => inst.check(_startsWith(...args));
  inst.endsWith = (...args) => inst.check(_endsWith(...args));
  inst.min = (...args) => inst.check(_minLength(...args));
  inst.max = (...args) => inst.check(_maxLength(...args));
  inst.length = (...args) => inst.check(_length(...args));
  inst.nonempty = (...args) => inst.check(_minLength(1, ...args));
  inst.lowercase = (params) => inst.check(_lowercase(params));
  inst.uppercase = (params) => inst.check(_uppercase(params));
  inst.trim = () => inst.check(_trim());
  inst.normalize = (...args) => inst.check(_normalize(...args));
  inst.toLowerCase = () => inst.check(_toLowerCase());
  inst.toUpperCase = () => inst.check(_toUpperCase());
  inst.slugify = () => inst.check(_slugify());
});
const ZodString = /* @__PURE__ */ $constructor("ZodString", (inst, def) => {
  $ZodString.init(inst, def);
  _ZodString.init(inst, def);
  inst.email = (params) => inst.check(_email(ZodEmail, params));
  inst.url = (params) => inst.check(_url(ZodURL, params));
  inst.jwt = (params) => inst.check(_jwt(ZodJWT, params));
  inst.emoji = (params) => inst.check(_emoji(ZodEmoji, params));
  inst.guid = (params) => inst.check(_guid(ZodGUID, params));
  inst.uuid = (params) => inst.check(_uuid(ZodUUID, params));
  inst.uuidv4 = (params) => inst.check(_uuidv4(ZodUUID, params));
  inst.uuidv6 = (params) => inst.check(_uuidv6(ZodUUID, params));
  inst.uuidv7 = (params) => inst.check(_uuidv7(ZodUUID, params));
  inst.nanoid = (params) => inst.check(_nanoid(ZodNanoID, params));
  inst.guid = (params) => inst.check(_guid(ZodGUID, params));
  inst.cuid = (params) => inst.check(_cuid(ZodCUID, params));
  inst.cuid2 = (params) => inst.check(_cuid2(ZodCUID2, params));
  inst.ulid = (params) => inst.check(_ulid(ZodULID, params));
  inst.base64 = (params) => inst.check(_base64(ZodBase64, params));
  inst.base64url = (params) => inst.check(_base64url(ZodBase64URL, params));
  inst.xid = (params) => inst.check(_xid(ZodXID, params));
  inst.ksuid = (params) => inst.check(_ksuid(ZodKSUID, params));
  inst.ipv4 = (params) => inst.check(_ipv4(ZodIPv4, params));
  inst.ipv6 = (params) => inst.check(_ipv6(ZodIPv6, params));
  inst.cidrv4 = (params) => inst.check(_cidrv4(ZodCIDRv4, params));
  inst.cidrv6 = (params) => inst.check(_cidrv6(ZodCIDRv6, params));
  inst.e164 = (params) => inst.check(_e164(ZodE164, params));
  inst.datetime = (params) => inst.check(datetime(params));
  inst.date = (params) => inst.check(date(params));
  inst.time = (params) => inst.check(time(params));
  inst.duration = (params) => inst.check(duration(params));
});
function string(params) {
  return _string(ZodString, params);
}
const ZodStringFormat = /* @__PURE__ */ $constructor("ZodStringFormat", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  _ZodString.init(inst, def);
});
const ZodEmail = /* @__PURE__ */ $constructor("ZodEmail", (inst, def) => {
  $ZodEmail.init(inst, def);
  ZodStringFormat.init(inst, def);
});
const ZodGUID = /* @__PURE__ */ $constructor("ZodGUID", (inst, def) => {
  $ZodGUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
const ZodUUID = /* @__PURE__ */ $constructor("ZodUUID", (inst, def) => {
  $ZodUUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
const ZodURL = /* @__PURE__ */ $constructor("ZodURL", (inst, def) => {
  $ZodURL.init(inst, def);
  ZodStringFormat.init(inst, def);
});
const ZodEmoji = /* @__PURE__ */ $constructor("ZodEmoji", (inst, def) => {
  $ZodEmoji.init(inst, def);
  ZodStringFormat.init(inst, def);
});
const ZodNanoID = /* @__PURE__ */ $constructor("ZodNanoID", (inst, def) => {
  $ZodNanoID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
const ZodCUID = /* @__PURE__ */ $constructor("ZodCUID", (inst, def) => {
  $ZodCUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
const ZodCUID2 = /* @__PURE__ */ $constructor("ZodCUID2", (inst, def) => {
  $ZodCUID2.init(inst, def);
  ZodStringFormat.init(inst, def);
});
const ZodULID = /* @__PURE__ */ $constructor("ZodULID", (inst, def) => {
  $ZodULID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
const ZodXID = /* @__PURE__ */ $constructor("ZodXID", (inst, def) => {
  $ZodXID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
const ZodKSUID = /* @__PURE__ */ $constructor("ZodKSUID", (inst, def) => {
  $ZodKSUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
const ZodIPv4 = /* @__PURE__ */ $constructor("ZodIPv4", (inst, def) => {
  $ZodIPv4.init(inst, def);
  ZodStringFormat.init(inst, def);
});
const ZodIPv6 = /* @__PURE__ */ $constructor("ZodIPv6", (inst, def) => {
  $ZodIPv6.init(inst, def);
  ZodStringFormat.init(inst, def);
});
const ZodCIDRv4 = /* @__PURE__ */ $constructor("ZodCIDRv4", (inst, def) => {
  $ZodCIDRv4.init(inst, def);
  ZodStringFormat.init(inst, def);
});
const ZodCIDRv6 = /* @__PURE__ */ $constructor("ZodCIDRv6", (inst, def) => {
  $ZodCIDRv6.init(inst, def);
  ZodStringFormat.init(inst, def);
});
const ZodBase64 = /* @__PURE__ */ $constructor("ZodBase64", (inst, def) => {
  $ZodBase64.init(inst, def);
  ZodStringFormat.init(inst, def);
});
const ZodBase64URL = /* @__PURE__ */ $constructor("ZodBase64URL", (inst, def) => {
  $ZodBase64URL.init(inst, def);
  ZodStringFormat.init(inst, def);
});
const ZodE164 = /* @__PURE__ */ $constructor("ZodE164", (inst, def) => {
  $ZodE164.init(inst, def);
  ZodStringFormat.init(inst, def);
});
const ZodJWT = /* @__PURE__ */ $constructor("ZodJWT", (inst, def) => {
  $ZodJWT.init(inst, def);
  ZodStringFormat.init(inst, def);
});
const ZodNumber = /* @__PURE__ */ $constructor("ZodNumber", (inst, def) => {
  $ZodNumber.init(inst, def);
  ZodType.init(inst, def);
  inst.gt = (value, params) => inst.check(_gt(value, params));
  inst.gte = (value, params) => inst.check(_gte(value, params));
  inst.min = (value, params) => inst.check(_gte(value, params));
  inst.lt = (value, params) => inst.check(_lt(value, params));
  inst.lte = (value, params) => inst.check(_lte(value, params));
  inst.max = (value, params) => inst.check(_lte(value, params));
  inst.int = (params) => inst.check(int(params));
  inst.safe = (params) => inst.check(int(params));
  inst.positive = (params) => inst.check(_gt(0, params));
  inst.nonnegative = (params) => inst.check(_gte(0, params));
  inst.negative = (params) => inst.check(_lt(0, params));
  inst.nonpositive = (params) => inst.check(_lte(0, params));
  inst.multipleOf = (value, params) => inst.check(_multipleOf(value, params));
  inst.step = (value, params) => inst.check(_multipleOf(value, params));
  inst.finite = () => inst;
  const bag = inst._zod.bag;
  inst.minValue = Math.max(bag.minimum ?? Number.NEGATIVE_INFINITY, bag.exclusiveMinimum ?? Number.NEGATIVE_INFINITY) ?? null;
  inst.maxValue = Math.min(bag.maximum ?? Number.POSITIVE_INFINITY, bag.exclusiveMaximum ?? Number.POSITIVE_INFINITY) ?? null;
  inst.isInt = (bag.format ?? "").includes("int") || Number.isSafeInteger(bag.multipleOf ?? 0.5);
  inst.isFinite = true;
  inst.format = bag.format ?? null;
});
function number(params) {
  return _number(ZodNumber, params);
}
const ZodNumberFormat = /* @__PURE__ */ $constructor("ZodNumberFormat", (inst, def) => {
  $ZodNumberFormat.init(inst, def);
  ZodNumber.init(inst, def);
});
function int(params) {
  return _int(ZodNumberFormat, params);
}
const ZodBoolean = /* @__PURE__ */ $constructor("ZodBoolean", (inst, def) => {
  $ZodBoolean.init(inst, def);
  ZodType.init(inst, def);
});
function boolean(params) {
  return _boolean(ZodBoolean, params);
}
const ZodAny = /* @__PURE__ */ $constructor("ZodAny", (inst, def) => {
  $ZodAny.init(inst, def);
  ZodType.init(inst, def);
});
function any() {
  return _any(ZodAny);
}
const ZodUnknown = /* @__PURE__ */ $constructor("ZodUnknown", (inst, def) => {
  $ZodUnknown.init(inst, def);
  ZodType.init(inst, def);
});
function unknown() {
  return _unknown(ZodUnknown);
}
const ZodNever = /* @__PURE__ */ $constructor("ZodNever", (inst, def) => {
  $ZodNever.init(inst, def);
  ZodType.init(inst, def);
});
function never(params) {
  return _never(ZodNever, params);
}
const ZodArray = /* @__PURE__ */ $constructor("ZodArray", (inst, def) => {
  $ZodArray.init(inst, def);
  ZodType.init(inst, def);
  inst.element = def.element;
  inst.min = (minLength, params) => inst.check(_minLength(minLength, params));
  inst.nonempty = (params) => inst.check(_minLength(1, params));
  inst.max = (maxLength, params) => inst.check(_maxLength(maxLength, params));
  inst.length = (len2, params) => inst.check(_length(len2, params));
  inst.unwrap = () => inst.element;
});
function array(element, params) {
  return _array(ZodArray, element, params);
}
const ZodObject = /* @__PURE__ */ $constructor("ZodObject", (inst, def) => {
  $ZodObjectJIT.init(inst, def);
  ZodType.init(inst, def);
  defineLazy(inst, "shape", () => {
    return def.shape;
  });
  inst.keyof = () => _enum(Object.keys(inst._zod.def.shape));
  inst.catchall = (catchall) => inst.clone({ ...inst._zod.def, catchall });
  inst.passthrough = () => inst.clone({ ...inst._zod.def, catchall: unknown() });
  inst.loose = () => inst.clone({ ...inst._zod.def, catchall: unknown() });
  inst.strict = () => inst.clone({ ...inst._zod.def, catchall: never() });
  inst.strip = () => inst.clone({ ...inst._zod.def, catchall: void 0 });
  inst.extend = (incoming) => {
    return extend(inst, incoming);
  };
  inst.safeExtend = (incoming) => {
    return safeExtend(inst, incoming);
  };
  inst.merge = (other) => merge(inst, other);
  inst.pick = (mask) => pick(inst, mask);
  inst.omit = (mask) => omit(inst, mask);
  inst.partial = (...args) => partial(ZodOptional, inst, args[0]);
  inst.required = (...args) => required(ZodNonOptional, inst, args[0]);
});
function object(shape, params) {
  const def = {
    type: "object",
    shape: shape ?? {},
    ...normalizeParams(params)
  };
  return new ZodObject(def);
}
const ZodUnion = /* @__PURE__ */ $constructor("ZodUnion", (inst, def) => {
  $ZodUnion.init(inst, def);
  ZodType.init(inst, def);
  inst.options = def.options;
});
function union(options2, params) {
  return new ZodUnion({
    type: "union",
    options: options2,
    ...normalizeParams(params)
  });
}
const ZodIntersection = /* @__PURE__ */ $constructor("ZodIntersection", (inst, def) => {
  $ZodIntersection.init(inst, def);
  ZodType.init(inst, def);
});
function intersection(left, right) {
  return new ZodIntersection({
    type: "intersection",
    left,
    right
  });
}
const ZodRecord = /* @__PURE__ */ $constructor("ZodRecord", (inst, def) => {
  $ZodRecord.init(inst, def);
  ZodType.init(inst, def);
  inst.keyType = def.keyType;
  inst.valueType = def.valueType;
});
function record(keyType, valueType, params) {
  return new ZodRecord({
    type: "record",
    keyType,
    valueType,
    ...normalizeParams(params)
  });
}
const ZodEnum = /* @__PURE__ */ $constructor("ZodEnum", (inst, def) => {
  $ZodEnum.init(inst, def);
  ZodType.init(inst, def);
  inst.enum = def.entries;
  inst.options = Object.values(def.entries);
  const keys = new Set(Object.keys(def.entries));
  inst.extract = (values, params) => {
    const newEntries = {};
    for (const value of values) {
      if (keys.has(value)) {
        newEntries[value] = def.entries[value];
      } else
        throw new Error(`Key ${value} not found in enum`);
    }
    return new ZodEnum({
      ...def,
      checks: [],
      ...normalizeParams(params),
      entries: newEntries
    });
  };
  inst.exclude = (values, params) => {
    const newEntries = { ...def.entries };
    for (const value of values) {
      if (keys.has(value)) {
        delete newEntries[value];
      } else
        throw new Error(`Key ${value} not found in enum`);
    }
    return new ZodEnum({
      ...def,
      checks: [],
      ...normalizeParams(params),
      entries: newEntries
    });
  };
});
function _enum(values, params) {
  const entries = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;
  return new ZodEnum({
    type: "enum",
    entries,
    ...normalizeParams(params)
  });
}
const ZodTransform = /* @__PURE__ */ $constructor("ZodTransform", (inst, def) => {
  $ZodTransform.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    if (_ctx.direction === "backward") {
      throw new $ZodEncodeError(inst.constructor.name);
    }
    payload.addIssue = (issue$1) => {
      if (typeof issue$1 === "string") {
        payload.issues.push(issue(issue$1, payload.value, def));
      } else {
        const _issue = issue$1;
        if (_issue.fatal)
          _issue.continue = false;
        _issue.code ?? (_issue.code = "custom");
        _issue.input ?? (_issue.input = payload.value);
        _issue.inst ?? (_issue.inst = inst);
        payload.issues.push(issue(_issue));
      }
    };
    const output = def.transform(payload.value, payload);
    if (output instanceof Promise) {
      return output.then((output2) => {
        payload.value = output2;
        return payload;
      });
    }
    payload.value = output;
    return payload;
  };
});
function transform(fn) {
  return new ZodTransform({
    type: "transform",
    transform: fn
  });
}
const ZodOptional = /* @__PURE__ */ $constructor("ZodOptional", (inst, def) => {
  $ZodOptional.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function optional(innerType) {
  return new ZodOptional({
    type: "optional",
    innerType
  });
}
const ZodNullable = /* @__PURE__ */ $constructor("ZodNullable", (inst, def) => {
  $ZodNullable.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function nullable(innerType) {
  return new ZodNullable({
    type: "nullable",
    innerType
  });
}
const ZodDefault = /* @__PURE__ */ $constructor("ZodDefault", (inst, def) => {
  $ZodDefault.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
  inst.removeDefault = inst.unwrap;
});
function _default(innerType, defaultValue) {
  return new ZodDefault({
    type: "default",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : shallowClone(defaultValue);
    }
  });
}
const ZodPrefault = /* @__PURE__ */ $constructor("ZodPrefault", (inst, def) => {
  $ZodPrefault.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function prefault(innerType, defaultValue) {
  return new ZodPrefault({
    type: "prefault",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : shallowClone(defaultValue);
    }
  });
}
const ZodNonOptional = /* @__PURE__ */ $constructor("ZodNonOptional", (inst, def) => {
  $ZodNonOptional.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function nonoptional(innerType, params) {
  return new ZodNonOptional({
    type: "nonoptional",
    innerType,
    ...normalizeParams(params)
  });
}
const ZodCatch = /* @__PURE__ */ $constructor("ZodCatch", (inst, def) => {
  $ZodCatch.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
  inst.removeCatch = inst.unwrap;
});
function _catch(innerType, catchValue) {
  return new ZodCatch({
    type: "catch",
    innerType,
    catchValue: typeof catchValue === "function" ? catchValue : () => catchValue
  });
}
const ZodPipe = /* @__PURE__ */ $constructor("ZodPipe", (inst, def) => {
  $ZodPipe.init(inst, def);
  ZodType.init(inst, def);
  inst.in = def.in;
  inst.out = def.out;
});
function pipe(in_, out) {
  return new ZodPipe({
    type: "pipe",
    in: in_,
    out
    // ...util.normalizeParams(params),
  });
}
const ZodReadonly = /* @__PURE__ */ $constructor("ZodReadonly", (inst, def) => {
  $ZodReadonly.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function readonly(innerType) {
  return new ZodReadonly({
    type: "readonly",
    innerType
  });
}
const ZodCustom = /* @__PURE__ */ $constructor("ZodCustom", (inst, def) => {
  $ZodCustom.init(inst, def);
  ZodType.init(inst, def);
});
function refine(fn, _params = {}) {
  return _refine(ZodCustom, fn, _params);
}
function superRefine(fn) {
  return _superRefine(fn);
}
const ignoreOverride = Symbol("Let zodToJsonSchema decide on which parser to use");
const defaultOptions = {
  name: void 0,
  $refStrategy: "root",
  effectStrategy: "input",
  pipeStrategy: "all",
  dateStrategy: "format:date-time",
  mapStrategy: "entries",
  nullableStrategy: "from-target",
  removeAdditionalStrategy: "passthrough",
  definitionPath: "definitions",
  target: "jsonSchema7",
  strictUnions: false,
  errorMessages: false,
  markdownDescription: false,
  patternStrategy: "escape",
  applyRegexFlags: false,
  emailStrategy: "format:email",
  base64Strategy: "contentEncoding:base64",
  nameStrategy: "ref"
};
const getDefaultOptions = (options2) => {
  return typeof options2 === "string" ? {
    ...defaultOptions,
    basePath: ["#"],
    definitions: {},
    name: options2
  } : {
    ...defaultOptions,
    basePath: ["#"],
    definitions: {},
    ...options2
  };
};
const zodDef = (zodSchema) => {
  return "_def" in zodSchema ? zodSchema._def : zodSchema;
};
function isEmptyObj(obj) {
  if (!obj)
    return true;
  for (const _k in obj)
    return false;
  return true;
}
const getRefs = (options2) => {
  const _options = getDefaultOptions(options2);
  const currentPath = _options.name !== void 0 ? [..._options.basePath, _options.definitionPath, _options.name] : _options.basePath;
  return {
    ..._options,
    currentPath,
    propertyPath: void 0,
    seenRefs: /* @__PURE__ */ new Set(),
    seen: new Map(Object.entries(_options.definitions).map(([name, def]) => [
      zodDef(def),
      {
        def: zodDef(def),
        path: [..._options.basePath, _options.definitionPath, name],
        // Resolution of references will be forced even though seen, so it's ok that the schema is undefined here for now.
        jsonSchema: void 0
      }
    ]))
  };
};
function addErrorMessage(res, key, errorMessage, refs) {
  if (!(refs == null ? void 0 : refs.errorMessages))
    return;
  if (errorMessage) {
    res.errorMessage = {
      ...res.errorMessage,
      [key]: errorMessage
    };
  }
}
function setResponseValueAndErrors(res, key, value, errorMessage, refs) {
  res[key] = value;
  addErrorMessage(res, key, errorMessage, refs);
}
function parseAnyDef() {
  return {};
}
function parseArrayDef(def, refs) {
  var _a3, _b;
  const res = {
    type: "array"
  };
  if (((_b = (_a3 = def.type) == null ? void 0 : _a3._def) == null ? void 0 : _b.typeName) !== ZodFirstPartyTypeKind.ZodAny) {
    res.items = parseDef(def.type._def, {
      ...refs,
      currentPath: [...refs.currentPath, "items"]
    });
  }
  if (def.minLength) {
    setResponseValueAndErrors(res, "minItems", def.minLength.value, def.minLength.message, refs);
  }
  if (def.maxLength) {
    setResponseValueAndErrors(res, "maxItems", def.maxLength.value, def.maxLength.message, refs);
  }
  if (def.exactLength) {
    setResponseValueAndErrors(res, "minItems", def.exactLength.value, def.exactLength.message, refs);
    setResponseValueAndErrors(res, "maxItems", def.exactLength.value, def.exactLength.message, refs);
  }
  return res;
}
function parseBigintDef(def, refs) {
  const res = {
    type: "integer",
    format: "int64"
  };
  if (!def.checks)
    return res;
  for (const check of def.checks) {
    switch (check.kind) {
      case "min":
        if (refs.target === "jsonSchema7") {
          if (check.inclusive) {
            setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
          } else {
            setResponseValueAndErrors(res, "exclusiveMinimum", check.value, check.message, refs);
          }
        } else {
          if (!check.inclusive) {
            res.exclusiveMinimum = true;
          }
          setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
        }
        break;
      case "max":
        if (refs.target === "jsonSchema7") {
          if (check.inclusive) {
            setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
          } else {
            setResponseValueAndErrors(res, "exclusiveMaximum", check.value, check.message, refs);
          }
        } else {
          if (!check.inclusive) {
            res.exclusiveMaximum = true;
          }
          setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
        }
        break;
      case "multipleOf":
        setResponseValueAndErrors(res, "multipleOf", check.value, check.message, refs);
        break;
    }
  }
  return res;
}
function parseBooleanDef() {
  return {
    type: "boolean"
  };
}
function parseBrandedDef(_def, refs) {
  return parseDef(_def.type._def, refs);
}
const parseCatchDef = (def, refs) => {
  return parseDef(def.innerType._def, refs);
};
function parseDateDef(def, refs, overrideDateStrategy) {
  const strategy = overrideDateStrategy ?? refs.dateStrategy;
  if (Array.isArray(strategy)) {
    return {
      anyOf: strategy.map((item, i2) => parseDateDef(def, refs, item))
    };
  }
  switch (strategy) {
    case "string":
    case "format:date-time":
      return {
        type: "string",
        format: "date-time"
      };
    case "format:date":
      return {
        type: "string",
        format: "date"
      };
    case "integer":
      return integerDateParser(def, refs);
  }
}
const integerDateParser = (def, refs) => {
  const res = {
    type: "integer",
    format: "unix-time"
  };
  if (refs.target === "openApi3") {
    return res;
  }
  for (const check of def.checks) {
    switch (check.kind) {
      case "min":
        setResponseValueAndErrors(
          res,
          "minimum",
          check.value,
          // This is in milliseconds
          check.message,
          refs
        );
        break;
      case "max":
        setResponseValueAndErrors(
          res,
          "maximum",
          check.value,
          // This is in milliseconds
          check.message,
          refs
        );
        break;
    }
  }
  return res;
};
function parseDefaultDef(_def, refs) {
  return {
    ...parseDef(_def.innerType._def, refs),
    default: _def.defaultValue()
  };
}
function parseEffectsDef(_def, refs, forceResolution) {
  return refs.effectStrategy === "input" ? parseDef(_def.schema._def, refs, forceResolution) : {};
}
function parseEnumDef(def) {
  return {
    type: "string",
    enum: [...def.values]
  };
}
const isJsonSchema7AllOfType = (type) => {
  if ("type" in type && type.type === "string")
    return false;
  return "allOf" in type;
};
function parseIntersectionDef(def, refs) {
  const allOf = [
    parseDef(def.left._def, {
      ...refs,
      currentPath: [...refs.currentPath, "allOf", "0"]
    }),
    parseDef(def.right._def, {
      ...refs,
      currentPath: [...refs.currentPath, "allOf", "1"]
    })
  ].filter((x) => !!x);
  let unevaluatedProperties = refs.target === "jsonSchema2019-09" ? { unevaluatedProperties: false } : void 0;
  const mergedAllOf = [];
  allOf.forEach((schema) => {
    if (isJsonSchema7AllOfType(schema)) {
      mergedAllOf.push(...schema.allOf);
      if (schema.unevaluatedProperties === void 0) {
        unevaluatedProperties = void 0;
      }
    } else {
      let nestedSchema = schema;
      if ("additionalProperties" in schema && schema.additionalProperties === false) {
        const { additionalProperties, ...rest } = schema;
        nestedSchema = rest;
      } else {
        unevaluatedProperties = void 0;
      }
      mergedAllOf.push(nestedSchema);
    }
  });
  return mergedAllOf.length ? {
    allOf: mergedAllOf,
    ...unevaluatedProperties
  } : void 0;
}
function parseLiteralDef(def, refs) {
  const parsedType = typeof def.value;
  if (parsedType !== "bigint" && parsedType !== "number" && parsedType !== "boolean" && parsedType !== "string") {
    return {
      type: Array.isArray(def.value) ? "array" : "object"
    };
  }
  if (refs.target === "openApi3") {
    return {
      type: parsedType === "bigint" ? "integer" : parsedType,
      enum: [def.value]
    };
  }
  return {
    type: parsedType === "bigint" ? "integer" : parsedType,
    const: def.value
  };
}
let emojiRegex;
const zodPatterns = {
  /**
   * `c` was changed to `[cC]` to replicate /i flag
   */
  cuid: /^[cC][^\s-]{8,}$/,
  cuid2: /^[0-9a-z]+$/,
  ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,
  /**
   * `a-z` was added to replicate /i flag
   */
  email: /^(?!\.)(?!.*\.\.)([a-zA-Z0-9_'+\-\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\-]*\.)+[a-zA-Z]{2,}$/,
  /**
   * Constructed a valid Unicode RegExp
   *
   * Lazily instantiate since this type of regex isn't supported
   * in all envs (e.g. React Native).
   *
   * See:
   * https://github.com/colinhacks/zod/issues/2433
   * Fix in Zod:
   * https://github.com/colinhacks/zod/commit/9340fd51e48576a75adc919bff65dbc4a5d4c99b
   */
  emoji: () => {
    if (emojiRegex === void 0) {
      emojiRegex = RegExp("^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$", "u");
    }
    return emojiRegex;
  },
  base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
  nanoid: /^[a-zA-Z0-9_-]{21}$/
};
function parseStringDef(def, refs) {
  const res = {
    type: "string"
  };
  function processPattern(value) {
    return refs.patternStrategy === "escape" ? escapeNonAlphaNumeric(value) : value;
  }
  if (def.checks) {
    for (const check of def.checks) {
      switch (check.kind) {
        case "min":
          setResponseValueAndErrors(res, "minLength", typeof res.minLength === "number" ? Math.max(res.minLength, check.value) : check.value, check.message, refs);
          break;
        case "max":
          setResponseValueAndErrors(res, "maxLength", typeof res.maxLength === "number" ? Math.min(res.maxLength, check.value) : check.value, check.message, refs);
          break;
        case "email":
          switch (refs.emailStrategy) {
            case "format:email":
              addFormat(res, "email", check.message, refs);
              break;
            case "format:idn-email":
              addFormat(res, "idn-email", check.message, refs);
              break;
            case "pattern:zod":
              addPattern(res, zodPatterns.email, check.message, refs);
              break;
          }
          break;
        case "url":
          addFormat(res, "uri", check.message, refs);
          break;
        case "uuid":
          addFormat(res, "uuid", check.message, refs);
          break;
        case "regex":
          addPattern(res, check.regex, check.message, refs);
          break;
        case "cuid":
          addPattern(res, zodPatterns.cuid, check.message, refs);
          break;
        case "cuid2":
          addPattern(res, zodPatterns.cuid2, check.message, refs);
          break;
        case "startsWith":
          addPattern(res, RegExp(`^${processPattern(check.value)}`), check.message, refs);
          break;
        case "endsWith":
          addPattern(res, RegExp(`${processPattern(check.value)}$`), check.message, refs);
          break;
        case "datetime":
          addFormat(res, "date-time", check.message, refs);
          break;
        case "date":
          addFormat(res, "date", check.message, refs);
          break;
        case "time":
          addFormat(res, "time", check.message, refs);
          break;
        case "duration":
          addFormat(res, "duration", check.message, refs);
          break;
        case "length":
          setResponseValueAndErrors(res, "minLength", typeof res.minLength === "number" ? Math.max(res.minLength, check.value) : check.value, check.message, refs);
          setResponseValueAndErrors(res, "maxLength", typeof res.maxLength === "number" ? Math.min(res.maxLength, check.value) : check.value, check.message, refs);
          break;
        case "includes": {
          addPattern(res, RegExp(processPattern(check.value)), check.message, refs);
          break;
        }
        case "ip": {
          if (check.version !== "v6") {
            addFormat(res, "ipv4", check.message, refs);
          }
          if (check.version !== "v4") {
            addFormat(res, "ipv6", check.message, refs);
          }
          break;
        }
        case "emoji":
          addPattern(res, zodPatterns.emoji, check.message, refs);
          break;
        case "ulid": {
          addPattern(res, zodPatterns.ulid, check.message, refs);
          break;
        }
        case "base64": {
          switch (refs.base64Strategy) {
            case "format:binary": {
              addFormat(res, "binary", check.message, refs);
              break;
            }
            case "contentEncoding:base64": {
              setResponseValueAndErrors(res, "contentEncoding", "base64", check.message, refs);
              break;
            }
            case "pattern:zod": {
              addPattern(res, zodPatterns.base64, check.message, refs);
              break;
            }
          }
          break;
        }
        case "nanoid": {
          addPattern(res, zodPatterns.nanoid, check.message, refs);
        }
      }
    }
  }
  return res;
}
const escapeNonAlphaNumeric = (value) => Array.from(value).map((c) => /[a-zA-Z0-9]/.test(c) ? c : `\\${c}`).join("");
const addFormat = (schema, value, message, refs) => {
  var _a3;
  if (schema.format || ((_a3 = schema.anyOf) == null ? void 0 : _a3.some((x) => x.format))) {
    if (!schema.anyOf) {
      schema.anyOf = [];
    }
    if (schema.format) {
      schema.anyOf.push({
        format: schema.format,
        ...schema.errorMessage && refs.errorMessages && {
          errorMessage: { format: schema.errorMessage.format }
        }
      });
      delete schema.format;
      if (schema.errorMessage) {
        delete schema.errorMessage.format;
        if (Object.keys(schema.errorMessage).length === 0) {
          delete schema.errorMessage;
        }
      }
    }
    schema.anyOf.push({
      format: value,
      ...message && refs.errorMessages && { errorMessage: { format: message } }
    });
  } else {
    setResponseValueAndErrors(schema, "format", value, message, refs);
  }
};
const addPattern = (schema, regex2, message, refs) => {
  var _a3;
  if (schema.pattern || ((_a3 = schema.allOf) == null ? void 0 : _a3.some((x) => x.pattern))) {
    if (!schema.allOf) {
      schema.allOf = [];
    }
    if (schema.pattern) {
      schema.allOf.push({
        pattern: schema.pattern,
        ...schema.errorMessage && refs.errorMessages && {
          errorMessage: { pattern: schema.errorMessage.pattern }
        }
      });
      delete schema.pattern;
      if (schema.errorMessage) {
        delete schema.errorMessage.pattern;
        if (Object.keys(schema.errorMessage).length === 0) {
          delete schema.errorMessage;
        }
      }
    }
    schema.allOf.push({
      pattern: processRegExp(regex2, refs),
      ...message && refs.errorMessages && { errorMessage: { pattern: message } }
    });
  } else {
    setResponseValueAndErrors(schema, "pattern", processRegExp(regex2, refs), message, refs);
  }
};
const processRegExp = (regexOrFunction, refs) => {
  var _a3;
  const regex2 = typeof regexOrFunction === "function" ? regexOrFunction() : regexOrFunction;
  if (!refs.applyRegexFlags || !regex2.flags)
    return regex2.source;
  const flags = {
    i: regex2.flags.includes("i"),
    // Case-insensitive
    m: regex2.flags.includes("m"),
    // `^` and `$` matches adjacent to newline characters
    s: regex2.flags.includes("s")
    // `.` matches newlines
  };
  const source = flags.i ? regex2.source.toLowerCase() : regex2.source;
  let pattern = "";
  let isEscaped = false;
  let inCharGroup = false;
  let inCharRange = false;
  for (let i2 = 0; i2 < source.length; i2++) {
    if (isEscaped) {
      pattern += source[i2];
      isEscaped = false;
      continue;
    }
    if (flags.i) {
      if (inCharGroup) {
        if (source[i2].match(/[a-z]/)) {
          if (inCharRange) {
            pattern += source[i2];
            pattern += `${source[i2 - 2]}-${source[i2]}`.toUpperCase();
            inCharRange = false;
          } else if (source[i2 + 1] === "-" && ((_a3 = source[i2 + 2]) == null ? void 0 : _a3.match(/[a-z]/))) {
            pattern += source[i2];
            inCharRange = true;
          } else {
            pattern += `${source[i2]}${source[i2].toUpperCase()}`;
          }
          continue;
        }
      } else if (source[i2].match(/[a-z]/)) {
        pattern += `[${source[i2]}${source[i2].toUpperCase()}]`;
        continue;
      }
    }
    if (flags.m) {
      if (source[i2] === "^") {
        pattern += `(^|(?<=[\r
]))`;
        continue;
      } else if (source[i2] === "$") {
        pattern += `($|(?=[\r
]))`;
        continue;
      }
    }
    if (flags.s && source[i2] === ".") {
      pattern += inCharGroup ? `${source[i2]}\r
` : `[${source[i2]}\r
]`;
      continue;
    }
    pattern += source[i2];
    if (source[i2] === "\\") {
      isEscaped = true;
    } else if (inCharGroup && source[i2] === "]") {
      inCharGroup = false;
    } else if (!inCharGroup && source[i2] === "[") {
      inCharGroup = true;
    }
  }
  try {
    const regexTest = new RegExp(pattern);
  } catch {
    console.warn(`Could not convert regex pattern at ${refs.currentPath.join("/")} to a flag-independent form! Falling back to the flag-ignorant source`);
    return regex2.source;
  }
  return pattern;
};
function parseRecordDef(def, refs) {
  var _a3, _b, _c, _d;
  if (refs.target === "openApi3" && ((_a3 = def.keyType) == null ? void 0 : _a3._def.typeName) === ZodFirstPartyTypeKind.ZodEnum) {
    return {
      type: "object",
      required: def.keyType._def.values,
      properties: def.keyType._def.values.reduce((acc, key) => ({
        ...acc,
        [key]: parseDef(def.valueType._def, {
          ...refs,
          currentPath: [...refs.currentPath, "properties", key]
        }) ?? {}
      }), {}),
      additionalProperties: false
    };
  }
  const schema = {
    type: "object",
    additionalProperties: parseDef(def.valueType._def, {
      ...refs,
      currentPath: [...refs.currentPath, "additionalProperties"]
    }) ?? {}
  };
  if (refs.target === "openApi3") {
    return schema;
  }
  if (((_b = def.keyType) == null ? void 0 : _b._def.typeName) === ZodFirstPartyTypeKind.ZodString && ((_c = def.keyType._def.checks) == null ? void 0 : _c.length)) {
    const keyType = Object.entries(parseStringDef(def.keyType._def, refs)).reduce((acc, [key, value]) => key === "type" ? acc : { ...acc, [key]: value }, {});
    return {
      ...schema,
      propertyNames: keyType
    };
  } else if (((_d = def.keyType) == null ? void 0 : _d._def.typeName) === ZodFirstPartyTypeKind.ZodEnum) {
    return {
      ...schema,
      propertyNames: {
        enum: def.keyType._def.values
      }
    };
  }
  return schema;
}
function parseMapDef(def, refs) {
  if (refs.mapStrategy === "record") {
    return parseRecordDef(def, refs);
  }
  const keys = parseDef(def.keyType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items", "items", "0"]
  }) || {};
  const values = parseDef(def.valueType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items", "items", "1"]
  }) || {};
  return {
    type: "array",
    maxItems: 125,
    items: {
      type: "array",
      items: [keys, values],
      minItems: 2,
      maxItems: 2
    }
  };
}
function parseNativeEnumDef(def) {
  const object2 = def.values;
  const actualKeys = Object.keys(def.values).filter((key) => {
    return typeof object2[object2[key]] !== "number";
  });
  const actualValues = actualKeys.map((key) => object2[key]);
  const parsedTypes = Array.from(new Set(actualValues.map((values) => typeof values)));
  return {
    type: parsedTypes.length === 1 ? parsedTypes[0] === "string" ? "string" : "number" : ["string", "number"],
    enum: actualValues
  };
}
function parseNeverDef() {
  return {
    not: {}
  };
}
function parseNullDef(refs) {
  return refs.target === "openApi3" ? {
    enum: ["null"],
    nullable: true
  } : {
    type: "null"
  };
}
const primitiveMappings = {
  ZodString: "string",
  ZodNumber: "number",
  ZodBigInt: "integer",
  ZodBoolean: "boolean",
  ZodNull: "null"
};
function parseUnionDef(def, refs) {
  if (refs.target === "openApi3")
    return asAnyOf(def, refs);
  const options2 = def.options instanceof Map ? Array.from(def.options.values()) : def.options;
  if (options2.every((x) => x._def.typeName in primitiveMappings && (!x._def.checks || !x._def.checks.length))) {
    const types = options2.reduce((types2, x) => {
      const type = primitiveMappings[x._def.typeName];
      return type && !types2.includes(type) ? [...types2, type] : types2;
    }, []);
    return {
      type: types.length > 1 ? types : types[0]
    };
  } else if (options2.every((x) => x._def.typeName === "ZodLiteral" && !x.description)) {
    const types = options2.reduce((acc, x) => {
      const type = typeof x._def.value;
      switch (type) {
        case "string":
        case "number":
        case "boolean":
          return [...acc, type];
        case "bigint":
          return [...acc, "integer"];
        case "object":
          if (x._def.value === null)
            return [...acc, "null"];
        case "symbol":
        case "undefined":
        case "function":
        default:
          return acc;
      }
    }, []);
    if (types.length === options2.length) {
      const uniqueTypes = types.filter((x, i2, a) => a.indexOf(x) === i2);
      return {
        type: uniqueTypes.length > 1 ? uniqueTypes : uniqueTypes[0],
        enum: options2.reduce((acc, x) => {
          return acc.includes(x._def.value) ? acc : [...acc, x._def.value];
        }, [])
      };
    }
  } else if (options2.every((x) => x._def.typeName === "ZodEnum")) {
    return {
      type: "string",
      enum: options2.reduce((acc, x) => [...acc, ...x._def.values.filter((x2) => !acc.includes(x2))], [])
    };
  }
  return asAnyOf(def, refs);
}
const asAnyOf = (def, refs) => {
  const anyOf = (def.options instanceof Map ? Array.from(def.options.values()) : def.options).map((x, i2) => parseDef(x._def, {
    ...refs,
    currentPath: [...refs.currentPath, "anyOf", `${i2}`]
  })).filter((x) => !!x && (!refs.strictUnions || typeof x === "object" && Object.keys(x).length > 0));
  return anyOf.length ? { anyOf } : void 0;
};
function parseNullableDef(def, refs) {
  if (["ZodString", "ZodNumber", "ZodBigInt", "ZodBoolean", "ZodNull"].includes(def.innerType._def.typeName) && (!def.innerType._def.checks || !def.innerType._def.checks.length)) {
    if (refs.target === "openApi3" || refs.nullableStrategy === "property") {
      return {
        type: primitiveMappings[def.innerType._def.typeName],
        nullable: true
      };
    }
    return {
      type: [primitiveMappings[def.innerType._def.typeName], "null"]
    };
  }
  if (refs.target === "openApi3") {
    const base2 = parseDef(def.innerType._def, {
      ...refs,
      currentPath: [...refs.currentPath]
    });
    if (base2 && "$ref" in base2)
      return { allOf: [base2], nullable: true };
    return base2 && { ...base2, nullable: true };
  }
  const base = parseDef(def.innerType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "anyOf", "0"]
  });
  return base && { anyOf: [base, { type: "null" }] };
}
function parseNumberDef(def, refs) {
  const res = {
    type: "number"
  };
  if (!def.checks)
    return res;
  for (const check of def.checks) {
    switch (check.kind) {
      case "int":
        res.type = "integer";
        addErrorMessage(res, "type", check.message, refs);
        break;
      case "min":
        if (refs.target === "jsonSchema7") {
          if (check.inclusive) {
            setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
          } else {
            setResponseValueAndErrors(res, "exclusiveMinimum", check.value, check.message, refs);
          }
        } else {
          if (!check.inclusive) {
            res.exclusiveMinimum = true;
          }
          setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
        }
        break;
      case "max":
        if (refs.target === "jsonSchema7") {
          if (check.inclusive) {
            setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
          } else {
            setResponseValueAndErrors(res, "exclusiveMaximum", check.value, check.message, refs);
          }
        } else {
          if (!check.inclusive) {
            res.exclusiveMaximum = true;
          }
          setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
        }
        break;
      case "multipleOf":
        setResponseValueAndErrors(res, "multipleOf", check.value, check.message, refs);
        break;
    }
  }
  return res;
}
function decideAdditionalProperties(def, refs) {
  if (refs.removeAdditionalStrategy === "strict") {
    return def.catchall._def.typeName === "ZodNever" ? def.unknownKeys !== "strict" : parseDef(def.catchall._def, {
      ...refs,
      currentPath: [...refs.currentPath, "additionalProperties"]
    }) ?? true;
  } else {
    return def.catchall._def.typeName === "ZodNever" ? def.unknownKeys === "passthrough" : parseDef(def.catchall._def, {
      ...refs,
      currentPath: [...refs.currentPath, "additionalProperties"]
    }) ?? true;
  }
}
function parseObjectDef(def, refs) {
  const result = {
    type: "object",
    ...Object.entries(def.shape()).reduce((acc, [propName, propDef]) => {
      var _a3;
      if (propDef === void 0 || propDef._def === void 0)
        return acc;
      const propertyPath = [...refs.currentPath, "properties", propName];
      const parsedDef = parseDef(propDef._def, {
        ...refs,
        currentPath: propertyPath,
        propertyPath
      });
      if (parsedDef === void 0)
        return acc;
      if (refs.openaiStrictMode && propDef.isOptional() && !propDef.isNullable() && typeof ((_a3 = propDef._def) == null ? void 0 : _a3.defaultValue) === "undefined") {
        throw new Error(`Zod field at \`${propertyPath.join("/")}\` uses \`.optional()\` without \`.nullable()\` which is not supported by the API. See: https://platform.openai.com/docs/guides/structured-outputs?api-mode=responses#all-fields-must-be-required`);
      }
      return {
        properties: {
          ...acc.properties,
          [propName]: parsedDef
        },
        required: propDef.isOptional() && !refs.openaiStrictMode ? acc.required : [...acc.required, propName]
      };
    }, { properties: {}, required: [] }),
    additionalProperties: decideAdditionalProperties(def, refs)
  };
  if (!result.required.length)
    delete result.required;
  return result;
}
const parseOptionalDef = (def, refs) => {
  if (refs.propertyPath && refs.currentPath.slice(0, refs.propertyPath.length).toString() === refs.propertyPath.toString()) {
    return parseDef(def.innerType._def, { ...refs, currentPath: refs.currentPath });
  }
  const innerSchema = parseDef(def.innerType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "anyOf", "1"]
  });
  return innerSchema ? {
    anyOf: [
      {
        not: {}
      },
      innerSchema
    ]
  } : {};
};
const parsePipelineDef = (def, refs) => {
  if (refs.pipeStrategy === "input") {
    return parseDef(def.in._def, refs);
  } else if (refs.pipeStrategy === "output") {
    return parseDef(def.out._def, refs);
  }
  const a = parseDef(def.in._def, {
    ...refs,
    currentPath: [...refs.currentPath, "allOf", "0"]
  });
  const b = parseDef(def.out._def, {
    ...refs,
    currentPath: [...refs.currentPath, "allOf", a ? "1" : "0"]
  });
  return {
    allOf: [a, b].filter((x) => x !== void 0)
  };
};
function parsePromiseDef(def, refs) {
  return parseDef(def.type._def, refs);
}
function parseSetDef(def, refs) {
  const items = parseDef(def.valueType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items"]
  });
  const schema = {
    type: "array",
    uniqueItems: true,
    items
  };
  if (def.minSize) {
    setResponseValueAndErrors(schema, "minItems", def.minSize.value, def.minSize.message, refs);
  }
  if (def.maxSize) {
    setResponseValueAndErrors(schema, "maxItems", def.maxSize.value, def.maxSize.message, refs);
  }
  return schema;
}
function parseTupleDef(def, refs) {
  if (def.rest) {
    return {
      type: "array",
      minItems: def.items.length,
      items: def.items.map((x, i2) => parseDef(x._def, {
        ...refs,
        currentPath: [...refs.currentPath, "items", `${i2}`]
      })).reduce((acc, x) => x === void 0 ? acc : [...acc, x], []),
      additionalItems: parseDef(def.rest._def, {
        ...refs,
        currentPath: [...refs.currentPath, "additionalItems"]
      })
    };
  } else {
    return {
      type: "array",
      minItems: def.items.length,
      maxItems: def.items.length,
      items: def.items.map((x, i2) => parseDef(x._def, {
        ...refs,
        currentPath: [...refs.currentPath, "items", `${i2}`]
      })).reduce((acc, x) => x === void 0 ? acc : [...acc, x], [])
    };
  }
}
function parseUndefinedDef() {
  return {
    not: {}
  };
}
function parseUnknownDef() {
  return {};
}
const parseReadonlyDef = (def, refs) => {
  return parseDef(def.innerType._def, refs);
};
function parseDef(def, refs, forceResolution = false) {
  var _a3;
  const seenItem = refs.seen.get(def);
  if (refs.override) {
    const overrideResult = (_a3 = refs.override) == null ? void 0 : _a3.call(refs, def, refs, seenItem, forceResolution);
    if (overrideResult !== ignoreOverride) {
      return overrideResult;
    }
  }
  if (seenItem && !forceResolution) {
    const seenSchema = get$ref(seenItem, refs);
    if (seenSchema !== void 0) {
      if ("$ref" in seenSchema) {
        refs.seenRefs.add(seenSchema.$ref);
      }
      return seenSchema;
    }
  }
  const newItem = { def, path: refs.currentPath, jsonSchema: void 0 };
  refs.seen.set(def, newItem);
  const jsonSchema = selectParser(def, def.typeName, refs, forceResolution);
  if (jsonSchema) {
    addMeta(def, refs, jsonSchema);
  }
  newItem.jsonSchema = jsonSchema;
  return jsonSchema;
}
const get$ref = (item, refs) => {
  switch (refs.$refStrategy) {
    case "root":
      return { $ref: item.path.join("/") };
    case "extract-to-root":
      const name = item.path.slice(refs.basePath.length + 1).join("_");
      if (name !== refs.name && refs.nameStrategy === "duplicate-ref") {
        refs.definitions[name] = item.def;
      }
      return { $ref: [...refs.basePath, refs.definitionPath, name].join("/") };
    case "relative":
      return { $ref: getRelativePath(refs.currentPath, item.path) };
    case "none":
    case "seen": {
      if (item.path.length < refs.currentPath.length && item.path.every((value, index) => refs.currentPath[index] === value)) {
        console.warn(`Recursive reference detected at ${refs.currentPath.join("/")}! Defaulting to any`);
        return {};
      }
      return refs.$refStrategy === "seen" ? {} : void 0;
    }
  }
};
const getRelativePath = (pathA, pathB) => {
  let i2 = 0;
  for (; i2 < pathA.length && i2 < pathB.length; i2++) {
    if (pathA[i2] !== pathB[i2])
      break;
  }
  return [(pathA.length - i2).toString(), ...pathB.slice(i2)].join("/");
};
const selectParser = (def, typeName, refs, forceResolution) => {
  switch (typeName) {
    case ZodFirstPartyTypeKind.ZodString:
      return parseStringDef(def, refs);
    case ZodFirstPartyTypeKind.ZodNumber:
      return parseNumberDef(def, refs);
    case ZodFirstPartyTypeKind.ZodObject:
      return parseObjectDef(def, refs);
    case ZodFirstPartyTypeKind.ZodBigInt:
      return parseBigintDef(def, refs);
    case ZodFirstPartyTypeKind.ZodBoolean:
      return parseBooleanDef();
    case ZodFirstPartyTypeKind.ZodDate:
      return parseDateDef(def, refs);
    case ZodFirstPartyTypeKind.ZodUndefined:
      return parseUndefinedDef();
    case ZodFirstPartyTypeKind.ZodNull:
      return parseNullDef(refs);
    case ZodFirstPartyTypeKind.ZodArray:
      return parseArrayDef(def, refs);
    case ZodFirstPartyTypeKind.ZodUnion:
    case ZodFirstPartyTypeKind.ZodDiscriminatedUnion:
      return parseUnionDef(def, refs);
    case ZodFirstPartyTypeKind.ZodIntersection:
      return parseIntersectionDef(def, refs);
    case ZodFirstPartyTypeKind.ZodTuple:
      return parseTupleDef(def, refs);
    case ZodFirstPartyTypeKind.ZodRecord:
      return parseRecordDef(def, refs);
    case ZodFirstPartyTypeKind.ZodLiteral:
      return parseLiteralDef(def, refs);
    case ZodFirstPartyTypeKind.ZodEnum:
      return parseEnumDef(def);
    case ZodFirstPartyTypeKind.ZodNativeEnum:
      return parseNativeEnumDef(def);
    case ZodFirstPartyTypeKind.ZodNullable:
      return parseNullableDef(def, refs);
    case ZodFirstPartyTypeKind.ZodOptional:
      return parseOptionalDef(def, refs);
    case ZodFirstPartyTypeKind.ZodMap:
      return parseMapDef(def, refs);
    case ZodFirstPartyTypeKind.ZodSet:
      return parseSetDef(def, refs);
    case ZodFirstPartyTypeKind.ZodLazy:
      return parseDef(def.getter()._def, refs);
    case ZodFirstPartyTypeKind.ZodPromise:
      return parsePromiseDef(def, refs);
    case ZodFirstPartyTypeKind.ZodNaN:
    case ZodFirstPartyTypeKind.ZodNever:
      return parseNeverDef();
    case ZodFirstPartyTypeKind.ZodEffects:
      return parseEffectsDef(def, refs, forceResolution);
    case ZodFirstPartyTypeKind.ZodAny:
      return parseAnyDef();
    case ZodFirstPartyTypeKind.ZodUnknown:
      return parseUnknownDef();
    case ZodFirstPartyTypeKind.ZodDefault:
      return parseDefaultDef(def, refs);
    case ZodFirstPartyTypeKind.ZodBranded:
      return parseBrandedDef(def, refs);
    case ZodFirstPartyTypeKind.ZodReadonly:
      return parseReadonlyDef(def, refs);
    case ZodFirstPartyTypeKind.ZodCatch:
      return parseCatchDef(def, refs);
    case ZodFirstPartyTypeKind.ZodPipeline:
      return parsePipelineDef(def, refs);
    case ZodFirstPartyTypeKind.ZodFunction:
    case ZodFirstPartyTypeKind.ZodVoid:
    case ZodFirstPartyTypeKind.ZodSymbol:
      return void 0;
    default:
      return /* @__PURE__ */ ((_) => void 0)();
  }
};
const addMeta = (def, refs, jsonSchema) => {
  if (def.description) {
    jsonSchema.description = def.description;
    if (refs.markdownDescription) {
      jsonSchema.markdownDescription = def.description;
    }
  }
  return jsonSchema;
};
const zodToJsonSchema = (schema, options2) => {
  const refs = getRefs(options2);
  const name = typeof options2 === "string" ? options2 : (options2 == null ? void 0 : options2.nameStrategy) === "title" ? void 0 : options2 == null ? void 0 : options2.name;
  const main2 = parseDef(schema._def, name === void 0 ? refs : {
    ...refs,
    currentPath: [...refs.basePath, refs.definitionPath, name]
  }, false) ?? {};
  const title = typeof options2 === "object" && options2.name !== void 0 && options2.nameStrategy === "title" ? options2.name : void 0;
  if (title !== void 0) {
    main2.title = title;
  }
  const definitions = (() => {
    if (isEmptyObj(refs.definitions)) {
      return void 0;
    }
    const definitions2 = {};
    const processedDefinitions = /* @__PURE__ */ new Set();
    for (let i2 = 0; i2 < 500; i2++) {
      const newDefinitions = Object.entries(refs.definitions).filter(([key]) => !processedDefinitions.has(key));
      if (newDefinitions.length === 0)
        break;
      for (const [key, schema2] of newDefinitions) {
        definitions2[key] = parseDef(zodDef(schema2), { ...refs, currentPath: [...refs.basePath, refs.definitionPath, key] }, true) ?? {};
        processedDefinitions.add(key);
      }
    }
    return definitions2;
  })();
  const combined = name === void 0 ? definitions ? {
    ...main2,
    [refs.definitionPath]: definitions
  } : main2 : refs.nameStrategy === "duplicate-ref" ? {
    ...main2,
    ...definitions || refs.seenRefs.size ? {
      [refs.definitionPath]: {
        ...definitions,
        // only actually duplicate the schema definition if it was ever referenced
        // otherwise the duplication is completely pointless
        ...refs.seenRefs.size ? { [name]: main2 } : void 0
      }
    } : void 0
  } : {
    $ref: [...refs.$refStrategy === "relative" ? [] : refs.basePath, refs.definitionPath, name].join("/"),
    [refs.definitionPath]: {
      ...definitions,
      [name]: main2
    }
  };
  if (refs.target === "jsonSchema7") {
    combined.$schema = "http://json-schema.org/draft-07/schema#";
  } else if (refs.target === "jsonSchema2019-09") {
    combined.$schema = "https://json-schema.org/draft/2019-09/schema#";
  }
  return combined;
};
function toStrictJsonSchema(schema) {
  if (schema.type !== "object") {
    throw new Error(`Root schema must have type: 'object' but got type: ${schema.type ? `'${schema.type}'` : "undefined"}`);
  }
  const schemaCopy = structuredClone(schema);
  return ensureStrictJsonSchema(schemaCopy, [], schemaCopy);
}
function isNullable(schema) {
  if (typeof schema === "boolean") {
    return false;
  }
  if (schema.type === "null") {
    return true;
  }
  for (const oneOfVariant of schema.oneOf ?? []) {
    if (isNullable(oneOfVariant)) {
      return true;
    }
  }
  for (const allOfVariant of schema.anyOf ?? []) {
    if (isNullable(allOfVariant)) {
      return true;
    }
  }
  return false;
}
function ensureStrictJsonSchema(jsonSchema, path2, root) {
  if (typeof jsonSchema === "boolean") {
    throw new TypeError(`Expected object schema but got boolean; path=${path2.join("/")}`);
  }
  if (!isObject(jsonSchema)) {
    throw new TypeError(`Expected ${JSON.stringify(jsonSchema)} to be an object; path=${path2.join("/")}`);
  }
  const defs = jsonSchema.$defs;
  if (isObject(defs)) {
    for (const [defName, defSchema] of Object.entries(defs)) {
      ensureStrictJsonSchema(defSchema, [...path2, "$defs", defName], root);
    }
  }
  const definitions = jsonSchema.definitions;
  if (isObject(definitions)) {
    for (const [definitionName, definitionSchema] of Object.entries(definitions)) {
      ensureStrictJsonSchema(definitionSchema, [...path2, "definitions", definitionName], root);
    }
  }
  const typ = jsonSchema.type;
  if (typ === "object" && !("additionalProperties" in jsonSchema)) {
    jsonSchema.additionalProperties = false;
  }
  const required2 = jsonSchema.required ?? [];
  const properties = jsonSchema.properties;
  if (isObject(properties)) {
    for (const [key, value] of Object.entries(properties)) {
      if (!isNullable(value) && !required2.includes(key)) {
        throw new Error(`Zod field at \`${[...path2, "properties", key].join("/")}\` uses \`.optional()\` without \`.nullable()\` which is not supported by the API. See: https://platform.openai.com/docs/guides/structured-outputs?api-mode=responses#all-fields-must-be-required`);
      }
    }
    jsonSchema.required = Object.keys(properties);
    jsonSchema.properties = Object.fromEntries(Object.entries(properties).map(([key, propSchema]) => [
      key,
      ensureStrictJsonSchema(propSchema, [...path2, "properties", key], root)
    ]));
  }
  const items = jsonSchema.items;
  if (isObject(items)) {
    jsonSchema.items = ensureStrictJsonSchema(items, [...path2, "items"], root);
  }
  const anyOf = jsonSchema.anyOf;
  if (Array.isArray(anyOf)) {
    jsonSchema.anyOf = anyOf.map((variant, i2) => ensureStrictJsonSchema(variant, [...path2, "anyOf", String(i2)], root));
  }
  const allOf = jsonSchema.allOf;
  if (Array.isArray(allOf)) {
    if (allOf.length === 1) {
      const resolved = ensureStrictJsonSchema(allOf[0], [...path2, "allOf", "0"], root);
      Object.assign(jsonSchema, resolved);
      delete jsonSchema.allOf;
    } else {
      jsonSchema.allOf = allOf.map((entry, i2) => ensureStrictJsonSchema(entry, [...path2, "allOf", String(i2)], root));
    }
  }
  if (jsonSchema.default === null) {
    delete jsonSchema.default;
  }
  const ref = jsonSchema.$ref;
  if (ref && hasMoreThanNKeys(jsonSchema, 1)) {
    if (typeof ref !== "string") {
      throw new TypeError(`Received non-string $ref - ${ref}; path=${path2.join("/")}`);
    }
    const resolved = resolveRef(root, ref);
    if (typeof resolved === "boolean") {
      throw new Error(`Expected \`$ref: ${ref}\` to resolve to an object schema but got boolean`);
    }
    if (!isObject(resolved)) {
      throw new Error(`Expected \`$ref: ${ref}\` to resolve to an object but got ${JSON.stringify(resolved)}`);
    }
    Object.assign(jsonSchema, { ...resolved, ...jsonSchema });
    delete jsonSchema.$ref;
    return ensureStrictJsonSchema(jsonSchema, path2, root);
  }
  return jsonSchema;
}
function resolveRef(root, ref) {
  if (!ref.startsWith("#/")) {
    throw new Error(`Unexpected $ref format ${JSON.stringify(ref)}; Does not start with #/`);
  }
  const pathParts = ref.slice(2).split("/");
  let resolved = root;
  for (const key of pathParts) {
    if (!isObject(resolved)) {
      throw new Error(`encountered non-object entry while resolving ${ref} - ${JSON.stringify(resolved)}`);
    }
    const value = resolved[key];
    if (value === void 0) {
      throw new Error(`Key ${key} not found while resolving ${ref}`);
    }
    resolved = value;
  }
  return resolved;
}
function isObject(obj) {
  return typeof obj === "object" && obj !== null && !Array.isArray(obj);
}
function hasMoreThanNKeys(obj, n) {
  let i2 = 0;
  for (const _ in obj) {
    i2++;
    if (i2 > n) {
      return true;
    }
  }
  return false;
}
function zodV3ToJsonSchema(schema, options2) {
  return zodToJsonSchema(schema, {
    openaiStrictMode: true,
    name: options2.name,
    nameStrategy: "duplicate-ref",
    $refStrategy: "extract-to-root",
    nullableStrategy: "property"
  });
}
function zodV4ToJsonSchema(schema) {
  return toStrictJsonSchema(toJSONSchema(schema, {
    target: "draft-7"
  }));
}
function isZodV4(zodObject) {
  return "_zod" in zodObject;
}
function zodResponseFormat(zodObject, name, props) {
  return makeParseableResponseFormat$1({
    type: "json_schema",
    json_schema: {
      ...props,
      name,
      strict: true,
      schema: isZodV4(zodObject) ? zodV4ToJsonSchema(zodObject) : zodV3ToJsonSchema(zodObject, { name })
    }
  }, (content) => zodObject.parse(JSON.parse(content)));
}
const SUPPORTED_METHODS = [
  "jsonSchema",
  "functionCalling",
  "jsonMode"
];
function getStructuredOutputMethod(model, method) {
  if (typeof method !== "undefined" && !SUPPORTED_METHODS.includes(method)) throw new Error(`Invalid method: ${method}. Supported methods are: ${SUPPORTED_METHODS.join(", ")}`);
  const hasSupportForJsonSchema = !model.startsWith("gpt-3") && !model.startsWith("gpt-4-") && model !== "gpt-4";
  if (hasSupportForJsonSchema && !method) return "jsonSchema";
  if (!hasSupportForJsonSchema && method === "jsonSchema") throw new Error(`JSON Schema is not supported for model "${model}". Please use a different method, e.g. "functionCalling" or "jsonMode".`);
  return method ?? "functionCalling";
}
function makeParseableResponseFormat(response_format, parser) {
  const obj = { ...response_format };
  Object.defineProperties(obj, {
    $brand: {
      value: "auto-parseable-response-format",
      enumerable: false
    },
    $parseRaw: {
      value: parser,
      enumerable: false
    }
  });
  return obj;
}
function interopZodResponseFormat(zodSchema, name, props) {
  if (isZodSchemaV3(zodSchema)) return zodResponseFormat(zodSchema, name, props);
  if (isZodSchemaV4(zodSchema)) return makeParseableResponseFormat({
    type: "json_schema",
    json_schema: {
      ...props,
      name,
      strict: true,
      schema: toJSONSchema(zodSchema, {
        cycles: "ref",
        reused: "ref",
        override(ctx) {
          ctx.jsonSchema.title = name;
        }
      })
    }
  }, (content) => parse$2(zodSchema, JSON.parse(content)));
  throw new Error("Unsupported schema response format");
}
function handleMultiModalOutput(content, messages) {
  if (messages && typeof messages === "object" && "images" in messages && Array.isArray(messages.images)) {
    const images = messages.images.filter((image) => {
      var _a3;
      return typeof ((_a3 = image == null ? void 0 : image.image_url) == null ? void 0 : _a3.url) === "string";
    }).map((image) => ({
      type: "image",
      url: image.image_url.url
    }));
    return [{
      type: "text",
      text: content
    }, ...images];
  }
  return content;
}
const PROFILES = {
  "gpt-4.1-nano": {
    maxInputTokens: 1047576,
    imageInputs: true,
    audioInputs: false,
    pdfInputs: true,
    videoInputs: false,
    maxOutputTokens: 32768,
    reasoningOutput: false,
    imageOutputs: false,
    audioOutputs: false,
    videoOutputs: false,
    toolCalling: true,
    structuredOutput: true,
    imageUrlInputs: true,
    pdfToolMessage: true,
    imageToolMessage: true,
    toolChoice: true
  },
  "text-embedding-3-small": {
    maxInputTokens: 8191,
    imageInputs: false,
    audioInputs: false,
    pdfInputs: true,
    videoInputs: false,
    maxOutputTokens: 1536,
    reasoningOutput: false,
    imageOutputs: false,
    audioOutputs: false,
    videoOutputs: false,
    toolCalling: false,
    structuredOutput: true,
    imageUrlInputs: true,
    pdfToolMessage: true,
    imageToolMessage: true,
    toolChoice: true
  },
  "gpt-4": {
    maxInputTokens: 8192,
    imageInputs: false,
    audioInputs: false,
    pdfInputs: true,
    videoInputs: false,
    maxOutputTokens: 8192,
    reasoningOutput: false,
    imageOutputs: false,
    audioOutputs: false,
    videoOutputs: false,
    toolCalling: true,
    structuredOutput: true,
    imageUrlInputs: true,
    pdfToolMessage: true,
    imageToolMessage: true,
    toolChoice: true
  },
  "o1-pro": {
    maxInputTokens: 2e5,
    imageInputs: true,
    audioInputs: false,
    pdfInputs: true,
    videoInputs: false,
    maxOutputTokens: 1e5,
    reasoningOutput: true,
    imageOutputs: false,
    audioOutputs: false,
    videoOutputs: false,
    toolCalling: true,
    structuredOutput: true,
    imageUrlInputs: true,
    pdfToolMessage: true,
    imageToolMessage: true,
    toolChoice: true
  },
  "gpt-4o-2024-05-13": {
    maxInputTokens: 128e3,
    imageInputs: true,
    audioInputs: false,
    pdfInputs: true,
    videoInputs: false,
    maxOutputTokens: 4096,
    reasoningOutput: false,
    imageOutputs: false,
    audioOutputs: false,
    videoOutputs: false,
    toolCalling: true,
    structuredOutput: true,
    imageUrlInputs: true,
    pdfToolMessage: true,
    imageToolMessage: true,
    toolChoice: true
  },
  "gpt-4o-2024-08-06": {
    maxInputTokens: 128e3,
    imageInputs: true,
    audioInputs: false,
    pdfInputs: true,
    videoInputs: false,
    maxOutputTokens: 16384,
    reasoningOutput: false,
    imageOutputs: false,
    audioOutputs: false,
    videoOutputs: false,
    toolCalling: true,
    structuredOutput: true,
    imageUrlInputs: true,
    pdfToolMessage: true,
    imageToolMessage: true,
    toolChoice: true
  },
  "gpt-4.1-mini": {
    maxInputTokens: 1047576,
    imageInputs: true,
    audioInputs: false,
    pdfInputs: true,
    videoInputs: false,
    maxOutputTokens: 32768,
    reasoningOutput: false,
    imageOutputs: false,
    audioOutputs: false,
    videoOutputs: false,
    toolCalling: true,
    structuredOutput: true,
    imageUrlInputs: true,
    pdfToolMessage: true,
    imageToolMessage: true,
    toolChoice: true
  },
  "o3-deep-research": {
    maxInputTokens: 2e5,
    imageInputs: true,
    audioInputs: false,
    pdfInputs: true,
    videoInputs: false,
    maxOutputTokens: 1e5,
    reasoningOutput: true,
    imageOutputs: false,
    audioOutputs: false,
    videoOutputs: false,
    toolCalling: true,
    structuredOutput: true,
    imageUrlInputs: true,
    pdfToolMessage: true,
    imageToolMessage: true,
    toolChoice: true
  },
  "gpt-3.5-turbo": {
    maxInputTokens: 16385,
    imageInputs: false,
    audioInputs: false,
    pdfInputs: false,
    videoInputs: false,
    maxOutputTokens: 4096,
    reasoningOutput: false,
    imageOutputs: false,
    audioOutputs: false,
    videoOutputs: false,
    toolCalling: false,
    structuredOutput: false,
    imageUrlInputs: false,
    pdfToolMessage: false,
    imageToolMessage: false,
    toolChoice: true
  },
  "text-embedding-3-large": {
    maxInputTokens: 8191,
    imageInputs: false,
    audioInputs: false,
    pdfInputs: true,
    videoInputs: false,
    maxOutputTokens: 3072,
    reasoningOutput: false,
    imageOutputs: false,
    audioOutputs: false,
    videoOutputs: false,
    toolCalling: false,
    structuredOutput: true,
    imageUrlInputs: true,
    pdfToolMessage: true,
    imageToolMessage: true,
    toolChoice: true
  },
  "gpt-4-turbo": {
    maxInputTokens: 128e3,
    imageInputs: true,
    audioInputs: false,
    pdfInputs: true,
    videoInputs: false,
    maxOutputTokens: 4096,
    reasoningOutput: false,
    imageOutputs: false,
    audioOutputs: false,
    videoOutputs: false,
    toolCalling: true,
    structuredOutput: true,
    imageUrlInputs: true,
    pdfToolMessage: true,
    imageToolMessage: true,
    toolChoice: true
  },
  "o1-preview": {
    maxInputTokens: 128e3,
    imageInputs: false,
    audioInputs: false,
    pdfInputs: true,
    videoInputs: false,
    maxOutputTokens: 32768,
    reasoningOutput: true,
    imageOutputs: false,
    audioOutputs: false,
    videoOutputs: false,
    toolCalling: false,
    structuredOutput: true,
    imageUrlInputs: true,
    pdfToolMessage: true,
    imageToolMessage: true,
    toolChoice: true
  },
  "o3-mini": {
    maxInputTokens: 2e5,
    imageInputs: false,
    audioInputs: false,
    pdfInputs: true,
    videoInputs: false,
    maxOutputTokens: 1e5,
    reasoningOutput: true,
    imageOutputs: false,
    audioOutputs: false,
    videoOutputs: false,
    toolCalling: true,
    structuredOutput: true,
    imageUrlInputs: true,
    pdfToolMessage: true,
    imageToolMessage: true,
    toolChoice: true
  },
  "codex-mini-latest": {
    maxInputTokens: 2e5,
    imageInputs: false,
    audioInputs: false,
    pdfInputs: true,
    videoInputs: false,
    maxOutputTokens: 1e5,
    reasoningOutput: true,
    imageOutputs: false,
    audioOutputs: false,
    videoOutputs: false,
    toolCalling: true,
    structuredOutput: true,
    imageUrlInputs: true,
    pdfToolMessage: true,
    imageToolMessage: true,
    toolChoice: true
  },
  "gpt-5-nano": {
    maxInputTokens: 4e5,
    imageInputs: true,
    audioInputs: false,
    pdfInputs: true,
    videoInputs: false,
    maxOutputTokens: 128e3,
    reasoningOutput: true,
    imageOutputs: false,
    audioOutputs: false,
    videoOutputs: false,
    toolCalling: true,
    structuredOutput: true,
    imageUrlInputs: true,
    pdfToolMessage: true,
    imageToolMessage: true,
    toolChoice: true
  },
  "gpt-5-codex": {
    maxInputTokens: 4e5,
    imageInputs: true,
    audioInputs: false,
    pdfInputs: true,
    videoInputs: false,
    maxOutputTokens: 128e3,
    reasoningOutput: true,
    imageOutputs: false,
    audioOutputs: false,
    videoOutputs: false,
    toolCalling: true,
    structuredOutput: true,
    imageUrlInputs: true,
    pdfToolMessage: true,
    imageToolMessage: true,
    toolChoice: true
  },
  "gpt-4o": {
    maxInputTokens: 128e3,
    imageInputs: true,
    audioInputs: false,
    pdfInputs: true,
    videoInputs: false,
    maxOutputTokens: 16384,
    reasoningOutput: false,
    imageOutputs: false,
    audioOutputs: false,
    videoOutputs: false,
    toolCalling: true,
    structuredOutput: true,
    imageUrlInputs: true,
    pdfToolMessage: true,
    imageToolMessage: true,
    toolChoice: true
  },
  "gpt-4.1": {
    maxInputTokens: 1047576,
    imageInputs: true,
    audioInputs: false,
    pdfInputs: true,
    videoInputs: false,
    maxOutputTokens: 32768,
    reasoningOutput: false,
    imageOutputs: false,
    audioOutputs: false,
    videoOutputs: false,
    toolCalling: true,
    structuredOutput: true,
    imageUrlInputs: true,
    pdfToolMessage: true,
    imageToolMessage: true,
    toolChoice: true
  },
  "o4-mini": {
    maxInputTokens: 2e5,
    imageInputs: true,
    audioInputs: false,
    pdfInputs: true,
    videoInputs: false,
    maxOutputTokens: 1e5,
    reasoningOutput: true,
    imageOutputs: false,
    audioOutputs: false,
    videoOutputs: false,
    toolCalling: true,
    structuredOutput: true,
    imageUrlInputs: true,
    pdfToolMessage: true,
    imageToolMessage: true,
    toolChoice: true
  },
  o1: {
    maxInputTokens: 2e5,
    imageInputs: true,
    audioInputs: false,
    pdfInputs: true,
    videoInputs: false,
    maxOutputTokens: 1e5,
    reasoningOutput: true,
    imageOutputs: false,
    audioOutputs: false,
    videoOutputs: false,
    toolCalling: true,
    structuredOutput: true,
    imageUrlInputs: true,
    pdfToolMessage: true,
    imageToolMessage: true,
    toolChoice: true
  },
  "gpt-5-mini": {
    maxInputTokens: 4e5,
    imageInputs: true,
    audioInputs: false,
    pdfInputs: true,
    videoInputs: false,
    maxOutputTokens: 128e3,
    reasoningOutput: true,
    imageOutputs: false,
    audioOutputs: false,
    videoOutputs: false,
    toolCalling: true,
    structuredOutput: true,
    imageUrlInputs: true,
    pdfToolMessage: true,
    imageToolMessage: true,
    toolChoice: true
  },
  "o1-mini": {
    maxInputTokens: 128e3,
    imageInputs: false,
    audioInputs: false,
    pdfInputs: true,
    videoInputs: false,
    maxOutputTokens: 65536,
    reasoningOutput: true,
    imageOutputs: false,
    audioOutputs: false,
    videoOutputs: false,
    toolCalling: false,
    structuredOutput: true,
    imageUrlInputs: true,
    pdfToolMessage: true,
    imageToolMessage: true,
    toolChoice: true
  },
  "text-embedding-ada-002": {
    maxInputTokens: 8192,
    imageInputs: false,
    audioInputs: false,
    pdfInputs: true,
    videoInputs: false,
    maxOutputTokens: 1536,
    reasoningOutput: false,
    imageOutputs: false,
    audioOutputs: false,
    videoOutputs: false,
    toolCalling: false,
    structuredOutput: true,
    imageUrlInputs: true,
    pdfToolMessage: true,
    imageToolMessage: true,
    toolChoice: true
  },
  "o3-pro": {
    maxInputTokens: 2e5,
    imageInputs: true,
    audioInputs: false,
    pdfInputs: true,
    videoInputs: false,
    maxOutputTokens: 1e5,
    reasoningOutput: true,
    imageOutputs: false,
    audioOutputs: false,
    videoOutputs: false,
    toolCalling: true,
    structuredOutput: true,
    imageUrlInputs: true,
    pdfToolMessage: true,
    imageToolMessage: true,
    toolChoice: true
  },
  "gpt-4o-2024-11-20": {
    maxInputTokens: 128e3,
    imageInputs: true,
    audioInputs: false,
    pdfInputs: true,
    videoInputs: false,
    maxOutputTokens: 16384,
    reasoningOutput: false,
    imageOutputs: false,
    audioOutputs: false,
    videoOutputs: false,
    toolCalling: true,
    structuredOutput: true,
    imageUrlInputs: true,
    pdfToolMessage: true,
    imageToolMessage: true,
    toolChoice: true
  },
  o3: {
    maxInputTokens: 2e5,
    imageInputs: true,
    audioInputs: false,
    pdfInputs: true,
    videoInputs: false,
    maxOutputTokens: 1e5,
    reasoningOutput: true,
    imageOutputs: false,
    audioOutputs: false,
    videoOutputs: false,
    toolCalling: true,
    structuredOutput: true,
    imageUrlInputs: true,
    pdfToolMessage: true,
    imageToolMessage: true,
    toolChoice: true
  },
  "o4-mini-deep-research": {
    maxInputTokens: 2e5,
    imageInputs: true,
    audioInputs: false,
    pdfInputs: true,
    videoInputs: false,
    maxOutputTokens: 1e5,
    reasoningOutput: true,
    imageOutputs: false,
    audioOutputs: false,
    videoOutputs: false,
    toolCalling: true,
    structuredOutput: true,
    imageUrlInputs: true,
    pdfToolMessage: true,
    imageToolMessage: true,
    toolChoice: true
  },
  "gpt-5-chat-latest": {
    maxInputTokens: 4e5,
    imageInputs: true,
    audioInputs: false,
    pdfInputs: true,
    videoInputs: false,
    maxOutputTokens: 128e3,
    reasoningOutput: true,
    imageOutputs: false,
    audioOutputs: false,
    videoOutputs: false,
    toolCalling: false,
    structuredOutput: true,
    imageUrlInputs: true,
    pdfToolMessage: true,
    imageToolMessage: true,
    toolChoice: true
  },
  "gpt-4o-mini": {
    maxInputTokens: 128e3,
    imageInputs: true,
    audioInputs: false,
    pdfInputs: true,
    videoInputs: false,
    maxOutputTokens: 16384,
    reasoningOutput: false,
    imageOutputs: false,
    audioOutputs: false,
    videoOutputs: false,
    toolCalling: true,
    structuredOutput: true,
    imageUrlInputs: true,
    pdfToolMessage: true,
    imageToolMessage: true,
    toolChoice: true
  },
  "gpt-5": {
    maxInputTokens: 4e5,
    imageInputs: true,
    audioInputs: false,
    pdfInputs: true,
    videoInputs: false,
    maxOutputTokens: 128e3,
    reasoningOutput: true,
    imageOutputs: false,
    audioOutputs: false,
    videoOutputs: false,
    toolCalling: true,
    structuredOutput: true,
    imageUrlInputs: true,
    pdfToolMessage: true,
    imageToolMessage: true,
    toolChoice: true
  },
  "gpt-5-pro": {
    maxInputTokens: 4e5,
    imageInputs: true,
    audioInputs: false,
    pdfInputs: true,
    videoInputs: false,
    maxOutputTokens: 272e3,
    reasoningOutput: true,
    imageOutputs: false,
    audioOutputs: false,
    videoOutputs: false,
    toolCalling: true,
    structuredOutput: true,
    imageUrlInputs: true,
    pdfToolMessage: true,
    imageToolMessage: true,
    toolChoice: true
  }
};
var profiles_default = PROFILES;
var prompt_values_exports = {};
__export(prompt_values_exports, {
  BasePromptValue: () => BasePromptValue,
  ChatPromptValue: () => ChatPromptValue,
  ImagePromptValue: () => ImagePromptValue,
  StringPromptValue: () => StringPromptValue
});
var BasePromptValue = class extends Serializable {
};
var StringPromptValue = class extends BasePromptValue {
  constructor(value) {
    super({ value });
    __publicField2(this, "lc_namespace", ["langchain_core", "prompt_values"]);
    __publicField2(this, "lc_serializable", true);
    __publicField2(this, "value");
    this.value = value;
  }
  static lc_name() {
    return "StringPromptValue";
  }
  toString() {
    return this.value;
  }
  toChatMessages() {
    return [new HumanMessage(this.value)];
  }
};
var ChatPromptValue = class extends BasePromptValue {
  constructor(fields) {
    if (Array.isArray(fields)) fields = { messages: fields };
    super(fields);
    __publicField2(this, "lc_namespace", ["langchain_core", "prompt_values"]);
    __publicField2(this, "lc_serializable", true);
    __publicField2(this, "messages");
    this.messages = fields.messages;
  }
  static lc_name() {
    return "ChatPromptValue";
  }
  toString() {
    return getBufferString(this.messages);
  }
  toChatMessages() {
    return this.messages;
  }
};
var ImagePromptValue = class extends BasePromptValue {
  constructor(fields) {
    if (!("imageUrl" in fields)) fields = { imageUrl: fields };
    super(fields);
    __publicField2(this, "lc_namespace", ["langchain_core", "prompt_values"]);
    __publicField2(this, "lc_serializable", true);
    __publicField2(this, "imageUrl");
    /** @ignore */
    __publicField2(this, "value");
    this.imageUrl = fields.imageUrl;
  }
  static lc_name() {
    return "ImagePromptValue";
  }
  toString() {
    return this.imageUrl.url;
  }
  toChatMessages() {
    return [new HumanMessage({ content: [{
      type: "image_url",
      image_url: {
        detail: this.imageUrl.detail,
        url: this.imageUrl.url
      }
    }] })];
  }
};
var HEX_CHARS = "0123456789abcdef".split("");
var EXTRA = [
  -2147483648,
  8388608,
  32768,
  128
];
var SHIFT = [
  24,
  16,
  8,
  0
];
var K = [
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
];
var blocks = [];
function Sha256(is224, sharedMemory) {
  if (sharedMemory) {
    blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
    this.blocks = blocks;
  } else this.blocks = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
  ];
  if (is224) {
    this.h0 = 3238371032;
    this.h1 = 914150663;
    this.h2 = 812702999;
    this.h3 = 4144912697;
    this.h4 = 4290775857;
    this.h5 = 1750603025;
    this.h6 = 1694076839;
    this.h7 = 3204075428;
  } else {
    this.h0 = 1779033703;
    this.h1 = 3144134277;
    this.h2 = 1013904242;
    this.h3 = 2773480762;
    this.h4 = 1359893119;
    this.h5 = 2600822924;
    this.h6 = 528734635;
    this.h7 = 1541459225;
  }
  this.block = this.start = this.bytes = this.hBytes = 0;
  this.finalized = this.hashed = false;
  this.first = true;
  this.is224 = is224;
}
Sha256.prototype.update = function(message) {
  if (this.finalized) return;
  var notString, type = typeof message;
  if (type !== "string") {
    if (type === "object") {
      if (message === null) throw new Error(ERROR);
      else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) message = new Uint8Array(message);
      else if (!Array.isArray(message)) {
        if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) throw new Error(ERROR);
      }
    } else throw new Error(ERROR);
    notString = true;
  }
  var code2, index = 0, i2, length = message.length, blocks$1 = this.blocks;
  while (index < length) {
    if (this.hashed) {
      this.hashed = false;
      blocks$1[0] = this.block;
      this.block = blocks$1[16] = blocks$1[1] = blocks$1[2] = blocks$1[3] = blocks$1[4] = blocks$1[5] = blocks$1[6] = blocks$1[7] = blocks$1[8] = blocks$1[9] = blocks$1[10] = blocks$1[11] = blocks$1[12] = blocks$1[13] = blocks$1[14] = blocks$1[15] = 0;
    }
    if (notString) for (i2 = this.start; index < length && i2 < 64; ++index) blocks$1[i2 >>> 2] |= message[index] << SHIFT[i2++ & 3];
    else for (i2 = this.start; index < length && i2 < 64; ++index) {
      code2 = message.charCodeAt(index);
      if (code2 < 128) blocks$1[i2 >>> 2] |= code2 << SHIFT[i2++ & 3];
      else if (code2 < 2048) {
        blocks$1[i2 >>> 2] |= (192 | code2 >>> 6) << SHIFT[i2++ & 3];
        blocks$1[i2 >>> 2] |= (128 | code2 & 63) << SHIFT[i2++ & 3];
      } else if (code2 < 55296 || code2 >= 57344) {
        blocks$1[i2 >>> 2] |= (224 | code2 >>> 12) << SHIFT[i2++ & 3];
        blocks$1[i2 >>> 2] |= (128 | code2 >>> 6 & 63) << SHIFT[i2++ & 3];
        blocks$1[i2 >>> 2] |= (128 | code2 & 63) << SHIFT[i2++ & 3];
      } else {
        code2 = 65536 + ((code2 & 1023) << 10 | message.charCodeAt(++index) & 1023);
        blocks$1[i2 >>> 2] |= (240 | code2 >>> 18) << SHIFT[i2++ & 3];
        blocks$1[i2 >>> 2] |= (128 | code2 >>> 12 & 63) << SHIFT[i2++ & 3];
        blocks$1[i2 >>> 2] |= (128 | code2 >>> 6 & 63) << SHIFT[i2++ & 3];
        blocks$1[i2 >>> 2] |= (128 | code2 & 63) << SHIFT[i2++ & 3];
      }
    }
    this.lastByteIndex = i2;
    this.bytes += i2 - this.start;
    if (i2 >= 64) {
      this.block = blocks$1[16];
      this.start = i2 - 64;
      this.hash();
      this.hashed = true;
    } else this.start = i2;
  }
  if (this.bytes > 4294967295) {
    this.hBytes += this.bytes / 4294967296 << 0;
    this.bytes = this.bytes % 4294967296;
  }
  return this;
};
Sha256.prototype.finalize = function() {
  if (this.finalized) return;
  this.finalized = true;
  var blocks$1 = this.blocks, i2 = this.lastByteIndex;
  blocks$1[16] = this.block;
  blocks$1[i2 >>> 2] |= EXTRA[i2 & 3];
  this.block = blocks$1[16];
  if (i2 >= 56) {
    if (!this.hashed) this.hash();
    blocks$1[0] = this.block;
    blocks$1[16] = blocks$1[1] = blocks$1[2] = blocks$1[3] = blocks$1[4] = blocks$1[5] = blocks$1[6] = blocks$1[7] = blocks$1[8] = blocks$1[9] = blocks$1[10] = blocks$1[11] = blocks$1[12] = blocks$1[13] = blocks$1[14] = blocks$1[15] = 0;
  }
  blocks$1[14] = this.hBytes << 3 | this.bytes >>> 29;
  blocks$1[15] = this.bytes << 3;
  this.hash();
};
Sha256.prototype.hash = function() {
  var a = this.h0, b = this.h1, c = this.h2, d = this.h3, e = this.h4, f = this.h5, g = this.h6, h = this.h7, blocks$1 = this.blocks, j, s0, s1, maj, t1, t2, ch, ab, da, cd, bc;
  for (j = 16; j < 64; ++j) {
    t1 = blocks$1[j - 15];
    s0 = (t1 >>> 7 | t1 << 25) ^ (t1 >>> 18 | t1 << 14) ^ t1 >>> 3;
    t1 = blocks$1[j - 2];
    s1 = (t1 >>> 17 | t1 << 15) ^ (t1 >>> 19 | t1 << 13) ^ t1 >>> 10;
    blocks$1[j] = blocks$1[j - 16] + s0 + blocks$1[j - 7] + s1 << 0;
  }
  bc = b & c;
  for (j = 0; j < 64; j += 4) {
    if (this.first) {
      if (this.is224) {
        ab = 300032;
        t1 = blocks$1[0] - 1413257819;
        h = t1 - 150054599 << 0;
        d = t1 + 24177077 << 0;
      } else {
        ab = 704751109;
        t1 = blocks$1[0] - 210244248;
        h = t1 - 1521486534 << 0;
        d = t1 + 143694565 << 0;
      }
      this.first = false;
    } else {
      s0 = (a >>> 2 | a << 30) ^ (a >>> 13 | a << 19) ^ (a >>> 22 | a << 10);
      s1 = (e >>> 6 | e << 26) ^ (e >>> 11 | e << 21) ^ (e >>> 25 | e << 7);
      ab = a & b;
      maj = ab ^ a & c ^ bc;
      ch = e & f ^ ~e & g;
      t1 = h + s1 + ch + K[j] + blocks$1[j];
      t2 = s0 + maj;
      h = d + t1 << 0;
      d = t1 + t2 << 0;
    }
    s0 = (d >>> 2 | d << 30) ^ (d >>> 13 | d << 19) ^ (d >>> 22 | d << 10);
    s1 = (h >>> 6 | h << 26) ^ (h >>> 11 | h << 21) ^ (h >>> 25 | h << 7);
    da = d & a;
    maj = da ^ d & b ^ ab;
    ch = g & h ^ ~g & e;
    t1 = f + s1 + ch + K[j + 1] + blocks$1[j + 1];
    t2 = s0 + maj;
    g = c + t1 << 0;
    c = t1 + t2 << 0;
    s0 = (c >>> 2 | c << 30) ^ (c >>> 13 | c << 19) ^ (c >>> 22 | c << 10);
    s1 = (g >>> 6 | g << 26) ^ (g >>> 11 | g << 21) ^ (g >>> 25 | g << 7);
    cd = c & d;
    maj = cd ^ c & a ^ da;
    ch = f & g ^ ~f & h;
    t1 = e + s1 + ch + K[j + 2] + blocks$1[j + 2];
    t2 = s0 + maj;
    f = b + t1 << 0;
    b = t1 + t2 << 0;
    s0 = (b >>> 2 | b << 30) ^ (b >>> 13 | b << 19) ^ (b >>> 22 | b << 10);
    s1 = (f >>> 6 | f << 26) ^ (f >>> 11 | f << 21) ^ (f >>> 25 | f << 7);
    bc = b & c;
    maj = bc ^ b & d ^ cd;
    ch = f & g ^ ~f & h;
    t1 = e + s1 + ch + K[j + 3] + blocks$1[j + 3];
    t2 = s0 + maj;
    e = a + t1 << 0;
    a = t1 + t2 << 0;
    this.chromeBugWorkAround = true;
  }
  this.h0 = this.h0 + a << 0;
  this.h1 = this.h1 + b << 0;
  this.h2 = this.h2 + c << 0;
  this.h3 = this.h3 + d << 0;
  this.h4 = this.h4 + e << 0;
  this.h5 = this.h5 + f << 0;
  this.h6 = this.h6 + g << 0;
  this.h7 = this.h7 + h << 0;
};
Sha256.prototype.hex = function() {
  this.finalize();
  var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3, h4 = this.h4, h5 = this.h5, h6 = this.h6, h7 = this.h7;
  var hex = HEX_CHARS[h0 >>> 28 & 15] + HEX_CHARS[h0 >>> 24 & 15] + HEX_CHARS[h0 >>> 20 & 15] + HEX_CHARS[h0 >>> 16 & 15] + HEX_CHARS[h0 >>> 12 & 15] + HEX_CHARS[h0 >>> 8 & 15] + HEX_CHARS[h0 >>> 4 & 15] + HEX_CHARS[h0 & 15] + HEX_CHARS[h1 >>> 28 & 15] + HEX_CHARS[h1 >>> 24 & 15] + HEX_CHARS[h1 >>> 20 & 15] + HEX_CHARS[h1 >>> 16 & 15] + HEX_CHARS[h1 >>> 12 & 15] + HEX_CHARS[h1 >>> 8 & 15] + HEX_CHARS[h1 >>> 4 & 15] + HEX_CHARS[h1 & 15] + HEX_CHARS[h2 >>> 28 & 15] + HEX_CHARS[h2 >>> 24 & 15] + HEX_CHARS[h2 >>> 20 & 15] + HEX_CHARS[h2 >>> 16 & 15] + HEX_CHARS[h2 >>> 12 & 15] + HEX_CHARS[h2 >>> 8 & 15] + HEX_CHARS[h2 >>> 4 & 15] + HEX_CHARS[h2 & 15] + HEX_CHARS[h3 >>> 28 & 15] + HEX_CHARS[h3 >>> 24 & 15] + HEX_CHARS[h3 >>> 20 & 15] + HEX_CHARS[h3 >>> 16 & 15] + HEX_CHARS[h3 >>> 12 & 15] + HEX_CHARS[h3 >>> 8 & 15] + HEX_CHARS[h3 >>> 4 & 15] + HEX_CHARS[h3 & 15] + HEX_CHARS[h4 >>> 28 & 15] + HEX_CHARS[h4 >>> 24 & 15] + HEX_CHARS[h4 >>> 20 & 15] + HEX_CHARS[h4 >>> 16 & 15] + HEX_CHARS[h4 >>> 12 & 15] + HEX_CHARS[h4 >>> 8 & 15] + HEX_CHARS[h4 >>> 4 & 15] + HEX_CHARS[h4 & 15] + HEX_CHARS[h5 >>> 28 & 15] + HEX_CHARS[h5 >>> 24 & 15] + HEX_CHARS[h5 >>> 20 & 15] + HEX_CHARS[h5 >>> 16 & 15] + HEX_CHARS[h5 >>> 12 & 15] + HEX_CHARS[h5 >>> 8 & 15] + HEX_CHARS[h5 >>> 4 & 15] + HEX_CHARS[h5 & 15] + HEX_CHARS[h6 >>> 28 & 15] + HEX_CHARS[h6 >>> 24 & 15] + HEX_CHARS[h6 >>> 20 & 15] + HEX_CHARS[h6 >>> 16 & 15] + HEX_CHARS[h6 >>> 12 & 15] + HEX_CHARS[h6 >>> 8 & 15] + HEX_CHARS[h6 >>> 4 & 15] + HEX_CHARS[h6 & 15];
  if (!this.is224) hex += HEX_CHARS[h7 >>> 28 & 15] + HEX_CHARS[h7 >>> 24 & 15] + HEX_CHARS[h7 >>> 20 & 15] + HEX_CHARS[h7 >>> 16 & 15] + HEX_CHARS[h7 >>> 12 & 15] + HEX_CHARS[h7 >>> 8 & 15] + HEX_CHARS[h7 >>> 4 & 15] + HEX_CHARS[h7 & 15];
  return hex;
};
Sha256.prototype.toString = Sha256.prototype.hex;
Sha256.prototype.digest = function() {
  this.finalize();
  var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3, h4 = this.h4, h5 = this.h5, h6 = this.h6, h7 = this.h7;
  var arr2 = [
    h0 >>> 24 & 255,
    h0 >>> 16 & 255,
    h0 >>> 8 & 255,
    h0 & 255,
    h1 >>> 24 & 255,
    h1 >>> 16 & 255,
    h1 >>> 8 & 255,
    h1 & 255,
    h2 >>> 24 & 255,
    h2 >>> 16 & 255,
    h2 >>> 8 & 255,
    h2 & 255,
    h3 >>> 24 & 255,
    h3 >>> 16 & 255,
    h3 >>> 8 & 255,
    h3 & 255,
    h4 >>> 24 & 255,
    h4 >>> 16 & 255,
    h4 >>> 8 & 255,
    h4 & 255,
    h5 >>> 24 & 255,
    h5 >>> 16 & 255,
    h5 >>> 8 & 255,
    h5 & 255,
    h6 >>> 24 & 255,
    h6 >>> 16 & 255,
    h6 >>> 8 & 255,
    h6 & 255
  ];
  if (!this.is224) arr2.push(h7 >>> 24 & 255, h7 >>> 16 & 255, h7 >>> 8 & 255, h7 & 255);
  return arr2;
};
Sha256.prototype.array = Sha256.prototype.digest;
Sha256.prototype.arrayBuffer = function() {
  this.finalize();
  var buffer = /* @__PURE__ */ new ArrayBuffer(this.is224 ? 28 : 32);
  var dataView = new DataView(buffer);
  dataView.setUint32(0, this.h0);
  dataView.setUint32(4, this.h1);
  dataView.setUint32(8, this.h2);
  dataView.setUint32(12, this.h3);
  dataView.setUint32(16, this.h4);
  dataView.setUint32(20, this.h5);
  dataView.setUint32(24, this.h6);
  if (!this.is224) dataView.setUint32(28, this.h7);
  return buffer;
};
const sha256 = (...strings) => {
  return new Sha256(false, true).update(strings.join("")).hex();
};
var hash_exports = {};
__export(hash_exports, { sha256: () => sha256 });
var caches_exports = {};
__export(caches_exports, {
  BaseCache: () => BaseCache,
  InMemoryCache: () => InMemoryCache,
  defaultHashKeyEncoder: () => defaultHashKeyEncoder,
  deserializeStoredGeneration: () => deserializeStoredGeneration,
  serializeGeneration: () => serializeGeneration
});
const defaultHashKeyEncoder = (...strings) => sha256(strings.join("_"));
function deserializeStoredGeneration(storedGeneration) {
  if (storedGeneration.message !== void 0) return {
    text: storedGeneration.text,
    message: mapStoredMessageToChatMessage(storedGeneration.message)
  };
  else return { text: storedGeneration.text };
}
function serializeGeneration(generation) {
  const serializedValue = { text: generation.text };
  if (generation.message !== void 0) serializedValue.message = generation.message.toDict();
  return serializedValue;
}
var BaseCache = class {
  constructor() {
    __publicField2(this, "keyEncoder", defaultHashKeyEncoder);
  }
  /**
  * Sets a custom key encoder function for the cache.
  * This function should take a prompt and an LLM key and return a string
  * that will be used as the cache key.
  * @param keyEncoderFn The custom key encoder function.
  */
  makeDefaultKeyEncoder(keyEncoderFn) {
    this.keyEncoder = keyEncoderFn;
  }
};
const GLOBAL_MAP = /* @__PURE__ */ new Map();
var InMemoryCache = class InMemoryCache2 extends BaseCache {
  constructor(map) {
    super();
    __publicField2(this, "cache");
    this.cache = map ?? /* @__PURE__ */ new Map();
  }
  /**
  * Retrieves data from the cache using a prompt and an LLM key. If the
  * data is not found, it returns null.
  * @param prompt The prompt used to find the data.
  * @param llmKey The LLM key used to find the data.
  * @returns The data corresponding to the prompt and LLM key, or null if not found.
  */
  lookup(prompt, llmKey) {
    return Promise.resolve(this.cache.get(this.keyEncoder(prompt, llmKey)) ?? null);
  }
  /**
  * Updates the cache with new data using a prompt and an LLM key.
  * @param prompt The prompt used to store the data.
  * @param llmKey The LLM key used to store the data.
  * @param value The data to be stored.
  */
  async update(prompt, llmKey, value) {
    this.cache.set(this.keyEncoder(prompt, llmKey), value);
  }
  /**
  * Returns a global instance of InMemoryCache using a predefined global
  * map as the initial cache.
  * @returns A global instance of InMemoryCache.
  */
  static global() {
    return new InMemoryCache2(GLOBAL_MAP);
  }
};
var base64Js = {};
base64Js.byteLength = byteLength;
base64Js.toByteArray = toByteArray;
base64Js.fromByteArray = fromByteArray;
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i];
  revLookup[code.charCodeAt(i)] = i;
}
revLookup["-".charCodeAt(0)] = 62;
revLookup["_".charCodeAt(0)] = 63;
function getLens(b64) {
  var len2 = b64.length;
  if (len2 % 4 > 0) {
    throw new Error("Invalid string. Length must be a multiple of 4");
  }
  var validLen = b64.indexOf("=");
  if (validLen === -1) validLen = len2;
  var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
  return [validLen, placeHoldersLen];
}
function byteLength(b64) {
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function _byteLength(b64, validLen, placeHoldersLen) {
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function toByteArray(b64) {
  var tmp;
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  var arr2 = new Arr(_byteLength(b64, validLen, placeHoldersLen));
  var curByte = 0;
  var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
  var i2;
  for (i2 = 0; i2 < len2; i2 += 4) {
    tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
    arr2[curByte++] = tmp >> 16 & 255;
    arr2[curByte++] = tmp >> 8 & 255;
    arr2[curByte++] = tmp & 255;
  }
  if (placeHoldersLen === 2) {
    tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
    arr2[curByte++] = tmp & 255;
  }
  if (placeHoldersLen === 1) {
    tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
    arr2[curByte++] = tmp >> 8 & 255;
    arr2[curByte++] = tmp & 255;
  }
  return arr2;
}
function tripletToBase64(num) {
  return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
}
function encodeChunk(uint8, start, end) {
  var tmp;
  var output = [];
  for (var i2 = start; i2 < end; i2 += 3) {
    tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
    output.push(tripletToBase64(tmp));
  }
  return output.join("");
}
function fromByteArray(uint8) {
  var tmp;
  var len2 = uint8.length;
  var extraBytes = len2 % 3;
  var parts = [];
  var maxChunkLength = 16383;
  for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
    parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
  }
  if (extraBytes === 1) {
    tmp = uint8[len2 - 1];
    parts.push(
      lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
    );
  } else if (extraBytes === 2) {
    tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
    parts.push(
      lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
    );
  }
  return parts.join("");
}
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, key + "", value);
  return value;
};
function bytePairMerge(piece, ranks) {
  let parts = Array.from(
    { length: piece.length },
    (_, i2) => ({ start: i2, end: i2 + 1 })
  );
  while (parts.length > 1) {
    let minRank = null;
    for (let i2 = 0; i2 < parts.length - 1; i2++) {
      const slice = piece.slice(parts[i2].start, parts[i2 + 1].end);
      const rank = ranks.get(slice.join(","));
      if (rank == null)
        continue;
      if (minRank == null || rank < minRank[0]) {
        minRank = [rank, i2];
      }
    }
    if (minRank != null) {
      const i2 = minRank[1];
      parts[i2] = { start: parts[i2].start, end: parts[i2 + 1].end };
      parts.splice(i2 + 1, 1);
    } else {
      break;
    }
  }
  return parts;
}
function bytePairEncode(piece, ranks) {
  if (piece.length === 1)
    return [ranks.get(piece.join(","))];
  return bytePairMerge(piece, ranks).map((p) => ranks.get(piece.slice(p.start, p.end).join(","))).filter((x) => x != null);
}
function escapeRegex(str2) {
  return str2.replace(/[\\^$*+?.()|[\]{}]/g, "\\$&");
}
var _Tiktoken = class {
  constructor(ranks, extendedSpecialTokens) {
    /** @internal */
    __publicField2(this, "specialTokens");
    /** @internal */
    __publicField2(this, "inverseSpecialTokens");
    /** @internal */
    __publicField2(this, "patStr");
    /** @internal */
    __publicField2(this, "textEncoder", new TextEncoder());
    /** @internal */
    __publicField2(this, "textDecoder", new TextDecoder("utf-8"));
    /** @internal */
    __publicField2(this, "rankMap", /* @__PURE__ */ new Map());
    /** @internal */
    __publicField2(this, "textMap", /* @__PURE__ */ new Map());
    this.patStr = ranks.pat_str;
    const uncompressed = ranks.bpe_ranks.split("\n").filter(Boolean).reduce((memo, x) => {
      const [_, offsetStr, ...tokens] = x.split(" ");
      const offset = Number.parseInt(offsetStr, 10);
      tokens.forEach((token, i2) => memo[token] = offset + i2);
      return memo;
    }, {});
    for (const [token, rank] of Object.entries(uncompressed)) {
      const bytes = base64Js.toByteArray(token);
      this.rankMap.set(bytes.join(","), rank);
      this.textMap.set(rank, bytes);
    }
    this.specialTokens = { ...ranks.special_tokens, ...extendedSpecialTokens };
    this.inverseSpecialTokens = Object.entries(this.specialTokens).reduce((memo, [text, rank]) => {
      memo[rank] = this.textEncoder.encode(text);
      return memo;
    }, {});
  }
  encode(text, allowedSpecial = [], disallowedSpecial = "all") {
    const regexes = new RegExp(this.patStr, "ug");
    const specialRegex = _Tiktoken.specialTokenRegex(
      Object.keys(this.specialTokens)
    );
    const ret = [];
    const allowedSpecialSet = new Set(
      allowedSpecial === "all" ? Object.keys(this.specialTokens) : allowedSpecial
    );
    const disallowedSpecialSet = new Set(
      disallowedSpecial === "all" ? Object.keys(this.specialTokens).filter(
        (x) => !allowedSpecialSet.has(x)
      ) : disallowedSpecial
    );
    if (disallowedSpecialSet.size > 0) {
      const disallowedSpecialRegex = _Tiktoken.specialTokenRegex([
        ...disallowedSpecialSet
      ]);
      const specialMatch = text.match(disallowedSpecialRegex);
      if (specialMatch != null) {
        throw new Error(
          `The text contains a special token that is not allowed: ${specialMatch[0]}`
        );
      }
    }
    let start = 0;
    while (true) {
      let nextSpecial = null;
      let startFind = start;
      while (true) {
        specialRegex.lastIndex = startFind;
        nextSpecial = specialRegex.exec(text);
        if (nextSpecial == null || allowedSpecialSet.has(nextSpecial[0]))
          break;
        startFind = nextSpecial.index + 1;
      }
      const end = (nextSpecial == null ? void 0 : nextSpecial.index) ?? text.length;
      for (const match of text.substring(start, end).matchAll(regexes)) {
        const piece = this.textEncoder.encode(match[0]);
        const token2 = this.rankMap.get(piece.join(","));
        if (token2 != null) {
          ret.push(token2);
          continue;
        }
        ret.push(...bytePairEncode(piece, this.rankMap));
      }
      if (nextSpecial == null)
        break;
      let token = this.specialTokens[nextSpecial[0]];
      ret.push(token);
      start = nextSpecial.index + nextSpecial[0].length;
    }
    return ret;
  }
  decode(tokens) {
    const res = [];
    let length = 0;
    for (let i22 = 0; i22 < tokens.length; ++i22) {
      const token = tokens[i22];
      const bytes = this.textMap.get(token) ?? this.inverseSpecialTokens[token];
      if (bytes != null) {
        res.push(bytes);
        length += bytes.length;
      }
    }
    const mergedArray = new Uint8Array(length);
    let i2 = 0;
    for (const bytes of res) {
      mergedArray.set(bytes, i2);
      i2 += bytes.length;
    }
    return this.textDecoder.decode(mergedArray);
  }
};
var Tiktoken = _Tiktoken;
__publicField(Tiktoken, "specialTokenRegex", (tokens) => {
  return new RegExp(tokens.map((i2) => escapeRegex(i2)).join("|"), "g");
});
function getEncodingNameForModel(model) {
  switch (model) {
    case "gpt2": {
      return "gpt2";
    }
    case "code-cushman-001":
    case "code-cushman-002":
    case "code-davinci-001":
    case "code-davinci-002":
    case "cushman-codex":
    case "davinci-codex":
    case "davinci-002":
    case "text-davinci-002":
    case "text-davinci-003": {
      return "p50k_base";
    }
    case "code-davinci-edit-001":
    case "text-davinci-edit-001": {
      return "p50k_edit";
    }
    case "ada":
    case "babbage":
    case "babbage-002":
    case "code-search-ada-code-001":
    case "code-search-babbage-code-001":
    case "curie":
    case "davinci":
    case "text-ada-001":
    case "text-babbage-001":
    case "text-curie-001":
    case "text-davinci-001":
    case "text-search-ada-doc-001":
    case "text-search-babbage-doc-001":
    case "text-search-curie-doc-001":
    case "text-search-davinci-doc-001":
    case "text-similarity-ada-001":
    case "text-similarity-babbage-001":
    case "text-similarity-curie-001":
    case "text-similarity-davinci-001": {
      return "r50k_base";
    }
    case "gpt-3.5-turbo-instruct-0914":
    case "gpt-3.5-turbo-instruct":
    case "gpt-3.5-turbo-16k-0613":
    case "gpt-3.5-turbo-16k":
    case "gpt-3.5-turbo-0613":
    case "gpt-3.5-turbo-0301":
    case "gpt-3.5-turbo":
    case "gpt-4-32k-0613":
    case "gpt-4-32k-0314":
    case "gpt-4-32k":
    case "gpt-4-0613":
    case "gpt-4-0314":
    case "gpt-4":
    case "gpt-3.5-turbo-1106":
    case "gpt-35-turbo":
    case "gpt-4-1106-preview":
    case "gpt-4-vision-preview":
    case "gpt-3.5-turbo-0125":
    case "gpt-4-turbo":
    case "gpt-4-turbo-2024-04-09":
    case "gpt-4-turbo-preview":
    case "gpt-4-0125-preview":
    case "text-embedding-ada-002":
    case "text-embedding-3-small":
    case "text-embedding-3-large": {
      return "cl100k_base";
    }
    case "gpt-4o":
    case "gpt-4o-2024-05-13":
    case "gpt-4o-2024-08-06":
    case "gpt-4o-2024-11-20":
    case "gpt-4o-mini-2024-07-18":
    case "gpt-4o-mini":
    case "gpt-4o-search-preview":
    case "gpt-4o-search-preview-2025-03-11":
    case "gpt-4o-mini-search-preview":
    case "gpt-4o-mini-search-preview-2025-03-11":
    case "gpt-4o-audio-preview":
    case "gpt-4o-audio-preview-2024-12-17":
    case "gpt-4o-audio-preview-2024-10-01":
    case "gpt-4o-mini-audio-preview":
    case "gpt-4o-mini-audio-preview-2024-12-17":
    case "o1":
    case "o1-2024-12-17":
    case "o1-mini":
    case "o1-mini-2024-09-12":
    case "o1-preview":
    case "o1-preview-2024-09-12":
    case "o1-pro":
    case "o1-pro-2025-03-19":
    case "o3":
    case "o3-2025-04-16":
    case "o3-mini":
    case "o3-mini-2025-01-31":
    case "o4-mini":
    case "o4-mini-2025-04-16":
    case "chatgpt-4o-latest":
    case "gpt-4o-realtime":
    case "gpt-4o-realtime-preview-2024-10-01":
    case "gpt-4o-realtime-preview-2024-12-17":
    case "gpt-4o-mini-realtime-preview":
    case "gpt-4o-mini-realtime-preview-2024-12-17":
    case "gpt-4.1":
    case "gpt-4.1-2025-04-14":
    case "gpt-4.1-mini":
    case "gpt-4.1-mini-2025-04-14":
    case "gpt-4.1-nano":
    case "gpt-4.1-nano-2025-04-14":
    case "gpt-4.5-preview":
    case "gpt-4.5-preview-2025-02-27":
    case "gpt-5":
    case "gpt-5-2025-08-07":
    case "gpt-5-nano":
    case "gpt-5-nano-2025-08-07":
    case "gpt-5-mini":
    case "gpt-5-mini-2025-08-07":
    case "gpt-5-chat-latest": {
      return "o200k_base";
    }
    default:
      throw new Error("Unknown model");
  }
}
var tiktoken_exports = {};
__export(tiktoken_exports, {
  encodingForModel: () => encodingForModel,
  getEncoding: () => getEncoding
});
const cache = {};
const caller = /* @__PURE__ */ new AsyncCaller({});
async function getEncoding(encoding) {
  if (!(encoding in cache)) cache[encoding] = caller.fetch(`https://tiktoken.pages.dev/js/${encoding}.json`).then((res) => res.json()).then((data) => new Tiktoken(data)).catch((e) => {
    delete cache[encoding];
    throw e;
  });
  return await cache[encoding];
}
async function encodingForModel(model) {
  return getEncoding(getEncodingNameForModel(model));
}
var base_exports = {};
__export(base_exports, {
  BaseLangChain: () => BaseLangChain,
  BaseLanguageModel: () => BaseLanguageModel,
  calculateMaxTokens: () => calculateMaxTokens,
  getEmbeddingContextSize: () => getEmbeddingContextSize,
  getModelContextSize: () => getModelContextSize,
  getModelNameForTiktoken: () => getModelNameForTiktoken,
  isOpenAITool: () => isOpenAITool
});
const getModelNameForTiktoken = (modelName) => {
  if (modelName.startsWith("gpt-5")) return "gpt-5";
  if (modelName.startsWith("gpt-3.5-turbo-16k")) return "gpt-3.5-turbo-16k";
  if (modelName.startsWith("gpt-3.5-turbo-")) return "gpt-3.5-turbo";
  if (modelName.startsWith("gpt-4-32k")) return "gpt-4-32k";
  if (modelName.startsWith("gpt-4-")) return "gpt-4";
  if (modelName.startsWith("gpt-4o")) return "gpt-4o";
  return modelName;
};
const getEmbeddingContextSize = (modelName) => {
  switch (modelName) {
    case "text-embedding-ada-002":
      return 8191;
    default:
      return 2046;
  }
};
const getModelContextSize = (modelName) => {
  const normalizedName = getModelNameForTiktoken(modelName);
  switch (normalizedName) {
    case "gpt-5":
    case "gpt-5-turbo":
    case "gpt-5-turbo-preview":
      return 4e5;
    case "gpt-4o":
    case "gpt-4o-mini":
    case "gpt-4o-2024-05-13":
    case "gpt-4o-2024-08-06":
      return 128e3;
    case "gpt-4-turbo":
    case "gpt-4-turbo-preview":
    case "gpt-4-turbo-2024-04-09":
    case "gpt-4-0125-preview":
    case "gpt-4-1106-preview":
      return 128e3;
    case "gpt-4-32k":
    case "gpt-4-32k-0314":
    case "gpt-4-32k-0613":
      return 32768;
    case "gpt-4":
    case "gpt-4-0314":
    case "gpt-4-0613":
      return 8192;
    case "gpt-3.5-turbo-16k":
    case "gpt-3.5-turbo-16k-0613":
      return 16384;
    case "gpt-3.5-turbo":
    case "gpt-3.5-turbo-0301":
    case "gpt-3.5-turbo-0613":
    case "gpt-3.5-turbo-1106":
    case "gpt-3.5-turbo-0125":
      return 4096;
    case "text-davinci-003":
    case "text-davinci-002":
      return 4097;
    case "text-davinci-001":
      return 2049;
    case "text-curie-001":
    case "text-babbage-001":
    case "text-ada-001":
      return 2048;
    case "code-davinci-002":
    case "code-davinci-001":
      return 8e3;
    case "code-cushman-001":
      return 2048;
    case "claude-3-5-sonnet-20241022":
    case "claude-3-5-sonnet-20240620":
    case "claude-3-opus-20240229":
    case "claude-3-sonnet-20240229":
    case "claude-3-haiku-20240307":
    case "claude-2.1":
      return 2e5;
    case "claude-2.0":
    case "claude-instant-1.2":
      return 1e5;
    case "gemini-1.5-pro":
    case "gemini-1.5-pro-latest":
    case "gemini-1.5-flash":
    case "gemini-1.5-flash-latest":
      return 1e6;
    case "gemini-pro":
    case "gemini-pro-vision":
      return 32768;
    default:
      return 4097;
  }
};
function isOpenAITool(tool2) {
  if (typeof tool2 !== "object" || !tool2) return false;
  if ("type" in tool2 && tool2.type === "function" && "function" in tool2 && typeof tool2.function === "object" && tool2.function && "name" in tool2.function && "parameters" in tool2.function) return true;
  return false;
}
const calculateMaxTokens = async ({ prompt, modelName }) => {
  let numTokens;
  try {
    numTokens = (await encodingForModel(getModelNameForTiktoken(modelName))).encode(prompt).length;
  } catch {
    console.warn("Failed to calculate number of tokens, falling back to approximate count");
    numTokens = Math.ceil(prompt.length / 4);
  }
  const maxTokens = getModelContextSize(modelName);
  return maxTokens - numTokens;
};
const getVerbosity = () => false;
var BaseLangChain = class extends Runnable {
  constructor(params) {
    super(params);
    /**
    * Whether to print out response text.
    */
    __publicField2(this, "verbose");
    __publicField2(this, "callbacks");
    __publicField2(this, "tags");
    __publicField2(this, "metadata");
    this.verbose = params.verbose ?? getVerbosity();
    this.callbacks = params.callbacks;
    this.tags = params.tags ?? [];
    this.metadata = params.metadata ?? {};
  }
  get lc_attributes() {
    return {
      callbacks: void 0,
      verbose: void 0
    };
  }
};
var BaseLanguageModel = class extends BaseLangChain {
  constructor({ callbacks, callbackManager, ...params }) {
    const { cache: cache2, ...rest } = params;
    super({
      callbacks: callbacks ?? callbackManager,
      ...rest
    });
    /**
    * The async caller should be used by subclasses to make any async calls,
    * which will thus benefit from the concurrency and retry logic.
    */
    __publicField2(this, "caller");
    __publicField2(this, "cache");
    __publicField2(this, "_encoding");
    if (typeof cache2 === "object") this.cache = cache2;
    else if (cache2) this.cache = InMemoryCache.global();
    else this.cache = void 0;
    this.caller = new AsyncCaller(params ?? {});
  }
  /**
  * Keys that the language model accepts as call options.
  */
  get callKeys() {
    return [
      "stop",
      "timeout",
      "signal",
      "tags",
      "metadata",
      "callbacks"
    ];
  }
  /**
  * Get the number of tokens in the content.
  * @param content The content to get the number of tokens for.
  * @returns The number of tokens in the content.
  */
  async getNumTokens(content) {
    let textContent;
    if (typeof content === "string") textContent = content;
    else
      textContent = content.map((item) => {
        if (typeof item === "string") return item;
        if (item.type === "text" && "text" in item) return item.text;
        return "";
      }).join("");
    let numTokens = Math.ceil(textContent.length / 4);
    if (!this._encoding) try {
      this._encoding = await encodingForModel("modelName" in this ? getModelNameForTiktoken(this.modelName) : "gpt2");
    } catch (error) {
      console.warn("Failed to calculate number of tokens, falling back to approximate count", error);
    }
    if (this._encoding) try {
      numTokens = this._encoding.encode(textContent).length;
    } catch (error) {
      console.warn("Failed to calculate number of tokens, falling back to approximate count", error);
    }
    return numTokens;
  }
  static _convertInputToPromptValue(input) {
    if (typeof input === "string") return new StringPromptValue(input);
    else if (Array.isArray(input)) return new ChatPromptValue(input.map(coerceMessageLikeToMessage));
    else return input;
  }
  /**
  * Get the identifying parameters of the LLM.
  */
  _identifyingParams() {
    return {};
  }
  /**
  * Create a unique cache key for a specific call to a specific language model.
  * @param callOptions Call options for the model
  * @returns A unique cache key.
  */
  _getSerializedCacheKeyParametersForCall({ config: config2, ...callOptions }) {
    const params = {
      ...this._identifyingParams(),
      ...callOptions,
      _type: this._llmType(),
      _model: this._modelType()
    };
    const filteredEntries = Object.entries(params).filter(([_, value]) => value !== void 0);
    const serializedEntries = filteredEntries.map(([key, value]) => `${key}:${JSON.stringify(value)}`).sort().join(",");
    return serializedEntries;
  }
  /**
  * @deprecated
  * Return a json-like object representing this LLM.
  */
  serialize() {
    return {
      ...this._identifyingParams(),
      _type: this._llmType(),
      _model: this._modelType()
    };
  }
  /**
  * @deprecated
  * Load an LLM from a json-like object describing it.
  */
  static async deserialize(_data) {
    throw new Error("Use .toJSON() instead");
  }
  /**
  * Return profiling information for the model.
  *
  * @returns {ModelProfile} An object describing the model's capabilities and constraints
  */
  get profile() {
    return {};
  }
};
var RunnablePassthrough = class extends Runnable {
  constructor(fields) {
    super(fields);
    __publicField2(this, "lc_namespace", ["langchain_core", "runnables"]);
    __publicField2(this, "lc_serializable", true);
    __publicField2(this, "func");
    if (fields) this.func = fields.func;
  }
  static lc_name() {
    return "RunnablePassthrough";
  }
  async invoke(input, options2) {
    const config2 = ensureConfig(options2);
    if (this.func) await this.func(input, config2);
    return this._callWithConfig((input$1) => Promise.resolve(input$1), input, config2);
  }
  async *transform(generator, options2) {
    const config2 = ensureConfig(options2);
    let finalOutput;
    let finalOutputSupported = true;
    for await (const chunk of this._transformStreamWithConfig(generator, (input) => input, config2)) {
      yield chunk;
      if (finalOutputSupported) if (finalOutput === void 0) finalOutput = chunk;
      else try {
        finalOutput = concat(finalOutput, chunk);
      } catch {
        finalOutput = void 0;
        finalOutputSupported = false;
      }
    }
    if (this.func && finalOutput !== void 0) await this.func(finalOutput, config2);
  }
  /**
  * A runnable that assigns key-value pairs to the input.
  *
  * The example below shows how you could use it with an inline function.
  *
  * @example
  * ```typescript
  * const prompt =
  *   PromptTemplate.fromTemplate(`Write a SQL query to answer the question using the following schema: {schema}
  * Question: {question}
  * SQL Query:`);
  *
  * // The `RunnablePassthrough.assign()` is used here to passthrough the input from the `.invoke()`
  * // call (in this example it's the question), along with any inputs passed to the `.assign()` method.
  * // In this case, we're passing the schema.
  * const sqlQueryGeneratorChain = RunnableSequence.from([
  *   RunnablePassthrough.assign({
  *     schema: async () => db.getTableInfo(),
  *   }),
  *   prompt,
  *   new ChatOpenAI({ model: "gpt-4o-mini" }).withConfig({ stop: ["\nSQLResult:"] }),
  *   new StringOutputParser(),
  * ]);
  * const result = await sqlQueryGeneratorChain.invoke({
  *   question: "How many employees are there?",
  * });
  * ```
  */
  static assign(mapping) {
    return new RunnableAssign(new RunnableMap({ steps: mapping }));
  }
};
const iife = (fn) => fn();
function castStandardMessageContent(message) {
  const Cls = message.constructor;
  return new Cls({
    ...message,
    content: message.contentBlocks,
    response_metadata: {
      ...message.response_metadata,
      output_version: "v1"
    }
  });
}
var chat_models_exports = {};
__export(chat_models_exports, {
  BaseChatModel: () => BaseChatModel,
  SimpleChatModel: () => SimpleChatModel
});
function _formatForTracing(messages) {
  const messagesToTrace = [];
  for (const message of messages) {
    let messageToTrace = message;
    if (Array.isArray(message.content)) for (let idx = 0; idx < message.content.length; idx++) {
      const block = message.content[idx];
      if (isURLContentBlock(block) || isBase64ContentBlock(block)) {
        if (messageToTrace === message) messageToTrace = new message.constructor({
          ...messageToTrace,
          content: [
            ...message.content.slice(0, idx),
            convertToOpenAIImageBlock(block),
            ...message.content.slice(idx + 1)
          ]
        });
      }
    }
    messagesToTrace.push(messageToTrace);
  }
  return messagesToTrace;
}
var BaseChatModel = class BaseChatModel2 extends BaseLanguageModel {
  constructor(fields) {
    super(fields);
    __publicField2(this, "lc_namespace", [
      "langchain",
      "chat_models",
      this._llmType()
    ]);
    __publicField2(this, "disableStreaming", false);
    __publicField2(this, "outputVersion");
    this.outputVersion = iife(() => {
      const outputVersion = fields.outputVersion ?? getEnvironmentVariable$1("LC_OUTPUT_VERSION");
      if (outputVersion && ["v0", "v1"].includes(outputVersion)) return outputVersion;
      return "v0";
    });
  }
  get callKeys() {
    return [...super.callKeys, "outputVersion"];
  }
  _separateRunnableConfigFromCallOptionsCompat(options2) {
    const [runnableConfig, callOptions] = super._separateRunnableConfigFromCallOptions(options2);
    callOptions.signal = runnableConfig.signal;
    return [runnableConfig, callOptions];
  }
  /**
  * Invokes the chat model with a single input.
  * @param input The input for the language model.
  * @param options The call options.
  * @returns A Promise that resolves to a BaseMessageChunk.
  */
  async invoke(input, options2) {
    const promptValue = BaseChatModel2._convertInputToPromptValue(input);
    const result = await this.generatePrompt([promptValue], options2, options2 == null ? void 0 : options2.callbacks);
    const chatGeneration = result.generations[0][0];
    return chatGeneration.message;
  }
  async *_streamResponseChunks(_messages, _options, _runManager) {
    throw new Error("Not implemented.");
  }
  async *_streamIterator(input, options2) {
    var _a3;
    if (this._streamResponseChunks === BaseChatModel2.prototype._streamResponseChunks || this.disableStreaming) yield this.invoke(input, options2);
    else {
      const prompt = BaseChatModel2._convertInputToPromptValue(input);
      const messages = prompt.toChatMessages();
      const [runnableConfig, callOptions] = this._separateRunnableConfigFromCallOptionsCompat(options2);
      const inheritableMetadata = {
        ...runnableConfig.metadata,
        ...this.getLsParams(callOptions)
      };
      const callbackManager_ = await CallbackManager.configure(runnableConfig.callbacks, this.callbacks, runnableConfig.tags, this.tags, inheritableMetadata, this.metadata, { verbose: this.verbose });
      const extra = {
        options: callOptions,
        invocation_params: this == null ? void 0 : this.invocationParams(callOptions),
        batch_size: 1
      };
      const outputVersion = callOptions.outputVersion ?? this.outputVersion;
      const runManagers = await (callbackManager_ == null ? void 0 : callbackManager_.handleChatModelStart(this.toJSON(), [_formatForTracing(messages)], runnableConfig.runId, void 0, extra, void 0, void 0, runnableConfig.runName));
      let generationChunk;
      let llmOutput;
      try {
        for await (const chunk of this._streamResponseChunks(messages, callOptions, runManagers == null ? void 0 : runManagers[0])) {
          if (chunk.message.id == null) {
            const runId = (_a3 = runManagers == null ? void 0 : runManagers.at(0)) == null ? void 0 : _a3.runId;
            if (runId != null) chunk.message._updateId(`run-${runId}`);
          }
          chunk.message.response_metadata = {
            ...chunk.generationInfo,
            ...chunk.message.response_metadata
          };
          if (outputVersion === "v1") yield castStandardMessageContent(chunk.message);
          else yield chunk.message;
          if (!generationChunk) generationChunk = chunk;
          else generationChunk = generationChunk.concat(chunk);
          if (isAIMessageChunk(chunk.message) && chunk.message.usage_metadata !== void 0) llmOutput = { tokenUsage: {
            promptTokens: chunk.message.usage_metadata.input_tokens,
            completionTokens: chunk.message.usage_metadata.output_tokens,
            totalTokens: chunk.message.usage_metadata.total_tokens
          } };
        }
      } catch (err) {
        await Promise.all((runManagers ?? []).map((runManager) => runManager == null ? void 0 : runManager.handleLLMError(err)));
        throw err;
      }
      await Promise.all((runManagers ?? []).map((runManager) => runManager == null ? void 0 : runManager.handleLLMEnd({
        generations: [[generationChunk]],
        llmOutput
      })));
    }
  }
  getLsParams(options2) {
    const providerName = this.getName().startsWith("Chat") ? this.getName().replace("Chat", "") : this.getName();
    return {
      ls_model_type: "chat",
      ls_stop: options2.stop,
      ls_provider: providerName
    };
  }
  /** @ignore */
  async _generateUncached(messages, parsedOptions, handledOptions, startedRunManagers) {
    var _a3, _b;
    const baseMessages = messages.map((messageList) => messageList.map(coerceMessageLikeToMessage));
    let runManagers;
    if (startedRunManagers !== void 0 && startedRunManagers.length === baseMessages.length) runManagers = startedRunManagers;
    else {
      const inheritableMetadata = {
        ...handledOptions.metadata,
        ...this.getLsParams(parsedOptions)
      };
      const callbackManager_ = await CallbackManager.configure(handledOptions.callbacks, this.callbacks, handledOptions.tags, this.tags, inheritableMetadata, this.metadata, { verbose: this.verbose });
      const extra = {
        options: parsedOptions,
        invocation_params: this == null ? void 0 : this.invocationParams(parsedOptions),
        batch_size: 1
      };
      runManagers = await (callbackManager_ == null ? void 0 : callbackManager_.handleChatModelStart(this.toJSON(), baseMessages.map(_formatForTracing), handledOptions.runId, void 0, extra, void 0, void 0, handledOptions.runName));
    }
    const outputVersion = parsedOptions.outputVersion ?? this.outputVersion;
    const generations = [];
    const llmOutputs = [];
    const hasStreamingHandler = !!(runManagers == null ? void 0 : runManagers[0].handlers.find(callbackHandlerPrefersStreaming));
    if (hasStreamingHandler && !this.disableStreaming && baseMessages.length === 1 && this._streamResponseChunks !== BaseChatModel2.prototype._streamResponseChunks) try {
      const stream = await this._streamResponseChunks(baseMessages[0], parsedOptions, runManagers == null ? void 0 : runManagers[0]);
      let aggregated;
      let llmOutput;
      for await (const chunk of stream) {
        if (chunk.message.id == null) {
          const runId = (_a3 = runManagers == null ? void 0 : runManagers.at(0)) == null ? void 0 : _a3.runId;
          if (runId != null) chunk.message._updateId(`run-${runId}`);
        }
        if (aggregated === void 0) aggregated = chunk;
        else aggregated = concat(aggregated, chunk);
        if (isAIMessageChunk(chunk.message) && chunk.message.usage_metadata !== void 0) llmOutput = { tokenUsage: {
          promptTokens: chunk.message.usage_metadata.input_tokens,
          completionTokens: chunk.message.usage_metadata.output_tokens,
          totalTokens: chunk.message.usage_metadata.total_tokens
        } };
      }
      if (aggregated === void 0) throw new Error("Received empty response from chat model call.");
      generations.push([aggregated]);
      await (runManagers == null ? void 0 : runManagers[0].handleLLMEnd({
        generations,
        llmOutput
      }));
    } catch (e) {
      await (runManagers == null ? void 0 : runManagers[0].handleLLMError(e));
      throw e;
    }
    else {
      const results2 = await Promise.allSettled(baseMessages.map(async (messageList, i2) => {
        const generateResults = await this._generate(messageList, {
          ...parsedOptions,
          promptIndex: i2
        }, runManagers == null ? void 0 : runManagers[i2]);
        if (outputVersion === "v1") for (const generation of generateResults.generations) generation.message = castStandardMessageContent(generation.message);
        return generateResults;
      }));
      await Promise.all(results2.map(async (pResult, i2) => {
        var _a4, _b2, _c;
        if (pResult.status === "fulfilled") {
          const result = pResult.value;
          for (const generation of result.generations) {
            if (generation.message.id == null) {
              const runId = (_a4 = runManagers == null ? void 0 : runManagers.at(0)) == null ? void 0 : _a4.runId;
              if (runId != null) generation.message._updateId(`run-${runId}`);
            }
            generation.message.response_metadata = {
              ...generation.generationInfo,
              ...generation.message.response_metadata
            };
          }
          if (result.generations.length === 1) result.generations[0].message.response_metadata = {
            ...result.llmOutput,
            ...result.generations[0].message.response_metadata
          };
          generations[i2] = result.generations;
          llmOutputs[i2] = result.llmOutput;
          return (_b2 = runManagers == null ? void 0 : runManagers[i2]) == null ? void 0 : _b2.handleLLMEnd({
            generations: [result.generations],
            llmOutput: result.llmOutput
          });
        } else {
          await ((_c = runManagers == null ? void 0 : runManagers[i2]) == null ? void 0 : _c.handleLLMError(pResult.reason));
          return Promise.reject(pResult.reason);
        }
      }));
    }
    const output = {
      generations,
      llmOutput: llmOutputs.length ? (_b = this._combineLLMOutput) == null ? void 0 : _b.call(this, ...llmOutputs) : void 0
    };
    Object.defineProperty(output, RUN_KEY, {
      value: runManagers ? { runIds: runManagers == null ? void 0 : runManagers.map((manager) => manager.runId) } : void 0,
      configurable: true
    });
    return output;
  }
  async _generateCached({ messages, cache: cache2, llmStringKey, parsedOptions, handledOptions }) {
    const baseMessages = messages.map((messageList) => messageList.map(coerceMessageLikeToMessage));
    const inheritableMetadata = {
      ...handledOptions.metadata,
      ...this.getLsParams(parsedOptions)
    };
    const callbackManager_ = await CallbackManager.configure(handledOptions.callbacks, this.callbacks, handledOptions.tags, this.tags, inheritableMetadata, this.metadata, { verbose: this.verbose });
    const extra = {
      options: parsedOptions,
      invocation_params: this == null ? void 0 : this.invocationParams(parsedOptions),
      batch_size: 1
    };
    const runManagers = await (callbackManager_ == null ? void 0 : callbackManager_.handleChatModelStart(this.toJSON(), baseMessages.map(_formatForTracing), handledOptions.runId, void 0, extra, void 0, void 0, handledOptions.runName));
    const missingPromptIndices = [];
    const results2 = await Promise.allSettled(baseMessages.map(async (baseMessage, index) => {
      const prompt = BaseChatModel2._convertInputToPromptValue(baseMessage).toString();
      const result = await cache2.lookup(prompt, llmStringKey);
      if (result == null) missingPromptIndices.push(index);
      return result;
    }));
    const cachedResults = results2.map((result, index) => ({
      result,
      runManager: runManagers == null ? void 0 : runManagers[index]
    })).filter(({ result }) => result.status === "fulfilled" && result.value != null || result.status === "rejected");
    const outputVersion = parsedOptions.outputVersion ?? this.outputVersion;
    const generations = [];
    await Promise.all(cachedResults.map(async ({ result: promiseResult, runManager }, i2) => {
      if (promiseResult.status === "fulfilled") {
        const result = promiseResult.value;
        generations[i2] = result.map((result$1) => {
          if ("message" in result$1 && isBaseMessage(result$1.message) && isAIMessage(result$1.message)) {
            result$1.message.usage_metadata = {
              input_tokens: 0,
              output_tokens: 0,
              total_tokens: 0
            };
            if (outputVersion === "v1") result$1.message = castStandardMessageContent(result$1.message);
          }
          result$1.generationInfo = {
            ...result$1.generationInfo,
            tokenUsage: {}
          };
          return result$1;
        });
        if (result.length) await (runManager == null ? void 0 : runManager.handleLLMNewToken(result[0].text));
        return runManager == null ? void 0 : runManager.handleLLMEnd({ generations: [result] }, void 0, void 0, void 0, { cached: true });
      } else {
        await (runManager == null ? void 0 : runManager.handleLLMError(promiseResult.reason, void 0, void 0, void 0, { cached: true }));
        return Promise.reject(promiseResult.reason);
      }
    }));
    const output = {
      generations,
      missingPromptIndices,
      startedRunManagers: runManagers
    };
    Object.defineProperty(output, RUN_KEY, {
      value: runManagers ? { runIds: runManagers == null ? void 0 : runManagers.map((manager) => manager.runId) } : void 0,
      configurable: true
    });
    return output;
  }
  /**
  * Generates chat based on the input messages.
  * @param messages An array of arrays of BaseMessage instances.
  * @param options The call options or an array of stop sequences.
  * @param callbacks The callbacks for the language model.
  * @returns A Promise that resolves to an LLMResult.
  */
  async generate(messages, options2, callbacks) {
    let parsedOptions;
    if (Array.isArray(options2)) parsedOptions = { stop: options2 };
    else parsedOptions = options2;
    const baseMessages = messages.map((messageList) => messageList.map(coerceMessageLikeToMessage));
    const [runnableConfig, callOptions] = this._separateRunnableConfigFromCallOptionsCompat(parsedOptions);
    runnableConfig.callbacks = runnableConfig.callbacks ?? callbacks;
    if (!this.cache) return this._generateUncached(baseMessages, callOptions, runnableConfig);
    const { cache: cache2 } = this;
    const llmStringKey = this._getSerializedCacheKeyParametersForCall(callOptions);
    const { generations, missingPromptIndices, startedRunManagers } = await this._generateCached({
      messages: baseMessages,
      cache: cache2,
      llmStringKey,
      parsedOptions: callOptions,
      handledOptions: runnableConfig
    });
    let llmOutput = {};
    if (missingPromptIndices.length > 0) {
      const results2 = await this._generateUncached(missingPromptIndices.map((i2) => baseMessages[i2]), callOptions, runnableConfig, startedRunManagers !== void 0 ? missingPromptIndices.map((i2) => startedRunManagers == null ? void 0 : startedRunManagers[i2]) : void 0);
      await Promise.all(results2.generations.map(async (generation, index) => {
        const promptIndex = missingPromptIndices[index];
        generations[promptIndex] = generation;
        const prompt = BaseChatModel2._convertInputToPromptValue(baseMessages[promptIndex]).toString();
        return cache2.update(prompt, llmStringKey, generation);
      }));
      llmOutput = results2.llmOutput ?? {};
    }
    return {
      generations,
      llmOutput
    };
  }
  /**
  * Get the parameters used to invoke the model
  */
  invocationParams(_options) {
    return {};
  }
  _modelType() {
    return "base_chat_model";
  }
  /**
  * Generates a prompt based on the input prompt values.
  * @param promptValues An array of BasePromptValue instances.
  * @param options The call options or an array of stop sequences.
  * @param callbacks The callbacks for the language model.
  * @returns A Promise that resolves to an LLMResult.
  */
  async generatePrompt(promptValues, options2, callbacks) {
    const promptMessages = promptValues.map((promptValue) => promptValue.toChatMessages());
    return this.generate(promptMessages, options2, callbacks);
  }
  withStructuredOutput(outputSchema, config2) {
    if (typeof this.bindTools !== "function") throw new Error(`Chat model must implement ".bindTools()" to use withStructuredOutput.`);
    if (config2 == null ? void 0 : config2.strict) throw new Error(`"strict" mode is not supported for this model by default.`);
    const schema = outputSchema;
    const name = config2 == null ? void 0 : config2.name;
    const description = getSchemaDescription(schema) ?? "A function available to call.";
    const method = config2 == null ? void 0 : config2.method;
    const includeRaw = config2 == null ? void 0 : config2.includeRaw;
    if (method === "jsonMode") throw new Error(`Base withStructuredOutput implementation only supports "functionCalling" as a method.`);
    let functionName = name ?? "extract";
    let tools;
    if (isInteropZodSchema(schema)) tools = [{
      type: "function",
      function: {
        name: functionName,
        description,
        parameters: toJsonSchema(schema)
      }
    }];
    else {
      if ("name" in schema) functionName = schema.name;
      tools = [{
        type: "function",
        function: {
          name: functionName,
          description,
          parameters: schema
        }
      }];
    }
    const llm = this.bindTools(tools);
    const outputParser = RunnableLambda.from((input) => {
      if (!AIMessageChunk.isInstance(input)) throw new Error("Input is not an AIMessageChunk.");
      if (!input.tool_calls || input.tool_calls.length === 0) throw new Error("No tool calls found in the response.");
      const toolCall = input.tool_calls.find((tc) => tc.name === functionName);
      if (!toolCall) throw new Error(`No tool call found with name ${functionName}.`);
      return toolCall.args;
    });
    if (!includeRaw) return llm.pipe(outputParser).withConfig({ runName: "StructuredOutput" });
    const parserAssign = RunnablePassthrough.assign({ parsed: (input, config$12) => outputParser.invoke(input.raw, config$12) });
    const parserNone = RunnablePassthrough.assign({ parsed: () => null });
    const parsedWithFallback = parserAssign.withFallbacks({ fallbacks: [parserNone] });
    return RunnableSequence.from([{ raw: llm }, parsedWithFallback]).withConfig({ runName: "StructuredOutputRunnable" });
  }
};
var SimpleChatModel = class extends BaseChatModel {
  async _generate(messages, options2, runManager) {
    const text = await this._call(messages, options2, runManager);
    const message = new AIMessage(text);
    if (typeof message.content !== "string") throw new Error("Cannot generate with a simple chat model when output is not a string.");
    return { generations: [{
      text: message.content,
      message
    }] };
  }
};
var RouterRunnable = class extends Runnable {
  constructor(fields) {
    super(fields);
    __publicField2(this, "lc_namespace", ["langchain_core", "runnables"]);
    __publicField2(this, "lc_serializable", true);
    __publicField2(this, "runnables");
    this.runnables = fields.runnables;
  }
  static lc_name() {
    return "RouterRunnable";
  }
  async invoke(input, options2) {
    const { key, input: actualInput } = input;
    const runnable = this.runnables[key];
    if (runnable === void 0) throw new Error(`No runnable associated with key "${key}".`);
    return runnable.invoke(actualInput, ensureConfig(options2));
  }
  async batch(inputs, options2, batchOptions) {
    var _a3;
    const keys = inputs.map((input) => input.key);
    const actualInputs = inputs.map((input) => input.input);
    const missingKey = keys.find((key) => this.runnables[key] === void 0);
    if (missingKey !== void 0) throw new Error(`One or more keys do not have a corresponding runnable.`);
    const runnables = keys.map((key) => this.runnables[key]);
    const optionsList = this._getOptionsList(options2 ?? {}, inputs.length);
    const maxConcurrency = ((_a3 = optionsList[0]) == null ? void 0 : _a3.maxConcurrency) ?? (batchOptions == null ? void 0 : batchOptions.maxConcurrency);
    const batchSize = maxConcurrency && maxConcurrency > 0 ? maxConcurrency : inputs.length;
    const batchResults = [];
    for (let i2 = 0; i2 < actualInputs.length; i2 += batchSize) {
      const batchPromises = actualInputs.slice(i2, i2 + batchSize).map((actualInput, i$1) => runnables[i$1].invoke(actualInput, optionsList[i$1]));
      const batchResult = await Promise.all(batchPromises);
      batchResults.push(batchResult);
    }
    return batchResults.flat();
  }
  async stream(input, options2) {
    const { key, input: actualInput } = input;
    const runnable = this.runnables[key];
    if (runnable === void 0) throw new Error(`No runnable associated with key "${key}".`);
    return runnable.stream(actualInput, options2);
  }
};
var RunnableBranch = class extends Runnable {
  constructor(fields) {
    super(fields);
    __publicField2(this, "lc_namespace", ["langchain_core", "runnables"]);
    __publicField2(this, "lc_serializable", true);
    __publicField2(this, "default");
    __publicField2(this, "branches");
    this.branches = fields.branches;
    this.default = fields.default;
  }
  static lc_name() {
    return "RunnableBranch";
  }
  /**
  * Convenience method for instantiating a RunnableBranch from
  * RunnableLikes (objects, functions, or Runnables).
  *
  * Each item in the input except for the last one should be a
  * tuple with two items. The first is a "condition" RunnableLike that
  * returns "true" if the second RunnableLike in the tuple should run.
  *
  * The final item in the input should be a RunnableLike that acts as a
  * default branch if no other branches match.
  *
  * @example
  * ```ts
  * import { RunnableBranch } from "@langchain/core/runnables";
  *
  * const branch = RunnableBranch.from([
  *   [(x: number) => x > 0, (x: number) => x + 1],
  *   [(x: number) => x < 0, (x: number) => x - 1],
  *   (x: number) => x
  * ]);
  * ```
  * @param branches An array where the every item except the last is a tuple of [condition, runnable]
  *   pairs. The last item is a default runnable which is invoked if no other condition matches.
  * @returns A new RunnableBranch.
  */
  static from(branches) {
    if (branches.length < 1) throw new Error("RunnableBranch requires at least one branch");
    const branchLikes = branches.slice(0, -1);
    const coercedBranches = branchLikes.map(([condition, runnable]) => [_coerceToRunnable(condition), _coerceToRunnable(runnable)]);
    const defaultBranch = _coerceToRunnable(branches[branches.length - 1]);
    return new this({
      branches: coercedBranches,
      default: defaultBranch
    });
  }
  async _invoke(input, config2, runManager) {
    let result;
    for (let i2 = 0; i2 < this.branches.length; i2 += 1) {
      const [condition, branchRunnable] = this.branches[i2];
      const conditionValue = await condition.invoke(input, patchConfig(config2, { callbacks: runManager == null ? void 0 : runManager.getChild(`condition:${i2 + 1}`) }));
      if (conditionValue) {
        result = await branchRunnable.invoke(input, patchConfig(config2, { callbacks: runManager == null ? void 0 : runManager.getChild(`branch:${i2 + 1}`) }));
        break;
      }
    }
    if (!result) result = await this.default.invoke(input, patchConfig(config2, { callbacks: runManager == null ? void 0 : runManager.getChild("branch:default") }));
    return result;
  }
  async invoke(input, config2 = {}) {
    return this._callWithConfig(this._invoke, input, config2);
  }
  async *_streamIterator(input, config2) {
    const callbackManager_ = await getCallbackManagerForConfig(config2);
    const runManager = await (callbackManager_ == null ? void 0 : callbackManager_.handleChainStart(this.toJSON(), _coerceToDict(input, "input"), config2 == null ? void 0 : config2.runId, void 0, void 0, void 0, config2 == null ? void 0 : config2.runName));
    let finalOutput;
    let finalOutputSupported = true;
    let stream;
    try {
      for (let i2 = 0; i2 < this.branches.length; i2 += 1) {
        const [condition, branchRunnable] = this.branches[i2];
        const conditionValue = await condition.invoke(input, patchConfig(config2, { callbacks: runManager == null ? void 0 : runManager.getChild(`condition:${i2 + 1}`) }));
        if (conditionValue) {
          stream = await branchRunnable.stream(input, patchConfig(config2, { callbacks: runManager == null ? void 0 : runManager.getChild(`branch:${i2 + 1}`) }));
          for await (const chunk of stream) {
            yield chunk;
            if (finalOutputSupported) if (finalOutput === void 0) finalOutput = chunk;
            else try {
              finalOutput = concat(finalOutput, chunk);
            } catch {
              finalOutput = void 0;
              finalOutputSupported = false;
            }
          }
          break;
        }
      }
      if (stream === void 0) {
        stream = await this.default.stream(input, patchConfig(config2, { callbacks: runManager == null ? void 0 : runManager.getChild("branch:default") }));
        for await (const chunk of stream) {
          yield chunk;
          if (finalOutputSupported) if (finalOutput === void 0) finalOutput = chunk;
          else try {
            finalOutput = concat(finalOutput, chunk);
          } catch {
            finalOutput = void 0;
            finalOutputSupported = false;
          }
        }
      }
    } catch (e) {
      await (runManager == null ? void 0 : runManager.handleChainError(e));
      throw e;
    }
    await (runManager == null ? void 0 : runManager.handleChainEnd(finalOutput ?? {}));
  }
};
var RunnableWithMessageHistory = class extends RunnableBinding {
  constructor(fields) {
    let historyChain = RunnableLambda.from((input, options2) => this._enterHistory(input, options2 ?? {})).withConfig({ runName: "loadHistory" });
    const messagesKey = fields.historyMessagesKey ?? fields.inputMessagesKey;
    if (messagesKey) historyChain = RunnablePassthrough.assign({ [messagesKey]: historyChain }).withConfig({ runName: "insertHistory" });
    const bound = historyChain.pipe(fields.runnable.withListeners({ onEnd: (run, config$12) => this._exitHistory(run, config$12 ?? {}) })).withConfig({ runName: "RunnableWithMessageHistory" });
    const config2 = fields.config ?? {};
    super({
      ...fields,
      config: config2,
      bound
    });
    __publicField2(this, "runnable");
    __publicField2(this, "inputMessagesKey");
    __publicField2(this, "outputMessagesKey");
    __publicField2(this, "historyMessagesKey");
    __publicField2(this, "getMessageHistory");
    this.runnable = fields.runnable;
    this.getMessageHistory = fields.getMessageHistory;
    this.inputMessagesKey = fields.inputMessagesKey;
    this.outputMessagesKey = fields.outputMessagesKey;
    this.historyMessagesKey = fields.historyMessagesKey;
  }
  _getInputMessages(inputValue) {
    let parsedInputValue;
    if (typeof inputValue === "object" && !Array.isArray(inputValue) && !isBaseMessage(inputValue)) {
      let key;
      if (this.inputMessagesKey) key = this.inputMessagesKey;
      else if (Object.keys(inputValue).length === 1) key = Object.keys(inputValue)[0];
      else key = "input";
      if (Array.isArray(inputValue[key]) && Array.isArray(inputValue[key][0])) parsedInputValue = inputValue[key][0];
      else parsedInputValue = inputValue[key];
    } else parsedInputValue = inputValue;
    if (typeof parsedInputValue === "string") return [new HumanMessage(parsedInputValue)];
    else if (Array.isArray(parsedInputValue)) return parsedInputValue;
    else if (isBaseMessage(parsedInputValue)) return [parsedInputValue];
    else throw new Error(`Expected a string, BaseMessage, or array of BaseMessages.
Got ${JSON.stringify(parsedInputValue, null, 2)}`);
  }
  _getOutputMessages(outputValue) {
    let parsedOutputValue;
    if (!Array.isArray(outputValue) && !isBaseMessage(outputValue) && typeof outputValue !== "string") {
      let key;
      if (this.outputMessagesKey !== void 0) key = this.outputMessagesKey;
      else if (Object.keys(outputValue).length === 1) key = Object.keys(outputValue)[0];
      else key = "output";
      if (outputValue.generations !== void 0) parsedOutputValue = outputValue.generations[0][0].message;
      else parsedOutputValue = outputValue[key];
    } else parsedOutputValue = outputValue;
    if (typeof parsedOutputValue === "string") return [new AIMessage(parsedOutputValue)];
    else if (Array.isArray(parsedOutputValue)) return parsedOutputValue;
    else if (isBaseMessage(parsedOutputValue)) return [parsedOutputValue];
    else throw new Error(`Expected a string, BaseMessage, or array of BaseMessages. Received: ${JSON.stringify(parsedOutputValue, null, 2)}`);
  }
  async _enterHistory(input, kwargs) {
    var _a3;
    const history = (_a3 = kwargs == null ? void 0 : kwargs.configurable) == null ? void 0 : _a3.messageHistory;
    const messages = await history.getMessages();
    if (this.historyMessagesKey === void 0) return messages.concat(this._getInputMessages(input));
    return messages;
  }
  async _exitHistory(run, config2) {
    var _a3;
    const history = (_a3 = config2.configurable) == null ? void 0 : _a3.messageHistory;
    let inputs;
    if (Array.isArray(run.inputs) && Array.isArray(run.inputs[0])) inputs = run.inputs[0];
    else inputs = run.inputs;
    let inputMessages = this._getInputMessages(inputs);
    if (this.historyMessagesKey === void 0) {
      const existingMessages = await history.getMessages();
      inputMessages = inputMessages.slice(existingMessages.length);
    }
    const outputValue = run.outputs;
    if (!outputValue) throw new Error(`Output values from 'Run' undefined. Run: ${JSON.stringify(run, null, 2)}`);
    const outputMessages = this._getOutputMessages(outputValue);
    await history.addMessages([...inputMessages, ...outputMessages]);
  }
  async _mergeConfig(...configs) {
    const config2 = await super._mergeConfig(...configs);
    if (!config2.configurable || !config2.configurable.sessionId) {
      const exampleInput = { [this.inputMessagesKey ?? "input"]: "foo" };
      const exampleConfig = { configurable: { sessionId: "123" } };
      throw new Error(`sessionId is required. Pass it in as part of the config argument to .invoke() or .stream()
eg. chain.invoke(${JSON.stringify(exampleInput)}, ${JSON.stringify(exampleConfig)})`);
    }
    const { sessionId } = config2.configurable;
    config2.configurable.messageHistory = await this.getMessageHistory(sessionId);
    return config2;
  }
};
var runnables_exports = {};
__export(runnables_exports, {
  RouterRunnable: () => RouterRunnable,
  Runnable: () => Runnable,
  RunnableAssign: () => RunnableAssign,
  RunnableBinding: () => RunnableBinding,
  RunnableBranch: () => RunnableBranch,
  RunnableEach: () => RunnableEach,
  RunnableLambda: () => RunnableLambda,
  RunnableMap: () => RunnableMap,
  RunnableParallel: () => RunnableParallel,
  RunnablePassthrough: () => RunnablePassthrough,
  RunnablePick: () => RunnablePick,
  RunnableRetry: () => RunnableRetry,
  RunnableSequence: () => RunnableSequence,
  RunnableToolLike: () => RunnableToolLike,
  RunnableWithFallbacks: () => RunnableWithFallbacks,
  RunnableWithMessageHistory: () => RunnableWithMessageHistory,
  _coerceToRunnable: () => _coerceToRunnable,
  ensureConfig: () => ensureConfig,
  getCallbackManagerForConfig: () => getCallbackManagerForConfig,
  mergeConfigs: () => mergeConfigs,
  patchConfig: () => patchConfig,
  pickRunnableConfigKeys: () => pickRunnableConfigKeys,
  raceWithSignal: () => raceWithSignal
});
var BaseLLMOutputParser = class extends Runnable {
  /**
  * Parses the result of an LLM call with a given prompt. By default, it
  * simply calls `parseResult`.
  * @param generations The generations from an LLM call.
  * @param _prompt The prompt used in the LLM call.
  * @param callbacks Optional callbacks.
  * @returns A promise of the parsed output.
  */
  parseResultWithPrompt(generations, _prompt, callbacks) {
    return this.parseResult(generations, callbacks);
  }
  _baseMessageToString(message) {
    return typeof message.content === "string" ? message.content : this._baseMessageContentToString(message.content);
  }
  _baseMessageContentToString(content) {
    return JSON.stringify(content);
  }
  /**
  * Calls the parser with a given input and optional configuration options.
  * If the input is a string, it creates a generation with the input as
  * text and calls `parseResult`. If the input is a `BaseMessage`, it
  * creates a generation with the input as a message and the content of the
  * input as text, and then calls `parseResult`.
  * @param input The input to the parser, which can be a string or a `BaseMessage`.
  * @param options Optional configuration options.
  * @returns A promise of the parsed output.
  */
  async invoke(input, options2) {
    if (typeof input === "string") return this._callWithConfig(async (input$1, options$1) => this.parseResult([{ text: input$1 }], options$1 == null ? void 0 : options$1.callbacks), input, {
      ...options2,
      runType: "parser"
    });
    else return this._callWithConfig(async (input$1, options$1) => this.parseResult([{
      message: input$1,
      text: this._baseMessageToString(input$1)
    }], options$1 == null ? void 0 : options$1.callbacks), input, {
      ...options2,
      runType: "parser"
    });
  }
};
var BaseOutputParser = class extends BaseLLMOutputParser {
  parseResult(generations, callbacks) {
    return this.parse(generations[0].text, callbacks);
  }
  async parseWithPrompt(text, _prompt, callbacks) {
    return this.parse(text, callbacks);
  }
  /**
  * Return the string type key uniquely identifying this class of parser
  */
  _type() {
    throw new Error("_type not implemented");
  }
};
var OutputParserException = class extends Error {
  constructor(message, llmOutput, observation, sendToLLM = false) {
    super(message);
    __publicField2(this, "llmOutput");
    __publicField2(this, "observation");
    __publicField2(this, "sendToLLM");
    this.llmOutput = llmOutput;
    this.observation = observation;
    this.sendToLLM = sendToLLM;
    if (sendToLLM) {
      if (observation === void 0 || llmOutput === void 0) throw new Error("Arguments 'observation' & 'llmOutput' are required if 'sendToLlm' is true");
    }
    addLangChainErrorFields(this, "OUTPUT_PARSING_FAILURE");
  }
};
var BaseTransformOutputParser = class extends BaseOutputParser {
  async *_transform(inputGenerator) {
    for await (const chunk of inputGenerator) if (typeof chunk === "string") yield this.parseResult([{ text: chunk }]);
    else yield this.parseResult([{
      message: chunk,
      text: this._baseMessageToString(chunk)
    }]);
  }
  /**
  * Transforms an asynchronous generator of input into an asynchronous
  * generator of parsed output.
  * @param inputGenerator An asynchronous generator of input.
  * @param options A configuration object.
  * @returns An asynchronous generator of parsed output.
  */
  async *transform(inputGenerator, options2) {
    yield* this._transformStreamWithConfig(inputGenerator, this._transform.bind(this), {
      ...options2,
      runType: "parser"
    });
  }
};
var BaseCumulativeTransformOutputParser = class extends BaseTransformOutputParser {
  constructor(fields) {
    super(fields);
    __publicField2(this, "diff", false);
    this.diff = (fields == null ? void 0 : fields.diff) ?? this.diff;
  }
  async *_transform(inputGenerator) {
    let prevParsed;
    let accGen;
    for await (const chunk of inputGenerator) {
      if (typeof chunk !== "string" && typeof chunk.content !== "string") throw new Error("Cannot handle non-string output.");
      let chunkGen;
      if (isBaseMessageChunk(chunk)) {
        if (typeof chunk.content !== "string") throw new Error("Cannot handle non-string message output.");
        chunkGen = new ChatGenerationChunk({
          message: chunk,
          text: chunk.content
        });
      } else if (isBaseMessage(chunk)) {
        if (typeof chunk.content !== "string") throw new Error("Cannot handle non-string message output.");
        chunkGen = new ChatGenerationChunk({
          message: convertToChunk(chunk),
          text: chunk.content
        });
      } else chunkGen = new GenerationChunk({ text: chunk });
      if (accGen === void 0) accGen = chunkGen;
      else accGen = accGen.concat(chunkGen);
      const parsed = await this.parsePartialResult([accGen]);
      if (parsed !== void 0 && parsed !== null && !deepCompareStrict(parsed, prevParsed)) {
        if (this.diff) yield this._diff(prevParsed, parsed);
        else yield parsed;
        prevParsed = parsed;
      }
    }
  }
  getFormatInstructions() {
    return "";
  }
};
var json_patch_exports = {};
__export(json_patch_exports, {
  applyPatch: () => applyPatch,
  compare: () => compare
});
var JsonOutputParser = class extends BaseCumulativeTransformOutputParser {
  constructor() {
    super(...arguments);
    __publicField2(this, "lc_namespace", ["langchain_core", "output_parsers"]);
    __publicField2(this, "lc_serializable", true);
  }
  static lc_name() {
    return "JsonOutputParser";
  }
  /** @internal */
  _concatOutputChunks(first, second) {
    if (this.diff) return super._concatOutputChunks(first, second);
    return second;
  }
  _diff(prev, next) {
    if (!next) return void 0;
    if (!prev) return [{
      op: "replace",
      path: "",
      value: next
    }];
    return compare(prev, next);
  }
  async parsePartialResult(generations) {
    return parseJsonMarkdown(generations[0].text);
  }
  async parse(text) {
    return parseJsonMarkdown(text, JSON.parse);
  }
  getFormatInstructions() {
    return "";
  }
};
var BytesOutputParser = class extends BaseTransformOutputParser {
  constructor() {
    super(...arguments);
    __publicField2(this, "lc_namespace", [
      "langchain_core",
      "output_parsers",
      "bytes"
    ]);
    __publicField2(this, "lc_serializable", true);
    __publicField2(this, "textEncoder", new TextEncoder());
  }
  static lc_name() {
    return "BytesOutputParser";
  }
  parse(text) {
    return Promise.resolve(this.textEncoder.encode(text));
  }
  getFormatInstructions() {
    return "";
  }
};
var ListOutputParser = class extends BaseTransformOutputParser {
  constructor() {
    super(...arguments);
    __publicField2(this, "re");
  }
  async *_transform(inputGenerator) {
    let buffer = "";
    for await (const input of inputGenerator) {
      if (typeof input === "string") buffer += input;
      else buffer += input.content;
      if (!this.re) {
        const parts = await this.parse(buffer);
        if (parts.length > 1) {
          for (const part of parts.slice(0, -1)) yield [part];
          buffer = parts[parts.length - 1];
        }
      } else {
        const matches = [...buffer.matchAll(this.re)];
        if (matches.length > 1) {
          let doneIdx = 0;
          for (const match of matches.slice(0, -1)) {
            yield [match[1]];
            doneIdx += (match.index ?? 0) + match[0].length;
          }
          buffer = buffer.slice(doneIdx);
        }
      }
    }
    for (const part of await this.parse(buffer)) yield [part];
  }
};
var CommaSeparatedListOutputParser = class extends ListOutputParser {
  constructor() {
    super(...arguments);
    __publicField2(this, "lc_namespace", [
      "langchain_core",
      "output_parsers",
      "list"
    ]);
    __publicField2(this, "lc_serializable", true);
  }
  static lc_name() {
    return "CommaSeparatedListOutputParser";
  }
  /**
  * Parses the given text into an array of strings, using a comma as the
  * separator. If the parsing fails, throws an OutputParserException.
  * @param text The text to parse.
  * @returns An array of strings obtained by splitting the input text at each comma.
  */
  async parse(text) {
    try {
      return text.trim().split(",").map((s) => s.trim());
    } catch {
      throw new OutputParserException(`Could not parse output: ${text}`, text);
    }
  }
  /**
  * Provides instructions on the expected format of the response for the
  * CommaSeparatedListOutputParser.
  * @returns A string containing instructions on the expected format of the response.
  */
  getFormatInstructions() {
    return `Your response should be a list of comma separated values, eg: \`foo, bar, baz\``;
  }
};
var CustomListOutputParser = class extends ListOutputParser {
  constructor({ length, separator }) {
    super(...arguments);
    __publicField2(this, "lc_namespace", [
      "langchain_core",
      "output_parsers",
      "list"
    ]);
    __publicField2(this, "length");
    __publicField2(this, "separator");
    this.length = length;
    this.separator = separator || ",";
  }
  /**
  * Parses the given text into an array of strings, using the specified
  * separator. If the parsing fails or the number of items in the list
  * doesn't match the expected length, throws an OutputParserException.
  * @param text The text to parse.
  * @returns An array of strings obtained by splitting the input text at each occurrence of the specified separator.
  */
  async parse(text) {
    try {
      const items = text.trim().split(this.separator).map((s) => s.trim());
      if (this.length !== void 0 && items.length !== this.length) throw new OutputParserException(`Incorrect number of items. Expected ${this.length}, got ${items.length}.`);
      return items;
    } catch (e) {
      if (Object.getPrototypeOf(e) === OutputParserException.prototype) throw e;
      throw new OutputParserException(`Could not parse output: ${text}`);
    }
  }
  /**
  * Provides instructions on the expected format of the response for the
  * CustomListOutputParser, including the number of items and the
  * separator.
  * @returns A string containing instructions on the expected format of the response.
  */
  getFormatInstructions() {
    return `Your response should be a list of ${this.length === void 0 ? "" : `${this.length} `}items separated by "${this.separator}" (eg: \`foo${this.separator} bar${this.separator} baz\`)`;
  }
};
var NumberedListOutputParser = class extends ListOutputParser {
  constructor() {
    super(...arguments);
    __publicField2(this, "lc_namespace", [
      "langchain_core",
      "output_parsers",
      "list"
    ]);
    __publicField2(this, "lc_serializable", true);
    __publicField2(this, "re", /\d+\.\s([^\n]+)/g);
  }
  static lc_name() {
    return "NumberedListOutputParser";
  }
  getFormatInstructions() {
    return `Your response should be a numbered list with each item on a new line. For example: 

1. foo

2. bar

3. baz`;
  }
  async parse(text) {
    return [...text.matchAll(this.re) ?? []].map((m) => m[1]);
  }
};
var MarkdownListOutputParser = class extends ListOutputParser {
  constructor() {
    super(...arguments);
    __publicField2(this, "lc_namespace", [
      "langchain_core",
      "output_parsers",
      "list"
    ]);
    __publicField2(this, "lc_serializable", true);
    __publicField2(this, "re", /^\s*[-*]\s([^\n]+)$/gm);
  }
  static lc_name() {
    return "NumberedListOutputParser";
  }
  getFormatInstructions() {
    return `Your response should be a numbered list with each item on a new line. For example: 

1. foo

2. bar

3. baz`;
  }
  async parse(text) {
    return [...text.matchAll(this.re) ?? []].map((m) => m[1]);
  }
};
var StringOutputParser = class extends BaseTransformOutputParser {
  constructor() {
    super(...arguments);
    __publicField2(this, "lc_namespace", [
      "langchain_core",
      "output_parsers",
      "string"
    ]);
    __publicField2(this, "lc_serializable", true);
  }
  static lc_name() {
    return "StrOutputParser";
  }
  /**
  * Parses a string output from an LLM call. This method is meant to be
  * implemented by subclasses to define how a string output from an LLM
  * should be parsed.
  * @param text The string output from an LLM call.
  * @param callbacks Optional callbacks.
  * @returns A promise of the parsed output.
  */
  parse(text) {
    return Promise.resolve(text);
  }
  getFormatInstructions() {
    return "";
  }
  _textContentToString(content) {
    return content.text;
  }
  _imageUrlContentToString(_content) {
    throw new Error(`Cannot coerce a multimodal "image_url" message part into a string.`);
  }
  _messageContentToString(content) {
    switch (content.type) {
      case "text":
      case "text_delta":
        if ("text" in content) return this._textContentToString(content);
        break;
      case "image_url":
        if ("image_url" in content) return this._imageUrlContentToString(content);
        break;
      default:
        throw new Error(`Cannot coerce "${content.type}" message part into a string.`);
    }
    throw new Error(`Invalid content type: ${content.type}`);
  }
  _baseMessageContentToString(content) {
    return content.reduce((acc, item) => acc + this._messageContentToString(item), "");
  }
};
var StructuredOutputParser = class extends BaseOutputParser {
  constructor(schema) {
    super(schema);
    __publicField2(this, "lc_namespace", [
      "langchain",
      "output_parsers",
      "structured"
    ]);
    this.schema = schema;
  }
  static lc_name() {
    return "StructuredOutputParser";
  }
  toJSON() {
    return this.toJSONNotImplemented();
  }
  /**
  * Creates a new StructuredOutputParser from a Zod schema.
  * @param schema The Zod schema which the output should match
  * @returns A new instance of StructuredOutputParser.
  */
  static fromZodSchema(schema) {
    return new this(schema);
  }
  /**
  * Creates a new StructuredOutputParser from a set of names and
  * descriptions.
  * @param schemas An object where each key is a name and each value is a description
  * @returns A new instance of StructuredOutputParser.
  */
  static fromNamesAndDescriptions(schemas) {
    const zodSchema = objectType(Object.fromEntries(Object.entries(schemas).map(([name, description]) => [name, stringType().describe(description)])));
    return new this(zodSchema);
  }
  /**
  * Returns a markdown code snippet with a JSON object formatted according
  * to the schema.
  * @param options Optional. The options for formatting the instructions
  * @returns A markdown code snippet with a JSON object formatted according to the schema.
  */
  getFormatInstructions() {
    return `You must format your output as a JSON value that adheres to a given "JSON Schema" instance.

"JSON Schema" is a declarative language that allows you to annotate and validate JSON documents.

For example, the example "JSON Schema" instance {{"properties": {{"foo": {{"description": "a list of test words", "type": "array", "items": {{"type": "string"}}}}}}, "required": ["foo"]}}
would match an object with one required property, "foo". The "type" property specifies "foo" must be an "array", and the "description" property semantically describes it as "a list of test words". The items within "foo" must be strings.
Thus, the object {{"foo": ["bar", "baz"]}} is a well-formatted instance of this example "JSON Schema". The object {{"properties": {{"foo": ["bar", "baz"]}}}} is not well-formatted.

Your output will be parsed and type-checked according to the provided schema instance, so make sure all fields in your output match the schema exactly and there are no trailing commas!

Here is the JSON Schema instance your output must adhere to. Include the enclosing markdown codeblock:
\`\`\`json
${JSON.stringify(toJsonSchema(this.schema))}
\`\`\`
`;
  }
  /**
  * Parses the given text according to the schema.
  * @param text The text to parse
  * @returns The parsed output.
  */
  async parse(text) {
    var _a3, _b;
    try {
      const trimmedText = text.trim();
      const json = ((_a3 = trimmedText.match(/^```(?:json)?\s*([\s\S]*?)```/)) == null ? void 0 : _a3[1]) || ((_b = trimmedText.match(/```json\s*([\s\S]*?)```/)) == null ? void 0 : _b[1]) || trimmedText;
      const escapedJson = json.replace(/"([^"\\]*(\\.[^"\\]*)*)"/g, (_match, capturedGroup) => {
        const escapedInsideQuotes = capturedGroup.replace(/\n/g, "\\n");
        return `"${escapedInsideQuotes}"`;
      }).replace(/\n/g, "");
      return await interopParseAsync(this.schema, JSON.parse(escapedJson));
    } catch (e) {
      throw new OutputParserException(`Failed to parse. Text: "${text}". Error: ${e}`, text);
    }
  }
};
var JsonMarkdownStructuredOutputParser = class extends StructuredOutputParser {
  static lc_name() {
    return "JsonMarkdownStructuredOutputParser";
  }
  getFormatInstructions(options2) {
    const interpolationDepth = (options2 == null ? void 0 : options2.interpolationDepth) ?? 1;
    if (interpolationDepth < 1) throw new Error("f string interpolation depth must be at least 1");
    return `Return a markdown code snippet with a JSON object formatted to look like:
\`\`\`json
${this._schemaToInstruction(toJsonSchema(this.schema)).replaceAll("{", "{".repeat(interpolationDepth)).replaceAll("}", "}".repeat(interpolationDepth))}
\`\`\``;
  }
  _schemaToInstruction(schemaInput, indent = 2) {
    const schema = schemaInput;
    if ("type" in schema) {
      let nullable2 = false;
      let type;
      if (Array.isArray(schema.type)) {
        const nullIdx = schema.type.findIndex((type$1) => type$1 === "null");
        if (nullIdx !== -1) {
          nullable2 = true;
          schema.type.splice(nullIdx, 1);
        }
        type = schema.type.join(" | ");
      } else type = schema.type;
      if (schema.type === "object" && schema.properties) {
        const description$1 = schema.description ? ` // ${schema.description}` : "";
        const properties = Object.entries(schema.properties).map(([key, value]) => {
          var _a3;
          const isOptional = ((_a3 = schema.required) == null ? void 0 : _a3.includes(key)) ? "" : " (optional)";
          return `${" ".repeat(indent)}"${key}": ${this._schemaToInstruction(value, indent + 2)}${isOptional}`;
        }).join("\n");
        return `{
${properties}
${" ".repeat(indent - 2)}}${description$1}`;
      }
      if (schema.type === "array" && schema.items) {
        const description$1 = schema.description ? ` // ${schema.description}` : "";
        return `array[
${" ".repeat(indent)}${this._schemaToInstruction(schema.items, indent + 2)}
${" ".repeat(indent - 2)}] ${description$1}`;
      }
      const isNullable2 = nullable2 ? " (nullable)" : "";
      const description = schema.description ? ` // ${schema.description}` : "";
      return `${type}${description}${isNullable2}`;
    }
    if ("anyOf" in schema) return schema.anyOf.map((s) => this._schemaToInstruction(s, indent)).join(`
${" ".repeat(indent - 2)}`);
    throw new Error("unsupported schema type");
  }
  static fromZodSchema(schema) {
    return new this(schema);
  }
  static fromNamesAndDescriptions(schemas) {
    const zodSchema = objectType(Object.fromEntries(Object.entries(schemas).map(([name, description]) => [name, stringType().describe(description)])));
    return new this(zodSchema);
  }
};
var AsymmetricStructuredOutputParser = class extends BaseOutputParser {
  constructor({ inputSchema }) {
    super(...arguments);
    __publicField2(this, "structuredInputParser");
    this.structuredInputParser = new JsonMarkdownStructuredOutputParser(inputSchema);
  }
  async parse(text) {
    let parsedInput;
    try {
      parsedInput = await this.structuredInputParser.parse(text);
    } catch (e) {
      throw new OutputParserException(`Failed to parse. Text: "${text}". Error: ${e}`, text);
    }
    return this.outputProcessor(parsedInput);
  }
  getFormatInstructions() {
    return this.structuredInputParser.getFormatInstructions();
  }
};
const initializeSax = function() {
  const sax$1 = {};
  sax$1.parser = function(strict, opt) {
    return new SAXParser(strict, opt);
  };
  sax$1.SAXParser = SAXParser;
  sax$1.SAXStream = SAXStream;
  sax$1.createStream = createStream;
  sax$1.MAX_BUFFER_LENGTH = 64 * 1024;
  const buffers = [
    "comment",
    "sgmlDecl",
    "textNode",
    "tagName",
    "doctype",
    "procInstName",
    "procInstBody",
    "entity",
    "attribName",
    "attribValue",
    "cdata",
    "script"
  ];
  sax$1.EVENTS = [
    "text",
    "processinginstruction",
    "sgmldeclaration",
    "doctype",
    "comment",
    "opentagstart",
    "attribute",
    "opentag",
    "closetag",
    "opencdata",
    "cdata",
    "closecdata",
    "error",
    "end",
    "ready",
    "script",
    "opennamespace",
    "closenamespace"
  ];
  function SAXParser(strict, opt) {
    if (!(this instanceof SAXParser)) return new SAXParser(strict, opt);
    var parser = this;
    clearBuffers(parser);
    parser.q = parser.c = "";
    parser.bufferCheckPosition = sax$1.MAX_BUFFER_LENGTH;
    parser.opt = opt || {};
    parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags;
    parser.looseCase = parser.opt.lowercase ? "toLowerCase" : "toUpperCase";
    parser.tags = [];
    parser.closed = parser.closedRoot = parser.sawRoot = false;
    parser.tag = parser.error = null;
    parser.strict = !!strict;
    parser.noscript = !!(strict || parser.opt.noscript);
    parser.state = S.BEGIN;
    parser.strictEntities = parser.opt.strictEntities;
    parser.ENTITIES = parser.strictEntities ? Object.create(sax$1.XML_ENTITIES) : Object.create(sax$1.ENTITIES);
    parser.attribList = [];
    if (parser.opt.xmlns) parser.ns = Object.create(rootNS);
    parser.trackPosition = parser.opt.position !== false;
    if (parser.trackPosition) parser.position = parser.line = parser.column = 0;
    emit(parser, "onready");
  }
  if (!Object.create) Object.create = function(o) {
    function F() {
    }
    F.prototype = o;
    var newf = new F();
    return newf;
  };
  if (!Object.keys) Object.keys = function(o) {
    var a = [];
    for (var i2 in o) if (o.hasOwnProperty(i2)) a.push(i2);
    return a;
  };
  function checkBufferLength(parser) {
    var maxAllowed = Math.max(sax$1.MAX_BUFFER_LENGTH, 10);
    var maxActual = 0;
    for (var i2 = 0, l = buffers.length; i2 < l; i2++) {
      var len2 = parser[buffers[i2]].length;
      if (len2 > maxAllowed) switch (buffers[i2]) {
        case "textNode":
          closeText(parser);
          break;
        case "cdata":
          emitNode(parser, "oncdata", parser.cdata);
          parser.cdata = "";
          break;
        case "script":
          emitNode(parser, "onscript", parser.script);
          parser.script = "";
          break;
        default:
          error(parser, "Max buffer length exceeded: " + buffers[i2]);
      }
      maxActual = Math.max(maxActual, len2);
    }
    var m = sax$1.MAX_BUFFER_LENGTH - maxActual;
    parser.bufferCheckPosition = m + parser.position;
  }
  function clearBuffers(parser) {
    for (var i2 = 0, l = buffers.length; i2 < l; i2++) parser[buffers[i2]] = "";
  }
  function flushBuffers(parser) {
    closeText(parser);
    if (parser.cdata !== "") {
      emitNode(parser, "oncdata", parser.cdata);
      parser.cdata = "";
    }
    if (parser.script !== "") {
      emitNode(parser, "onscript", parser.script);
      parser.script = "";
    }
  }
  SAXParser.prototype = {
    end: function() {
      end(this);
    },
    write,
    resume: function() {
      this.error = null;
      return this;
    },
    close: function() {
      return this.write(null);
    },
    flush: function() {
      flushBuffers(this);
    }
  };
  var Stream2 = ReadableStream;
  if (!Stream2) Stream2 = function() {
  };
  var streamWraps = sax$1.EVENTS.filter(function(ev) {
    return ev !== "error" && ev !== "end";
  });
  function createStream(strict, opt) {
    return new SAXStream(strict, opt);
  }
  function SAXStream(strict, opt) {
    if (!(this instanceof SAXStream)) return new SAXStream(strict, opt);
    Stream2.apply(this);
    this._parser = new SAXParser(strict, opt);
    this.writable = true;
    this.readable = true;
    var me = this;
    this._parser.onend = function() {
      me.emit("end");
    };
    this._parser.onerror = function(er) {
      me.emit("error", er);
      me._parser.error = null;
    };
    this._decoder = null;
    streamWraps.forEach(function(ev) {
      Object.defineProperty(me, "on" + ev, {
        get: function() {
          return me._parser["on" + ev];
        },
        set: function(h) {
          if (!h) {
            me.removeAllListeners(ev);
            me._parser["on" + ev] = h;
            return h;
          }
          me.on(ev, h);
        },
        enumerable: true,
        configurable: false
      });
    });
  }
  SAXStream.prototype = Object.create(Stream2.prototype, { constructor: { value: SAXStream } });
  SAXStream.prototype.write = function(data) {
    this._parser.write(data.toString());
    this.emit("data", data);
    return true;
  };
  SAXStream.prototype.end = function(chunk) {
    if (chunk && chunk.length) this.write(chunk);
    this._parser.end();
    return true;
  };
  SAXStream.prototype.on = function(ev, handler) {
    var me = this;
    if (!me._parser["on" + ev] && streamWraps.indexOf(ev) !== -1) me._parser["on" + ev] = function() {
      var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments);
      args.splice(0, 0, ev);
      me.emit.apply(me, args);
    };
    return Stream2.prototype.on.call(me, ev, handler);
  };
  var CDATA = "[CDATA[";
  var DOCTYPE = "DOCTYPE";
  var XML_NAMESPACE = "http://www.w3.org/XML/1998/namespace";
  var XMLNS_NAMESPACE = "http://www.w3.org/2000/xmlns/";
  var rootNS = {
    xml: XML_NAMESPACE,
    xmlns: XMLNS_NAMESPACE
  };
  var nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
  var nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
  var entityStart = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
  var entityBody = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
  function isWhitespace(c) {
    return c === " " || c === "\n" || c === "\r" || c === "	";
  }
  function isQuote(c) {
    return c === '"' || c === "'";
  }
  function isAttribEnd(c) {
    return c === ">" || isWhitespace(c);
  }
  function isMatch(regex2, c) {
    return regex2.test(c);
  }
  function notMatch(regex2, c) {
    return !isMatch(regex2, c);
  }
  var S = 0;
  sax$1.STATE = {
    BEGIN: S++,
    BEGIN_WHITESPACE: S++,
    TEXT: S++,
    TEXT_ENTITY: S++,
    OPEN_WAKA: S++,
    SGML_DECL: S++,
    SGML_DECL_QUOTED: S++,
    DOCTYPE: S++,
    DOCTYPE_QUOTED: S++,
    DOCTYPE_DTD: S++,
    DOCTYPE_DTD_QUOTED: S++,
    COMMENT_STARTING: S++,
    COMMENT: S++,
    COMMENT_ENDING: S++,
    COMMENT_ENDED: S++,
    CDATA: S++,
    CDATA_ENDING: S++,
    CDATA_ENDING_2: S++,
    PROC_INST: S++,
    PROC_INST_BODY: S++,
    PROC_INST_ENDING: S++,
    OPEN_TAG: S++,
    OPEN_TAG_SLASH: S++,
    ATTRIB: S++,
    ATTRIB_NAME: S++,
    ATTRIB_NAME_SAW_WHITE: S++,
    ATTRIB_VALUE: S++,
    ATTRIB_VALUE_QUOTED: S++,
    ATTRIB_VALUE_CLOSED: S++,
    ATTRIB_VALUE_UNQUOTED: S++,
    ATTRIB_VALUE_ENTITY_Q: S++,
    ATTRIB_VALUE_ENTITY_U: S++,
    CLOSE_TAG: S++,
    CLOSE_TAG_SAW_WHITE: S++,
    SCRIPT: S++,
    SCRIPT_ENDING: S++
  };
  sax$1.XML_ENTITIES = {
    amp: "&",
    gt: ">",
    lt: "<",
    quot: '"',
    apos: "'"
  };
  sax$1.ENTITIES = {
    amp: "&",
    gt: ">",
    lt: "<",
    quot: '"',
    apos: "'",
    AElig: 198,
    Aacute: 193,
    Acirc: 194,
    Agrave: 192,
    Aring: 197,
    Atilde: 195,
    Auml: 196,
    Ccedil: 199,
    ETH: 208,
    Eacute: 201,
    Ecirc: 202,
    Egrave: 200,
    Euml: 203,
    Iacute: 205,
    Icirc: 206,
    Igrave: 204,
    Iuml: 207,
    Ntilde: 209,
    Oacute: 211,
    Ocirc: 212,
    Ograve: 210,
    Oslash: 216,
    Otilde: 213,
    Ouml: 214,
    THORN: 222,
    Uacute: 218,
    Ucirc: 219,
    Ugrave: 217,
    Uuml: 220,
    Yacute: 221,
    aacute: 225,
    acirc: 226,
    aelig: 230,
    agrave: 224,
    aring: 229,
    atilde: 227,
    auml: 228,
    ccedil: 231,
    eacute: 233,
    ecirc: 234,
    egrave: 232,
    eth: 240,
    euml: 235,
    iacute: 237,
    icirc: 238,
    igrave: 236,
    iuml: 239,
    ntilde: 241,
    oacute: 243,
    ocirc: 244,
    ograve: 242,
    oslash: 248,
    otilde: 245,
    ouml: 246,
    szlig: 223,
    thorn: 254,
    uacute: 250,
    ucirc: 251,
    ugrave: 249,
    uuml: 252,
    yacute: 253,
    yuml: 255,
    copy: 169,
    reg: 174,
    nbsp: 160,
    iexcl: 161,
    cent: 162,
    pound: 163,
    curren: 164,
    yen: 165,
    brvbar: 166,
    sect: 167,
    uml: 168,
    ordf: 170,
    laquo: 171,
    not: 172,
    shy: 173,
    macr: 175,
    deg: 176,
    plusmn: 177,
    sup1: 185,
    sup2: 178,
    sup3: 179,
    acute: 180,
    micro: 181,
    para: 182,
    middot: 183,
    cedil: 184,
    ordm: 186,
    raquo: 187,
    frac14: 188,
    frac12: 189,
    frac34: 190,
    iquest: 191,
    times: 215,
    divide: 247,
    OElig: 338,
    oelig: 339,
    Scaron: 352,
    scaron: 353,
    Yuml: 376,
    fnof: 402,
    circ: 710,
    tilde: 732,
    Alpha: 913,
    Beta: 914,
    Gamma: 915,
    Delta: 916,
    Epsilon: 917,
    Zeta: 918,
    Eta: 919,
    Theta: 920,
    Iota: 921,
    Kappa: 922,
    Lambda: 923,
    Mu: 924,
    Nu: 925,
    Xi: 926,
    Omicron: 927,
    Pi: 928,
    Rho: 929,
    Sigma: 931,
    Tau: 932,
    Upsilon: 933,
    Phi: 934,
    Chi: 935,
    Psi: 936,
    Omega: 937,
    alpha: 945,
    beta: 946,
    gamma: 947,
    delta: 948,
    epsilon: 949,
    zeta: 950,
    eta: 951,
    theta: 952,
    iota: 953,
    kappa: 954,
    lambda: 955,
    mu: 956,
    nu: 957,
    xi: 958,
    omicron: 959,
    pi: 960,
    rho: 961,
    sigmaf: 962,
    sigma: 963,
    tau: 964,
    upsilon: 965,
    phi: 966,
    chi: 967,
    psi: 968,
    omega: 969,
    thetasym: 977,
    upsih: 978,
    piv: 982,
    ensp: 8194,
    emsp: 8195,
    thinsp: 8201,
    zwnj: 8204,
    zwj: 8205,
    lrm: 8206,
    rlm: 8207,
    ndash: 8211,
    mdash: 8212,
    lsquo: 8216,
    rsquo: 8217,
    sbquo: 8218,
    ldquo: 8220,
    rdquo: 8221,
    bdquo: 8222,
    dagger: 8224,
    Dagger: 8225,
    bull: 8226,
    hellip: 8230,
    permil: 8240,
    prime: 8242,
    Prime: 8243,
    lsaquo: 8249,
    rsaquo: 8250,
    oline: 8254,
    frasl: 8260,
    euro: 8364,
    image: 8465,
    weierp: 8472,
    real: 8476,
    trade: 8482,
    alefsym: 8501,
    larr: 8592,
    uarr: 8593,
    rarr: 8594,
    darr: 8595,
    harr: 8596,
    crarr: 8629,
    lArr: 8656,
    uArr: 8657,
    rArr: 8658,
    dArr: 8659,
    hArr: 8660,
    forall: 8704,
    part: 8706,
    exist: 8707,
    empty: 8709,
    nabla: 8711,
    isin: 8712,
    notin: 8713,
    ni: 8715,
    prod: 8719,
    sum: 8721,
    minus: 8722,
    lowast: 8727,
    radic: 8730,
    prop: 8733,
    infin: 8734,
    ang: 8736,
    and: 8743,
    or: 8744,
    cap: 8745,
    cup: 8746,
    int: 8747,
    there4: 8756,
    sim: 8764,
    cong: 8773,
    asymp: 8776,
    ne: 8800,
    equiv: 8801,
    le: 8804,
    ge: 8805,
    sub: 8834,
    sup: 8835,
    nsub: 8836,
    sube: 8838,
    supe: 8839,
    oplus: 8853,
    otimes: 8855,
    perp: 8869,
    sdot: 8901,
    lceil: 8968,
    rceil: 8969,
    lfloor: 8970,
    rfloor: 8971,
    lang: 9001,
    rang: 9002,
    loz: 9674,
    spades: 9824,
    clubs: 9827,
    hearts: 9829,
    diams: 9830
  };
  Object.keys(sax$1.ENTITIES).forEach(function(key) {
    var e = sax$1.ENTITIES[key];
    var s$1 = typeof e === "number" ? String.fromCharCode(e) : e;
    sax$1.ENTITIES[key] = s$1;
  });
  for (var s in sax$1.STATE) sax$1.STATE[sax$1.STATE[s]] = s;
  S = sax$1.STATE;
  function emit(parser, event, data) {
    parser[event] && parser[event](data);
  }
  function emitNode(parser, nodeType, data) {
    if (parser.textNode) closeText(parser);
    emit(parser, nodeType, data);
  }
  function closeText(parser) {
    parser.textNode = textopts(parser.opt, parser.textNode);
    if (parser.textNode) emit(parser, "ontext", parser.textNode);
    parser.textNode = "";
  }
  function textopts(opt, text) {
    if (opt.trim) text = text.trim();
    if (opt.normalize) text = text.replace(/\s+/g, " ");
    return text;
  }
  function error(parser, er) {
    closeText(parser);
    if (parser.trackPosition) er += "\nLine: " + parser.line + "\nColumn: " + parser.column + "\nChar: " + parser.c;
    er = new Error(er);
    parser.error = er;
    emit(parser, "onerror", er);
    return parser;
  }
  function end(parser) {
    if (parser.sawRoot && !parser.closedRoot) strictFail(parser, "Unclosed root tag");
    if (parser.state !== S.BEGIN && parser.state !== S.BEGIN_WHITESPACE && parser.state !== S.TEXT) error(parser, "Unexpected end");
    closeText(parser);
    parser.c = "";
    parser.closed = true;
    emit(parser, "onend");
    SAXParser.call(parser, parser.strict, parser.opt);
    return parser;
  }
  function strictFail(parser, message) {
    if (typeof parser !== "object" || !(parser instanceof SAXParser)) throw new Error("bad call to strictFail");
    if (parser.strict) error(parser, message);
  }
  function newTag(parser) {
    if (!parser.strict) parser.tagName = parser.tagName[parser.looseCase]();
    var parent = parser.tags[parser.tags.length - 1] || parser;
    var tag = parser.tag = {
      name: parser.tagName,
      attributes: {}
    };
    if (parser.opt.xmlns) tag.ns = parent.ns;
    parser.attribList.length = 0;
    emitNode(parser, "onopentagstart", tag);
  }
  function qname(name, attribute) {
    var i2 = name.indexOf(":");
    var qualName = i2 < 0 ? ["", name] : name.split(":");
    var prefix = qualName[0];
    var local = qualName[1];
    if (attribute && name === "xmlns") {
      prefix = "xmlns";
      local = "";
    }
    return {
      prefix,
      local
    };
  }
  function attrib(parser) {
    if (!parser.strict) parser.attribName = parser.attribName[parser.looseCase]();
    if (parser.attribList.indexOf(parser.attribName) !== -1 || parser.tag.attributes.hasOwnProperty(parser.attribName)) {
      parser.attribName = parser.attribValue = "";
      return;
    }
    if (parser.opt.xmlns) {
      var qn = qname(parser.attribName, true);
      var prefix = qn.prefix;
      var local = qn.local;
      if (prefix === "xmlns") if (local === "xml" && parser.attribValue !== XML_NAMESPACE) strictFail(parser, "xml: prefix must be bound to " + XML_NAMESPACE + "\nActual: " + parser.attribValue);
      else if (local === "xmlns" && parser.attribValue !== XMLNS_NAMESPACE) strictFail(parser, "xmlns: prefix must be bound to " + XMLNS_NAMESPACE + "\nActual: " + parser.attribValue);
      else {
        var tag = parser.tag;
        var parent = parser.tags[parser.tags.length - 1] || parser;
        if (tag.ns === parent.ns) tag.ns = Object.create(parent.ns);
        tag.ns[local] = parser.attribValue;
      }
      parser.attribList.push([parser.attribName, parser.attribValue]);
    } else {
      parser.tag.attributes[parser.attribName] = parser.attribValue;
      emitNode(parser, "onattribute", {
        name: parser.attribName,
        value: parser.attribValue
      });
    }
    parser.attribName = parser.attribValue = "";
  }
  function openTag(parser, selfClosing) {
    if (parser.opt.xmlns) {
      var tag = parser.tag;
      var qn = qname(parser.tagName);
      tag.prefix = qn.prefix;
      tag.local = qn.local;
      tag.uri = tag.ns[qn.prefix] || "";
      if (tag.prefix && !tag.uri) {
        strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(parser.tagName));
        tag.uri = qn.prefix;
      }
      var parent = parser.tags[parser.tags.length - 1] || parser;
      if (tag.ns && parent.ns !== tag.ns) Object.keys(tag.ns).forEach(function(p) {
        emitNode(parser, "onopennamespace", {
          prefix: p,
          uri: tag.ns[p]
        });
      });
      for (var i2 = 0, l = parser.attribList.length; i2 < l; i2++) {
        var nv = parser.attribList[i2];
        var name = nv[0];
        var value = nv[1];
        var qualName = qname(name, true);
        var prefix = qualName.prefix;
        var local = qualName.local;
        var uri2 = prefix === "" ? "" : tag.ns[prefix] || "";
        var a = {
          name,
          value,
          prefix,
          local,
          uri: uri2
        };
        if (prefix && prefix !== "xmlns" && !uri2) {
          strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(prefix));
          a.uri = prefix;
        }
        parser.tag.attributes[name] = a;
        emitNode(parser, "onattribute", a);
      }
      parser.attribList.length = 0;
    }
    parser.tag.isSelfClosing = !!selfClosing;
    parser.sawRoot = true;
    parser.tags.push(parser.tag);
    emitNode(parser, "onopentag", parser.tag);
    if (!selfClosing) {
      if (!parser.noscript && parser.tagName.toLowerCase() === "script") parser.state = S.SCRIPT;
      else parser.state = S.TEXT;
      parser.tag = null;
      parser.tagName = "";
    }
    parser.attribName = parser.attribValue = "";
    parser.attribList.length = 0;
  }
  function closeTag(parser) {
    if (!parser.tagName) {
      strictFail(parser, "Weird empty close tag.");
      parser.textNode += "</>";
      parser.state = S.TEXT;
      return;
    }
    if (parser.script) {
      if (parser.tagName !== "script") {
        parser.script += "</" + parser.tagName + ">";
        parser.tagName = "";
        parser.state = S.SCRIPT;
        return;
      }
      emitNode(parser, "onscript", parser.script);
      parser.script = "";
    }
    var t2 = parser.tags.length;
    var tagName = parser.tagName;
    if (!parser.strict) tagName = tagName[parser.looseCase]();
    var closeTo = tagName;
    while (t2--) {
      var close = parser.tags[t2];
      if (close.name !== closeTo) strictFail(parser, "Unexpected close tag");
      else break;
    }
    if (t2 < 0) {
      strictFail(parser, "Unmatched closing tag: " + parser.tagName);
      parser.textNode += "</" + parser.tagName + ">";
      parser.state = S.TEXT;
      return;
    }
    parser.tagName = tagName;
    var s$1 = parser.tags.length;
    while (s$1-- > t2) {
      var tag = parser.tag = parser.tags.pop();
      parser.tagName = parser.tag.name;
      emitNode(parser, "onclosetag", parser.tagName);
      var x = {};
      for (var i2 in tag.ns) x[i2] = tag.ns[i2];
      var parent = parser.tags[parser.tags.length - 1] || parser;
      if (parser.opt.xmlns && tag.ns !== parent.ns) Object.keys(tag.ns).forEach(function(p) {
        var n = tag.ns[p];
        emitNode(parser, "onclosenamespace", {
          prefix: p,
          uri: n
        });
      });
    }
    if (t2 === 0) parser.closedRoot = true;
    parser.tagName = parser.attribValue = parser.attribName = "";
    parser.attribList.length = 0;
    parser.state = S.TEXT;
  }
  function parseEntity(parser) {
    var entity = parser.entity;
    var entityLC = entity.toLowerCase();
    var num;
    var numStr = "";
    if (parser.ENTITIES[entity]) return parser.ENTITIES[entity];
    if (parser.ENTITIES[entityLC]) return parser.ENTITIES[entityLC];
    entity = entityLC;
    if (entity.charAt(0) === "#") if (entity.charAt(1) === "x") {
      entity = entity.slice(2);
      num = parseInt(entity, 16);
      numStr = num.toString(16);
    } else {
      entity = entity.slice(1);
      num = parseInt(entity, 10);
      numStr = num.toString(10);
    }
    entity = entity.replace(/^0+/, "");
    if (isNaN(num) || numStr.toLowerCase() !== entity) {
      strictFail(parser, "Invalid character entity");
      return "&" + parser.entity + ";";
    }
    return String.fromCodePoint(num);
  }
  function beginWhiteSpace(parser, c) {
    if (c === "<") {
      parser.state = S.OPEN_WAKA;
      parser.startTagPosition = parser.position;
    } else if (!isWhitespace(c)) {
      strictFail(parser, "Non-whitespace before first tag.");
      parser.textNode = c;
      parser.state = S.TEXT;
    }
  }
  function charAt(chunk, i2) {
    var result = "";
    if (i2 < chunk.length) result = chunk.charAt(i2);
    return result;
  }
  function write(chunk) {
    var parser = this;
    if (this.error) throw this.error;
    if (parser.closed) return error(parser, "Cannot write after close. Assign an onready handler.");
    if (chunk === null) return end(parser);
    if (typeof chunk === "object") chunk = chunk.toString();
    var i2 = 0;
    var c = "";
    while (true) {
      c = charAt(chunk, i2++);
      parser.c = c;
      if (!c) break;
      if (parser.trackPosition) {
        parser.position++;
        if (c === "\n") {
          parser.line++;
          parser.column = 0;
        } else parser.column++;
      }
      switch (parser.state) {
        case S.BEGIN:
          parser.state = S.BEGIN_WHITESPACE;
          if (c === "\uFEFF") continue;
          beginWhiteSpace(parser, c);
          continue;
        case S.BEGIN_WHITESPACE:
          beginWhiteSpace(parser, c);
          continue;
        case S.TEXT:
          if (parser.sawRoot && !parser.closedRoot) {
            var starti = i2 - 1;
            while (c && c !== "<" && c !== "&") {
              c = charAt(chunk, i2++);
              if (c && parser.trackPosition) {
                parser.position++;
                if (c === "\n") {
                  parser.line++;
                  parser.column = 0;
                } else parser.column++;
              }
            }
            parser.textNode += chunk.substring(starti, i2 - 1);
          }
          if (c === "<" && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {
            parser.state = S.OPEN_WAKA;
            parser.startTagPosition = parser.position;
          } else {
            if (!isWhitespace(c) && (!parser.sawRoot || parser.closedRoot)) strictFail(parser, "Text data outside of root node.");
            if (c === "&") parser.state = S.TEXT_ENTITY;
            else parser.textNode += c;
          }
          continue;
        case S.SCRIPT:
          if (c === "<") parser.state = S.SCRIPT_ENDING;
          else parser.script += c;
          continue;
        case S.SCRIPT_ENDING:
          if (c === "/") parser.state = S.CLOSE_TAG;
          else {
            parser.script += "<" + c;
            parser.state = S.SCRIPT;
          }
          continue;
        case S.OPEN_WAKA:
          if (c === "!") {
            parser.state = S.SGML_DECL;
            parser.sgmlDecl = "";
          } else if (isWhitespace(c)) ;
          else if (isMatch(nameStart, c)) {
            parser.state = S.OPEN_TAG;
            parser.tagName = c;
          } else if (c === "/") {
            parser.state = S.CLOSE_TAG;
            parser.tagName = "";
          } else if (c === "?") {
            parser.state = S.PROC_INST;
            parser.procInstName = parser.procInstBody = "";
          } else {
            strictFail(parser, "Unencoded <");
            if (parser.startTagPosition + 1 < parser.position) {
              var pad = parser.position - parser.startTagPosition;
              c = new Array(pad).join(" ") + c;
            }
            parser.textNode += "<" + c;
            parser.state = S.TEXT;
          }
          continue;
        case S.SGML_DECL:
          if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {
            emitNode(parser, "onopencdata");
            parser.state = S.CDATA;
            parser.sgmlDecl = "";
            parser.cdata = "";
          } else if (parser.sgmlDecl + c === "--") {
            parser.state = S.COMMENT;
            parser.comment = "";
            parser.sgmlDecl = "";
          } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {
            parser.state = S.DOCTYPE;
            if (parser.doctype || parser.sawRoot) strictFail(parser, "Inappropriately located doctype declaration");
            parser.doctype = "";
            parser.sgmlDecl = "";
          } else if (c === ">") {
            emitNode(parser, "onsgmldeclaration", parser.sgmlDecl);
            parser.sgmlDecl = "";
            parser.state = S.TEXT;
          } else if (isQuote(c)) {
            parser.state = S.SGML_DECL_QUOTED;
            parser.sgmlDecl += c;
          } else parser.sgmlDecl += c;
          continue;
        case S.SGML_DECL_QUOTED:
          if (c === parser.q) {
            parser.state = S.SGML_DECL;
            parser.q = "";
          }
          parser.sgmlDecl += c;
          continue;
        case S.DOCTYPE:
          if (c === ">") {
            parser.state = S.TEXT;
            emitNode(parser, "ondoctype", parser.doctype);
            parser.doctype = true;
          } else {
            parser.doctype += c;
            if (c === "[") parser.state = S.DOCTYPE_DTD;
            else if (isQuote(c)) {
              parser.state = S.DOCTYPE_QUOTED;
              parser.q = c;
            }
          }
          continue;
        case S.DOCTYPE_QUOTED:
          parser.doctype += c;
          if (c === parser.q) {
            parser.q = "";
            parser.state = S.DOCTYPE;
          }
          continue;
        case S.DOCTYPE_DTD:
          parser.doctype += c;
          if (c === "]") parser.state = S.DOCTYPE;
          else if (isQuote(c)) {
            parser.state = S.DOCTYPE_DTD_QUOTED;
            parser.q = c;
          }
          continue;
        case S.DOCTYPE_DTD_QUOTED:
          parser.doctype += c;
          if (c === parser.q) {
            parser.state = S.DOCTYPE_DTD;
            parser.q = "";
          }
          continue;
        case S.COMMENT:
          if (c === "-") parser.state = S.COMMENT_ENDING;
          else parser.comment += c;
          continue;
        case S.COMMENT_ENDING:
          if (c === "-") {
            parser.state = S.COMMENT_ENDED;
            parser.comment = textopts(parser.opt, parser.comment);
            if (parser.comment) emitNode(parser, "oncomment", parser.comment);
            parser.comment = "";
          } else {
            parser.comment += "-" + c;
            parser.state = S.COMMENT;
          }
          continue;
        case S.COMMENT_ENDED:
          if (c !== ">") {
            strictFail(parser, "Malformed comment");
            parser.comment += "--" + c;
            parser.state = S.COMMENT;
          } else parser.state = S.TEXT;
          continue;
        case S.CDATA:
          if (c === "]") parser.state = S.CDATA_ENDING;
          else parser.cdata += c;
          continue;
        case S.CDATA_ENDING:
          if (c === "]") parser.state = S.CDATA_ENDING_2;
          else {
            parser.cdata += "]" + c;
            parser.state = S.CDATA;
          }
          continue;
        case S.CDATA_ENDING_2:
          if (c === ">") {
            if (parser.cdata) emitNode(parser, "oncdata", parser.cdata);
            emitNode(parser, "onclosecdata");
            parser.cdata = "";
            parser.state = S.TEXT;
          } else if (c === "]") parser.cdata += "]";
          else {
            parser.cdata += "]]" + c;
            parser.state = S.CDATA;
          }
          continue;
        case S.PROC_INST:
          if (c === "?") parser.state = S.PROC_INST_ENDING;
          else if (isWhitespace(c)) parser.state = S.PROC_INST_BODY;
          else parser.procInstName += c;
          continue;
        case S.PROC_INST_BODY:
          if (!parser.procInstBody && isWhitespace(c)) continue;
          else if (c === "?") parser.state = S.PROC_INST_ENDING;
          else parser.procInstBody += c;
          continue;
        case S.PROC_INST_ENDING:
          if (c === ">") {
            emitNode(parser, "onprocessinginstruction", {
              name: parser.procInstName,
              body: parser.procInstBody
            });
            parser.procInstName = parser.procInstBody = "";
            parser.state = S.TEXT;
          } else {
            parser.procInstBody += "?" + c;
            parser.state = S.PROC_INST_BODY;
          }
          continue;
        case S.OPEN_TAG:
          if (isMatch(nameBody, c)) parser.tagName += c;
          else {
            newTag(parser);
            if (c === ">") openTag(parser);
            else if (c === "/") parser.state = S.OPEN_TAG_SLASH;
            else {
              if (!isWhitespace(c)) strictFail(parser, "Invalid character in tag name");
              parser.state = S.ATTRIB;
            }
          }
          continue;
        case S.OPEN_TAG_SLASH:
          if (c === ">") {
            openTag(parser, true);
            closeTag(parser);
          } else {
            strictFail(parser, "Forward-slash in opening tag not followed by >");
            parser.state = S.ATTRIB;
          }
          continue;
        case S.ATTRIB:
          if (isWhitespace(c)) continue;
          else if (c === ">") openTag(parser);
          else if (c === "/") parser.state = S.OPEN_TAG_SLASH;
          else if (isMatch(nameStart, c)) {
            parser.attribName = c;
            parser.attribValue = "";
            parser.state = S.ATTRIB_NAME;
          } else strictFail(parser, "Invalid attribute name");
          continue;
        case S.ATTRIB_NAME:
          if (c === "=") parser.state = S.ATTRIB_VALUE;
          else if (c === ">") {
            strictFail(parser, "Attribute without value");
            parser.attribValue = parser.attribName;
            attrib(parser);
            openTag(parser);
          } else if (isWhitespace(c)) parser.state = S.ATTRIB_NAME_SAW_WHITE;
          else if (isMatch(nameBody, c)) parser.attribName += c;
          else strictFail(parser, "Invalid attribute name");
          continue;
        case S.ATTRIB_NAME_SAW_WHITE:
          if (c === "=") parser.state = S.ATTRIB_VALUE;
          else if (isWhitespace(c)) continue;
          else {
            strictFail(parser, "Attribute without value");
            parser.tag.attributes[parser.attribName] = "";
            parser.attribValue = "";
            emitNode(parser, "onattribute", {
              name: parser.attribName,
              value: ""
            });
            parser.attribName = "";
            if (c === ">") openTag(parser);
            else if (isMatch(nameStart, c)) {
              parser.attribName = c;
              parser.state = S.ATTRIB_NAME;
            } else {
              strictFail(parser, "Invalid attribute name");
              parser.state = S.ATTRIB;
            }
          }
          continue;
        case S.ATTRIB_VALUE:
          if (isWhitespace(c)) continue;
          else if (isQuote(c)) {
            parser.q = c;
            parser.state = S.ATTRIB_VALUE_QUOTED;
          } else {
            strictFail(parser, "Unquoted attribute value");
            parser.state = S.ATTRIB_VALUE_UNQUOTED;
            parser.attribValue = c;
          }
          continue;
        case S.ATTRIB_VALUE_QUOTED:
          if (c !== parser.q) {
            if (c === "&") parser.state = S.ATTRIB_VALUE_ENTITY_Q;
            else parser.attribValue += c;
            continue;
          }
          attrib(parser);
          parser.q = "";
          parser.state = S.ATTRIB_VALUE_CLOSED;
          continue;
        case S.ATTRIB_VALUE_CLOSED:
          if (isWhitespace(c)) parser.state = S.ATTRIB;
          else if (c === ">") openTag(parser);
          else if (c === "/") parser.state = S.OPEN_TAG_SLASH;
          else if (isMatch(nameStart, c)) {
            strictFail(parser, "No whitespace between attributes");
            parser.attribName = c;
            parser.attribValue = "";
            parser.state = S.ATTRIB_NAME;
          } else strictFail(parser, "Invalid attribute name");
          continue;
        case S.ATTRIB_VALUE_UNQUOTED:
          if (!isAttribEnd(c)) {
            if (c === "&") parser.state = S.ATTRIB_VALUE_ENTITY_U;
            else parser.attribValue += c;
            continue;
          }
          attrib(parser);
          if (c === ">") openTag(parser);
          else parser.state = S.ATTRIB;
          continue;
        case S.CLOSE_TAG:
          if (!parser.tagName) if (isWhitespace(c)) continue;
          else if (notMatch(nameStart, c)) if (parser.script) {
            parser.script += "</" + c;
            parser.state = S.SCRIPT;
          } else strictFail(parser, "Invalid tagname in closing tag.");
          else parser.tagName = c;
          else if (c === ">") closeTag(parser);
          else if (isMatch(nameBody, c)) parser.tagName += c;
          else if (parser.script) {
            parser.script += "</" + parser.tagName;
            parser.tagName = "";
            parser.state = S.SCRIPT;
          } else {
            if (!isWhitespace(c)) strictFail(parser, "Invalid tagname in closing tag");
            parser.state = S.CLOSE_TAG_SAW_WHITE;
          }
          continue;
        case S.CLOSE_TAG_SAW_WHITE:
          if (isWhitespace(c)) continue;
          if (c === ">") closeTag(parser);
          else strictFail(parser, "Invalid characters in closing tag");
          continue;
        case S.TEXT_ENTITY:
        case S.ATTRIB_VALUE_ENTITY_Q:
        case S.ATTRIB_VALUE_ENTITY_U:
          var returnState;
          var buffer;
          switch (parser.state) {
            case S.TEXT_ENTITY:
              returnState = S.TEXT;
              buffer = "textNode";
              break;
            case S.ATTRIB_VALUE_ENTITY_Q:
              returnState = S.ATTRIB_VALUE_QUOTED;
              buffer = "attribValue";
              break;
            case S.ATTRIB_VALUE_ENTITY_U:
              returnState = S.ATTRIB_VALUE_UNQUOTED;
              buffer = "attribValue";
              break;
          }
          if (c === ";") if (parser.opt.unparsedEntities) {
            var parsedEntity = parseEntity(parser);
            parser.entity = "";
            parser.state = returnState;
            parser.write(parsedEntity);
          } else {
            parser[buffer] += parseEntity(parser);
            parser.entity = "";
            parser.state = returnState;
          }
          else if (isMatch(parser.entity.length ? entityBody : entityStart, c)) parser.entity += c;
          else {
            strictFail(parser, "Invalid character in entity name");
            parser[buffer] += "&" + parser.entity + c;
            parser.entity = "";
            parser.state = returnState;
          }
          continue;
        default:
          throw new Error(parser, "Unknown state: " + parser.state);
      }
    }
    if (parser.position >= parser.bufferCheckPosition) checkBufferLength(parser);
    return parser;
  }
  /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */
  if (!String.fromCodePoint) (function() {
    var stringFromCharCode = String.fromCharCode;
    var floor = Math.floor;
    var fromCodePoint = function() {
      var MAX_SIZE = 16384;
      var codeUnits = [];
      var highSurrogate;
      var lowSurrogate;
      var index = -1;
      var length = arguments.length;
      if (!length) return "";
      var result = "";
      while (++index < length) {
        var codePoint = Number(arguments[index]);
        if (!isFinite(codePoint) || codePoint < 0 || codePoint > 1114111 || floor(codePoint) !== codePoint) throw RangeError("Invalid code point: " + codePoint);
        if (codePoint <= 65535) codeUnits.push(codePoint);
        else {
          codePoint -= 65536;
          highSurrogate = (codePoint >> 10) + 55296;
          lowSurrogate = codePoint % 1024 + 56320;
          codeUnits.push(highSurrogate, lowSurrogate);
        }
        if (index + 1 === length || codeUnits.length > MAX_SIZE) {
          result += stringFromCharCode.apply(null, codeUnits);
          codeUnits.length = 0;
        }
      }
      return result;
    };
    if (Object.defineProperty) Object.defineProperty(String, "fromCodePoint", {
      value: fromCodePoint,
      configurable: true,
      writable: true
    });
    else String.fromCodePoint = fromCodePoint;
  })();
  return sax$1;
};
const sax = initializeSax();
const XML_FORMAT_INSTRUCTIONS = `The output should be formatted as a XML file.
1. Output should conform to the tags below. 
2. If tags are not given, make them on your own.
3. Remember to always open and close all the tags.

As an example, for the tags ["foo", "bar", "baz"]:
1. String "<foo>
   <bar>
      <baz></baz>
   </bar>
</foo>" is a well-formatted instance of the schema. 
2. String "<foo>
   <bar>
   </foo>" is a badly-formatted instance.
3. String "<foo>
   <tag>
   </tag>
</foo>" is a badly-formatted instance.

Here are the output tags:
\`\`\`
{tags}
\`\`\``;
var XMLOutputParser = class extends BaseCumulativeTransformOutputParser {
  constructor(fields) {
    super(fields);
    __publicField2(this, "tags");
    __publicField2(this, "lc_namespace", ["langchain_core", "output_parsers"]);
    __publicField2(this, "lc_serializable", true);
    this.tags = fields == null ? void 0 : fields.tags;
  }
  static lc_name() {
    return "XMLOutputParser";
  }
  _diff(prev, next) {
    if (!next) return void 0;
    if (!prev) return [{
      op: "replace",
      path: "",
      value: next
    }];
    return compare(prev, next);
  }
  async parsePartialResult(generations) {
    return parseXMLMarkdown(generations[0].text);
  }
  async parse(text) {
    return parseXMLMarkdown(text);
  }
  getFormatInstructions() {
    var _a3;
    const withTags = !!(this.tags && this.tags.length > 0);
    return withTags ? XML_FORMAT_INSTRUCTIONS.replace("{tags}", ((_a3 = this.tags) == null ? void 0 : _a3.join(", ")) ?? "") : XML_FORMAT_INSTRUCTIONS;
  }
};
const strip = (text) => text.split("\n").map((line) => line.replace(/^\s+/, "")).join("\n").trim();
const parseParsedResult = (input) => {
  if (Object.keys(input).length === 0) return {};
  const result = {};
  if (input.children.length > 0) {
    result[input.name] = input.children.map(parseParsedResult);
    return result;
  } else {
    result[input.name] = input.text ?? void 0;
    return result;
  }
};
function parseXMLMarkdown(s) {
  const cleanedString = strip(s);
  const parser = sax.parser(true);
  let parsedResult = {};
  const elementStack = [];
  parser.onopentag = (node) => {
    const element = {
      name: node.name,
      attributes: node.attributes,
      children: [],
      text: "",
      isSelfClosing: node.isSelfClosing
    };
    if (elementStack.length > 0) {
      const parentElement = elementStack[elementStack.length - 1];
      parentElement.children.push(element);
    } else parsedResult = element;
    if (!node.isSelfClosing) elementStack.push(element);
  };
  parser.onclosetag = () => {
    if (elementStack.length > 0) {
      const lastElement = elementStack.pop();
      if (elementStack.length === 0 && lastElement) parsedResult = lastElement;
    }
  };
  parser.ontext = (text) => {
    if (elementStack.length > 0) {
      const currentElement = elementStack[elementStack.length - 1];
      currentElement.text += text;
    }
  };
  parser.onattribute = (attr) => {
    if (elementStack.length > 0) {
      const currentElement = elementStack[elementStack.length - 1];
      currentElement.attributes[attr.name] = attr.value;
    }
  };
  const match = /```(xml)?(.*)```/s.exec(cleanedString);
  const xmlString = match ? match[2] : cleanedString;
  parser.write(xmlString).close();
  if (parsedResult && parsedResult.name === "?xml") parsedResult = parsedResult.children[0];
  return parseParsedResult(parsedResult);
}
var output_parsers_exports = {};
__export(output_parsers_exports, {
  AsymmetricStructuredOutputParser: () => AsymmetricStructuredOutputParser,
  BaseCumulativeTransformOutputParser: () => BaseCumulativeTransformOutputParser,
  BaseLLMOutputParser: () => BaseLLMOutputParser,
  BaseOutputParser: () => BaseOutputParser,
  BaseTransformOutputParser: () => BaseTransformOutputParser,
  BytesOutputParser: () => BytesOutputParser,
  CommaSeparatedListOutputParser: () => CommaSeparatedListOutputParser,
  CustomListOutputParser: () => CustomListOutputParser,
  JsonMarkdownStructuredOutputParser: () => JsonMarkdownStructuredOutputParser,
  JsonOutputParser: () => JsonOutputParser,
  ListOutputParser: () => ListOutputParser,
  MarkdownListOutputParser: () => MarkdownListOutputParser,
  NumberedListOutputParser: () => NumberedListOutputParser,
  OutputParserException: () => OutputParserException,
  StringOutputParser: () => StringOutputParser,
  StructuredOutputParser: () => StructuredOutputParser,
  XMLOutputParser: () => XMLOutputParser,
  XML_FORMAT_INSTRUCTIONS: () => XML_FORMAT_INSTRUCTIONS,
  parseJsonMarkdown: () => parseJsonMarkdown,
  parsePartialJson: () => parsePartialJson,
  parseXMLMarkdown: () => parseXMLMarkdown
});
function parseToolCall(rawToolCall, options2) {
  if (rawToolCall.function === void 0) return void 0;
  let functionArgs;
  if (options2 == null ? void 0 : options2.partial) try {
    functionArgs = parsePartialJson(rawToolCall.function.arguments ?? "{}");
  } catch {
    return void 0;
  }
  else try {
    functionArgs = JSON.parse(rawToolCall.function.arguments);
  } catch (e) {
    throw new OutputParserException([
      `Function "${rawToolCall.function.name}" arguments:`,
      ``,
      rawToolCall.function.arguments,
      ``,
      `are not valid JSON.`,
      `Error: ${e.message}`
    ].join("\n"));
  }
  const parsedToolCall = {
    name: rawToolCall.function.name,
    args: functionArgs,
    type: "tool_call"
  };
  if (options2 == null ? void 0 : options2.returnId) parsedToolCall.id = rawToolCall.id;
  return parsedToolCall;
}
function convertLangChainToolCallToOpenAI(toolCall) {
  if (toolCall.id === void 0) throw new Error(`All OpenAI tool calls must have an "id" field.`);
  return {
    id: toolCall.id,
    type: "function",
    function: {
      name: toolCall.name,
      arguments: JSON.stringify(toolCall.args)
    }
  };
}
function makeInvalidToolCall(rawToolCall, errorMsg) {
  var _a3, _b;
  return {
    name: (_a3 = rawToolCall.function) == null ? void 0 : _a3.name,
    args: (_b = rawToolCall.function) == null ? void 0 : _b.arguments,
    id: rawToolCall.id,
    error: errorMsg,
    type: "invalid_tool_call"
  };
}
var JsonOutputToolsParser = class extends BaseCumulativeTransformOutputParser {
  constructor(fields) {
    super(fields);
    __publicField2(this, "returnId", false);
    __publicField2(this, "lc_namespace", [
      "langchain",
      "output_parsers",
      "openai_tools"
    ]);
    __publicField2(this, "lc_serializable", true);
    this.returnId = (fields == null ? void 0 : fields.returnId) ?? this.returnId;
  }
  static lc_name() {
    return "JsonOutputToolsParser";
  }
  _diff() {
    throw new Error("Not supported.");
  }
  async parse() {
    throw new Error("Not implemented.");
  }
  async parseResult(generations) {
    const result = await this.parsePartialResult(generations, false);
    return result;
  }
  /**
  * Parses the output and returns a JSON object. If `argsOnly` is true,
  * only the arguments of the function call are returned.
  * @param generations The output of the LLM to parse.
  * @returns A JSON object representation of the function call or its arguments.
  */
  async parsePartialResult(generations, partial2 = true) {
    var _a3;
    const message = generations[0].message;
    let toolCalls;
    if (isAIMessage(message) && ((_a3 = message.tool_calls) == null ? void 0 : _a3.length)) toolCalls = message.tool_calls.map((toolCall) => {
      const { id, ...rest } = toolCall;
      if (!this.returnId) return rest;
      return {
        id,
        ...rest
      };
    });
    else if (message.additional_kwargs.tool_calls !== void 0) {
      const rawToolCalls = JSON.parse(JSON.stringify(message.additional_kwargs.tool_calls));
      toolCalls = rawToolCalls.map((rawToolCall) => {
        return parseToolCall(rawToolCall, {
          returnId: this.returnId,
          partial: partial2
        });
      });
    }
    if (!toolCalls) return [];
    const parsedToolCalls = [];
    for (const toolCall of toolCalls) if (toolCall !== void 0) {
      const backwardsCompatibleToolCall = {
        type: toolCall.name,
        args: toolCall.args,
        id: toolCall.id
      };
      parsedToolCalls.push(backwardsCompatibleToolCall);
    }
    return parsedToolCalls;
  }
};
var JsonOutputKeyToolsParser = class extends JsonOutputToolsParser {
  constructor(params) {
    super(params);
    __publicField2(this, "lc_namespace", [
      "langchain",
      "output_parsers",
      "openai_tools"
    ]);
    __publicField2(this, "lc_serializable", true);
    __publicField2(this, "returnId", false);
    /** The type of tool calls to return. */
    __publicField2(this, "keyName");
    /** Whether to return only the first tool call. */
    __publicField2(this, "returnSingle", false);
    __publicField2(this, "zodSchema");
    this.keyName = params.keyName;
    this.returnSingle = params.returnSingle ?? this.returnSingle;
    this.zodSchema = params.zodSchema;
  }
  static lc_name() {
    return "JsonOutputKeyToolsParser";
  }
  async _validateResult(result) {
    var _a3;
    if (this.zodSchema === void 0) return result;
    const zodParsedResult = await interopSafeParseAsync(this.zodSchema, result);
    if (zodParsedResult.success) return zodParsedResult.data;
    else throw new OutputParserException(`Failed to parse. Text: "${JSON.stringify(result, null, 2)}". Error: ${JSON.stringify((_a3 = zodParsedResult.error) == null ? void 0 : _a3.issues)}`, JSON.stringify(result, null, 2));
  }
  async parsePartialResult(generations) {
    const results2 = await super.parsePartialResult(generations);
    const matchingResults = results2.filter((result) => result.type === this.keyName);
    let returnedValues = matchingResults;
    if (!matchingResults.length) return void 0;
    if (!this.returnId) returnedValues = matchingResults.map((result) => result.args);
    if (this.returnSingle) return returnedValues[0];
    return returnedValues;
  }
  async parseResult(generations) {
    const results2 = await super.parsePartialResult(generations, false);
    const matchingResults = results2.filter((result) => result.type === this.keyName);
    let returnedValues = matchingResults;
    if (!matchingResults.length) return void 0;
    if (!this.returnId) returnedValues = matchingResults.map((result) => result.args);
    if (this.returnSingle) return this._validateResult(returnedValues[0]);
    const toolCallResults = await Promise.all(returnedValues.map((value) => this._validateResult(value)));
    return toolCallResults;
  }
};
var openai_tools_exports = {};
__export(openai_tools_exports, {
  JsonOutputKeyToolsParser: () => JsonOutputKeyToolsParser,
  JsonOutputToolsParser: () => JsonOutputToolsParser,
  convertLangChainToolCallToOpenAI: () => convertLangChainToolCallToOpenAI,
  makeInvalidToolCall: () => makeInvalidToolCall,
  parseToolCall: () => parseToolCall
});
var BaseChatOpenAI = class extends BaseChatModel {
  constructor(fields) {
    var _a3, _b, _c, _d;
    super(fields ?? {});
    __publicField2(this, "temperature");
    __publicField2(this, "topP");
    __publicField2(this, "frequencyPenalty");
    __publicField2(this, "presencePenalty");
    __publicField2(this, "n");
    __publicField2(this, "logitBias");
    __publicField2(this, "model", "gpt-3.5-turbo");
    __publicField2(this, "modelKwargs");
    __publicField2(this, "stop");
    __publicField2(this, "stopSequences");
    __publicField2(this, "user");
    __publicField2(this, "timeout");
    __publicField2(this, "streaming", false);
    __publicField2(this, "streamUsage", true);
    __publicField2(this, "maxTokens");
    __publicField2(this, "logprobs");
    __publicField2(this, "topLogprobs");
    __publicField2(this, "apiKey");
    __publicField2(this, "organization");
    __publicField2(this, "__includeRawResponse");
    /** @internal */
    __publicField2(this, "client");
    /** @internal */
    __publicField2(this, "clientConfig");
    /**
    * Whether the model supports the `strict` argument when passing in tools.
    * If `undefined` the `strict` argument will not be passed to OpenAI.
    */
    __publicField2(this, "supportsStrictToolCalling");
    __publicField2(this, "audio");
    __publicField2(this, "modalities");
    __publicField2(this, "reasoning");
    /**
    * Must be set to `true` in tenancies with Zero Data Retention. Setting to `true` will disable
    * output storage in the Responses API, but this DOES NOT enable Zero Data Retention in your
    * OpenAI organization or project. This must be configured directly with OpenAI.
    *
    * See:
    * https://platform.openai.com/docs/guides/your-data
    * https://platform.openai.com/docs/api-reference/responses/create#responses-create-store
    *
    * @default false
    */
    __publicField2(this, "zdrEnabled");
    /**
    * Service tier to use for this request. Can be "auto", "default", or "flex" or "priority".
    * Specifies the service tier for prioritization and latency optimization.
    */
    __publicField2(this, "service_tier");
    /**
    * Used by OpenAI to cache responses for similar requests to optimize your cache
    * hit rates.
    * [Learn more](https://platform.openai.com/docs/guides/prompt-caching).
    */
    __publicField2(this, "promptCacheKey");
    /**
    * The verbosity of the model's response.
    */
    __publicField2(this, "verbosity");
    __publicField2(this, "defaultOptions");
    __publicField2(this, "lc_serializable", true);
    const configApiKey = typeof ((_a3 = fields == null ? void 0 : fields.configuration) == null ? void 0 : _a3.apiKey) === "string" || typeof ((_b = fields == null ? void 0 : fields.configuration) == null ? void 0 : _b.apiKey) === "function" ? (_c = fields == null ? void 0 : fields.configuration) == null ? void 0 : _c.apiKey : void 0;
    this.apiKey = (fields == null ? void 0 : fields.apiKey) ?? configApiKey ?? getEnvironmentVariable$1("OPENAI_API_KEY");
    this.organization = ((_d = fields == null ? void 0 : fields.configuration) == null ? void 0 : _d.organization) ?? getEnvironmentVariable$1("OPENAI_ORGANIZATION");
    this.model = (fields == null ? void 0 : fields.model) ?? (fields == null ? void 0 : fields.modelName) ?? this.model;
    this.modelKwargs = (fields == null ? void 0 : fields.modelKwargs) ?? {};
    this.timeout = fields == null ? void 0 : fields.timeout;
    this.temperature = (fields == null ? void 0 : fields.temperature) ?? this.temperature;
    this.topP = (fields == null ? void 0 : fields.topP) ?? this.topP;
    this.frequencyPenalty = (fields == null ? void 0 : fields.frequencyPenalty) ?? this.frequencyPenalty;
    this.presencePenalty = (fields == null ? void 0 : fields.presencePenalty) ?? this.presencePenalty;
    this.logprobs = fields == null ? void 0 : fields.logprobs;
    this.topLogprobs = fields == null ? void 0 : fields.topLogprobs;
    this.n = (fields == null ? void 0 : fields.n) ?? this.n;
    this.logitBias = fields == null ? void 0 : fields.logitBias;
    this.stop = (fields == null ? void 0 : fields.stopSequences) ?? (fields == null ? void 0 : fields.stop);
    this.stopSequences = this.stop;
    this.user = fields == null ? void 0 : fields.user;
    this.__includeRawResponse = fields == null ? void 0 : fields.__includeRawResponse;
    this.audio = fields == null ? void 0 : fields.audio;
    this.modalities = fields == null ? void 0 : fields.modalities;
    this.reasoning = fields == null ? void 0 : fields.reasoning;
    this.maxTokens = (fields == null ? void 0 : fields.maxCompletionTokens) ?? (fields == null ? void 0 : fields.maxTokens);
    this.promptCacheKey = (fields == null ? void 0 : fields.promptCacheKey) ?? this.promptCacheKey;
    this.verbosity = (fields == null ? void 0 : fields.verbosity) ?? this.verbosity;
    this.disableStreaming = (fields == null ? void 0 : fields.disableStreaming) === true;
    this.streaming = (fields == null ? void 0 : fields.streaming) === true;
    if (this.disableStreaming) this.streaming = false;
    if ((fields == null ? void 0 : fields.streaming) === false) this.disableStreaming = true;
    this.streamUsage = (fields == null ? void 0 : fields.streamUsage) ?? this.streamUsage;
    if (this.disableStreaming) this.streamUsage = false;
    this.clientConfig = {
      apiKey: this.apiKey,
      organization: this.organization,
      dangerouslyAllowBrowser: true,
      ...fields == null ? void 0 : fields.configuration
    };
    if ((fields == null ? void 0 : fields.supportsStrictToolCalling) !== void 0) this.supportsStrictToolCalling = fields.supportsStrictToolCalling;
    if ((fields == null ? void 0 : fields.service_tier) !== void 0) this.service_tier = fields.service_tier;
    this.zdrEnabled = (fields == null ? void 0 : fields.zdrEnabled) ?? false;
  }
  _llmType() {
    return "openai";
  }
  static lc_name() {
    return "ChatOpenAI";
  }
  get callKeys() {
    return [
      ...super.callKeys,
      "options",
      "function_call",
      "functions",
      "tools",
      "tool_choice",
      "promptIndex",
      "response_format",
      "seed",
      "reasoning",
      "service_tier"
    ];
  }
  get lc_secrets() {
    return {
      apiKey: "OPENAI_API_KEY",
      organization: "OPENAI_ORGANIZATION"
    };
  }
  get lc_aliases() {
    return {
      apiKey: "openai_api_key",
      modelName: "model"
    };
  }
  get lc_serializable_keys() {
    return [
      "configuration",
      "logprobs",
      "topLogprobs",
      "prefixMessages",
      "supportsStrictToolCalling",
      "modalities",
      "audio",
      "temperature",
      "maxTokens",
      "topP",
      "frequencyPenalty",
      "presencePenalty",
      "n",
      "logitBias",
      "user",
      "streaming",
      "streamUsage",
      "model",
      "modelName",
      "modelKwargs",
      "stop",
      "stopSequences",
      "timeout",
      "apiKey",
      "cache",
      "maxConcurrency",
      "maxRetries",
      "verbose",
      "callbacks",
      "tags",
      "metadata",
      "disableStreaming",
      "zdrEnabled",
      "reasoning",
      "promptCacheKey",
      "verbosity"
    ];
  }
  getLsParams(options2) {
    const params = this.invocationParams(options2);
    return {
      ls_provider: "openai",
      ls_model_name: this.model,
      ls_model_type: "chat",
      ls_temperature: params.temperature ?? void 0,
      ls_max_tokens: params.max_tokens ?? void 0,
      ls_stop: options2.stop
    };
  }
  /** @ignore */
  _identifyingParams() {
    return {
      model_name: this.model,
      ...this.invocationParams(),
      ...this.clientConfig
    };
  }
  /**
  * Get the identifying parameters for the model
  */
  identifyingParams() {
    return this._identifyingParams();
  }
  /**
  * Returns backwards compatible reasoning parameters from constructor params and call options
  * @internal
  */
  _getReasoningParams(options2) {
    if (!isReasoningModel(this.model)) return;
    let reasoning;
    if (this.reasoning !== void 0) reasoning = {
      ...reasoning,
      ...this.reasoning
    };
    if ((options2 == null ? void 0 : options2.reasoning) !== void 0) reasoning = {
      ...reasoning,
      ...options2.reasoning
    };
    return reasoning;
  }
  /**
  * Returns an openai compatible response format from a set of options
  * @internal
  */
  _getResponseFormat(resFormat) {
    if (resFormat && resFormat.type === "json_schema" && resFormat.json_schema.schema && isInteropZodSchema(resFormat.json_schema.schema)) return interopZodResponseFormat(resFormat.json_schema.schema, resFormat.json_schema.name, { description: resFormat.json_schema.description });
    return resFormat;
  }
  _combineCallOptions(additionalOptions) {
    return {
      ...this.defaultOptions,
      ...additionalOptions ?? {}
    };
  }
  /** @internal */
  _getClientOptions(options2) {
    if (!this.client) {
      const openAIEndpointConfig = { baseURL: this.clientConfig.baseURL };
      const endpoint = getEndpoint(openAIEndpointConfig);
      const params = {
        ...this.clientConfig,
        baseURL: endpoint,
        timeout: this.timeout,
        maxRetries: 0
      };
      if (!params.baseURL) delete params.baseURL;
      params.defaultHeaders = getHeadersWithUserAgent(params.defaultHeaders);
      this.client = new OpenAI(params);
    }
    const requestOptions = {
      ...this.clientConfig,
      ...options2
    };
    return requestOptions;
  }
  _convertChatOpenAIToolToCompletionsTool(tool2, fields) {
    if (isCustomTool(tool2)) return convertResponsesCustomTool(tool2.metadata.customTool);
    if (isOpenAITool(tool2)) {
      if ((fields == null ? void 0 : fields.strict) !== void 0) return {
        ...tool2,
        function: {
          ...tool2.function,
          strict: fields.strict
        }
      };
      return tool2;
    }
    return _convertToOpenAITool(tool2, fields);
  }
  bindTools(tools, kwargs) {
    let strict;
    if ((kwargs == null ? void 0 : kwargs.strict) !== void 0) strict = kwargs.strict;
    else if (this.supportsStrictToolCalling !== void 0) strict = this.supportsStrictToolCalling;
    return this.withConfig({
      tools: tools.map((tool2) => isBuiltInTool(tool2) || isCustomTool(tool2) ? tool2 : this._convertChatOpenAIToolToCompletionsTool(tool2, { strict })),
      ...kwargs
    });
  }
  async stream(input, options2) {
    return super.stream(input, this._combineCallOptions(options2));
  }
  async invoke(input, options2) {
    return super.invoke(input, this._combineCallOptions(options2));
  }
  /** @ignore */
  _combineLLMOutput(...llmOutputs) {
    return llmOutputs.reduce((acc, llmOutput) => {
      if (llmOutput && llmOutput.tokenUsage) {
        acc.tokenUsage.completionTokens += llmOutput.tokenUsage.completionTokens ?? 0;
        acc.tokenUsage.promptTokens += llmOutput.tokenUsage.promptTokens ?? 0;
        acc.tokenUsage.totalTokens += llmOutput.tokenUsage.totalTokens ?? 0;
      }
      return acc;
    }, { tokenUsage: {
      completionTokens: 0,
      promptTokens: 0,
      totalTokens: 0
    } });
  }
  async getNumTokensFromMessages(messages) {
    let totalCount = 0;
    let tokensPerMessage = 0;
    let tokensPerName = 0;
    if (this.model === "gpt-3.5-turbo-0301") {
      tokensPerMessage = 4;
      tokensPerName = -1;
    } else {
      tokensPerMessage = 3;
      tokensPerName = 1;
    }
    const countPerMessage = await Promise.all(messages.map(async (message) => {
      var _a3, _b, _c, _d, _e, _f;
      const textCount = await this.getNumTokens(message.content);
      const roleCount = await this.getNumTokens(messageToOpenAIRole(message));
      const nameCount = message.name !== void 0 ? tokensPerName + await this.getNumTokens(message.name) : 0;
      let count = textCount + tokensPerMessage + roleCount + nameCount;
      const openAIMessage = message;
      if (openAIMessage._getType() === "function") count -= 2;
      if ((_a3 = openAIMessage.additional_kwargs) == null ? void 0 : _a3.function_call) count += 3;
      if ((_b = openAIMessage == null ? void 0 : openAIMessage.additional_kwargs.function_call) == null ? void 0 : _b.name) count += await this.getNumTokens((_c = openAIMessage.additional_kwargs.function_call) == null ? void 0 : _c.name);
      if ((_d = openAIMessage.additional_kwargs.function_call) == null ? void 0 : _d.arguments) try {
        count += await this.getNumTokens(JSON.stringify(JSON.parse((_e = openAIMessage.additional_kwargs.function_call) == null ? void 0 : _e.arguments)));
      } catch (error) {
        console.error("Error parsing function arguments", error, JSON.stringify(openAIMessage.additional_kwargs.function_call));
        count += await this.getNumTokens((_f = openAIMessage.additional_kwargs.function_call) == null ? void 0 : _f.arguments);
      }
      totalCount += count;
      return count;
    }));
    totalCount += 3;
    return {
      totalCount,
      countPerMessage
    };
  }
  /** @internal */
  async _getNumTokensFromGenerations(generations) {
    const generationUsages = await Promise.all(generations.map(async (generation) => {
      var _a3;
      if ((_a3 = generation.message.additional_kwargs) == null ? void 0 : _a3.function_call) return (await this.getNumTokensFromMessages([generation.message])).countPerMessage[0];
      else return await this.getNumTokens(generation.message.content);
    }));
    return generationUsages.reduce((a, b) => a + b, 0);
  }
  /** @internal */
  async _getEstimatedTokenCountFromPrompt(messages, functions, function_call) {
    let tokens = (await this.getNumTokensFromMessages(messages)).totalCount;
    if (functions && function_call !== "auto") {
      const promptDefinitions = formatFunctionDefinitions(functions);
      tokens += await this.getNumTokens(promptDefinitions);
      tokens += 9;
    }
    if (functions && messages.find((m) => m._getType() === "system")) tokens -= 4;
    if (function_call === "none") tokens += 1;
    else if (typeof function_call === "object") tokens += await this.getNumTokens(function_call.name) + 4;
    return tokens;
  }
  /**
  * Return profiling information for the model.
  *
  * Provides information about the model's capabilities and constraints,
  * including token limits, multimodal support, and advanced features like
  * tool calling and structured output.
  *
  * @returns {ModelProfile} An object describing the model's capabilities and constraints
  *
  * @example
  * ```typescript
  * const model = new ChatOpenAI({ model: "gpt-4o" });
  * const profile = model.profile;
  * console.log(profile.maxInputTokens); // 128000
  * console.log(profile.imageInputs); // true
  * ```
  */
  get profile() {
    return profiles_default[this.model] ?? {};
  }
  /** @internal */
  _getStructuredOutputMethod(config2) {
    const ensuredConfig = { ...config2 };
    if (!this.model.startsWith("gpt-3") && !this.model.startsWith("gpt-4-") && this.model !== "gpt-4") {
      if ((ensuredConfig == null ? void 0 : ensuredConfig.method) === void 0) return "jsonSchema";
    } else if (ensuredConfig.method === "jsonSchema") console.warn(`[WARNING]: JSON Schema is not supported for model "${this.model}". Falling back to tool calling.`);
    return ensuredConfig.method;
  }
  /**
  * Add structured output to the model.
  *
  * The OpenAI model family supports the following structured output methods:
  * - `jsonSchema`: Use the `response_format` field in the response to return a JSON schema. Only supported with the `gpt-4o-mini`,
  *   `gpt-4o-mini-2024-07-18`, and `gpt-4o-2024-08-06` model snapshots and later.
  * - `functionCalling`: Function calling is useful when you are building an application that bridges the models and functionality
  *   of your application.
  * - `jsonMode`: JSON mode is a more basic version of the Structured Outputs feature. While JSON mode ensures that model
  *   output is valid JSON, Structured Outputs reliably matches the model's output to the schema you specify.
  *   We recommend you use `functionCalling` or `jsonSchema` if it is supported for your use case.
  *
  * The default method is `functionCalling`.
  *
  * @see https://platform.openai.com/docs/guides/structured-outputs
  * @param outputSchema - The schema to use for structured output.
  * @param config - The structured output method options.
  * @returns The model with structured output.
  */
  withStructuredOutput(outputSchema, config2) {
    let llm;
    let outputParser;
    const { schema, name, includeRaw } = {
      ...config2,
      schema: outputSchema
    };
    if ((config2 == null ? void 0 : config2.strict) !== void 0 && config2.method === "jsonMode") throw new Error("Argument `strict` is only supported for `method` = 'function_calling'");
    const method = getStructuredOutputMethod(this.model, config2 == null ? void 0 : config2.method);
    if (method === "jsonMode") {
      if (isInteropZodSchema(schema)) outputParser = StructuredOutputParser.fromZodSchema(schema);
      else outputParser = new JsonOutputParser();
      const asJsonSchema = toJsonSchema(schema);
      llm = this.withConfig({
        outputVersion: "v0",
        response_format: { type: "json_object" },
        ls_structured_output_format: {
          kwargs: { method: "json_mode" },
          schema: {
            title: name ?? "extract",
            ...asJsonSchema
          }
        }
      });
    } else if (method === "jsonSchema") {
      const openaiJsonSchemaParams = {
        name: name ?? "extract",
        description: getSchemaDescription(schema),
        schema,
        strict: config2 == null ? void 0 : config2.strict
      };
      const asJsonSchema = toJsonSchema(openaiJsonSchemaParams.schema);
      llm = this.withConfig({
        outputVersion: "v0",
        response_format: {
          type: "json_schema",
          json_schema: openaiJsonSchemaParams
        },
        ls_structured_output_format: {
          kwargs: { method: "json_schema" },
          schema: {
            title: openaiJsonSchemaParams.name,
            description: openaiJsonSchemaParams.description,
            ...asJsonSchema
          }
        }
      });
      if (isInteropZodSchema(schema)) {
        const altParser = StructuredOutputParser.fromZodSchema(schema);
        outputParser = RunnableLambda.from((aiMessage) => {
          if ("parsed" in aiMessage.additional_kwargs) return aiMessage.additional_kwargs.parsed;
          return altParser;
        });
      } else outputParser = new JsonOutputParser();
    } else {
      let functionName = name ?? "extract";
      if (isInteropZodSchema(schema)) {
        const asJsonSchema = toJsonSchema(schema);
        llm = this.withConfig({
          outputVersion: "v0",
          tools: [{
            type: "function",
            function: {
              name: functionName,
              description: asJsonSchema.description,
              parameters: asJsonSchema
            }
          }],
          tool_choice: {
            type: "function",
            function: { name: functionName }
          },
          ls_structured_output_format: {
            kwargs: { method: "function_calling" },
            schema: {
              title: functionName,
              ...asJsonSchema
            }
          },
          ...(config2 == null ? void 0 : config2.strict) !== void 0 ? { strict: config2.strict } : {}
        });
        outputParser = new JsonOutputKeyToolsParser({
          returnSingle: true,
          keyName: functionName,
          zodSchema: schema
        });
      } else {
        let openAIFunctionDefinition;
        if (typeof schema.name === "string" && typeof schema.parameters === "object" && schema.parameters != null) {
          openAIFunctionDefinition = schema;
          functionName = schema.name;
        } else {
          functionName = schema.title ?? functionName;
          openAIFunctionDefinition = {
            name: functionName,
            description: schema.description ?? "",
            parameters: schema
          };
        }
        const asJsonSchema = toJsonSchema(schema);
        llm = this.withConfig({
          outputVersion: "v0",
          tools: [{
            type: "function",
            function: openAIFunctionDefinition
          }],
          tool_choice: {
            type: "function",
            function: { name: functionName }
          },
          ls_structured_output_format: {
            kwargs: { method: "function_calling" },
            schema: {
              title: functionName,
              ...asJsonSchema
            }
          },
          ...(config2 == null ? void 0 : config2.strict) !== void 0 ? { strict: config2.strict } : {}
        });
        outputParser = new JsonOutputKeyToolsParser({
          returnSingle: true,
          keyName: functionName
        });
      }
    }
    if (!includeRaw) return llm.pipe(outputParser);
    const parserAssign = RunnablePassthrough.assign({ parsed: (input, config$12) => outputParser.invoke(input.raw, config$12) });
    const parserNone = RunnablePassthrough.assign({ parsed: () => null });
    const parsedWithFallback = parserAssign.withFallbacks({ fallbacks: [parserNone] });
    return RunnableSequence.from([{ raw: llm }, parsedWithFallback]);
  }
};
const completionsApiContentBlockConverter = {
  providerName: "ChatOpenAI",
  fromStandardTextBlock(block) {
    return {
      type: "text",
      text: block.text
    };
  },
  fromStandardImageBlock(block) {
    var _a3, _b;
    if (block.source_type === "url") return {
      type: "image_url",
      image_url: {
        url: block.url,
        ...((_a3 = block.metadata) == null ? void 0 : _a3.detail) ? { detail: block.metadata.detail } : {}
      }
    };
    if (block.source_type === "base64") {
      const url = `data:${block.mime_type ?? ""};base64,${block.data}`;
      return {
        type: "image_url",
        image_url: {
          url,
          ...((_b = block.metadata) == null ? void 0 : _b.detail) ? { detail: block.metadata.detail } : {}
        }
      };
    }
    throw new Error(`Image content blocks with source_type ${block.source_type} are not supported for ChatOpenAI`);
  },
  fromStandardAudioBlock(block) {
    if (block.source_type === "url") {
      const data = parseBase64DataUrl({ dataUrl: block.url });
      if (!data) throw new Error(`URL audio blocks with source_type ${block.source_type} must be formatted as a data URL for ChatOpenAI`);
      const rawMimeType = data.mime_type || block.mime_type || "";
      let mimeType;
      try {
        mimeType = parseMimeType(rawMimeType);
      } catch {
        throw new Error(`Audio blocks with source_type ${block.source_type} must have mime type of audio/wav or audio/mp3`);
      }
      if (mimeType.type !== "audio" || mimeType.subtype !== "wav" && mimeType.subtype !== "mp3") throw new Error(`Audio blocks with source_type ${block.source_type} must have mime type of audio/wav or audio/mp3`);
      return {
        type: "input_audio",
        input_audio: {
          format: mimeType.subtype,
          data: data.data
        }
      };
    }
    if (block.source_type === "base64") {
      let mimeType;
      try {
        mimeType = parseMimeType(block.mime_type ?? "");
      } catch {
        throw new Error(`Audio blocks with source_type ${block.source_type} must have mime type of audio/wav or audio/mp3`);
      }
      if (mimeType.type !== "audio" || mimeType.subtype !== "wav" && mimeType.subtype !== "mp3") throw new Error(`Audio blocks with source_type ${block.source_type} must have mime type of audio/wav or audio/mp3`);
      return {
        type: "input_audio",
        input_audio: {
          format: mimeType.subtype,
          data: block.data
        }
      };
    }
    throw new Error(`Audio content blocks with source_type ${block.source_type} are not supported for ChatOpenAI`);
  },
  fromStandardFileBlock(block) {
    var _a3, _b, _c, _d, _e, _f, _g, _h, _i, _j;
    if (block.source_type === "url") {
      const data = parseBase64DataUrl({ dataUrl: block.url });
      if (!data) throw new Error(`URL file blocks with source_type ${block.source_type} must be formatted as a data URL for ChatOpenAI`);
      return {
        type: "file",
        file: {
          file_data: block.url,
          ...((_a3 = block.metadata) == null ? void 0 : _a3.filename) || ((_b = block.metadata) == null ? void 0 : _b.name) ? { filename: ((_c = block.metadata) == null ? void 0 : _c.filename) || ((_d = block.metadata) == null ? void 0 : _d.name) } : {}
        }
      };
    }
    if (block.source_type === "base64") return {
      type: "file",
      file: {
        file_data: `data:${block.mime_type ?? ""};base64,${block.data}`,
        ...((_e = block.metadata) == null ? void 0 : _e.filename) || ((_f = block.metadata) == null ? void 0 : _f.name) || ((_g = block.metadata) == null ? void 0 : _g.title) ? { filename: ((_h = block.metadata) == null ? void 0 : _h.filename) || ((_i = block.metadata) == null ? void 0 : _i.name) || ((_j = block.metadata) == null ? void 0 : _j.title) } : {}
      }
    };
    if (block.source_type === "id") return {
      type: "file",
      file: { file_id: block.id }
    };
    throw new Error(`File content blocks with source_type ${block.source_type} are not supported for ChatOpenAI`);
  }
};
const convertCompletionsMessageToBaseMessage = ({ message, rawResponse, includeRawResponse }) => {
  var _a3, _b;
  const rawToolCalls = message.tool_calls;
  switch (message.role) {
    case "assistant": {
      const toolCalls = [];
      const invalidToolCalls = [];
      for (const rawToolCall of rawToolCalls ?? []) try {
        toolCalls.push(parseToolCall(rawToolCall, { returnId: true }));
      } catch (e) {
        invalidToolCalls.push(makeInvalidToolCall(rawToolCall, e.message));
      }
      const additional_kwargs = {
        function_call: message.function_call,
        tool_calls: rawToolCalls
      };
      if (includeRawResponse !== void 0) additional_kwargs.__raw_response = rawResponse;
      const response_metadata = {
        model_provider: "openai",
        model_name: rawResponse.model,
        ...rawResponse.system_fingerprint ? {
          usage: { ...rawResponse.usage },
          system_fingerprint: rawResponse.system_fingerprint
        } : {}
      };
      if (message.audio) additional_kwargs.audio = message.audio;
      const content = handleMultiModalOutput(message.content || "", (_b = (_a3 = rawResponse.choices) == null ? void 0 : _a3[0]) == null ? void 0 : _b.message);
      return new AIMessage({
        content,
        tool_calls: toolCalls,
        invalid_tool_calls: invalidToolCalls,
        additional_kwargs,
        response_metadata,
        id: rawResponse.id
      });
    }
    default:
      return new ChatMessage(message.content || "", message.role ?? "unknown");
  }
};
const convertCompletionsDeltaToBaseMessageChunk = ({ delta, rawResponse, includeRawResponse, defaultRole }) => {
  var _a3, _b;
  const role = delta.role ?? defaultRole;
  const content = delta.content ?? "";
  let additional_kwargs;
  if (delta.function_call) additional_kwargs = { function_call: delta.function_call };
  else if (delta.tool_calls) additional_kwargs = { tool_calls: delta.tool_calls };
  else additional_kwargs = {};
  if (includeRawResponse) additional_kwargs.__raw_response = rawResponse;
  if (delta.audio) additional_kwargs.audio = {
    ...delta.audio,
    index: rawResponse.choices[0].index
  };
  const response_metadata = {
    model_provider: "openai",
    usage: { ...rawResponse.usage }
  };
  if (role === "user") return new HumanMessageChunk({
    content,
    response_metadata
  });
  else if (role === "assistant") {
    const toolCallChunks = [];
    if (Array.isArray(delta.tool_calls)) for (const rawToolCall of delta.tool_calls) toolCallChunks.push({
      name: (_a3 = rawToolCall.function) == null ? void 0 : _a3.name,
      args: (_b = rawToolCall.function) == null ? void 0 : _b.arguments,
      id: rawToolCall.id,
      index: rawToolCall.index,
      type: "tool_call_chunk"
    });
    return new AIMessageChunk({
      content,
      tool_call_chunks: toolCallChunks,
      additional_kwargs,
      id: rawResponse.id,
      response_metadata
    });
  } else if (role === "system") return new SystemMessageChunk({
    content,
    response_metadata
  });
  else if (role === "developer") return new SystemMessageChunk({
    content,
    response_metadata,
    additional_kwargs: { __openai_role__: "developer" }
  });
  else if (role === "function") return new FunctionMessageChunk({
    content,
    additional_kwargs,
    name: delta.name,
    response_metadata
  });
  else if (role === "tool") return new ToolMessageChunk({
    content,
    additional_kwargs,
    tool_call_id: delta.tool_call_id,
    response_metadata
  });
  else return new ChatMessageChunk({
    content,
    role,
    response_metadata
  });
};
const convertStandardContentBlockToCompletionsContentPart = (block) => {
  if (block.type === "image") {
    if (block.url) return {
      type: "image_url",
      image_url: { url: block.url }
    };
    else if (block.data) return {
      type: "image_url",
      image_url: { url: `data:${block.mimeType};base64,${block.data}` }
    };
  }
  if (block.type === "audio") {
    if (block.data) {
      const format2 = iife$2(() => {
        const [, format$1] = block.mimeType.split("/");
        if (format$1 === "wav" || format$1 === "mp3") return format$1;
        return "wav";
      });
      return {
        type: "input_audio",
        input_audio: {
          data: block.data.toString(),
          format: format2
        }
      };
    }
  }
  if (block.type === "file") {
    if (block.data) return {
      type: "file",
      file: { file_data: block.data.toString() }
    };
    if (block.fileId) return {
      type: "file",
      file: { file_id: block.fileId }
    };
  }
  return void 0;
};
const convertStandardContentMessageToCompletionsMessage = ({ message, model }) => {
  let role = messageToOpenAIRole(message);
  if (role === "system" && isReasoningModel(model)) role = "developer";
  if (role === "developer") return {
    role: "developer",
    content: message.contentBlocks.filter((block) => block.type === "text")
  };
  else if (role === "system") return {
    role: "system",
    content: message.contentBlocks.filter((block) => block.type === "text")
  };
  else if (role === "assistant") return {
    role: "assistant",
    content: message.contentBlocks.filter((block) => block.type === "text")
  };
  else if (role === "tool" && ToolMessage.isInstance(message)) return {
    role: "tool",
    tool_call_id: message.tool_call_id,
    content: message.contentBlocks.filter((block) => block.type === "text")
  };
  else if (role === "function") return {
    role: "function",
    name: message.name ?? "",
    content: message.contentBlocks.filter((block) => block.type === "text").join("")
  };
  function* iterateUserContent(blocks2) {
    for (const block of blocks2) {
      if (block.type === "text") yield {
        type: "text",
        text: block.text
      };
      const data = convertStandardContentBlockToCompletionsContentPart(block);
      if (data) yield data;
    }
  }
  return {
    role: "user",
    content: Array.from(iterateUserContent(message.contentBlocks))
  };
};
const convertMessagesToCompletionsMessageParams = ({ messages, model }) => {
  return messages.flatMap((message) => {
    var _a3, _b;
    if ("output_version" in message.response_metadata && ((_a3 = message.response_metadata) == null ? void 0 : _a3.output_version) === "v1") return convertStandardContentMessageToCompletionsMessage({ message });
    let role = messageToOpenAIRole(message);
    if (role === "system" && isReasoningModel(model)) role = "developer";
    const content = typeof message.content === "string" ? message.content : message.content.map((m) => {
      if (isDataContentBlock(m)) return convertToProviderContentBlock(m, completionsApiContentBlockConverter);
      return m;
    });
    const completionParam = {
      role,
      content
    };
    if (message.name != null) completionParam.name = message.name;
    if (message.additional_kwargs.function_call != null) {
      completionParam.function_call = message.additional_kwargs.function_call;
      completionParam.content = "";
    }
    if (AIMessage.isInstance(message) && !!((_b = message.tool_calls) == null ? void 0 : _b.length)) {
      completionParam.tool_calls = message.tool_calls.map(convertLangChainToolCallToOpenAI);
      completionParam.content = "";
    } else {
      if (message.additional_kwargs.tool_calls != null) completionParam.tool_calls = message.additional_kwargs.tool_calls;
      if (ToolMessage.isInstance(message) && message.tool_call_id != null) completionParam.tool_call_id = message.tool_call_id;
    }
    if (message.additional_kwargs.audio && typeof message.additional_kwargs.audio === "object" && "id" in message.additional_kwargs.audio) {
      const audioMessage = {
        role: "assistant",
        audio: { id: message.additional_kwargs.audio.id }
      };
      return [completionParam, audioMessage];
    }
    return completionParam;
  });
};
var ChatOpenAICompletions = class extends BaseChatOpenAI {
  /** @internal */
  invocationParams(options2, extra) {
    var _a3;
    let strict;
    if ((options2 == null ? void 0 : options2.strict) !== void 0) strict = options2.strict;
    else if (this.supportsStrictToolCalling !== void 0) strict = this.supportsStrictToolCalling;
    let streamOptionsConfig = {};
    if ((options2 == null ? void 0 : options2.stream_options) !== void 0) streamOptionsConfig = { stream_options: options2.stream_options };
    else if (this.streamUsage && (this.streaming || (extra == null ? void 0 : extra.streaming))) streamOptionsConfig = { stream_options: { include_usage: true } };
    const params = {
      model: this.model,
      temperature: this.temperature,
      top_p: this.topP,
      frequency_penalty: this.frequencyPenalty,
      presence_penalty: this.presencePenalty,
      logprobs: this.logprobs,
      top_logprobs: this.topLogprobs,
      n: this.n,
      logit_bias: this.logitBias,
      stop: (options2 == null ? void 0 : options2.stop) ?? this.stopSequences,
      user: this.user,
      stream: this.streaming,
      functions: options2 == null ? void 0 : options2.functions,
      function_call: options2 == null ? void 0 : options2.function_call,
      tools: ((_a3 = options2 == null ? void 0 : options2.tools) == null ? void 0 : _a3.length) ? options2.tools.map((tool2) => this._convertChatOpenAIToolToCompletionsTool(tool2, { strict })) : void 0,
      tool_choice: formatToOpenAIToolChoice(options2 == null ? void 0 : options2.tool_choice),
      response_format: this._getResponseFormat(options2 == null ? void 0 : options2.response_format),
      seed: options2 == null ? void 0 : options2.seed,
      ...streamOptionsConfig,
      parallel_tool_calls: options2 == null ? void 0 : options2.parallel_tool_calls,
      ...this.audio || (options2 == null ? void 0 : options2.audio) ? { audio: this.audio || (options2 == null ? void 0 : options2.audio) } : {},
      ...this.modalities || (options2 == null ? void 0 : options2.modalities) ? { modalities: this.modalities || (options2 == null ? void 0 : options2.modalities) } : {},
      ...this.modelKwargs,
      prompt_cache_key: (options2 == null ? void 0 : options2.promptCacheKey) ?? this.promptCacheKey,
      verbosity: (options2 == null ? void 0 : options2.verbosity) ?? this.verbosity
    };
    if ((options2 == null ? void 0 : options2.prediction) !== void 0) params.prediction = options2.prediction;
    if (this.service_tier !== void 0) params.service_tier = this.service_tier;
    if ((options2 == null ? void 0 : options2.service_tier) !== void 0) params.service_tier = options2.service_tier;
    const reasoning = this._getReasoningParams(options2);
    if (reasoning !== void 0 && reasoning.effort !== void 0) params.reasoning_effort = reasoning.effort;
    if (isReasoningModel(params.model)) params.max_completion_tokens = this.maxTokens === -1 ? void 0 : this.maxTokens;
    else params.max_tokens = this.maxTokens === -1 ? void 0 : this.maxTokens;
    return params;
  }
  async _generate(messages, options2, runManager) {
    var _a3, _b;
    const usageMetadata = {};
    const params = this.invocationParams(options2);
    const messagesMapped = convertMessagesToCompletionsMessageParams({
      messages,
      model: this.model
    });
    if (params.stream) {
      const stream = this._streamResponseChunks(messages, options2, runManager);
      const finalChunks = {};
      for await (const chunk of stream) {
        chunk.message.response_metadata = {
          ...chunk.generationInfo,
          ...chunk.message.response_metadata
        };
        const index = ((_a3 = chunk.generationInfo) == null ? void 0 : _a3.completion) ?? 0;
        if (finalChunks[index] === void 0) finalChunks[index] = chunk;
        else finalChunks[index] = finalChunks[index].concat(chunk);
      }
      const generations = Object.entries(finalChunks).sort(([aKey], [bKey]) => parseInt(aKey, 10) - parseInt(bKey, 10)).map(([_, value]) => value);
      const { functions, function_call } = this.invocationParams(options2);
      const promptTokenUsage = await this._getEstimatedTokenCountFromPrompt(messages, functions, function_call);
      const completionTokenUsage = await this._getNumTokensFromGenerations(generations);
      usageMetadata.input_tokens = promptTokenUsage;
      usageMetadata.output_tokens = completionTokenUsage;
      usageMetadata.total_tokens = promptTokenUsage + completionTokenUsage;
      return {
        generations,
        llmOutput: { estimatedTokenUsage: {
          promptTokens: usageMetadata.input_tokens,
          completionTokens: usageMetadata.output_tokens,
          totalTokens: usageMetadata.total_tokens
        } }
      };
    } else {
      const data = await this.completionWithRetry({
        ...params,
        stream: false,
        messages: messagesMapped
      }, {
        signal: options2 == null ? void 0 : options2.signal,
        ...options2 == null ? void 0 : options2.options
      });
      const { completion_tokens: completionTokens, prompt_tokens: promptTokens, total_tokens: totalTokens, prompt_tokens_details: promptTokensDetails, completion_tokens_details: completionTokensDetails } = (data == null ? void 0 : data.usage) ?? {};
      if (completionTokens) usageMetadata.output_tokens = (usageMetadata.output_tokens ?? 0) + completionTokens;
      if (promptTokens) usageMetadata.input_tokens = (usageMetadata.input_tokens ?? 0) + promptTokens;
      if (totalTokens) usageMetadata.total_tokens = (usageMetadata.total_tokens ?? 0) + totalTokens;
      if ((promptTokensDetails == null ? void 0 : promptTokensDetails.audio_tokens) !== null || (promptTokensDetails == null ? void 0 : promptTokensDetails.cached_tokens) !== null) usageMetadata.input_token_details = {
        ...(promptTokensDetails == null ? void 0 : promptTokensDetails.audio_tokens) !== null && { audio: promptTokensDetails == null ? void 0 : promptTokensDetails.audio_tokens },
        ...(promptTokensDetails == null ? void 0 : promptTokensDetails.cached_tokens) !== null && { cache_read: promptTokensDetails == null ? void 0 : promptTokensDetails.cached_tokens }
      };
      if ((completionTokensDetails == null ? void 0 : completionTokensDetails.audio_tokens) !== null || (completionTokensDetails == null ? void 0 : completionTokensDetails.reasoning_tokens) !== null) usageMetadata.output_token_details = {
        ...(completionTokensDetails == null ? void 0 : completionTokensDetails.audio_tokens) !== null && { audio: completionTokensDetails == null ? void 0 : completionTokensDetails.audio_tokens },
        ...(completionTokensDetails == null ? void 0 : completionTokensDetails.reasoning_tokens) !== null && { reasoning: completionTokensDetails == null ? void 0 : completionTokensDetails.reasoning_tokens }
      };
      const generations = [];
      for (const part of (data == null ? void 0 : data.choices) ?? []) {
        const text = ((_b = part.message) == null ? void 0 : _b.content) ?? "";
        const generation = {
          text,
          message: this._convertCompletionsMessageToBaseMessage(part.message ?? { role: "assistant" }, data)
        };
        generation.generationInfo = {
          ...part.finish_reason ? { finish_reason: part.finish_reason } : {},
          ...part.logprobs ? { logprobs: part.logprobs } : {}
        };
        if (isAIMessage(generation.message)) generation.message.usage_metadata = usageMetadata;
        generation.message = new AIMessage(Object.fromEntries(Object.entries(generation.message).filter(([key]) => !key.startsWith("lc_"))));
        generations.push(generation);
      }
      return {
        generations,
        llmOutput: { tokenUsage: {
          promptTokens: usageMetadata.input_tokens,
          completionTokens: usageMetadata.output_tokens,
          totalTokens: usageMetadata.total_tokens
        } }
      };
    }
  }
  async *_streamResponseChunks(messages, options2, runManager) {
    var _a3, _b, _c, _d, _e, _f, _g, _h, _i, _j;
    const messagesMapped = convertMessagesToCompletionsMessageParams({
      messages,
      model: this.model
    });
    const params = {
      ...this.invocationParams(options2, { streaming: true }),
      messages: messagesMapped,
      stream: true
    };
    let defaultRole;
    const streamIterable = await this.completionWithRetry(params, options2);
    let usage;
    for await (const data of streamIterable) {
      const choice = (_a3 = data == null ? void 0 : data.choices) == null ? void 0 : _a3[0];
      if (data.usage) usage = data.usage;
      if (!choice) continue;
      const { delta } = choice;
      if (!delta) continue;
      const chunk = this._convertCompletionsDeltaToBaseMessageChunk(delta, data, defaultRole);
      defaultRole = delta.role ?? defaultRole;
      const newTokenIndices = {
        prompt: options2.promptIndex ?? 0,
        completion: choice.index ?? 0
      };
      if (typeof chunk.content !== "string") {
        console.log("[WARNING]: Received non-string content from OpenAI. This is currently not supported.");
        continue;
      }
      const generationInfo = { ...newTokenIndices };
      if (choice.finish_reason != null) {
        generationInfo.finish_reason = choice.finish_reason;
        generationInfo.system_fingerprint = data.system_fingerprint;
        generationInfo.model_name = data.model;
        generationInfo.service_tier = data.service_tier;
      }
      if (this.logprobs) generationInfo.logprobs = choice.logprobs;
      const generationChunk = new ChatGenerationChunk({
        message: chunk,
        text: chunk.content,
        generationInfo
      });
      yield generationChunk;
      await (runManager == null ? void 0 : runManager.handleLLMNewToken(generationChunk.text ?? "", newTokenIndices, void 0, void 0, void 0, { chunk: generationChunk }));
    }
    if (usage) {
      const inputTokenDetails = {
        ...((_b = usage.prompt_tokens_details) == null ? void 0 : _b.audio_tokens) !== null && { audio: (_c = usage.prompt_tokens_details) == null ? void 0 : _c.audio_tokens },
        ...((_d = usage.prompt_tokens_details) == null ? void 0 : _d.cached_tokens) !== null && { cache_read: (_e = usage.prompt_tokens_details) == null ? void 0 : _e.cached_tokens }
      };
      const outputTokenDetails = {
        ...((_f = usage.completion_tokens_details) == null ? void 0 : _f.audio_tokens) !== null && { audio: (_g = usage.completion_tokens_details) == null ? void 0 : _g.audio_tokens },
        ...((_h = usage.completion_tokens_details) == null ? void 0 : _h.reasoning_tokens) !== null && { reasoning: (_i = usage.completion_tokens_details) == null ? void 0 : _i.reasoning_tokens }
      };
      const generationChunk = new ChatGenerationChunk({
        message: new AIMessageChunk({
          content: "",
          response_metadata: { usage: { ...usage } },
          usage_metadata: {
            input_tokens: usage.prompt_tokens,
            output_tokens: usage.completion_tokens,
            total_tokens: usage.total_tokens,
            ...Object.keys(inputTokenDetails).length > 0 && { input_token_details: inputTokenDetails },
            ...Object.keys(outputTokenDetails).length > 0 && { output_token_details: outputTokenDetails }
          }
        }),
        text: ""
      });
      yield generationChunk;
    }
    if ((_j = options2.signal) == null ? void 0 : _j.aborted) throw new Error("AbortError");
  }
  async completionWithRetry(request, requestOptions) {
    const clientOptions = this._getClientOptions(requestOptions);
    const isParseableFormat = request.response_format && request.response_format.type === "json_schema";
    return this.caller.call(async () => {
      try {
        if (isParseableFormat && !request.stream) return await this.client.chat.completions.parse(request, clientOptions);
        else return await this.client.chat.completions.create(request, clientOptions);
      } catch (e) {
        const error = wrapOpenAIClientError(e);
        throw error;
      }
    });
  }
  /**
  * @deprecated
  * This function was hoisted into a publicly accessible function from a
  * different export, but to maintain backwards compatibility with chat models
  * that depend on ChatOpenAICompletions, we'll keep it here as an overridable
  * method. This will be removed in a future release
  */
  _convertCompletionsDeltaToBaseMessageChunk(delta, rawResponse, defaultRole) {
    return convertCompletionsDeltaToBaseMessageChunk({
      delta,
      rawResponse,
      includeRawResponse: this.__includeRawResponse,
      defaultRole
    });
  }
  /**
  * @deprecated
  * This function was hoisted into a publicly accessible function from a
  * different export, but to maintain backwards compatibility with chat models
  * that depend on ChatOpenAICompletions, we'll keep it here as an overridable
  * method. This will be removed in a future release
  */
  _convertCompletionsMessageToBaseMessage(message, rawResponse) {
    return convertCompletionsMessageToBaseMessage({
      message,
      rawResponse,
      includeRawResponse: this.__includeRawResponse
    });
  }
};
const _FUNCTION_CALL_IDS_MAP_KEY = "__openai_function_call_ids__";
const convertResponsesUsageToUsageMetadata = (usage) => {
  var _a3, _b, _c, _d;
  const inputTokenDetails = { ...((_a3 = usage == null ? void 0 : usage.input_tokens_details) == null ? void 0 : _a3.cached_tokens) != null && { cache_read: (_b = usage == null ? void 0 : usage.input_tokens_details) == null ? void 0 : _b.cached_tokens } };
  const outputTokenDetails = { ...((_c = usage == null ? void 0 : usage.output_tokens_details) == null ? void 0 : _c.reasoning_tokens) != null && { reasoning: (_d = usage == null ? void 0 : usage.output_tokens_details) == null ? void 0 : _d.reasoning_tokens } };
  return {
    input_tokens: (usage == null ? void 0 : usage.input_tokens) ?? 0,
    output_tokens: (usage == null ? void 0 : usage.output_tokens) ?? 0,
    total_tokens: (usage == null ? void 0 : usage.total_tokens) ?? 0,
    input_token_details: inputTokenDetails,
    output_token_details: outputTokenDetails
  };
};
const convertResponsesMessageToAIMessage = (response) => {
  if (response.error) {
    const error = new Error(response.error.message);
    error.name = response.error.code;
    throw error;
  }
  let messageId;
  const content = [];
  const tool_calls = [];
  const invalid_tool_calls = [];
  const response_metadata = {
    model_provider: "openai",
    model: response.model,
    created_at: response.created_at,
    id: response.id,
    incomplete_details: response.incomplete_details,
    metadata: response.metadata,
    object: response.object,
    status: response.status,
    user: response.user,
    service_tier: response.service_tier,
    model_name: response.model
  };
  const additional_kwargs = {};
  for (const item of response.output) if (item.type === "message") {
    messageId = item.id;
    content.push(...item.content.flatMap((part) => {
      if (part.type === "output_text") {
        if ("parsed" in part && part.parsed != null) additional_kwargs.parsed = part.parsed;
        return {
          type: "text",
          text: part.text,
          annotations: part.annotations
        };
      }
      if (part.type === "refusal") {
        additional_kwargs.refusal = part.refusal;
        return [];
      }
      return part;
    }));
  } else if (item.type === "function_call") {
    const fnAdapter = {
      function: {
        name: item.name,
        arguments: item.arguments
      },
      id: item.call_id
    };
    try {
      tool_calls.push(parseToolCall(fnAdapter, { returnId: true }));
    } catch (e) {
      let errMessage;
      if (typeof e === "object" && e != null && "message" in e && typeof e.message === "string") errMessage = e.message;
      invalid_tool_calls.push(makeInvalidToolCall(fnAdapter, errMessage));
    }
    additional_kwargs[_FUNCTION_CALL_IDS_MAP_KEY] ?? (additional_kwargs[_FUNCTION_CALL_IDS_MAP_KEY] = {});
    if (item.id) additional_kwargs[_FUNCTION_CALL_IDS_MAP_KEY][item.call_id] = item.id;
  } else if (item.type === "reasoning") additional_kwargs.reasoning = item;
  else if (item.type === "custom_tool_call") {
    const parsed = parseCustomToolCall(item);
    if (parsed) tool_calls.push(parsed);
    else invalid_tool_calls.push(makeInvalidToolCall(item, "Malformed custom tool call"));
  } else {
    additional_kwargs.tool_outputs ?? (additional_kwargs.tool_outputs = []);
    additional_kwargs.tool_outputs.push(item);
  }
  return new AIMessage({
    id: messageId,
    content,
    tool_calls,
    invalid_tool_calls,
    usage_metadata: convertResponsesUsageToUsageMetadata(response.usage),
    additional_kwargs,
    response_metadata
  });
};
const convertReasoningSummaryToResponsesReasoningItem = (reasoning) => {
  const summary = (reasoning.summary.length > 1 ? reasoning.summary.reduce((acc, curr) => {
    const last = acc[acc.length - 1];
    if (last.index === curr.index) last.text += curr.text;
    else acc.push(curr);
    return acc;
  }, [{ ...reasoning.summary[0] }]) : reasoning.summary).map((s) => Object.fromEntries(Object.entries(s).filter(([k]) => k !== "index")));
  return {
    ...reasoning,
    summary
  };
};
const convertResponsesDeltaToChatGenerationChunk = (event) => {
  var _a3, _b;
  const content = [];
  let generationInfo = {};
  let usage_metadata;
  const tool_call_chunks = [];
  const response_metadata = { model_provider: "openai" };
  const additional_kwargs = {};
  let id;
  if (event.type === "response.output_text.delta") content.push({
    type: "text",
    text: event.delta,
    index: event.content_index
  });
  else if (event.type === "response.output_text.annotation.added") content.push({
    type: "text",
    text: "",
    annotations: [event.annotation],
    index: event.content_index
  });
  else if (event.type === "response.output_item.added" && event.item.type === "message") id = event.item.id;
  else if (event.type === "response.output_item.added" && event.item.type === "function_call") {
    tool_call_chunks.push({
      type: "tool_call_chunk",
      name: event.item.name,
      args: event.item.arguments,
      id: event.item.call_id,
      index: event.output_index
    });
    additional_kwargs[_FUNCTION_CALL_IDS_MAP_KEY] = { [event.item.call_id]: event.item.id };
  } else if (event.type === "response.output_item.done" && [
    "web_search_call",
    "file_search_call",
    "computer_call",
    "code_interpreter_call",
    "mcp_call",
    "mcp_list_tools",
    "mcp_approval_request",
    "image_generation_call",
    "custom_tool_call"
  ].includes(event.item.type)) additional_kwargs.tool_outputs = [event.item];
  else if (event.type === "response.created") {
    response_metadata.id = event.response.id;
    response_metadata.model_name = event.response.model;
    response_metadata.model = event.response.model;
  } else if (event.type === "response.completed") {
    const msg = convertResponsesMessageToAIMessage(event.response);
    usage_metadata = convertResponsesUsageToUsageMetadata(event.response.usage);
    if (((_b = (_a3 = event.response.text) == null ? void 0 : _a3.format) == null ? void 0 : _b.type) === "json_schema") additional_kwargs.parsed ?? (additional_kwargs.parsed = JSON.parse(msg.text));
    for (const [key, value] of Object.entries(event.response)) if (key !== "id") response_metadata[key] = value;
  } else if (event.type === "response.function_call_arguments.delta" || event.type === "response.custom_tool_call_input.delta") tool_call_chunks.push({
    type: "tool_call_chunk",
    args: event.delta,
    index: event.output_index
  });
  else if (event.type === "response.web_search_call.completed" || event.type === "response.file_search_call.completed") generationInfo = { tool_outputs: {
    id: event.item_id,
    type: event.type.replace("response.", "").replace(".completed", ""),
    status: "completed"
  } };
  else if (event.type === "response.refusal.done") additional_kwargs.refusal = event.refusal;
  else if (event.type === "response.output_item.added" && "item" in event && event.item.type === "reasoning") {
    const summary = event.item.summary ? event.item.summary.map((s, index) => ({
      ...s,
      index
    })) : void 0;
    additional_kwargs.reasoning = {
      id: event.item.id,
      type: event.item.type,
      ...summary ? { summary } : {}
    };
  } else if (event.type === "response.reasoning_summary_part.added") additional_kwargs.reasoning = {
    type: "reasoning",
    summary: [{
      ...event.part,
      index: event.summary_index
    }]
  };
  else if (event.type === "response.reasoning_summary_text.delta") additional_kwargs.reasoning = {
    type: "reasoning",
    summary: [{
      text: event.delta,
      type: "summary_text",
      index: event.summary_index
    }]
  };
  else if (event.type === "response.image_generation_call.partial_image") return null;
  else return null;
  return new ChatGenerationChunk({
    text: content.map((part) => part.text).join(""),
    message: new AIMessageChunk({
      id,
      content,
      tool_call_chunks,
      usage_metadata,
      additional_kwargs,
      response_metadata
    }),
    generationInfo
  });
};
const convertStandardContentMessageToResponsesInput = (message) => {
  var _a3;
  const isResponsesMessage = AIMessage.isInstance(message) && ((_a3 = message.response_metadata) == null ? void 0 : _a3.model_provider) === "openai";
  function* iterateItems() {
    const messageRole = iife$1(() => {
      try {
        const role = messageToOpenAIRole(message);
        if (role === "system" || role === "developer" || role === "assistant" || role === "user") return role;
        return "assistant";
      } catch {
        return "assistant";
      }
    });
    let currentMessage = void 0;
    const functionCallIdsWithBlocks = /* @__PURE__ */ new Set();
    const serverFunctionCallIdsWithBlocks = /* @__PURE__ */ new Set();
    const pendingFunctionChunks = /* @__PURE__ */ new Map();
    const pendingServerFunctionChunks = /* @__PURE__ */ new Map();
    function* flushMessage() {
      if (!currentMessage) return;
      const content = currentMessage.content;
      if (typeof content === "string" && content.length > 0 || Array.isArray(content) && content.length > 0) yield currentMessage;
      currentMessage = void 0;
    }
    const pushMessageContent = (content) => {
      if (!currentMessage) currentMessage = {
        type: "message",
        role: messageRole,
        content: []
      };
      if (typeof currentMessage.content === "string") currentMessage.content = currentMessage.content.length > 0 ? [{
        type: "input_text",
        text: currentMessage.content
      }, ...content] : [...content];
      else currentMessage.content.push(...content);
    };
    const toJsonString = (value) => {
      if (typeof value === "string") return value;
      try {
        return JSON.stringify(value ?? {});
      } catch {
        return "{}";
      }
    };
    const resolveImageItem = (block) => {
      const detail = iife$1(() => {
        var _a4;
        const raw = (_a4 = block.metadata) == null ? void 0 : _a4.detail;
        if (raw === "low" || raw === "high" || raw === "auto") return raw;
        return "auto";
      });
      if (block.fileId) return {
        type: "input_image",
        detail,
        file_id: block.fileId
      };
      if (block.url) return {
        type: "input_image",
        detail,
        image_url: block.url
      };
      if (block.data) {
        const base64Data = typeof block.data === "string" ? block.data : Buffer.from(block.data).toString("base64");
        const mimeType = block.mimeType ?? "image/png";
        return {
          type: "input_image",
          detail,
          image_url: `data:${mimeType};base64,${base64Data}`
        };
      }
      return void 0;
    };
    const resolveFileItem = (block) => {
      var _a4, _b, _c;
      const filename = ((_a4 = block.metadata) == null ? void 0 : _a4.filename) ?? ((_b = block.metadata) == null ? void 0 : _b.name) ?? ((_c = block.metadata) == null ? void 0 : _c.title);
      if (block.fileId && typeof filename === "string") return {
        type: "input_file",
        file_id: block.fileId,
        ...filename ? { filename } : {}
      };
      if (block.url && typeof filename === "string") return {
        type: "input_file",
        file_url: block.url,
        ...filename ? { filename } : {}
      };
      if (block.data && typeof filename === "string") {
        const encoded = typeof block.data === "string" ? block.data : Buffer.from(block.data).toString("base64");
        const mimeType = block.mimeType ?? "application/octet-stream";
        return {
          type: "input_file",
          file_data: `data:${mimeType};base64,${encoded}`,
          ...filename ? { filename } : {}
        };
      }
      return void 0;
    };
    const convertReasoningBlock = (block) => {
      const summaryEntries = iife$1(() => {
        if (Array.isArray(block.summary)) {
          const candidate = block.summary;
          const mapped = (candidate == null ? void 0 : candidate.map((item) => item == null ? void 0 : item.text).filter((text) => typeof text === "string")) ?? [];
          if (mapped.length > 0) return mapped;
        }
        return block.reasoning ? [block.reasoning] : [];
      });
      const summary = summaryEntries.length > 0 ? summaryEntries.map((text) => ({
        type: "summary_text",
        text
      })) : [{
        type: "summary_text",
        text: ""
      }];
      const reasoningItem = {
        type: "reasoning",
        id: block.id ?? "",
        summary
      };
      if (block.reasoning) reasoningItem.content = [{
        type: "reasoning_text",
        text: block.reasoning
      }];
      return reasoningItem;
    };
    const convertFunctionCall = (block) => ({
      type: "function_call",
      name: block.name ?? "",
      call_id: block.id ?? "",
      arguments: toJsonString(block.args)
    });
    const convertFunctionCallOutput = (block) => {
      const output = toJsonString(block.output);
      const status = block.status === "success" ? "completed" : block.status === "error" ? "incomplete" : void 0;
      return {
        type: "function_call_output",
        call_id: block.toolCallId ?? "",
        output,
        ...status ? { status } : {}
      };
    };
    for (const block of message.contentBlocks) if (block.type === "text") pushMessageContent([{
      type: "input_text",
      text: block.text
    }]);
    else if (block.type === "invalid_tool_call") ;
    else if (block.type === "reasoning") {
      yield* flushMessage();
      yield convertReasoningBlock(block);
    } else if (block.type === "tool_call") {
      yield* flushMessage();
      const id = block.id ?? "";
      if (id) {
        functionCallIdsWithBlocks.add(id);
        pendingFunctionChunks.delete(id);
      }
      yield convertFunctionCall(block);
    } else if (block.type === "tool_call_chunk") {
      if (block.id) {
        const existing = pendingFunctionChunks.get(block.id) ?? {
          name: block.name,
          args: []
        };
        if (block.name) existing.name = block.name;
        if (block.args) existing.args.push(block.args);
        pendingFunctionChunks.set(block.id, existing);
      }
    } else if (block.type === "server_tool_call") {
      yield* flushMessage();
      const id = block.id ?? "";
      if (id) {
        serverFunctionCallIdsWithBlocks.add(id);
        pendingServerFunctionChunks.delete(id);
      }
      yield convertFunctionCall(block);
    } else if (block.type === "server_tool_call_chunk") {
      if (block.id) {
        const existing = pendingServerFunctionChunks.get(block.id) ?? {
          name: block.name,
          args: []
        };
        if (block.name) existing.name = block.name;
        if (block.args) existing.args.push(block.args);
        pendingServerFunctionChunks.set(block.id, existing);
      }
    } else if (block.type === "server_tool_call_result") {
      yield* flushMessage();
      yield convertFunctionCallOutput(block);
    } else if (block.type === "audio") ;
    else if (block.type === "file") {
      const fileItem = resolveFileItem(block);
      if (fileItem) pushMessageContent([fileItem]);
    } else if (block.type === "image") {
      const imageItem = resolveImageItem(block);
      if (imageItem) pushMessageContent([imageItem]);
    } else if (block.type === "video") {
      const videoItem = resolveFileItem(block);
      if (videoItem) pushMessageContent([videoItem]);
    } else if (block.type === "text-plain") {
      if (block.text) pushMessageContent([{
        type: "input_text",
        text: block.text
      }]);
    } else if (block.type === "non_standard" && isResponsesMessage) {
      yield* flushMessage();
      yield block.value;
    }
    yield* flushMessage();
    for (const [id, chunk] of pendingFunctionChunks) {
      if (!id || functionCallIdsWithBlocks.has(id)) continue;
      const args = chunk.args.join("");
      if (!chunk.name && !args) continue;
      yield {
        type: "function_call",
        call_id: id,
        name: chunk.name ?? "",
        arguments: args
      };
    }
    for (const [id, chunk] of pendingServerFunctionChunks) {
      if (!id || serverFunctionCallIdsWithBlocks.has(id)) continue;
      const args = chunk.args.join("");
      if (!chunk.name && !args) continue;
      yield {
        type: "function_call",
        call_id: id,
        name: chunk.name ?? "",
        arguments: args
      };
    }
  }
  return Array.from(iterateItems());
};
const convertMessagesToResponsesInput = ({ messages, zdrEnabled, model }) => {
  return messages.flatMap((lcMsg) => {
    var _a3, _b, _c, _d;
    const responseMetadata = lcMsg.response_metadata;
    if ((responseMetadata == null ? void 0 : responseMetadata.output_version) === "v1") return convertStandardContentMessageToResponsesInput(lcMsg);
    const additional_kwargs = lcMsg.additional_kwargs;
    let role = messageToOpenAIRole(lcMsg);
    if (role === "system" && isReasoningModel(model)) role = "developer";
    if (role === "function") throw new Error("Function messages are not supported in Responses API");
    if (role === "tool") {
      const toolMessage = lcMsg;
      if ((additional_kwargs == null ? void 0 : additional_kwargs.type) === "computer_call_output") {
        const output = (() => {
          if (typeof toolMessage.content === "string") return {
            type: "computer_screenshot",
            image_url: toolMessage.content
          };
          if (Array.isArray(toolMessage.content)) {
            const oaiScreenshot = toolMessage.content.find((i2) => i2.type === "computer_screenshot");
            if (oaiScreenshot) return oaiScreenshot;
            const lcImage = toolMessage.content.find((i2) => i2.type === "image_url");
            if (lcImage) return {
              type: "computer_screenshot",
              image_url: typeof lcImage.image_url === "string" ? lcImage.image_url : lcImage.image_url.url
            };
          }
          throw new Error("Invalid computer call output");
        })();
        return {
          type: "computer_call_output",
          output,
          call_id: toolMessage.tool_call_id
        };
      }
      if ((_a3 = toolMessage.additional_kwargs) == null ? void 0 : _a3.customTool) return {
        type: "custom_tool_call_output",
        call_id: toolMessage.tool_call_id,
        output: toolMessage.content
      };
      return {
        type: "function_call_output",
        call_id: toolMessage.tool_call_id,
        id: ((_b = toolMessage.id) == null ? void 0 : _b.startsWith("fc_")) ? toolMessage.id : void 0,
        output: typeof toolMessage.content !== "string" ? JSON.stringify(toolMessage.content) : toolMessage.content
      };
    }
    if (role === "assistant") {
      if (!zdrEnabled && (responseMetadata == null ? void 0 : responseMetadata.output) != null && Array.isArray(responseMetadata == null ? void 0 : responseMetadata.output) && (responseMetadata == null ? void 0 : responseMetadata.output.length) > 0 && (responseMetadata == null ? void 0 : responseMetadata.output.every((item) => "type" in item))) return responseMetadata == null ? void 0 : responseMetadata.output;
      const input = [];
      if ((additional_kwargs == null ? void 0 : additional_kwargs.reasoning) && !zdrEnabled) {
        const reasoningItem = convertReasoningSummaryToResponsesReasoningItem(additional_kwargs.reasoning);
        input.push(reasoningItem);
      }
      let { content } = lcMsg;
      if (additional_kwargs == null ? void 0 : additional_kwargs.refusal) {
        if (typeof content === "string") content = [{
          type: "output_text",
          text: content,
          annotations: []
        }];
        content = [...content, {
          type: "refusal",
          refusal: additional_kwargs.refusal
        }];
      }
      if (typeof content === "string" || content.length > 0) input.push({
        type: "message",
        role: "assistant",
        ...lcMsg.id && !zdrEnabled && lcMsg.id.startsWith("msg_") ? { id: lcMsg.id } : {},
        content: iife$1(() => {
          if (typeof content === "string") return content;
          return content.flatMap((item) => {
            if (item.type === "text") return {
              type: "output_text",
              text: item.text,
              annotations: item.annotations ?? []
            };
            if (item.type === "output_text" || item.type === "refusal") return item;
            return [];
          });
        })
      });
      const functionCallIds = additional_kwargs == null ? void 0 : additional_kwargs[_FUNCTION_CALL_IDS_MAP_KEY];
      if (AIMessage.isInstance(lcMsg) && !!((_c = lcMsg.tool_calls) == null ? void 0 : _c.length)) input.push(...lcMsg.tool_calls.map((toolCall) => {
        if (isCustomToolCall(toolCall)) return {
          type: "custom_tool_call",
          id: toolCall.call_id,
          call_id: toolCall.id ?? "",
          input: toolCall.args.input,
          name: toolCall.name
        };
        return {
          type: "function_call",
          name: toolCall.name,
          arguments: JSON.stringify(toolCall.args),
          call_id: toolCall.id,
          ...!zdrEnabled ? { id: functionCallIds == null ? void 0 : functionCallIds[toolCall.id] } : {}
        };
      }));
      else if (additional_kwargs == null ? void 0 : additional_kwargs.tool_calls) input.push(...additional_kwargs.tool_calls.map((toolCall) => ({
        type: "function_call",
        name: toolCall.function.name,
        call_id: toolCall.id,
        arguments: toolCall.function.arguments,
        ...!zdrEnabled ? { id: functionCallIds == null ? void 0 : functionCallIds[toolCall.id] } : {}
      })));
      const toolOutputs = ((_d = responseMetadata == null ? void 0 : responseMetadata.output) == null ? void 0 : _d.length) ? responseMetadata == null ? void 0 : responseMetadata.output : additional_kwargs.tool_outputs;
      const fallthroughCallTypes = [
        "computer_call",
        "mcp_call",
        "code_interpreter_call",
        "image_generation_call"
      ];
      if (toolOutputs != null) {
        const castToolOutputs = toolOutputs;
        const fallthroughCalls = castToolOutputs == null ? void 0 : castToolOutputs.filter((item) => fallthroughCallTypes.includes(item.type));
        if (fallthroughCalls.length > 0) input.push(...fallthroughCalls);
      }
      return input;
    }
    if (role === "user" || role === "system" || role === "developer") {
      if (typeof lcMsg.content === "string") return {
        type: "message",
        role,
        content: lcMsg.content
      };
      const messages$1 = [];
      const content = lcMsg.content.flatMap((item) => {
        if (item.type === "mcp_approval_response") messages$1.push({
          type: "mcp_approval_response",
          approval_request_id: item.approval_request_id,
          approve: item.approve
        });
        if (isDataContentBlock(item)) return convertToProviderContentBlock(item, completionsApiContentBlockConverter);
        if (item.type === "text") return {
          type: "input_text",
          text: item.text
        };
        if (item.type === "image_url") {
          const imageUrl = iife$1(() => {
            if (typeof item.image_url === "string") return item.image_url;
            else if (typeof item.image_url === "object" && item.image_url !== null && "url" in item.image_url) return item.image_url.url;
            return void 0;
          });
          const detail = iife$1(() => {
            if (typeof item.image_url === "string") return "auto";
            else if (typeof item.image_url === "object" && item.image_url !== null && "detail" in item.image_url) return item.image_url.detail;
            return void 0;
          });
          return {
            type: "input_image",
            image_url: imageUrl,
            detail
          };
        }
        if (item.type === "input_text" || item.type === "input_image" || item.type === "input_file") return item;
        return [];
      });
      if (content.length > 0) messages$1.push({
        type: "message",
        role,
        content
      });
      return messages$1;
    }
    console.warn(`Unsupported role found when converting to OpenAI Responses API: ${role}`);
    return [];
  });
};
var ChatOpenAIResponses = class extends BaseChatOpenAI {
  invocationParams(options2) {
    var _a3;
    let strict;
    if ((options2 == null ? void 0 : options2.strict) !== void 0) strict = options2.strict;
    else if (this.supportsStrictToolCalling !== void 0) strict = this.supportsStrictToolCalling;
    const params = {
      model: this.model,
      temperature: this.temperature,
      top_p: this.topP,
      user: this.user,
      stream: this.streaming,
      previous_response_id: options2 == null ? void 0 : options2.previous_response_id,
      truncation: options2 == null ? void 0 : options2.truncation,
      include: options2 == null ? void 0 : options2.include,
      tools: ((_a3 = options2 == null ? void 0 : options2.tools) == null ? void 0 : _a3.length) ? this._reduceChatOpenAITools(options2.tools, {
        stream: this.streaming,
        strict
      }) : void 0,
      tool_choice: isBuiltInToolChoice(options2 == null ? void 0 : options2.tool_choice) ? options2 == null ? void 0 : options2.tool_choice : (() => {
        const formatted = formatToOpenAIToolChoice(options2 == null ? void 0 : options2.tool_choice);
        if (typeof formatted === "object" && "type" in formatted) {
          if (formatted.type === "function") return {
            type: "function",
            name: formatted.function.name
          };
          else if (formatted.type === "allowed_tools") return {
            type: "allowed_tools",
            mode: formatted.allowed_tools.mode,
            tools: formatted.allowed_tools.tools
          };
          else if (formatted.type === "custom") return {
            type: "custom",
            name: formatted.custom.name
          };
        }
        return void 0;
      })(),
      text: (() => {
        if (options2 == null ? void 0 : options2.text) return options2.text;
        const format2 = this._getResponseFormat(options2 == null ? void 0 : options2.response_format);
        if ((format2 == null ? void 0 : format2.type) === "json_schema") {
          if (format2.json_schema.schema != null) return {
            format: {
              type: "json_schema",
              schema: format2.json_schema.schema,
              description: format2.json_schema.description,
              name: format2.json_schema.name,
              strict: format2.json_schema.strict
            },
            verbosity: options2 == null ? void 0 : options2.verbosity
          };
          return void 0;
        }
        return {
          format: format2,
          verbosity: options2 == null ? void 0 : options2.verbosity
        };
      })(),
      parallel_tool_calls: options2 == null ? void 0 : options2.parallel_tool_calls,
      max_output_tokens: this.maxTokens === -1 ? void 0 : this.maxTokens,
      prompt_cache_key: (options2 == null ? void 0 : options2.promptCacheKey) ?? this.promptCacheKey,
      ...this.zdrEnabled ? { store: false } : {},
      ...this.modelKwargs
    };
    const reasoning = this._getReasoningParams(options2);
    if (reasoning !== void 0) params.reasoning = reasoning;
    return params;
  }
  async _generate(messages, options2) {
    var _a3;
    const invocationParams = this.invocationParams(options2);
    if (invocationParams.stream) {
      const stream = this._streamResponseChunks(messages, options2);
      let finalChunk;
      for await (const chunk of stream) {
        chunk.message.response_metadata = {
          ...chunk.generationInfo,
          ...chunk.message.response_metadata
        };
        finalChunk = (finalChunk == null ? void 0 : finalChunk.concat(chunk)) ?? chunk;
      }
      return {
        generations: finalChunk ? [finalChunk] : [],
        llmOutput: { estimatedTokenUsage: (_a3 = finalChunk == null ? void 0 : finalChunk.message) == null ? void 0 : _a3.usage_metadata }
      };
    } else {
      const data = await this.completionWithRetry({
        input: convertMessagesToResponsesInput({
          messages,
          zdrEnabled: this.zdrEnabled ?? false,
          model: this.model
        }),
        ...invocationParams,
        stream: false
      }, {
        signal: options2 == null ? void 0 : options2.signal,
        ...options2 == null ? void 0 : options2.options
      });
      return {
        generations: [{
          text: data.output_text,
          message: convertResponsesMessageToAIMessage(data)
        }],
        llmOutput: {
          id: data.id,
          estimatedTokenUsage: data.usage ? {
            promptTokens: data.usage.input_tokens,
            completionTokens: data.usage.output_tokens,
            totalTokens: data.usage.total_tokens
          } : void 0
        }
      };
    }
  }
  async *_streamResponseChunks(messages, options2, runManager) {
    const streamIterable = await this.completionWithRetry({
      ...this.invocationParams(options2),
      input: convertMessagesToResponsesInput({
        messages,
        zdrEnabled: this.zdrEnabled ?? false,
        model: this.model
      }),
      stream: true
    }, options2);
    for await (const data of streamIterable) {
      const chunk = convertResponsesDeltaToChatGenerationChunk(data);
      if (chunk == null) continue;
      yield chunk;
      await (runManager == null ? void 0 : runManager.handleLLMNewToken(chunk.text || "", {
        prompt: options2.promptIndex ?? 0,
        completion: 0
      }, void 0, void 0, void 0, { chunk }));
    }
  }
  async completionWithRetry(request, requestOptions) {
    return this.caller.call(async () => {
      var _a3, _b;
      const clientOptions = this._getClientOptions(requestOptions);
      try {
        if (((_b = (_a3 = request.text) == null ? void 0 : _a3.format) == null ? void 0 : _b.type) === "json_schema" && !request.stream) return await this.client.responses.parse(request, clientOptions);
        return await this.client.responses.create(request, clientOptions);
      } catch (e) {
        const error = wrapOpenAIClientError(e);
        throw error;
      }
    });
  }
  /** @internal */
  _reduceChatOpenAITools(tools, fields) {
    const reducedTools = [];
    for (const tool2 of tools) if (isBuiltInTool(tool2)) {
      if (tool2.type === "image_generation" && (fields == null ? void 0 : fields.stream)) tool2.partial_images = 1;
      reducedTools.push(tool2);
    } else if (isCustomTool(tool2)) {
      const customToolData = tool2.metadata.customTool;
      reducedTools.push({
        type: "custom",
        name: customToolData.name,
        description: customToolData.description,
        format: customToolData.format
      });
    } else if (isOpenAITool(tool2)) reducedTools.push({
      type: "function",
      name: tool2.function.name,
      parameters: tool2.function.parameters,
      description: tool2.function.description,
      strict: (fields == null ? void 0 : fields.strict) ?? null
    });
    else if (isOpenAICustomTool(tool2)) reducedTools.push(convertCompletionsCustomTool(tool2));
    return reducedTools;
  }
};
var ChatOpenAI = class ChatOpenAI2 extends BaseChatOpenAI {
  constructor(fields) {
    super(fields);
    /**
    * Whether to use the responses API for all requests. If `false` the responses API will be used
    * only when required in order to fulfill the request.
    */
    __publicField2(this, "useResponsesApi", false);
    __publicField2(this, "responses");
    __publicField2(this, "completions");
    this.fields = fields;
    this.useResponsesApi = (fields == null ? void 0 : fields.useResponsesApi) ?? false;
    this.responses = (fields == null ? void 0 : fields.responses) ?? new ChatOpenAIResponses(fields);
    this.completions = (fields == null ? void 0 : fields.completions) ?? new ChatOpenAICompletions(fields);
  }
  get lc_serializable_keys() {
    return [...super.lc_serializable_keys, "useResponsesApi"];
  }
  get callKeys() {
    return [...super.callKeys, "useResponsesApi"];
  }
  _useResponsesApi(options2) {
    var _a3, _b, _c, _d, _e;
    const usesBuiltInTools = (_a3 = options2 == null ? void 0 : options2.tools) == null ? void 0 : _a3.some(isBuiltInTool);
    const hasResponsesOnlyKwargs = (options2 == null ? void 0 : options2.previous_response_id) != null || (options2 == null ? void 0 : options2.text) != null || (options2 == null ? void 0 : options2.truncation) != null || (options2 == null ? void 0 : options2.include) != null || ((_b = options2 == null ? void 0 : options2.reasoning) == null ? void 0 : _b.summary) != null || ((_c = this.reasoning) == null ? void 0 : _c.summary) != null;
    const hasCustomTools = ((_d = options2 == null ? void 0 : options2.tools) == null ? void 0 : _d.some(isOpenAICustomTool)) || ((_e = options2 == null ? void 0 : options2.tools) == null ? void 0 : _e.some(isCustomTool));
    return this.useResponsesApi || usesBuiltInTools || hasResponsesOnlyKwargs || hasCustomTools;
  }
  getLsParams(options2) {
    const optionsWithDefaults = this._combineCallOptions(options2);
    if (this._useResponsesApi(options2)) return this.responses.getLsParams(optionsWithDefaults);
    return this.completions.getLsParams(optionsWithDefaults);
  }
  invocationParams(options2) {
    const optionsWithDefaults = this._combineCallOptions(options2);
    if (this._useResponsesApi(options2)) return this.responses.invocationParams(optionsWithDefaults);
    return this.completions.invocationParams(optionsWithDefaults);
  }
  /** @ignore */
  async _generate(messages, options2, runManager) {
    if (this._useResponsesApi(options2)) return this.responses._generate(messages, options2);
    return this.completions._generate(messages, options2, runManager);
  }
  async *_streamResponseChunks(messages, options2, runManager) {
    if (this._useResponsesApi(options2)) {
      yield* this.responses._streamResponseChunks(messages, this._combineCallOptions(options2), runManager);
      return;
    }
    yield* this.completions._streamResponseChunks(messages, this._combineCallOptions(options2), runManager);
  }
  withConfig(config2) {
    const newModel = new ChatOpenAI2(this.fields);
    newModel.defaultOptions = {
      ...this.defaultOptions,
      ...config2
    };
    return newModel;
  }
};
var llms_exports = {};
__export(llms_exports, {
  BaseLLM: () => BaseLLM,
  LLM: () => LLM
});
var BaseLLM = class BaseLLM2 extends BaseLanguageModel {
  constructor() {
    super(...arguments);
    __publicField2(this, "lc_namespace", [
      "langchain",
      "llms",
      this._llmType()
    ]);
  }
  /**
  * This method takes an input and options, and returns a string. It
  * converts the input to a prompt value and generates a result based on
  * the prompt.
  * @param input Input for the LLM.
  * @param options Options for the LLM call.
  * @returns A string result based on the prompt.
  */
  async invoke(input, options2) {
    const promptValue = BaseLLM2._convertInputToPromptValue(input);
    const result = await this.generatePrompt([promptValue], options2, options2 == null ? void 0 : options2.callbacks);
    return result.generations[0][0].text;
  }
  async *_streamResponseChunks(_input, _options, _runManager) {
    throw new Error("Not implemented.");
  }
  _separateRunnableConfigFromCallOptionsCompat(options2) {
    const [runnableConfig, callOptions] = super._separateRunnableConfigFromCallOptions(options2);
    callOptions.signal = runnableConfig.signal;
    return [runnableConfig, callOptions];
  }
  async *_streamIterator(input, options2) {
    if (this._streamResponseChunks === BaseLLM2.prototype._streamResponseChunks) yield this.invoke(input, options2);
    else {
      const prompt = BaseLLM2._convertInputToPromptValue(input);
      const [runnableConfig, callOptions] = this._separateRunnableConfigFromCallOptionsCompat(options2);
      const callbackManager_ = await CallbackManager.configure(runnableConfig.callbacks, this.callbacks, runnableConfig.tags, this.tags, runnableConfig.metadata, this.metadata, { verbose: this.verbose });
      const extra = {
        options: callOptions,
        invocation_params: this == null ? void 0 : this.invocationParams(callOptions),
        batch_size: 1
      };
      const runManagers = await (callbackManager_ == null ? void 0 : callbackManager_.handleLLMStart(this.toJSON(), [prompt.toString()], runnableConfig.runId, void 0, extra, void 0, void 0, runnableConfig.runName));
      let generation = new GenerationChunk({ text: "" });
      try {
        for await (const chunk of this._streamResponseChunks(prompt.toString(), callOptions, runManagers == null ? void 0 : runManagers[0])) {
          if (!generation) generation = chunk;
          else generation = generation.concat(chunk);
          if (typeof chunk.text === "string") yield chunk.text;
        }
      } catch (err) {
        await Promise.all((runManagers ?? []).map((runManager) => runManager == null ? void 0 : runManager.handleLLMError(err)));
        throw err;
      }
      await Promise.all((runManagers ?? []).map((runManager) => runManager == null ? void 0 : runManager.handleLLMEnd({ generations: [[generation]] })));
    }
  }
  /**
  * This method takes prompt values, options, and callbacks, and generates
  * a result based on the prompts.
  * @param promptValues Prompt values for the LLM.
  * @param options Options for the LLM call.
  * @param callbacks Callbacks for the LLM call.
  * @returns An LLMResult based on the prompts.
  */
  async generatePrompt(promptValues, options2, callbacks) {
    const prompts = promptValues.map((promptValue) => promptValue.toString());
    return this.generate(prompts, options2, callbacks);
  }
  /**
  * Get the parameters used to invoke the model
  */
  invocationParams(_options) {
    return {};
  }
  _flattenLLMResult(llmResult) {
    const llmResults = [];
    for (let i2 = 0; i2 < llmResult.generations.length; i2 += 1) {
      const genList = llmResult.generations[i2];
      if (i2 === 0) llmResults.push({
        generations: [genList],
        llmOutput: llmResult.llmOutput
      });
      else {
        const llmOutput = llmResult.llmOutput ? {
          ...llmResult.llmOutput,
          tokenUsage: {}
        } : void 0;
        llmResults.push({
          generations: [genList],
          llmOutput
        });
      }
    }
    return llmResults;
  }
  /** @ignore */
  async _generateUncached(prompts, parsedOptions, handledOptions, startedRunManagers) {
    let runManagers;
    if (startedRunManagers !== void 0 && startedRunManagers.length === prompts.length) runManagers = startedRunManagers;
    else {
      const callbackManager_ = await CallbackManager.configure(handledOptions.callbacks, this.callbacks, handledOptions.tags, this.tags, handledOptions.metadata, this.metadata, { verbose: this.verbose });
      const extra = {
        options: parsedOptions,
        invocation_params: this == null ? void 0 : this.invocationParams(parsedOptions),
        batch_size: prompts.length
      };
      runManagers = await (callbackManager_ == null ? void 0 : callbackManager_.handleLLMStart(this.toJSON(), prompts, handledOptions.runId, void 0, extra, void 0, void 0, handledOptions == null ? void 0 : handledOptions.runName));
    }
    const hasStreamingHandler = !!(runManagers == null ? void 0 : runManagers[0].handlers.find(callbackHandlerPrefersStreaming));
    let output;
    if (hasStreamingHandler && prompts.length === 1 && this._streamResponseChunks !== BaseLLM2.prototype._streamResponseChunks) try {
      const stream = await this._streamResponseChunks(prompts[0], parsedOptions, runManagers == null ? void 0 : runManagers[0]);
      let aggregated;
      for await (const chunk of stream) if (aggregated === void 0) aggregated = chunk;
      else aggregated = concat(aggregated, chunk);
      if (aggregated === void 0) throw new Error("Received empty response from chat model call.");
      output = {
        generations: [[aggregated]],
        llmOutput: {}
      };
      await (runManagers == null ? void 0 : runManagers[0].handleLLMEnd(output));
    } catch (e) {
      await (runManagers == null ? void 0 : runManagers[0].handleLLMError(e));
      throw e;
    }
    else {
      try {
        output = await this._generate(prompts, parsedOptions, runManagers == null ? void 0 : runManagers[0]);
      } catch (err) {
        await Promise.all((runManagers ?? []).map((runManager) => runManager == null ? void 0 : runManager.handleLLMError(err)));
        throw err;
      }
      const flattenedOutputs = this._flattenLLMResult(output);
      await Promise.all((runManagers ?? []).map((runManager, i2) => runManager == null ? void 0 : runManager.handleLLMEnd(flattenedOutputs[i2])));
    }
    const runIds = (runManagers == null ? void 0 : runManagers.map((manager) => manager.runId)) || void 0;
    Object.defineProperty(output, RUN_KEY, {
      value: runIds ? { runIds } : void 0,
      configurable: true
    });
    return output;
  }
  async _generateCached({ prompts, cache: cache2, llmStringKey, parsedOptions, handledOptions, runId }) {
    const callbackManager_ = await CallbackManager.configure(handledOptions.callbacks, this.callbacks, handledOptions.tags, this.tags, handledOptions.metadata, this.metadata, { verbose: this.verbose });
    const extra = {
      options: parsedOptions,
      invocation_params: this == null ? void 0 : this.invocationParams(parsedOptions),
      batch_size: prompts.length
    };
    const runManagers = await (callbackManager_ == null ? void 0 : callbackManager_.handleLLMStart(this.toJSON(), prompts, runId, void 0, extra, void 0, void 0, handledOptions == null ? void 0 : handledOptions.runName));
    const missingPromptIndices = [];
    const results2 = await Promise.allSettled(prompts.map(async (prompt, index) => {
      const result = await cache2.lookup(prompt, llmStringKey);
      if (result == null) missingPromptIndices.push(index);
      return result;
    }));
    const cachedResults = results2.map((result, index) => ({
      result,
      runManager: runManagers == null ? void 0 : runManagers[index]
    })).filter(({ result }) => result.status === "fulfilled" && result.value != null || result.status === "rejected");
    const generations = [];
    await Promise.all(cachedResults.map(async ({ result: promiseResult, runManager }, i2) => {
      if (promiseResult.status === "fulfilled") {
        const result = promiseResult.value;
        generations[i2] = result.map((result$1) => {
          result$1.generationInfo = {
            ...result$1.generationInfo,
            tokenUsage: {}
          };
          return result$1;
        });
        if (result.length) await (runManager == null ? void 0 : runManager.handleLLMNewToken(result[0].text));
        return runManager == null ? void 0 : runManager.handleLLMEnd({ generations: [result] }, void 0, void 0, void 0, { cached: true });
      } else {
        await (runManager == null ? void 0 : runManager.handleLLMError(promiseResult.reason, void 0, void 0, void 0, { cached: true }));
        return Promise.reject(promiseResult.reason);
      }
    }));
    const output = {
      generations,
      missingPromptIndices,
      startedRunManagers: runManagers
    };
    Object.defineProperty(output, RUN_KEY, {
      value: runManagers ? { runIds: runManagers == null ? void 0 : runManagers.map((manager) => manager.runId) } : void 0,
      configurable: true
    });
    return output;
  }
  /**
  * Run the LLM on the given prompts and input, handling caching.
  */
  async generate(prompts, options2, callbacks) {
    if (!Array.isArray(prompts)) throw new Error("Argument 'prompts' is expected to be a string[]");
    let parsedOptions;
    if (Array.isArray(options2)) parsedOptions = { stop: options2 };
    else parsedOptions = options2;
    const [runnableConfig, callOptions] = this._separateRunnableConfigFromCallOptionsCompat(parsedOptions);
    runnableConfig.callbacks = runnableConfig.callbacks ?? callbacks;
    if (!this.cache) return this._generateUncached(prompts, callOptions, runnableConfig);
    const { cache: cache2 } = this;
    const llmStringKey = this._getSerializedCacheKeyParametersForCall(callOptions);
    const { generations, missingPromptIndices, startedRunManagers } = await this._generateCached({
      prompts,
      cache: cache2,
      llmStringKey,
      parsedOptions: callOptions,
      handledOptions: runnableConfig,
      runId: runnableConfig.runId
    });
    let llmOutput = {};
    if (missingPromptIndices.length > 0) {
      const results2 = await this._generateUncached(missingPromptIndices.map((i2) => prompts[i2]), callOptions, runnableConfig, startedRunManagers !== void 0 ? missingPromptIndices.map((i2) => startedRunManagers == null ? void 0 : startedRunManagers[i2]) : void 0);
      await Promise.all(results2.generations.map(async (generation, index) => {
        const promptIndex = missingPromptIndices[index];
        generations[promptIndex] = generation;
        return cache2.update(prompts[promptIndex], llmStringKey, generation);
      }));
      llmOutput = results2.llmOutput ?? {};
    }
    return {
      generations,
      llmOutput
    };
  }
  /**
  * Get the identifying parameters of the LLM.
  */
  _identifyingParams() {
    return {};
  }
  _modelType() {
    return "base_llm";
  }
};
var LLM = class extends BaseLLM {
  async _generate(prompts, options2, runManager) {
    const generations = await Promise.all(prompts.map((prompt, promptIndex) => this._call(prompt, {
      ...options2,
      promptIndex
    }, runManager).then((text) => [{ text }])));
    return { generations };
  }
};
var chunk_array_exports = {};
__export(chunk_array_exports, { chunkArray: () => chunkArray });
const chunkArray = (arr2, chunkSize) => arr2.reduce((chunks, elem, index) => {
  const chunkIndex = Math.floor(index / chunkSize);
  const chunk = chunks[chunkIndex] || [];
  chunks[chunkIndex] = chunk.concat([elem]);
  return chunks;
}, []);
var embeddings_exports = {};
__export(embeddings_exports, { Embeddings: () => Embeddings });
var Embeddings = class {
  constructor(params) {
    /**
    * The async caller should be used by subclasses to make any async calls,
    * which will thus benefit from the concurrency and retry logic.
    */
    __publicField2(this, "caller");
    this.caller = new AsyncCaller(params ?? {});
  }
};
var tools_exports = {};
__export(tools_exports, {
  BaseToolkit: () => BaseToolkit,
  DynamicStructuredTool: () => DynamicStructuredTool,
  DynamicTool: () => DynamicTool,
  StructuredTool: () => StructuredTool,
  Tool: () => Tool,
  ToolInputParsingException: () => ToolInputParsingException,
  isLangChainTool: () => isLangChainTool,
  isRunnableToolLike: () => isRunnableToolLike,
  isStructuredTool: () => isStructuredTool,
  isStructuredToolParams: () => isStructuredToolParams,
  tool: () => tool
});
var StructuredTool = class extends BaseLangChain {
  constructor(fields) {
    super(fields ?? {});
    /**
    * Optional provider-specific extra fields for the tool.
    *
    * This is used to pass provider-specific configuration that doesn't fit into
    * standard tool fields.
    */
    __publicField2(this, "extras");
    /**
    * Whether to return the tool's output directly.
    *
    * Setting this to true means that after the tool is called,
    * an agent should stop looping.
    */
    __publicField2(this, "returnDirect", false);
    __publicField2(this, "verboseParsingErrors", false);
    /**
    * The tool response format.
    *
    * If "content" then the output of the tool is interpreted as the contents of a
    * ToolMessage. If "content_and_artifact" then the output is expected to be a
    * two-tuple corresponding to the (content, artifact) of a ToolMessage.
    *
    * @default "content"
    */
    __publicField2(this, "responseFormat", "content");
    /**
    * Default config object for the tool runnable.
    */
    __publicField2(this, "defaultConfig");
    this.verboseParsingErrors = (fields == null ? void 0 : fields.verboseParsingErrors) ?? this.verboseParsingErrors;
    this.responseFormat = (fields == null ? void 0 : fields.responseFormat) ?? this.responseFormat;
    this.defaultConfig = (fields == null ? void 0 : fields.defaultConfig) ?? this.defaultConfig;
    this.metadata = (fields == null ? void 0 : fields.metadata) ?? this.metadata;
    this.extras = (fields == null ? void 0 : fields.extras) ?? this.extras;
  }
  get lc_namespace() {
    return ["langchain", "tools"];
  }
  /**
  * Invokes the tool with the provided input and configuration.
  * @param input The input for the tool.
  * @param config Optional configuration for the tool.
  * @returns A Promise that resolves with the tool's output.
  */
  async invoke(input, config2) {
    let toolInput;
    let enrichedConfig = ensureConfig(mergeConfigs(this.defaultConfig, config2));
    if (_isToolCall(input)) {
      toolInput = input.args;
      enrichedConfig = {
        ...enrichedConfig,
        toolCall: input
      };
    } else toolInput = input;
    return this.call(toolInput, enrichedConfig);
  }
  /**
  * @deprecated Use .invoke() instead. Will be removed in 0.3.0.
  *
  * Calls the tool with the provided argument, configuration, and tags. It
  * parses the input according to the schema, handles any errors, and
  * manages callbacks.
  * @param arg The input argument for the tool.
  * @param configArg Optional configuration or callbacks for the tool.
  * @param tags Optional tags for the tool.
  * @returns A Promise that resolves with a string.
  */
  async call(arg, configArg, tags) {
    const inputForValidation = _isToolCall(arg) ? arg.args : arg;
    let parsed;
    if (isInteropZodSchema(this.schema)) try {
      parsed = await interopParseAsync(this.schema, inputForValidation);
    } catch (e) {
      let message = `Received tool input did not match expected schema`;
      if (this.verboseParsingErrors) message = `${message}
Details: ${e.message}`;
      if (isInteropZodError(e)) message = `${message}

${prettifyError(e)}`;
      throw new ToolInputParsingException(message, JSON.stringify(arg));
    }
    else {
      const result$1 = validate(inputForValidation, this.schema);
      if (!result$1.valid) {
        let message = `Received tool input did not match expected schema`;
        if (this.verboseParsingErrors) message = `${message}
Details: ${result$1.errors.map((e) => `${e.keywordLocation}: ${e.error}`).join("\n")}`;
        throw new ToolInputParsingException(message, JSON.stringify(arg));
      }
      parsed = inputForValidation;
    }
    const config2 = parseCallbackConfigArg(configArg);
    const callbackManager_ = CallbackManager.configure(config2.callbacks, this.callbacks, config2.tags || tags, this.tags, config2.metadata, this.metadata, { verbose: this.verbose });
    const runManager = await (callbackManager_ == null ? void 0 : callbackManager_.handleToolStart(this.toJSON(), typeof arg === "string" ? arg : JSON.stringify(arg), config2.runId, void 0, void 0, void 0, config2.runName));
    delete config2.runId;
    let result;
    try {
      result = await this._call(parsed, runManager, config2);
    } catch (e) {
      await (runManager == null ? void 0 : runManager.handleToolError(e));
      throw e;
    }
    let content;
    let artifact;
    if (this.responseFormat === "content_and_artifact") if (Array.isArray(result) && result.length === 2) [content, artifact] = result;
    else throw new Error(`Tool response format is "content_and_artifact" but the output was not a two-tuple.
Result: ${JSON.stringify(result)}`);
    else content = result;
    let toolCallId;
    if (_isToolCall(arg)) toolCallId = arg.id;
    if (!toolCallId && _configHasToolCallId(config2)) toolCallId = config2.toolCall.id;
    const formattedOutput = _formatToolOutput({
      content,
      artifact,
      toolCallId,
      name: this.name,
      metadata: this.metadata
    });
    await (runManager == null ? void 0 : runManager.handleToolEnd(formattedOutput));
    return formattedOutput;
  }
};
var Tool = class extends StructuredTool {
  constructor(fields) {
    super(fields);
    __publicField2(this, "schema", objectType({ input: stringType().optional() }).transform((obj) => obj.input));
  }
  /**
  * @deprecated Use .invoke() instead. Will be removed in 0.3.0.
  *
  * Calls the tool with the provided argument and callbacks. It handles
  * string inputs specifically.
  * @param arg The input argument for the tool, which can be a string, undefined, or an input of the tool's schema.
  * @param callbacks Optional callbacks for the tool.
  * @returns A Promise that resolves with a string.
  */
  call(arg, callbacks) {
    const structuredArg = typeof arg === "string" || arg == null ? { input: arg } : arg;
    return super.call(structuredArg, callbacks);
  }
};
var DynamicTool = class extends Tool {
  constructor(fields) {
    super(fields);
    __publicField2(this, "name");
    __publicField2(this, "description");
    __publicField2(this, "func");
    this.name = fields.name;
    this.description = fields.description;
    this.func = fields.func;
    this.returnDirect = fields.returnDirect ?? this.returnDirect;
  }
  static lc_name() {
    return "DynamicTool";
  }
  /**
  * @deprecated Use .invoke() instead. Will be removed in 0.3.0.
  */
  async call(arg, configArg) {
    const config2 = parseCallbackConfigArg(configArg);
    if (config2.runName === void 0) config2.runName = this.name;
    return super.call(arg, config2);
  }
  /** @ignore */
  async _call(input, runManager, parentConfig) {
    return this.func(input, runManager, parentConfig);
  }
};
var DynamicStructuredTool = class extends StructuredTool {
  constructor(fields) {
    super(fields);
    __publicField2(this, "name");
    __publicField2(this, "description");
    __publicField2(this, "func");
    __publicField2(this, "schema");
    this.name = fields.name;
    this.description = fields.description;
    this.func = fields.func;
    this.returnDirect = fields.returnDirect ?? this.returnDirect;
    this.schema = fields.schema;
  }
  static lc_name() {
    return "DynamicStructuredTool";
  }
  /**
  * @deprecated Use .invoke() instead. Will be removed in 0.3.0.
  */
  async call(arg, configArg, tags) {
    const config2 = parseCallbackConfigArg(configArg);
    if (config2.runName === void 0) config2.runName = this.name;
    return super.call(arg, config2, tags);
  }
  _call(arg, runManager, parentConfig) {
    return this.func(arg, runManager, parentConfig);
  }
};
var BaseToolkit = class {
  getTools() {
    return this.tools;
  }
};
function tool(func, fields) {
  var _a3;
  const isSimpleStringSchema = isSimpleStringZodSchema(fields.schema);
  const isStringJSONSchema = validatesOnlyStrings(fields.schema);
  if (!fields.schema || isSimpleStringSchema || isStringJSONSchema) return new DynamicTool({
    ...fields,
    description: fields.description ?? ((_a3 = fields.schema) == null ? void 0 : _a3.description) ?? `${fields.name} tool`,
    func: async (input, runManager, config2) => {
      return new Promise((resolve, reject) => {
        const childConfig = patchConfig(config2, { callbacks: runManager == null ? void 0 : runManager.getChild() });
        AsyncLocalStorageProviderSingleton.runWithConfig(pickRunnableConfigKeys(childConfig), async () => {
          try {
            resolve(func(input, childConfig));
          } catch (e) {
            reject(e);
          }
        });
      });
    }
  });
  const schema = fields.schema;
  const description = fields.description ?? fields.schema.description ?? `${fields.name} tool`;
  return new DynamicStructuredTool({
    ...fields,
    description,
    schema,
    func: async (input, runManager, config2) => {
      return new Promise((resolve, reject) => {
        let listener;
        const cleanup = () => {
          if ((config2 == null ? void 0 : config2.signal) && listener) config2.signal.removeEventListener("abort", listener);
        };
        if (config2 == null ? void 0 : config2.signal) {
          listener = () => {
            cleanup();
            reject(getAbortSignalError(config2.signal));
          };
          config2.signal.addEventListener("abort", listener);
        }
        const childConfig = patchConfig(config2, { callbacks: runManager == null ? void 0 : runManager.getChild() });
        AsyncLocalStorageProviderSingleton.runWithConfig(pickRunnableConfigKeys(childConfig), async () => {
          var _a4;
          try {
            const result = await func(input, childConfig);
            if ((_a4 = config2 == null ? void 0 : config2.signal) == null ? void 0 : _a4.aborted) {
              cleanup();
              return;
            }
            cleanup();
            resolve(result);
          } catch (e) {
            cleanup();
            reject(e);
          }
        });
      });
    }
  });
}
function _formatToolOutput(params) {
  const { content, artifact, toolCallId, metadata } = params;
  if (toolCallId && !isDirectToolOutput(content)) if (typeof content === "string" || Array.isArray(content) && content.every((item) => typeof item === "object")) return new ToolMessage({
    status: "success",
    content,
    artifact,
    tool_call_id: toolCallId,
    name: params.name,
    metadata
  });
  else return new ToolMessage({
    status: "success",
    content: _stringify(content),
    artifact,
    tool_call_id: toolCallId,
    name: params.name,
    metadata
  });
  else return content;
}
function _stringify(content) {
  try {
    return JSON.stringify(content, null, 2) ?? "";
  } catch (_noOp) {
    return `${content}`;
  }
}
var main = { exports: {} };
const version$1 = "17.2.3";
const require$$4 = {
  version: version$1
};
const fs = require$$0;
const path = path__default;
const os = require$$2;
const crypto$1 = crypto$3;
const packageJson = require$$4;
const version = packageJson.version;
const TIPS = [
  "ðŸ” encrypt with Dotenvx: https://dotenvx.com",
  "ðŸ” prevent committing .env to code: https://dotenvx.com/precommit",
  "ðŸ” prevent building .env in docker: https://dotenvx.com/prebuild",
  "ðŸ“¡ add observability to secrets: https://dotenvx.com/ops",
  "ðŸ‘¥ sync secrets across teammates & machines: https://dotenvx.com/ops",
  "ðŸ—‚ï¸ backup and recover secrets: https://dotenvx.com/ops",
  "âœ… audit secrets and track compliance: https://dotenvx.com/ops",
  "ðŸ”„ add secrets lifecycle management: https://dotenvx.com/ops",
  "ðŸ”‘ add access controls to secrets: https://dotenvx.com/ops",
  "ðŸ› ï¸  run anywhere with `dotenvx run -- yourcommand`",
  "âš™ï¸  specify custom .env file path with { path: '/custom/path/.env' }",
  "âš™ï¸  enable debug logging with { debug: true }",
  "âš™ï¸  override existing env vars with { override: true }",
  "âš™ï¸  suppress all logs with { quiet: true }",
  "âš™ï¸  write to custom object with { processEnv: myObject }",
  "âš™ï¸  load multiple .env files with { path: ['.env.local', '.env'] }"
];
function _getRandomTip() {
  return TIPS[Math.floor(Math.random() * TIPS.length)];
}
function parseBoolean(value) {
  if (typeof value === "string") {
    return !["false", "0", "no", "off", ""].includes(value.toLowerCase());
  }
  return Boolean(value);
}
function supportsAnsi() {
  return process.stdout.isTTY;
}
function dim(text) {
  return supportsAnsi() ? `\x1B[2m${text}\x1B[0m` : text;
}
const LINE = /(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/mg;
function parse(src) {
  const obj = {};
  let lines = src.toString();
  lines = lines.replace(/\r\n?/mg, "\n");
  let match;
  while ((match = LINE.exec(lines)) != null) {
    const key = match[1];
    let value = match[2] || "";
    value = value.trim();
    const maybeQuote = value[0];
    value = value.replace(/^(['"`])([\s\S]*)\1$/mg, "$2");
    if (maybeQuote === '"') {
      value = value.replace(/\\n/g, "\n");
      value = value.replace(/\\r/g, "\r");
    }
    obj[key] = value;
  }
  return obj;
}
function _parseVault(options2) {
  options2 = options2 || {};
  const vaultPath = _vaultPath(options2);
  options2.path = vaultPath;
  const result = DotenvModule.configDotenv(options2);
  if (!result.parsed) {
    const err = new Error(`MISSING_DATA: Cannot parse ${vaultPath} for an unknown reason`);
    err.code = "MISSING_DATA";
    throw err;
  }
  const keys = _dotenvKey(options2).split(",");
  const length = keys.length;
  let decrypted;
  for (let i2 = 0; i2 < length; i2++) {
    try {
      const key = keys[i2].trim();
      const attrs = _instructions(result, key);
      decrypted = DotenvModule.decrypt(attrs.ciphertext, attrs.key);
      break;
    } catch (error) {
      if (i2 + 1 >= length) {
        throw error;
      }
    }
  }
  return DotenvModule.parse(decrypted);
}
function _warn(message) {
  console.error(`[dotenv@${version}][WARN] ${message}`);
}
function _debug(message) {
  console.log(`[dotenv@${version}][DEBUG] ${message}`);
}
function _log(message) {
  console.log(`[dotenv@${version}] ${message}`);
}
function _dotenvKey(options2) {
  if (options2 && options2.DOTENV_KEY && options2.DOTENV_KEY.length > 0) {
    return options2.DOTENV_KEY;
  }
  if (process.env.DOTENV_KEY && process.env.DOTENV_KEY.length > 0) {
    return process.env.DOTENV_KEY;
  }
  return "";
}
function _instructions(result, dotenvKey) {
  let uri2;
  try {
    uri2 = new URL(dotenvKey);
  } catch (error) {
    if (error.code === "ERR_INVALID_URL") {
      const err = new Error("INVALID_DOTENV_KEY: Wrong format. Must be in valid uri format like dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=development");
      err.code = "INVALID_DOTENV_KEY";
      throw err;
    }
    throw error;
  }
  const key = uri2.password;
  if (!key) {
    const err = new Error("INVALID_DOTENV_KEY: Missing key part");
    err.code = "INVALID_DOTENV_KEY";
    throw err;
  }
  const environment = uri2.searchParams.get("environment");
  if (!environment) {
    const err = new Error("INVALID_DOTENV_KEY: Missing environment part");
    err.code = "INVALID_DOTENV_KEY";
    throw err;
  }
  const environmentKey = `DOTENV_VAULT_${environment.toUpperCase()}`;
  const ciphertext = result.parsed[environmentKey];
  if (!ciphertext) {
    const err = new Error(`NOT_FOUND_DOTENV_ENVIRONMENT: Cannot locate environment ${environmentKey} in your .env.vault file.`);
    err.code = "NOT_FOUND_DOTENV_ENVIRONMENT";
    throw err;
  }
  return { ciphertext, key };
}
function _vaultPath(options2) {
  let possibleVaultPath = null;
  if (options2 && options2.path && options2.path.length > 0) {
    if (Array.isArray(options2.path)) {
      for (const filepath of options2.path) {
        if (fs.existsSync(filepath)) {
          possibleVaultPath = filepath.endsWith(".vault") ? filepath : `${filepath}.vault`;
        }
      }
    } else {
      possibleVaultPath = options2.path.endsWith(".vault") ? options2.path : `${options2.path}.vault`;
    }
  } else {
    possibleVaultPath = path.resolve(process.cwd(), ".env.vault");
  }
  if (fs.existsSync(possibleVaultPath)) {
    return possibleVaultPath;
  }
  return null;
}
function _resolveHome(envPath) {
  return envPath[0] === "~" ? path.join(os.homedir(), envPath.slice(1)) : envPath;
}
function _configVault(options2) {
  const debug2 = parseBoolean(process.env.DOTENV_CONFIG_DEBUG || options2 && options2.debug);
  const quiet = parseBoolean(process.env.DOTENV_CONFIG_QUIET || options2 && options2.quiet);
  if (debug2 || !quiet) {
    _log("Loading env from encrypted .env.vault");
  }
  const parsed = DotenvModule._parseVault(options2);
  let processEnv = process.env;
  if (options2 && options2.processEnv != null) {
    processEnv = options2.processEnv;
  }
  DotenvModule.populate(processEnv, parsed, options2);
  return { parsed };
}
function configDotenv(options2) {
  const dotenvPath = path.resolve(process.cwd(), ".env");
  let encoding = "utf8";
  let processEnv = process.env;
  if (options2 && options2.processEnv != null) {
    processEnv = options2.processEnv;
  }
  let debug2 = parseBoolean(processEnv.DOTENV_CONFIG_DEBUG || options2 && options2.debug);
  let quiet = parseBoolean(processEnv.DOTENV_CONFIG_QUIET || options2 && options2.quiet);
  if (options2 && options2.encoding) {
    encoding = options2.encoding;
  } else {
    if (debug2) {
      _debug("No encoding is specified. UTF-8 is used by default");
    }
  }
  let optionPaths = [dotenvPath];
  if (options2 && options2.path) {
    if (!Array.isArray(options2.path)) {
      optionPaths = [_resolveHome(options2.path)];
    } else {
      optionPaths = [];
      for (const filepath of options2.path) {
        optionPaths.push(_resolveHome(filepath));
      }
    }
  }
  let lastError;
  const parsedAll = {};
  for (const path2 of optionPaths) {
    try {
      const parsed = DotenvModule.parse(fs.readFileSync(path2, { encoding }));
      DotenvModule.populate(parsedAll, parsed, options2);
    } catch (e) {
      if (debug2) {
        _debug(`Failed to load ${path2} ${e.message}`);
      }
      lastError = e;
    }
  }
  const populated = DotenvModule.populate(processEnv, parsedAll, options2);
  debug2 = parseBoolean(processEnv.DOTENV_CONFIG_DEBUG || debug2);
  quiet = parseBoolean(processEnv.DOTENV_CONFIG_QUIET || quiet);
  if (debug2 || !quiet) {
    const keysCount = Object.keys(populated).length;
    const shortPaths = [];
    for (const filePath of optionPaths) {
      try {
        const relative = path.relative(process.cwd(), filePath);
        shortPaths.push(relative);
      } catch (e) {
        if (debug2) {
          _debug(`Failed to load ${filePath} ${e.message}`);
        }
        lastError = e;
      }
    }
    _log(`injecting env (${keysCount}) from ${shortPaths.join(",")} ${dim(`-- tip: ${_getRandomTip()}`)}`);
  }
  if (lastError) {
    return { parsed: parsedAll, error: lastError };
  } else {
    return { parsed: parsedAll };
  }
}
function config(options2) {
  if (_dotenvKey(options2).length === 0) {
    return DotenvModule.configDotenv(options2);
  }
  const vaultPath = _vaultPath(options2);
  if (!vaultPath) {
    _warn(`You set DOTENV_KEY but you are missing a .env.vault file at ${vaultPath}. Did you forget to build it?`);
    return DotenvModule.configDotenv(options2);
  }
  return DotenvModule._configVault(options2);
}
function decrypt(encrypted, keyStr) {
  const key = Buffer.from(keyStr.slice(-64), "hex");
  let ciphertext = Buffer.from(encrypted, "base64");
  const nonce = ciphertext.subarray(0, 12);
  const authTag = ciphertext.subarray(-16);
  ciphertext = ciphertext.subarray(12, -16);
  try {
    const aesgcm = crypto$1.createDecipheriv("aes-256-gcm", key, nonce);
    aesgcm.setAuthTag(authTag);
    return `${aesgcm.update(ciphertext)}${aesgcm.final()}`;
  } catch (error) {
    const isRange = error instanceof RangeError;
    const invalidKeyLength = error.message === "Invalid key length";
    const decryptionFailed = error.message === "Unsupported state or unable to authenticate data";
    if (isRange || invalidKeyLength) {
      const err = new Error("INVALID_DOTENV_KEY: It must be 64 characters long (or more)");
      err.code = "INVALID_DOTENV_KEY";
      throw err;
    } else if (decryptionFailed) {
      const err = new Error("DECRYPTION_FAILED: Please check your DOTENV_KEY");
      err.code = "DECRYPTION_FAILED";
      throw err;
    } else {
      throw error;
    }
  }
}
function populate(processEnv, parsed, options2 = {}) {
  const debug2 = Boolean(options2 && options2.debug);
  const override = Boolean(options2 && options2.override);
  const populated = {};
  if (typeof parsed !== "object") {
    const err = new Error("OBJECT_REQUIRED: Please check the processEnv argument being passed to populate");
    err.code = "OBJECT_REQUIRED";
    throw err;
  }
  for (const key of Object.keys(parsed)) {
    if (Object.prototype.hasOwnProperty.call(processEnv, key)) {
      if (override === true) {
        processEnv[key] = parsed[key];
        populated[key] = parsed[key];
      }
      if (debug2) {
        if (override === true) {
          _debug(`"${key}" is already defined and WAS overwritten`);
        } else {
          _debug(`"${key}" is already defined and was NOT overwritten`);
        }
      }
    } else {
      processEnv[key] = parsed[key];
      populated[key] = parsed[key];
    }
  }
  return populated;
}
const DotenvModule = {
  configDotenv,
  _configVault,
  _parseVault,
  config,
  decrypt,
  parse,
  populate
};
main.exports.configDotenv = DotenvModule.configDotenv;
main.exports._configVault = DotenvModule._configVault;
main.exports._parseVault = DotenvModule._parseVault;
main.exports.config = DotenvModule.config;
main.exports.decrypt = DotenvModule.decrypt;
main.exports.parse = DotenvModule.parse;
main.exports.populate = DotenvModule.populate;
main.exports = DotenvModule;
var mainExports = main.exports;
const dotenv = /* @__PURE__ */ getDefaultExportFromCjs(mainExports);
class AgentRunContext {
  constructor() {
    __publicField2(this, "storage", new AsyncLocalStorage());
  }
  run(store, fn) {
    if (!store.loop) {
      store.loop = {
        urlCounts: /* @__PURE__ */ new Map(),
        toolSigCounts: /* @__PURE__ */ new Map()
      };
    }
    return this.storage.run(store, fn);
  }
  getRunId() {
    var _a3;
    return ((_a3 = this.storage.getStore()) == null ? void 0 : _a3.runId) ?? null;
  }
  getRequesterWebContentsId() {
    var _a3;
    return ((_a3 = this.storage.getStore()) == null ? void 0 : _a3.requesterWebContentsId) ?? null;
  }
  getBrowserContext() {
    var _a3;
    return ((_a3 = this.storage.getStore()) == null ? void 0 : _a3.browserContext) ?? null;
  }
  setBrowserContext(context) {
    const store = this.storage.getStore();
    if (store) {
      store.browserContext = context;
      const url = typeof (context == null ? void 0 : context.url) === "string" ? context.url : void 0;
      if (url) this.recordUrlVisit(url);
    }
  }
  recordUrlVisit(url) {
    const store = this.storage.getStore();
    if (!(store == null ? void 0 : store.loop)) return;
    const key = String(url);
    const next = (store.loop.urlCounts.get(key) ?? 0) + 1;
    store.loop.urlCounts.set(key, next);
    if (next > 3) {
      store.loop.alert = { kind: "url", key, count: next };
    }
  }
  recordToolCall(toolName, args) {
    const store = this.storage.getStore();
    if (!(store == null ? void 0 : store.loop)) return;
    const argsJson = (() => {
      try {
        return JSON.stringify(args ?? null);
      } catch {
        return "[unserializable_args]";
      }
    })();
    const argsHash = crypto$2.createHash("sha256").update(argsJson).digest("hex");
    const sig = `${toolName}:${argsHash}`;
    const next = (store.loop.toolSigCounts.get(sig) ?? 0) + 1;
    store.loop.toolSigCounts.set(sig, next);
    if (next > 3) {
      store.loop.alert = { kind: "tool", key: sig, count: next };
    }
    if (toolName === "browser_navigate" && typeof (args == null ? void 0 : args.url) === "string") {
      this.recordUrlVisit(args.url);
    }
  }
  consumeLoopAlert() {
    var _a3;
    const store = this.storage.getStore();
    if (!((_a3 = store == null ? void 0 : store.loop) == null ? void 0 : _a3.alert)) return null;
    const v = store.loop.alert;
    store.loop.alert = void 0;
    return v;
  }
  getObserveOnly() {
    var _a3;
    return ((_a3 = this.storage.getStore()) == null ? void 0 : _a3.observeOnly) ?? false;
  }
  setObserveOnly(observeOnly) {
    const store = this.storage.getStore();
    if (store) {
      store.observeOnly = observeOnly;
    }
  }
  getPermissionMode() {
    var _a3;
    return ((_a3 = this.storage.getStore()) == null ? void 0 : _a3.permissionMode) ?? "permissions";
  }
  getYoloMode() {
    var _a3;
    return ((_a3 = this.storage.getStore()) == null ? void 0 : _a3.permissionMode) === "yolo";
  }
  setPermissionMode(mode) {
    const store = this.storage.getStore();
    if (store) {
      store.permissionMode = mode;
    }
  }
}
const agentRunContext = new AgentRunContext();
class TelemetryService {
  constructor() {
    __publicField2(this, "baseDir", null);
  }
  getBaseDir() {
    if (this.baseDir) return this.baseDir;
    const userData = app$1.getPath("userData");
    this.baseDir = path__default$1.join(userData, "telemetry");
    return this.baseDir;
  }
  async ensureDir() {
    await fs$3.mkdir(this.getBaseDir(), { recursive: true });
  }
  fileForRun(runId) {
    return path__default$1.join(this.getBaseDir(), `agent-run-${runId}.jsonl`);
  }
  async appendLine(filePath, event) {
    await this.ensureDir();
    await fs$3.appendFile(filePath, JSON.stringify(event) + "\n", "utf8");
  }
  async emit(event) {
    const runId = event.runId;
    if (runId) {
      await this.appendLine(this.fileForRun(runId), event);
    }
    await this.appendLine(path__default$1.join(this.getBaseDir(), "agent-events.jsonl"), event);
  }
  async exportTrajectories(outputPath) {
    await this.ensureDir();
    const dir = this.getBaseDir();
    const files = await fs$3.readdir(dir);
    const runFiles = files.filter((f) => f.startsWith("agent-run-") && f.endsWith(".jsonl"));
    const trajectories = [];
    for (const file of runFiles) {
      try {
        const content = await fs$3.readFile(path__default$1.join(dir, file), "utf8");
        const events = content.trim().split("\n").map((line) => {
          try {
            return JSON.parse(line);
          } catch {
            return null;
          }
        }).filter((e) => e !== null);
        if (events.length > 0) {
          trajectories.push({
            runId: events[0].runId,
            timestamp: events[0].ts,
            eventCount: events.length,
            events
          });
        }
      } catch (err) {
        console.error(`Failed to process trajectory file ${file}:`, err);
      }
    }
    await fs$3.writeFile(outputPath, JSON.stringify(trajectories, null, 2));
    return trajectories.length;
  }
  // Terminal execution telemetry
  terminalLogFile() {
    return path__default$1.join(this.getBaseDir(), "terminal-executions.jsonl");
  }
  async logTerminalExecution(log) {
    await this.ensureDir();
    await fs$3.appendFile(this.terminalLogFile(), JSON.stringify(log) + "\n", "utf8");
    await this.emit({
      eventId: log.id,
      ts: new Date(log.timestamp).toISOString(),
      type: "terminal_execution",
      data: {
        command: log.command,
        success: log.success,
        duration: log.duration,
        error: log.error,
        url: log.url
      }
    });
  }
  async getTerminalLogs(limit2 = 100) {
    await this.ensureDir();
    try {
      const content = await fs$3.readFile(this.terminalLogFile(), "utf8");
      const logs = content.trim().split("\n").map((line) => {
        try {
          return JSON.parse(line);
        } catch {
          return null;
        }
      }).filter((e) => e !== null);
      return logs.reverse().slice(0, limit2);
    } catch {
      return [];
    }
  }
  async getTerminalStats() {
    const logs = await this.getTerminalLogs(1e3);
    const successful = logs.filter((l) => l.success).length;
    const failed = logs.filter((l) => !l.success).length;
    const avgDuration = logs.length > 0 ? logs.reduce((sum, l) => sum + l.duration, 0) / logs.length : 0;
    const recentErrors = logs.filter((l) => !l.success && l.error).slice(0, 5).map((l) => l.error);
    return {
      total: logs.length,
      successful,
      failed,
      avgDuration: Math.round(avgDuration),
      recentErrors
    };
  }
  async exportTerminalLogs(outputPath) {
    const logs = await this.getTerminalLogs(1e4);
    await fs$3.writeFile(outputPath, JSON.stringify(logs, null, 2));
    return logs.length;
  }
  async clearTerminalLogs() {
    await this.ensureDir();
    try {
      await fs$3.unlink(this.terminalLogFile());
    } catch {
    }
  }
}
const telemetryService = new TelemetryService();
const TelemetryService$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  TelemetryService,
  telemetryService
}, Symbol.toStringTag, { value: "Module" }));
class HttpLogShipper {
  constructor(url, apiKey) {
    __publicField2(this, "url");
    __publicField2(this, "apiKey");
    this.url = url;
    this.apiKey = apiKey;
  }
  async ship(payload) {
    const headers = {
      "Content-Type": "application/json"
    };
    if (this.apiKey) headers["Authorization"] = `Bearer ${this.apiKey}`;
    const res = await fetch(this.url, {
      method: "POST",
      headers,
      body: payload
    });
    if (!res.ok) {
      const text = await res.text().catch(() => "");
      throw new Error(`Audit ship failed: ${res.status} ${text}`);
    }
  }
}
class AuditService {
  constructor() {
    __publicField2(this, "db");
    __publicField2(this, "encryptionKey", null);
    __publicField2(this, "shipperKey", null);
    __publicField2(this, "ready");
    __publicField2(this, "shipper", null);
    __publicField2(this, "DB_FILENAME", "audit_logs.db");
    const userDataPath = app$1.getPath("userData");
    const dbPath = path__default.join(userDataPath, this.DB_FILENAME);
    this.db = new Database(dbPath);
    this.ready = this.init();
  }
  async init() {
    this.db.exec(`
      CREATE TABLE IF NOT EXISTS audit_logs (
        id TEXT PRIMARY KEY,
        timestamp TEXT NOT NULL,
        actor TEXT NOT NULL,
        action TEXT NOT NULL,
        details TEXT,
        status TEXT NOT NULL,
        prev_hash TEXT,
        hash TEXT,
        shipped_at TEXT
      )
    `);
    this.ensureColumn("prev_hash", "TEXT");
    this.ensureColumn("hash", "TEXT");
    this.ensureColumn("shipped_at", "TEXT");
    await this.loadOrGenerateKey();
    await this.loadOrGenerateShipperKey();
    this.backfillHashChain();
    this.configureFromEnv();
  }
  ensureColumn(name, type) {
    try {
      const cols = this.db.prepare("PRAGMA table_info(audit_logs)").all();
      const exists = cols.some((c) => c && String(c.name) === name);
      if (!exists) {
        this.db.exec(`ALTER TABLE audit_logs ADD COLUMN ${name} ${type}`);
      }
    } catch {
    }
  }
  configureFromEnv() {
    const url = process.env.AUDIT_SHIPPER_URL;
    if (typeof url === "string" && url.trim()) {
      const apiKey = typeof process.env.AUDIT_SHIPPER_API_KEY === "string" ? process.env.AUDIT_SHIPPER_API_KEY.trim() : void 0;
      this.shipper = new HttpLogShipper(url.trim(), apiKey && apiKey.length > 0 ? apiKey : void 0);
    }
  }
  async loadOrGenerateKey() {
    let keyHex = await vaultService.getSecret("audit_db_key");
    if (!keyHex) {
      keyHex = crypto$3.randomBytes(32).toString("hex");
      await vaultService.setSecret("audit_db_key", keyHex);
    }
    this.encryptionKey = Buffer.from(keyHex, "hex");
  }
  async loadOrGenerateShipperKey() {
    let keyHex = await vaultService.getSecret("audit_shipper_key");
    if (!keyHex) {
      keyHex = crypto$3.randomBytes(32).toString("hex");
      await vaultService.setSecret("audit_shipper_key", keyHex);
    }
    this.shipperKey = Buffer.from(keyHex, "hex");
  }
  computeHash(prevHash, row) {
    const h = crypto$3.createHash("sha256");
    h.update(prevHash);
    h.update("|");
    h.update(row.id);
    h.update("|");
    h.update(row.timestamp);
    h.update("|");
    h.update(row.actor);
    h.update("|");
    h.update(row.action);
    h.update("|");
    h.update(row.details);
    h.update("|");
    h.update(row.status);
    return h.digest("hex");
  }
  backfillHashChain() {
    try {
      const rows = this.db.prepare("SELECT rowid, id, timestamp, actor, action, details, status, prev_hash, hash FROM audit_logs ORDER BY rowid ASC").all();
      let prev = "";
      for (const r of rows) {
        const existing = typeof r.hash === "string" && r.hash.length > 0 ? r.hash : null;
        if (existing) {
          prev = existing;
          continue;
        }
        const prevHash = prev;
        const nextHash = this.computeHash(prevHash, {
          id: r.id,
          timestamp: r.timestamp,
          actor: String(r.actor),
          action: String(r.action),
          details: String(r.details ?? ""),
          status: String(r.status)
        });
        this.db.prepare("UPDATE audit_logs SET prev_hash = ?, hash = ? WHERE id = ?").run(prevHash || null, nextHash, r.id);
        prev = nextHash;
      }
    } catch {
    }
  }
  encrypt(text) {
    if (!this.encryptionKey) return text;
    const iv = crypto$3.randomBytes(16);
    const cipher = crypto$3.createCipheriv("aes-256-cbc", this.encryptionKey, iv);
    let encrypted = cipher.update(text);
    encrypted = Buffer.concat([encrypted, cipher.final()]);
    return iv.toString("hex") + ":" + encrypted.toString("hex");
  }
  encryptForShipping(text) {
    if (!this.shipperKey) return text;
    const iv = crypto$3.randomBytes(12);
    const cipher = crypto$3.createCipheriv("aes-256-gcm", this.shipperKey, iv);
    const enc = Buffer.concat([cipher.update(text, "utf8"), cipher.final()]);
    const tag = cipher.getAuthTag();
    return iv.toString("hex") + ":" + tag.toString("hex") + ":" + enc.toString("hex");
  }
  decrypt(text) {
    if (!this.encryptionKey) return text;
    try {
      const textParts = text.split(":");
      const iv = Buffer.from(textParts.shift(), "hex");
      const encryptedText = Buffer.from(textParts.join(":"), "hex");
      const decipher = crypto$3.createDecipheriv("aes-256-cbc", this.encryptionKey, iv);
      let decrypted = decipher.update(encryptedText);
      decrypted = Buffer.concat([decrypted, decipher.final()]);
      return decrypted.toString();
    } catch (e) {
      console.error("Failed to decrypt log:", e);
      return "[Encrypted Content]";
    }
  }
  async log(entry) {
    await this.ready;
    if (!this.encryptionKey) await this.loadOrGenerateKey();
    const id = v4$2();
    const timestamp = (/* @__PURE__ */ new Date()).toISOString();
    const detailsStr = JSON.stringify(entry.details);
    const encryptedDetails = this.encrypt(detailsStr);
    const last = this.db.prepare("SELECT hash FROM audit_logs ORDER BY rowid DESC LIMIT 1").get();
    const prevHash = typeof (last == null ? void 0 : last.hash) === "string" ? last.hash : "";
    const rowHash = this.computeHash(prevHash || "", {
      id,
      timestamp,
      actor: entry.actor,
      action: entry.action,
      details: encryptedDetails,
      status: entry.status
    });
    const stmt = this.db.prepare(`
      INSERT INTO audit_logs (id, timestamp, actor, action, details, status, prev_hash, hash, shipped_at)
      VALUES (?, ?, ?, ?, ?, ?, ?, ?, NULL)
    `);
    stmt.run(id, timestamp, entry.actor, entry.action, encryptedDetails, entry.status, prevHash || null, rowHash);
    return id;
  }
  getLogs(limit2 = 100) {
    const stmt = this.db.prepare("SELECT * FROM audit_logs ORDER BY timestamp DESC LIMIT ?");
    const rows = stmt.all(limit2);
    return rows.map((row) => ({
      ...row,
      actor: row.actor,
      status: row.status,
      details: this.decrypt(row.details)
    }));
  }
  verifyHashChain(limit2) {
    try {
      const sql = typeof limit2 === "number" ? "SELECT rowid, id, timestamp, actor, action, details, status, prev_hash, hash FROM audit_logs ORDER BY rowid ASC LIMIT ?" : "SELECT rowid, id, timestamp, actor, action, details, status, prev_hash, hash FROM audit_logs ORDER BY rowid ASC";
      const rows = typeof limit2 === "number" ? this.db.prepare(sql).all(limit2) : this.db.prepare(sql).all();
      let prev = "";
      for (const r of rows) {
        const expectedPrev = prev;
        const storedPrev = typeof r.prev_hash === "string" ? r.prev_hash : "";
        if ((storedPrev || "") !== (expectedPrev || "")) {
          return { ok: false, brokenAtId: r.id };
        }
        const computed = this.computeHash(expectedPrev || "", {
          id: r.id,
          timestamp: r.timestamp,
          actor: String(r.actor),
          action: String(r.action),
          details: String(r.details ?? ""),
          status: String(r.status)
        });
        if (String(r.hash ?? "") !== computed) {
          return { ok: false, brokenAtId: r.id };
        }
        prev = computed;
      }
      return { ok: true };
    } catch {
      return { ok: false };
    }
  }
  async shipPendingLogs(limit2 = 200) {
    await this.ready;
    if (!this.shipper) return { shipped: 0 };
    const rows = this.db.prepare(
      "SELECT rowid, id, timestamp, actor, action, details, status, prev_hash, hash FROM audit_logs WHERE shipped_at IS NULL ORDER BY rowid ASC LIMIT ?"
    ).all(limit2);
    if (!rows.length) return { shipped: 0 };
    const batch = rows.map((r) => {
      const decrypted = this.decrypt(String(r.details ?? ""));
      const parsed = (() => {
        try {
          return JSON.parse(decrypted);
        } catch {
          return decrypted;
        }
      })();
      return {
        id: r.id,
        timestamp: r.timestamp,
        actor: r.actor,
        action: r.action,
        status: r.status,
        details: parsed,
        prev_hash: r.prev_hash ?? null,
        hash: r.hash ?? null
      };
    });
    const payload = {
      sentAt: (/* @__PURE__ */ new Date()).toISOString(),
      count: batch.length,
      payload: this.encryptForShipping(JSON.stringify(batch))
    };
    await this.shipper.ship(JSON.stringify(payload));
    const shippedAt = (/* @__PURE__ */ new Date()).toISOString();
    const update = this.db.prepare("UPDATE audit_logs SET shipped_at = ? WHERE id = ?");
    const tx = this.db.transaction((ids) => {
      for (const id of ids) update.run(shippedAt, id);
    });
    tx(rows.map((r) => r.id));
    return { shipped: rows.length };
  }
  async rotateLogs(retentionDays = 30) {
    await this.ready;
    const days = typeof retentionDays === "number" && Number.isFinite(retentionDays) ? retentionDays : 30;
    const cutoff = new Date(Date.now() - Math.max(1, days) * 24 * 60 * 60 * 1e3).toISOString();
    const stmt = this.db.prepare("DELETE FROM audit_logs WHERE timestamp < ? AND shipped_at IS NOT NULL");
    const info = stmt.run(cutoff);
    return { deleted: Number(info.changes) || 0 };
  }
}
const auditService = new AuditService();
var PolicyDecision = /* @__PURE__ */ ((PolicyDecision2) => {
  PolicyDecision2["ALLOW"] = "allow";
  PolicyDecision2["DENY"] = "deny";
  PolicyDecision2["NEEDS_APPROVAL"] = "needs_approval";
  return PolicyDecision2;
})(PolicyDecision || {});
const DOMAIN_RISK_LEVELS = {
  "localhost:3000": "low",
  "github.com": "low",
  "google.com": "low",
  "duckduckgo.com": "low",
  "wikipedia.org": "low"
  /* LOW */
};
const TOOL_RISK_LEVELS = {
  "browser_observe": "low",
  "browser_navigate": "medium",
  "browser_click": "medium",
  "browser_type": "high",
  "browser_execute_plan": "high",
  "browser_open_tab": "medium",
  "api_web_search": "low"
  /* LOW */
};
const RemotePolicySchema = object({
  version: number(),
  fetchedAt: number().optional(),
  domainAllowlist: array(string()).optional(),
  domainBlocklist: array(string()).optional(),
  domainRiskOverrides: record(string(), _enum(["low", "medium", "high"])).optional(),
  toolRiskOverrides: record(string(), _enum(["low", "medium", "high"])).optional()
});
class PolicyService {
  constructor(auditServiceInstance = auditService, telemetryServiceInstance = telemetryService) {
    __publicField2(this, "rules", []);
    __publicField2(this, "cacheFilePath");
    __publicField2(this, "remotePolicy", null);
    __publicField2(this, "remotePolicyUrl", null);
    __publicField2(this, "remotePolicyAuthToken", null);
    __publicField2(this, "syncTimer", null);
    __publicField2(this, "syncStatus", "idle");
    __publicField2(this, "lastSyncError", null);
    __publicField2(this, "adminMessage", null);
    __publicField2(this, "developerOverride", false);
    this.auditServiceInstance = auditServiceInstance;
    this.telemetryServiceInstance = telemetryServiceInstance;
    this.cacheFilePath = path__default$1.join(process.cwd(), "policy_cache.json");
    this.setupDefaultRules();
    this.loadCachedRemotePolicy();
  }
  setupDefaultRules() {
    this.addRule({
      name: "domain-blocklist",
      priority: 100,
      match: (ctx) => {
        var _a3, _b;
        if (!ctx.domain) return false;
        return ((_b = (_a3 = this.remotePolicy) == null ? void 0 : _a3.domainBlocklist) == null ? void 0 : _b.includes(ctx.domain)) ?? false;
      },
      evaluate: (ctx) => ({
        decision: "deny",
        riskLevel: "high",
        reason: `Domain ${ctx.domain} is explicitly blocked by enterprise policy`,
        matchedRule: "domain-blocklist"
      })
    });
    this.addRule({
      name: "domain-allowlist",
      priority: 90,
      match: (ctx) => {
        var _a3, _b;
        if (!ctx.domain) return false;
        return ((_b = (_a3 = this.remotePolicy) == null ? void 0 : _a3.domainAllowlist) == null ? void 0 : _b.includes(ctx.domain)) ?? false;
      },
      evaluate: (ctx) => ({
        decision: "allow",
        riskLevel: "low",
        reason: `Domain ${ctx.domain} is explicitly allowed by enterprise policy`,
        matchedRule: "domain-allowlist"
      })
    });
    this.addRule({
      name: "default-risk-evaluation",
      priority: 0,
      match: () => true,
      // Catch-all
      evaluate: (ctx) => {
        const toolRisk = TOOL_RISK_LEVELS[ctx.toolName] ?? "medium";
        const domainRisk = ctx.domain ? DOMAIN_RISK_LEVELS[ctx.domain] ?? "medium" : "medium";
        let escalatedRisk = toolRisk;
        if (domainRisk === "high") escalatedRisk = "high";
        if (toolRisk === "high") escalatedRisk = "high";
        const argRisk = this.evaluateArgsRisk(ctx);
        if (argRisk === "high") escalatedRisk = "high";
        if (escalatedRisk === "high") {
          return {
            decision: "needs_approval",
            riskLevel: "high",
            reason: "High risk operation detected",
            matchedRule: "default-risk-evaluation"
          };
        }
        if (escalatedRisk === "medium" && ctx.userMode !== "developer" && ctx.userMode !== "admin") {
          return {
            decision: "needs_approval",
            riskLevel: "medium",
            reason: "Medium risk operation requires approval in standard mode",
            matchedRule: "default-risk-evaluation"
          };
        }
        return {
          decision: "allow",
          riskLevel: escalatedRisk,
          reason: "Low risk operation allowed",
          matchedRule: "default-risk-evaluation"
        };
      }
    });
  }
  evaluateArgsRisk(context) {
    const { args } = context;
    if (!args || typeof args !== "object") return "low";
    if (context.toolName === "browser_navigate") {
      const url = args.url;
      if (url) {
        try {
          const u = new URL(url);
          const domain = u.port ? `${u.hostname}:${u.port}` : u.hostname;
          const domainRisk = DOMAIN_RISK_LEVELS[domain];
          if (domainRisk === "high" || domainRisk === void 0) {
            return "high";
          }
        } catch {
          return "high";
        }
      }
    }
    if (context.toolName === "browser_execute_plan" || context.toolName === "workflow_task") {
      try {
        const steps = Array.isArray(args.steps) ? args.steps : [];
        for (const step of steps) {
          if ((step == null ? void 0 : step.action) === "navigate" && typeof (step == null ? void 0 : step.url) === "string") {
            try {
              const u = new URL(step.url);
              const domain = u.port ? `${u.hostname}:${u.port}` : u.hostname;
              const domainRisk = DOMAIN_RISK_LEVELS[domain];
              if (domainRisk === "high" || domainRisk === void 0) {
                return "high";
              }
            } catch {
              return "high";
            }
          }
        }
      } catch {
        return "medium";
      }
    }
    const riskyPatterns = [
      /password/i,
      /token/i,
      /secret/i,
      /key/i,
      /delete/i,
      /drop\s+table/i,
      /rm\s+-rf/i,
      /sudo/i
    ];
    const argsStr = JSON.stringify(args).toLowerCase();
    for (const pattern of riskyPatterns) {
      if (pattern.test(argsStr)) {
        return "high";
      }
    }
    if (args.value && typeof args.value === "string" && args.value.length > 1e4) {
      return "medium";
    }
    return "low";
  }
  hashArgs(args) {
    if (!args) return "";
    const str2 = JSON.stringify(args);
    let hash = 0;
    for (let i2 = 0; i2 < str2.length; i2++) {
      const char = str2.charCodeAt(i2);
      hash = (hash << 5) - hash + char;
      hash = hash & hash;
    }
    return Math.abs(hash).toString(16);
  }
  addRule(rule) {
    this.rules.push(rule);
    this.rules.sort((a, b) => b.priority - a.priority);
  }
  removeRule(name) {
    this.rules = this.rules.filter((rule) => rule.name !== name);
  }
  async evaluate(context) {
    const startTime2 = Date.now();
    const runId = context.runId;
    for (const rule of this.rules) {
      if (rule.match(context)) {
        const evaluation = rule.evaluate(context);
        const durationMs = Date.now() - startTime2;
        const argsHash = this.hashArgs(context.args);
        try {
          await this.telemetryServiceInstance.emit({
            eventId: v4$2(),
            runId,
            ts: (/* @__PURE__ */ new Date()).toISOString(),
            type: "policy_evaluation",
            name: "PolicyService",
            data: {
              toolName: context.toolName,
              domain: context.domain,
              userMode: context.userMode,
              decision: evaluation.decision,
              riskLevel: evaluation.riskLevel,
              matchedRule: rule.name,
              durationMs,
              argsHash
            }
          });
        } catch {
        }
        try {
          await this.auditServiceInstance.log({
            actor: "system",
            action: "policy_evaluation",
            details: {
              runId,
              toolName: context.toolName,
              domain: context.domain,
              userMode: context.userMode,
              decision: evaluation.decision,
              riskLevel: evaluation.riskLevel,
              reason: evaluation.reason,
              matchedRule: rule.name,
              durationMs,
              argsHash
            },
            status: "success"
          });
        } catch {
        }
        return evaluation;
      }
    }
    return {
      decision: "needs_approval",
      riskLevel: "medium",
      reason: "No policy rules matched",
      matchedRule: "none"
    };
  }
  getToolRiskLevel(toolName) {
    return TOOL_RISK_LEVELS[toolName] || "medium";
  }
  getDomainRiskLevel(domain) {
    return DOMAIN_RISK_LEVELS[domain] || "medium";
  }
  updateDomainRiskLevel(domain, riskLevel) {
    DOMAIN_RISK_LEVELS[domain] = riskLevel;
  }
  updateToolRiskLevel(toolName, riskLevel) {
    TOOL_RISK_LEVELS[toolName] = riskLevel;
  }
  async syncPolicies() {
    if (!this.remotePolicyUrl) return { success: false, error: "No remote policy URL configured" };
    this.syncStatus = "syncing";
    try {
      const bundle = await this.fetchRemotePolicies(this.remotePolicyUrl);
      this.applyRemotePolicy(bundle);
      this.syncStatus = "synced";
      this.lastSyncError = null;
      return { success: true };
    } catch (err) {
      this.syncStatus = "error";
      this.lastSyncError = err instanceof Error ? err.message : String(err);
      return { success: false, error: this.lastSyncError };
    }
  }
  async fetchRemotePolicies(url) {
    const headers = { "Content-Type": "application/json" };
    if (this.remotePolicyAuthToken) {
      headers["Authorization"] = `Bearer ${this.remotePolicyAuthToken}`;
    }
    const response = await fetch(url, { headers });
    if (!response.ok) throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    const data = await response.json();
    return RemotePolicySchema.parse(data);
  }
  applyRemotePolicy(bundle) {
    this.remotePolicy = bundle;
    if (bundle.domainRiskOverrides) {
      for (const [domain, lvl] of Object.entries(bundle.domainRiskOverrides)) {
        this.updateDomainRiskLevel(domain, this.toRiskLevel(lvl));
      }
    }
    if (bundle.toolRiskOverrides) {
      for (const [tool2, lvl] of Object.entries(bundle.toolRiskOverrides)) {
        this.updateToolRiskLevel(tool2, this.toRiskLevel(lvl));
      }
    }
    this.saveCachedRemotePolicy(bundle);
  }
  toRiskLevel(v) {
    if (v === "low") return "low";
    if (v === "medium") return "medium";
    return "high";
  }
  async loadCachedRemotePolicy() {
    try {
      const raw = await fs$3.readFile(this.cacheFilePath, "utf8");
      const bundle = RemotePolicySchema.parse(JSON.parse(raw));
      this.applyRemotePolicy(bundle);
    } catch {
    }
  }
  async saveCachedRemotePolicy(bundle) {
    try {
      await fs$3.writeFile(this.cacheFilePath, JSON.stringify(bundle, null, 2), "utf8");
    } catch {
    }
  }
  configure(cfg) {
    this.remotePolicyUrl = cfg.url;
    this.remotePolicyAuthToken = cfg.authToken ?? null;
  }
  startPeriodicSync(intervalMs = 3e5) {
    if (this.syncTimer) clearInterval(this.syncTimer);
    this.syncTimer = setInterval(() => this.syncPolicies(), intervalMs);
  }
  async init(cfg) {
    if (cfg == null ? void 0 : cfg.remotePolicyUrl) {
      this.remotePolicyUrl = cfg.remotePolicyUrl;
      await this.syncPolicies();
    }
  }
  getRemotePolicyStatus() {
    var _a3;
    return {
      configured: !!this.remotePolicyUrl,
      url: this.remotePolicyUrl,
      lastSync: ((_a3 = this.remotePolicy) == null ? void 0 : _a3.fetchedAt) ? new Date(this.remotePolicy.fetchedAt).toISOString() : null,
      status: this.syncStatus
    };
  }
  getSyncState() {
    return {
      status: this.syncStatus,
      lastError: this.lastSyncError
    };
  }
  async configureRemotePolicy(url, authToken) {
    this.remotePolicyUrl = url;
    this.remotePolicyAuthToken = authToken ?? null;
    return this.syncPolicies();
  }
  async setAuthToken(token) {
    this.remotePolicyAuthToken = token;
  }
  async clearAuthToken() {
    this.remotePolicyAuthToken = null;
  }
  getAdminMessage() {
    return this.adminMessage;
  }
  setAdminMessage(message) {
    this.adminMessage = message;
  }
  async setDeveloperOverride(enabled, _token) {
    this.developerOverride = enabled;
    return true;
  }
  isDeveloperOverrideEnabled() {
    return this.developerOverride;
  }
}
new PolicyService();
class ToolRegistry {
  constructor() {
    __publicField2(this, "tools", /* @__PURE__ */ new Map());
    __publicField2(this, "langChainToolsCache", /* @__PURE__ */ new Map());
    __publicField2(this, "approvalHandler", null);
    __publicField2(this, "policyService", null);
  }
  setApprovalHandler(handler) {
    this.approvalHandler = handler;
  }
  setPolicyService(policyService) {
    this.policyService = policyService;
  }
  getPolicyService() {
    return this.policyService;
  }
  register(tool2) {
    if (this.tools.has(tool2.name)) {
      console.warn(`Tool with name ${tool2.name} is already registered. Overwriting.`);
    }
    this.tools.set(tool2.name, tool2);
    this.langChainToolsCache.delete(tool2.name);
  }
  getTool(name) {
    return this.tools.get(name);
  }
  getAllTools() {
    return Array.from(this.tools.values());
  }
  getLangChainTool(name) {
    const cached2 = this.langChainToolsCache.get(name);
    if (cached2) return cached2;
    const tool2 = this.tools.get(name);
    if (!tool2) return void 0;
    const registry2 = this;
    const currentTool = tool2;
    const structuredTool = new class extends StructuredTool {
      constructor() {
        super(...arguments);
        __publicField2(this, "name", currentTool.name);
        __publicField2(this, "description", currentTool.description);
        __publicField2(this, "schema", currentTool.schema);
      }
      async _call(arg) {
        return registry2.invokeToolInternal(currentTool, arg);
      }
    }();
    this.langChainToolsCache.set(name, structuredTool);
    return structuredTool;
  }
  async invokeTool(toolName, arg) {
    const tool2 = this.tools.get(toolName);
    if (!tool2) return `Error: Tool '${toolName}' not found.`;
    return this.invokeToolInternal(tool2, arg);
  }
  async invokeToolInternal(tool2, arg) {
    var _a3;
    const runId = agentRunContext.getRunId() ?? void 0;
    try {
      agentRunContext.recordToolCall(tool2.name, arg);
    } catch {
    }
    const argsJson = (() => {
      try {
        return JSON.stringify(arg ?? null);
      } catch {
        return "[unserializable_args]";
      }
    })();
    const argsHash = crypto$2.createHash("sha256").update(argsJson).digest("hex");
    const toolCallId = v4$2();
    const startedAt = Date.now();
    try {
      await telemetryService.emit({
        eventId: v4$2(),
        runId,
        ts: (/* @__PURE__ */ new Date()).toISOString(),
        type: "tool_call_start",
        name: tool2.name,
        data: { toolCallId, argsHash }
      });
    } catch {
    }
    try {
      auditService.log({
        actor: "agent",
        action: "tool_call_start",
        details: { runId, toolName: tool2.name, toolCallId, argsHash },
        status: "pending"
      }).catch(() => {
      });
    } catch {
    }
    const approvalHandler = this.approvalHandler;
    const policyService = this.policyService;
    if (policyService) {
      const browserContext = agentRunContext.getBrowserContext();
      const context = {
        toolName: tool2.name,
        args: arg,
        url: browserContext == null ? void 0 : browserContext.url,
        domain: browserContext == null ? void 0 : browserContext.domain,
        userMode: "standard",
        observeOnly: agentRunContext.getObserveOnly(),
        runId
      };
      const policyEvaluation = await policyService.evaluate(context);
      if (policyEvaluation.decision === PolicyDecision.DENY) {
        const durationMs = Date.now() - startedAt;
        try {
          await telemetryService.emit({
            eventId: v4$2(),
            runId,
            ts: (/* @__PURE__ */ new Date()).toISOString(),
            type: "tool_call_end",
            name: tool2.name,
            data: { toolCallId, argsHash, durationMs, error: "Policy denied" }
          });
        } catch {
        }
        try {
          auditService.log({
            actor: "system",
            action: "tool_call_denied",
            details: { runId, toolName: tool2.name, toolCallId, reason: policyEvaluation.reason },
            status: "failure"
          }).catch(() => {
          });
        } catch {
        }
        return `Operation denied by policy: ${policyEvaluation.reason}`;
      }
      if (policyEvaluation.decision === PolicyDecision.NEEDS_APPROVAL && approvalHandler) {
        const permissionMode = agentRunContext.getPermissionMode();
        if (permissionMode === "yolo") {
          try {
            auditService.log({
              actor: "system",
              action: "approval_auto_granted",
              details: { runId, toolName: tool2.name, toolCallId, reason: "YOLO mode" },
              status: "success"
            }).catch(() => {
            });
          } catch {
          }
        } else if (permissionMode === "permissions" || permissionMode === "manual") {
          try {
            await telemetryService.emit({
              eventId: v4$2(),
              runId,
              ts: (/* @__PURE__ */ new Date()).toISOString(),
              type: "approval_request",
              name: tool2.name,
              data: { toolCallId, argsHash, riskLevel: policyEvaluation.riskLevel }
            });
          } catch {
          }
          try {
            auditService.log({
              actor: "system",
              action: "approval_request",
              details: { runId, toolName: tool2.name, toolCallId, argsHash, reason: policyEvaluation.reason },
              status: "pending"
            }).catch(() => {
            });
          } catch {
          }
          const approvalResult = await approvalHandler(tool2.name, arg);
          const approved = typeof approvalResult === "boolean" ? approvalResult : Boolean(approvalResult == null ? void 0 : approvalResult.approved);
          const approvalReason = typeof approvalResult === "boolean" ? approved ? void 0 : "denied" : approvalResult == null ? void 0 : approvalResult.reason;
          try {
            await telemetryService.emit({
              eventId: v4$2(),
              runId,
              ts: (/* @__PURE__ */ new Date()).toISOString(),
              type: "approval_decision",
              name: tool2.name,
              data: { toolCallId, argsHash, approved, reason: approvalReason }
            });
          } catch {
          }
          try {
            auditService.log({
              actor: "system",
              action: "approval_decision",
              details: { runId, toolName: tool2.name, toolCallId, argsHash, approved, reason: approvalReason },
              status: approved ? "success" : "failure"
            }).catch(() => {
            });
          } catch {
          }
          if (!approved) {
            const durationMs = Date.now() - startedAt;
            const isTimeout = approvalReason === "timeout";
            try {
              await telemetryService.emit({
                eventId: v4$2(),
                runId,
                ts: (/* @__PURE__ */ new Date()).toISOString(),
                type: "tool_call_end",
                name: tool2.name,
                data: { toolCallId, argsHash, durationMs, error: isTimeout ? "Approval timed out" : "User denied" }
              });
            } catch {
            }
            try {
              auditService.log({
                actor: isTimeout ? "system" : "user",
                action: isTimeout ? "approval_timeout" : "tool_call_denied",
                details: { runId, toolName: tool2.name, toolCallId },
                status: "failure"
              }).catch(() => {
              });
            } catch {
            }
            return isTimeout ? "Approval timed out for this tool." : "User denied execution of this tool.";
          }
        }
      }
    } else if (tool2.requiresApproval && approvalHandler) {
      const permissionMode = agentRunContext.getPermissionMode();
      if (permissionMode === "yolo") {
        try {
          auditService.log({
            actor: "system",
            action: "approval_auto_granted",
            details: { runId, toolName: tool2.name, toolCallId, reason: "YOLO mode" },
            status: "success"
          }).catch(() => {
          });
        } catch {
        }
      } else if (permissionMode === "permissions" || permissionMode === "manual") {
        try {
          await telemetryService.emit({
            eventId: v4$2(),
            runId,
            ts: (/* @__PURE__ */ new Date()).toISOString(),
            type: "approval_request",
            name: tool2.name,
            data: { toolCallId, argsHash }
          });
        } catch {
        }
        try {
          auditService.log({
            actor: "system",
            action: "approval_request",
            details: { runId, toolName: tool2.name, toolCallId, argsHash },
            status: "pending"
          }).catch(() => {
          });
        } catch {
        }
        const approvalResult = await approvalHandler(tool2.name, arg);
        const approved = typeof approvalResult === "boolean" ? approvalResult : Boolean(approvalResult == null ? void 0 : approvalResult.approved);
        const approvalReason = typeof approvalResult === "boolean" ? approved ? void 0 : "denied" : approvalResult == null ? void 0 : approvalResult.reason;
        try {
          await telemetryService.emit({
            eventId: v4$2(),
            runId,
            ts: (/* @__PURE__ */ new Date()).toISOString(),
            type: "approval_decision",
            name: tool2.name,
            data: { toolCallId, argsHash, approved, reason: approvalReason }
          });
        } catch {
        }
        try {
          auditService.log({
            actor: "system",
            action: "approval_decision",
            details: { runId, toolName: tool2.name, toolCallId, argsHash, approved, reason: approvalReason },
            status: approved ? "success" : "failure"
          }).catch(() => {
          });
        } catch {
        }
        if (!approved) {
          const durationMs = Date.now() - startedAt;
          const isTimeout = approvalReason === "timeout";
          try {
            await telemetryService.emit({
              eventId: v4$2(),
              runId,
              ts: (/* @__PURE__ */ new Date()).toISOString(),
              type: "tool_call_end",
              name: tool2.name,
              data: { toolCallId, argsHash, durationMs, error: isTimeout ? "Approval timed out" : "User denied" }
            });
          } catch {
          }
          try {
            auditService.log({
              actor: isTimeout ? "system" : "user",
              action: isTimeout ? "approval_timeout" : "tool_call_denied",
              details: { runId, toolName: tool2.name, toolCallId },
              status: "failure"
            }).catch(() => {
            });
          } catch {
          }
          return isTimeout ? "Approval timed out for this tool." : "User denied execution of this tool.";
        }
      } else {
        try {
          await telemetryService.emit({
            eventId: v4$2(),
            runId,
            ts: (/* @__PURE__ */ new Date()).toISOString(),
            type: "approval_request",
            name: tool2.name,
            data: { toolCallId, argsHash }
          });
        } catch {
        }
        try {
          auditService.log({
            actor: "system",
            action: "approval_request",
            details: { runId, toolName: tool2.name, toolCallId, argsHash },
            status: "pending"
          }).catch(() => {
          });
        } catch {
        }
        const approvalResult = await approvalHandler(tool2.name, arg);
        const approved = typeof approvalResult === "boolean" ? approvalResult : Boolean(approvalResult == null ? void 0 : approvalResult.approved);
        const approvalReason = typeof approvalResult === "boolean" ? approved ? void 0 : "denied" : approvalResult == null ? void 0 : approvalResult.reason;
        try {
          await telemetryService.emit({
            eventId: v4$2(),
            runId,
            ts: (/* @__PURE__ */ new Date()).toISOString(),
            type: "approval_decision",
            name: tool2.name,
            data: { toolCallId, argsHash, approved, reason: approvalReason }
          });
        } catch {
        }
        try {
          auditService.log({
            actor: "system",
            action: "approval_decision",
            details: { runId, toolName: tool2.name, toolCallId, argsHash, approved, reason: approvalReason },
            status: approved ? "success" : "failure"
          }).catch(() => {
          });
        } catch {
        }
        if (!approved) {
          const durationMs = Date.now() - startedAt;
          const isTimeout = approvalReason === "timeout";
          try {
            await telemetryService.emit({
              eventId: v4$2(),
              runId,
              ts: (/* @__PURE__ */ new Date()).toISOString(),
              type: "tool_call_end",
              name: tool2.name,
              data: { toolCallId, argsHash, durationMs, error: isTimeout ? "Approval timed out" : "User denied" }
            });
          } catch {
          }
          try {
            auditService.log({
              actor: isTimeout ? "system" : "user",
              action: isTimeout ? "approval_timeout" : "tool_call_denied",
              details: { runId, toolName: tool2.name, toolCallId },
              status: "failure"
            }).catch(() => {
            });
          } catch {
          }
          return isTimeout ? "Approval timed out for this tool." : "User denied execution of this tool.";
        }
      }
    }
    try {
      const parsedArgs = ((_a3 = tool2.schema) == null ? void 0 : _a3.parse) ? tool2.schema.parse(arg ?? {}) : arg;
      const result = await tool2.execute(parsedArgs);
      const durationMs = Date.now() - startedAt;
      try {
        await telemetryService.emit({
          eventId: v4$2(),
          runId,
          ts: (/* @__PURE__ */ new Date()).toISOString(),
          type: "tool_call_end",
          name: tool2.name,
          data: { toolCallId, argsHash, durationMs, resultLength: String(result ?? "").length }
        });
      } catch {
      }
      try {
        auditService.log({
          actor: "agent",
          action: "tool_call_end",
          details: { runId, toolName: tool2.name, toolCallId, durationMs },
          status: "success"
        }).catch(() => {
        });
      } catch {
      }
      return result;
    } catch (e) {
      const durationMs = Date.now() - startedAt;
      const errorMessage = e instanceof Error ? e.message : String(e);
      try {
        await telemetryService.emit({
          eventId: v4$2(),
          runId,
          ts: (/* @__PURE__ */ new Date()).toISOString(),
          type: "tool_call_end",
          name: tool2.name,
          data: { toolCallId, argsHash, durationMs, error: errorMessage }
        });
      } catch {
      }
      try {
        auditService.log({
          actor: "agent",
          action: "tool_call_end",
          details: { runId, toolName: tool2.name, toolCallId, durationMs, error: errorMessage },
          status: "failure"
        }).catch(() => {
        });
      } catch {
      }
      return `Tool execution failed: ${errorMessage}`;
    }
  }
  // Convert to LangChain tools format
  toLangChainTools() {
    return this.getAllTools().map((tool2) => this.getLangChainTool(tool2.name));
  }
}
const toolRegistry = new ToolRegistry();
dotenv.config();
function base64UrlEncode(buf) {
  return buf.toString("base64").replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/g, "");
}
function sha256Base64Url(input) {
  return base64UrlEncode(crypto$2.createHash("sha256").update(input).digest());
}
function randomBase64Url(bytes) {
  return base64UrlEncode(crypto$2.randomBytes(bytes));
}
function parseUrlParams(u) {
  const url = new URL(u);
  const params = Object.fromEntries(url.searchParams.entries());
  return { url, params };
}
function toExpiresAt(expiresIn) {
  if (typeof expiresIn !== "number" || !Number.isFinite(expiresIn) || expiresIn <= 0) return void 0;
  return Date.now() + expiresIn * 1e3;
}
class IdentityService {
  constructor() {
    __publicField2(this, "discovery", null);
  }
  get issuerUrl() {
    const v = process.env.OIDC_ISSUER_URL;
    if (typeof v !== "string" || !v.trim()) throw new Error("OIDC_ISSUER_URL not configured");
    return v.trim().replace(/\/$/, "");
  }
  get clientId() {
    const v = process.env.OIDC_CLIENT_ID;
    if (typeof v !== "string" || !v.trim()) throw new Error("OIDC_CLIENT_ID not configured");
    return v.trim();
  }
  get redirectUri() {
    const v = process.env.OIDC_REDIRECT_URI;
    if (typeof v !== "string" || !v.trim()) return "enterprisebrowser://auth/callback";
    return v.trim();
  }
  get scope() {
    const v = process.env.OIDC_SCOPE;
    return typeof v === "string" && v.trim() ? v.trim() : "openid profile email";
  }
  async getDiscovery() {
    if (this.discovery) return this.discovery;
    const url = `${this.issuerUrl}/.well-known/openid-configuration`;
    const res = await fetch(url);
    if (!res.ok) throw new Error(`OIDC discovery failed: ${res.status}`);
    const json = await res.json();
    const discovery = {
      authorization_endpoint: String(json.authorization_endpoint || ""),
      token_endpoint: String(json.token_endpoint || ""),
      userinfo_endpoint: typeof json.userinfo_endpoint === "string" ? json.userinfo_endpoint : void 0
    };
    if (!discovery.authorization_endpoint || !discovery.token_endpoint) {
      throw new Error("OIDC discovery missing endpoints");
    }
    this.discovery = discovery;
    return discovery;
  }
  async exchangeCodeForToken(code2, codeVerifier) {
    const d = await this.getDiscovery();
    const body = new URLSearchParams({
      grant_type: "authorization_code",
      code: code2,
      redirect_uri: this.redirectUri,
      client_id: this.clientId,
      code_verifier: codeVerifier
    });
    const res = await fetch(d.token_endpoint, {
      method: "POST",
      headers: { "Content-Type": "application/x-www-form-urlencoded" },
      body
    });
    if (!res.ok) {
      const text = await res.text().catch(() => "");
      throw new Error(`OIDC token exchange failed: ${res.status} ${text}`);
    }
    return await res.json();
  }
  async refreshToken(refreshToken) {
    const d = await this.getDiscovery();
    const body = new URLSearchParams({
      grant_type: "refresh_token",
      refresh_token: refreshToken,
      client_id: this.clientId
    });
    const res = await fetch(d.token_endpoint, {
      method: "POST",
      headers: { "Content-Type": "application/x-www-form-urlencoded" },
      body
    });
    if (!res.ok) {
      const text = await res.text().catch(() => "");
      throw new Error(`OIDC refresh failed: ${res.status} ${text}`);
    }
    return await res.json();
  }
  async fetchUserInfo(accessToken) {
    const d = await this.getDiscovery();
    if (!d.userinfo_endpoint) return null;
    const res = await fetch(d.userinfo_endpoint, {
      headers: { Authorization: `Bearer ${accessToken}` }
    });
    if (!res.ok) return null;
    return await res.json();
  }
  toProfile(ui) {
    const name = ((ui == null ? void 0 : ui.name) || (ui == null ? void 0 : ui.preferred_username) || "User").toString();
    const email2 = ((ui == null ? void 0 : ui.email) || "unknown@example.com").toString();
    const avatar = (ui == null ? void 0 : ui.picture) ? String(ui.picture) : void 0;
    if (name && email2) return { name, email: email2, avatar };
    return { name: "User", email: "unknown@example.com", avatar };
  }
  async storeSession(session) {
    await vaultService.setSecret("oidc:access_token", session.accessToken);
    if (session.refreshToken) await vaultService.setSecret("oidc:refresh_token", session.refreshToken);
    if (session.idToken) await vaultService.setSecret("oidc:id_token", session.idToken);
    if (typeof session.expiresAt === "number") await vaultService.setSecret("oidc:expires_at", String(session.expiresAt));
    await vaultService.setSecret("oidc:user_profile", JSON.stringify(session.profile));
  }
  async clearSession() {
    await vaultService.deleteSecret("oidc:access_token").catch(() => void 0);
    await vaultService.deleteSecret("oidc:refresh_token").catch(() => void 0);
    await vaultService.deleteSecret("oidc:id_token").catch(() => void 0);
    await vaultService.deleteSecret("oidc:expires_at").catch(() => void 0);
    await vaultService.deleteSecret("oidc:user_profile").catch(() => void 0);
  }
  async getSession() {
    const profileRaw = await vaultService.getSecret("oidc:user_profile").catch(() => null);
    const access = await vaultService.getSecret("oidc:access_token").catch(() => null);
    if (!profileRaw || !access) return null;
    const expiresRaw = await vaultService.getSecret("oidc:expires_at").catch(() => null);
    const expiresAt = expiresRaw ? Number(expiresRaw) : void 0;
    if (expiresAt && Date.now() > expiresAt - 3e4) {
      const rt = await vaultService.getSecret("oidc:refresh_token").catch(() => null);
      if (rt) {
        const refreshed = await this.refreshToken(rt);
        const newAccess = refreshed.access_token;
        const newRt = refreshed.refresh_token || rt;
        const newExp = toExpiresAt(refreshed.expires_in);
        const ui = await this.fetchUserInfo(newAccess).catch(() => null);
        const profile = this.toProfile(ui);
        await this.storeSession({
          profile,
          accessToken: newAccess,
          refreshToken: newRt,
          expiresAt: newExp,
          idToken: refreshed.id_token
        });
        return profile;
      }
      return null;
    }
    try {
      const parsed = JSON.parse(profileRaw);
      const name = String((parsed == null ? void 0 : parsed.name) ?? "User");
      const email2 = String((parsed == null ? void 0 : parsed.email) ?? "unknown@example.com");
      const avatar = (parsed == null ? void 0 : parsed.avatar) ? String(parsed.avatar) : void 0;
      return { name, email: email2, avatar };
    } catch {
      return null;
    }
  }
  async loginWithPopup() {
    const d = await this.getDiscovery();
    const state = randomBase64Url(16);
    const nonce = randomBase64Url(16);
    const codeVerifier = randomBase64Url(32);
    const codeChallenge = sha256Base64Url(codeVerifier);
    const authUrl = new URL(d.authorization_endpoint);
    authUrl.searchParams.set("response_type", "code");
    authUrl.searchParams.set("client_id", this.clientId);
    authUrl.searchParams.set("redirect_uri", this.redirectUri);
    authUrl.searchParams.set("scope", this.scope);
    authUrl.searchParams.set("state", state);
    authUrl.searchParams.set("nonce", nonce);
    authUrl.searchParams.set("code_challenge", codeChallenge);
    authUrl.searchParams.set("code_challenge_method", "S256");
    const loginWin = new BrowserWindow$1({
      width: 960,
      height: 720,
      show: true,
      webPreferences: {
        nodeIntegration: false,
        contextIsolation: true,
        sandbox: true
      }
    });
    const cleanupSessionHooks = (() => {
      const ses = loginWin.webContents.session;
      const filter = { urls: ["*://*/*", "enterprisebrowser://*/*"] };
      const onBeforeRequest = (_details, cb) => {
        cb({});
      };
      ses.webRequest.onBeforeRequest(filter, onBeforeRequest);
      return () => {
        var _a3, _b;
        try {
          (_b = (_a3 = ses.webRequest).off) == null ? void 0 : _b.call(_a3, "onBeforeRequest", onBeforeRequest);
        } catch {
        }
      };
    })();
    const waitForRedirect = new Promise((resolve, reject) => {
      const timeout = setTimeout(() => reject(new Error("Login timed out")), 18e4);
      const finish = (u) => {
        clearTimeout(timeout);
        resolve(u);
      };
      const fail = (err) => {
        clearTimeout(timeout);
        reject(err);
      };
      const handleUrl = (u) => {
        if (!u) return;
        const ru = this.redirectUri;
        if (u.startsWith(ru)) {
          finish(u);
        }
      };
      loginWin.webContents.on("will-redirect", (_e, url) => handleUrl(url));
      loginWin.webContents.on("will-navigate", (_e, url) => handleUrl(url));
      loginWin.webContents.on("did-fail-load", (_e, _code, desc) => {
        if (String(desc || "").toLowerCase().includes("aborted")) return;
      });
      loginWin.on("closed", () => fail(new Error("Login window closed")));
    });
    await loginWin.loadURL(authUrl.toString()).catch((e) => {
      if (String((e == null ? void 0 : e.message) || "").includes("ERR_ABORTED")) return;
      throw e;
    });
    let finalUrl;
    try {
      finalUrl = await waitForRedirect;
    } finally {
      cleanupSessionHooks();
      if (!loginWin.isDestroyed()) loginWin.close();
    }
    const { params } = parseUrlParams(finalUrl);
    if (params.state !== state) throw new Error("OIDC state mismatch");
    const code2 = params.code;
    if (typeof code2 !== "string" || !code2) throw new Error("OIDC missing code");
    const tokens = await this.exchangeCodeForToken(code2, codeVerifier);
    const accessToken = tokens.access_token;
    const expiresAt = toExpiresAt(tokens.expires_in);
    const ui = await this.fetchUserInfo(accessToken).catch(() => null);
    const profile = this.toProfile(ui);
    await this.storeSession({
      profile,
      accessToken,
      refreshToken: tokens.refresh_token,
      expiresAt,
      idToken: tokens.id_token
    });
    return profile;
  }
  async getAccessToken() {
    const access = await vaultService.getSecret("oidc:access_token").catch(() => null);
    if (!access) return null;
    const expiresRaw = await vaultService.getSecret("oidc:expires_at").catch(() => null);
    const expiresAt = expiresRaw ? Number(expiresRaw) : void 0;
    if (expiresAt && Date.now() > expiresAt - 3e4) {
      const rt = await vaultService.getSecret("oidc:refresh_token").catch(() => null);
      if (!rt) return null;
      const refreshed = await this.refreshToken(rt);
      const newAccess = refreshed.access_token;
      const newRt = refreshed.refresh_token || rt;
      const newExp = toExpiresAt(refreshed.expires_in);
      const profile = await this.getSession();
      if (profile) {
        await this.storeSession({
          profile,
          accessToken: newAccess,
          refreshToken: newRt,
          expiresAt: newExp,
          idToken: refreshed.id_token
        });
      } else {
        await vaultService.setSecret("oidc:access_token", newAccess);
        await vaultService.setSecret("oidc:refresh_token", newRt);
        if (typeof newExp === "number") await vaultService.setSecret("oidc:expires_at", String(newExp));
      }
      return newAccess;
    }
    return access;
  }
}
const identityService = new IdentityService();
dotenv.config();
class WebAPIService {
  constructor() {
    this.registerTools();
  }
  getCloudBaseUrl() {
    const v = process.env.SKILL_CLOUD_BASE_URL;
    if (typeof v !== "string") return null;
    const s = v.trim();
    return s ? s : null;
  }
  async getCloudHeaders() {
    const headers = {
      "Content-Type": "application/json"
    };
    const key = process.env.SKILL_CLOUD_API_KEY;
    if (typeof key === "string" && key.trim()) {
      headers["Authorization"] = `Bearer ${key.trim()}`;
      return headers;
    }
    const token = await identityService.getAccessToken().catch(() => null);
    if (typeof token === "string" && token.trim()) {
      headers["Authorization"] = `Bearer ${token.trim()}`;
    }
    return headers;
  }
  async getSkillLibrary() {
    const base = this.getCloudBaseUrl();
    if (!base) return [];
    const url = `${base.replace(/\/$/, "")}/skills`;
    const response = await fetch(url, { method: "GET", headers: await this.getCloudHeaders() });
    if (!response.ok) {
      throw new Error(`Skill library fetch failed: ${response.status} ${response.statusText}`);
    }
    const data = await response.json();
    if (Array.isArray(data)) return data;
    if (data && typeof data === "object" && "skills" in data && Array.isArray(data.skills)) {
      return data.skills;
    }
    return [];
  }
  async upsertSkillLibrary(skills) {
    const base = this.getCloudBaseUrl();
    if (!base) return;
    const url = `${base.replace(/\/$/, "")}/skills/bulk`;
    const response = await fetch(url, {
      method: "POST",
      headers: await this.getCloudHeaders(),
      body: JSON.stringify({ skills: Array.isArray(skills) ? skills : [] })
    });
    if (!response.ok) {
      throw new Error(`Skill library upsert failed: ${response.status} ${response.statusText}`);
    }
  }
  registerTools() {
    const githubSearchSchema = object({
      query: string().describe('Search query (e.g., "langchain", "react")'),
      type: _enum(["repositories", "users", "code"]).optional().describe("Type of search (default: repositories)"),
      sort: _enum(["stars", "forks", "updated", "best-match"]).optional().describe("Sort by (default: best-match)"),
      limit: number().optional().describe("Number of results to return (default: 5, max: 10)")
    });
    const githubSearchTool = {
      name: "api_github_search",
      description: "Search GitHub repositories, users, or code via API. MUCH faster than browser automation. Returns repo names, stars, descriptions. Use this instead of navigating to github.com for search tasks.",
      schema: githubSearchSchema,
      execute: async ({ query, type = "repositories", sort = "stars", limit: limit2 = 5 }) => {
        try {
          const searchType = type === "repositories" ? "repositories" : type === "users" ? "users" : "code";
          const url = `https://api.github.com/search/${searchType}?q=${encodeURIComponent(query)}&sort=${sort}&order=desc&per_page=${Math.min(limit2, 10)}`;
          const response = await fetch(url, {
            headers: {
              "Accept": "application/vnd.github.v3+json",
              "User-Agent": "EnterpriseBrowser/1.0"
            }
          });
          if (!response.ok) {
            if (response.status === 403) {
              return JSON.stringify({ error: "Rate limited. Try browser_navigate to https://github.com/search?q=" + encodeURIComponent(query) + "&type=repositories&s=stars&o=desc instead." });
            }
            return JSON.stringify({ error: `GitHub API error: ${response.status} ${response.statusText}` });
          }
          const data = await response.json();
          if (searchType === "repositories") {
            const results2 = data.items.slice(0, limit2).map((repo) => ({
              name: String(repo.full_name || ""),
              stars: Number(repo.stargazers_count || 0),
              forks: Number(repo.forks_count || 0),
              description: String(repo.description || "").slice(0, 100),
              url: String(repo.html_url || ""),
              language: String(repo.language || "")
            }));
            return JSON.stringify({ total_count: data.total_count, results: results2 }, null, 2);
          } else if (searchType === "users") {
            const results2 = data.items.slice(0, limit2).map((user) => ({
              login: String(user.login || ""),
              url: String(user.html_url || ""),
              type: String(user.type || "")
            }));
            return JSON.stringify({ total_count: data.total_count, results: results2 }, null, 2);
          }
          return JSON.stringify({ total_count: data.total_count, items: data.items.slice(0, limit2) }, null, 2);
        } catch (e) {
          const errorMessage = e instanceof Error ? e.message : String(e);
          return JSON.stringify({ error: `Failed to search GitHub: ${errorMessage}` });
        }
      }
    };
    const githubGetRepoSchema = object({
      owner: string().describe('Repository owner/organization (e.g., "vercel")'),
      repo: string().describe('Repository name (e.g., "next.js")')
    });
    const githubGetRepoTool = {
      name: "api_github_get_repo",
      description: "Get GitHub repository metadata via API (description, stars, forks, topics, language, homepage, updated time). Use this for summarizing a specific repo.",
      schema: githubGetRepoSchema,
      execute: async ({ owner, repo }) => {
        var _a3;
        try {
          const url = `https://api.github.com/repos/${encodeURIComponent(owner)}/${encodeURIComponent(repo)}`;
          const response = await fetch(url, {
            headers: {
              "Accept": "application/vnd.github.v3+json",
              "User-Agent": "EnterpriseBrowser/1.0"
            }
          });
          if (!response.ok) {
            if (response.status === 403) {
              return JSON.stringify({ error: "Rate limited. Try browser_navigate to https://github.com/" + owner + "/" + repo + " instead." });
            }
            return JSON.stringify({ error: `GitHub API error: ${response.status} ${response.statusText}` });
          }
          const data = await response.json();
          const result = {
            full_name: String(data.full_name || ""),
            url: String(data.html_url || ""),
            description: String(data.description || ""),
            homepage: String(data.homepage || ""),
            topics: Array.isArray(data.topics) ? data.topics : [],
            language: String(data.language || ""),
            stars: Number(data.stargazers_count || 0),
            forks: Number(data.forks_count || 0),
            open_issues: Number(data.open_issues_count || 0),
            archived: Boolean(data.archived),
            updated_at: String(data.updated_at || ""),
            created_at: String(data.created_at || ""),
            license: ((_a3 = data.license) == null ? void 0 : _a3.spdx_id) || ""
          };
          return JSON.stringify(result, null, 2);
        } catch (e) {
          const errorMessage = e instanceof Error ? e.message : String(e);
          return JSON.stringify({ error: `Failed to fetch repo: ${errorMessage}` });
        }
      }
    };
    const githubGetReadmeSchema = object({
      owner: string().describe('Repository owner/organization (e.g., "vercel")'),
      repo: string().describe('Repository name (e.g., "next.js")'),
      ref: string().optional().describe('Optional git ref/branch/tag (e.g., "main")'),
      maxChars: number().optional().describe("Maximum characters of README to return (default: 6000)")
    });
    const githubGetReadmeTool = {
      name: "api_github_get_readme",
      description: "Fetch a GitHub repository README via API and return its text (truncated). Use this to summarize what a project does without relying on browser scraping.",
      schema: githubGetReadmeSchema,
      execute: async ({ owner, repo, ref, maxChars = 6e3 }) => {
        try {
          const qs = ref ? `?ref=${encodeURIComponent(ref)}` : "";
          const url = `https://api.github.com/repos/${encodeURIComponent(owner)}/${encodeURIComponent(repo)}/readme${qs}`;
          const response = await fetch(url, {
            headers: {
              "Accept": "application/vnd.github.v3+json",
              "User-Agent": "EnterpriseBrowser/1.0"
            }
          });
          if (!response.ok) {
            if (response.status === 404) {
              return JSON.stringify({ error: "README not found for this repository." });
            }
            if (response.status === 403) {
              return JSON.stringify({ error: "Rate limited. Try browser_navigate to https://github.com/" + owner + "/" + repo + " instead." });
            }
            return JSON.stringify({ error: `GitHub API error: ${response.status} ${response.statusText}` });
          }
          const data = await response.json();
          const contentBase64 = data.content || "";
          const encoding = data.encoding || "";
          if (!contentBase64 || encoding !== "base64") {
            return JSON.stringify({ error: "Unexpected README response format from GitHub API." });
          }
          const text = Buffer.from(contentBase64, "base64").toString("utf8");
          const truncated = text.slice(0, Math.max(0, Math.min(maxChars, 2e4)));
          return JSON.stringify(
            {
              owner,
              repo,
              name: data.name || "README",
              path: data.path || "",
              html_url: data.html_url || "",
              text: truncated,
              truncated: truncated.length < text.length
            },
            null,
            2
          );
        } catch (e) {
          const errorMessage = e instanceof Error ? e.message : String(e);
          return JSON.stringify({ error: `Failed to fetch README: ${errorMessage}` });
        }
      }
    };
    const hnTopStoriesSchema = object({
      limit: number().optional().describe("Number of stories to return (default: 5, max: 30)")
    });
    const hnTopStoriesTool = {
      name: "api_hackernews_top",
      description: "Get top stories from Hacker News via API. Returns titles, scores, URLs. Use this instead of navigating to news.ycombinator.com.",
      schema: hnTopStoriesSchema,
      execute: async ({ limit: limit2 = 5 }) => {
        try {
          const idsResponse = await fetch("https://hacker-news.firebaseio.com/v0/topstories.json");
          if (!idsResponse.ok) {
            return JSON.stringify({ error: "Failed to fetch HN top stories" });
          }
          const ids = await idsResponse.json();
          const storyLimit = Math.min(limit2, 30);
          const stories = await Promise.all(
            ids.slice(0, storyLimit).map(async (id) => {
              const storyResponse = await fetch(`https://hacker-news.firebaseio.com/v0/item/${id}.json`);
              return storyResponse.json();
            })
          );
          const results2 = stories.map((story) => ({
            title: String(story.title || ""),
            score: Number(story.score || 0),
            url: String(story.url || `https://news.ycombinator.com/item?id=${story.id}`),
            by: String(story.by || ""),
            comments: Number(story.descendants || 0)
          }));
          return JSON.stringify({ results: results2 }, null, 2);
        } catch (e) {
          const errorMessage = e instanceof Error ? e.message : String(e);
          return JSON.stringify({ error: `Failed to fetch HN stories: ${errorMessage}` });
        }
      }
    };
    const wikiTodaySchema = object({});
    const wikiTodayTool = {
      name: "api_wikipedia_featured",
      description: "Get today's featured article from Wikipedia via API. Use this instead of navigating to wikipedia.org.",
      schema: wikiTodaySchema,
      execute: async () => {
        var _a3, _b, _c, _d, _e, _f;
        try {
          const today = /* @__PURE__ */ new Date();
          const year = today.getFullYear();
          const month = String(today.getMonth() + 1).padStart(2, "0");
          const day = String(today.getDate()).padStart(2, "0");
          const url = `https://api.wikimedia.org/feed/v1/wikipedia/en/featured/${year}/${month}/${day}`;
          const response = await fetch(url, {
            headers: {
              "User-Agent": "EnterpriseBrowser/1.0"
            }
          });
          if (!response.ok) {
            return JSON.stringify({ error: `Wikipedia API error: ${response.status}` });
          }
          const data = await response.json();
          const result = {
            title: ((_a3 = data.tfa) == null ? void 0 : _a3.title) || "Unknown",
            extract: ((_c = (_b = data.tfa) == null ? void 0 : _b.extract) == null ? void 0 : _c.slice(0, 500)) || "",
            url: ((_f = (_e = (_d = data.tfa) == null ? void 0 : _d.content_urls) == null ? void 0 : _e.desktop) == null ? void 0 : _f.page) || ""
          };
          return JSON.stringify(result, null, 2);
        } catch (e) {
          const errorMessage = e instanceof Error ? e.message : String(e);
          return JSON.stringify({ error: `Failed to fetch Wikipedia featured: ${errorMessage}` });
        }
      }
    };
    const httpGetSchema = object({
      url: string().describe("URL to fetch"),
      headers: record(string(), string()).optional().describe("Optional headers")
    });
    const httpGetTool = {
      name: "api_http_get",
      description: "Make a simple HTTP GET request to any URL. Returns the response body. Useful for APIs that return JSON.",
      schema: httpGetSchema,
      execute: async ({ url, headers = {} }) => {
        try {
          const response = await fetch(url, {
            headers: {
              "User-Agent": "EnterpriseBrowser/1.0",
              ...headers
            }
          });
          if (!response.ok) {
            return JSON.stringify({ error: `HTTP ${response.status}: ${response.statusText}` });
          }
          const contentType = response.headers.get("content-type") || "";
          if (contentType.includes("application/json")) {
            const data = await response.json();
            return JSON.stringify(data, null, 2);
          }
          const text = await response.text();
          return text.slice(0, 5e3);
        } catch (e) {
          const errorMessage = e instanceof Error ? e.message : String(e);
          return JSON.stringify({ error: `HTTP request failed: ${errorMessage}` });
        }
      }
    };
    const cryptoPriceSchema = object({
      coin: string().describe('Cryptocurrency name or symbol (e.g., "bitcoin", "ethereum", "btc", "eth")')
    });
    const cryptoPriceTool = {
      name: "api_crypto_price",
      description: "Get current cryptocurrency price via CoinGecko API. Use this instead of navigating to coinmarketcap.com. Returns price in USD, 24h change, and market cap.",
      schema: cryptoPriceSchema,
      execute: async ({ coin }) => {
        var _a3;
        try {
          const coinMap = {
            "btc": "bitcoin",
            "eth": "ethereum",
            "sol": "solana",
            "doge": "dogecoin",
            "xrp": "ripple",
            "ada": "cardano",
            "dot": "polkadot",
            "matic": "polygon",
            "link": "chainlink",
            "avax": "avalanche-2"
          };
          const coinId = coinMap[coin.toLowerCase()] || coin.toLowerCase();
          const url = `https://api.coingecko.com/api/v3/simple/price?ids=${coinId}&vs_currencies=usd&include_24hr_change=true&include_market_cap=true`;
          const response = await fetch(url, {
            headers: { "User-Agent": "EnterpriseBrowser/1.0" }
          });
          if (!response.ok) {
            return JSON.stringify({ error: `CoinGecko API error: ${response.status}` });
          }
          const data = await response.json();
          if (!data[coinId]) {
            return JSON.stringify({ error: `Coin '${coin}' not found.` });
          }
          const coinData = data[coinId];
          const result = {
            coin: coinId,
            price_usd: coinData.usd,
            change_24h_percent: ((_a3 = coinData.usd_24h_change) == null ? void 0 : _a3.toFixed(2)) + "%",
            market_cap_usd: coinData.usd_market_cap
          };
          return JSON.stringify(result, null, 2);
        } catch (e) {
          const errorMessage = e instanceof Error ? e.message : String(e);
          return JSON.stringify({ error: `Failed to fetch crypto price: ${errorMessage}` });
        }
      }
    };
    const weatherSchema = object({
      latitude: number().describe("Latitude of the location"),
      longitude: number().describe("Longitude of the location"),
      city: string().optional().describe("City name for display purposes")
    });
    const weatherTool = {
      name: "api_weather",
      description: "Get current weather via Open-Meteo API.",
      schema: weatherSchema,
      execute: async ({ latitude, longitude, city }) => {
        try {
          const url = `https://api.open-meteo.com/v1/forecast?latitude=${latitude}&longitude=${longitude}&current=temperature_2m,relative_humidity_2m,apparent_temperature,precipitation,rain,showers,snowfall,weather_code,wind_speed_10m&temperature_unit=fahrenheit&wind_speed_unit=mph&precipitation_unit=inch`;
          const response = await fetch(url);
          if (!response.ok) return JSON.stringify({ error: `Weather API error: ${response.status}` });
          const data = await response.json();
          const current = data.current;
          return JSON.stringify({
            location: city || `${latitude}, ${longitude}`,
            temperature: `${current.temperature_2m}Â°F`,
            feels_like: `${current.apparent_temperature}Â°F`,
            humidity: `${current.relative_humidity_2m}%`,
            wind_speed: `${current.wind_speed_10m} mph`,
            condition_code: current.weather_code,
            units: data.current_units
          }, null, 2);
        } catch (e) {
          const errorMessage = e instanceof Error ? e.message : String(e);
          return JSON.stringify({ error: `Failed to fetch weather: ${errorMessage}` });
        }
      }
    };
    const webSearchSchema = object({
      query: string().describe("Search query")
    });
    const webSearchTool = {
      name: "api_web_search",
      description: "Search the web via DuckDuckGo API.",
      schema: webSearchSchema,
      execute: async ({ query }) => {
        var _a3;
        try {
          const url = `https://api.duckduckgo.com/?q=${encodeURIComponent(query)}&format=json&no_html=1&skip_disambig=1`;
          const response = await fetch(url, { headers: { "User-Agent": "EnterpriseBrowser/1.0" } });
          if (!response.ok) {
            const searchUrl = `https://duckduckgo.com/?q=${encodeURIComponent(query)}`;
            return JSON.stringify({ status: "browser_required", message: `API unavailable.`, url: searchUrl });
          }
          const data = await response.json();
          if (!data.AbstractText && (!data.RelatedTopics || data.RelatedTopics.length === 0)) {
            const searchUrl = `https://duckduckgo.com/?q=${encodeURIComponent(query)}`;
            return JSON.stringify({ status: "browser_required", message: `No instant answer available.`, url: searchUrl });
          }
          return JSON.stringify({
            status: "success",
            abstract: data.AbstractText,
            source: data.AbstractSource,
            url: data.AbstractURL,
            related: (_a3 = data.RelatedTopics) == null ? void 0 : _a3.slice(0, 5).map((topic) => ({ text: topic.Text, url: topic.FirstURL }))
          }, null, 2);
        } catch (e) {
          const errorMessage = e instanceof Error ? e.message : String(e);
          const searchUrl = `https://duckduckgo.com/?q=${encodeURIComponent(query)}`;
          return JSON.stringify({ status: "browser_required", message: `Search API failed: ${errorMessage}`, url: searchUrl });
        }
      }
    };
    const cityCoordSchema = object({
      city: string().describe("City name")
    });
    const cityCoordTool = {
      name: "lookup_city_coordinates",
      description: "Get latitude and longitude for a city name.",
      schema: cityCoordSchema,
      execute: async ({ city }) => {
        try {
          const url = `https://geocoding-api.open-meteo.com/v1/search?name=${encodeURIComponent(city)}&count=1&language=en&format=json`;
          const response = await fetch(url);
          if (!response.ok) return JSON.stringify({ error: `Geocoding API error: ${response.status}` });
          const data = await response.json();
          if (!data.results || data.results.length === 0) return JSON.stringify({ error: `City '${city}' not found.` });
          const result = data.results[0];
          return JSON.stringify({
            city: result.name,
            country: result.country,
            latitude: result.latitude,
            longitude: result.longitude,
            timezone: result.timezone
          }, null, 2);
        } catch (e) {
          const errorMessage = e instanceof Error ? e.message : String(e);
          return JSON.stringify({ error: `Failed to lookup city: ${errorMessage}` });
        }
      }
    };
    toolRegistry.register(githubSearchTool);
    toolRegistry.register(githubGetRepoTool);
    toolRegistry.register(githubGetReadmeTool);
    toolRegistry.register(hnTopStoriesTool);
    toolRegistry.register(wikiTodayTool);
    toolRegistry.register(httpGetTool);
    toolRegistry.register(cryptoPriceTool);
    toolRegistry.register(weatherTool);
    toolRegistry.register(webSearchTool);
    toolRegistry.register(cityCoordTool);
  }
}
const webAPIService = new WebAPIService();
dotenv.config();
const SkillSchema = object({
  id: string(),
  name: string(),
  description: string(),
  domain: string(),
  fingerprint: string().optional(),
  steps: array(
    object({
      action: _enum(["navigate", "click", "type", "select", "wait", "open_tab", "workflow_task"]),
      url: string().optional(),
      selector: string().optional(),
      value: string().optional(),
      text: string().optional(),
      id: string().optional(),
      dependencies: array(string()).optional(),
      tool: string().optional(),
      args: any().optional()
    })
  ),
  isWorkflow: boolean().optional(),
  currentVersion: number(),
  embedding: array(number()).optional(),
  stats: object({
    successes: number(),
    failures: number(),
    partials: number().optional(),
    lastUsed: number(),
    lastOutcomeAt: number().optional(),
    lastOutcomeSuccess: boolean().optional()
  }),
  feedback: array(
    object({
      ts: number(),
      label: _enum(["worked", "failed", "partial"]),
      version: number().optional(),
      runId: string().optional(),
      domain: string().optional(),
      fingerprint: string().optional()
    })
  ).optional(),
  versions: array(
    object({
      version: number(),
      steps: array(
        object({
          action: _enum(["navigate", "click", "type", "select", "wait", "open_tab", "workflow_task"]),
          url: string().optional(),
          selector: string().optional(),
          value: string().optional(),
          text: string().optional(),
          id: string().optional(),
          dependencies: array(string()).optional(),
          tool: string().optional(),
          args: any().optional()
        })
      ),
      isWorkflow: boolean().optional(),
      createdAt: number()
    })
  ),
  tags: array(string())
});
class LocalJsonSkillStorage {
  constructor(storageFile) {
    __publicField2(this, "storageFile");
    this.storageFile = storageFile;
  }
  getAllSync() {
    try {
      const data = fs__default.readFileSync(this.storageFile, "utf8");
      const parsed = JSON.parse(data);
      if (!Array.isArray(parsed)) return [];
      const out = [];
      for (const s of parsed) {
        try {
          out.push(SkillSchema.parse(s));
        } catch {
        }
      }
      return out;
    } catch {
      return [];
    }
  }
  async getAll() {
    try {
      const data = await fs__default.promises.readFile(this.storageFile, "utf8");
      const parsed = JSON.parse(data);
      if (!Array.isArray(parsed)) return [];
      const out = [];
      for (const s of parsed) {
        try {
          out.push(SkillSchema.parse(s));
        } catch {
        }
      }
      return out;
    } catch {
      try {
        const legacyPath = path__default$1.resolve(process.cwd(), "task_knowledge.json");
        if (fs__default.existsSync(legacyPath)) {
          const legacyData = await fs__default.promises.readFile(legacyPath, "utf8");
          const plans = JSON.parse(legacyData);
          const migrated = Array.isArray(plans) ? plans.map((p) => {
            const createdAt = Date.now();
            return {
              id: v4$2(),
              name: String((p == null ? void 0 : p.goal) ?? "").toLowerCase().replace(/\s+/g, "_").slice(0, 50),
              description: String((p == null ? void 0 : p.goal) ?? ""),
              domain: "unknown",
              steps: Array.isArray(p == null ? void 0 : p.steps) ? p.steps : [],
              currentVersion: 1,
              stats: { successes: 0, failures: 0, partials: 0, lastUsed: createdAt },
              feedback: [],
              versions: [{ version: 1, steps: Array.isArray(p == null ? void 0 : p.steps) ? p.steps : [], createdAt }],
              tags: Array.isArray(p == null ? void 0 : p.trigger_keywords) ? p.trigger_keywords : []
            };
          }) : [];
          await this.putAll(migrated);
          return migrated;
        }
      } catch {
      }
      return [];
    }
  }
  async putAll(skills) {
    await fs__default.promises.writeFile(this.storageFile, JSON.stringify(skills, null, 2));
  }
}
class CloudSkillStorage {
  async getAll() {
    const rows = await webAPIService.getSkillLibrary();
    const out = [];
    for (const s of rows) {
      try {
        out.push(SkillSchema.parse(s));
      } catch {
      }
    }
    return out;
  }
  async putAll(skills) {
    await webAPIService.upsertSkillLibrary(skills);
  }
}
class TaskKnowledgeService {
  constructor() {
    __publicField2(this, "storageFile");
    __publicField2(this, "localStorage");
    __publicField2(this, "cloudStorage");
    __publicField2(this, "skills", []);
    __publicField2(this, "cloudPushTimer", null);
    var _a3, _b;
    this.storageFile = path__default$1.resolve(process.cwd(), "skill_library.json");
    this.localStorage = new LocalJsonSkillStorage(this.storageFile);
    this.cloudStorage = process.env.SKILL_CLOUD_BASE_URL ? new CloudSkillStorage() : null;
    const maybeSync = (_b = (_a3 = this.localStorage).getAllSync) == null ? void 0 : _b.call(_a3);
    if (Array.isArray(maybeSync) && maybeSync.length > 0) {
      this.skills = maybeSync;
    }
    this.init().catch(() => void 0);
    this.registerTools();
  }
  async init() {
    const local = await this.localStorage.getAll().catch(() => []);
    this.skills = local;
    await this.normalizeLoadedSkills();
    if (this.cloudStorage) {
      const remote = await this.cloudStorage.getAll().catch(() => []);
      const merged = await this.mergeSkillLibraries(local, remote);
      this.skills = merged;
      await this.save();
    }
    await this.pruneStaleSkills();
  }
  /**
   * Prune skills that have consistently failed or haven't been used in a long time.
   * This prevents memory bloat and removes outdated institutional knowledge.
   */
  async pruneStaleSkills() {
    const now = Date.now();
    const originalCount = this.skills.length;
    this.skills = this.skills.filter((skill) => {
      const total = skill.stats.successes + skill.stats.failures;
      const successRate = total > 0 ? skill.stats.successes / total : 0.5;
      const daysSinceLastUse = (now - skill.stats.lastUsed) / (24 * 60 * 60 * 1e3);
      if (total >= 5 && successRate < 0.2) {
        console.log(`[TaskKnowledge] Pruning low-success skill: ${skill.name} (${Math.round(successRate * 100)}% success)`);
        return false;
      }
      if (daysSinceLastUse > 90 && successRate < 0.5) {
        console.log(`[TaskKnowledge] Pruning stale skill: ${skill.name} (${Math.round(daysSinceLastUse)} days old)`);
        return false;
      }
      if (daysSinceLastUse > 30 && skill.stats.successes === 0 && skill.stats.failures > 0) {
        console.log(`[TaskKnowledge] Pruning failed skill: ${skill.name} (0 successes, ${skill.stats.failures} failures)`);
        return false;
      }
      return true;
    });
    const pruned = originalCount - this.skills.length;
    if (pruned > 0) {
      console.log(`[TaskKnowledge] Pruned ${pruned} stale skills`);
      await this.save();
    }
  }
  skillIdentity(s) {
    const fp = s.fingerprint ?? "";
    return `${s.domain}::${fp}::${s.name}`;
  }
  async mergeSkillLibraries(local, remote) {
    const byKey = /* @__PURE__ */ new Map();
    for (const s of remote) byKey.set(this.skillIdentity(s), s);
    for (const s of local) {
      const k = this.skillIdentity(s);
      const existing = byKey.get(k);
      if (!existing) {
        byKey.set(k, s);
        continue;
      }
      const existingVer = typeof existing.currentVersion === "number" ? existing.currentVersion : 1;
      const localVer = typeof s.currentVersion === "number" ? s.currentVersion : 1;
      const base = existingVer >= localVer ? existing : s;
      const other = base === existing ? s : existing;
      const merged = {
        ...base,
        id: s.id || existing.id,
        tags: Array.from(/* @__PURE__ */ new Set([...base.tags || [], ...other.tags || []])),
        versions: Array.isArray(base.versions) && base.versions.length >= (other.versions || []).length ? base.versions : other.versions,
        steps: base.steps && base.steps.length > 0 ? base.steps : other.steps,
        stats: s.stats || existing.stats,
        feedback: Array.isArray(s.feedback) ? s.feedback : Array.isArray(existing.feedback) ? existing.feedback : [],
        embedding: Array.isArray(base.embedding) && base.embedding.length > 0 ? base.embedding : other.embedding
      };
      byKey.set(k, merged);
    }
    const out = Array.from(byKey.values());
    for (const s of out) {
      if (!Array.isArray(s.embedding) || s.embedding.length === 0) {
        s.embedding = await this.computeSkillEmbedding(this.buildSkillText(s));
      }
    }
    if (this.cloudStorage) {
      this.cloudStorage.putAll(out).catch(() => void 0);
    }
    return out;
  }
  async normalizeLoadedSkills() {
    var _a3;
    for (const s of this.skills) {
      const v = Array.isArray(s == null ? void 0 : s.versions) ? s.versions : [];
      if (typeof s.currentVersion !== "number") {
        const latest = v.length > 0 ? Number(((_a3 = v[v.length - 1]) == null ? void 0 : _a3.version) ?? v.length) : 1;
        s.currentVersion = latest;
      }
      if (!s.stats || typeof s.stats !== "object") {
        s.stats = { successes: 0, failures: 0, partials: 0, lastUsed: Date.now() };
      }
      if (typeof s.stats.successes !== "number") s.stats.successes = 0;
      if (typeof s.stats.failures !== "number") s.stats.failures = 0;
      if (typeof s.stats.partials !== "number") s.stats.partials = 0;
      if (typeof s.stats.lastUsed !== "number") s.stats.lastUsed = Date.now();
      if (!Array.isArray(s.tags)) s.tags = [];
      if (!Array.isArray(s.feedback)) s.feedback = [];
      if (!Array.isArray(s.embedding) || s.embedding.length === 0) {
        s.embedding = await this.computeSkillEmbedding(this.buildSkillText(s));
      }
    }
  }
  normalizeText(text) {
    return String(text ?? "").toLowerCase().replace(/_/g, " ").replace(/[^a-z0-9\-\s/.:]+/g, " ").replace(/\s+/g, " ").trim();
  }
  tokenize(text) {
    const normalized = this.normalizeText(text);
    if (!normalized) return [];
    return normalized.split(" ").filter(Boolean).slice(0, 400);
  }
  computeEmbedding(text) {
    const dim2 = 256;
    const vec = new Array(dim2).fill(0);
    const tokens = this.tokenize(text);
    for (const tok of tokens) {
      let h = 2166136261;
      for (let i2 = 0; i2 < tok.length; i2++) {
        h ^= tok.charCodeAt(i2);
        h = Math.imul(h, 16777619);
      }
      const idx = Math.abs(h) % dim2;
      vec[idx] += 1;
    }
    let norm = 0;
    for (const x of vec) norm += x * x;
    norm = Math.sqrt(norm) || 1;
    return vec.map((x) => x / norm);
  }
  cosineSimilarity(a, b) {
    if (!a || !b || a.length === 0 || b.length === 0) return 0;
    const n = Math.min(a.length, b.length);
    let dot = 0;
    for (let i2 = 0; i2 < n; i2++) dot += a[i2] * b[i2];
    return dot;
  }
  /**
   * Compute embedding via OpenAI API (text-embedding-3-small)
   * Falls back to local hash-based embedding if API fails
   */
  async computeApiEmbedding(text) {
    var _a3, _b;
    const apiKey = process.env.OPENAI_API_KEY;
    if (!apiKey) {
      console.warn("[TaskKnowledge] No OPENAI_API_KEY, using local embedding");
      return this.computeEmbedding(text);
    }
    const timeoutMs = Number(process.env.SKILL_EMBEDDING_TIMEOUT_MS ?? 5e3);
    const controller = new AbortController();
    const timeout = setTimeout(() => controller.abort(), timeoutMs);
    try {
      const response = await fetch("https://api.openai.com/v1/embeddings", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${apiKey}`
        },
        body: JSON.stringify({
          model: "text-embedding-3-small",
          input: text.substring(0, 8e3)
          // Limit input length
        }),
        signal: controller.signal
      });
      if (!response.ok) {
        console.warn("[TaskKnowledge] Embedding API error:", response.status);
        return this.computeEmbedding(text);
      }
      const data = await response.json();
      if ((_b = (_a3 = data.data) == null ? void 0 : _a3[0]) == null ? void 0 : _b.embedding) {
        return data.data[0].embedding;
      }
    } catch (e) {
      console.warn("[TaskKnowledge] Embedding API failed:", e);
    } finally {
      clearTimeout(timeout);
    }
    return this.computeEmbedding(text);
  }
  /**
   * Find nearest skill by embedding similarity
   * @param query - User query text
   * @param threshold - Minimum similarity threshold (0-1)
   * @returns Skill and similarity score if above threshold, null otherwise
   */
  async findNearest(query, threshold = 0.8) {
    if (this.skills.length === 0) return null;
    const queryEmbedding = await this.computeSkillEmbedding(query);
    const queryTokens = this.tokenize(query);
    let bestMatch = null;
    for (const skill of this.skills) {
      const total = skill.stats.successes + skill.stats.failures;
      if (total > 3 && skill.stats.failures > skill.stats.successes) {
        continue;
      }
      let similarity = this.cosineSimilarity(skill.embedding, queryEmbedding);
      if (queryTokens.length > 0) {
        const skillText = this.normalizeText(skill.name + " " + skill.description + " " + (skill.tags || []).join(" "));
        const skillTokens = new Set(skillText.split(" "));
        const overlap = queryTokens.filter((t2) => skillTokens.has(t2)).length;
        const overlapRatio = overlap / queryTokens.length;
        if (overlapRatio > 0.75) {
          similarity = Math.max(similarity, 0.85);
        } else if (overlapRatio > 0.5) {
          similarity = Math.max(similarity, 0.75);
        }
      }
      if (similarity >= threshold) {
        if (!bestMatch || similarity > bestMatch.similarity) {
          bestMatch = { skill, similarity };
        }
      }
    }
    if (bestMatch) {
      console.log(`[TaskKnowledge] Found nearest skill: ${bestMatch.skill.name} (similarity: ${bestMatch.similarity.toFixed(3)})`);
    }
    return bestMatch;
  }
  /**
   * Mark a skill as stale (failed during warm-start execution)
   */
  markStale(skillId) {
    const skill = this.skills.find((s) => s.id === skillId);
    if (skill) {
      skill.stats.failures++;
      skill.stats.lastOutcomeAt = Date.now();
      skill.stats.lastOutcomeSuccess = false;
      this.save();
      console.log(`[TaskKnowledge] Marked skill ${skill.name} as stale`);
    }
  }
  buildSkillText(skill) {
    const stepBits = (skill.steps || []).map((s) => [s.action, s.url, s.selector, s.value, s.text].filter(Boolean).join(" ")).join(" ");
    return [skill.name, skill.description, skill.domain, skill.fingerprint ?? "", ...skill.tags || [], stepBits].filter(Boolean).join(" ");
  }
  async save() {
    try {
      await this.localStorage.putAll(this.skills);
      this.scheduleCloudPush();
    } catch (err) {
      console.error("Failed to save skill library:", err);
    }
  }
  scheduleCloudPush() {
    if (!this.cloudStorage) return;
    if (this.cloudPushTimer) clearTimeout(this.cloudPushTimer);
    this.cloudPushTimer = setTimeout(() => {
      var _a3;
      this.cloudPushTimer = null;
      (_a3 = this.cloudStorage) == null ? void 0 : _a3.putAll(this.skills).catch(() => void 0);
    }, 750);
  }
  async computeSkillEmbedding(text) {
    const mode = String(process.env.SKILL_EMBEDDING_MODE ?? "local").toLowerCase();
    if (mode === "openai") {
      return await this.computeApiEmbedding(text);
    }
    return this.computeEmbedding(text);
  }
  findSkill(query, domain, fingerprint) {
    const q = query.toLowerCase();
    let candidates = this.skills;
    if (domain) {
      candidates = candidates.filter(
        (s) => s.domain === domain || domain.includes(s.domain) || s.domain === "unknown"
      );
    }
    if (fingerprint) {
      candidates = candidates.filter((s) => {
        if (!s.fingerprint) return true;
        return fingerprint.includes(s.fingerprint) || s.fingerprint.includes(fingerprint);
      });
    }
    const queryEmbedding = this.computeEmbedding(query);
    const scored = candidates.map((skill) => {
      let score = 0;
      if (skill.name.replace(/_/g, " ").includes(q)) score += 10;
      if (skill.description.toLowerCase().includes(q)) score += 5;
      if (skill.tags.some((t2) => q.includes(t2.toLowerCase()))) score += 3;
      const partials = skill.stats.partials ?? 0;
      const total = skill.stats.successes + skill.stats.failures + partials;
      if (total > 0) {
        const weightedSuccess = (skill.stats.successes + 0.5 * partials) / total;
        score += weightedSuccess * 2;
      }
      if (fingerprint && skill.fingerprint) {
        if (fingerprint === skill.fingerprint) score += 3;
        else if (fingerprint.includes(skill.fingerprint) || skill.fingerprint.includes(fingerprint)) score += 1;
      }
      const sim = this.cosineSimilarity(skill.embedding, queryEmbedding);
      score += sim * 10;
      const fb = Array.isArray(skill.feedback) ? skill.feedback : [];
      const recent = fb.slice(-6);
      for (const e of recent) {
        if (e.label === "worked") score += 0.6;
        if (e.label === "partial") score += 0.2;
        if (e.label === "failed") score -= 0.6;
      }
      return { skill, score };
    });
    scored.sort((a, b) => b.score - a.score);
    if (scored.length > 0 && scored[0].score > 0) {
      return scored[0].skill;
    }
    return null;
  }
  addSkill(input) {
    const existingIndex = this.skills.findIndex(
      (s) => s.name === input.name && s.domain === input.domain
    );
    if (existingIndex >= 0) {
      const existing = this.skills[existingIndex];
      const newVersion = (existing.versions.length > 0 ? existing.versions[existing.versions.length - 1].version : 0) + 1;
      existing.versions.push({
        version: newVersion,
        steps: input.steps,
        isWorkflow: input.isWorkflow,
        createdAt: Date.now()
      });
      existing.steps = input.steps;
      existing.description = input.description;
      existing.domain = input.domain;
      existing.fingerprint = input.fingerprint ?? existing.fingerprint;
      existing.isWorkflow = input.isWorkflow ?? existing.isWorkflow;
      existing.currentVersion = newVersion;
      existing.tags = Array.from(/* @__PURE__ */ new Set([...existing.tags, ...input.tags]));
      existing.stats.lastUsed = Date.now();
      existing.stats.successes += 1;
      existing.stats.lastOutcomeAt = Date.now();
      existing.stats.lastOutcomeSuccess = true;
      existing.embedding = this.computeEmbedding(this.buildSkillText(existing));
      this.skills[existingIndex] = existing;
    } else {
      const newSkill = {
        id: v4$2(),
        name: input.name,
        description: input.description,
        domain: input.domain,
        fingerprint: input.fingerprint,
        isWorkflow: input.isWorkflow,
        steps: input.steps,
        currentVersion: 1,
        embedding: this.computeEmbedding(this.buildSkillText({
          id: "tmp",
          name: input.name,
          description: input.description,
          domain: input.domain,
          fingerprint: input.fingerprint,
          isWorkflow: input.isWorkflow,
          steps: input.steps,
          currentVersion: 1,
          stats: { successes: 1, failures: 0, partials: 0, lastUsed: Date.now(), lastOutcomeAt: Date.now(), lastOutcomeSuccess: true },
          versions: [{ version: 1, steps: input.steps, isWorkflow: input.isWorkflow, createdAt: Date.now() }],
          tags: input.tags
        })),
        stats: { successes: 1, failures: 0, partials: 0, lastUsed: Date.now(), lastOutcomeAt: Date.now(), lastOutcomeSuccess: true },
        feedback: [],
        versions: [{ version: 1, steps: input.steps, isWorkflow: input.isWorkflow, createdAt: Date.now() }],
        tags: input.tags
      };
      this.skills.push(newSkill);
    }
    this.save();
  }
  recordOutcome(skillId, success2) {
    this.recordFeedback(skillId, success2 ? "worked" : "failed");
  }
  recordFeedback(skillId, label, version2) {
    const skill = this.skills.find((s) => s.id === skillId);
    if (!skill) return;
    if (label === "worked") skill.stats.successes++;
    if (label === "failed") skill.stats.failures++;
    if (label === "partial") skill.stats.partials = (skill.stats.partials ?? 0) + 1;
    skill.stats.lastUsed = Date.now();
    skill.stats.lastOutcomeAt = Date.now();
    skill.stats.lastOutcomeSuccess = label === "worked";
    const runId = agentRunContext.getRunId() ?? void 0;
    const ctx = agentRunContext.getBrowserContext();
    const entry = {
      ts: Date.now(),
      label,
      version: version2 ?? skill.currentVersion,
      runId,
      domain: ctx == null ? void 0 : ctx.domain,
      fingerprint: (() => {
        const url = ctx == null ? void 0 : ctx.url;
        if (!url) return void 0;
        try {
          const u = new URL(url);
          return u.pathname || void 0;
        } catch {
          return void 0;
        }
      })()
    };
    if (!Array.isArray(skill.feedback)) skill.feedback = [];
    skill.feedback.push(entry);
    if (skill.feedback.length > 200) skill.feedback = skill.feedback.slice(-200);
    this.save();
  }
  rollbackSkill(skillId, version2) {
    const skill = this.skills.find((s) => s.id === skillId);
    if (!skill) return false;
    const v = skill.versions.find((x) => x.version === version2);
    if (!v) return false;
    skill.steps = v.steps;
    skill.currentVersion = v.version;
    skill.stats.lastUsed = Date.now();
    this.save();
    return true;
  }
  registerTools() {
    const saveSkillSchema = object({
      name: string().describe('Short identifier for the skill (e.g. "create_jira_issue")'),
      description: string().describe("Description of what the skill does"),
      domain: string().optional().describe('Domain where this skill applies (e.g. "localhost:3000")'),
      fingerprint: string().optional().describe('Optional page fingerprint (e.g. "/jira" or "/aerocore/admin")'),
      isWorkflow: boolean().optional().describe("Whether this is a DAG-based workflow"),
      steps: array(
        object({
          action: _enum(["navigate", "click", "type", "select", "wait", "open_tab", "workflow_task"]),
          url: string().optional(),
          selector: string().optional(),
          value: string().optional(),
          text: string().optional(),
          id: string().optional(),
          dependencies: array(string()).optional(),
          tool: string().optional(),
          args: any().optional()
        })
      ),
      tags: array(string()).describe("Keywords for retrieval")
    });
    const saveSkillTool = {
      name: "knowledge_save_skill",
      description: "Save a verified execution plan or DAG-based workflow as a reusable skill.",
      schema: saveSkillSchema,
      execute: async (args) => {
        const input = saveSkillSchema.parse(args);
        const ctx = agentRunContext.getBrowserContext();
        const domain = input.domain ?? (ctx == null ? void 0 : ctx.domain) ?? "unknown";
        const fingerprint = (() => {
          if (input.fingerprint) return input.fingerprint;
          const url = ctx == null ? void 0 : ctx.url;
          if (!url) return void 0;
          try {
            const u = new URL(url);
            return u.pathname || void 0;
          } catch {
            return void 0;
          }
        })();
        this.addSkill({
          name: input.name,
          description: input.description,
          domain,
          fingerprint,
          isWorkflow: input.isWorkflow,
          steps: input.steps,
          tags: input.tags
        });
        return `Saved ${input.isWorkflow ? "workflow" : "skill"} "${input.name}" for domain ${domain}.`;
      }
    };
    const searchSkillTool = {
      name: "knowledge_search_skill",
      description: "Search for a saved skill matching the user request and domain.",
      schema: object({
        query: string().describe("User request description"),
        domain: string().optional().describe("Current domain context"),
        fingerprint: string().optional().describe("Optional page fingerprint for disambiguation")
      }),
      execute: async (args) => {
        const { query, domain, fingerprint } = args;
        const ctx = agentRunContext.getBrowserContext();
        const effectiveDomain = domain ?? (ctx == null ? void 0 : ctx.domain);
        const effectiveFingerprint = fingerprint ?? (() => {
          const url = ctx == null ? void 0 : ctx.url;
          if (!url) return void 0;
          try {
            const u = new URL(url);
            return u.pathname || void 0;
          } catch {
            return void 0;
          }
        })();
        const skill = this.findSkill(query, effectiveDomain, effectiveFingerprint);
        if (skill) {
          return JSON.stringify({
            found: true,
            skill: {
              id: skill.id,
              name: skill.name,
              description: skill.description,
              domain: skill.domain,
              fingerprint: skill.fingerprint,
              currentVersion: skill.currentVersion,
              steps: skill.steps,
              stats: skill.stats
            }
          });
        }
        return JSON.stringify({ found: false });
      }
    };
    const recordOutcomeTool = {
      name: "knowledge_record_outcome",
      description: "Record whether a skill execution succeeded or failed.",
      schema: object({
        skillId: string(),
        success: boolean().optional(),
        label: _enum(["worked", "failed", "partial"]).optional(),
        version: number().optional()
      }),
      execute: async (args) => {
        const { skillId, success: success2, label, version: version2 } = args;
        const resolvedLabel = label ?? (success2 === true ? "worked" : success2 === false ? "failed" : "worked");
        this.recordFeedback(skillId, resolvedLabel, version2);
        return `Recorded ${resolvedLabel} for skill ${skillId}.`;
      }
    };
    const rollbackTool = {
      name: "knowledge_rollback_skill",
      description: "Rollback a skill to a previous version.",
      schema: object({
        skillId: string(),
        version: number().describe("Version number to restore")
      }),
      execute: async (args) => {
        const { skillId, version: version2 } = args;
        const ok = this.rollbackSkill(skillId, version2);
        return ok ? `Rolled back skill ${skillId} to version ${version2}.` : `Failed to rollback skill ${skillId} to version ${version2}.`;
      }
    };
    const listSkillsTool = {
      name: "knowledge_list_skills",
      description: "List saved skills for debugging and evaluation.",
      schema: object({
        domain: string().optional()
      }),
      execute: async (args) => {
        const { domain } = args ?? {};
        const ctx = agentRunContext.getBrowserContext();
        const effectiveDomain = domain ?? (ctx == null ? void 0 : ctx.domain);
        const skills = effectiveDomain ? this.skills.filter((s) => s.domain === effectiveDomain || s.domain === "unknown") : this.skills;
        const out = skills.map((s) => {
          const total = s.stats.successes + s.stats.failures;
          const rate = total > 0 ? s.stats.successes / total : null;
          return {
            id: s.id,
            name: s.name,
            domain: s.domain,
            fingerprint: s.fingerprint,
            currentVersion: s.currentVersion,
            successes: s.stats.successes,
            failures: s.stats.failures,
            successRate: rate,
            versions: s.versions.map((v) => v.version),
            lastUsed: s.stats.lastUsed,
            tags: s.tags
          };
        }).sort((a, b) => (b.successRate ?? -1) - (a.successRate ?? -1));
        return JSON.stringify({ count: out.length, skills: out }, null, 2);
      }
    };
    toolRegistry.register(saveSkillTool);
    toolRegistry.register(searchSkillTool);
    toolRegistry.register(recordOutcomeTool);
    toolRegistry.register(rollbackTool);
    toolRegistry.register(listSkillsTool);
  }
}
const taskKnowledgeService = new TaskKnowledgeService();
function getPrimaryDomainToken(hostname) {
  const host = String(hostname || "").toLowerCase().trim();
  if (!host) return null;
  const parts = host.split(".").filter(Boolean);
  if (parts.length === 0) return null;
  if (parts[0] === "localhost") return "localhost";
  const cleaned = parts[0] === "www" ? parts.slice(1) : parts;
  if (cleaned.length >= 2) return cleaned[cleaned.length - 2];
  return cleaned[0] ?? null;
}
const IN_CONTEXT_PATTERNS = [
  /\b(summarize|summary of)\s+(this|the|current)\s+(page|article|content|document)/i,
  /\b(explain|describe)\s+(this|what('s| is) on|the current)/i,
  /\b(find|search|look for)\s+(on|in|within)\s+(this|the|current)\s+(page|document)/i,
  /\b(scroll|go)\s+(down|up|to the|to section)/i,
  /\bwhat('s| is)\s+(this|on this page|here)\b/i,
  /\b(read|analyze|extract from)\s+(this|the current|the page)/i,
  /\b(click|press|select|fill|type|enter)\s/i,
  /\b(submit|save|create|add|delete|remove|update|edit)\s+(the|this|a)\b/i,
  /\bthis\s+(page|repo|article|document|form|table|list)\b/i,
  /\b(on|in|within)\s+this\s+(page|site|tab)\b/i
];
const EXPLORATORY_PATTERNS = [
  /\b(find|search|look up|look for|research)\s+(articles?|information|docs?|documentation|alternatives?|examples?|tutorials?)\s+(about|on|for|regarding)/i,
  /\b(compare|contrast)\s+(this|it)\s+(with|to|against)/i,
  /\b(go to|open|navigate to|visit)\s+(a different|another|new|the)\s+(page|site|website|url)/i,
  /\b(search|google|look up)\s+(for|about)?\s*[^(this|the current)]/i,
  /\bfind\s+(me\s+)?(an?|some|the)\s+(article|page|site|resource|documentation)/i,
  /\b(what is|who is|where is|how to|how do)\b(?!.*\b(this|here|on this page)\b)/i,
  /\b(learn|read)\s+(more\s+)?(about|regarding)/i
];
const EXPLICIT_REPLACE_TAB = [
  /\breplace\s+(this|the|current)\s+tab\b/i,
  /\bin\s+(this|the same)\s+tab\b/i,
  /\buse\s+(this|the current)\s+(page|tab)\b/i,
  /\bnavigate\s+away\b/i
];
const EXPLICIT_BACKGROUND = [
  /\b(in the\s+)?background\b/i,
  /\bdon't\s+(switch|change|leave)\b/i,
  /\bkeep\s+(me\s+)?(here|on this page)\b/i,
  /\bwithout\s+(leaving|switching|navigating away)\b/i
];
const EXPLICIT_NEW_TAB = [
  /\b(in\s+)?a?\s*new\s+tab\b/i,
  /\bopen\s+(it\s+)?(separately|aside)\b/i
];
function classifyIntent(userMessage, currentUrl) {
  const msg = userMessage.toLowerCase().trim();
  for (const pattern of EXPLICIT_REPLACE_TAB) {
    if (pattern.test(msg)) {
      return {
        type: "in_context",
        confidence: 1,
        reason: "User explicitly requested to use current tab",
        openInBackground: false,
        explicitOverride: "replace_tab"
      };
    }
  }
  for (const pattern of EXPLICIT_BACKGROUND) {
    if (pattern.test(msg)) {
      return {
        type: "exploratory",
        confidence: 1,
        reason: "User explicitly requested background operation",
        openInBackground: true,
        explicitOverride: "background"
      };
    }
  }
  for (const pattern of EXPLICIT_NEW_TAB) {
    if (pattern.test(msg)) {
      return {
        type: "exploratory",
        confidence: 1,
        reason: "User explicitly requested new tab",
        openInBackground: false,
        explicitOverride: "new_tab"
      };
    }
  }
  let inContextScore = 0;
  let inContextReasons = [];
  for (const pattern of IN_CONTEXT_PATTERNS) {
    if (pattern.test(msg)) {
      inContextScore += 1;
      inContextReasons.push(pattern.source.slice(0, 30));
    }
  }
  let exploratoryScore = 0;
  let exploratoryReasons = [];
  for (const pattern of EXPLORATORY_PATTERNS) {
    if (pattern.test(msg)) {
      exploratoryScore += 1;
      exploratoryReasons.push(pattern.source.slice(0, 30));
    }
  }
  if (/\bthis\s+(page|repo|article|document|site|tab)\b/i.test(msg)) {
    inContextScore += 2;
  }
  if (/https?:\/\/|www\.|\.com|\.org|\.io/i.test(msg)) {
    exploratoryScore += 2;
  }
  const simpleActionWords = /^(open|go to|navigate to|visit|find|search|look up)\s/i;
  if (simpleActionWords.test(msg) && !/\bthis\b/i.test(msg)) {
    exploratoryScore += 1;
  }
  if (currentUrl) {
    try {
      const hostname = new URL(currentUrl).hostname;
      const token = getPrimaryDomainToken(hostname);
      if (token && token !== "localhost" && new RegExp(`\\b${token}\\b`, "i").test(msg)) {
        inContextScore += 6;
        inContextReasons.push(`mentions_current_site:${token}`);
      }
      if (hostname === "localhost" && /\baerocore\b/i.test(msg)) {
        inContextScore += 6;
        inContextReasons.push("mentions_current_site:aerocore");
      }
    } catch {
    }
  }
  const totalScore = inContextScore + exploratoryScore;
  if (totalScore === 0) {
    return {
      type: "exploratory",
      confidence: 0.5,
      reason: "Ambiguous intent - defaulting to new tab (reversible)",
      // Default for "new thing": open new tab and switch to it.
      openInBackground: false
    };
  }
  if (inContextScore > exploratoryScore) {
    return {
      type: "in_context",
      confidence: inContextScore / totalScore,
      reason: `In-context signals: ${inContextReasons.join(", ")}`,
      openInBackground: false
    };
  }
  if (exploratoryScore > inContextScore) {
    return {
      type: "exploratory",
      confidence: exploratoryScore / totalScore,
      reason: `Exploratory signals: ${exploratoryReasons.join(", ")}`,
      // Default for "new thing": open new tab and switch to it.
      // True background work is still supported via explicit "background" override.
      openInBackground: false
    };
  }
  return {
    type: "exploratory",
    confidence: 0.5,
    reason: "Equal signals - defaulting to new tab (reversible)",
    openInBackground: false
  };
}
function shouldNavigateActiveTab(userMessage, targetUrl, currentUrl) {
  const intent = classifyIntent(userMessage, currentUrl);
  if (intent.explicitOverride === "replace_tab") {
    return { allowNavigation: true, reason: "User explicitly requested tab replacement" };
  }
  if (intent.explicitOverride === "new_tab" || intent.explicitOverride === "background") {
    return { allowNavigation: false, reason: "User explicitly requested new tab" };
  }
  if (intent.type === "in_context" && intent.confidence >= 0.7) {
    return { allowNavigation: true, reason: intent.reason };
  }
  if (currentUrl && targetUrl) {
    try {
      const currentDomain = new URL(currentUrl).hostname;
      const targetDomain = new URL(targetUrl).hostname;
      if (currentDomain === targetDomain) {
        return { allowNavigation: true, reason: "Same-domain navigation" };
      }
    } catch {
    }
  }
  return {
    allowNavigation: false,
    reason: `Exploratory intent detected (${intent.reason}) - opening new tab to preserve context`
  };
}
const LIST_ITEM_MARKER = "-";
const LIST_ITEM_PREFIX = "- ";
const COMMA = ",";
const COLON = ":";
const SPACE = " ";
const PIPE = "|";
const OPEN_BRACKET = "[";
const CLOSE_BRACKET = "]";
const OPEN_BRACE = "{";
const CLOSE_BRACE = "}";
const NULL_LITERAL = "null";
const TRUE_LITERAL = "true";
const FALSE_LITERAL = "false";
const BACKSLASH = "\\";
const DOUBLE_QUOTE = '"';
const NEWLINE = "\n";
const CARRIAGE_RETURN = "\r";
const TAB = "	";
const DELIMITERS = {
  comma: COMMA,
  tab: TAB,
  pipe: PIPE
};
const DEFAULT_DELIMITER = DELIMITERS.comma;
function unescapeString(value) {
  let unescaped = "";
  let i2 = 0;
  while (i2 < value.length) {
    if (value[i2] === BACKSLASH) {
      if (i2 + 1 >= value.length) throw new SyntaxError("Invalid escape sequence: backslash at end of string");
      const next = value[i2 + 1];
      if (next === "n") {
        unescaped += NEWLINE;
        i2 += 2;
        continue;
      }
      if (next === "t") {
        unescaped += TAB;
        i2 += 2;
        continue;
      }
      if (next === "r") {
        unescaped += CARRIAGE_RETURN;
        i2 += 2;
        continue;
      }
      if (next === BACKSLASH) {
        unescaped += BACKSLASH;
        i2 += 2;
        continue;
      }
      if (next === DOUBLE_QUOTE) {
        unescaped += DOUBLE_QUOTE;
        i2 += 2;
        continue;
      }
      throw new SyntaxError(`Invalid escape sequence: \\${next}`);
    }
    unescaped += value[i2];
    i2++;
  }
  return unescaped;
}
function findClosingQuote(content, start) {
  let i2 = start + 1;
  while (i2 < content.length) {
    if (content[i2] === BACKSLASH && i2 + 1 < content.length) {
      i2 += 2;
      continue;
    }
    if (content[i2] === DOUBLE_QUOTE) return i2;
    i2++;
  }
  return -1;
}
function findUnquotedChar(content, char, start = 0) {
  let inQuotes = false;
  let i2 = start;
  while (i2 < content.length) {
    if (content[i2] === BACKSLASH && i2 + 1 < content.length && inQuotes) {
      i2 += 2;
      continue;
    }
    if (content[i2] === DOUBLE_QUOTE) {
      inQuotes = !inQuotes;
      i2++;
      continue;
    }
    if (content[i2] === char && !inQuotes) return i2;
    i2++;
  }
  return -1;
}
function isBooleanOrNullLiteral(token) {
  return token === TRUE_LITERAL || token === FALSE_LITERAL || token === NULL_LITERAL;
}
function isNumericLiteral(token) {
  if (!token) return false;
  if (token.length > 1 && token[0] === "0" && token[1] !== ".") return false;
  const numericValue = Number(token);
  return !Number.isNaN(numericValue) && Number.isFinite(numericValue);
}
function parseArrayHeaderLine(content, defaultDelimiter) {
  const trimmedToken = content.trimStart();
  let bracketStart = -1;
  if (trimmedToken.startsWith(DOUBLE_QUOTE)) {
    const closingQuoteIndex = findClosingQuote(trimmedToken, 0);
    if (closingQuoteIndex === -1) return;
    if (!trimmedToken.slice(closingQuoteIndex + 1).startsWith(OPEN_BRACKET)) return;
    const keyEndIndex = content.length - trimmedToken.length + closingQuoteIndex + 1;
    bracketStart = content.indexOf(OPEN_BRACKET, keyEndIndex);
  } else bracketStart = content.indexOf(OPEN_BRACKET);
  if (bracketStart === -1) return;
  const bracketEnd = content.indexOf(CLOSE_BRACKET, bracketStart);
  if (bracketEnd === -1) return;
  let colonIndex = bracketEnd + 1;
  let braceEnd = colonIndex;
  const braceStart = content.indexOf(OPEN_BRACE, bracketEnd);
  if (braceStart !== -1 && braceStart < content.indexOf(COLON, bracketEnd)) {
    const foundBraceEnd = content.indexOf(CLOSE_BRACE, braceStart);
    if (foundBraceEnd !== -1) braceEnd = foundBraceEnd + 1;
  }
  colonIndex = content.indexOf(COLON, Math.max(bracketEnd, braceEnd));
  if (colonIndex === -1) return;
  let key;
  if (bracketStart > 0) {
    const rawKey = content.slice(0, bracketStart).trim();
    key = rawKey.startsWith(DOUBLE_QUOTE) ? parseStringLiteral(rawKey) : rawKey;
  }
  const afterColon = content.slice(colonIndex + 1).trim();
  const bracketContent = content.slice(bracketStart + 1, bracketEnd);
  let parsedBracket;
  try {
    parsedBracket = parseBracketSegment(bracketContent, defaultDelimiter);
  } catch {
    return;
  }
  const { length, delimiter } = parsedBracket;
  let fields;
  if (braceStart !== -1 && braceStart < colonIndex) {
    const foundBraceEnd = content.indexOf(CLOSE_BRACE, braceStart);
    if (foundBraceEnd !== -1 && foundBraceEnd < colonIndex) fields = parseDelimitedValues(content.slice(braceStart + 1, foundBraceEnd), delimiter).map((field) => parseStringLiteral(field.trim()));
  }
  return {
    header: {
      key,
      length,
      delimiter,
      fields
    },
    inlineValues: afterColon || void 0
  };
}
function parseBracketSegment(seg, defaultDelimiter) {
  let content = seg;
  let delimiter = defaultDelimiter;
  if (content.endsWith(TAB)) {
    delimiter = DELIMITERS.tab;
    content = content.slice(0, -1);
  } else if (content.endsWith(PIPE)) {
    delimiter = DELIMITERS.pipe;
    content = content.slice(0, -1);
  }
  const length = Number.parseInt(content, 10);
  if (Number.isNaN(length)) throw new TypeError(`Invalid array length: ${seg}`);
  return {
    length,
    delimiter
  };
}
function parseDelimitedValues(input, delimiter) {
  const values = [];
  let valueBuffer = "";
  let inQuotes = false;
  let i2 = 0;
  while (i2 < input.length) {
    const char = input[i2];
    if (char === BACKSLASH && i2 + 1 < input.length && inQuotes) {
      valueBuffer += char + input[i2 + 1];
      i2 += 2;
      continue;
    }
    if (char === DOUBLE_QUOTE) {
      inQuotes = !inQuotes;
      valueBuffer += char;
      i2++;
      continue;
    }
    if (char === delimiter && !inQuotes) {
      values.push(valueBuffer.trim());
      valueBuffer = "";
      i2++;
      continue;
    }
    valueBuffer += char;
    i2++;
  }
  if (valueBuffer || values.length > 0) values.push(valueBuffer.trim());
  return values;
}
function mapRowValuesToPrimitives(values) {
  return values.map((v) => parsePrimitiveToken(v));
}
function parsePrimitiveToken(token) {
  const trimmedToken = token.trim();
  if (!trimmedToken) return "";
  if (trimmedToken.startsWith(DOUBLE_QUOTE)) return parseStringLiteral(trimmedToken);
  if (isBooleanOrNullLiteral(trimmedToken)) {
    if (trimmedToken === TRUE_LITERAL) return true;
    if (trimmedToken === FALSE_LITERAL) return false;
    if (trimmedToken === NULL_LITERAL) return null;
  }
  if (isNumericLiteral(trimmedToken)) {
    const parsedNumber = Number.parseFloat(trimmedToken);
    return Object.is(parsedNumber, -0) ? 0 : parsedNumber;
  }
  return trimmedToken;
}
function parseStringLiteral(token) {
  const trimmedToken = token.trim();
  if (trimmedToken.startsWith(DOUBLE_QUOTE)) {
    const closingQuoteIndex = findClosingQuote(trimmedToken, 0);
    if (closingQuoteIndex === -1) throw new SyntaxError("Unterminated string: missing closing quote");
    if (closingQuoteIndex !== trimmedToken.length - 1) throw new SyntaxError("Unexpected characters after closing quote");
    return unescapeString(trimmedToken.slice(1, closingQuoteIndex));
  }
  return trimmedToken;
}
function parseUnquotedKey(content, start) {
  let parsePosition = start;
  while (parsePosition < content.length && content[parsePosition] !== COLON) parsePosition++;
  if (parsePosition >= content.length || content[parsePosition] !== COLON) throw new SyntaxError("Missing colon after key");
  const key = content.slice(start, parsePosition).trim();
  parsePosition++;
  return {
    key,
    end: parsePosition
  };
}
function parseQuotedKey(content, start) {
  const closingQuoteIndex = findClosingQuote(content, start);
  if (closingQuoteIndex === -1) throw new SyntaxError("Unterminated quoted key");
  const key = unescapeString(content.slice(start + 1, closingQuoteIndex));
  let parsePosition = closingQuoteIndex + 1;
  if (parsePosition >= content.length || content[parsePosition] !== COLON) throw new SyntaxError("Missing colon after key");
  parsePosition++;
  return {
    key,
    end: parsePosition
  };
}
function parseKeyToken(content, start) {
  const isQuoted = content[start] === DOUBLE_QUOTE;
  return {
    ...isQuoted ? parseQuotedKey(content, start) : parseUnquotedKey(content, start),
    isQuoted
  };
}
function isArrayHeaderContent(content) {
  return content.trim().startsWith(OPEN_BRACKET) && findUnquotedChar(content, COLON) !== -1;
}
function isKeyValueContent(content) {
  return findUnquotedChar(content, COLON) !== -1;
}
function createScanState() {
  return {
    lineNumber: 0,
    blankLines: []
  };
}
function parseLineIncremental(raw, state, indentSize, strict) {
  state.lineNumber++;
  const lineNumber = state.lineNumber;
  let indent = 0;
  while (indent < raw.length && raw[indent] === SPACE) indent++;
  const content = raw.slice(indent);
  if (!content.trim()) {
    const depth$1 = computeDepthFromIndent(indent, indentSize);
    state.blankLines.push({
      lineNumber,
      indent,
      depth: depth$1
    });
    return;
  }
  const depth = computeDepthFromIndent(indent, indentSize);
  {
    let whitespaceEndIndex = 0;
    while (whitespaceEndIndex < raw.length && (raw[whitespaceEndIndex] === SPACE || raw[whitespaceEndIndex] === TAB)) whitespaceEndIndex++;
    if (raw.slice(0, whitespaceEndIndex).includes(TAB)) throw new SyntaxError(`Line ${lineNumber}: Tabs are not allowed in indentation in strict mode`);
    if (indent > 0 && indent % indentSize !== 0) throw new SyntaxError(`Line ${lineNumber}: Indentation must be exact multiple of ${indentSize}, but found ${indent} spaces`);
  }
  return {
    raw,
    indent,
    content,
    depth,
    lineNumber
  };
}
function* parseLinesSync(source, indentSize, strict, state) {
  for (const raw of source) {
    const parsedLine = parseLineIncremental(raw, state, indentSize);
    if (parsedLine !== void 0) yield parsedLine;
  }
}
function computeDepthFromIndent(indentSpaces, indentSize) {
  return Math.floor(indentSpaces / indentSize);
}
function assertExpectedCount(actual, expected, itemType, options2) {
  if (options2.strict && actual !== expected) throw new RangeError(`Expected ${expected} ${itemType}, but got ${actual}`);
}
function validateNoExtraListItems(nextLine, itemDepth, expectedCount) {
  if ((nextLine == null ? void 0 : nextLine.depth) === itemDepth && nextLine.content.startsWith(LIST_ITEM_PREFIX)) throw new RangeError(`Expected ${expectedCount} list array items, but found more`);
}
function validateNoExtraTabularRows(nextLine, rowDepth, header) {
  if ((nextLine == null ? void 0 : nextLine.depth) === rowDepth && !nextLine.content.startsWith(LIST_ITEM_PREFIX) && isDataRow(nextLine.content, header.delimiter)) throw new RangeError(`Expected ${header.length} tabular rows, but found more`);
}
function validateNoBlankLinesInRange(startLine, endLine, blankLines, strict, context) {
  if (!strict) return;
  const firstBlank = blankLines.find((blank) => blank.lineNumber > startLine && blank.lineNumber < endLine);
  if (firstBlank) throw new SyntaxError(`Line ${firstBlank.lineNumber}: Blank lines inside ${context} are not allowed in strict mode`);
}
function isDataRow(content, delimiter) {
  const colonPos = content.indexOf(COLON);
  const delimiterPos = content.indexOf(delimiter);
  if (colonPos === -1) return true;
  if (delimiterPos !== -1 && delimiterPos < colonPos) return true;
  return false;
}
var StreamingLineCursor = class {
  constructor(generator, scanState) {
    __publicField2(this, "buffer", []);
    __publicField2(this, "generator");
    __publicField2(this, "done", false);
    __publicField2(this, "lastLine");
    __publicField2(this, "scanState");
    this.generator = generator;
    this.scanState = scanState;
  }
  getBlankLines() {
    return this.scanState.blankLines;
  }
  async peek() {
    if (this.buffer.length > 0) return this.buffer[0];
    if (this.done) return;
    const result = await this.generator.next();
    if (result.done) {
      this.done = true;
      return;
    }
    this.buffer.push(result.value);
    return result.value;
  }
  async next() {
    const line = await this.peek();
    if (line !== void 0) {
      this.buffer.shift();
      this.lastLine = line;
    }
    return line;
  }
  async advance() {
    await this.next();
  }
  current() {
    return this.lastLine;
  }
  async atEnd() {
    return await this.peek() === void 0;
  }
  peekSync() {
    if (this.buffer.length > 0) return this.buffer[0];
    if (this.done) return;
    const result = this.generator.next();
    if (result.done) {
      this.done = true;
      return;
    }
    this.buffer.push(result.value);
    return result.value;
  }
  nextSync() {
    const line = this.peekSync();
    if (line !== void 0) {
      this.buffer.shift();
      this.lastLine = line;
    }
    return line;
  }
  advanceSync() {
    this.nextSync();
  }
  atEndSync() {
    return this.peekSync() === void 0;
  }
};
function* decodeStreamSync$1(source, options2) {
  if ((options2 == null ? void 0 : options2.expandPaths) !== void 0) throw new Error("expandPaths is not supported in streaming decode");
  const resolvedOptions = {
    indent: options2 == null ? void 0 : options2.indent,
    strict: options2 == null ? void 0 : options2.strict
  };
  const scanState = createScanState();
  const cursor = new StreamingLineCursor(parseLinesSync(source, resolvedOptions.indent, resolvedOptions.strict, scanState), scanState);
  const first = cursor.peekSync();
  if (!first) {
    yield { type: "startObject" };
    yield { type: "endObject" };
    return;
  }
  if (isArrayHeaderContent(first.content)) {
    const headerInfo = parseArrayHeaderLine(first.content, DEFAULT_DELIMITER);
    if (headerInfo) {
      cursor.advanceSync();
      yield* decodeArrayFromHeaderSync(headerInfo.header, headerInfo.inlineValues, cursor, 0, resolvedOptions);
      return;
    }
  }
  cursor.advanceSync();
  if (!!cursor.atEndSync() && !isKeyValueLineSync(first)) {
    yield {
      type: "primitive",
      value: parsePrimitiveToken(first.content.trim())
    };
    return;
  }
  yield { type: "startObject" };
  yield* decodeKeyValueSync(first.content, cursor, 0, resolvedOptions);
  while (!cursor.atEndSync()) {
    const line = cursor.peekSync();
    if (!line || line.depth !== 0) break;
    cursor.advanceSync();
    yield* decodeKeyValueSync(line.content, cursor, 0, resolvedOptions);
  }
  yield { type: "endObject" };
}
function* decodeKeyValueSync(content, cursor, baseDepth, options2) {
  const arrayHeader = parseArrayHeaderLine(content, DEFAULT_DELIMITER);
  if (arrayHeader && arrayHeader.header.key) {
    yield {
      type: "key",
      key: arrayHeader.header.key
    };
    yield* decodeArrayFromHeaderSync(arrayHeader.header, arrayHeader.inlineValues, cursor, baseDepth, options2);
    return;
  }
  const { key, isQuoted } = parseKeyToken(content, 0);
  const colonIndex = content.indexOf(COLON, key.length);
  const rest = colonIndex >= 0 ? content.slice(colonIndex + 1).trim() : "";
  yield isQuoted ? {
    type: "key",
    key,
    wasQuoted: true
  } : {
    type: "key",
    key
  };
  if (!rest) {
    const nextLine = cursor.peekSync();
    if (nextLine && nextLine.depth > baseDepth) {
      yield { type: "startObject" };
      yield* decodeObjectFieldsSync(cursor, baseDepth + 1, options2);
      yield { type: "endObject" };
      return;
    }
    yield { type: "startObject" };
    yield { type: "endObject" };
    return;
  }
  yield {
    type: "primitive",
    value: parsePrimitiveToken(rest)
  };
}
function* decodeObjectFieldsSync(cursor, baseDepth, options2) {
  let computedDepth;
  while (!cursor.atEndSync()) {
    const line = cursor.peekSync();
    if (!line || line.depth < baseDepth) break;
    if (computedDepth === void 0 && line.depth >= baseDepth) computedDepth = line.depth;
    if (line.depth === computedDepth) {
      cursor.advanceSync();
      yield* decodeKeyValueSync(line.content, cursor, computedDepth, options2);
    } else break;
  }
}
function* decodeArrayFromHeaderSync(header, inlineValues, cursor, baseDepth, options2) {
  yield {
    type: "startArray",
    length: header.length
  };
  if (inlineValues) {
    yield* decodeInlinePrimitiveArraySync(header, inlineValues, options2);
    yield { type: "endArray" };
    return;
  }
  if (header.fields && header.fields.length > 0) {
    yield* decodeTabularArraySync(header, cursor, baseDepth, options2);
    yield { type: "endArray" };
    return;
  }
  yield* decodeListArraySync(header, cursor, baseDepth, options2);
  yield { type: "endArray" };
}
function* decodeInlinePrimitiveArraySync(header, inlineValues, options2) {
  if (!inlineValues.trim()) {
    assertExpectedCount(0, header.length, "inline array items", options2);
    return;
  }
  const primitives = mapRowValuesToPrimitives(parseDelimitedValues(inlineValues, header.delimiter));
  assertExpectedCount(primitives.length, header.length, "inline array items", options2);
  for (const primitive of primitives) yield {
    type: "primitive",
    value: primitive
  };
}
function* decodeTabularArraySync(header, cursor, baseDepth, options2) {
  const rowDepth = baseDepth + 1;
  let rowCount = 0;
  let startLine;
  let endLine;
  while (!cursor.atEndSync() && rowCount < header.length) {
    const line = cursor.peekSync();
    if (!line || line.depth < rowDepth) break;
    if (line.depth === rowDepth) {
      if (startLine === void 0) startLine = line.lineNumber;
      endLine = line.lineNumber;
      cursor.advanceSync();
      const values = parseDelimitedValues(line.content, header.delimiter);
      assertExpectedCount(values.length, header.fields.length, "tabular row values", options2);
      const primitives = mapRowValuesToPrimitives(values);
      yield* yieldObjectFromFields(header.fields, primitives);
      rowCount++;
    } else break;
  }
  assertExpectedCount(rowCount, header.length, "tabular rows", options2);
  if (options2.strict && startLine !== void 0 && endLine !== void 0) validateNoBlankLinesInRange(startLine, endLine, cursor.getBlankLines(), options2.strict, "tabular array");
  if (options2.strict) validateNoExtraTabularRows(cursor.peekSync(), rowDepth, header);
}
function* decodeListArraySync(header, cursor, baseDepth, options2) {
  const itemDepth = baseDepth + 1;
  let itemCount = 0;
  let startLine;
  let endLine;
  while (!cursor.atEndSync() && itemCount < header.length) {
    const line = cursor.peekSync();
    if (!line || line.depth < itemDepth) break;
    const isListItem = line.content.startsWith(LIST_ITEM_PREFIX) || line.content === LIST_ITEM_MARKER;
    if (line.depth === itemDepth && isListItem) {
      if (startLine === void 0) startLine = line.lineNumber;
      endLine = line.lineNumber;
      yield* decodeListItemSync(cursor, itemDepth, options2);
      const currentLine = cursor.current();
      if (currentLine) endLine = currentLine.lineNumber;
      itemCount++;
    } else break;
  }
  assertExpectedCount(itemCount, header.length, "list array items", options2);
  if (options2.strict && startLine !== void 0 && endLine !== void 0) validateNoBlankLinesInRange(startLine, endLine, cursor.getBlankLines(), options2.strict, "list array");
  if (options2.strict) validateNoExtraListItems(cursor.peekSync(), itemDepth, header.length);
}
function* decodeListItemSync(cursor, baseDepth, options2) {
  const line = cursor.nextSync();
  if (!line) throw new ReferenceError("Expected list item");
  let afterHyphen;
  if (line.content === LIST_ITEM_MARKER) {
    const followDepth = baseDepth + 1;
    const nextLine = cursor.peekSync();
    if (!nextLine || nextLine.depth < followDepth) {
      yield { type: "startObject" };
      yield { type: "endObject" };
      return;
    }
    if (nextLine.depth === followDepth && !nextLine.content.startsWith(LIST_ITEM_PREFIX)) {
      yield { type: "startObject" };
      while (!cursor.atEndSync()) {
        const fieldLine = cursor.peekSync();
        if (!fieldLine || fieldLine.depth < followDepth) break;
        if (fieldLine.depth === followDepth && !fieldLine.content.startsWith(LIST_ITEM_PREFIX)) {
          cursor.advanceSync();
          yield* decodeKeyValueSync(fieldLine.content, cursor, followDepth, options2);
        } else break;
      }
      yield { type: "endObject" };
      return;
    } else {
      yield { type: "startObject" };
      yield { type: "endObject" };
      return;
    }
  } else if (line.content.startsWith(LIST_ITEM_PREFIX)) afterHyphen = line.content.slice(LIST_ITEM_PREFIX.length);
  else throw new SyntaxError(`Expected list item to start with "${LIST_ITEM_PREFIX}"`);
  if (!afterHyphen.trim()) {
    yield { type: "startObject" };
    yield { type: "endObject" };
    return;
  }
  if (isArrayHeaderContent(afterHyphen)) {
    const arrayHeader = parseArrayHeaderLine(afterHyphen, DEFAULT_DELIMITER);
    if (arrayHeader) {
      yield* decodeArrayFromHeaderSync(arrayHeader.header, arrayHeader.inlineValues, cursor, baseDepth, options2);
      return;
    }
  }
  const headerInfo = parseArrayHeaderLine(afterHyphen, DEFAULT_DELIMITER);
  if (headerInfo && headerInfo.header.key && headerInfo.header.fields) {
    const header = headerInfo.header;
    yield { type: "startObject" };
    yield {
      type: "key",
      key: header.key
    };
    yield* decodeArrayFromHeaderSync(header, headerInfo.inlineValues, cursor, baseDepth + 1, options2);
    const followDepth = baseDepth + 1;
    while (!cursor.atEndSync()) {
      const nextLine = cursor.peekSync();
      if (!nextLine || nextLine.depth < followDepth) break;
      if (nextLine.depth === followDepth && !nextLine.content.startsWith(LIST_ITEM_PREFIX)) {
        cursor.advanceSync();
        yield* decodeKeyValueSync(nextLine.content, cursor, followDepth, options2);
      } else break;
    }
    yield { type: "endObject" };
    return;
  }
  if (isKeyValueContent(afterHyphen)) {
    yield { type: "startObject" };
    yield* decodeKeyValueSync(afterHyphen, cursor, baseDepth + 1, options2);
    const followDepth = baseDepth + 1;
    while (!cursor.atEndSync()) {
      const nextLine = cursor.peekSync();
      if (!nextLine || nextLine.depth < followDepth) break;
      if (nextLine.depth === followDepth && !nextLine.content.startsWith(LIST_ITEM_PREFIX)) {
        cursor.advanceSync();
        yield* decodeKeyValueSync(nextLine.content, cursor, followDepth, options2);
      } else break;
    }
    yield { type: "endObject" };
    return;
  }
  yield {
    type: "primitive",
    value: parsePrimitiveToken(afterHyphen)
  };
}
function isKeyValueLineSync(line) {
  const content = line.content;
  if (content.startsWith('"')) {
    const closingQuoteIndex = findClosingQuote(content, 0);
    if (closingQuoteIndex === -1) return false;
    return content.slice(closingQuoteIndex + 1).includes(COLON);
  } else return content.includes(COLON);
}
function* yieldObjectFromFields(fields, primitives) {
  yield { type: "startObject" };
  for (let i2 = 0; i2 < fields.length; i2++) {
    yield {
      type: "key",
      key: fields[i2]
    };
    yield {
      type: "primitive",
      value: primitives[i2]
    };
  }
  yield { type: "endObject" };
}
const QUOTED_KEY_MARKER = Symbol("quotedKey");
function buildValueFromEvents(events) {
  const state = {
    stack: [],
    root: void 0
  };
  for (const event of events) applyEvent(state, event);
  return finalizeState(state);
}
function applyEvent(state, event) {
  const { stack } = state;
  switch (event.type) {
    case "startObject": {
      const obj = {};
      const quotedKeys = /* @__PURE__ */ new Set();
      if (stack.length === 0) stack.push({
        type: "object",
        obj,
        quotedKeys
      });
      else {
        const parent = stack[stack.length - 1];
        if (parent.type === "object") {
          if (parent.currentKey === void 0) throw new Error("Object startObject event without preceding key");
          parent.obj[parent.currentKey] = obj;
          parent.currentKey = void 0;
        } else if (parent.type === "array") parent.arr.push(obj);
        stack.push({
          type: "object",
          obj,
          quotedKeys
        });
      }
      break;
    }
    case "endObject": {
      if (stack.length === 0) throw new Error("Unexpected endObject event");
      const context = stack.pop();
      if (context.type !== "object") throw new Error("Mismatched endObject event");
      if (context.quotedKeys.size > 0) Object.defineProperty(context.obj, QUOTED_KEY_MARKER, {
        value: context.quotedKeys,
        enumerable: false,
        writable: false,
        configurable: false
      });
      if (stack.length === 0) state.root = context.obj;
      break;
    }
    case "startArray": {
      const arr2 = [];
      if (stack.length === 0) stack.push({
        type: "array",
        arr: arr2
      });
      else {
        const parent = stack[stack.length - 1];
        if (parent.type === "object") {
          if (parent.currentKey === void 0) throw new Error("Array startArray event without preceding key");
          parent.obj[parent.currentKey] = arr2;
          parent.currentKey = void 0;
        } else if (parent.type === "array") parent.arr.push(arr2);
        stack.push({
          type: "array",
          arr: arr2
        });
      }
      break;
    }
    case "endArray": {
      if (stack.length === 0) throw new Error("Unexpected endArray event");
      const context = stack.pop();
      if (context.type !== "array") throw new Error("Mismatched endArray event");
      if (stack.length === 0) state.root = context.arr;
      break;
    }
    case "key": {
      if (stack.length === 0) throw new Error("Key event outside of object context");
      const parent = stack[stack.length - 1];
      if (parent.type !== "object") throw new Error("Key event in non-object context");
      parent.currentKey = event.key;
      if (event.wasQuoted) parent.quotedKeys.add(event.key);
      break;
    }
    case "primitive":
      if (stack.length === 0) state.root = event.value;
      else {
        const parent = stack[stack.length - 1];
        if (parent.type === "object") {
          if (parent.currentKey === void 0) throw new Error("Primitive event without preceding key in object");
          parent.obj[parent.currentKey] = event.value;
          parent.currentKey = void 0;
        } else if (parent.type === "array") parent.arr.push(event.value);
      }
      break;
  }
}
function finalizeState(state) {
  if (state.stack.length !== 0) throw new Error("Incomplete event stream: stack not empty at end");
  if (state.root === void 0) throw new Error("No root value built from events");
  return state.root;
}
function decode(input, options2) {
  return decodeFromLines(input.split("\n"));
}
function decodeFromLines(lines, options2) {
  const resolvedOptions = resolveDecodeOptions();
  const decodedValue = buildValueFromEvents(decodeStreamSync$1(lines, {
    indent: resolvedOptions.indent,
    strict: resolvedOptions.strict
  }));
  return decodedValue;
}
function resolveDecodeOptions(options2) {
  return {
    indent: 2,
    strict: true,
    expandPaths: "off"
  };
}
const fromTOON = (s) => decode(s);
const safeParseTOON = (s, fallback) => {
  try {
    return fromTOON(s);
  } catch {
    return fallback;
  }
};
const TOON_SUMMARY_PROMPT_TEMPLATE = `You are a conversation summarizer. Compress the following conversation messages into a structured TOON format summary.

TOON format uses headers with :: and indented content. Output ONLY the TOON text, no markdown.

Example output:
meta::
  version: 1.0
  timestamp: 2025-01-01T00:00:00Z
  messagesCompressed: 15
conversationSummary::
  User asked about X. Agent navigated to Y and extracted Z.
activePlan::
  - Step 1
  - Step 2
keyEntities::
  - Entity A
  - Entity B

Now summarize these messages:
`;
const ToonMetaSchema = object({
  version: string().default("1.0"),
  timestamp: string().optional(),
  messagesCompressed: number().int().nonnegative()
});
const ToonSummarySchema = object({
  meta: ToonMetaSchema,
  conversationSummary: string().min(1, "Conversation summary cannot be empty"),
  activePlan: array(string()).optional(),
  keyEntities: array(string()).optional(),
  pendingActions: array(string()).optional()
});
function safeValidateToonSummary(data) {
  const result = ToonSummarySchema.safeParse(data);
  if (result.success) {
    return result.data;
  }
  console.warn("[ToonSummary] Validation failed:", result.error.issues);
  return null;
}
function createToonSummary(summary, messagesCompressed, options2) {
  return {
    meta: {
      version: "1.0",
      timestamp: (/* @__PURE__ */ new Date()).toISOString(),
      messagesCompressed
    },
    conversationSummary: summary,
    activePlan: options2 == null ? void 0 : options2.activePlan,
    keyEntities: options2 == null ? void 0 : options2.keyEntities,
    pendingActions: options2 == null ? void 0 : options2.pendingActions
  };
}
const _SelectorCache = class _SelectorCache {
  constructor(dbPath) {
    __publicField2(this, "db", null);
    __publicField2(this, "memoryCache", /* @__PURE__ */ new Map());
    __publicField2(this, "prefetchQueue", /* @__PURE__ */ new Map());
    __publicField2(this, "navigationPatterns", /* @__PURE__ */ new Map());
    __publicField2(this, "currentUrl", null);
    this.initDatabase(dbPath);
  }
  initDatabase(dbPath) {
    const dbDir = dbPath ? path$2.dirname(dbPath) : path$2.join(process.cwd(), ".cache");
    if (!fs$1.existsSync(dbDir)) {
      fs$1.mkdirSync(dbDir, { recursive: true });
    }
    const fullPath = dbPath || path$2.join(dbDir, "selector_cache.db");
    try {
      this.db = new Database(fullPath);
      this.db.pragma("journal_mode = WAL");
      this.db.pragma("synchronous = NORMAL");
      this.db.exec(`
        CREATE TABLE IF NOT EXISTS selectors (
          id TEXT PRIMARY KEY,
          domain TEXT NOT NULL,
          url_pattern TEXT NOT NULL,
          test_id TEXT NOT NULL,
          css_selector TEXT NOT NULL,
          xpath_selector TEXT,
          element_type TEXT NOT NULL,
          description TEXT,
          confidence REAL DEFAULT 1.0,
          success_count INTEGER DEFAULT 0,
          failure_count INTEGER DEFAULT 0,
          last_used INTEGER,
          last_updated INTEGER,
          ttl_ms INTEGER,
          alternatives TEXT DEFAULT '[]'
        );
        
        CREATE INDEX IF NOT EXISTS idx_domain ON selectors(domain);
        CREATE INDEX IF NOT EXISTS idx_url_pattern ON selectors(url_pattern);
        CREATE INDEX IF NOT EXISTS idx_test_id ON selectors(test_id);
        CREATE INDEX IF NOT EXISTS idx_confidence ON selectors(confidence DESC);
        
        CREATE TABLE IF NOT EXISTS navigation_patterns (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          from_url TEXT NOT NULL,
          to_url TEXT NOT NULL,
          count INTEGER DEFAULT 1,
          last_seen INTEGER,
          UNIQUE(from_url, to_url)
        );
        
        CREATE INDEX IF NOT EXISTS idx_from_url ON navigation_patterns(from_url);
      `);
      console.log("[SelectorCache] Database initialized at", fullPath);
    } catch (e) {
      console.error("[SelectorCache] Failed to initialize database:", e);
      this.db = null;
    }
  }
  /**
   * Get selectors for a URL pattern - sub-5ms target
   */
  async getSelectors(urlPattern) {
    const startTime2 = performance.now();
    const results2 = [];
    const memoryCached = this.memoryCache.get(urlPattern);
    if (memoryCached && memoryCached.length > 0) {
      const lookupTime = performance.now() - startTime2;
      for (const selector of memoryCached) {
        if (this.isValid(selector)) {
          results2.push({ selector, source: "cache", lookupTimeMs: lookupTime });
        }
      }
      if (results2.length > 0) {
        this.emitLookupTelemetry(urlPattern, results2.length, lookupTime, "memory");
        return results2;
      }
    }
    const prefetched = this.prefetchQueue.get(urlPattern);
    if (prefetched && prefetched.length > 0) {
      const lookupTime = performance.now() - startTime2;
      for (const selector of prefetched) {
        results2.push({ selector, source: "prefetch", lookupTimeMs: lookupTime });
      }
      this.memoryCache.set(urlPattern, prefetched);
      this.prefetchQueue.delete(urlPattern);
      this.emitLookupTelemetry(urlPattern, results2.length, lookupTime, "prefetch");
      return results2;
    }
    if (this.db) {
      try {
        const domain = this.extractDomain(urlPattern);
        const stmt = this.db.prepare(`
          SELECT * FROM selectors 
          WHERE (url_pattern = ? OR domain = ?)
          AND confidence >= ?
          ORDER BY confidence DESC, success_count DESC
          LIMIT 100
        `);
        const rows = stmt.all(urlPattern, domain, _SelectorCache.CONFIDENCE_THRESHOLD);
        const lookupTime = performance.now() - startTime2;
        for (const row of rows) {
          const selector = this.rowToSelector(row);
          if (this.isValid(selector)) {
            results2.push({ selector, source: "cache", lookupTimeMs: lookupTime });
          }
        }
        if (results2.length > 0) {
          this.memoryCache.set(urlPattern, results2.map((r) => r.selector));
          this.trimMemoryCache();
        }
        this.emitLookupTelemetry(urlPattern, results2.length, lookupTime, "sqlite");
      } catch (e) {
        console.error("[SelectorCache] Database query failed:", e);
      }
    }
    return results2;
  }
  /**
   * Get a specific selector by testId - optimized for speed
   */
  async getSelectorByTestId(testId, urlPattern) {
    const startTime2 = performance.now();
    for (const [pattern, selectors] of this.memoryCache) {
      if (!urlPattern || pattern === urlPattern) {
        const found = selectors.find((s) => s.testId === testId);
        if (found && this.isValid(found)) {
          return found;
        }
      }
    }
    if (this.db) {
      try {
        let stmt;
        let row;
        if (urlPattern) {
          stmt = this.db.prepare(`
            SELECT * FROM selectors 
            WHERE test_id = ? AND url_pattern = ?
            ORDER BY confidence DESC
            LIMIT 1
          `);
          row = stmt.get(testId, urlPattern);
        } else {
          stmt = this.db.prepare(`
            SELECT * FROM selectors 
            WHERE test_id = ?
            ORDER BY confidence DESC, last_used DESC
            LIMIT 1
          `);
          row = stmt.get(testId);
        }
        if (row) {
          const selector = this.rowToSelector(row);
          const lookupTime = performance.now() - startTime2;
          this.emitLookupTelemetry(testId, 1, lookupTime, "sqlite-testid");
          return selector;
        }
      } catch (e) {
        console.error("[SelectorCache] Failed to get selector by testId:", e);
      }
    }
    return null;
  }
  /**
   * Store a selector in the cache
   */
  async cacheSelector(selector) {
    const id = v4$2();
    const now = Date.now();
    const fullSelector = {
      ...selector,
      id,
      lastUsed: now,
      lastUpdated: now,
      ttlMs: selector.ttlMs || _SelectorCache.DEFAULT_TTL_MS,
      alternatives: selector.alternatives || []
    };
    const existing = this.memoryCache.get(selector.urlPattern) || [];
    existing.push(fullSelector);
    this.memoryCache.set(selector.urlPattern, existing);
    if (this.db) {
      try {
        const stmt = this.db.prepare(`
          INSERT OR REPLACE INTO selectors 
          (id, domain, url_pattern, test_id, css_selector, xpath_selector, 
           element_type, description, confidence, success_count, failure_count,
           last_used, last_updated, ttl_ms, alternatives)
          VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `);
        stmt.run(
          fullSelector.id,
          fullSelector.domain,
          fullSelector.urlPattern,
          fullSelector.testId,
          fullSelector.cssSelector,
          fullSelector.xpathSelector,
          fullSelector.elementType,
          fullSelector.description,
          fullSelector.confidence,
          fullSelector.successCount,
          fullSelector.failureCount,
          fullSelector.lastUsed,
          fullSelector.lastUpdated,
          fullSelector.ttlMs,
          JSON.stringify(fullSelector.alternatives)
        );
      } catch (e) {
        console.error("[SelectorCache] Failed to cache selector:", e);
      }
    }
    return id;
  }
  /**
   * Record selector usage success - updates confidence
   */
  recordSuccess(testId, urlPattern) {
    this.updateSelectorStats(testId, urlPattern, true);
  }
  /**
   * Record selector usage failure - updates confidence and triggers auto-heal
   */
  recordFailure(testId, urlPattern) {
    this.updateSelectorStats(testId, urlPattern, false);
    return this.tryAutoHeal(testId, urlPattern);
  }
  updateSelectorStats(testId, urlPattern, success2) {
    const now = Date.now();
    const cached2 = this.memoryCache.get(urlPattern);
    if (cached2) {
      const selector = cached2.find((s) => s.testId === testId);
      if (selector) {
        if (success2) {
          selector.successCount++;
        } else {
          selector.failureCount++;
        }
        selector.lastUsed = now;
        selector.confidence = this.calculateConfidence(selector.successCount, selector.failureCount);
      }
    }
    if (this.db) {
      try {
        const column = success2 ? "success_count" : "failure_count";
        const stmt = this.db.prepare(`
          UPDATE selectors 
          SET ${column} = ${column} + 1,
              last_used = ?,
              confidence = CAST(success_count AS REAL) / (success_count + failure_count + 1)
          WHERE test_id = ? AND url_pattern = ?
        `);
        stmt.run(now, testId, urlPattern);
      } catch (e) {
        console.error("[SelectorCache] Failed to update selector stats:", e);
      }
    }
    telemetryService.emit({
      eventId: v4$2(),
      ts: (/* @__PURE__ */ new Date()).toISOString(),
      type: "plan_step_end",
      name: "SelectorCache",
      data: { testId, urlPattern, success: success2, action: "record_usage" }
    });
  }
  /**
   * Auto-heal: Find alternative selector when primary fails
   */
  tryAutoHeal(testId, urlPattern) {
    const cached2 = this.memoryCache.get(urlPattern);
    if (cached2) {
      const selector = cached2.find((s) => s.testId === testId);
      if (selector && selector.alternatives.length > 0) {
        const altCss = selector.alternatives[0];
        const healedSelector = {
          ...selector,
          id: v4$2(),
          cssSelector: altCss,
          confidence: 0.5,
          // Start with lower confidence
          successCount: 0,
          failureCount: 0,
          lastUpdated: Date.now()
        };
        selector.alternatives = selector.alternatives.slice(1);
        telemetryService.emit({
          eventId: v4$2(),
          ts: (/* @__PURE__ */ new Date()).toISOString(),
          type: "plan_step_start",
          name: "SelectorCache",
          data: { testId, urlPattern, action: "auto_heal", newSelector: altCss }
        });
        return healedSelector;
      }
    }
    return null;
  }
  /**
   * Add alternative selectors for auto-healing
   */
  addAlternatives(testId, urlPattern, alternatives) {
    const cached2 = this.memoryCache.get(urlPattern);
    if (cached2) {
      const selector = cached2.find((s) => s.testId === testId);
      if (selector) {
        const newAlts = [.../* @__PURE__ */ new Set([...selector.alternatives, ...alternatives])];
        selector.alternatives = newAlts.slice(0, _SelectorCache.MAX_ALTERNATIVES);
      }
    }
    if (this.db) {
      try {
        const stmt = this.db.prepare(`
          UPDATE selectors 
          SET alternatives = ?
          WHERE test_id = ? AND url_pattern = ?
        `);
        const existingStmt = this.db.prepare(`
          SELECT alternatives FROM selectors WHERE test_id = ? AND url_pattern = ?
        `);
        const row = existingStmt.get(testId, urlPattern);
        if (row) {
          const existing = JSON.parse(row.alternatives || "[]");
          const merged = [.../* @__PURE__ */ new Set([...existing, ...alternatives])].slice(0, _SelectorCache.MAX_ALTERNATIVES);
          stmt.run(JSON.stringify(merged), testId, urlPattern);
        }
      } catch (e) {
        console.error("[SelectorCache] Failed to add alternatives:", e);
      }
    }
  }
  /**
   * Predictive pre-fetch: Load selectors for likely next pages
   */
  async prefetchForNavigation(currentUrl) {
    this.currentUrl = currentUrl;
    const predictions = this.getPrefetchPredictions(currentUrl);
    for (const prediction of predictions) {
      if (prediction.confidence >= _SelectorCache.PREFETCH_CONFIDENCE_THRESHOLD) {
        const selectors = await this.getSelectors(prediction.urlPattern);
        if (selectors.length > 0) {
          this.prefetchQueue.set(prediction.urlPattern, selectors.map((r) => r.selector));
        }
      }
    }
    telemetryService.emit({
      eventId: v4$2(),
      ts: (/* @__PURE__ */ new Date()).toISOString(),
      type: "plan_step_start",
      name: "SelectorCache",
      data: {
        action: "prefetch",
        currentUrl,
        predictions: predictions.length,
        prefetched: this.prefetchQueue.size
      }
    });
  }
  /**
   * Record navigation for pattern learning
   */
  recordNavigation(fromUrl, toUrl) {
    const now = Date.now();
    const patterns = this.navigationPatterns.get(fromUrl) || [];
    const existing = patterns.find((p) => p.toUrl === toUrl);
    if (existing) {
      existing.count++;
      existing.lastSeen = now;
    } else {
      patterns.push({ fromUrl, toUrl, count: 1, lastSeen: now });
    }
    this.navigationPatterns.set(fromUrl, patterns);
    if (this.db) {
      try {
        const stmt = this.db.prepare(`
          INSERT INTO navigation_patterns (from_url, to_url, count, last_seen)
          VALUES (?, ?, 1, ?)
          ON CONFLICT(from_url, to_url) DO UPDATE SET
            count = count + 1,
            last_seen = ?
        `);
        stmt.run(fromUrl, toUrl, now, now);
      } catch (e) {
        console.error("[SelectorCache] Failed to record navigation:", e);
      }
    }
    this.prefetchForNavigation(toUrl);
  }
  /**
   * Get prefetch predictions based on navigation history
   */
  getPrefetchPredictions(currentUrl) {
    const predictions = [];
    const patterns = this.navigationPatterns.get(currentUrl);
    if (patterns) {
      const totalCount = patterns.reduce((sum, p) => sum + p.count, 0);
      for (const pattern of patterns) {
        predictions.push({
          urlPattern: pattern.toUrl,
          selectors: [],
          confidence: pattern.count / totalCount
        });
      }
    }
    if (this.db) {
      try {
        const stmt = this.db.prepare(`
          SELECT to_url, count, 
                 CAST(count AS REAL) / (SELECT SUM(count) FROM navigation_patterns WHERE from_url = ?) as confidence
          FROM navigation_patterns 
          WHERE from_url = ?
          ORDER BY count DESC
          LIMIT 5
        `);
        const rows = stmt.all(currentUrl, currentUrl);
        for (const row of rows) {
          if (!predictions.find((p) => p.urlPattern === row.to_url)) {
            predictions.push({
              urlPattern: row.to_url,
              selectors: [],
              confidence: row.confidence
            });
          }
        }
      } catch (e) {
        console.error("[SelectorCache] Failed to get prefetch predictions:", e);
      }
    }
    return predictions.sort((a, b) => b.confidence - a.confidence);
  }
  /**
   * Get confidence score for a selector
   */
  getConfidence(testId, urlPattern) {
    const cached2 = this.memoryCache.get(urlPattern);
    if (cached2) {
      const selector = cached2.find((s) => s.testId === testId);
      if (selector) {
        return selector.confidence;
      }
    }
    return 0;
  }
  /**
   * Get all selectors with low confidence (for review/healing)
   */
  getLowConfidenceSelectors(threshold = 0.5) {
    const results2 = [];
    if (this.db) {
      try {
        const stmt = this.db.prepare(`
          SELECT * FROM selectors 
          WHERE confidence < ?
          ORDER BY confidence ASC
          LIMIT 50
        `);
        const rows = stmt.all(threshold);
        for (const row of rows) {
          results2.push(this.rowToSelector(row));
        }
      } catch (e) {
        console.error("[SelectorCache] Failed to get low confidence selectors:", e);
      }
    }
    return results2;
  }
  /**
   * Get cache statistics
   */
  getStats() {
    let totalSelectors = 0;
    let totalConfidence = 0;
    let totalSuccess = 0;
    let totalFailure = 0;
    if (this.db) {
      try {
        const countStmt = this.db.prepare("SELECT COUNT(*) as count FROM selectors");
        const countRow = countStmt.get();
        totalSelectors = countRow.count;
        const avgStmt = this.db.prepare("SELECT AVG(confidence) as avg FROM selectors");
        const avgRow = avgStmt.get();
        totalConfidence = avgRow.avg || 0;
        const statsStmt = this.db.prepare("SELECT SUM(success_count) as success, SUM(failure_count) as failure FROM selectors");
        const statsRow = statsStmt.get();
        totalSuccess = statsRow.success || 0;
        totalFailure = statsRow.failure || 0;
      } catch (e) {
        console.error("[SelectorCache] Failed to get stats:", e);
      }
    }
    return {
      totalSelectors,
      memoryCacheSize: this.memoryCache.size,
      prefetchQueueSize: this.prefetchQueue.size,
      avgConfidence: totalConfidence,
      hitRate: totalSuccess + totalFailure > 0 ? totalSuccess / (totalSuccess + totalFailure) : 0
    };
  }
  /**
   * Clear expired entries from cache
   */
  async cleanup() {
    const now = Date.now();
    for (const [pattern, selectors] of this.memoryCache) {
      const valid = selectors.filter((s) => this.isValid(s));
      if (valid.length === 0) {
        this.memoryCache.delete(pattern);
      } else {
        this.memoryCache.set(pattern, valid);
      }
    }
    if (this.db) {
      try {
        const stmt = this.db.prepare(`
          DELETE FROM selectors 
          WHERE last_updated + ttl_ms < ?
        `);
        const result = stmt.run(now);
        console.log(`[SelectorCache] Cleaned up ${result.changes} expired selectors`);
      } catch (e) {
        console.error("[SelectorCache] Failed to cleanup:", e);
      }
    }
  }
  /**
   * Close database connection
   */
  close() {
    if (this.db) {
      this.db.close();
      this.db = null;
    }
  }
  isValid(selector) {
    const now = Date.now();
    return selector.lastUpdated + selector.ttlMs > now;
  }
  calculateConfidence(success2, failure) {
    if (success2 + failure === 0) return 1;
    return success2 / (success2 + failure);
  }
  extractDomain(url) {
    try {
      const parsed = new URL(url);
      return parsed.hostname;
    } catch {
      return url.split("/")[0];
    }
  }
  rowToSelector(row) {
    return {
      id: row.id,
      domain: row.domain,
      urlPattern: row.url_pattern,
      testId: row.test_id,
      cssSelector: row.css_selector,
      xpathSelector: row.xpath_selector,
      elementType: row.element_type,
      description: row.description,
      confidence: row.confidence,
      successCount: row.success_count,
      failureCount: row.failure_count,
      lastUsed: row.last_used,
      lastUpdated: row.last_updated,
      ttlMs: row.ttl_ms,
      alternatives: JSON.parse(row.alternatives || "[]")
    };
  }
  trimMemoryCache() {
    if (this.memoryCache.size > _SelectorCache.MEMORY_CACHE_SIZE) {
      const entries = Array.from(this.memoryCache.entries());
      entries.sort((a, b) => {
        const aLastUsed = Math.max(...a[1].map((s) => s.lastUsed));
        const bLastUsed = Math.max(...b[1].map((s) => s.lastUsed));
        return aLastUsed - bLastUsed;
      });
      const toRemove = entries.slice(0, entries.length - _SelectorCache.MEMORY_CACHE_SIZE);
      for (const [pattern] of toRemove) {
        this.memoryCache.delete(pattern);
      }
    }
  }
  emitLookupTelemetry(key, count, timeMs, source) {
    telemetryService.emit({
      eventId: v4$2(),
      ts: (/* @__PURE__ */ new Date()).toISOString(),
      type: "plan_step_end",
      name: "SelectorCache",
      data: { key, count, timeMs: Math.round(timeMs * 100) / 100, source }
    });
  }
};
__publicField2(_SelectorCache, "DEFAULT_TTL_MS", 24 * 60 * 60 * 1e3);
// 24 hours
__publicField2(_SelectorCache, "CONFIDENCE_THRESHOLD", 0.7);
__publicField2(_SelectorCache, "MAX_ALTERNATIVES", 5);
__publicField2(_SelectorCache, "PREFETCH_CONFIDENCE_THRESHOLD", 0.6);
__publicField2(_SelectorCache, "MEMORY_CACHE_SIZE", 1e3);
let SelectorCache = _SelectorCache;
const selectorCache = new SelectorCache();
class SelectorDiscoveryService {
  constructor() {
    __publicField2(this, "selectorMap", /* @__PURE__ */ new Map());
    __publicField2(this, "lastScan", 0);
    __publicField2(this, "CACHE_TTL", 1e3 * 60 * 60);
    // 1 hour
    __publicField2(this, "currentUrl", null);
  }
  /**
   * Scans the mock-saas source code to find all data-testid attributes
   */
  async discoverSelectors() {
    const now = Date.now();
    if (this.selectorMap.size > 0 && now - this.lastScan < this.CACHE_TTL) {
      return this.selectorMap;
    }
    const mockSaasSrc = path__default$1.resolve(process.cwd(), "mock-saas", "src");
    this.selectorMap.clear();
    try {
      await this.scanDirectory(mockSaasSrc);
      this.lastScan = now;
      console.log(`[SelectorDiscovery] Discovered ${this.getTotalSelectorCount()} selectors across ${this.selectorMap.size} pages`);
    } catch (e) {
      console.error("[SelectorDiscovery] Failed to scan mock-saas:", e);
    }
    return this.selectorMap;
  }
  async scanDirectory(dir) {
    const entries = await fs$3.readdir(dir, { withFileTypes: true });
    for (const entry of entries) {
      const fullPath = path__default$1.join(dir, entry.name);
      if (entry.isDirectory()) {
        await this.scanDirectory(fullPath);
      } else if (entry.isFile() && (entry.name.endsWith(".tsx") || entry.name.endsWith(".ts"))) {
        await this.scanFile(fullPath);
      }
    }
  }
  async scanFile(filePath) {
    const content = await fs$3.readFile(filePath, "utf8");
    const pageName = path__default$1.basename(filePath, path__default$1.extname(filePath));
    const testIdRegex = /data-testid=["']([^"']+)["']/g;
    let match;
    while ((match = testIdRegex.exec(content)) !== null) {
      const testId = match[1];
      const type = this.inferTypeFromContext(content, match.index);
      const selectors = this.selectorMap.get(pageName) || [];
      selectors.push({
        testId,
        description: `Discovered from ${pageName}`,
        type,
        page: pageName
      });
      this.selectorMap.set(pageName, selectors);
    }
  }
  inferTypeFromContext(content, index) {
    const context = content.slice(Math.max(0, index - 100), index);
    if (context.toLowerCase().includes("<button") || context.toLowerCase().includes("button")) return "button";
    if (context.toLowerCase().includes("<input")) return "input";
    if (context.toLowerCase().includes("<select")) return "select";
    if (context.toLowerCase().includes("<form")) return "form";
    return "other";
  }
  getTotalSelectorCount() {
    let count = 0;
    for (const selectors of this.selectorMap.values()) {
      count += selectors.length;
    }
    return count;
  }
  /**
   * Get selectors for a specific page or component
   */
  getSelectorsForPage(page) {
    return this.selectorMap.get(page) || [];
  }
  /**
   * Find a specific selector by its testId
   */
  findSelector(testId) {
    for (const selectors of this.selectorMap.values()) {
      const found = selectors.find((s) => s.testId === testId);
      if (found) return found;
    }
    return void 0;
  }
  /**
   * Get selector with caching - sub-5ms target for cache hits
   */
  async getCachedSelector(testId, urlPattern) {
    return selectorCache.getSelectorByTestId(testId, urlPattern);
  }
  /**
   * Cache a discovered selector for fast future lookups
   */
  async cacheDiscoveredSelector(selector, urlPattern, cssSelector, xpathSelector) {
    const domain = this.extractDomain(urlPattern);
    return selectorCache.cacheSelector({
      domain,
      urlPattern,
      testId: selector.testId,
      cssSelector,
      xpathSelector: xpathSelector || null,
      elementType: selector.type === "other" ? "other" : selector.type,
      description: selector.description,
      confidence: 1,
      successCount: 0,
      failureCount: 0,
      ttlMs: this.CACHE_TTL,
      alternatives: []
    });
  }
  /**
   * Record selector usage for confidence tracking
   */
  recordSelectorSuccess(testId, urlPattern) {
    selectorCache.recordSuccess(testId, urlPattern);
  }
  /**
   * Record selector failure and attempt auto-heal
   */
  recordSelectorFailure(testId, urlPattern) {
    return selectorCache.recordFailure(testId, urlPattern);
  }
  /**
   * Notify of navigation for predictive pre-fetching
   */
  async onNavigation(fromUrl, toUrl) {
    this.currentUrl = toUrl;
    selectorCache.recordNavigation(fromUrl, toUrl);
  }
  /**
   * Pre-fetch selectors for predicted next pages
   */
  async prefetchSelectors(currentUrl) {
    this.currentUrl = currentUrl;
    await selectorCache.prefetchForNavigation(currentUrl);
  }
  /**
   * Get cache statistics
   */
  getCacheStats() {
    return selectorCache.getStats();
  }
  /**
   * Get selectors with low confidence for review
   */
  getLowConfidenceSelectors(threshold) {
    return selectorCache.getLowConfidenceSelectors(threshold);
  }
  /**
   * Add alternative selectors for auto-healing
   */
  addSelectorAlternatives(testId, urlPattern, alternatives) {
    selectorCache.addAlternatives(testId, urlPattern, alternatives);
  }
  extractDomain(url) {
    try {
      const parsed = new URL(url);
      return parsed.hostname;
    } catch {
      return url.split("/")[0] || "localhost";
    }
  }
}
const selectorDiscoveryService = new SelectorDiscoveryService();
class WorkflowOrchestrator {
  constructor(model) {
    __publicField2(this, "tasks", /* @__PURE__ */ new Map());
    __publicField2(this, "context", {});
    __publicField2(this, "model");
    __publicField2(this, "availableTabs", []);
    // Track agent-created background tabs
    __publicField2(this, "browserToolQueue", Promise.resolve());
    this.model = model;
  }
  /**
   * Plan the workflow based on the user request and current state
   */
  async plan(userMessage, browserContext) {
    const plannerPrompt = new SystemMessage(`You are a workflow planner for an enterprise browser.
Your goal is to decompose the user's request into a Directed Acyclic Graph (DAG) of tasks.

Current Browser Context:
${browserContext}

User Request: ${userMessage}

Respond ONLY with a JSON array of tasks. Each task must follow this schema:
{
  "id": "unique_id",
  "name": "short_descriptive_name",
  "tool": "tool_name",
  "args": { ... },
  "dependencies": ["list_of_dependency_ids"]
}

Rules:
1. Identify independent tasks that can run in parallel (e.g., searching Jira and Confluence at the same time).
2. Use dependencies for tasks that require the output of another task.
3. Use variables in args like "{{task_id.property}}" to refer to output of previous tasks.
4. For cross-app tasks, ALWAYS plan to use "browser_open_tab" first to create a dedicated context if multiple apps are involved.
5. If a task uses a specific tab, include "tabId": "{{open_tab_task_id.tabId}}" in its args.`);
    try {
      const response = await this.model.invoke([plannerPrompt]);
      const content = typeof response.content === "string" ? response.content : JSON.stringify(response.content);
      const jsonMatch = content.match(/\[\s*\{[\s\S]*\}\s*\]/);
      if (!jsonMatch) {
        console.error("[WorkflowOrchestrator] Failed to parse plan JSON:", content);
        return [];
      }
      const rawTasks = JSON.parse(jsonMatch[0]);
      return rawTasks.map((t2) => ({
        ...t2,
        status: "pending"
      }));
    } catch (e) {
      console.error("[WorkflowOrchestrator] Planning failed:", e);
      return [];
    }
  }
  /**
   * Execute the planned tasks in parallel where possible
   */
  async execute(tasks, onStep) {
    this.tasks.clear();
    tasks.forEach((t2) => this.tasks.set(t2.id, t2));
    this.context = {};
    this.availableTabs = [];
    this.browserToolQueue = Promise.resolve();
    let hasFailure = false;
    while (this.getPendingTasks().length > 0 || this.getRunningTasks().length > 0) {
      const readyTasks = this.getPendingTasks().filter(
        (t2) => t2.dependencies.every((depId) => {
          var _a3;
          return ((_a3 = this.tasks.get(depId)) == null ? void 0 : _a3.status) === "completed";
        })
      );
      if (readyTasks.length === 0 && this.getRunningTasks().length === 0) {
        break;
      }
      const taskPromises = readyTasks.map(async (task) => {
        task.status = "running";
        onStep == null ? void 0 : onStep("thought", `Executing task: ${task.name}`, { taskId: task.id, phase: "task_start" });
        try {
          const resolvedArgs = this.resolveArgs(task.args);
          const langChainTools = toolRegistry.toLangChainTools();
          const tool2 = langChainTools.find((t2) => t2.name === task.tool);
          if (!tool2) {
            throw new Error(`Tool not found: ${task.tool}`);
          }
          const result = await this.invokeWithBrowserLock(task.tool, () => tool2.invoke(resolvedArgs));
          task.result = String(result);
          if (task.assertions && task.assertions.length > 0) {
            onStep == null ? void 0 : onStep("thought", `Verifying task: ${task.name} with ${task.assertions.length} assertions...`, { taskId: task.id });
            for (const assertion of task.assertions) {
              const assertionTool = this.getAssertionTool(assertion.type);
              if (assertionTool) {
                const assertionArgs = {
                  [assertion.type === "text_exists" ? "text" : assertion.type === "selector_exists" ? "selector" : "urlPart"]: assertion.value,
                  tabId: resolvedArgs.tabId,
                  timeoutMs: assertion.timeoutMs || 5e3
                };
                const verificationResult = await this.invokeWithBrowserLock(assertionTool.name, () => assertionTool.invoke(assertionArgs));
                if (verificationResult.includes("Timeout") || verificationResult.includes("Did not find")) {
                  throw new Error(`Assertion failed: ${assertion.type} "${assertion.value}" - ${verificationResult}`);
                }
              }
            }
          }
          task.status = "completed";
          if (task.tool === "browser_open_tab" && task.result) {
            try {
              const parsed = JSON.parse(task.result);
              if (parsed.tabId) {
                this.availableTabs.push(parsed.tabId);
              }
            } catch {
            }
          }
          this.extractToContext(task.id, task.result);
          onStep == null ? void 0 : onStep("observation", `Task ${task.name} completed.`, { taskId: task.id, result: task.result, phase: "task_end" });
        } catch (e) {
          const errorMessage = e instanceof Error ? e.message : String(e);
          task.status = "failed";
          task.error = errorMessage;
          hasFailure = true;
          onStep == null ? void 0 : onStep("observation", `Task ${task.name} failed: ${errorMessage}`, { taskId: task.id, error: errorMessage, phase: "task_error" });
        }
      });
      if (taskPromises.length > 0) {
        await Promise.race(taskPromises);
      } else {
        await new Promise((resolve) => setTimeout(resolve, 100));
      }
    }
    return {
      success: !hasFailure && this.getPendingTasks().length === 0,
      tasks: Array.from(this.tasks.values()),
      context: this.context
    };
  }
  getPendingTasks() {
    return Array.from(this.tasks.values()).filter((t2) => t2.status === "pending");
  }
  getRunningTasks() {
    return Array.from(this.tasks.values()).filter((t2) => t2.status === "running");
  }
  getAssertionTool(type) {
    const toolName = type === "text_exists" ? "browser_wait_for_text" : type === "selector_exists" ? "browser_wait_for_selector" : "browser_wait_for_url";
    const langChainTools = toolRegistry.toLangChainTools();
    return langChainTools.find((t2) => t2.name === toolName);
  }
  async invokeWithBrowserLock(toolName, fn) {
    if (!this.isBrowserTool(toolName)) {
      return fn();
    }
    const previous = this.browserToolQueue;
    let release = () => void 0;
    const next = new Promise((resolve) => {
      release = resolve;
    });
    this.browserToolQueue = previous.then(() => next);
    await previous;
    try {
      return await fn();
    } finally {
      release();
    }
  }
  isBrowserTool(toolName) {
    return toolName.startsWith("browser_");
  }
  resolveArgs(args) {
    const resolved = { ...args };
    for (const key in resolved) {
      const value = resolved[key];
      if (typeof value === "string") {
        resolved[key] = value.replace(/\{\{([^}]+)\}\}/g, (_, pathMatch) => {
          const [taskId, ...props] = pathMatch.split(".");
          let val = this.context[taskId];
          if (val && typeof val === "object") {
            for (const prop of props) {
              if (val && typeof val === "object" && prop in val) {
                val = val[prop];
              } else {
                val = void 0;
                break;
              }
            }
          }
          return val !== void 0 ? String(val) : `{{${pathMatch}}}`;
        });
      } else if (typeof value === "object" && value !== null) {
        resolved[key] = this.resolveArgs(value);
      }
    }
    return resolved;
  }
  extractToContext(taskId, result) {
    try {
      const parsed = JSON.parse(result);
      this.context[taskId] = parsed;
    } catch {
      this.context[taskId] = { raw: result };
    }
  }
}
const _SpeculativeExecutor = class _SpeculativeExecutor {
  constructor() {
    __publicField2(this, "patterns", []);
    __publicField2(this, "pendingSpeculations", /* @__PURE__ */ new Map());
    __publicField2(this, "domSnapshots", /* @__PURE__ */ new Map());
    __publicField2(this, "rollbackStack", []);
    __publicField2(this, "stats", {
      totalPredictions: 0,
      correctPredictions: 0,
      executedSpeculations: 0,
      rolledBack: 0,
      totalLatencySavedMs: 0
    });
    this.setupDefaultPatterns();
  }
  setupDefaultPatterns() {
    this.addPattern({
      name: "navigate-then-observe",
      priority: 100,
      match: (ctx) => ctx.lastTool === "browser_navigate",
      predict: (_ctx) => ({
        tool: "browser_observe",
        args: {},
        confidence: 0.95,
        reason: "After navigation, observation is almost always needed"
      })
    });
    this.addPattern({
      name: "observe-form-interaction",
      priority: 90,
      match: (ctx) => {
        var _a3;
        if (ctx.lastTool !== "browser_observe") return false;
        const resultText = ((_a3 = ctx.lastToolResult) == null ? void 0 : _a3.toLowerCase()) || "";
        return resultText.includes("input") || resultText.includes("form") || resultText.includes("button");
      },
      predict: (ctx) => {
        var _a3, _b, _c;
        ((_a3 = ctx.lastToolResult) == null ? void 0 : _a3.toLowerCase()) || "";
        const userMsg = ctx.userMessage.toLowerCase();
        if (userMsg.includes("search") || userMsg.includes("type") || userMsg.includes("enter")) {
          const inputMatch = (_b = ctx.lastToolResult) == null ? void 0 : _b.match(/data-testid="([^"]*input[^"]*)"/i);
          if (inputMatch) {
            return {
              tool: "browser_click",
              args: { selector: `[data-testid="${inputMatch[1]}"]` },
              confidence: 0.88,
              reason: "User wants to type, clicking input field first"
            };
          }
        }
        if (userMsg.includes("click") || userMsg.includes("submit") || userMsg.includes("go")) {
          const buttonMatch = (_c = ctx.lastToolResult) == null ? void 0 : _c.match(/data-testid="([^"]*button[^"]*)"/i);
          if (buttonMatch) {
            return {
              tool: "browser_click",
              args: { selector: `[data-testid="${buttonMatch[1]}"]` },
              confidence: 0.86,
              reason: "User wants to click, found matching button"
            };
          }
        }
        return null;
      }
    });
    this.addPattern({
      name: "search-intent",
      priority: 80,
      match: (ctx) => {
        var _a3;
        const msg = ctx.userMessage.toLowerCase();
        return (msg.includes("search for") || msg.includes("look up") || msg.includes("find info")) && !((_a3 = ctx.browserUrl) == null ? void 0 : _a3.includes("duckduckgo"));
      },
      predict: (ctx) => {
        const searchMatch = ctx.userMessage.match(/(?:search for|look up|find info about)\s+["']?([^"'\n]+)/i);
        if (searchMatch) {
          const query = encodeURIComponent(searchMatch[1].trim());
          return {
            tool: "browser_navigate",
            args: { url: `https://duckduckgo.com/?q=${query}` },
            confidence: 0.9,
            reason: "User wants to search, navigating to DuckDuckGo"
          };
        }
        return null;
      }
    });
    this.addPattern({
      name: "click-then-observe",
      priority: 95,
      match: (ctx) => ctx.lastTool === "browser_click",
      predict: (_ctx) => ({
        tool: "browser_observe",
        args: {},
        confidence: 0.92,
        reason: "After clicking, need to observe the result"
      })
    });
    this.addPattern({
      name: "type-then-submit",
      priority: 85,
      match: (ctx) => ctx.lastTool === "browser_type",
      predict: (ctx) => {
        var _a3, _b;
        const submitMatch = ((_a3 = ctx.lastToolResult) == null ? void 0 : _a3.match(/data-testid="([^"]*submit[^"]*)"/i)) || ((_b = ctx.lastToolResult) == null ? void 0 : _b.match(/data-testid="([^"]*search[^"]*button[^"]*)"/i));
        if (submitMatch) {
          return {
            tool: "browser_click",
            args: { selector: `[data-testid="${submitMatch[1]}"]` },
            confidence: 0.87,
            reason: "After typing, clicking submit button"
          };
        }
        return null;
      }
    });
    this.addPattern({
      name: "url-in-message",
      priority: 70,
      match: (ctx) => {
        return /https?:\/\/[^\s]+/.test(ctx.userMessage) || /\b[a-z0-9-]+\.(com|org|net|io)\b/i.test(ctx.userMessage);
      },
      predict: (ctx) => {
        let urlMatch = ctx.userMessage.match(/(https?:\/\/[^\s]+)/);
        if (!urlMatch) {
          const domainMatch = ctx.userMessage.match(/\b([a-z0-9-]+\.(com|org|net|io)[^\s]*)/i);
          if (domainMatch) {
            urlMatch = [`https://${domainMatch[1]}`, `https://${domainMatch[1]}`];
          }
        }
        if (urlMatch) {
          return {
            tool: "browser_navigate",
            args: { url: urlMatch[1] },
            confidence: 0.88,
            reason: "URL detected in user message"
          };
        }
        return null;
      }
    });
    this.addPattern({
      name: "navigation-intent",
      priority: 75,
      match: (ctx) => {
        const msg = ctx.userMessage.toLowerCase();
        return msg.includes("go to") || msg.includes("open") || msg.includes("navigate to");
      },
      predict: (ctx) => {
        const navMatch = ctx.userMessage.match(/(?:go to|open|navigate to)\s+["']?([^\s"']+)/i);
        if (navMatch) {
          let url = navMatch[1];
          if (!url.startsWith("http")) {
            url = `https://${url}`;
          }
          return {
            tool: "browser_navigate",
            args: { url },
            confidence: 0.86,
            reason: "Navigation intent detected"
          };
        }
        return null;
      }
    });
  }
  addPattern(pattern) {
    this.patterns.push(pattern);
    this.patterns.sort((a, b) => b.priority - a.priority);
  }
  removePattern(name) {
    this.patterns = this.patterns.filter((p) => p.name !== name);
  }
  /**
   * Predict the next likely tool call based on current context
   */
  predict(context) {
    for (const pattern of this.patterns) {
      if (pattern.match(context)) {
        const prediction = pattern.predict(context);
        if (prediction && prediction.confidence >= _SpeculativeExecutor.CONFIDENCE_THRESHOLD) {
          this.stats.totalPredictions++;
          return prediction;
        }
      }
    }
    return null;
  }
  /**
   * Execute a speculative prediction
   */
  async executeSpeculative(prediction) {
    const predictionId = v4$2();
    const startTime2 = Date.now();
    const result = {
      predictionId,
      prediction,
      result: null,
      executed: false,
      matched: false,
      executionTimeMs: 0
    };
    if (this.pendingSpeculations.size >= _SpeculativeExecutor.MAX_SPECULATIVE_QUEUE) {
      return result;
    }
    const safeTool = this.isSafeForSpeculation(prediction.tool);
    if (!safeTool) {
      return result;
    }
    try {
      await this.captureSnapshot(predictionId);
      const tools = toolRegistry.toLangChainTools();
      const tool2 = tools.find((t2) => t2.name === prediction.tool);
      if (tool2) {
        const toolResult = await tool2.invoke(prediction.args);
        result.result = String(toolResult);
        result.executed = true;
        result.executionTimeMs = Date.now() - startTime2;
        this.stats.executedSpeculations++;
        this.rollbackStack.push({
          snapshotId: predictionId,
          toolName: prediction.tool,
          args: prediction.args,
          canRollback: this.canRollback(prediction.tool)
        });
        telemetryService.emit({
          eventId: v4$2(),
          runId: agentRunContext.getRunId() ?? void 0,
          ts: (/* @__PURE__ */ new Date()).toISOString(),
          type: "tool_call_start",
          name: "SpeculativeExecutor",
          data: {
            predictionId,
            tool: prediction.tool,
            confidence: prediction.confidence,
            speculative: true,
            executionTimeMs: result.executionTimeMs
          }
        });
      }
    } catch (e) {
      console.error("[SpeculativeExecutor] Speculative execution failed:", e);
    }
    this.pendingSpeculations.set(predictionId, result);
    return result;
  }
  /**
   * Verify if the actual LLM output matches our prediction
   */
  verifyPrediction(predictionId, actualTool, actualArgs) {
    const speculation = this.pendingSpeculations.get(predictionId);
    if (!speculation) {
      return { matched: false, result: null };
    }
    const matched = speculation.prediction.tool === actualTool && this.argsMatch(speculation.prediction.args, actualArgs);
    speculation.matched = matched;
    if (matched) {
      this.stats.correctPredictions++;
      this.stats.totalLatencySavedMs += speculation.executionTimeMs;
    }
    telemetryService.emit({
      eventId: v4$2(),
      runId: agentRunContext.getRunId() ?? void 0,
      ts: (/* @__PURE__ */ new Date()).toISOString(),
      type: "tool_call_end",
      name: "SpeculativeExecutor",
      data: {
        predictionId,
        matched,
        predictedTool: speculation.prediction.tool,
        actualTool,
        latencySavedMs: matched ? speculation.executionTimeMs : 0
      }
    });
    return { matched, result: speculation };
  }
  /**
   * Rollback a mis-predicted speculative execution
   */
  async rollback(predictionId) {
    const rollbackState = this.rollbackStack.find((r) => r.snapshotId === predictionId);
    if (!rollbackState || !rollbackState.canRollback) {
      return false;
    }
    const snapshot = this.domSnapshots.get(predictionId);
    if (!snapshot) {
      return false;
    }
    try {
      if (rollbackState.toolName === "browser_navigate") {
        const tools = toolRegistry.toLangChainTools();
        const navTool = tools.find((t2) => t2.name === "browser_navigate");
        if (navTool && snapshot.url) {
          await navTool.invoke({ url: snapshot.url });
          this.stats.rolledBack++;
          return true;
        }
      }
      if (rollbackState.toolName === "browser_click") {
        const tools = toolRegistry.toLangChainTools();
        const navTool = tools.find((t2) => t2.name === "browser_navigate");
        if (navTool && snapshot.url) {
          await navTool.invoke({ url: snapshot.url });
          this.stats.rolledBack++;
          return true;
        }
      }
    } catch (e) {
      console.error("[SpeculativeExecutor] Rollback failed:", e);
    }
    return false;
  }
  /**
   * Get a pending speculation result if it matches the requested tool
   */
  getMatchingSpeculation(tool2, args) {
    for (const [, speculation] of this.pendingSpeculations) {
      if (speculation.executed && speculation.prediction.tool === tool2 && this.argsMatch(speculation.prediction.args, args)) {
        return speculation;
      }
    }
    return null;
  }
  /**
   * Clear all pending speculations
   */
  clearPending() {
    this.pendingSpeculations.clear();
    this.rollbackStack = [];
  }
  /**
   * Get speculation statistics
   */
  getStats() {
    const hitRate = this.stats.totalPredictions > 0 ? this.stats.correctPredictions / this.stats.totalPredictions * 100 : 0;
    return {
      ...this.stats,
      hitRate: Math.round(hitRate * 100) / 100,
      avgLatencySavedMs: this.stats.correctPredictions > 0 ? Math.round(this.stats.totalLatencySavedMs / this.stats.correctPredictions) : 0
    };
  }
  /**
   * Reset statistics
   */
  resetStats() {
    this.stats = {
      totalPredictions: 0,
      correctPredictions: 0,
      executedSpeculations: 0,
      rolledBack: 0,
      totalLatencySavedMs: 0
    };
  }
  isSafeForSpeculation(toolName) {
    const safeTool = [
      "browser_observe",
      "api_web_search"
    ];
    return safeTool.includes(toolName);
  }
  canRollback(toolName) {
    const rollbackable = ["browser_navigate", "browser_click"];
    return rollbackable.includes(toolName);
  }
  argsMatch(predicted, actual) {
    const predictedKeys = Object.keys(predicted);
    for (const key of predictedKeys) {
      if (predicted[key] !== actual[key]) {
        if (key === "url" && typeof predicted[key] === "string" && typeof actual[key] === "string") {
          const normalizedPredicted = this.normalizeUrl(predicted[key]);
          const normalizedActual = this.normalizeUrl(actual[key]);
          if (normalizedPredicted !== normalizedActual) {
            return false;
          }
        } else {
          return false;
        }
      }
    }
    return true;
  }
  normalizeUrl(url) {
    try {
      const parsed = new URL(url);
      return `${parsed.hostname}${parsed.pathname}`.replace(/\/$/, "").toLowerCase();
    } catch {
      return url.toLowerCase().replace(/\/$/, "");
    }
  }
  async captureSnapshot(id) {
    const snapshot = {
      id,
      timestamp: Date.now(),
      url: "",
      // Would be populated from browser
      html: "",
      // Would be populated from browser
      scrollPosition: { x: 0, y: 0 },
      activeElement: null
    };
    this.domSnapshots.set(id, snapshot);
    if (this.domSnapshots.size > 10) {
      const oldest = Array.from(this.domSnapshots.keys())[0];
      this.domSnapshots.delete(oldest);
    }
  }
  /**
   * Update snapshot with actual browser state
   */
  updateSnapshot(id, state) {
    const snapshot = this.domSnapshots.get(id);
    if (snapshot) {
      Object.assign(snapshot, state);
    }
  }
};
__publicField2(_SpeculativeExecutor, "CONFIDENCE_THRESHOLD", 0.85);
__publicField2(_SpeculativeExecutor, "MAX_SPECULATIVE_QUEUE", 3);
let SpeculativeExecutor = _SpeculativeExecutor;
const speculativeExecutor = new SpeculativeExecutor();
var TaskComplexity = /* @__PURE__ */ ((TaskComplexity2) => {
  TaskComplexity2["TRIVIAL"] = "trivial";
  TaskComplexity2["SIMPLE"] = "simple";
  TaskComplexity2["MODERATE"] = "moderate";
  TaskComplexity2["COMPLEX"] = "complex";
  TaskComplexity2["EXPERT"] = "expert";
  return TaskComplexity2;
})(TaskComplexity || {});
const MODEL_TIERS = [
  // Fast tier - for trivial/simple tasks
  {
    id: "llama-3.2-3b",
    name: "Llama 3.2 3B (Ultra Fast)",
    modelName: "meta/llama-3.2-3b-instruct",
    tier: "fast",
    avgLatencyMs: 50,
    maxTokens: 2048,
    temperature: 0.1,
    supportsThinking: false,
    complexities: [
      "trivial"
      /* TRIVIAL */
    ]
  },
  {
    id: "llama-3.1-8b",
    name: "Llama 3.1 8B (Fast)",
    modelName: "meta/llama-3.1-8b-instruct",
    tier: "fast",
    avgLatencyMs: 100,
    maxTokens: 4096,
    temperature: 0.1,
    supportsThinking: false,
    complexities: [
      "trivial",
      "simple"
      /* SIMPLE */
    ]
  },
  // Balanced tier - for moderate tasks
  {
    id: "llama-3.1-70b",
    name: "Llama 3.1 70B (Balanced)",
    modelName: "meta/llama-3.1-70b-instruct",
    tier: "balanced",
    avgLatencyMs: 300,
    maxTokens: 4096,
    temperature: 0.1,
    supportsThinking: false,
    complexities: [
      "simple",
      "moderate"
      /* MODERATE */
    ]
  },
  {
    id: "llama-3.3-70b",
    name: "Llama 3.3 70B (Balanced+)",
    modelName: "meta/llama-3.3-70b-instruct",
    tier: "balanced",
    avgLatencyMs: 350,
    maxTokens: 4096,
    temperature: 0.1,
    supportsThinking: false,
    complexities: [
      "moderate",
      "complex"
      /* COMPLEX */
    ]
  },
  // Powerful tier - for complex/expert tasks
  {
    id: "qwen3-235b",
    name: "Qwen3 235B (Powerful)",
    modelName: "qwen/qwen3-235b-a22b",
    tier: "powerful",
    avgLatencyMs: 1500,
    maxTokens: 4096,
    temperature: 0.6,
    supportsThinking: false,
    complexities: [
      "complex",
      "expert"
      /* EXPERT */
    ]
  },
  {
    id: "deepseek-v3.1",
    name: "DeepSeek V3.1 (Thinking)",
    modelName: "deepseek-ai/deepseek-v3.1-terminus",
    tier: "powerful",
    avgLatencyMs: 2e3,
    maxTokens: 8192,
    temperature: 0.2,
    supportsThinking: true,
    complexities: [
      "complex",
      "expert"
      /* EXPERT */
    ]
  },
  {
    id: "kimi-k2",
    name: "Kimi K2 (Expert Thinking)",
    modelName: "moonshotai/kimi-k2-thinking",
    tier: "powerful",
    avgLatencyMs: 3e3,
    maxTokens: 16384,
    temperature: 1,
    supportsThinking: true,
    complexities: [
      "expert"
      /* EXPERT */
    ]
  }
];
const COMPLEXITY_INDICATORS = {
  trivial: [
    /^(hi|hello|hey|thanks|thank you|ok|okay|yes|no|sure)$/i,
    /^what (is|are) (the )?(time|date|weather)/i,
    /^(open|go to|navigate to) [a-z0-9.-]+\.(com|org|net|io)/i
  ],
  simple: [
    /^(search for|look up|find) .{1,50}$/i,
    /^(scroll|go) (up|down|to)/i,
    /^(show|display|list) .{1,30}$/i
  ],
  moderate: [
    // Browser automation tasks need capable models for tool calling
    /^(click|tap|press) (on |the )?\w+/i,
    /^(navigate|go) to .+/i,
    /aerocore/i,
    /button/i,
    /^(create|make|add|new) (a |an )?\w+ (in|on|for)/i,
    /^(update|edit|modify|change) .{1,100}$/i,
    /^(fill|complete) (the |this )?(form|fields)/i,
    /multi.?step/i,
    /then .+ then/i,
    /and (click|type|select|navigate)/i
  ],
  complex: [
    /^(analyze|compare|evaluate|assess)/i,
    /^(integrate|sync|connect|link) .+ (with|to|and)/i,
    /^(automate|workflow|process)/i,
    /multiple (systems|apps|platforms)/i,
    /cross.?(platform|system|app)/i
  ],
  expert: [
    /^(debug|troubleshoot|diagnose|investigate)/i,
    /^(optimize|refactor|architect)/i,
    /complex (logic|workflow|integration)/i,
    /enterprise.?(wide|level|grade)/i,
    /mission.?critical/i
  ]
};
const TOKEN_THRESHOLDS = {
  trivial: 20,
  simple: 50,
  moderate: 150,
  complex: 300
};
const _ModelRouter = class _ModelRouter {
  constructor() {
    __publicField2(this, "performanceStats", /* @__PURE__ */ new Map());
    __publicField2(this, "escalationHistory", []);
    for (const model of MODEL_TIERS) {
      this.performanceStats.set(model.id, {
        modelId: model.id,
        totalCalls: 0,
        successfulCalls: 0,
        failedCalls: 0,
        escalations: 0,
        avgLatencyMs: model.avgLatencyMs,
        totalLatencyMs: 0,
        avgConfidence: 0,
        lastUsed: 0
      });
    }
  }
  /**
   * Classify the complexity of a task based on the user message
   */
  classifyComplexity(userMessage, context) {
    const indicators = [];
    let scores = {
      [
        "trivial"
        /* TRIVIAL */
      ]: 0,
      [
        "simple"
        /* SIMPLE */
      ]: 0,
      [
        "moderate"
        /* MODERATE */
      ]: 0,
      [
        "complex"
        /* COMPLEX */
      ]: 0,
      [
        "expert"
        /* EXPERT */
      ]: 0
    };
    const message = userMessage.toLowerCase().trim();
    const tokenCount = this.estimateTokens(userMessage);
    for (const [complexity, patterns] of Object.entries(COMPLEXITY_INDICATORS)) {
      for (const pattern of patterns) {
        if (pattern.test(message)) {
          scores[complexity] += 5;
          indicators.push(`Pattern match: ${complexity}`);
        }
      }
    }
    if (tokenCount <= TOKEN_THRESHOLDS.trivial) {
      scores[
        "trivial"
        /* TRIVIAL */
      ] += 1;
      indicators.push(`Short message (${tokenCount} tokens)`);
    } else if (tokenCount <= TOKEN_THRESHOLDS.simple) {
      scores[
        "simple"
        /* SIMPLE */
      ] += 1;
      indicators.push(`Brief message (${tokenCount} tokens)`);
    } else if (tokenCount <= TOKEN_THRESHOLDS.moderate) {
      scores[
        "moderate"
        /* MODERATE */
      ] += 1;
      indicators.push(`Medium message (${tokenCount} tokens)`);
    } else if (tokenCount <= TOKEN_THRESHOLDS.complex) {
      scores[
        "complex"
        /* COMPLEX */
      ] += 2;
      indicators.push(`Long message (${tokenCount} tokens)`);
    } else {
      scores[
        "expert"
        /* EXPERT */
      ] += 3;
      indicators.push(`Very long message (${tokenCount} tokens)`);
    }
    const stepIndicators = (message.match(/\b(then|after|next|finally|first|second|third)\b/gi) || []).length;
    if (stepIndicators >= 3) {
      scores[
        "complex"
        /* COMPLEX */
      ] += 3;
      indicators.push(`Multi-step task (${stepIndicators} step indicators)`);
    } else if (stepIndicators >= 1) {
      scores[
        "moderate"
        /* MODERATE */
      ] += 2;
      indicators.push(`Sequential task (${stepIndicators} step indicators)`);
    }
    const technicalTerms = (message.match(/\b(api|database|server|deploy|config|auth|token|webhook|endpoint)\b/gi) || []).length;
    if (technicalTerms >= 3) {
      scores[
        "complex"
        /* COMPLEX */
      ] += 2;
      indicators.push(`Technical task (${technicalTerms} technical terms)`);
    }
    if (/^(how|why|what if|explain|compare)/i.test(message)) {
      scores[
        "moderate"
        /* MODERATE */
      ] += 1;
      indicators.push("Analytical question");
    }
    if (context) {
      const contextLength = context.length;
      if (contextLength > 5e3) {
        scores[
          "complex"
          /* COMPLEX */
        ] += 1;
        indicators.push("Large context");
      }
    }
    let maxScore = 0;
    let selectedComplexity = "moderate";
    for (const [complexity, score] of Object.entries(scores)) {
      if (score > maxScore) {
        maxScore = score;
        selectedComplexity = complexity;
      }
    }
    const sortedScores = Object.values(scores).sort((a, b) => b - a);
    const margin = sortedScores[0] - (sortedScores[1] || 0);
    const totalScore = sortedScores.reduce((a, b) => a + b, 0);
    const confidence = totalScore > 0 ? Math.min(0.95, 0.5 + margin / totalScore * 0.5 + maxScore / 10 * 0.2) : 0.5;
    return {
      complexity: selectedComplexity,
      confidence: Math.round(confidence * 100) / 100,
      reason: this.getComplexityReason(selectedComplexity, indicators),
      indicators
    };
  }
  /**
   * Route to the optimal model based on task complexity
   */
  route(userMessage, context) {
    const classification = this.classifyComplexity(userMessage, context);
    const eligibleModels = MODEL_TIERS.filter(
      (m) => m.complexities.includes(classification.complexity)
    );
    if (eligibleModels.length === 0) {
      const fallback = MODEL_TIERS.find((m) => m.id === "llama-3.3-70b");
      return {
        selectedModel: fallback,
        classification,
        fallbackModel: MODEL_TIERS.find((m) => m.id === "qwen3-235b") || null,
        reason: "No model found for complexity, using balanced fallback"
      };
    }
    const sortedModels = eligibleModels.sort((a, b) => {
      const statsA = this.performanceStats.get(a.id);
      const statsB = this.performanceStats.get(b.id);
      if (statsA && statsB && statsA.totalCalls > 10 && statsB.totalCalls > 10) {
        const successRateA = statsA.successfulCalls / statsA.totalCalls;
        const successRateB = statsB.successfulCalls / statsB.totalCalls;
        if (successRateA < 0.8 && successRateB >= 0.8) return 1;
        if (successRateB < 0.8 && successRateA >= 0.8) return -1;
      }
      return a.avgLatencyMs - b.avgLatencyMs;
    });
    const selectedModel = sortedModels[0];
    let fallbackModel = null;
    if (selectedModel.tier === "fast") {
      fallbackModel = MODEL_TIERS.find((m) => m.tier === "balanced") || null;
    } else if (selectedModel.tier === "balanced") {
      fallbackModel = MODEL_TIERS.find((m) => m.tier === "powerful") || null;
    }
    telemetryService.emit({
      eventId: v4$2(),
      runId: agentRunContext.getRunId() ?? void 0,
      ts: (/* @__PURE__ */ new Date()).toISOString(),
      type: "plan_step_start",
      name: "ModelRouter",
      data: {
        complexity: classification.complexity,
        confidence: classification.confidence,
        selectedModel: selectedModel.id,
        fallbackModel: fallbackModel == null ? void 0 : fallbackModel.id,
        indicators: classification.indicators
      }
    });
    return {
      selectedModel,
      classification,
      fallbackModel,
      reason: `Selected ${selectedModel.name} for ${classification.complexity} task (${Math.round(classification.confidence * 100)}% confidence)`
    };
  }
  /**
   * Check if we should escalate to a more powerful model
   */
  shouldEscalate(currentModelId, confidence, errorOccurred = false) {
    const currentModel = MODEL_TIERS.find((m) => m.id === currentModelId);
    if (!currentModel) {
      return { escalate: false, targetModel: null, reason: "Current model not found" };
    }
    if (currentModel.tier === "powerful" && currentModel.supportsThinking) {
      return { escalate: false, targetModel: null, reason: "Already at highest tier" };
    }
    const shouldEscalate = confidence < _ModelRouter.ESCALATION_CONFIDENCE_THRESHOLD || errorOccurred;
    if (!shouldEscalate) {
      return { escalate: false, targetModel: null, reason: "Confidence sufficient" };
    }
    let targetModel = null;
    if (currentModel.tier === "fast") {
      targetModel = MODEL_TIERS.find((m) => m.tier === "balanced") || null;
    } else if (currentModel.tier === "balanced") {
      targetModel = MODEL_TIERS.find((m) => m.tier === "powerful") || null;
    } else if (currentModel.tier === "powerful" && !currentModel.supportsThinking) {
      targetModel = MODEL_TIERS.find((m) => m.tier === "powerful" && m.supportsThinking) || null;
    }
    if (targetModel) {
      const reason = errorOccurred ? `Error occurred, escalating from ${currentModel.name} to ${targetModel.name}` : `Low confidence (${Math.round(confidence * 100)}%), escalating from ${currentModel.name} to ${targetModel.name}`;
      this.escalationHistory.push({
        from: currentModelId,
        to: targetModel.id,
        reason,
        timestamp: Date.now()
      });
      if (this.escalationHistory.length > _ModelRouter.MAX_ESCALATION_HISTORY) {
        this.escalationHistory = this.escalationHistory.slice(-100);
      }
      const stats = this.performanceStats.get(currentModelId);
      if (stats) {
        stats.escalations++;
      }
      return { escalate: true, targetModel, reason };
    }
    return { escalate: false, targetModel: null, reason: "No higher tier available" };
  }
  /**
   * Record model performance for a completed call
   */
  recordPerformance(modelId, success2, latencyMs, confidence) {
    const stats = this.performanceStats.get(modelId);
    if (!stats) return;
    stats.totalCalls++;
    if (success2) {
      stats.successfulCalls++;
    } else {
      stats.failedCalls++;
    }
    stats.totalLatencyMs += latencyMs;
    stats.avgLatencyMs = Math.round(stats.totalLatencyMs / stats.totalCalls);
    stats.avgConfidence = (stats.avgConfidence * (stats.totalCalls - 1) + confidence) / stats.totalCalls;
    stats.lastUsed = Date.now();
    telemetryService.emit({
      eventId: v4$2(),
      runId: agentRunContext.getRunId() ?? void 0,
      ts: (/* @__PURE__ */ new Date()).toISOString(),
      type: "plan_step_end",
      name: "ModelRouter",
      data: {
        modelId,
        success: success2,
        latencyMs,
        confidence,
        avgLatencyMs: stats.avgLatencyMs,
        successRate: stats.successfulCalls / stats.totalCalls
      }
    });
  }
  /**
   * Get performance statistics for all models
   */
  getPerformanceStats() {
    return Array.from(this.performanceStats.values());
  }
  /**
   * Get performance dashboard data
   */
  getDashboard() {
    const models = Array.from(this.performanceStats.values()).map((stats) => {
      const model = MODEL_TIERS.find((m) => m.id === stats.modelId);
      return {
        ...stats,
        tier: (model == null ? void 0 : model.tier) || "unknown",
        successRate: stats.totalCalls > 0 ? stats.successfulCalls / stats.totalCalls : 0
      };
    });
    const totalCalls = models.reduce((sum, m) => sum + m.totalCalls, 0);
    const totalEscalations = models.reduce((sum, m) => sum + m.escalations, 0);
    const escalationRate = totalCalls > 0 ? totalEscalations / totalCalls : 0;
    const avgLatencyByTier = {};
    for (const tier of ["fast", "balanced", "powerful"]) {
      const tierModels = models.filter((m) => m.tier === tier && m.totalCalls > 0);
      if (tierModels.length > 0) {
        avgLatencyByTier[tier] = Math.round(
          tierModels.reduce((sum, m) => sum + m.avgLatencyMs, 0) / tierModels.length
        );
      }
    }
    const recommendations = [];
    for (const model of models) {
      if (model.totalCalls > 20 && model.successRate < 0.8) {
        recommendations.push(`Consider avoiding ${model.modelId} - success rate is ${Math.round(model.successRate * 100)}%`);
      }
      if (model.escalations > model.totalCalls * 0.3) {
        recommendations.push(`${model.modelId} has high escalation rate - consider routing to higher tier directly`);
      }
    }
    if (escalationRate > 0.2) {
      recommendations.push("High overall escalation rate - consider adjusting complexity thresholds");
    }
    return {
      models,
      escalationRate,
      avgLatencyByTier,
      recommendations
    };
  }
  /**
   * Get all available model tiers
   */
  getModelTiers() {
    return [...MODEL_TIERS];
  }
  /**
   * Reset performance statistics
   */
  resetStats() {
    for (const model of MODEL_TIERS) {
      this.performanceStats.set(model.id, {
        modelId: model.id,
        totalCalls: 0,
        successfulCalls: 0,
        failedCalls: 0,
        escalations: 0,
        avgLatencyMs: model.avgLatencyMs,
        totalLatencyMs: 0,
        avgConfidence: 0,
        lastUsed: 0
      });
    }
    this.escalationHistory = [];
  }
  estimateTokens(text) {
    return Math.ceil(text.length / 4);
  }
  getComplexityReason(complexity, indicators) {
    const reasons = {
      [
        "trivial"
        /* TRIVIAL */
      ]: "Simple greeting or single-action request",
      [
        "simple"
        /* SIMPLE */
      ]: "Basic task with clear intent",
      [
        "moderate"
        /* MODERATE */
      ]: "Multi-step task or form interaction",
      [
        "complex"
        /* COMPLEX */
      ]: "Cross-system integration or analysis required",
      [
        "expert"
        /* EXPERT */
      ]: "Advanced reasoning or debugging needed"
    };
    return `${reasons[complexity]}. Indicators: ${indicators.slice(0, 3).join(", ")}`;
  }
};
__publicField2(_ModelRouter, "ESCALATION_CONFIDENCE_THRESHOLD", 0.7);
__publicField2(_ModelRouter, "MAX_ESCALATION_HISTORY", 100);
let ModelRouter = _ModelRouter;
const modelRouter = new ModelRouter();
class BrowserTargetService {
  constructor() {
    __publicField2(this, "tabIdToWebContentsId", /* @__PURE__ */ new Map());
    __publicField2(this, "activeTabId", null);
    __publicField2(this, "waiters", /* @__PURE__ */ new Map());
  }
  getDomainTokenFromUrl(url) {
    try {
      const host = new URL(url).hostname.toLowerCase();
      if (!host) return null;
      if (host === "localhost") return "localhost";
      const parts = host.split(".").filter(Boolean);
      const cleaned = parts[0] === "www" ? parts.slice(1) : parts;
      if (cleaned.length >= 2) return cleaned[cleaned.length - 2];
      return cleaned[0] ?? null;
    } catch {
      return null;
    }
  }
  registerWebview(tabId, webContentsId) {
    if (!tabId || !Number.isFinite(webContentsId)) return;
    this.tabIdToWebContentsId.set(tabId, {
      tabId,
      webContentsId,
      lastSeenAt: Date.now()
    });
    const pending = this.waiters.get(tabId);
    if (pending && pending.length > 0) {
      this.waiters.delete(tabId);
      for (const wake of pending) wake();
    }
  }
  setActiveTab(tabId) {
    this.activeTabId = tabId;
    if (tabId) {
      const existing = this.tabIdToWebContentsId.get(tabId);
      if (existing) {
        this.tabIdToWebContentsId.set(tabId, { ...existing, lastSeenAt: Date.now() });
      }
    }
  }
  getActiveTabId() {
    return this.activeTabId;
  }
  getWebContents(tabId) {
    const registered = this.tabIdToWebContentsId.get(tabId);
    if (registered) {
      const wc = webContents$1.fromId(registered.webContentsId);
      if (wc && !wc.isDestroyed()) {
        this.tabIdToWebContentsId.set(tabId, { ...registered, lastSeenAt: Date.now() });
        return wc;
      }
    }
    return null;
  }
  async waitForTab(tabId, timeoutMs = 5e3) {
    if (!tabId) return false;
    if (this.getWebContents(tabId)) return true;
    return await new Promise((resolve) => {
      const timer = setTimeout(() => resolve(false), timeoutMs);
      const wake = () => {
        clearTimeout(timer);
        resolve(Boolean(this.getWebContents(tabId)));
      };
      const list = this.waiters.get(tabId) ?? [];
      list.push(wake);
      this.waiters.set(tabId, list);
    });
  }
  /**
   * Returns the most recently used tabId for a domain token (e.g. "youtube")
   * based on lastSeenAt. Returns null if none match.
   */
  getMostRecentTabForDomainToken(domainToken) {
    const token = String(domainToken || "").toLowerCase().trim();
    if (!token) return null;
    const candidates = Array.from(this.tabIdToWebContentsId.values()).slice().sort((a, b) => (b.lastSeenAt ?? 0) - (a.lastSeenAt ?? 0));
    for (const reg of candidates) {
      const wc = webContents$1.fromId(reg.webContentsId);
      if (!wc || wc.isDestroyed()) continue;
      const url = wc.getURL() || "";
      const dt = this.getDomainTokenFromUrl(url);
      if (dt && dt === token) return reg.tabId;
    }
    return null;
  }
  getActiveWebContents() {
    const activeTabId = this.activeTabId;
    if (activeTabId) {
      const wc = this.getWebContents(activeTabId);
      if (wc) return wc;
    }
    const all = webContents$1.getAllWebContents();
    const candidates = all.filter((wc) => !wc.isDestroyed()).filter((wc) => wc.getType() === "webview").filter((wc) => {
      const url = wc.getURL() || "";
      return !url.startsWith("devtools://") && !url.includes("localhost:5173") && !url.includes("localhost:5174") && !url.endsWith("index.html");
    });
    if (candidates.length === 0) {
      throw new Error(
        "No active webview found. Open a tab and ensure the BrowserView is loaded."
      );
    }
    return candidates[candidates.length - 1];
  }
}
const browserTargetService = new BrowserTargetService();
class AgentTabOpenService {
  constructor() {
    __publicField2(this, "pending", /* @__PURE__ */ new Map());
    __publicField2(this, "listening", false);
  }
  ensureListener() {
    if (this.listening) return;
    this.listening = true;
    ipcMain$1.on(
      "browser:open-agent-tab-result",
      (_event, payload) => {
        const resolve = this.pending.get(payload.requestId);
        if (resolve) {
          this.pending.delete(payload.requestId);
          resolve(payload.tabId);
        }
      }
    );
  }
  async openAgentTab(args) {
    this.ensureListener();
    const win2 = BrowserWindow$1.getAllWindows()[0];
    if (!win2) {
      return "new-tab-" + Date.now();
    }
    const requestId = v4$2();
    const tabId = await new Promise((resolve) => {
      this.pending.set(requestId, resolve);
      win2.webContents.send("browser:open-agent-tab", { ...args, requestId });
      setTimeout(() => {
        if (this.pending.has(requestId)) {
          this.pending.delete(requestId);
          resolve("new-tab-" + Date.now());
        }
      }, 2e3);
    });
    return tabId;
  }
}
const agentTabOpenService = new AgentTabOpenService();
dotenv.config();
const AVAILABLE_MODELS = [
  {
    id: "llama-3.1-70b",
    name: "Llama 3.1 70B (Fast)",
    modelName: "meta/llama-3.1-70b-instruct",
    temperature: 0.1,
    maxTokens: 4096,
    supportsThinking: false
  },
  {
    id: "llama-3.3-70b",
    name: "Llama 3.3 70B â­ Recommended",
    modelName: "meta/llama-3.3-70b-instruct",
    temperature: 0.1,
    maxTokens: 4096,
    supportsThinking: false
  },
  {
    id: "qwen3-235b",
    name: "Qwen3 235B (Best Quality)",
    modelName: "qwen/qwen3-235b-a22b",
    temperature: 0.6,
    maxTokens: 4096,
    supportsThinking: false
  },
  {
    id: "deepseek-v3.1",
    name: "DeepSeek V3.1 (Thinking)",
    modelName: "deepseek-ai/deepseek-v3.1-terminus",
    temperature: 0.2,
    maxTokens: 8192,
    supportsThinking: true,
    extraBody: { chat_template_kwargs: { thinking: true } }
  },
  {
    id: "qwen3-80b",
    name: "Qwen3 80B (Thinking)",
    modelName: "qwen/qwen3-next-80b-a3b-thinking",
    temperature: 0.6,
    maxTokens: 4096,
    supportsThinking: true
  },
  {
    id: "kimi-k2",
    name: "Kimi K2 (Thinking)",
    modelName: "moonshotai/kimi-k2-thinking",
    temperature: 1,
    maxTokens: 16384,
    supportsThinking: true
  },
  {
    id: "nemotron-nano",
    name: "Nemotron Nano 30B (Thinking)",
    modelName: "nvidia/nemotron-3-nano-30b-a3b",
    temperature: 1,
    maxTokens: 16384,
    supportsThinking: true,
    extraBody: { chat_template_kwargs: { enable_thinking: true } }
  },
  {
    id: "actions-policy-v1",
    name: "Actions Policy (Beta)",
    modelName: "custom/actions-policy-v1",
    temperature: 0,
    maxTokens: 2048,
    supportsThinking: false
  }
];
const _AgentService = class _AgentService {
  constructor() {
    __publicField2(this, "model");
    __publicField2(this, "currentModelId", "llama-3.1-70b");
    __publicField2(this, "useActionsPolicy", false);
    __publicField2(this, "agentMode", "do");
    __publicField2(this, "permissionMode", "permissions");
    __publicField2(this, "onStep");
    __publicField2(this, "onToken");
    __publicField2(this, "conversationHistory", []);
    __publicField2(this, "systemPrompt");
    __publicField2(this, "llmConfig", {
      provider: "nvidia",
      baseUrl: "https://integrate.api.nvidia.com/v1",
      apiKeyAccount: "llm:nvidia:apiKey",
      apiKey: process.env.NVIDIA_API_KEY ?? null
    });
    __publicField2(this, "summaries", []);
    __publicField2(this, "orchestrator");
    this.model = this.createModel("llama-3.1-70b");
    this.systemPrompt = new SystemMessage("");
    this.orchestrator = new WorkflowOrchestrator(this.model);
  }
  redactSecrets(text) {
    if (!text) return text;
    let redacted = text;
    const patterns = [
      { re: /Bearer\s+[a-zA-Z0-9\-._]+/gi, repl: "Bearer [REDACTED_TOKEN]" },
      { re: /Authorization\s*:\s*Bearer\s+[a-zA-Z0-9\-._]+/gi, repl: "Authorization: Bearer [REDACTED_TOKEN]" },
      { re: /sk-[a-zA-Z0-9]{32,}/g, repl: "[REDACTED_OPENAI_KEY]" },
      { re: /gh[pousr]_[A-Za-z0-9_]{20,}/g, repl: "[REDACTED_GITHUB_TOKEN]" },
      { re: /xox[baprs]-[A-Za-z0-9-]{10,}/g, repl: "[REDACTED_SLACK_TOKEN]" },
      { re: /AKIA[0-9A-Z]{16}/g, repl: "[REDACTED_AWS_KEY]" },
      { re: /\beyJ[a-zA-Z0-9_-]{10,}\.[a-zA-Z0-9_-]{10,}\.[a-zA-Z0-9_-]{10,}\b/g, repl: "[REDACTED_JWT]" },
      { re: /"(password|client_secret|access_token|id_token|refresh_token|api_key|apikey)"\s*:\s*"[^"]+"/gi, repl: '"$1": "[REDACTED]"' },
      { re: /(password|passwd|pwd|token|secret|api[_-]?key)\s*[:=]\s*[^\s\n"']+/gi, repl: "$1=[REDACTED]" },
      { re: /-----BEGIN [A-Z]+ PRIVATE KEY-----[\s\S]*?-----END [A-Z]+ PRIVATE KEY-----/g, repl: "[REDACTED_PRIVATE_KEY]" }
    ];
    for (const { re: re2, repl } of patterns) {
      redacted = redacted.replace(re2, repl);
    }
    return redacted;
  }
  extractJsonObject(input) {
    const markdownMatch = input.match(/```json\s*([\s\S]*?)```/) || input.match(/```\s*(\{[\s\S]*?})\s*```/);
    let text = markdownMatch ? markdownMatch[1].trim() : input.trim();
    if (!markdownMatch || text.length < 5) {
      const candidates = [];
      let pos = input.indexOf("{");
      while (pos !== -1) {
        candidates.push(input.slice(pos));
        pos = input.indexOf("{", pos + 1);
      }
      for (const candidate of candidates) {
        let depth2 = 0;
        let inString2 = false;
        let escaped2 = false;
        for (let i2 = 0; i2 < candidate.length; i2++) {
          const ch = candidate[i2];
          if (inString2) {
            if (escaped2) escaped2 = false;
            else if (ch === "\\") escaped2 = true;
            else if (ch === '"') inString2 = false;
            continue;
          }
          if (ch === '"') {
            inString2 = true;
            continue;
          }
          if (ch === "{") depth2++;
          if (ch === "}") depth2--;
          if (depth2 === 0) {
            const potential = candidate.slice(0, i2 + 1);
            if (potential.includes('"tool"') || potential.includes("'tool'") || potential.includes('"thought"') || potential.includes("'thought'")) {
              return potential;
            }
          }
        }
      }
      text = input.trim();
    }
    const start = text.indexOf("{");
    if (start === -1) return null;
    let inString = false;
    let escaped = false;
    let depth = 0;
    for (let i2 = start; i2 < text.length; i2++) {
      const ch = text[i2];
      if (inString) {
        if (escaped) escaped = false;
        else if (ch === "\\") escaped = true;
        else if (ch === '"') inString = false;
        continue;
      }
      if (ch === '"') {
        inString = true;
        continue;
      }
      if (ch === "{") depth++;
      if (ch === "}") depth--;
      if (depth === 0) return text.slice(start, i2 + 1);
    }
    return null;
  }
  extractDirectNavigationUrl(text) {
    const match = text.match(/(?:open|go to|navigate to|visit)\s+(?:the\s+)?["']?(https?:\/\/[^\s"']+|(?:[a-z0-9-]+\.)+[a-z]{2,}[^\s"']*)/i);
    if (!match) return null;
    let url = match[1].replace(/[),.!?]+$/, "");
    if (!/^https?:\/\//i.test(url)) url = `https://${url}`;
    return url;
  }
  inferToolFromText(text) {
    const lower = text.toLowerCase();
    let toolName = null;
    if (lower.includes("api_web_search")) toolName = "api_web_search";
    else if (lower.includes("browser_navigate")) toolName = "browser_navigate";
    else if (lower.includes("browser_observe")) toolName = "browser_observe";
    else if (lower.includes("browser_click")) toolName = "browser_click";
    else if (lower.includes("api_http_get")) toolName = "api_http_get";
    if (!toolName) return null;
    let args = {};
    if (toolName === "api_web_search") {
      const match = text.match(/search(?:ing)? (?:for )?["']?([^"'\n]+?)["']?(?: on | in | using |$|\.|,)/i);
      if (match) args = { query: match[1].trim() };
    } else if (toolName === "browser_navigate") {
      const match = text.match(/(?:navigate to|go to|open|visit) (?:the |this )?["']?(https?:\/\/[^\s"']+|[a-z0-9.-]+\.[a-z]{2,}[^\s"']*)/i);
      if (match) {
        let url = match[1];
        if (!url.startsWith("http")) url = "https://" + url;
        args = { url };
      }
      if (Object.keys(args).length === 0) {
        const domainMatch = text.match(/https?:\/\/[^\s"']+|(?:[a-z0-9-]+\.)+[a-z]{2,}(?:\/[\S]*)?/i);
        if (domainMatch) {
          let url = domainMatch[0];
          if (!url.startsWith("http")) url = "https://" + url;
          args = { url };
        }
      }
    }
    if (Object.keys(args).length === 0) return null;
    return { tool: toolName, args, thought: text.slice(0, 100).trim() };
  }
  parseToolCall(rawContent) {
    const cleaned = rawContent.replace(/```json/g, "").replace(/```/g, "").trim();
    const candidate = this.extractJsonObject(cleaned) ?? (cleaned.startsWith("{") ? cleaned : null);
    if (!candidate) return this.inferToolFromText(cleaned);
    const tryParse = (s) => {
      try {
        return JSON.parse(s);
      } catch {
        return null;
      }
    };
    let parsed = tryParse(candidate);
    if (!parsed) parsed = tryParse(candidate.replace(/,\s*([}\]])/g, "$1"));
    if (!parsed) parsed = tryParse(candidate.replace(/:\s*"([^"]*)\n([^"]*)"/g, ': "$1\\n$2"'));
    if (parsed) {
      const normalizedTool = (() => {
        if (typeof parsed.tool === "string") return parsed.tool;
        if (typeof parsed.action === "string") return parsed.action;
        if (typeof parsed.command === "string") return parsed.command;
        return null;
      })();
      if (Array.isArray(parsed.tools) && parsed.tools.length > 0) {
        return { tool: parsed.tools[0].tool, args: parsed.tools[0].args, thought: parsed.thought, tools: parsed.tools };
      }
      if (normalizedTool) {
        const parsedArgs = parsed.args ?? parsed.input ?? {};
        return { tool: normalizedTool, args: parsedArgs, thought: parsed.thought };
      }
      return parsed;
    }
    return null;
  }
  async setLLMConfig(next) {
    const merged = { ...this.llmConfig, ...next ?? {} };
    if (!merged.apiKey && merged.provider === "nvidia") merged.apiKey = process.env.NVIDIA_API_KEY ?? null;
    this.llmConfig = merged;
    if (typeof (next == null ? void 0 : next.modelId) === "string" && next.modelId.trim()) this.currentModelId = next.modelId.trim();
    this.model = this.createModel(this.currentModelId);
    this.orchestrator = new WorkflowOrchestrator(this.model);
  }
  getLLMConfig() {
    const { apiKey: _unusedApiKey, ...rest } = this.llmConfig;
    return rest;
  }
  toggleActionsPolicy(enabled) {
    this.useActionsPolicy = enabled;
    this.setModel(enabled ? "actions-policy-v1" : "llama-3.1-70b");
  }
  isActionsPolicyEnabled() {
    return this.useActionsPolicy;
  }
  setAgentMode(mode) {
    this.agentMode = mode;
  }
  getAgentMode() {
    return this.agentMode;
  }
  setPermissionMode(mode) {
    this.permissionMode = mode;
  }
  getPermissionMode() {
    return this.permissionMode;
  }
  isYoloMode() {
    return this.agentMode === "do" && this.permissionMode === "yolo";
  }
  isManualMode() {
    return this.permissionMode === "manual";
  }
  createModel(modelId) {
    const cfg = AVAILABLE_MODELS.find((m) => m.id === modelId) || AVAILABLE_MODELS[0];
    return new ChatOpenAI({
      configuration: { baseURL: this.llmConfig.baseUrl, apiKey: this.llmConfig.apiKey ?? "local" },
      modelName: cfg.modelName,
      temperature: cfg.temperature,
      maxTokens: cfg.maxTokens,
      streaming: false,
      modelKwargs: { response_format: { type: "json_object" }, ...cfg.extraBody ?? {} }
    });
  }
  createModelForRouting(tier) {
    return new ChatOpenAI({
      configuration: { baseURL: this.llmConfig.baseUrl, apiKey: this.llmConfig.apiKey ?? "local" },
      modelName: tier.modelName,
      temperature: tier.temperature,
      maxTokens: tier.maxTokens,
      streaming: false,
      modelKwargs: { response_format: { type: "json_object" } }
    });
  }
  setModel(modelId) {
    this.currentModelId = modelId;
    this.model = this.createModel(modelId);
  }
  resetConversation() {
    this.conversationHistory = [];
    this.summaries = [];
  }
  trimConversationHistory() {
    if (this.conversationHistory.length > _AgentService.MAX_HISTORY_MESSAGES) {
      this.conversationHistory = this.conversationHistory.slice(-50);
    }
  }
  async maybeSummarize() {
    if (this.conversationHistory.length > _AgentService.SUMMARY_EVERY) await this.summarizeBlock();
  }
  async summarizeBlock() {
    const blockSize = _AgentService.SUMMARY_BLOCK_SIZE;
    if (this.conversationHistory.length < blockSize) return;
    const toSummarize = this.conversationHistory.slice(0, blockSize);
    const messagesText = toSummarize.map((m) => {
      const role = m._getType();
      const content = typeof m.content === "string" ? m.content : JSON.stringify(m.content);
      const truncated = content.length > 500 ? content.substring(0, 500) + "..." : content;
      return `[${role}]: ${truncated}`;
    }).join("\n\n");
    const summaryPrompt = new SystemMessage(TOON_SUMMARY_PROMPT_TEMPLATE + messagesText);
    try {
      const summarizerModel = this.createModel("llama-3.1-70b");
      const response = await summarizerModel.invoke([summaryPrompt]);
      const rawSummary = typeof response.content === "string" ? response.content : JSON.stringify(response.content);
      const rawParsed = safeParseTOON(rawSummary, { meta: { version: "1.0", timestamp: (/* @__PURE__ */ new Date()).toISOString(), messagesCompressed: blockSize }, conversationSummary: rawSummary });
      safeValidateToonSummary(rawParsed) ?? createToonSummary(rawSummary, blockSize);
      const summaryMessage = new SystemMessage(`[SUMMARY] ${rawSummary}`);
      this.summaries.push(summaryMessage);
      this.conversationHistory = this.conversationHistory.slice(blockSize);
      console.log(`[AgentService] Summarized ${blockSize} messages into TOON format. Remaining: ${this.conversationHistory.length}`);
    } catch (e) {
      console.error("[AgentService] Summarization failed:", e);
      this.conversationHistory = this.conversationHistory.slice(blockSize);
    }
  }
  buildMessagesWithSummaries(systemPrompt) {
    return [systemPrompt, ...this.summaries, ...this.conversationHistory];
  }
  setStepHandler(handler) {
    this.onStep = handler;
  }
  setTokenHandler(handler) {
    this.onToken = handler;
  }
  clearStepHandler() {
    this.onStep = void 0;
    this.onToken = void 0;
  }
  emitStep(type, content, metadata) {
    if (this.onStep) {
      const runId = agentRunContext.getRunId() ?? void 0;
      this.onStep({ type, content, metadata: { ...metadata, ts: (/* @__PURE__ */ new Date()).toISOString(), runId } });
    }
  }
  // @ts-ignore Reserved for future streaming support
  _emitToken(token) {
    if (this.onToken) this.onToken(token);
  }
  getCurrentModelId() {
    return this.currentModelId;
  }
  async chat(userMessage, browserContext) {
    if (this.agentMode === "chat") return this.chatOnly(userMessage);
    if (this.agentMode === "read") return this.readOnly(userMessage, browserContext);
    return this.doMode(userMessage, browserContext);
  }
  async chatOnly(userMessage) {
    const safeUserMessage = this.redactSecrets(userMessage);
    const chatPrompt = new SystemMessage(`You are a helpful assistant. You are in CHAT mode - you cannot access the browser or use any tools. Just have a helpful conversation with the user. Respond naturally without JSON formatting.`);
    this.conversationHistory.push(new HumanMessage(safeUserMessage));
    this.trimConversationHistory();
    try {
      const response = await this.model.invoke([chatPrompt, ...this.conversationHistory]);
      const content = String(response.content);
      this.conversationHistory.push(new AIMessage(content));
      this.trimConversationHistory();
      return content;
    } catch (e) {
      return `Error: ${e instanceof Error ? e.message : String(e)}`;
    }
  }
  async readOnly(userMessage, browserContext) {
    const safeUserMessage = this.redactSecrets(userMessage);
    let context = browserContext || "Current browser state: No context provided";
    context = this.redactSecrets(context);
    const readPrompt = new SystemMessage(`You are a helpful assistant integrated into a browser. You are in READ mode - you can see what the user sees on their browser, but you CANNOT take any actions or use any tools.
Current browser state:
${context}
You can answer questions about what's on the page, explain content, summarize information, or help the user understand what they're looking at. But you cannot click, type, navigate, or modify anything. Respond naturally without JSON formatting.`);
    this.conversationHistory.push(new HumanMessage(safeUserMessage));
    this.trimConversationHistory();
    try {
      const response = await this.model.invoke([readPrompt, ...this.conversationHistory]);
      const content = String(response.content);
      this.conversationHistory.push(new AIMessage(content));
      this.trimConversationHistory();
      return content;
    } catch (e) {
      return `Error: ${e instanceof Error ? e.message : String(e)}`;
    }
  }
  async doMode(userMessage, browserContext) {
    var _a3;
    const runId = agentRunContext.getRunId() ?? v4$2();
    const runStartedAt = Date.now();
    const langChainTools = toolRegistry.toLangChainTools();
    let usedBrowserTools = false;
    let parseFailures = 0;
    let loopAlertCount = 0;
    let pendingErrorForReflection = null;
    let verificationFailures = 0;
    let stepCount = 0;
    const toolsUsed = [];
    let lastTool = null;
    let lastToolResult = null;
    let lastThought = null;
    let speculativeHits = 0;
    let speculativeMisses = 0;
    let preferredTabId = null;
    telemetryService.emit({ eventId: v4$2(), runId, ts: (/* @__PURE__ */ new Date()).toISOString(), type: "agent_run_start", data: { userMessage: userMessage.slice(0, 100), model: this.currentModelId } });
    auditService.log({ actor: "agent", action: "agent_run_start", details: { runId, userMessage: userMessage.slice(0, 100) }, status: "pending" });
    const activeUrl = (() => {
      try {
        return browserTargetService.getActiveWebContents().getURL();
      } catch {
        return void 0;
      }
    })();
    const intentClassification = classifyIntent(userMessage, activeUrl);
    this.emitStep("thought", `Intent: ${intentClassification.type} (${Math.round(intentClassification.confidence * 100)}% confidence) - ${intentClassification.reason}`, { phase: "intent_classification", intent: intentClassification });
    const routingDecision = modelRouter.route(userMessage, browserContext);
    const selectedModelId = routingDecision.selectedModel.id;
    const isTrivialOrSimple = [TaskComplexity.TRIVIAL, TaskComplexity.SIMPLE].includes(routingDecision.classification.complexity);
    let currentModelForRun = this.createModelForRouting(routingDecision.selectedModel);
    this.emitStep("thought", `ðŸŽ¯ Model: ${routingDecision.selectedModel.name} (${routingDecision.classification.complexity} task, ${Math.round(routingDecision.classification.confidence * 100)}% confidence)`, {
      phase: "model_routing",
      model: selectedModelId,
      complexity: routingDecision.classification.complexity,
      confidence: routingDecision.classification.confidence
    });
    try {
      const directNavUrl = this.extractDirectNavigationUrl(userMessage);
      if (directNavUrl && isTrivialOrSimple) {
        const navTool = langChainTools.find((t2) => t2.name === "browser_navigate");
        if (navTool) {
          try {
            const navCheck = shouldNavigateActiveTab(userMessage, directNavUrl, activeUrl);
            let tabId = null;
            if (!navCheck.allowNavigation) {
              const targetToken = (() => {
                try {
                  const host = new URL(directNavUrl).hostname.toLowerCase();
                  if (!host) return null;
                  if (host === "localhost") return "localhost";
                  const parts = host.split(".").filter(Boolean);
                  const cleaned = parts[0] === "www" ? parts.slice(1) : parts;
                  if (cleaned.length >= 2) return cleaned[cleaned.length - 2];
                  return cleaned[0] ?? null;
                } catch {
                  return null;
                }
              })();
              if (targetToken) {
                tabId = browserTargetService.getMostRecentTabForDomainToken(targetToken);
              }
              if (!tabId) {
                tabId = await agentTabOpenService.openAgentTab({
                  url: directNavUrl,
                  background: Boolean(intentClassification.openInBackground),
                  agentCreated: true
                });
              } else if (!intentClassification.openInBackground) {
                const win2 = BrowserWindow$1.getAllWindows()[0];
                if (win2) win2.webContents.send("browser:activate-tab", { tabId });
              }
            }
            const toolArgs = { url: directNavUrl, ...tabId ? { tabId } : {} };
            stepCount++;
            toolsUsed.push(navTool.name);
            this.emitStep("action", `Executing ${navTool.name}`, { tool: navTool.name, args: toolArgs, phase: "direct_nav_fast_path" });
            auditService.log({ actor: "agent", action: "tool_execution", details: { runId, tool: navTool.name, args: toolArgs }, status: "pending" });
            const toolResult = await navTool.invoke(toolArgs);
            const resStr = String(toolResult);
            const ok = !resStr.toLowerCase().startsWith("failed");
            this.emitStep("observation", resStr, { tool: navTool.name, result: resStr, ok, phase: "direct_nav_fast_path", tabId: tabId ?? void 0 });
            usedBrowserTools = true;
            telemetryService.emit({ eventId: v4$2(), runId, ts: (/* @__PURE__ */ new Date()).toISOString(), type: "agent_run_end", data: { success: ok, via: "direct_nav_fast_path", stepCount, durationMs: Date.now() - runStartedAt } });
            auditService.log({ actor: "agent", action: "agent_run_complete", details: { runId, stepCount, toolsUsed }, status: ok ? "success" : "failure" });
            return resStr;
          } catch (e) {
            const errMsg = e instanceof Error ? e.message : String(e);
            await this.logFailure(runId, userMessage, errMsg, stepCount, toolsUsed, Date.now() - runStartedAt);
            telemetryService.emit({ eventId: v4$2(), runId, ts: (/* @__PURE__ */ new Date()).toISOString(), type: "agent_run_end", data: { success: false, reason: "direct_nav_error", durationMs: Date.now() - runStartedAt } });
            auditService.log({ actor: "agent", action: "agent_run_error", details: { runId, error: errMsg }, status: "failure" });
            return `Error: ${errMsg}`;
          }
        }
      }
      let context = browserContext || "Current browser state: No context provided";
      context = this.redactSecrets(context);
      const safeUserMessage = this.redactSecrets(userMessage);
      const shouldLoadSelectors = context.includes("localhost:3000") || safeUserMessage.toLowerCase().includes("aerocore");
      const selectors = shouldLoadSelectors ? await selectorDiscoveryService.discoverSelectors() : /* @__PURE__ */ new Map();
      const selectorContext = shouldLoadSelectors ? Array.from(selectors.entries()).map(([p, s]) => `${p}: ${s.map((x) => x.testId).join(",")}`).join("\n") : "";
      const withTimeout = async (promise, timeoutMs, fallback, label) => {
        let timer = null;
        let timedOut = false;
        const timeoutPromise = new Promise((resolve) => {
          timer = setTimeout(() => {
            timedOut = true;
            resolve(fallback);
          }, timeoutMs);
        });
        const result2 = await Promise.race([promise, timeoutPromise]);
        if (timer) clearTimeout(timer);
        if (timedOut) {
          this.emitStep("observation", `${label} timed out after ${timeoutMs}ms. Continuing.`, { phase: "timeout", ok: false, step: label });
        }
        return result2;
      };
      this.systemPrompt = new SystemMessage(`<role>You are a helpful enterprise assistant integrated into a browser. Your goal is to help users complete tasks by using tools effectively and safely.</role>
<tool_calling>You MUST respond ONLY with a single JSON object. JSON schema: { "thought": "brief reasoning", "tool": "tool_name", "args": { ... } } Final response: { "thought": "brief completion summary", "tool": "final_response", "args": { "message": "your message" } }</tool_calling>
<strategy>API-FIRST, BROWSER-FALLBACK: - Try API tools first. - If api_web_search returns status="browser_required", immediately use browser_navigate. - Use DuckDuckGo for browser searches.</strategy>
<browser_primitives>- Always call browser_observe before interactions. - From browser_observe, prefer CSS matches=1, then XPath matches=1, then click_text.</browser_primitives>
<terminal_power>For complex page interactions (data extraction, semantic element finding, form filling, or when selectors fail), use browser_terminal_command with a natural language description. It generates and executes robust JavaScript automatically.</terminal_power>
<known_apps>
- AeroCore: http://localhost:3000/aerocore - Enterprise aviation management suite
  - Admin: http://localhost:3000/aerocore/admin (pilot management, settings)
  - Dispatch: http://localhost:3000/aerocore/dispatch (flight scheduling)
  - Fleet: http://localhost:3000/aerocore/fleet (aircraft management)
  - Cargo: http://localhost:3000/aerocore/cargo (shipment tracking)
  - Workforce: http://localhost:3000/aerocore/hr (employee management)
When user mentions "AeroCore" or any of its modules, navigate to the corresponding localhost:3000 URL.
</known_apps>
<mock_saas_ground_truth>Selectors discovered from source:
${selectorContext}</mock_saas_ground_truth>
<workflow_orchestrator>For complex tasks, use WorkflowOrchestrator to manage multi-step plans.</workflow_orchestrator>
Available tools:
${langChainTools.map((t2) => `- ${t2.name}: ${t2.description}`).join("\n")}`);
      this.conversationHistory.push(new HumanMessage(`[${context}]

User request: ${safeUserMessage}`));
      this.trimConversationHistory();
      await this.maybeSummarize();
      const messages = this.buildMessagesWithSummaries(this.systemPrompt);
      if (!isTrivialOrSimple && userMessage.length > 10) {
        const workflowHit = await withTimeout(
          taskKnowledgeService.findNearest(userMessage, 0.85),
          8e3,
          null,
          "Workflow lookup"
        ).catch(() => null);
        if (workflowHit && workflowHit.skill.isWorkflow) {
          this.emitStep("thought", `Executing workflow: "${workflowHit.skill.name}".`);
          const result2 = await this.orchestrator.execute(workflowHit.skill.steps.map((s) => ({ id: s.id, name: s.name || s.tool, tool: s.tool, args: s.args || {}, dependencies: s.dependencies || [], status: "pending" })), (type, content, metadata) => this.emitStep(type, content, metadata));
          if (result2.success) {
            telemetryService.emit({ eventId: v4$2(), runId, ts: (/* @__PURE__ */ new Date()).toISOString(), type: "agent_run_end", data: { success: true, via: "workflow_hit", durationMs: Date.now() - runStartedAt } });
            return `Completed via workflow ${workflowHit.skill.name}`;
          }
        }
        const workflowTasks = await withTimeout(
          this.orchestrator.plan(userMessage, context),
          15e3,
          [],
          "Workflow planning"
        ).catch(() => []);
        if (workflowTasks.length > 1) {
          this.emitStep("thought", `Planned ${workflowTasks.length} steps. Executing...`);
          const result2 = await this.orchestrator.execute(workflowTasks, (type, content, metadata) => this.emitStep(type, content, metadata));
          if (result2.success) {
            try {
              await taskKnowledgeService.addSkill({ name: `workflow_${v4$2().slice(0, 8)}`, description: userMessage, domain: context.includes("localhost:3000") ? "localhost:3000" : "unknown", isWorkflow: true, steps: result2.tasks.map((t2) => ({ action: "workflow_task", id: t2.id, name: t2.name, tool: t2.tool, args: t2.args, dependencies: t2.dependencies })), tags: ["workflow"] });
            } catch {
            }
            telemetryService.emit({ eventId: v4$2(), runId, ts: (/* @__PURE__ */ new Date()).toISOString(), type: "agent_run_end", data: { success: true, via: "workflow_planned", durationMs: Date.now() - runStartedAt } });
            return `Workflow completed successfully.`;
          }
        }
      }
      for (let i2 = 0; i2 < 15; i2++) {
        const loopAlert = agentRunContext.consumeLoopAlert();
        if (loopAlert) {
          loopAlertCount++;
          const loopMsg = `Loop detected: ${loopAlert.kind} repeated ${loopAlert.count} times.`;
          this.emitStep("observation", loopMsg);
          pendingErrorForReflection = loopMsg;
          if (loopAlertCount >= 2) {
            await this.logFailure(runId, userMessage, "Loop detected", stepCount, toolsUsed, Date.now() - runStartedAt);
            telemetryService.emit({ eventId: v4$2(), runId, ts: (/* @__PURE__ */ new Date()).toISOString(), type: "agent_run_end", data: { success: false, reason: "loop_detected", durationMs: Date.now() - runStartedAt } });
            return "Loop detected. Please provide guidance.";
          }
        }
        if (pendingErrorForReflection) {
          messages.push(new SystemMessage(`Previous error: ${pendingErrorForReflection}. Reflect and choose a different path.`));
          pendingErrorForReflection = null;
        }
        const timeoutMs = 6e4;
        let response;
        try {
          const timeoutPromise = new Promise((_, reject) => setTimeout(() => reject(new Error("LLM timeout")), timeoutMs));
          response = await Promise.race([currentModelForRun.invoke(messages), timeoutPromise]);
        } catch (err) {
          await this.logFailure(runId, userMessage, "Request timed out", stepCount, toolsUsed, Date.now() - runStartedAt);
          telemetryService.emit({ eventId: v4$2(), runId, ts: (/* @__PURE__ */ new Date()).toISOString(), type: "agent_run_end", data: { success: false, reason: "timeout", durationMs: Date.now() - runStartedAt } });
          return "Request timed out.";
        }
        const content = response.content.replace(/<think>[\s\S]*?<\/think>/gi, "").trim();
        const action = this.parseToolCall(content);
        if (!action) {
          if (++parseFailures >= 3) {
            await this.logFailure(runId, userMessage, "Parse failures", stepCount, toolsUsed, Date.now() - runStartedAt);
            telemetryService.emit({ eventId: v4$2(), runId, ts: (/* @__PURE__ */ new Date()).toISOString(), type: "agent_run_end", data: { success: false, reason: "parse_failures", durationMs: Date.now() - runStartedAt } });
            return "Failed to generate valid commands.";
          }
          messages.push(new AIMessage(content));
          messages.push(new SystemMessage("Error: Invalid JSON. Output ONLY valid JSON."));
          continue;
        }
        if (action.thought) this.emitStep("thought", action.thought);
        if (action.tool === "final_response") {
          let finalMessage = action.args.message || content;
          if (usedBrowserTools) {
            const verification = await this.verifyTaskSuccess(userMessage, String(messages[messages.length - 1].content));
            if (!verification.success) {
              verificationFailures += 1;
              if (verificationFailures <= 1) {
                messages.push(new SystemMessage(`Verification failed: ${verification.reason}. Please double check.`));
                continue;
              }
              this.emitStep("observation", `Verification failed twice (${verification.reason}). Returning best-effort response.`, { ok: false, phase: "verification_soft_fail" });
              finalMessage = `${finalMessage}

(Verification warning: ${verification.reason})`;
            }
          }
          this.conversationHistory.push(new AIMessage(JSON.stringify(action)));
          telemetryService.emit({ eventId: v4$2(), runId, ts: (/* @__PURE__ */ new Date()).toISOString(), type: "agent_run_end", data: { success: true, via: "final_response", stepCount, durationMs: Date.now() - runStartedAt } });
          auditService.log({ actor: "agent", action: "agent_run_complete", details: { runId, stepCount, toolsUsed }, status: "success" });
          return finalMessage;
        }
        const tool2 = langChainTools.find((t2) => t2.name === action.tool);
        if (tool2) {
          const navArgs = action.args;
          if (tool2.name === "browser_navigate" && (navArgs == null ? void 0 : navArgs.url)) {
            const navCheck = shouldNavigateActiveTab(userMessage, navArgs.url, activeUrl);
            if (!navCheck.allowNavigation) {
              const targetUrl = String(navArgs.url);
              const targetToken = (() => {
                try {
                  const host = new URL(targetUrl).hostname.toLowerCase();
                  if (!host) return null;
                  if (host === "localhost") return "localhost";
                  const parts = host.split(".").filter(Boolean);
                  const cleaned = parts[0] === "www" ? parts.slice(1) : parts;
                  if (cleaned.length >= 2) return cleaned[cleaned.length - 2];
                  return cleaned[0] ?? null;
                } catch {
                  return null;
                }
              })();
              let tabId = null;
              if (targetToken) {
                tabId = browserTargetService.getMostRecentTabForDomainToken(targetToken);
              }
              if (!tabId) {
                tabId = await agentTabOpenService.openAgentTab({
                  url: targetUrl,
                  background: Boolean(intentClassification.openInBackground),
                  agentCreated: true
                });
              } else {
                if (!intentClassification.openInBackground) {
                  const win2 = BrowserWindow$1.getAllWindows()[0];
                  if (win2) win2.webContents.send("browser:activate-tab", { tabId });
                }
              }
              preferredTabId = tabId;
              const toolResult = await tool2.invoke({ ...action.args, tabId });
              const resStr = String(toolResult);
              this.emitStep("observation", resStr, { tool: tool2.name, result: resStr, ok: true, tabId });
              usedBrowserTools = true;
              messages.push(new AIMessage(content));
              messages.push(new SystemMessage(`Tool Output:
${resStr}`));
              continue;
            }
          }
          const TAB_ID_TOOLS = /* @__PURE__ */ new Set([
            "browser_observe",
            "browser_navigate",
            "browser_scroll",
            "browser_press_key",
            "browser_wait_for_selector",
            "browser_wait_for_url",
            "browser_focus",
            "browser_clear",
            "browser_click",
            "browser_type",
            "browser_get_text",
            "browser_find_text",
            "browser_wait_for_text",
            "browser_wait_for_text_in",
            "browser_select",
            "browser_click_text"
          ]);
          const toolArgs = (() => {
            const args = { ...action.args };
            if (preferredTabId && TAB_ID_TOOLS.has(tool2.name) && args.tabId == null) {
              args.tabId = preferredTabId;
            }
            return args;
          })();
          stepCount++;
          toolsUsed.push(tool2.name);
          this.emitStep("action", `Executing ${tool2.name}`, { tool: tool2.name, args: toolArgs });
          auditService.log({ actor: "agent", action: "tool_execution", details: { runId, tool: tool2.name, args: toolArgs }, status: "pending" });
          const toolStartedAt = Date.now();
          try {
            const speculativeMatch = speculativeExecutor.getMatchingSpeculation(
              tool2.name,
              action.args
            );
            let resStr;
            let durationMs;
            if (speculativeMatch && speculativeMatch.result) {
              resStr = speculativeMatch.result;
              durationMs = 0;
              speculativeHits++;
              this.emitStep("thought", `âš¡ Speculative hit! Saved ${speculativeMatch.executionTimeMs}ms`, {
                phase: "speculative_hit",
                savedMs: speculativeMatch.executionTimeMs
              });
              telemetryService.emit({ eventId: v4$2(), runId, ts: (/* @__PURE__ */ new Date()).toISOString(), type: "tool_call_end", name: tool2.name, data: { success: true, durationMs: 0, speculative: true, savedMs: speculativeMatch.executionTimeMs } });
            } else {
              if (speculativeMatch) speculativeMisses++;
              const toolResult = await tool2.invoke(toolArgs);
              resStr = String(toolResult);
              durationMs = Date.now() - toolStartedAt;
              telemetryService.emit({ eventId: v4$2(), runId, ts: (/* @__PURE__ */ new Date()).toISOString(), type: "tool_call_end", name: tool2.name, data: { success: true, durationMs } });
            }
            this.emitStep("observation", resStr, { tool: tool2.name, result: resStr, durationMs, ok: true });
            if (tool2.name.startsWith("browser_")) usedBrowserTools = true;
            messages.push(new AIMessage(content));
            messages.push(new SystemMessage(`Tool Output:
${resStr}`));
            lastTool = tool2.name;
            lastToolResult = resStr;
            lastThought = action.thought || null;
            const predictionContext = {
              lastTool,
              lastToolResult,
              lastThought,
              userMessage: safeUserMessage,
              browserUrl: context.includes("URL:") ? ((_a3 = context.match(/URL:\s*([^\n]+)/)) == null ? void 0 : _a3[1]) || null : null,
              browserTitle: null,
              visibleElements: [],
              conversationHistory: [],
              pendingGoal: safeUserMessage
            };
            const prediction = speculativeExecutor.predict(predictionContext);
            if (prediction) {
              this.emitStep("thought", `ðŸ”® Speculating: ${prediction.tool} (${Math.round(prediction.confidence * 100)}% confidence)`, {
                phase: "speculative_predict",
                tool: prediction.tool,
                confidence: prediction.confidence
              });
              speculativeExecutor.executeSpeculative(prediction).catch(() => {
              });
            }
          } catch (e) {
            const durationMs = Date.now() - toolStartedAt;
            const errMsg = e instanceof Error ? e.message : String(e);
            telemetryService.emit({ eventId: v4$2(), runId, ts: (/* @__PURE__ */ new Date()).toISOString(), type: "tool_call_end", name: tool2.name, data: { success: false, error: errMsg, durationMs } });
            this.emitStep("observation", `Tool Error: ${errMsg}`, { tool: tool2.name, errorMessage: errMsg, durationMs, ok: false });
            messages.push(new AIMessage(content));
            messages.push(new SystemMessage(`Tool Error: ${errMsg}`));
            lastTool = tool2.name;
            lastToolResult = `Error: ${errMsg}`;
          }
        } else {
          messages.push(new AIMessage(content));
          messages.push(new SystemMessage(`Error: Tool ${action.tool} not found.`));
        }
      }
      const result = "Maximum steps reached.";
      await this.logFailure(runId, userMessage, result, stepCount, toolsUsed, Date.now() - runStartedAt);
      telemetryService.emit({ eventId: v4$2(), runId, ts: (/* @__PURE__ */ new Date()).toISOString(), type: "agent_run_end", data: { success: false, reason: "max_steps", durationMs: Date.now() - runStartedAt } });
      return result;
    } catch (error) {
      const errMsg = error instanceof Error ? error.message : String(error);
      const result = `Error: ${errMsg}`;
      await this.logFailure(runId, userMessage, result, stepCount, toolsUsed, Date.now() - runStartedAt);
      telemetryService.emit({ eventId: v4$2(), runId, ts: (/* @__PURE__ */ new Date()).toISOString(), type: "agent_run_end", data: { success: false, reason: "exception", error: errMsg, durationMs: Date.now() - runStartedAt } });
      auditService.log({ actor: "agent", action: "agent_run_error", details: { runId, error: errMsg }, status: "failure" });
      return result;
    }
  }
  async logFailure(runId, userMessage, result, stepCount, toolsUsed, durationMs) {
    try {
      const logDir = path__default$1.join(process.cwd(), "tuning_logs");
      await fs$3.mkdir(logDir, { recursive: true });
      const logFile = path__default$1.join(logDir, `failure_${runId}_${Date.now()}.json`);
      const logData = {
        runId,
        timestamp: (/* @__PURE__ */ new Date()).toISOString(),
        userMessage,
        result,
        stepCount,
        toolsUsed,
        durationMs,
        model: this.currentModelId
      };
      await fs$3.writeFile(logFile, JSON.stringify(logData, null, 2));
    } catch (e) {
      console.error("[AgentService] Failed to write failure log:", e);
    }
  }
  async verifyTaskSuccess(goal, lastObservation) {
    const prompt = new SystemMessage(`Verify goal: ${goal}. Obs: ${lastObservation}. JSON output {success, reason}.`);
    try {
      const res = await this.model.invoke([prompt]);
      const json = this.extractJsonObject(String(res.content));
      if (json) return JSON.parse(json);
      return { success: false, reason: "Invalid JSON from verifier" };
    } catch {
      return { success: false, reason: "Error during verification" };
    }
  }
};
__publicField2(_AgentService, "MAX_HISTORY_MESSAGES", 50);
__publicField2(_AgentService, "SUMMARY_EVERY", 30);
__publicField2(_AgentService, "SUMMARY_BLOCK_SIZE", 15);
let AgentService = _AgentService;
const agentService = new AgentService();
const FILE_NAME = "saved_plans.json";
class PlanMemory {
  constructor() {
    __publicField2(this, "filePath");
    __publicField2(this, "plans", []);
    const userDataDir = path__default$1.join(os$1.homedir(), ".enterprise_agent");
    this.filePath = path__default$1.join(userDataDir, FILE_NAME);
    fs$3.mkdir(userDataDir, { recursive: true }).catch(() => void 0);
    this.load();
  }
  async load() {
    try {
      const data = await fs$3.readFile(this.filePath, "utf-8");
      this.plans = JSON.parse(data);
    } catch {
      this.plans = [];
    }
  }
  async persist() {
    await fs$3.writeFile(this.filePath, JSON.stringify(this.plans, null, 2), "utf-8");
  }
  async getPlans() {
    await this.load();
    return [...this.plans];
  }
  async savePlan(taskId, plan2) {
    this.plans = this.plans.filter((p) => p.id !== taskId);
    this.plans.push({ id: taskId, ts: Date.now(), plan: plan2 });
    await this.persist();
  }
  async deletePlan(taskId) {
    this.plans = this.plans.filter((p) => p.id !== taskId);
    await this.persist();
  }
}
class BrowserAutomationService {
  constructor() {
    __publicField2(this, "mockSaasRoutesCache", null);
    __publicField2(this, "observeCache", /* @__PURE__ */ new Map());
    __publicField2(this, "attachedWebContentsIds", /* @__PURE__ */ new Set());
    this.setupWebContentsInvalidation();
    this.registerTools();
  }
  setupWebContentsInvalidation() {
    try {
      for (const wc of webContents$1.getAllWebContents()) {
        this.attachWebContentsListeners(wc);
      }
    } catch {
    }
    try {
      app$1.on("web-contents-created", (_event, wc) => {
        this.attachWebContentsListeners(wc);
      });
    } catch {
    }
  }
  attachWebContentsListeners(wc) {
    try {
      if (!wc || wc.isDestroyed()) return;
      if (this.attachedWebContentsIds.has(wc.id)) return;
      this.attachedWebContentsIds.add(wc.id);
      const invalidate = () => this.invalidateCache(wc.id);
      wc.on("did-start-navigation", invalidate);
      wc.on("did-navigate", invalidate);
      wc.on("did-navigate-in-page", invalidate);
      wc.on("dom-ready", invalidate);
      wc.on("destroyed", () => {
        this.invalidateCache(wc.id);
        this.attachedWebContentsIds.delete(wc.id);
      });
    } catch {
    }
  }
  invalidateCache(webContentsId) {
    this.observeCache.delete(webContentsId);
  }
  async getDomVersion(target) {
    try {
      const v = await target.executeJavaScript(
        `(() => {
          const w = window;
          if (typeof w.__enterprise_observe_dom_version !== 'number') {
            w.__enterprise_observe_dom_version = 0;
          }
          if (!w.__enterprise_observe_dom_observer) {
            const bump = () => { w.__enterprise_observe_dom_version += 1; };
            const obs = new MutationObserver(() => bump());
            const root = document.documentElement || document.body;
            if (root) {
              obs.observe(root, { subtree: true, childList: true, attributes: true, characterData: true });
            }
            w.__enterprise_observe_dom_observer = obs;
          }
          return w.__enterprise_observe_dom_version;
        })()`,
        true
      );
      return Number(v) || 0;
    } catch {
      return 0;
    }
  }
  async delay(ms) {
    await new Promise((resolve) => setTimeout(resolve, ms));
  }
  async getMockSaasRoutes() {
    const now = Date.now();
    if (this.mockSaasRoutesCache && now - this.mockSaasRoutesCache.loadedAt < 1e4) {
      return this.mockSaasRoutesCache.routes;
    }
    const defaultRoutes = /* @__PURE__ */ new Set(["/", "/jira", "/confluence", "/trello"]);
    const candidates = [
      path__default$1.resolve(process.cwd(), "mock-saas", "src", "App.tsx"),
      path__default$1.resolve(process.cwd(), "..", "mock-saas", "src", "App.tsx"),
      path__default$1.resolve(process.cwd(), "..", "..", "mock-saas", "src", "App.tsx")
    ];
    let appTsx = null;
    for (const p of candidates) {
      try {
        const stat = await fs$3.stat(p);
        if (stat.isFile()) {
          appTsx = p;
          break;
        }
      } catch {
      }
    }
    if (!appTsx) {
      this.mockSaasRoutesCache = { loadedAt: now, routes: defaultRoutes };
      return defaultRoutes;
    }
    try {
      const raw = await fs$3.readFile(appTsx, "utf8");
      const routes = /* @__PURE__ */ new Set();
      const re2 = /<Route\s+(?:path|element)\s*=\s*["']([^"']+)["']/g;
      let match;
      while (match = re2.exec(raw)) {
        let route = match[1];
        if (route.endsWith("/*")) {
          route = route.replace("/*", "");
          if (route === "/aerocore") {
            routes.add("/aerocore/admin");
            routes.add("/aerocore/dispatch");
            routes.add("/aerocore/fleet");
            routes.add("/aerocore/security");
            routes.add("/aerocore/hr");
            routes.add("/aerocore/cargo");
            routes.add("/aerocore/data");
          }
        }
        routes.add(route);
      }
      const final = routes.size > 0 ? routes : defaultRoutes;
      this.mockSaasRoutesCache = { loadedAt: now, routes: final };
      return final;
    } catch {
      this.mockSaasRoutesCache = { loadedAt: now, routes: defaultRoutes };
      return defaultRoutes;
    }
  }
  async getTarget(tabId) {
    if (tabId) {
      const ready = await browserTargetService.waitForTab(tabId, 5e3);
      const target = browserTargetService.getWebContents(tabId);
      if (ready && target) return target;
      throw new Error(`No webContents registered for tabId ${tabId}`);
    }
    return browserTargetService.getActiveWebContents();
  }
  async waitForSelector(target, selector, timeoutMs = 5e3) {
    const startedAt = Date.now();
    while (Date.now() - startedAt < timeoutMs) {
      const found = await target.executeJavaScript(
        `(() => {
          const sel = ${JSON.stringify(selector)};
          const s = String(sel ?? '').trim();
          const isXpath = s.startsWith('xpath=') || s.startsWith('//') || s.startsWith('/') || s.startsWith('(');
          if (isXpath) {
            const xp = s.startsWith('xpath=') ? s.slice(6) : s;
            try {
              const node = document.evaluate(
                xp,
                document,
                null,
                XPathResult.FIRST_ORDERED_NODE_TYPE,
                null
              ).singleNodeValue;
              return Boolean(node);
            } catch {
              return false;
            }
          }
          return Boolean(document.querySelector(sel));
        })()`,
        true
      );
      if (found) return;
      await this.delay(100);
    }
    throw new Error(`Timeout waiting for selector: ${selector}`);
  }
  async querySelectorCount(target, selector) {
    const count = await target.executeJavaScript(
      `(() => {
        const sel = ${JSON.stringify(selector)};
        const s = String(sel ?? '').trim();
        const isXpath = s.startsWith('xpath=') || s.startsWith('//') || s.startsWith('/') || s.startsWith('(');
        if (isXpath) {
          const xp = s.startsWith('xpath=') ? s.slice(6) : s;
          try {
            const snap = document.evaluate(
              xp,
              document,
              null,
              XPathResult.ORDERED_NODE_SNAPSHOT_TYPE,
              null
            );
            return snap.snapshotLength || 0;
          } catch {
            return 0;
          }
        }
        return document.querySelectorAll(sel).length;
      })()`,
      true
    );
    return Number(count) || 0;
  }
  registerTools() {
    const observeSchema = object({
      scope: _enum(["main", "document"]).optional().describe("Where to look for elements (default: main)"),
      maxElements: number().optional().describe("Max interactive elements to return (default: 80)"),
      forceRefresh: boolean().optional().describe("Ignore cache and force a fresh observation"),
      tabId: string().optional().describe("Target tab ID for execution")
    });
    const observeTool = {
      name: "browser_observe",
      description: "Analyze the current page URL/title and return visible interactive elements. Defaults to main content to avoid header/nav noise. Caches results for performance; use forceRefresh to bypass.",
      schema: observeSchema,
      execute: async (args) => {
        const { scope, maxElements, forceRefresh, tabId } = observeSchema.parse(args ?? {});
        try {
          const target = await this.getTarget(tabId);
          const targetId = target.id;
          const currentUrl = target.getURL();
          const argsKey = JSON.stringify({ scope: scope ?? "main", maxElements: maxElements ?? 80 });
          const domVersion = await this.getDomVersion(target);
          if (!forceRefresh) {
            const cached2 = this.observeCache.get(targetId);
            if (cached2 && cached2.url === currentUrl && cached2.argsKey === argsKey && cached2.domVersion === domVersion && Date.now() - cached2.timestamp < 5e3) {
              const ageMs = Date.now() - cached2.timestamp;
              return JSON.stringify(
                {
                  ...cached2.data,
                  _meta: {
                    cached: true,
                    timestamp: cached2.timestamp,
                    ageMs,
                    url: cached2.url,
                    title: cached2.title,
                    domVersion: cached2.domVersion,
                    args: { scope: scope ?? "main", maxElements: maxElements ?? 80 }
                  }
                },
                null,
                2
              );
            }
          }
          const url = currentUrl;
          const title = await target.executeJavaScript(`document.title`, true);
          const elements = await target.executeJavaScript(
            `(() => {
                // ========== Semantic Selector Engine ==========
                // Implements robust, accessibility-first selector generation
                // with scoring based on attribute stability and semantic meaning.
                
                // ========== Scoring Configuration ==========
                const WEIGHTS = {
                  id: 100,           // IDs are typically unique and stable
                  testId: 95,        // data-testid is explicitly for testing
                  ariaLabel: 90,     // Accessibility labels are semantic and stable
                  ariaLabelledBy: 85,
                  role: 80,          // ARIA roles indicate semantic purpose
                  name: 75,          // Form element names are usually stable
                  placeholder: 70,   // Placeholders are user-facing, relatively stable
                  title: 65,         // Title attributes are semantic
                  href: 60,          // Links with specific hrefs
                  text: 55,          // Visible text (can change with i18n)
                  classes: 30,       // Classes are often dynamic/utility-based
                  nthOfType: 20,     // Positional selectors are fragile
                  xpath: 40,         // XPath fallback
                };

                const BONUSES = {
                  semanticAttribute: 15,
                  stableAttribute: 10,
                  shortSelector: 5,
                };

                // ========== Utility Functions ==========
                const escapeForSingleQuotes = (value) => {
                  if (typeof value !== 'string') return '';
                  return value.replace(/\\\\/g, '\\\\\\\\').replace(/'/g, "\\\\'");
                };

                const attrSelectorValue = (value) => {
                  if (typeof value !== 'string') return "''";
                  if (/^[a-zA-Z0-9_-]+$/.test(value)) return value;
                  return "'" + escapeForSingleQuotes(value) + "'";
                };

                const xpathLiteral = (value) => {
                  const v = String(value ?? '');
                  if (!v.includes("'")) return "'" + v + "'";
                  if (!v.includes('"')) return '"' + v + '"';
                  return 'concat(' + v.split("'").map((p) => "'" + p + "'").join(", "'", ") + ')';
                };

                // Detect dynamic/generated class names (CSS-in-JS, etc.)
                const isDynamicClass = (className) => {
                  const patterns = [
                    /^[a-z]{1,3}[A-Z][a-zA-Z0-9]{4,}$/,  // camelCase with hash
                    /^_[a-zA-Z0-9]{6,}$/,                 // Underscore prefix with hash
                    /^css-[a-zA-Z0-9]+$/,                 // Emotion/styled-components
                    /^sc-[a-zA-Z0-9]+$/,                  // styled-components
                    /^styles?_[a-zA-Z0-9]+__[a-zA-Z0-9]+/, // CSS Modules
                    /^[a-zA-Z0-9]{20,}$/,                 // Long random strings
                    /^[a-f0-9]{8,}$/i,                    // Hex hashes
                    /^\\d+$/,                              // Pure numbers
                  ];
                  return patterns.some(p => p.test(className));
                };

                const isVisible = (el) => {
                  if (!el || el.nodeType !== 1) return false;
                  const style = window.getComputedStyle(el);
                  if (!style) return false;
                  if (style.display === 'none' || style.visibility === 'hidden' || style.opacity === '0') return false;
                  if (style.pointerEvents === 'none') return false;
                  const rects = el.getClientRects();
                  if (!rects || rects.length === 0) return false;
                  const rect = el.getBoundingClientRect();
                  if (rect.width < 2 || rect.height < 2) return false;
                  const vw = window.innerWidth || 0;
                  const vh = window.innerHeight || 0;
                  const buffer = 40;
                  if (rect.bottom < -buffer || rect.top > vh + buffer) return false;
                  if (rect.right < -buffer || rect.left > vw + buffer) return false;
                  return true;
                };

                // ========== Selector Validation ==========
                const countCSS = (sel) => {
                  try { return document.querySelectorAll(sel).length; } catch { return 0; }
                };

                const countXPath = (xp) => {
                  try {
                    const snap = document.evaluate(xp, document, null, XPathResult.ORDERED_NODE_SNAPSHOT_TYPE, null);
                    return snap.snapshotLength || 0;
                  } catch { return 0; }
                };

                const unique = (sel) => {
                  try { return sel && document.querySelectorAll(sel).length === 1; } catch { return false; }
                };

                // ========== CSS Selector Generation ==========
                const generateCSSCandidates = (el) => {
                  const candidates = [];
                  const tag = (el.tagName || '').toLowerCase();

                  // Priority 1: ID (if not dynamic)
                  if (el.id && !isDynamicClass(el.id)) {
                    const sel = '#' + CSS.escape(el.id);
                    candidates.push({ kind: 'css', value: sel, score: WEIGHTS.id, strategy: 'id', confidence: 'high' });
                  }

                  // Priority 2: data-testid
                  const testId = el.getAttribute?.('data-testid') || el.getAttribute?.('data-test-id');
                  if (testId) {
                    candidates.push({ kind: 'css', value: '[data-testid=' + attrSelectorValue(testId) + ']', score: WEIGHTS.testId, strategy: 'testId', confidence: 'high' });
                  }

                  // Priority 3: aria-label (semantic)
                  const ariaLabel = el.getAttribute?.('aria-label');
                  if (ariaLabel) {
                    candidates.push({ kind: 'css', value: tag + '[aria-label=' + attrSelectorValue(ariaLabel) + ']', score: WEIGHTS.ariaLabel + BONUSES.semanticAttribute, strategy: 'ariaLabel', confidence: 'high' });
                  }

                  // Priority 4: role + aria-label combination
                  const role = el.getAttribute?.('role');
                  if (role) {
                    candidates.push({ kind: 'css', value: '[role=' + attrSelectorValue(role) + ']', score: WEIGHTS.role + BONUSES.semanticAttribute, strategy: 'role', confidence: 'medium' });
                    if (ariaLabel) {
                      candidates.push({ kind: 'css', value: '[role=' + attrSelectorValue(role) + '][aria-label=' + attrSelectorValue(ariaLabel) + ']', score: WEIGHTS.role + WEIGHTS.ariaLabel + BONUSES.semanticAttribute, strategy: 'role+ariaLabel', confidence: 'high' });
                    }
                  }

                  // Priority 5: name attribute
                  const name = el.getAttribute?.('name');
                  if (name) {
                    candidates.push({ kind: 'css', value: tag + '[name=' + attrSelectorValue(name) + ']', score: WEIGHTS.name + BONUSES.stableAttribute, strategy: 'name', confidence: 'high' });
                  }

                  // Priority 6: placeholder
                  const placeholder = el.getAttribute?.('placeholder');
                  if (placeholder) {
                    candidates.push({ kind: 'css', value: tag + '[placeholder=' + attrSelectorValue(placeholder) + ']', score: WEIGHTS.placeholder, strategy: 'placeholder', confidence: 'medium' });
                  }

                  // Priority 7: title
                  const title = el.getAttribute?.('title');
                  if (title) {
                    candidates.push({ kind: 'css', value: tag + '[title=' + attrSelectorValue(title) + ']', score: WEIGHTS.title, strategy: 'title', confidence: 'medium' });
                  }

                  // Priority 8: href for links
                  if (tag === 'a') {
                    const href = el.getAttribute?.('href');
                    if (href) {
                      candidates.push({ kind: 'css', value: 'a[href=' + attrSelectorValue(href) + ']', score: WEIGHTS.href + BONUSES.stableAttribute, strategy: 'href', confidence: 'high' });
                    }
                  }

                  // Priority 9: type + name/placeholder for inputs
                  const type = el.getAttribute?.('type');
                  if (type && ['input', 'button'].includes(tag)) {
                    if (name) {
                      candidates.push({ kind: 'css', value: tag + '[type=' + attrSelectorValue(type) + '][name=' + attrSelectorValue(name) + ']', score: WEIGHTS.name + 20, strategy: 'type+name', confidence: 'high' });
                    }
                    if (placeholder) {
                      candidates.push({ kind: 'css', value: tag + '[type=' + attrSelectorValue(type) + '][placeholder=' + attrSelectorValue(placeholder) + ']', score: WEIGHTS.placeholder + 15, strategy: 'type+placeholder', confidence: 'medium' });
                    }
                  }

                  // Priority 10: Stable classes only (filter out dynamic ones)
                  if (el.className && typeof el.className === 'string') {
                    const stableClasses = el.className.split(' ').filter(c => c.trim() && !isDynamicClass(c));
                    if (stableClasses.length > 0) {
                      const classSelector = stableClasses.slice(0, 2).map(c => '.' + CSS.escape(c)).join('');
                      candidates.push({ kind: 'css', value: tag + classSelector, score: WEIGHTS.classes + (stableClasses.length > 1 ? 5 : 0), strategy: 'classes', confidence: 'low' });
                    }
                  }

                  return candidates;
                };

                // ========== XPath Selector Generation ==========
                const generateXPathCandidates = (el) => {
                  const candidates = [];
                  const tag = (el.tagName || '').toLowerCase();

                  // XPath by ID
                  if (el.id && !isDynamicClass(el.id)) {
                    candidates.push({ kind: 'xpath', value: 'xpath=//*[@id=' + xpathLiteral(el.id) + ']', score: WEIGHTS.id - 5, strategy: 'xpath-id', confidence: 'high' });
                  }

                  // XPath by data-testid
                  const testId = el.getAttribute?.('data-testid') || el.getAttribute?.('data-test-id');
                  if (testId) {
                    candidates.push({ kind: 'xpath', value: 'xpath=//*[@data-testid=' + xpathLiteral(testId) + ']', score: WEIGHTS.testId - 5, strategy: 'xpath-testId', confidence: 'high' });
                  }

                  // XPath by aria-label
                  const ariaLabel = el.getAttribute?.('aria-label');
                  if (ariaLabel) {
                    candidates.push({ kind: 'xpath', value: 'xpath=//' + tag + '[@aria-label=' + xpathLiteral(ariaLabel) + ']', score: WEIGHTS.ariaLabel, strategy: 'xpath-ariaLabel', confidence: 'high' });
                  }

                  // XPath by name
                  const name = el.getAttribute?.('name');
                  if (name) {
                    candidates.push({ kind: 'xpath', value: 'xpath=//' + tag + '[@name=' + xpathLiteral(name) + ']', score: WEIGHTS.name, strategy: 'xpath-name', confidence: 'high' });
                  }

                  // XPath by placeholder
                  const placeholder = el.getAttribute?.('placeholder');
                  if (placeholder) {
                    candidates.push({ kind: 'xpath', value: 'xpath=//' + tag + '[@placeholder=' + xpathLiteral(placeholder) + ']', score: WEIGHTS.placeholder, strategy: 'xpath-placeholder', confidence: 'medium' });
                  }

                  // XPath by role
                  const role = el.getAttribute?.('role');
                  if (role) {
                    candidates.push({ kind: 'xpath', value: 'xpath=//*[@role=' + xpathLiteral(role) + ']', score: WEIGHTS.role, strategy: 'xpath-role', confidence: 'medium' });
                    if (ariaLabel) {
                      candidates.push({ kind: 'xpath', value: 'xpath=//*[@role=' + xpathLiteral(role) + ' and @aria-label=' + xpathLiteral(ariaLabel) + ']', score: WEIGHTS.role + WEIGHTS.ariaLabel, strategy: 'xpath-role+ariaLabel', confidence: 'high' });
                    }
                  }

                  // XPath by text content (powerful for buttons/links)
                  const text = (el.textContent || '').replace(/\\s+/g, ' ').trim();
                  if (text && text.length > 0 && text.length < 80) {
                    candidates.push({ kind: 'xpath', value: 'xpath=//' + tag + '[normalize-space(.)=' + xpathLiteral(text) + ']', score: WEIGHTS.text + 10, strategy: 'xpath-exactText', confidence: 'medium' });
                    candidates.push({ kind: 'xpath', value: 'xpath=//' + tag + '[contains(normalize-space(.), ' + xpathLiteral(text) + ')]', score: WEIGHTS.text, strategy: 'xpath-containsText', confidence: 'low' });
                    
                    // Role + text combination
                    if (role || ['button', 'a'].includes(tag)) {
                      const roleTag = role ? "*[@role='" + role + "']" : tag;
                      candidates.push({ kind: 'xpath', value: 'xpath=//' + roleTag + '[normalize-space(.)=' + xpathLiteral(text) + ']', score: WEIGHTS.text + WEIGHTS.role, strategy: 'xpath-roleText', confidence: 'medium' });
                    }
                  }

                  // XPath positional fallback with parent context
                  const parent = el.parentElement;
                  if (parent) {
                    const siblings = Array.from(parent.children).filter(sib => sib.tagName === el.tagName);
                    if (siblings.length > 1) {
                      const nth = siblings.indexOf(el) + 1;
                      if (parent.id && !isDynamicClass(parent.id)) {
                        candidates.push({ kind: 'xpath', value: 'xpath=//*[@id=' + xpathLiteral(parent.id) + ']//' + tag + '[' + nth + ']', score: WEIGHTS.nthOfType + 20, strategy: 'xpath-parentId+nth', confidence: 'medium' });
                      }
                      const parentTestId = parent.getAttribute?.('data-testid') || parent.getAttribute?.('data-test-id');
                      if (parentTestId) {
                        candidates.push({ kind: 'xpath', value: 'xpath=//*[@data-testid=' + xpathLiteral(parentTestId) + ']//' + tag + '[' + nth + ']', score: WEIGHTS.nthOfType + 15, strategy: 'xpath-parentTestId+nth', confidence: 'medium' });
                      }
                    }
                  }

                  return candidates;
                };

                // ========== CSS Path Fallback ==========
                const cssPath = (el) => {
                  if (!el || el.nodeType !== 1) return '';
                  const parts = [];
                  let cur = el;
                  let guard = 0;
                  while (cur && cur.nodeType === 1 && guard++ < 7) {
                    const tag = cur.tagName.toLowerCase();
                    if (cur.id && !isDynamicClass(cur.id)) {
                      parts.unshift(tag + '#' + CSS.escape(cur.id));
                      break;
                    }
                    let part = tag;
                    const testId = cur.getAttribute?.('data-testid') || cur.getAttribute?.('data-test-id');
                    if (testId) {
                      part += '[data-testid=' + attrSelectorValue(testId) + ']';
                      parts.unshift(part);
                      break;
                    }
                    const parent = cur.parentElement;
                    if (parent) {
                      const sameTagSiblings = Array.from(parent.children).filter(sib => sib.tagName === cur.tagName);
                      if (sameTagSiblings.length > 1) {
                        part += ':nth-of-type(' + (sameTagSiblings.indexOf(cur) + 1) + ')';
                      }
                    }
                    parts.unshift(part);
                    cur = cur.parentElement;
                  }
                  return parts.join(' > ');
                };

                // ========== Best Selector Selection ==========
                const bestSelector = (el) => {
                  if (!el || el.nodeType !== 1) return '';
                  
                  // Generate all candidates
                  const cssCandidates = generateCSSCandidates(el);
                  
                  // Validate uniqueness and sort by score
                  for (const c of cssCandidates) {
                    c.matches = countCSS(c.value);
                    c.isUnique = c.matches === 1;
                  }
                  
                  // Sort by: unique first, then by score
                  cssCandidates.sort((a, b) => {
                    if (a.isUnique && !b.isUnique) return -1;
                    if (!a.isUnique && b.isUnique) return 1;
                    return b.score - a.score;
                  });
                  
                  // Return first unique, or highest scored
                  for (const c of cssCandidates) {
                    if (c.isUnique) return c.value;
                  }
                  
                  // Fallback to CSS path
                  return cssPath(el) || el.tagName.toLowerCase();
                };

                // ========== Generate All Ranked Candidates ==========
                const generateAllCandidates = (el) => {
                  const cssCandidates = generateCSSCandidates(el);
                  const xpathCandidates = generateXPathCandidates(el);
                  const allCandidates = [...cssCandidates, ...xpathCandidates];
                  
                  // Validate and score
                  for (const c of allCandidates) {
                    if (c.kind === 'xpath') {
                      const xp = c.value.startsWith('xpath=') ? c.value.slice(6) : c.value;
                      c.matches = countXPath(xp);
                    } else {
                      c.matches = countCSS(c.value);
                    }
                    c.isUnique = c.matches === 1;
                    // Penalize non-unique selectors
                    if (!c.isUnique && c.matches > 0) {
                      c.score -= 50;
                    }
                  }
                  
                  // Sort by score
                  allCandidates.sort((a, b) => b.score - a.score);
                  
                  // Return top 6 candidates
                  return allCandidates.slice(0, 6);
                };

                // ========== Main Observation Logic ==========
                const requestedScope = ${JSON.stringify(scope ?? "main")};
                const root =
                  requestedScope === 'document'
                    ? document
                    : (document.querySelector('main, [role="main"]') || document.body);

                const withinRoot = (el) => {
                  try { return root && root !== document ? root.contains(el) : true; } catch { return true; }
                };

                const selectorList = 'button, a, input, textarea, select, summary, [role="button"], [role="link"], [role="tab"], [role="menuitem"], [role="option"], [role="checkbox"], [role="radio"], [role="switch"], [role="slider"], [role="combobox"], [role="listbox"], [role="textbox"]';
                const candidates = Array.from((root && root !== document ? root : document).querySelectorAll(selectorList));

                const seen = new Set();
                const out = [];
                const limit = Math.max(1, Math.min(200, ${JSON.stringify(maxElements ?? 80)}));

                for (const el of candidates) {
                  if (!withinRoot(el)) continue;
                  if (!isVisible(el)) continue;

                  const tag = el.tagName.toLowerCase();
                  const text = (el.textContent || '').substring(0, 80).trim().replace(/\\s+/g, ' ');
                  const placeholder = el.getAttribute('placeholder') || '';
                  const type = el.getAttribute('type') || '';
                  const role = el.getAttribute('role') || '';
                  const name = el.getAttribute('name') || '';
                  const title = el.getAttribute('title') || '';
                  const disabled = 'disabled' in el ? Boolean(el.disabled) : el.getAttribute('aria-disabled') === 'true';
                  const value = 'value' in el ? String(el.value ?? '') : '';
                  const href = tag === 'a' ? (el.getAttribute('href') || '') : '';
                  const ariaLabel = el.getAttribute('aria-label') || '';
                  const ariaLabelledBy = el.getAttribute('aria-labelledby') || '';
                  const testId = el.getAttribute('data-testid') || el.getAttribute('data-test-id') || '';

                  // Generate best selector and all candidates
                  const selector = bestSelector(el);
                  const matches = selector ? countCSS(selector) : 0;
                  const selectorCandidates = generateAllCandidates(el);

                  const key = [tag, selector, text].join('|');
                  if (seen.has(key)) continue;
                  seen.add(key);

                  out.push({
                    tag,
                    text,
                    placeholder,
                    type,
                    role,
                    name,
                    title,
                    disabled,
                    value,
                    href,
                    ariaLabel,
                    ariaLabelledBy,
                    testId,
                    selector,
                    matches,
                    isUnique: matches === 1,
                    selectorCandidates,
                  });
                  if (out.length >= limit) break;
                }

                // Provide a small main-text snippet so the agent can orient itself.
                const mainText = (() => {
                  const node = (document.querySelector('main, [role="main"]') || document.body);
                  const raw = (node?.innerText || '').replace(/\\s+/g, ' ').trim();
                  return raw.slice(0, 1200);
                })();

                return { interactiveElements: out, mainTextSnippet: mainText, scope: requestedScope };
              })()`,
            true
          );
          const resultData = { url, title, ...elements };
          const timestamp = Date.now();
          this.observeCache.set(targetId, {
            url,
            title: String(title ?? ""),
            argsKey,
            data: resultData,
            timestamp,
            domVersion
          });
          return JSON.stringify(
            {
              ...resultData,
              _meta: {
                cached: false,
                timestamp,
                ageMs: 0,
                url,
                title: String(title ?? ""),
                domVersion,
                args: { scope: scope ?? "main", maxElements: maxElements ?? 80 }
              }
            },
            null,
            2
          );
        } catch (e) {
          return `Failed to observe page: ${e.message}`;
        }
      }
    };
    const goBackTool = {
      name: "browser_go_back",
      description: "Navigate back in the browser history.",
      schema: object({}),
      execute: async () => {
        const target = await this.getTarget();
        if (target.canGoBack()) {
          target.goBack();
          this.invalidateCache(target.id);
          await this.delay(500);
          return "Navigated back";
        }
        return "Cannot go back (no history)";
      }
    };
    const goForwardTool = {
      name: "browser_go_forward",
      description: "Navigate forward in the browser history.",
      schema: object({}),
      execute: async () => {
        const target = await this.getTarget();
        if (target.canGoForward()) {
          target.goForward();
          this.invalidateCache(target.id);
          await this.delay(500);
          return "Navigated forward";
        }
        return "Cannot go forward (no history)";
      }
    };
    const reloadTool = {
      name: "browser_reload",
      description: "Reload the current page.",
      schema: object({}),
      execute: async () => {
        const target = await this.getTarget();
        target.reload();
        this.invalidateCache(target.id);
        await this.delay(1e3);
        return "Page reloading triggered";
      }
    };
    const navigateTool = {
      name: "browser_navigate",
      description: "Navigate the browser to a specific URL.",
      schema: object({
        url: string().describe("The URL to navigate to (must include http/https)"),
        tabId: string().optional().describe("Target tab ID for execution"),
        waitForSelector: string().optional().describe("Optional selector to wait for after navigation"),
        waitForText: string().optional().describe("Optional text to wait for after navigation"),
        timeoutMs: number().optional().describe("Timeout in ms for optional waits (default 8000)")
      }),
      execute: async ({
        url,
        tabId,
        waitForSelector,
        waitForText,
        timeoutMs
      }) => {
        try {
          let target;
          try {
            target = await this.getTarget(tabId);
          } catch (noWebviewError) {
            const { BrowserWindow: BrowserWindow2 } = await import("electron");
            const win2 = BrowserWindow2.getAllWindows()[0];
            if (win2) {
              win2.webContents.send("browser:navigate-to", url);
              await this.delay(1500);
              try {
                target = await this.getTarget();
              } catch {
                return `Navigated to ${url} (webview initializing)`;
              }
            } else {
              return `Failed to navigate: No browser window found`;
            }
          }
          try {
            const parsed = new URL$2(url);
            if ((parsed.hostname === "localhost" || parsed.hostname === "127.0.0.1") && parsed.port === "3000") {
              const routes = await this.getMockSaasRoutes();
              const pathname = parsed.pathname.replace(/\/+$/, "") || "/";
              if (!routes.has(pathname)) {
                return `Failed to navigate: Unknown mock-saas route ${pathname}. Known routes: ${Array.from(
                  routes
                ).sort().join(", ")}. Navigate to /jira and use the Create button (it is a modal, not a /create route).`;
              }
            }
          } catch {
          }
          this.invalidateCache(target.id);
          const loadTimeout = timeoutMs ?? 8e3;
          try {
            await target.loadURL(url);
          } catch (e) {
            const msg = String((e == null ? void 0 : e.message) ?? e);
            const isAborted2 = msg.includes("ERR_ABORTED") || e.code === "ERR_ABORTED" || e.errno === -3;
            if (!isAborted2) throw e;
            await this.delay(250);
            if (target.isDestroyed()) throw new Error("WebContents destroyed during navigation");
            const current = target.getURL();
            if (!current) throw e;
          }
          if (waitForSelector) {
            await this.waitForSelector(target, waitForSelector, loadTimeout);
          }
          if (waitForText) {
            const startedAt = Date.now();
            const needle = waitForText.toLowerCase();
            while (Date.now() - startedAt < loadTimeout) {
              const found = await target.executeJavaScript(
                `document.body && document.body.innerText && document.body.innerText.toLowerCase().includes(${JSON.stringify(
                  needle
                )})`,
                true
              );
              if (found) break;
              await this.delay(150);
            }
          }
          return `Navigated to ${target.getURL()}`;
        } catch (e) {
          return `Failed to navigate: ${e.message}`;
        }
      }
    };
    const scrollSchema = object({
      selector: string().optional().describe("CSS selector to scroll into view"),
      direction: _enum(["up", "down", "top", "bottom"]).optional().describe("Scroll direction if no selector provided"),
      amount: number().optional().describe("Pixels to scroll (default 500 for up/down)")
    });
    const scrollTool = {
      name: "browser_scroll",
      description: 'Scroll to an element or by an amount. Provide "selector" to scroll element into view, or "direction" (up/down/top/bottom) to scroll page.',
      schema: scrollSchema,
      execute: async ({ selector, direction, amount }) => {
        const target = await this.getTarget();
        this.invalidateCache(target.id);
        if (selector) {
          await this.waitForSelector(target, selector, 5e3);
          await target.executeJavaScript(
            `(() => {
               const el = document.querySelector(${JSON.stringify(selector)});
               if (el) el.scrollIntoView({ behavior: 'smooth', block: 'center' });
             })()`,
            true
          );
          return `Scrolled to element "${selector}"`;
        } else if (direction) {
          const amt = amount ?? 500;
          await target.executeJavaScript(
            `(() => {
               const amt = ${JSON.stringify(amt)};
               const dir = ${JSON.stringify(direction)};
               if (dir === 'top') window.scrollTo({ top: 0, behavior: 'smooth' });
               else if (dir === 'bottom') window.scrollTo({ top: document.body.scrollHeight, behavior: 'smooth' });
               else if (dir === 'up') window.scrollBy({ top: -amt, behavior: 'smooth' });
               else window.scrollBy({ top: amt, behavior: 'smooth' });
             })()`,
            true
          );
          return `Scrolled ${direction}`;
        }
        return "No scroll action performed (provide selector or direction)";
      }
    };
    const pressKeySchema = object({
      key: string().describe("Key name (e.g. Enter, Escape, ArrowDown)")
    });
    const pressKeyTool = {
      name: "browser_press_key",
      description: "Press a keyboard key (e.g. Enter, Escape, ArrowDown, Tab).",
      schema: pressKeySchema,
      execute: async ({ key }) => {
        const target = await this.getTarget();
        try {
          target.sendInputEvent({ type: "keyDown", keyCode: key });
          target.sendInputEvent({ type: "keyUp", keyCode: key });
          this.invalidateCache(target.id);
          return `Pressed key: ${key}`;
        } catch (e) {
          return `Failed to press key: ${e.message}`;
        }
      }
    };
    const waitForSelectorTool = {
      name: "browser_wait_for_selector",
      description: "Wait for an element to appear in the DOM.",
      schema: object({
        selector: string().describe("CSS selector to wait for"),
        tabId: string().optional().describe("Target tab ID for execution"),
        timeoutMs: number().optional().describe("Timeout in ms (default 5000)")
      }),
      execute: async (args) => {
        const { selector, tabId, timeoutMs } = args;
        const target = await this.getTarget(tabId);
        const timeout = timeoutMs ?? 5e3;
        try {
          await this.waitForSelector(target, selector, timeout);
          return `Element "${selector}" appeared`;
        } catch (e) {
          return `Timeout waiting for "${selector}"`;
        }
      }
    };
    const waitForUrlTool = {
      name: "browser_wait_for_url",
      description: "Wait for the URL to contain a specific string.",
      schema: object({
        urlPart: string().describe("Substring or full URL to wait for"),
        tabId: string().optional().describe("Target tab ID for execution"),
        timeoutMs: number().optional().describe("Timeout in ms (default 5000)")
      }),
      execute: async (args) => {
        const { urlPart, tabId, timeoutMs } = args;
        const target = await this.getTarget(tabId);
        const timeout = timeoutMs ?? 5e3;
        const startedAt = Date.now();
        while (Date.now() - startedAt < timeout) {
          const currentUrl = target.getURL();
          if (currentUrl.includes(urlPart)) return `URL matches "${urlPart}"`;
          await this.delay(200);
        }
        return `Timeout waiting for URL to contain "${urlPart}"`;
      }
    };
    const focusSchema = object({
      selector: string().describe("CSS selector to focus")
    });
    const focusTool = {
      name: "browser_focus",
      description: "Focus an element (e.g. input field).",
      schema: focusSchema,
      execute: async ({ selector }) => {
        const target = await this.getTarget();
        await this.waitForSelector(target, selector, 5e3);
        await target.executeJavaScript(
          `(() => {
             const el = document.querySelector(${JSON.stringify(selector)});
             if (el && typeof el.focus === 'function') el.focus();
           })()`,
          true
        );
        this.invalidateCache(target.id);
        return `Focused "${selector}"`;
      }
    };
    const clearSchema = object({
      selector: string().describe("CSS selector of input to clear")
    });
    const clearTool = {
      name: "browser_clear",
      description: "Clear the value of an input or textarea.",
      schema: clearSchema,
      execute: async ({ selector }) => {
        const target = await this.getTarget();
        await this.waitForSelector(target, selector, 5e3);
        await target.executeJavaScript(
          `(() => {
             const el = document.querySelector(${JSON.stringify(selector)});
             if (!el) return { ok: false, error: 'Element not found' };
             const tag = (el.tagName || '').toLowerCase();
             const isEditable = tag === 'input' || tag === 'textarea' || Boolean(el.isContentEditable);
             if (!isEditable) return { ok: false, error: 'Element is not editable' };

             const setNativeValue = (node, value) => {
               const t = (node.tagName || '').toLowerCase();
               if (t === 'input') {
                 const setter = Object.getOwnPropertyDescriptor(window.HTMLInputElement.prototype, 'value')?.set;
                 if (setter) setter.call(node, value);
                 else node.value = value;
                 return;
               }
               if (t === 'textarea') {
                 const setter = Object.getOwnPropertyDescriptor(window.HTMLTextAreaElement.prototype, 'value')?.set;
                 if (setter) setter.call(node, value);
                 else node.value = value;
                 return;
               }
               if (node.isContentEditable) {
                 node.textContent = value;
                 return;
               }
               node.value = value;
             };

             setNativeValue(el, '');
             el.dispatchEvent(new InputEvent('input', { bubbles: true, data: '', inputType: 'deleteContentBackward' }));
             el.dispatchEvent(new Event('change', { bubbles: true }));
             return { ok: true };
           })()`,
          true
        );
        this.invalidateCache(target.id);
        return `Cleared input "${selector}"`;
      }
    };
    const clickSchema = object({
      selector: string().describe('CSS selector (or XPath prefixed with "xpath=") of the element to click'),
      tabId: string().optional().describe("Target tab ID for execution"),
      withinSelector: string().optional().describe("Optional container selector to scope the search (must match exactly 1 element)"),
      index: number().optional().describe("Index of element if multiple match (0-based)"),
      matchText: string().optional().describe("Text content to match if multiple elements found")
    });
    const clickTool = {
      name: "browser_click",
      description: "Click an element on the current page. Safe + deterministic: if the selector matches multiple visible elements, you must disambiguate using withinSelector, matchText, or index (or use browser_click_text).",
      schema: clickSchema,
      execute: async ({ selector, tabId, withinSelector, index, matchText }) => {
        try {
          const target = await this.getTarget(tabId);
          if (withinSelector) {
            await this.waitForSelector(target, withinSelector, 5e3);
          }
          await this.waitForSelector(target, selector, 5e3);
          const result = await target.executeJavaScript(
            `(() => {
                // Helper to find elements including shadow DOM
                const isXPathSelector = (sel) => {
                  const s = String(sel ?? '').trim();
                  return s.startsWith('xpath=') || s.startsWith('//') || s.startsWith('/') || s.startsWith('(');
                };

                const normalizeXPath = (sel) => {
                  const s = String(sel ?? '').trim();
                  return s.startsWith('xpath=') ? s.slice(6) : s;
                };

                const findByXPath = (xp) => {
                  const out = [];
                  try {
                    const snap = document.evaluate(
                      xp,
                      document,
                      null,
                      XPathResult.ORDERED_NODE_SNAPSHOT_TYPE,
                      null
                    );
                    for (let i = 0; i < snap.snapshotLength; i++) {
                      const node = snap.snapshotItem(i);
                      if (node && node.nodeType === 1) out.push(node);
                    }
                  } catch {
                    // ignore
                  }
                  return out;
                };

                const findElements = (root, sel) => {
                  if (isXPathSelector(sel)) {
                    const xp = normalizeXPath(sel);
                    const nodes = findByXPath(xp);
                    if (root && root !== document) {
                      return nodes.filter((n) => {
                        try {
                          return root.contains(n);
                        } catch {
                          return false;
                        }
                      });
                    }
                    return nodes;
                  }
                  const results = [];
                  const queryDeep = (root) => {
                    const els = Array.from(root.querySelectorAll(sel));
                    results.push(...els);
                    if (root.shadowRoot) {
                      queryDeep(root.shadowRoot);
                    }
                    const walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT);
                    while (walker.nextNode()) {
                      const node = walker.currentNode;
                      if (node.shadowRoot) {
                        queryDeep(node.shadowRoot);
                      }
                    }
                  };
                  queryDeep(root);
                  return results;
                };

                const isVisible = (el) => {
                  if (!el || el.nodeType !== 1) return false;
                  const style = window.getComputedStyle(el);
                  if (!style) return false;
                  if (style.display === 'none' || style.visibility === 'hidden' || style.opacity === '0') return false;
                  if (style.pointerEvents === 'none') return false;
                  const rects = el.getClientRects();
                  if (!rects || rects.length === 0) return false;
                  const rect = el.getBoundingClientRect();
                  if (rect.width < 2 || rect.height < 2) return false;
                  const vw = window.innerWidth || 0;
                  const vh = window.innerHeight || 0;
                  const buffer = 40;
                  if (rect.bottom < -buffer || rect.top > vh + buffer) return false;
                  if (rect.right < -buffer || rect.left > vw + buffer) return false;
                  return true;
                };

                const describe = (el) => {
                  const tag = (el.tagName || '').toLowerCase();
                  const text = (el.innerText || el.textContent || '').replace(/s+/g, ' ').trim().slice(0, 80);
                  const ariaLabel = el.getAttribute?.('aria-label') || '';
                  const testId = el.getAttribute?.('data-testid') || el.getAttribute?.('data-test-id') || '';
                  const id = el.id || '';
                  return { tag, text, ariaLabel, testId, id };
                };

                const withinSel = ${JSON.stringify(withinSelector ?? "")};
                let root = document;
                if (withinSel) {
                  const roots = Array.from(document.querySelectorAll(withinSel)).filter(isVisible);
                  if (roots.length === 0) {
                    return { ok: false, error: 'Within selector not found (or not visible)', matches: 0 };
                  }
                  if (roots.length > 1) {
                    return { ok: false, error: 'Within selector is not unique', matches: roots.length, roots: roots.slice(0, 5).map(describe) };
                  }
                  root = roots[0];
                }

                let candidates = findElements(root, ${JSON.stringify(selector)});
                candidates = candidates.filter(isVisible);
                
                // Filter by text if provided
                if (${JSON.stringify(matchText)}) {
                  const needle = ${JSON.stringify(matchText || "")}.toLowerCase();
                  candidates = candidates.filter(el => (el.innerText || '').toLowerCase().includes(needle));
                }

                if (candidates.length === 0) {
                  return { ok: false, error: 'Element not found (visible)', matches: 0 };
                }

                const idxProvided = ${JSON.stringify(index !== void 0)};
                const idx = ${JSON.stringify(index ?? 0)};

                if (candidates.length > 1 && !idxProvided) {
                  return {
                    ok: false,
                    error: 'Ambiguous selector (multiple visible matches)',
                    matches: candidates.length,
                    candidates: candidates.slice(0, 6).map(describe),
                  };
                }

                if (idx >= candidates.length) return { ok: false, error: 'Index out of bounds' };
                
                const el = candidates[idx];
                
                const isDisabled = ('disabled' in el && Boolean(el.disabled)) || el.getAttribute?.('aria-disabled') === 'true';
                if (isDisabled) return { ok: false, error: 'Element is disabled' };
                
                el.scrollIntoView({ block: 'center', inline: 'center' });
                
                // Try multiple click strategies
                try {
                  el.click(); // Standard click
                } catch (e) { console.error('Standard click failed', e); }
                
                // Dispatch events (crucial for React/Angular/Vue apps)
                const eventOpts = { bubbles: true, cancelable: true, view: window };
                el.dispatchEvent(new MouseEvent('mouseover', eventOpts));
                el.dispatchEvent(new MouseEvent('mousedown', eventOpts));
                el.dispatchEvent(new MouseEvent('mouseup', eventOpts));
                el.dispatchEvent(new MouseEvent('click', eventOpts));
                
                return { ok: true, matches: candidates.length, clicked: describe(el) };
              })()`,
            true
          );
          if (!result.ok) {
            const base = `Refusing to click: ${result.error}. Selector=${JSON.stringify(
              selector
            )}${withinSelector ? ` within=${JSON.stringify(withinSelector)}` : ""}.`;
            if (result.error === "Ambiguous selector (multiple visible matches)") {
              const matches = typeof result.matches === "number" ? result.matches : "multiple";
              const preview = Array.isArray(result.candidates) ? result.candidates.map((c, i2) => {
                const bits = [c.tag, c.testId ? `testId=${c.testId}` : "", c.id ? `id=${c.id}` : ""].filter(Boolean).join(" ");
                const label = c.ariaLabel ? ` ariaLabel=${JSON.stringify(c.ariaLabel)}` : "";
                const text = c.text ? ` text=${JSON.stringify(c.text)}` : "";
                return `#${i2} ${bits}${label}${text}`;
              }).join("\n") : "";
              return `${base} Matched ${matches} visible elements.
Provide one of: {"index":0..}, {"matchText":"..."}, or {"withinSelector":"..."}.
Or prefer browser_click_text (more robust).
` + (preview ? `Candidates:
${preview}` : "");
            }
            if (result.error === "Within selector is not unique") {
              const rootsPreview = Array.isArray(result.roots) ? result.roots.map((c, i2) => {
                const bits = [c.tag, c.testId ? `testId=${c.testId}` : "", c.id ? `id=${c.id}` : ""].filter(Boolean).join(" ");
                const text = c.text ? ` text=${JSON.stringify(c.text)}` : "";
                return `#${i2} ${bits}${text}`;
              }).join("\n") : "";
              return `${base} The withinSelector must match exactly 1 visible container.
` + (rootsPreview ? `Within candidates:
${rootsPreview}` : "");
            }
            return `${base} Try browser_click_text or refine your selector.`;
          }
          this.invalidateCache(target.id);
          return `Clicked element ${selector}`;
        } catch (e) {
          return `Failed to click ${selector}: ${e.message}`;
        }
      }
    };
    const typeTool = {
      name: "browser_type",
      description: "Type text into an input field.",
      schema: object({
        selector: string().describe('CSS selector (or XPath prefixed with "xpath=") of the input'),
        text: string().describe("Text to type"),
        tabId: string().optional().describe("Target tab ID for execution")
      }),
      execute: async ({ selector, text, tabId }) => {
        try {
          const target = await this.getTarget(tabId);
          const matches = await this.querySelectorCount(target, selector);
          if (matches > 1) {
            return `Refusing to type into non-unique selector (matches=${matches}): ${selector}`;
          }
          await this.waitForSelector(target, selector, 5e3);
          const typedValue = await target.executeJavaScript(
            `(() => {
                const sel = ${JSON.stringify(selector)};
                const s = String(sel ?? '').trim();
                const isXpath = s.startsWith('xpath=') || s.startsWith('//') || s.startsWith('/') || s.startsWith('(');
                const xp = s.startsWith('xpath=') ? s.slice(6) : s;
                const el = isXpath
                  ? (document.evaluate(xp, document, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue)
                  : document.querySelector(sel);
                if (!el) throw new Error('Element not found');
                const isDisabled = ('disabled' in el && Boolean(el.disabled)) || el.getAttribute?.('aria-disabled') === 'true';
                if (isDisabled) throw new Error('Element is disabled');
                el.scrollIntoView({ block: 'center', inline: 'center' });
                el.focus?.();

                const setNativeValue = (node, value) => {
                  const tag = node.tagName?.toLowerCase?.() || '';
                  if (tag === 'input') {
                    const setter = Object.getOwnPropertyDescriptor(window.HTMLInputElement.prototype, 'value')?.set;
                    if (setter) setter.call(node, value);
                    else node.value = value;
                    return;
                  }
                  if (tag === 'textarea') {
                    const setter = Object.getOwnPropertyDescriptor(window.HTMLTextAreaElement.prototype, 'value')?.set;
                    if (setter) setter.call(node, value);
                    else node.value = value;
                    return;
                  }
                  if (node.isContentEditable) {
                    node.textContent = value;
                    return;
                  }
                  node.value = value;
                };

                setNativeValue(el, '');
                el.dispatchEvent(new InputEvent('input', { bubbles: true, data: '', inputType: 'deleteContentBackward' }));
                setNativeValue(el, ${JSON.stringify(text)});
                el.dispatchEvent(new InputEvent('input', { bubbles: true, data: ${JSON.stringify(text)}, inputType: 'insertText' }));
                el.dispatchEvent(new Event('change', { bubbles: true }));
                return ('value' in el) ? String(el.value ?? '') : (el.textContent || '');
              })()`,
            true
          );
          this.invalidateCache(target.id);
          return `Typed into ${selector}. Current value: ${JSON.stringify(typedValue)}`;
        } catch (e) {
          return `Failed to type into ${selector}: ${e.message}`;
        }
      }
    };
    const getTextTool = {
      name: "browser_get_text",
      description: "Get the text content of an element.",
      schema: object({
        selector: string().describe('CSS selector (or XPath prefixed with "xpath=")'),
        tabId: string().optional().describe("Target tab ID for execution")
      }),
      execute: async ({ selector, tabId }) => {
        try {
          const target = await this.getTarget(tabId);
          await this.waitForSelector(target, selector, 5e3);
          const text = await target.executeJavaScript(
            `(() => {
                    const sel = ${JSON.stringify(selector)};
                    const s = String(sel ?? '').trim();
                    const isXpath = s.startsWith('xpath=') || s.startsWith('//') || s.startsWith('/') || s.startsWith('(');
                    const xp = s.startsWith('xpath=') ? s.slice(6) : s;
                    const el = isXpath
                      ? (document.evaluate(xp, document, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue)
                      : document.querySelector(sel);
                    return el ? (el.textContent || '') : null;
                  })()`,
            true
          );
          return text || "Element found but has no text.";
        } catch (e) {
          return `Failed to get text: ${e.message}`;
        }
      }
    };
    const screenshotTool = {
      name: "browser_screenshot",
      description: "Take a screenshot of the current page.",
      schema: object({
        path: string().optional().describe("Path to save the screenshot (optional)")
      }),
      execute: async ({ path: savePath }) => {
        const target = await this.getTarget();
        const image = await target.capturePage();
        const buffer = image.toPNG();
        if (savePath) {
          const resolved = path__default$1.isAbsolute(savePath) ? savePath : path__default$1.join(process.cwd(), savePath);
          await fs$3.writeFile(resolved, buffer);
          return `Screenshot saved to ${resolved} (${buffer.length} bytes).`;
        }
        return `Screenshot taken (${buffer.length} bytes).`;
      }
    };
    const findTextTool = {
      name: "browser_find_text",
      description: "Find text on the current page and return matching elements/selectors.",
      schema: object({
        text: string().describe("Text to search for (case-insensitive substring match)"),
        maxMatches: number().optional().describe("Max results to return (default 10)")
      }),
      execute: async ({ text, maxMatches }) => {
        const target = await this.getTarget();
        const results2 = await target.executeJavaScript(
          `(() => {
            const query = ${JSON.stringify(text)}.toLowerCase();
            const limit = Math.max(1, Math.min(50, ${JSON.stringify(maxMatches ?? 10)}));

            const escapeForSingleQuotes = (value) => {
              if (typeof value !== 'string') return '';
              return value.replace(/\\\\/g, '\\\\\\\\').replace(/'/g, "\\\\'");
            };

            const attrSelectorValue = (value) => {
              if (typeof value !== 'string') return "''";
              if (/^[a-zA-Z0-9_-]+$/.test(value)) return value;
              return "'" + escapeForSingleQuotes(value) + "'";
            };

            const selectorFor = (el) => {
              if (!el || el.nodeType !== 1) return '';
              if (el.id) return '#' + el.id;
              const testId = el.getAttribute && (el.getAttribute('data-testid') || el.getAttribute('data-test-id'));
              if (testId) return '[data-testid=' + attrSelectorValue(testId) + ']';
              const ariaLabel = el.getAttribute && el.getAttribute('aria-label');
              if (ariaLabel) return el.tagName.toLowerCase() + '[aria-label=' + attrSelectorValue(ariaLabel) + ']';
              const placeholder = el.getAttribute && el.getAttribute('placeholder');
              if (placeholder) return el.tagName.toLowerCase() + '[placeholder=' + attrSelectorValue(placeholder) + ']';
              return el.tagName.toLowerCase();
            };

            const out = [];
            const walker = document.createTreeWalker(document.body, NodeFilter.SHOW_TEXT);
            while (walker.nextNode()) {
              const node = walker.currentNode;
              const raw = node.nodeValue || '';
              const normalized = raw.replace(/\\s+/g, ' ').trim();
              if (!normalized) continue;
              if (!normalized.toLowerCase().includes(query)) continue;

              const parent = node.parentElement;
              if (!parent) continue;
              const el = parent.closest('button, a, [role="button"], [role="link"], input, textarea, select, div, span, p') || parent;
              const selector = selectorFor(el);
              out.push({
                selector,
                tag: el.tagName.toLowerCase(),
                text: (el.textContent || '').replace(/\\s+/g, ' ').trim().slice(0, 120),
              });
              if (out.length >= limit) break;
            }
            return out;
          })()`,
          true
        );
        return JSON.stringify({ found: Array.isArray(results2) ? results2.length : 0, matches: results2 }, null, 2);
      }
    };
    const waitForTextTool = {
      name: "browser_wait_for_text",
      description: "Wait until text appears on the page (case-insensitive). Useful to verify actions succeeded.",
      schema: object({
        text: string().describe("Text to wait for"),
        tabId: string().optional().describe("Target tab ID for execution"),
        timeoutMs: number().optional().describe("Timeout in ms (default 5000)")
      }),
      execute: async ({ text, tabId, timeoutMs }) => {
        const target = await this.getTarget(tabId);
        const startedAt = Date.now();
        const timeout = timeoutMs ?? 5e3;
        while (Date.now() - startedAt < timeout) {
          const found = await target.executeJavaScript(
            `document.body && document.body.innerText && document.body.innerText.toLowerCase().includes(${JSON.stringify(
              text.toLowerCase()
            )})`,
            true
          );
          if (found) return `Found text: ${JSON.stringify(text)}`;
          await this.delay(150);
        }
        return `Did not find text within ${timeout}ms: ${JSON.stringify(text)}`;
      }
    };
    const waitForTextInTool = {
      name: "browser_wait_for_text_in",
      description: "Wait until text appears within a specific container selector (case-insensitive).",
      schema: object({
        selector: string().describe("CSS selector for the container"),
        text: string().describe("Text to wait for"),
        timeoutMs: number().optional().describe("Timeout in ms (default 5000)")
      }),
      execute: async ({
        selector,
        text,
        timeoutMs
      }) => {
        const target = await this.getTarget();
        const startedAt = Date.now();
        const timeout = timeoutMs ?? 5e3;
        const needle = text.toLowerCase();
        while (Date.now() - startedAt < timeout) {
          const found = await target.executeJavaScript(
            `(() => {
              const root = document.querySelector(${JSON.stringify(selector)});
              if (!root) return false;
              const text = (root.innerText || '').toLowerCase();
              return text.includes(${JSON.stringify(needle)});
            })()`,
            true
          );
          if (found) return `Found text in ${selector}: ${JSON.stringify(text)}`;
          await this.delay(150);
        }
        return `Did not find text in ${selector} within ${timeout}ms: ${JSON.stringify(text)}`;
      }
    };
    const selectTool = {
      name: "browser_select",
      description: "Set the value of a <select> element.",
      schema: object({
        selector: string().describe('CSS selector (or XPath prefixed with "xpath=") of the select element'),
        value: string().describe("Option value to set"),
        tabId: string().optional().describe("Target tab ID for execution")
      }),
      execute: async ({ selector, value, tabId }) => {
        try {
          const target = await this.getTarget(tabId);
          const matches = await this.querySelectorCount(target, selector);
          if (matches > 1) {
            return `Refusing to select on non-unique selector (matches=${matches}): ${selector}`;
          }
          await this.waitForSelector(target, selector, 5e3);
          const selected = await target.executeJavaScript(
            `(() => {
              const sel = ${JSON.stringify(selector)};
              const s = String(sel ?? '').trim();
              const isXpath = s.startsWith('xpath=') || s.startsWith('//') || s.startsWith('/') || s.startsWith('(');
              const xp = s.startsWith('xpath=') ? s.slice(6) : s;
              const el = isXpath
                ? (document.evaluate(xp, document, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue)
                : document.querySelector(sel);
              if (!el) throw new Error('Element not found');
              const tag = el.tagName?.toLowerCase?.();
              if (tag !== 'select') throw new Error('Element is not a <select>');
              const isDisabled = Boolean(el.disabled) || el.getAttribute?.('aria-disabled') === 'true';
              if (isDisabled) throw new Error('Element is disabled');
              el.value = ${JSON.stringify(value)};
              el.dispatchEvent(new Event('input', { bubbles: true }));
              el.dispatchEvent(new Event('change', { bubbles: true }));
              return String(el.value ?? '');
            })()`,
            true
          );
          this.invalidateCache(target.id);
          return `Selected value ${JSON.stringify(selected)} on ${selector}`;
        } catch (e) {
          return `Failed to select on ${selector}: ${e.message}`;
        }
      }
    };
    const clickTextTool = {
      name: "browser_click_text",
      description: "Click a visible element by its text (avoids brittle selectors). Optionally filter by tag/role and choose index.",
      schema: object({
        text: string().describe("Visible text to match"),
        exact: boolean().optional().describe("Exact match (default false = substring match)"),
        role: string().optional().describe("ARIA role to filter (e.g. tab, button, link)"),
        tag: string().optional().describe("Tag name to filter (e.g. a, button)"),
        index: number().optional().describe("Which match to click (0-based, default 0)"),
        withinSelector: string().optional().describe("Limit search to a container selector")
      }),
      execute: async ({
        text,
        exact,
        role,
        tag,
        index,
        withinSelector
      }) => {
        try {
          const target = await this.getTarget();
          const clicked = await target.executeJavaScript(
            `(() => {
              const query = ${JSON.stringify(text)}.toLowerCase().trim();
              const exact = Boolean(${JSON.stringify(exact ?? false)});
              const role = ${JSON.stringify(role ?? "")}.toLowerCase().trim();
              const tag = ${JSON.stringify(tag ?? "")}.toLowerCase().trim();
              const idx = Math.max(0, Math.floor(${JSON.stringify(index ?? 0)}));
              const root = ${withinSelector ? `document.querySelector(${JSON.stringify(withinSelector)})` : "document"} || document;

              const isVisible = (el) => {
                if (!el || el.nodeType !== 1) return false;
                const style = window.getComputedStyle(el);
                if (!style) return false;
                if (style.display === 'none' || style.visibility === 'hidden' || style.opacity === '0') return false;
                if (style.pointerEvents === 'none') return false;
                const rects = el.getClientRects();
                if (!rects || rects.length === 0) return false;
                const rect = el.getBoundingClientRect();
                if (rect.width < 2 || rect.height < 2) return false;
                const vw = window.innerWidth || 0;
                const vh = window.innerHeight || 0;
                const buffer = 40;
                if (rect.bottom < -buffer || rect.top > vh + buffer) return false;
                if (rect.right < -buffer || rect.left > vw + buffer) return false;
                return true;
              };

              const selector = 'button, a, [role="button"], [role="link"], [role="tab"], summary';
              const candidates = Array.from((root === document ? document : root).querySelectorAll(selector));
              const matches = [];
              for (const el of candidates) {
                if (!isVisible(el)) continue;
                if (tag && el.tagName.toLowerCase() !== tag) continue;
                if (role) {
                  const r = (el.getAttribute('role') || '').toLowerCase();
                  if (r !== role) continue;
                }
                const t = (el.textContent || '').replace(/\\s+/g, ' ').trim().toLowerCase();
                if (!t) continue;
                const ok = exact ? t === query : t.includes(query);
                if (!ok) continue;
                const disabled = ('disabled' in el && Boolean(el.disabled)) || el.getAttribute?.('aria-disabled') === 'true';
                matches.push({ el, text: t, disabled });
              }

              if (matches.length === 0) {
                return { ok: false, reason: 'No matching visible elements', matches: 0 };
              }
              const chosen = matches[Math.min(idx, matches.length - 1)];
              if (chosen.disabled) {
                return { ok: false, reason: 'Matched element is disabled', matches: matches.length };
              }
              const el = chosen.el;
              el.scrollIntoView({ block: 'center', inline: 'center' });
              el.dispatchEvent(new MouseEvent('mouseover', { bubbles: true }));
              el.dispatchEvent(new MouseEvent('mousedown', { bubbles: true }));
              el.dispatchEvent(new MouseEvent('mouseup', { bubbles: true }));
              el.click();
              return { ok: true, matches: matches.length, clickedText: chosen.text };
            })()`,
            true
          );
          return `ClickText result: ${JSON.stringify(clicked)}`;
        } catch (e) {
          return `Failed to click by text: ${e.message}`;
        }
      }
    };
    const extractMainTextTool = {
      name: "browser_extract_main_text",
      description: "Extract visible text from the main content area (role=main/main tag) to support scraping/QA.",
      schema: object({
        maxChars: number().optional().describe("Max characters to return (default 2000, hard cap 4000)")
      }),
      execute: async ({ maxChars }) => {
        const target = await this.getTarget();
        const limit2 = Math.max(1, Math.min(4e3, Math.floor(maxChars ?? 2e3)));
        const text = await target.executeJavaScript(
          `(() => {
            const node = document.querySelector('main, [role="main"]') || document.body;
            const raw = (node?.innerText || '').replace(/s+/g, ' ').trim();
            return raw.slice(0, ${JSON.stringify(limit2)});
          })()`,
          true
        );
        return String(text ?? "");
      }
    };
    const executePlanStepSchema = object({
      action: _enum(["navigate", "click", "type", "select", "wait"]),
      url: string().optional().describe("For navigate action"),
      selector: string().optional().describe("For click/type/select actions"),
      value: string().optional().describe("For type/select actions"),
      text: string().optional().describe("For wait action"),
      index: number().optional().describe("For click actions: index to disambiguate (0-based)"),
      matchText: string().optional().describe("For click actions: filter candidates by visible text"),
      withinSelector: string().optional().describe("For click actions: scope search to a unique container selector")
    });
    const executePlanSchema = object({
      steps: array(executePlanStepSchema)
    });
    const executePlanTool = {
      name: "browser_execute_plan",
      description: "Execute a batch of browser actions (navigate, click, type, select, wait). Use this for Mock SaaS tasks where you have read the code and know the selectors.",
      schema: executePlanSchema,
      execute: async (input) => {
        const parsed = executePlanSchema.parse(input ?? {});
        const steps = parsed.steps;
        const results2 = [];
        const runId = agentRunContext.getRunId() ?? void 0;
        const planId = v4$2();
        if (!Array.isArray(steps) || steps.length === 0) {
          return "Plan rejected: steps must be a non-empty array.";
        }
        for (const [i2, step] of steps.entries()) {
          if (step.action === "navigate") {
            if (!step.url) return `Plan rejected: step ${i2 + 1} navigate is missing url.`;
          }
          if (step.action === "click") {
            if (!step.selector) return `Plan rejected: step ${i2 + 1} click is missing selector.`;
          }
          if (step.action === "type") {
            if (!step.selector) return `Plan rejected: step ${i2 + 1} type is missing selector.`;
            if (step.value === void 0) return `Plan rejected: step ${i2 + 1} type is missing value.`;
          }
          if (step.action === "select") {
            if (!step.selector) return `Plan rejected: step ${i2 + 1} select is missing selector.`;
            if (step.value === void 0) return `Plan rejected: step ${i2 + 1} select is missing value.`;
          }
          if (step.action === "wait") {
            if (!step.text) return `Plan rejected: step ${i2 + 1} wait is missing text.`;
          }
        }
        const hasInteraction = steps.some((s) => s.action === "click" || s.action === "type" || s.action === "select");
        if (hasInteraction) {
          const last = steps[steps.length - 1];
          if ((last == null ? void 0 : last.action) !== "wait" || !(last == null ? void 0 : last.text)) {
            return 'Plan rejected: plans with interactions must end with a verification wait step (action="wait" with text).';
          }
        }
        const policyService = toolRegistry.getPolicyService();
        if (policyService) {
          const browserContext = agentRunContext.getBrowserContext();
          for (const [i2, step] of steps.entries()) {
            const toolNameForStep = (() => {
              switch (step.action) {
                case "navigate":
                  return "browser_navigate";
                case "click":
                  return "browser_click";
                case "type":
                  return "browser_type";
                case "select":
                  return "browser_select";
                case "wait":
                  return "browser_wait_for_text";
                default:
                  return "browser_execute_plan_step";
              }
            })();
            const argsForStep = (() => {
              switch (step.action) {
                case "navigate":
                  return { url: step.url };
                case "click":
                  return {
                    selector: step.selector,
                    index: step.index,
                    matchText: step.matchText,
                    withinSelector: step.withinSelector
                  };
                case "type":
                  return { selector: step.selector, text: step.value };
                case "select":
                  return { selector: step.selector, value: step.value };
                case "wait":
                  return { text: step.text };
              }
            })();
            const decision = await policyService.evaluate({
              toolName: toolNameForStep,
              args: argsForStep,
              url: browserContext == null ? void 0 : browserContext.url,
              domain: browserContext == null ? void 0 : browserContext.domain,
              userMode: "standard",
              observeOnly: agentRunContext.getObserveOnly(),
              runId
            });
            if (decision.decision === "deny") {
              return `Plan rejected by policy at step ${i2 + 1} (${toolNameForStep}): ${decision.reason}`;
            }
          }
        }
        const isFailureOutput = (s) => {
          const t2 = String(s ?? "");
          return t2.startsWith("Refusing") || t2.startsWith("Failed") || t2.startsWith("Timeout") || t2.startsWith("Operation denied by policy") || t2.startsWith("User denied") || t2.startsWith("Tool execution failed");
        };
        for (const [i2, step] of steps.entries()) {
          const stepId = v4$2();
          const startedAt = Date.now();
          try {
            await telemetryService.emit({
              eventId: v4$2(),
              runId,
              ts: (/* @__PURE__ */ new Date()).toISOString(),
              type: "plan_step_start",
              name: "browser_execute_plan",
              data: {
                planId,
                stepId,
                stepIndex: i2,
                action: String((step == null ? void 0 : step.action) ?? "")
              }
            });
          } catch {
          }
          try {
            const toolNameForStep = (() => {
              switch (step.action) {
                case "navigate":
                  return "browser_navigate";
                case "click":
                  return "browser_click";
                case "type":
                  return "browser_type";
                case "select":
                  return "browser_select";
                case "wait":
                  return "browser_wait_for_text";
                default:
                  return "browser_execute_plan_step";
              }
            })();
            const toolArgsForStep = (() => {
              switch (step.action) {
                case "navigate":
                  return { url: step.url };
                case "click":
                  return {
                    selector: step.selector,
                    index: step.index,
                    matchText: step.matchText,
                    withinSelector: step.withinSelector
                  };
                case "type":
                  return { selector: step.selector, text: step.value };
                case "select":
                  return { selector: step.selector, value: step.value };
                case "wait":
                  return { text: step.text };
              }
            })();
            const res = await toolRegistry.invokeTool(toolNameForStep, toolArgsForStep);
            const resStr = String(res ?? "");
            if (isFailureOutput(resStr)) {
              throw new Error(resStr);
            }
            if (step.action === "wait" && !resStr.startsWith("Found text")) {
              throw new Error(resStr);
            }
            const durationMs = Date.now() - startedAt;
            try {
              await telemetryService.emit({
                eventId: v4$2(),
                runId,
                ts: (/* @__PURE__ */ new Date()).toISOString(),
                type: "plan_step_end",
                name: "browser_execute_plan",
                data: {
                  planId,
                  stepId,
                  stepIndex: i2,
                  action: String((step == null ? void 0 : step.action) ?? ""),
                  ok: true,
                  durationMs,
                  resultLength: String(resStr ?? "").length
                }
              });
            } catch {
            }
            results2.push(`Step ${i2 + 1} (${step.action}): ${resStr}`);
          } catch (e) {
            const durationMs = Date.now() - startedAt;
            try {
              await telemetryService.emit({
                eventId: v4$2(),
                runId,
                ts: (/* @__PURE__ */ new Date()).toISOString(),
                type: "plan_step_end",
                name: "browser_execute_plan",
                data: {
                  planId,
                  stepId,
                  stepIndex: i2,
                  action: String((step == null ? void 0 : step.action) ?? ""),
                  ok: false,
                  durationMs,
                  errorMessage: String((e == null ? void 0 : e.message) ?? e)
                }
              });
            } catch {
            }
            results2.push(`Step ${i2 + 1} (${step.action}) FAILED: ${e.message}`);
            return `Plan execution stopped at step ${i2 + 1} due to error.
Results so far:
${results2.join("\n")}`;
          }
        }
        return `Plan completed successfully.
${results2.join("\n")}`;
      }
    };
    toolRegistry.register(observeTool);
    const openTabTool = {
      name: "browser_open_tab",
      description: "Open a new browser tab with the specified URL.",
      schema: object({
        url: string().describe("The URL to open"),
        background: boolean().optional().describe("Open in background (default: true)")
      }),
      execute: async ({ url, background }) => {
        try {
          const tabId = await agentTabOpenService.openAgentTab({
            url,
            background: background ?? true,
            agentCreated: true
          });
          return JSON.stringify({ ok: true, tabId, message: `Opened ${url} in a new tab` });
        } catch (e) {
          return `Failed to open tab: ${e.message}`;
        }
      }
    };
    toolRegistry.register(openTabTool);
    toolRegistry.register(goBackTool);
    toolRegistry.register(goForwardTool);
    toolRegistry.register(reloadTool);
    toolRegistry.register(navigateTool);
    toolRegistry.register(scrollTool);
    toolRegistry.register(pressKeyTool);
    toolRegistry.register(waitForSelectorTool);
    toolRegistry.register(waitForUrlTool);
    toolRegistry.register(focusTool);
    toolRegistry.register(clearTool);
    toolRegistry.register(clickTool);
    toolRegistry.register(typeTool);
    toolRegistry.register(getTextTool);
    toolRegistry.register(screenshotTool);
    toolRegistry.register(findTextTool);
    toolRegistry.register(waitForTextTool);
    toolRegistry.register(waitForTextInTool);
    toolRegistry.register(selectTool);
    toolRegistry.register(clickTextTool);
    toolRegistry.register(extractMainTextTool);
    toolRegistry.register(executePlanTool);
  }
}
const browserAutomationService = new BrowserAutomationService();
const BENCHMARK_SUITE = [
  {
    id: "aerocore-dispatch",
    name: "AeroCore Dispatch",
    description: "Create and dispatch a new job in AeroCore Dispatch",
    userMessage: "Go to AeroCore Dispatch and create a new dispatch job for cargo delivery from Warehouse A to Terminal 1",
    expectedOutcome: { type: "text_present", value: "Warehouse A" },
    timeoutMs: 6e4
  },
  {
    id: "aerocore-fleet",
    name: "AeroCore Fleet",
    description: "Add a new drone to the fleet",
    userMessage: "Navigate to AeroCore Fleet and add a new drone with serial DR-001",
    expectedOutcome: { type: "text_present", value: "DR-001" },
    timeoutMs: 6e4
  },
  {
    id: "aerocore-workforce",
    name: "AeroCore Workforce",
    description: "Create a new employee profile",
    userMessage: "Go to AeroCore Workforce and create a new employee profile for Jane Doe",
    expectedOutcome: { type: "text_present", value: "Jane Doe" },
    timeoutMs: 6e4
  },
  {
    id: "aerocore-cargo",
    name: "AeroCore Cargo",
    description: "Create a new shipment",
    userMessage: "Navigate to AeroCore Cargo and create a new shipment with ID SH-9987",
    expectedOutcome: { type: "text_present", value: "SH-9987" },
    timeoutMs: 6e4
  },
  {
    id: "aerocore-security",
    name: "AeroCore Security",
    description: "Create a security incident report",
    userMessage: "Go to AeroCore Security and file a new security incident report",
    expectedOutcome: { type: "text_present", value: "Incident" },
    timeoutMs: 6e4
  },
  {
    id: "aerocore-admin",
    name: "AeroCore Admin",
    description: "Update system settings",
    userMessage: "Navigate to AeroCore Admin and update the system timezone to UTC",
    expectedOutcome: { type: "text_present", value: "UTC" },
    timeoutMs: 6e4
  },
  {
    id: "aerocore-portal",
    name: "AeroCore Portal",
    description: "Create a new portal announcement",
    userMessage: "Go to AeroCore Portal and create a new announcement about system maintenance",
    expectedOutcome: { type: "text_present", value: "maintenance" },
    timeoutMs: 6e4
  },
  {
    id: "aerocore-datalake",
    name: "AeroCore Datalake",
    description: "Run a data query",
    userMessage: "Navigate to AeroCore Datalake and run a query for recent logs",
    expectedOutcome: { type: "text_present", value: "logs" },
    timeoutMs: 6e4
  },
  // Personal Browser Scenarios
  {
    id: "personal-wikipedia",
    name: "Wikipedia Navigation",
    description: "Navigate to Wikipedia and find the Featured Article",
    userMessage: `Go to wikipedia.org and verify that the "From today's featured article" section is present.`,
    expectedOutcome: { type: "text_present", value: "From today's featured article" },
    timeoutMs: 6e4
  },
  {
    id: "personal-todomvc",
    name: "TodoMVC Interaction",
    description: "Add and complete tasks in a React Todo app",
    userMessage: 'Go to https://todomvc.com/examples/react/dist/. Add a new todo item called "Review Agent Performance" and then press Enter.',
    expectedOutcome: { type: "text_present", value: "Review Agent Performance" },
    timeoutMs: 6e4
  },
  {
    id: "personal-hn",
    name: "Hacker News Retrieval",
    description: "Navigate to Hacker News",
    userMessage: 'Go to news.ycombinator.com and find the "Hacker News" header.',
    expectedOutcome: { type: "text_present", value: "Hacker News" },
    timeoutMs: 45e3
  },
  {
    id: "personal-duckduckgo",
    name: "Search Engine Usage",
    description: "Search using DuckDuckGo",
    userMessage: 'Go to duckduckgo.com, type "Enterprise Browser" into the search box, and search.',
    expectedOutcome: { type: "url_match", value: "duckduckgo.com/?q=Enterprise+Browser" },
    timeoutMs: 6e4
  },
  // Advanced Scenarios
  {
    id: "advanced-cross-app",
    name: "Cross-App Workflow",
    description: "Information transfer between Apps",
    userMessage: 'Go to Jira, find "EB-1" issue, copy its description, and create a new page in Confluence called "Issue EB-1 Draft" with that description.',
    expectedOutcome: { type: "text_present", value: "EB-1" },
    timeoutMs: 12e4
  },
  {
    id: "skill-learning-cycle",
    name: "Skill Learning Cycle",
    description: "Save and reuse a skill",
    userMessage: 'Go to AeroCore Admin, find the "User Management" button, and click it. Then save this as a skill called "go_to_user_admin". Then use it.',
    expectedOutcome: { type: "text_present", value: "User Management" },
    timeoutMs: 9e4
  },
  {
    id: "disambiguation-logic",
    name: "Disambiguation Logic",
    description: "Handle ambiguous selectors",
    userMessage: 'In Jira, find the "Create" button. If there are multiple, click the one in the top navigation bar.',
    expectedOutcome: { type: "text_present", value: "Create Issue" },
    timeoutMs: 6e4
  },
  {
    id: "information-synthesis",
    name: "Information Synthesis",
    description: "Compare data from search",
    userMessage: "Compare the price of Bitcoin and Ethereum and tell me which one is higher.",
    expectedOutcome: { type: "text_present", value: "Bitcoin" },
    timeoutMs: 6e4
  }
];
class BenchmarkService {
  constructor() {
    __publicField2(this, "trajectory", []);
    __publicField2(this, "llmCalls", 0);
    __publicField2(this, "retries", 0);
    __publicField2(this, "planMemory", new PlanMemory());
    __publicField2(this, "autoLearnEnabled", false);
  }
  setAutoLearn(enabled) {
    this.autoLearnEnabled = enabled;
  }
  async runSuite(filter, enableActionsPolicy) {
    const scenarios = filter ? BENCHMARK_SUITE.filter((s) => s.id.includes(filter)) : BENCHMARK_SUITE;
    console.log(`[Benchmark] Starting suite with ${scenarios.length} scenarios (actionsPolicy=${enableActionsPolicy})...`);
    const results2 = [];
    for (const scenario of scenarios) {
      console.log(`[Benchmark] Running scenario: ${scenario.name} (${scenario.id})`);
      const result = await this.runScenario(scenario, enableActionsPolicy);
      results2.push(result);
      console.log(`[Benchmark] Scenario ${scenario.id} ${result.success ? "PASSED" : "FAILED"} in ${result.durationMs}ms (llmCalls=${result.llmCalls}, retries=${result.retries})`);
    }
    return results2;
  }
  async runScenario(scenario, enableActionsPolicy) {
    const runId = v4$2();
    const start = Date.now();
    this.trajectory = [];
    this.llmCalls = 0;
    this.retries = 0;
    const stepCollector = (step) => {
      var _a3;
      this.trajectory.push({
        ts: ((_a3 = step.metadata) == null ? void 0 : _a3.ts) ? new Date(step.metadata.ts).getTime() : Date.now(),
        type: step.type,
        content: step.content,
        metadata: step.metadata
      });
      if (step.type === "action" && step.content.includes("llm_start")) this.llmCalls++;
    };
    try {
      await agentService.resetConversation();
      agentService.toggleActionsPolicy(!!enableActionsPolicy);
      agentService.setStepHandler(stepCollector);
      await agentService.chat(scenario.userMessage);
      const success2 = await this.verifyOutcome(scenario);
      if (success2 && this.autoLearnEnabled) {
        const planSteps = this.extractPlanSteps(this.trajectory);
        if (planSteps.length > 0) {
          await this.planMemory.savePlan(scenario.id, planSteps);
          console.log(`[Benchmark] Auto-saved plan for ${scenario.id}`);
        }
      }
      return {
        scenarioId: scenario.id,
        success: success2,
        durationMs: Date.now() - start,
        steps: this.trajectory.length,
        llmCalls: this.llmCalls,
        retries: this.retries,
        runId,
        trajectory: [...this.trajectory]
      };
    } catch (e) {
      const errorMessage = e instanceof Error ? e.message : String(e);
      return {
        scenarioId: scenario.id,
        success: false,
        durationMs: Date.now() - start,
        steps: this.trajectory.length,
        llmCalls: this.llmCalls,
        retries: this.retries,
        error: errorMessage,
        runId,
        trajectory: [...this.trajectory]
      };
    } finally {
      agentService.clearStepHandler();
    }
  }
  extractPlanSteps(trajectory) {
    return trajectory.filter((e) => {
      var _a3;
      return e.type === "action" && ((_a3 = e.metadata) == null ? void 0 : _a3.tool);
    }).map((e) => {
      var _a3;
      const tool2 = (_a3 = e.metadata) == null ? void 0 : _a3.tool;
      const content = e.content || "";
      return `${tool2}: ${content.replace(/^Executing\s+/i, "").substring(0, 100)}`;
    });
  }
  extractNormalizedPlan(trajectory) {
    const toolCalls = trajectory.filter((e) => {
      var _a3;
      return e.type === "action" && ((_a3 = e.metadata) == null ? void 0 : _a3.tool);
    });
    return toolCalls.map((e) => {
      var _a3, _b;
      const args = ((_a3 = e.metadata) == null ? void 0 : _a3.toolArgs) ?? {};
      return {
        tool: (_b = e.metadata) == null ? void 0 : _b.tool,
        args,
        ts: e.ts
      };
    });
  }
  extractFeedbackLabels(trajectory) {
    return trajectory.filter((e) => {
      var _a3;
      return e.type === "observation" && ((_a3 = e.content) == null ? void 0 : _a3.includes("Recorded"));
    }).map((e) => {
      var _a3;
      const m = (_a3 = e.content) == null ? void 0 : _a3.match(/Recorded (worked|failed|partial)/i);
      return m ? m[1].toLowerCase() : void 0;
    }).filter(Boolean);
  }
  async exportTrajectories(results2) {
    var _a3, _b;
    const exportDir = path__default$1.join(app$1.getPath("userData"), "benchmark_datasets");
    await fs$3.mkdir(exportDir, { recursive: true });
    const timestamp = (/* @__PURE__ */ new Date()).toISOString().replace(/[:.]/g, "-");
    const filePath = path__default$1.join(exportDir, `trajectories_${timestamp}.jsonl`);
    const lines = [];
    for (const r of results2) {
      if (!r.trajectory) continue;
      const normalizedPlan = this.extractNormalizedPlan(r.trajectory);
      const feedbackLabels = this.extractFeedbackLabels(r.trajectory);
      const firstUrl = (_b = (_a3 = r.trajectory.find((e) => {
        var _a4;
        return (_a4 = e.metadata) == null ? void 0 : _a4.url;
      })) == null ? void 0 : _a3.metadata) == null ? void 0 : _b.url;
      const domain = (() => {
        if (!firstUrl) return "unknown";
        try {
          return new URL(firstUrl).hostname;
        } catch {
          return "unknown";
        }
      })();
      const fingerprint = (() => {
        if (!firstUrl) return void 0;
        try {
          return new URL(firstUrl).pathname;
        } catch {
          return void 0;
        }
      })();
      const record2 = {
        scenarioId: r.scenarioId,
        runId: r.runId,
        domain,
        fingerprint,
        normalizedPlan,
        steps: r.trajectory,
        outcome: r.success ? "success" : "failure",
        success: r.success,
        durationMs: r.durationMs,
        llmCalls: r.llmCalls,
        retries: r.retries,
        feedbackLabels
      };
      lines.push(JSON.stringify(record2));
    }
    await fs$3.writeFile(filePath, lines.join("\n"), "utf8");
    console.log(`[Benchmark] Exported ${results2.length} trajectories to ${filePath}`);
    return filePath;
  }
  async verifyOutcome(scenario) {
    const target = await browserAutomationService.getTarget();
    if (scenario.expectedOutcome.type === "text_present") {
      const found = await target.executeJavaScript(
        `document.body.innerText.includes(${JSON.stringify(scenario.expectedOutcome.value)})`,
        true
      );
      return Boolean(found);
    }
    if (scenario.expectedOutcome.type === "url_match") {
      const url = await target.getURL();
      return url.includes(scenario.expectedOutcome.value);
    }
    return false;
  }
}
const benchmarkService = new BenchmarkService();
function clamp(n, min, max) {
  return Math.max(min, Math.min(max, n));
}
function formatPct(n) {
  return `${Math.round(n)}%`;
}
function formatDelta(n, unit) {
  const sign = n > 0 ? "+" : "";
  return `${sign}${n}${unit}`;
}
function uid(prefix) {
  return `${prefix}_${Math.random().toString(36).slice(2, 10)}`;
}
class DummyAeroCoreDataSource {
  constructor() {
    __publicField2(this, "ts", Date.now());
    __publicField2(this, "openOrders", 42);
    __publicField2(this, "slaBreaches", 3);
    __publicField2(this, "fleetUtil", 78);
    __publicField2(this, "activeIncidents", 1);
    __publicField2(this, "last", {
      openOrders: this.openOrders,
      slaBreaches: this.slaBreaches,
      fleetUtil: this.fleetUtil,
      activeIncidents: this.activeIncidents
    });
    __publicField2(this, "events", []);
    __publicField2(this, "reasoning", []);
  }
  async getSnapshot() {
    return this.buildSnapshot();
  }
  async tick() {
    this.ts = Date.now();
    this.openOrders = clamp(this.openOrders + this.randInt(-2, 4), 10, 140);
    this.slaBreaches = clamp(this.slaBreaches + this.randInt(-1, 2), 0, 20);
    this.fleetUtil = clamp(this.fleetUtil + this.randInt(-2, 2), 40, 98);
    this.activeIncidents = clamp(this.activeIncidents + this.randInt(-1, 1), 0, 6);
    if (Math.random() < 0.55) {
      this.events.unshift(this.makeEvent());
      this.events = this.events.slice(0, 8);
    }
    const deltas = {
      openOrders: this.openOrders - this.last.openOrders,
      slaBreaches: this.slaBreaches - this.last.slaBreaches,
      fleetUtil: this.fleetUtil - this.last.fleetUtil,
      activeIncidents: this.activeIncidents - this.last.activeIncidents
    };
    const reasoningMd = this.makeReasoning(deltas);
    if (reasoningMd) {
      this.reasoning.unshift({ id: uid("r"), ts: this.ts, markdown: reasoningMd });
      this.reasoning = this.reasoning.slice(0, 10);
    }
    this.last = {
      openOrders: this.openOrders,
      slaBreaches: this.slaBreaches,
      fleetUtil: this.fleetUtil,
      activeIncidents: this.activeIncidents
    };
    return this.buildSnapshot();
  }
  buildSnapshot() {
    const kpis = [
      {
        id: "open_orders",
        label: "Open Orders",
        value: String(this.openOrders),
        delta: formatDelta(this.openOrders - this.last.openOrders, "")
      },
      {
        id: "fleet_util",
        label: "Fleet Utilization",
        value: formatPct(this.fleetUtil),
        delta: formatDelta(this.fleetUtil - this.last.fleetUtil, "pp")
      },
      {
        id: "sla_breaches",
        label: "SLA Breaches",
        value: String(this.slaBreaches),
        delta: formatDelta(this.slaBreaches - this.last.slaBreaches, "")
      },
      {
        id: "active_incidents",
        label: "Active Incidents",
        value: String(this.activeIncidents),
        delta: formatDelta(this.activeIncidents - this.last.activeIncidents, "")
      }
    ];
    return {
      ts: this.ts,
      kpis,
      events: this.events,
      reasoning: this.reasoning
    };
  }
  randInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }
  makeEvent() {
    const choices = [
      {
        title: "Dispatch backlog rebalanced",
        detail: "Reassigned 6 loads from ATL to DAL to reduce spillover.",
        severity: "info"
      },
      {
        title: "Carrier ETA drift detected",
        detail: "2 shipments trending late (>35m). Consider proactive reroute.",
        severity: "warn"
      },
      {
        title: "SLA breach risk rising",
        detail: "Queue depth increased on inbound dock; validate staffing plan.",
        severity: "warn"
      },
      {
        title: "Incident: Telemetry ingest lag",
        detail: "Event stream delay ~3m; dashboards may be stale.",
        severity: "critical"
      },
      {
        title: "Fleet utilization stabilized",
        detail: "Idle time reduced across Zone 3; keep monitoring.",
        severity: "info"
      }
    ];
    const base = choices[Math.floor(Math.random() * choices.length)];
    return { id: uid("e"), ts: this.ts, ...base };
  }
  makeReasoning(d) {
    const lines = [];
    if (d.openOrders >= 3) {
      lines.push(`- **Signal**: Open orders spiked (${d.openOrders} net).`);
      lines.push(`  - **Hypothesis**: Dispatch throughput < intake (check staffing + carrier acceptance).`);
      lines.push(`  - **Next**: Prioritize high-SLA lanes; batch low-risk loads.`);
    }
    if (d.slaBreaches > 0) {
      lines.push(`- **Risk**: SLA breaches increased (+${d.slaBreaches}).`);
      lines.push(`  - **Next**: Trigger proactive notifications; escalate only critical routes.`);
    }
    if (d.activeIncidents > 0) {
      lines.push(`- **Incident**: New incident(s) detected (+${d.activeIncidents}).`);
      lines.push(`  - **Next**: Freeze non-essential workflow changes; validate telemetry pipeline.`);
    }
    if (d.fleetUtil <= -2) {
      lines.push(`- **Signal**: Fleet utilization dropped (${d.fleetUtil}pp).`);
      lines.push(`  - **Hypothesis**: Route fragmentation or staging delays.`);
      lines.push(`  - **Next**: Consolidate loads; adjust zone boundaries.`);
    }
    if (lines.length === 0) {
      if (Math.random() < 0.35) {
        return `- **Steady state**: No major anomalies.
  - **Next**: Keep monitoring lane-level SLA drift.`;
      }
      return "";
    }
    return lines.join("\n");
  }
}
class NewTabDashboardService {
  constructor(source) {
    __publicField2(this, "source");
    __publicField2(this, "snapshot");
    this.source = source;
    this.snapshot = { ts: Date.now(), kpis: [], events: [], reasoning: [] };
  }
  async init() {
    this.snapshot = await this.source.getSnapshot();
  }
  getSnapshot() {
    return this.snapshot;
  }
  async tick() {
    this.snapshot = await this.source.tick();
    return this.snapshot;
  }
}
const MAX_FILES_DEFAULT = 2e3;
const MAX_FILE_BYTES_DEFAULT = 2e5;
const IGNORE_DIRS = /* @__PURE__ */ new Set([
  "node_modules",
  ".git",
  "dist",
  "build",
  ".next",
  ".turbo",
  ".cache"
]);
const isPathInside = (child, parent) => {
  const rel = path__default$1.relative(parent, child);
  return rel === "" || !rel.startsWith(".." + path__default$1.sep) && rel !== "..";
};
class CodeReaderService {
  constructor() {
    __publicField2(this, "mockSaasSrcRoot", null);
    __publicField2(this, "mockSaasSrcRootReal", null);
    this.registerTools();
  }
  async pathExists(p) {
    try {
      await fs$3.stat(p);
      return true;
    } catch {
      return false;
    }
  }
  async getMockSaasSrcRoot() {
    if (this.mockSaasSrcRoot && this.mockSaasSrcRootReal) {
      return { root: this.mockSaasSrcRoot, rootReal: this.mockSaasSrcRootReal };
    }
    const candidates = [];
    candidates.push(process.cwd());
    candidates.push(path__default$1.dirname(process.cwd()));
    candidates.push(path__default$1.dirname(path__default$1.dirname(process.cwd())));
    try {
      candidates.push(app$1.getAppPath());
      candidates.push(path__default$1.dirname(app$1.getAppPath()));
      candidates.push(path__default$1.dirname(path__default$1.dirname(app$1.getAppPath())));
    } catch {
    }
    for (const base of candidates) {
      const p = path__default$1.resolve(base, "mock-saas", "src");
      if (await this.pathExists(p)) {
        const real = await fs$3.realpath(p);
        this.mockSaasSrcRoot = p;
        this.mockSaasSrcRootReal = real;
        return { root: p, rootReal: real };
      }
    }
    throw new Error(
      "mock-saas/src not found. This white-box tool only works when the repo contains mock-saas/src."
    );
  }
  normalizeUserPath(inputPath) {
    const p = inputPath.replace(/\\/g, "/").trim();
    const stripped = p.replace(/^(\.\/)+/, "").replace(/^\/+/, "").replace(/^mock-saas\/src\//, "").replace(/^mock-saas\//, "").replace(/^src\//, "");
    return stripped;
  }
  async resolvePathWithinMockSaasSrc(inputPath) {
    const { rootReal } = await this.getMockSaasSrcRoot();
    const rel = this.normalizeUserPath(inputPath);
    const resolved = path__default$1.resolve(rootReal, rel);
    if (!isPathInside(resolved, rootReal)) {
      throw new Error("Path escapes mock-saas/src. Access denied.");
    }
    return resolved;
  }
  async listFilesRecursive(dir, maxFiles, out, baseReal) {
    if (out.length >= maxFiles) return;
    const entries = await fs$3.readdir(dir, { withFileTypes: true });
    for (const entry of entries) {
      if (out.length >= maxFiles) return;
      if (entry.name.startsWith(".")) continue;
      if (IGNORE_DIRS.has(entry.name)) continue;
      const full = path__default$1.join(dir, entry.name);
      let real;
      try {
        real = await fs$3.realpath(full);
      } catch {
        continue;
      }
      if (!isPathInside(real, baseReal)) continue;
      if (entry.isDirectory()) {
        await this.listFilesRecursive(real, maxFiles, out, baseReal);
      } else if (entry.isFile()) {
        out.push(real);
      }
    }
  }
  registerTools() {
    const listSchema = object({
      dir: string().optional().describe('Directory within mock-saas/src to list (default: ".")'),
      maxFiles: number().int().min(1).max(5e3).optional().describe("Max files to return (default 500)")
    });
    const listTool = {
      name: "code_list_files",
      description: "List files under mock-saas/src (white-box access). Ignores node_modules/dist. Returns paths relative to mock-saas/src.",
      schema: listSchema,
      execute: async (args) => {
        const { dir, maxFiles } = listSchema.parse(args ?? {});
        const { rootReal } = await this.getMockSaasSrcRoot();
        const resolvedDir = await this.resolvePathWithinMockSaasSrc(dir ?? ".");
        const filesReal = [];
        await this.listFilesRecursive(resolvedDir, maxFiles ?? 500, filesReal, rootReal);
        const files = filesReal.map((p) => path__default$1.relative(rootReal, p).replace(/\\/g, "/")).sort();
        return JSON.stringify(
          {
            root: "mock-saas/src",
            dir: (dir ?? ".").replace(/\\/g, "/"),
            count: files.length,
            files
          },
          null,
          2
        );
      }
    };
    const readSchema = object({
      path: string().describe('File path within mock-saas/src (e.g. "pages/jira/JiraPage.tsx")'),
      startLine: number().int().min(1).optional().describe("Start line (1-based)"),
      maxLines: number().int().min(1).max(2e3).optional().describe("Max lines to return (default 200)"),
      maxBytes: number().int().min(1).max(2e6).optional().describe("Max bytes to read (default 200k)")
    });
    const readTool = {
      name: "code_read_file",
      description: "Read a file from mock-saas/src (white-box access). Use this to discover data-testid selectors and UI state logic.",
      schema: readSchema,
      execute: async (args) => {
        const { path: filePath, startLine, maxLines, maxBytes } = readSchema.parse(args);
        const { rootReal } = await this.getMockSaasSrcRoot();
        const resolved = await this.resolvePathWithinMockSaasSrc(filePath);
        const stat = await fs$3.stat(resolved);
        if (!stat.isFile()) throw new Error("Not a file.");
        if (stat.size > (maxBytes ?? MAX_FILE_BYTES_DEFAULT)) {
          throw new Error(
            `File too large (${stat.size} bytes). Increase maxBytes (<=2,000,000) or read a smaller file.`
          );
        }
        const raw = await fs$3.readFile(resolved, "utf8");
        const lines = raw.split(/\r?\n/);
        const totalLines = lines.length;
        const start = Math.max(1, startLine ?? 1);
        const max = maxLines ?? 200;
        const end = Math.min(totalLines, start + max - 1);
        const content = lines.slice(start - 1, end).join("\n");
        return JSON.stringify(
          {
            root: "mock-saas/src",
            path: path__default$1.relative(rootReal, resolved).replace(/\\/g, "/"),
            totalLines,
            startLine: start,
            endLine: end,
            content
          },
          null,
          2
        );
      }
    };
    const searchSchema = object({
      query: string().min(1).describe("Text to search for"),
      dir: string().optional().describe('Directory within mock-saas/src to search (default ".")'),
      maxResults: number().int().min(1).max(200).optional().describe("Max matches to return (default 20)"),
      caseSensitive: boolean().optional().describe("Case-sensitive search (default false)"),
      maxFiles: number().int().min(1).max(5e3).optional().describe("Max files to scan (default 2000)")
    });
    const searchTool = {
      name: "code_search",
      description: "Search for text within mock-saas/src (white-box access). Returns file/line previews to quickly find relevant components.",
      schema: searchSchema,
      execute: async (args) => {
        const { query, dir, maxResults, caseSensitive, maxFiles } = searchSchema.parse(args);
        const { rootReal } = await this.getMockSaasSrcRoot();
        const resolvedDir = await this.resolvePathWithinMockSaasSrc(dir ?? ".");
        const filesReal = [];
        await this.listFilesRecursive(resolvedDir, maxFiles ?? MAX_FILES_DEFAULT, filesReal, rootReal);
        const needle = caseSensitive ? query : query.toLowerCase();
        const limit2 = maxResults ?? 20;
        const matches = [];
        for (const fileReal of filesReal) {
          if (matches.length >= limit2) break;
          let stat;
          try {
            stat = await fs$3.stat(fileReal);
          } catch {
            continue;
          }
          if (!stat.isFile()) continue;
          if (stat.size > MAX_FILE_BYTES_DEFAULT * 2) continue;
          let raw;
          try {
            raw = await fs$3.readFile(fileReal, "utf8");
          } catch {
            continue;
          }
          const lines = raw.split(/\r?\n/);
          for (let i2 = 0; i2 < lines.length; i2++) {
            if (matches.length >= limit2) break;
            const hay = caseSensitive ? lines[i2] : lines[i2].toLowerCase();
            if (!hay.includes(needle)) continue;
            matches.push({
              path: path__default$1.relative(rootReal, fileReal).replace(/\\/g, "/"),
              line: i2 + 1,
              preview: lines[i2].trim().slice(0, 200)
            });
          }
        }
        return JSON.stringify(
          {
            root: "mock-saas/src",
            dir: (dir ?? ".").replace(/\\/g, "/"),
            query,
            count: matches.length,
            matches
          },
          null,
          2
        );
      }
    };
    toolRegistry.register(listTool);
    toolRegistry.register(readTool);
    toolRegistry.register(searchTool);
  }
}
new CodeReaderService();
class MockJiraConnector {
  constructor() {
    __publicField2(this, "issues", [
      {
        key: "PROJ-1",
        summary: "Fix login page layout",
        description: "The login button is misaligned on mobile devices.",
        status: "To Do",
        assignee: "jdoe"
      },
      {
        key: "PROJ-2",
        summary: "Update API documentation",
        description: "The /v2/users endpoint docs are outdated.",
        status: "In Progress",
        assignee: "smitchell"
      },
      {
        key: "PROJ-3",
        summary: "Investigate server crash",
        description: "Server 3 crashed with OOM error last night.",
        status: "Done",
        assignee: "jdoe"
      }
    ]);
    this.registerTools();
  }
  async simulateDelay() {
    await new Promise((resolve) => setTimeout(resolve, 500));
  }
  registerTools() {
    const listIssuesTool = {
      name: "jira_list_issues",
      description: "List all Jira issues, optionally filtered by status.",
      schema: object({
        status: string().optional().describe("Filter by status (To Do, In Progress, Done)")
      }),
      execute: async ({ status }) => {
        await this.simulateDelay();
        let results2 = this.issues;
        if (status) {
          results2 = results2.filter((i2) => i2.status.toLowerCase() === status.toLowerCase());
        }
        return JSON.stringify(results2, null, 2);
      }
    };
    const getIssueTool = {
      name: "jira_get_issue",
      description: "Get details of a specific Jira issue by key.",
      schema: object({
        key: string().describe("The issue key (e.g., PROJ-1)")
      }),
      execute: async ({ key }) => {
        await this.simulateDelay();
        const issue2 = this.issues.find((i2) => i2.key === key);
        if (!issue2) return `Issue ${key} not found.`;
        return JSON.stringify(issue2, null, 2);
      }
    };
    const createIssueTool = {
      name: "jira_create_issue",
      description: "Create a new Jira issue.",
      requiresApproval: true,
      schema: object({
        summary: string().describe("The issue summary/title"),
        description: string().describe("The issue description"),
        assignee: string().optional().describe("The user to assign the issue to")
      }),
      execute: async ({ summary, description, assignee }) => {
        await this.simulateDelay();
        const newKey = `PROJ-${this.issues.length + 1}`;
        const newIssue = {
          key: newKey,
          summary,
          description,
          status: "To Do",
          assignee: assignee || "unassigned"
        };
        this.issues.push(newIssue);
        return `Successfully created issue ${newKey}`;
      }
    };
    toolRegistry.register(listIssuesTool);
    toolRegistry.register(getIssueTool);
    toolRegistry.register(createIssueTool);
  }
}
new MockJiraConnector();
class MockConfluenceConnector {
  constructor() {
    __publicField2(this, "pages", [
      {
        id: "1001",
        title: "Project Phoenix Architecture",
        space: "ENG",
        content: "Project Phoenix aims to unify the browser experience. Key components: Electron, React, LangChain.",
        lastUpdated: "2023-10-01"
      },
      {
        id: "1002",
        title: "Q4 Marketing Strategy",
        space: "MKT",
        content: "Focus on enterprise decision makers. Channels: LinkedIn, TechCrunch, Industry Events.",
        lastUpdated: "2023-10-15"
      },
      {
        id: "1003",
        title: "Employee Onboarding Guide",
        space: "HR",
        content: "Welcome to the team! 1. Setup email. 2. Join Slack. 3. Read the handbook.",
        lastUpdated: "2023-09-20"
      }
    ]);
    this.registerTools();
  }
  async simulateDelay() {
    await new Promise((resolve) => setTimeout(resolve, 500));
  }
  registerTools() {
    const searchPagesTool = {
      name: "confluence_search",
      description: "Search for Confluence pages by title or content.",
      schema: object({
        query: string().describe("Search query string")
      }),
      execute: async ({ query }) => {
        await this.simulateDelay();
        const lowerQuery = query.toLowerCase();
        const results2 = this.pages.filter(
          (p) => p.title.toLowerCase().includes(lowerQuery) || p.content.toLowerCase().includes(lowerQuery)
        ).map(({ content, ...rest }) => rest);
        return JSON.stringify(results2, null, 2);
      }
    };
    const readPageTool = {
      name: "confluence_read_page",
      description: "Read the full content of a Confluence page.",
      schema: object({
        id: string().describe("The page ID (e.g., 1001)")
      }),
      execute: async ({ id }) => {
        await this.simulateDelay();
        const page = this.pages.find((p) => p.id === id);
        if (!page) return `Page ${id} not found.`;
        return JSON.stringify(page, null, 2);
      }
    };
    const createPageTool = {
      name: "confluence_create_page",
      description: "Create a new Confluence page.",
      schema: object({
        title: string().describe("Page title"),
        space: string().describe("Space key (e.g. ENG, HR)"),
        content: string().describe("Page content")
      }),
      execute: async ({ title, space, content }) => {
        await this.simulateDelay();
        const newId = (1e3 + this.pages.length + 1).toString();
        this.pages.push({
          id: newId,
          title,
          space,
          content,
          lastUpdated: (/* @__PURE__ */ new Date()).toISOString().split("T")[0]
        });
        return `Created page ${newId}: "${title}" in space ${space}`;
      }
    };
    toolRegistry.register(searchPagesTool);
    toolRegistry.register(readPageTool);
    toolRegistry.register(createPageTool);
  }
}
new MockConfluenceConnector();
class MockTrelloConnector {
  constructor() {
    __publicField2(this, "boards", [
      {
        id: "board-1",
        name: "Product Roadmap",
        lists: [
          { id: "list-1", name: "Backlog" },
          { id: "list-2", name: "Doing" },
          { id: "list-3", name: "Done" }
        ],
        cards: [
          { id: "card-1", title: "Research competitors", listId: "list-1" },
          { id: "card-2", title: "Design new logo", listId: "list-2" }
        ]
      }
    ]);
    this.registerTools();
  }
  async simulateDelay() {
    await new Promise((resolve) => setTimeout(resolve, 500));
  }
  registerTools() {
    const getBoardTool = {
      name: "trello_get_board",
      description: "Get details of a Trello board, including lists and cards.",
      schema: object({
        id: string().describe("The board ID (e.g., board-1)")
      }),
      execute: async ({ id }) => {
        await this.simulateDelay();
        const board = this.boards.find((b) => b.id === id);
        if (!board) return `Board ${id} not found.`;
        return JSON.stringify(board, null, 2);
      }
    };
    const moveCardTool = {
      name: "trello_move_card",
      description: "Move a Trello card to a different list.",
      schema: object({
        cardId: string().describe("The ID of the card to move"),
        targetListId: string().describe("The ID of the destination list")
      }),
      execute: async ({ cardId, targetListId }) => {
        await this.simulateDelay();
        for (const board of this.boards) {
          const card = board.cards.find((c) => c.id === cardId);
          if (card) {
            const listExists = board.lists.some((l) => l.id === targetListId);
            if (!listExists) return `List ${targetListId} not found on this board.`;
            card.listId = targetListId;
            return `Successfully moved card ${cardId} to list ${targetListId}`;
          }
        }
        return `Card ${cardId} not found.`;
      }
    };
    const createCardTool = {
      name: "trello_create_card",
      description: "Create a new Trello card.",
      schema: object({
        boardId: string().describe("Board ID"),
        listId: string().describe("List ID"),
        title: string().describe("Card title")
      }),
      execute: async ({ boardId, listId, title }) => {
        await this.simulateDelay();
        const board = this.boards.find((b) => b.id === boardId);
        if (!board) return `Board ${boardId} not found`;
        const list = board.lists.find((l) => l.id === listId);
        if (!list) return `List ${listId} not found`;
        const newCardId = `card-${Date.now()}`;
        board.cards.push({ id: newCardId, title, listId });
        return `Created card ${newCardId}: "${title}" in list ${list.name}`;
      }
    };
    toolRegistry.register(getBoardTool);
    toolRegistry.register(moveCardTool);
    toolRegistry.register(createCardTool);
  }
}
new MockTrelloConnector();
class CodeExecutionService {
  constructor() {
    this.registerTools();
  }
  registerTools() {
    const executeCodeSchema = object({
      code: string().describe(`JavaScript code to execute. Must be an async function body that returns a result. Has access to: fetch, JSON, console.log, setTimeout. Example: "const res = await fetch('https://api.example.com/data'); const data = await res.json(); return data;"`),
      description: string().optional().describe("Brief description of what this code does (for logging)")
    });
    const executeCodeTool = {
      name: "execute_code",
      description: `Execute JavaScript code to call APIs, process data, or perform calculations. Use this when no existing tool fits your needs. The code runs in a sandboxed environment with access to fetch() for HTTP requests. 
      
EXAMPLES:
1. Weather API (Open-Meteo, free, no key):
   const res = await fetch('https://api.open-meteo.com/v1/forecast?latitude=40.71&longitude=-74.01&current=temperature_2m');
   const data = await res.json();
   return { temperature: data.current.temperature_2m, unit: data.current_units.temperature_2m };

2. Any JSON API:
   const res = await fetch('https://api.example.com/data');
   return await res.json();

3. Data processing:
   const numbers = [1, 2, 3, 4, 5];
   return { sum: numbers.reduce((a, b) => a + b, 0), avg: numbers.reduce((a, b) => a + b, 0) / numbers.length };`,
      schema: executeCodeSchema,
      execute: async ({ code: code2, description }) => {
        try {
          console.log(`[CodeExecution] Running: ${description || "custom code"}`);
          const sandbox = {
            fetch: globalThis.fetch,
            JSON,
            console: {
              log: (...args) => console.log("[CodeExecution]", ...args),
              error: (...args) => console.error("[CodeExecution]", ...args)
            },
            setTimeout,
            Promise,
            Array,
            Object,
            String,
            Number,
            Boolean,
            Date,
            Math,
            encodeURIComponent,
            decodeURIComponent,
            URL,
            URLSearchParams
          };
          vm.createContext(sandbox);
          const wrappedCode = `
            (async () => {
              ${code2}
            })()
          `;
          const result = await vm.runInContext(wrappedCode, sandbox, {
            timeout: 3e4
            // 30 second timeout
          });
          if (result === void 0) {
            return JSON.stringify({ success: true, result: null });
          }
          if (typeof result === "object") {
            return JSON.stringify(result, null, 2);
          }
          return String(result);
        } catch (error) {
          console.error("[CodeExecution] Error:", error.message);
          return JSON.stringify({
            error: error.message,
            hint: "Check your code syntax and ensure APIs are accessible. Use try/catch for better error handling."
          });
        }
      }
    };
    const cityCoordinatesSchema = object({
      city: string().describe('City name (e.g., "New York", "Los Angeles", "Tokyo")')
    });
    const cityCoordinatesTool = {
      name: "lookup_city_coordinates",
      description: "Get latitude/longitude for a city. Useful for weather APIs that need coordinates.",
      schema: cityCoordinatesSchema,
      execute: async ({ city }) => {
        const cities = {
          "new york": { lat: 40.7128, lon: -74.006 },
          "los angeles": { lat: 34.0522, lon: -118.2437 },
          "chicago": { lat: 41.8781, lon: -87.6298 },
          "houston": { lat: 29.7604, lon: -95.3698 },
          "phoenix": { lat: 33.4484, lon: -112.074 },
          "san francisco": { lat: 37.7749, lon: -122.4194 },
          "seattle": { lat: 47.6062, lon: -122.3321 },
          "miami": { lat: 25.7617, lon: -80.1918 },
          "boston": { lat: 42.3601, lon: -71.0589 },
          "denver": { lat: 39.7392, lon: -104.9903 },
          "london": { lat: 51.5074, lon: -0.1278 },
          "paris": { lat: 48.8566, lon: 2.3522 },
          "tokyo": { lat: 35.6762, lon: 139.6503 },
          "sydney": { lat: -33.8688, lon: 151.2093 },
          "berlin": { lat: 52.52, lon: 13.405 }
        };
        const normalized = city.toLowerCase().trim();
        const coords = cities[normalized];
        if (coords) {
          return JSON.stringify({ city, latitude: coords.lat, longitude: coords.lon });
        }
        return JSON.stringify({
          error: `City '${city}' not in cache. Use execute_code to call a geocoding API like: fetch('https://geocoding-api.open-meteo.com/v1/search?name=${encodeURIComponent(city)}&count=1')`
        });
      }
    };
    toolRegistry.register(executeCodeTool);
    toolRegistry.register(cityCoordinatesTool);
  }
}
new CodeExecutionService();
const DOM_EXTRACTION_SCRIPT = `
(function() {
  const startTime = performance.now();
  
  // Aggressive limits for token efficiency
  const MAX_TEXT = 60;
  const MAX_BUTTONS = 20;
  const MAX_LINKS = 30;
  const MAX_INPUTS = 20;
  const MAX_SELECTS = 10;
  const MAX_CONTENT = 50;
  
  // Viewport bounds for visibility check
  const vw = window.innerWidth;
  const vh = window.innerHeight;
  
  // Fast visibility check (avoid getComputedStyle when possible)
  function isVisible(el) {
    if (!el || el.offsetParent === null) return false;
    const r = el.getBoundingClientRect();
    // Skip zero-size and off-screen elements
    if (r.width === 0 || r.height === 0) return false;
    // Skip elements far off-screen (allow some buffer)
    if (r.bottom < -100 || r.top > vh + 500 || r.right < -100 || r.left > vw + 100) return false;
    return true;
  }
  
  // Fast text extraction with aggressive truncation
  function getText(el) {
    if (!el) return undefined;
    // Prefer aria-label or title for buttons/links
    const label = el.getAttribute('aria-label') || el.title;
    if (label) return label.slice(0, MAX_TEXT).trim() || undefined;
    // Get innerText (faster than traversing childNodes)
    const t = (el.innerText || el.textContent || '').trim().replace(/\\s+/g, ' ');
    return t ? t.slice(0, MAX_TEXT) : undefined;
  }
  
  // Compact element extraction - only essential attributes
  function extract(el) {
    const tag = el.tagName.toLowerCase();
    const r = { t: tag };
    
    // Priority: data-testid > id > name (for selectors)
    const testId = el.getAttribute('data-testid');
    if (testId) { r.d = testId; }
    else if (el.id) { r.i = el.id; }
    else if (el.name) { r.n = el.name; }
    
    // Text content
    const text = getText(el);
    if (text) r.x = text;
    
    // Type-specific attributes
    if (tag === 'a' && el.href) {
      // Shorten URLs - just path for same-origin
      try {
        const u = new URL(el.href);
        r.h = u.origin === location.origin ? u.pathname + u.search : el.href;
      } catch { r.h = el.href; }
    }
    if (tag === 'input') {
      if (el.type && el.type !== 'text') r.y = el.type;
      if (el.placeholder) r.p = el.placeholder.slice(0, 30);
    }
    if (el.getAttribute('role')) r.r = el.getAttribute('role');
    
    return r;
  }
  
  // Deduplicate similar elements (e.g., repeated list items)
  function dedupeByText(elements) {
    const seen = new Set();
    const result = [];
    for (const el of elements) {
      const key = el.x || el.d || el.i || '';
      if (key && seen.has(key)) continue;
      if (key) seen.add(key);
      result.push(el);
    }
    return result;
  }
  
  // Collect interactive elements with priority scoring
  function collectInteractive() {
    const buttons = [], links = [], inputs = [], selects = [];
    
    // Buttons - prioritize visible, with text
    for (const el of document.querySelectorAll('button, [role="button"], input[type="submit"], input[type="button"]')) {
      if (buttons.length >= MAX_BUTTONS) break;
      if (!isVisible(el)) continue;
      const e = extract(el);
      if (e.x || e.d || e.i) buttons.push(e);
    }
    
    // Links - prioritize navigation, skip repetitive
    const linkSet = new Set();
    for (const el of document.querySelectorAll('a[href]')) {
      if (links.length >= MAX_LINKS) break;
      if (!isVisible(el)) continue;
      // Skip duplicate hrefs
      if (linkSet.has(el.href)) continue;
      linkSet.add(el.href);
      const e = extract(el);
      if (e.x || e.d || e.i) links.push(e);
    }
    
    // Inputs - all visible
    for (const el of document.querySelectorAll('input:not([type="hidden"]), textarea')) {
      if (inputs.length >= MAX_INPUTS) break;
      if (!isVisible(el)) continue;
      inputs.push(extract(el));
    }
    
    // Selects
    for (const el of document.querySelectorAll('select')) {
      if (selects.length >= MAX_SELECTS) break;
      if (!isVisible(el)) continue;
      selects.push(extract(el));
    }
    
    return { b: buttons, l: links, i: inputs, s: selects };
  }
  
  // Collect important content areas (headings, key text)
  function collectContent() {
    const content = [];
    
    // Find main content area
    const main = document.querySelector('main, [role="main"], article, #content, .content, #main');
    const scope = main || document.body;
    
    // Headings are high priority
    for (const el of scope.querySelectorAll('h1, h2, h3')) {
      if (content.length >= 10) break;
      if (!isVisible(el)) continue;
      const e = extract(el);
      if (e.x) content.push(e);
    }
    
    // Key content indicators
    for (const el of scope.querySelectorAll('[data-testid], [role="listitem"], .product, .item, .card, .result')) {
      if (content.length >= MAX_CONTENT) break;
      if (!isVisible(el)) continue;
      const e = extract(el);
      if (e.x || e.d) content.push(e);
    }
    
    return dedupeByText(content);
  }
  
  // Build result
  const ie = collectInteractive();
  const mc = collectContent();
  const metaDesc = document.querySelector('meta[name="description"]');
  
  const result = {
    u: location.href,
    t: document.title || '',
    m: metaDesc ? metaDesc.getAttribute('content')?.slice(0, 150) : undefined,
    ie,
    mc,
    _ms: Math.round(performance.now() - startTime)
  };
  
  return result;
})();
`;
const _DOMContextService = class _DOMContextService {
  /**
   * Expand compact element to full DOMElement
   */
  expandElement(compact) {
    const el = { tag: compact.t };
    if (compact.d) el.dataTestId = compact.d;
    if (compact.i) el.id = compact.i;
    if (compact.n) el.name = compact.n;
    if (compact.x) el.text = compact.x;
    if (compact.h) el.href = compact.h;
    if (compact.y) el.type = compact.y;
    if (compact.p) el.placeholder = compact.p;
    if (compact.r) el.role = compact.r;
    return el;
  }
  /**
   * Expand compact result to full DOMContext
   */
  expandResult(compact) {
    return {
      url: compact.u,
      title: compact.t,
      metaDescription: compact.m,
      interactiveElements: {
        buttons: compact.ie.b.map((e) => this.expandElement(e)),
        links: compact.ie.l.map((e) => this.expandElement(e)),
        inputs: compact.ie.i.map((e) => this.expandElement(e)),
        selects: compact.ie.s.map((e) => this.expandElement(e))
      },
      mainContent: compact.mc.map((e) => this.expandElement(e)),
      tokenEstimate: 0,
      truncated: false
    };
  }
  /**
   * Extract DOM context from the active webview
   */
  async getContext(tabId) {
    const wc = tabId ? browserTargetService.getWebContents(tabId) : browserTargetService.getActiveWebContents();
    if (!wc || wc.isDestroyed()) {
      throw new Error("No active webview available");
    }
    try {
      const compactResult = await wc.executeJavaScript(DOM_EXTRACTION_SCRIPT);
      console.log(`[DOMContext] Extracted in ${compactResult._ms}ms`);
      const result = this.expandResult(compactResult);
      const jsonStr = JSON.stringify(compactResult);
      result.tokenEstimate = Math.ceil(jsonStr.length / _DOMContextService.CHARS_PER_TOKEN);
      if (result.tokenEstimate > _DOMContextService.MAX_TOKENS) {
        return this.truncateContext(result);
      }
      return result;
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : String(err);
      throw new Error(`Failed to extract DOM context: ${errorMessage}`);
    }
  }
  /**
   * Get a minimal context (just URL, title, and interactive element counts)
   */
  async getMinimalContext(tabId) {
    const wc = tabId ? browserTargetService.getWebContents(tabId) : browserTargetService.getActiveWebContents();
    if (!wc || wc.isDestroyed()) {
      throw new Error("No active webview available");
    }
    const url = wc.getURL();
    const title = wc.getTitle();
    const countScript = `
      (function() {
        return {
          buttons: document.querySelectorAll('button, [role="button"]').length,
          links: document.querySelectorAll('a[href]').length,
          inputs: document.querySelectorAll('input, textarea').length,
          selects: document.querySelectorAll('select').length
        };
      })();
    `;
    const counts = await wc.executeJavaScript(countScript);
    const summary = `Page has ${counts.buttons} buttons, ${counts.links} links, ${counts.inputs} inputs, ${counts.selects} selects`;
    return { url, title, summary };
  }
  /**
   * Truncate context to fit within token limit
   */
  truncateContext(context) {
    const result = { ...context, truncated: true };
    const maxChars = _DOMContextService.MAX_TOKENS * _DOMContextService.CHARS_PER_TOKEN;
    if (result.mainContent && result.mainContent.length > 100) {
      result.mainContent = result.mainContent.slice(0, 100);
    }
    let jsonStr = JSON.stringify(result);
    if (jsonStr.length <= maxChars) {
      result.tokenEstimate = Math.ceil(jsonStr.length / _DOMContextService.CHARS_PER_TOKEN);
      return result;
    }
    if (result.mainContent && result.mainContent.length > 50) {
      result.mainContent = result.mainContent.slice(0, 50);
    }
    jsonStr = JSON.stringify(result);
    if (jsonStr.length <= maxChars) {
      result.tokenEstimate = Math.ceil(jsonStr.length / _DOMContextService.CHARS_PER_TOKEN);
      return result;
    }
    if (result.interactiveElements.links.length > 50) {
      result.interactiveElements.links = result.interactiveElements.links.slice(0, 50);
    }
    jsonStr = JSON.stringify(result);
    if (jsonStr.length <= maxChars) {
      result.tokenEstimate = Math.ceil(jsonStr.length / _DOMContextService.CHARS_PER_TOKEN);
      return result;
    }
    result.mainContent = [];
    jsonStr = JSON.stringify(result);
    result.tokenEstimate = Math.ceil(jsonStr.length / _DOMContextService.CHARS_PER_TOKEN);
    return result;
  }
};
__publicField2(_DOMContextService, "MAX_TOKENS", 2e3);
// Reduced target
__publicField2(_DOMContextService, "CHARS_PER_TOKEN", 4);
let DOMContextService = _DOMContextService;
const domContextService = new DOMContextService();
const DOMContextService$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  DOMContextService,
  domContextService
}, Symbol.toStringTag, { value: "Module" }));
function findUp(startDir, filename, maxHops = 8) {
  let dir = startDir;
  for (let i2 = 0; i2 < maxHops; i2++) {
    const candidate = path__default$1.join(dir, filename);
    if (fs__default.existsSync(candidate)) return candidate;
    const parent = path__default$1.dirname(dir);
    if (parent === dir) break;
    dir = parent;
  }
  return null;
}
function ensureEnvLoaded() {
  if (process.env.NVIDIA_API_KEY) return;
  const moduleDir = path__default$1.dirname(fileURLToPath(import.meta.url));
  const appPath = (() => {
    try {
      return app$1.getAppPath();
    } catch {
      return null;
    }
  })();
  const projectRoot = path__default$1.resolve(moduleDir, "..");
  const roots = [
    moduleDir,
    projectRoot,
    // Parent of dist-electron (project root)
    process.cwd(),
    appPath ?? void 0
  ].filter((v) => Boolean(v));
  for (const root of roots) {
    const envPath = findUp(root, ".env");
    if (envPath) {
      dotenv.config({ path: envPath });
      console.log("[CodeGeneratorService] Loaded .env from:", envPath);
      console.log("[CodeGeneratorService] NVIDIA_API_KEY set after dotenv:", Boolean(process.env.NVIDIA_API_KEY));
      return;
    }
  }
  console.warn("[CodeGeneratorService] Failed to locate .env. Roots tried:", roots);
}
function getApiKey$1() {
  ensureEnvLoaded();
  console.log("[CodeGeneratorService] NVIDIA_API_KEY present:", Boolean(process.env.NVIDIA_API_KEY));
  if (process.env.NVIDIA_API_KEY) return { key: process.env.NVIDIA_API_KEY };
  return null;
}
const CODE_GENERATOR_SYSTEM_PROMPT = `You are a browser automation code generator. Your job is to write JavaScript code that will be executed in a web browser to accomplish the user's task.

IMPORTANT RULES:
1. Return ONLY executable JavaScript code - no markdown fences, no explanations, no comments unless specifically requested
2. The code runs in the browser context via executeJavaScript() - you have access to document, window, etc.
3. Always return a value from your code - use 'return' at the end
4. Handle errors gracefully - wrap risky operations in try/catch
5. For async operations, the code is already wrapped in an async IIFE, so you can use await directly
6. Keep code concise and efficient
7. Use modern JavaScript (ES6+)

COMMON PATTERNS:

For data extraction:
- Use document.querySelectorAll() to find elements
- Map over results to extract text, attributes, etc.
- Return arrays of objects for structured data

For clicking:
- Find element with querySelector()
- Call element.click()
- Return confirmation of action

For form filling:
- Find input with querySelector()
- Set element.value
- Dispatch 'input' and 'change' events
- Return confirmation

For scrolling:
- Use element.scrollIntoView() or window.scrollTo()
- Return confirmation

For waiting:
- Use Promises with setTimeout or MutationObserver
- Return when condition is met

EXAMPLE OUTPUTS:

User: "Get all links on this page"
const links = document.querySelectorAll('a[href]');
return Array.from(links).map(a => ({ text: a.textContent?.trim() || '', href: a.href }));

User: "Click the submit button"
const btn = document.querySelector('button[type="submit"], input[type="submit"], button:contains("Submit")');
if (!btn) throw new Error('Submit button not found');
btn.click();
return { clicked: true, element: btn.tagName };

User: "Fill the email field with test@example.com"
const input = document.querySelector('input[type="email"], input[name="email"], input[placeholder*="email" i]');
if (!input) throw new Error('Email input not found');
input.focus();
input.value = 'test@example.com';
input.dispatchEvent(new Event('input', { bubbles: true }));
input.dispatchEvent(new Event('change', { bubbles: true }));
return { filled: true, value: input.value };`;
class CodeGeneratorService {
  /**
   * Initialize or get the LLM model
   */
  getModel(options2 = {}) {
    const apiKeyInfo = getApiKey$1();
    if (!apiKeyInfo) {
      throw new Error("No API key found. Set NVIDIA_API_KEY in .env file.");
    }
    return new ChatOpenAI({
      apiKey: apiKeyInfo.key,
      model: "moonshotai/kimi-k2-instruct",
      // Kimi K2 thinking model
      temperature: options2.temperature ?? 0.1,
      maxTokens: options2.maxTokens ?? 2048,
      configuration: {
        baseURL: "https://integrate.api.nvidia.com/v1"
      }
    });
  }
  /**
   * Generate JavaScript code from a natural language command
   */
  async generate(command, context, options2 = {}) {
    var _a3;
    const startTime2 = Date.now();
    try {
      const domContext = context ?? await domContextService.getContext().catch(() => null);
      const userPrompt = this.buildUserPrompt(command, domContext, options2);
      const model = this.getModel(options2);
      const response = await model.invoke([
        new SystemMessage(CODE_GENERATOR_SYSTEM_PROMPT),
        new HumanMessage(userPrompt)
      ]);
      let code2 = typeof response.content === "string" ? response.content : JSON.stringify(response.content);
      code2 = this.cleanCode(code2);
      return {
        success: true,
        code: code2,
        tokensUsed: (_a3 = response.usage_metadata) == null ? void 0 : _a3.total_tokens,
        duration: Date.now() - startTime2
      };
    } catch (err) {
      return {
        success: false,
        error: err instanceof Error ? err.message : String(err),
        duration: Date.now() - startTime2
      };
    }
  }
  /**
   * Generate code with streaming - yields tokens as they arrive
   */
  async *generateStream(command, context, options2 = {}) {
    try {
      const domContext = context ?? await domContextService.getContext().catch(() => null);
      const userPrompt = this.buildUserPrompt(command, domContext, options2);
      const model = this.getModel(options2);
      const stream = await model.stream([
        new SystemMessage(CODE_GENERATOR_SYSTEM_PROMPT),
        new HumanMessage(userPrompt)
      ]);
      let fullContent = "";
      for await (const chunk of stream) {
        const token = typeof chunk.content === "string" ? chunk.content : "";
        if (token) {
          fullContent += token;
          yield { type: "token", content: token };
        }
      }
      const code2 = this.cleanCode(fullContent);
      yield {
        type: "done",
        content: "",
        code: code2
      };
    } catch (err) {
      yield {
        type: "error",
        content: err instanceof Error ? err.message : String(err)
      };
    }
  }
  /**
   * Generate code with automatic retry on error
   */
  async generateWithRetry(command, previousCode, error, context, options2 = {}) {
    var _a3;
    const startTime2 = Date.now();
    try {
      const domContext = context ?? await domContextService.getContext().catch(() => null);
      const retryPrompt = `The previous code failed with this error:
Error: ${error}

Previous code that failed:
${previousCode}

Original request: ${command}

Please fix the code to handle this error. Return ONLY the corrected JavaScript code.`;
      const model = this.getModel(options2);
      const response = await model.invoke([
        new SystemMessage(CODE_GENERATOR_SYSTEM_PROMPT),
        new HumanMessage(this.buildUserPrompt(command, domContext, options2)),
        new HumanMessage(retryPrompt)
      ]);
      let code2 = typeof response.content === "string" ? response.content : JSON.stringify(response.content);
      code2 = this.cleanCode(code2);
      return {
        success: true,
        code: code2,
        tokensUsed: (_a3 = response.usage_metadata) == null ? void 0 : _a3.total_tokens,
        duration: Date.now() - startTime2
      };
    } catch (err) {
      return {
        success: false,
        error: err instanceof Error ? err.message : String(err),
        duration: Date.now() - startTime2
      };
    }
  }
  /**
   * Build the user prompt with DOM context
   */
  buildUserPrompt(command, context, options2) {
    let prompt = "";
    if (context) {
      prompt += `Current page context:
- URL: ${context.url}
- Title: ${context.title}
${context.metaDescription ? `- Description: ${context.metaDescription}` : ""}

Interactive elements on page:
- Buttons (${context.interactiveElements.buttons.length}): ${this.summarizeElements(context.interactiveElements.buttons, 10)}
- Links (${context.interactiveElements.links.length}): ${this.summarizeElements(context.interactiveElements.links, 10)}
- Inputs (${context.interactiveElements.inputs.length}): ${this.summarizeElements(context.interactiveElements.inputs, 10)}
- Selects (${context.interactiveElements.selects.length}): ${this.summarizeElements(context.interactiveElements.selects, 5)}

`;
    } else {
      prompt += `(No page context available - generate generic code)

`;
    }
    prompt += `User request: ${command}`;
    if (options2.includeExplanation) {
      prompt += `

Include brief comments explaining what the code does.`;
    }
    return prompt;
  }
  /**
   * Summarize DOM elements for the prompt
   */
  summarizeElements(elements, limit2) {
    if (elements.length === 0) return "none";
    const summary = elements.slice(0, limit2).map((el) => {
      const parts = [];
      if (el.id) parts.push(`#${el.id}`);
      if (el.dataTestId) parts.push(`[data-testid="${el.dataTestId}"]`);
      if (el.text) parts.push(`"${el.text.slice(0, 30)}${el.text.length > 30 ? "..." : ""}"`);
      if (parts.length === 0) parts.push(el.tag);
      return parts.join(" ");
    }).join(", ");
    if (elements.length > limit2) {
      return `${summary}, ... (${elements.length - limit2} more)`;
    }
    return summary;
  }
  /**
   * Clean up generated code (remove markdown fences, etc.)
   */
  cleanCode(code2) {
    code2 = code2.replace(/^```(?:javascript|js)?\n?/gm, "");
    code2 = code2.replace(/\n?```$/gm, "");
    code2 = code2.trim();
    code2 = code2.replace(/^(?:Here(?:'s| is) (?:the )?(?:code|JavaScript)[:\s]*\n?)/i, "");
    return code2;
  }
  /**
   * Generate a multi-step execution plan for complex tasks
   */
  async generateMultiStepPlan(command, context, options2 = {}) {
    var _a3;
    const startTime2 = Date.now();
    const multiStepPrompt = `You are a browser automation planner. The user wants to perform a complex task that may require multiple steps.

Analyze the task and create a JSON execution plan with multiple steps. Each step should be a discrete action.

RESPONSE FORMAT (return ONLY valid JSON, no markdown):
{
  "steps": [
    {
      "id": "step1",
      "description": "Brief description of what this step does",
      "code": "// JavaScript code for this step",
      "waitFor": "element|navigation|delay|none",
      "waitSelector": "#some-element",
      "waitTimeout": 5000,
      "continueOnError": false
    }
  ],
  "loopUntil": "// Optional: JS expression that returns true when loop should stop",
  "maxIterations": 10
}

STEP TYPES:
- waitFor: "element" - Wait for a selector to appear before next step
- waitFor: "navigation" - Wait for page navigation to complete
- waitFor: "delay" - Wait a fixed time (use waitTimeout in ms)
- waitFor: "none" or omit - Continue immediately

IMPORTANT:
- Each step's code should be self-contained and return a result
- Use __previousResult to access the result from the previous step
- For loops (pagination, etc.), set loopUntil to a condition that stops the loop
- Keep each step focused on one action
- Handle errors gracefully in each step

EXAMPLE - Paginated data collection:
{
  "steps": [
    {
      "id": "collect",
      "description": "Collect data from current page",
      "code": "const items = document.querySelectorAll('.item'); return Array.from(items).map(i => i.textContent);",
      "waitFor": "none"
    },
    {
      "id": "clickNext",
      "description": "Click the next page button",
      "code": "const next = document.querySelector('.next-page, [aria-label=\\"Next\\"]'); if (!next || next.disabled) return { done: true }; next.click(); return { clicked: true };",
      "waitFor": "navigation",
      "waitTimeout": 5000,
      "continueOnError": true
    }
  ],
  "loopUntil": "__previousResult?.done === true",
  "maxIterations": 20
}`;
    try {
      const domContext = context ?? await domContextService.getContext().catch(() => null);
      const model = this.getModel({ ...options2, maxTokens: 4096 });
      const userPrompt = this.buildUserPrompt(command, domContext, options2);
      const response = await model.invoke([
        new SystemMessage(multiStepPrompt),
        new HumanMessage(userPrompt)
      ]);
      let content = typeof response.content === "string" ? response.content : JSON.stringify(response.content);
      content = content.replace(/^```(?:json)?\n?/gm, "");
      content = content.replace(/\n?```$/gm, "");
      content = content.trim();
      const plan2 = JSON.parse(content);
      if (!plan2.steps || !Array.isArray(plan2.steps) || plan2.steps.length === 0) {
        throw new Error("Invalid plan: no steps found");
      }
      return {
        success: true,
        isMultiStep: true,
        steps: plan2,
        tokensUsed: (_a3 = response.usage_metadata) == null ? void 0 : _a3.total_tokens,
        duration: Date.now() - startTime2
      };
    } catch (err) {
      console.warn("[CodeGenerator] Multi-step plan failed, falling back to single-step:", err);
      return this.generate(command, context, options2);
    }
  }
  /**
   * Detect if a command likely needs multi-step execution
   */
  isMultiStepCommand(command) {
    const multiStepPatterns = [
      /\b(all|every|each)\b.*\b(page|pages)\b/i,
      /\bpaginat/i,
      /\bclick.*through\b/i,
      /\bcollect.*from.*multiple/i,
      /\brepeat\b/i,
      /\bloop\b/i,
      /\buntil\b/i,
      /\bthen\b/i,
      /\bafter\b.*\b(click|wait|load)/i,
      /\bstep\s*\d/i,
      /\bfirst\b.*\bthen\b/i,
      /\bnext\b.*\bpage/i
    ];
    return multiStepPatterns.some((pattern) => pattern.test(command));
  }
}
const codeGeneratorService = new CodeGeneratorService();
const CodeGeneratorService$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  CodeGeneratorService,
  codeGeneratorService
}, Symbol.toStringTag, { value: "Module" }));
function createExecutionWrapper(userCode) {
  return `
(async function() {
  const __serializeResult = (value, seen = new WeakSet(), depth = 0) => {
    if (depth > 10) return '[Max depth exceeded]';
    if (value === null) return null;
    if (value === undefined) return undefined;
    
    const type = typeof value;
    if (type === 'string' || type === 'number' || type === 'boolean') {
      return value;
    }
    
    if (type === 'function') {
      return '[Function: ' + (value.name || 'anonymous') + ']';
    }
    
    if (type === 'symbol') {
      return value.toString();
    }
    
    if (value instanceof Error) {
      return { __type: 'Error', message: value.message, stack: value.stack };
    }
    
    if (value instanceof Date) {
      return { __type: 'Date', value: value.toISOString() };
    }
    
    if (value instanceof RegExp) {
      return { __type: 'RegExp', value: value.toString() };
    }
    
    // Handle DOM nodes
    if (value instanceof Node) {
      if (value instanceof Element) {
        return {
          __type: 'Element',
          tagName: value.tagName.toLowerCase(),
          id: value.id || undefined,
          className: value.className || undefined,
          textContent: (value.textContent || '').slice(0, 100)
        };
      }
      return { __type: 'Node', nodeName: value.nodeName };
    }
    
    // Handle NodeList and HTMLCollection
    if (value instanceof NodeList || value instanceof HTMLCollection) {
      return Array.from(value).slice(0, 100).map(n => __serializeResult(n, seen, depth + 1));
    }
    
    // Handle arrays
    if (Array.isArray(value)) {
      if (seen.has(value)) return '[Circular]';
      seen.add(value);
      return value.slice(0, 1000).map(item => __serializeResult(item, seen, depth + 1));
    }
    
    // Handle objects
    if (type === 'object') {
      if (seen.has(value)) return '[Circular]';
      seen.add(value);
      
      const result = {};
      const keys = Object.keys(value).slice(0, 100);
      for (const key of keys) {
        try {
          result[key] = __serializeResult(value[key], seen, depth + 1);
        } catch (e) {
          result[key] = '[Unserializable]';
        }
      }
      return result;
    }
    
    return String(value);
  };

  try {
    const __userResult = await (async () => {
      ${userCode}
    })();
    return { success: true, result: __serializeResult(__userResult) };
  } catch (e) {
    return {
      success: false,
      error: e instanceof Error ? e.message : String(e),
      stack: e instanceof Error ? e.stack : undefined
    };
  }
})();
`;
}
const _CodeExecutorService = class _CodeExecutorService {
  // 30 seconds
  /**
   * Execute JavaScript code in the active webview
   */
  async execute(code2, options2 = {}) {
    const {
      timeout = _CodeExecutorService.DEFAULT_TIMEOUT,
      tabId,
      wrapInTryCatch = true
    } = options2;
    const startTime2 = Date.now();
    const wc = tabId ? browserTargetService.getWebContents(tabId) : browserTargetService.getActiveWebContents();
    if (!wc || wc.isDestroyed()) {
      return {
        success: false,
        error: "No active webview available. Please open a tab first.",
        duration: Date.now() - startTime2
      };
    }
    const executableCode = wrapInTryCatch ? createExecutionWrapper(code2) : code2;
    try {
      const resultPromise = wc.executeJavaScript(executableCode);
      const timeoutPromise = new Promise((_, reject) => {
        setTimeout(() => reject(new Error("Execution timed out")), timeout);
      });
      const result = await Promise.race([resultPromise, timeoutPromise]);
      const duration2 = Date.now() - startTime2;
      if (wrapInTryCatch && typeof result === "object" && result !== null) {
        const wrapped = result;
        return {
          success: wrapped.success,
          result: wrapped.result,
          error: wrapped.error,
          stack: wrapped.stack,
          duration: duration2
        };
      }
      return {
        success: true,
        result,
        duration: duration2
      };
    } catch (err) {
      const duration2 = Date.now() - startTime2;
      const isTimeout = err instanceof Error && err.message === "Execution timed out";
      return {
        success: false,
        error: err instanceof Error ? err.message : String(err),
        stack: err instanceof Error ? err.stack : void 0,
        duration: duration2,
        timedOut: isTimeout
      };
    }
  }
  /**
   * Execute a simple expression and return the result
   * Useful for quick evaluations like `document.title`
   */
  async evaluate(expression, options2 = {}) {
    const code2 = expression.trim().startsWith("return ") ? expression : `return (${expression});`;
    return this.execute(code2, options2);
  }
  /**
   * Execute code that performs DOM queries and returns elements
   */
  async queryDOM(selector, options2 = {}) {
    const code2 = `
      const elements = document.querySelectorAll(${JSON.stringify(selector)});
      return Array.from(elements).map(el => ({
        tag: el.tagName.toLowerCase(),
        id: el.id || undefined,
        className: el.className || undefined,
        text: (el.textContent || '').trim().slice(0, 100),
        href: el.href || undefined,
        src: el.src || undefined,
      }));
    `;
    return this.execute(code2, options2);
  }
  /**
   * Click an element by selector
   */
  async click(selector, options2 = {}) {
    const code2 = `
      const el = document.querySelector(${JSON.stringify(selector)});
      if (!el) throw new Error('Element not found: ${selector}');
      el.click();
      return { clicked: true, element: el.tagName.toLowerCase() };
    `;
    return this.execute(code2, options2);
  }
  /**
   * Type text into an input element
   */
  async type(selector, text, options2 = {}) {
    const code2 = `
      const el = document.querySelector(${JSON.stringify(selector)});
      if (!el) throw new Error('Element not found: ${selector}');
      if (!('value' in el)) throw new Error('Element is not an input');
      el.focus();
      el.value = ${JSON.stringify(text)};
      el.dispatchEvent(new Event('input', { bubbles: true }));
      el.dispatchEvent(new Event('change', { bubbles: true }));
      return { typed: true, value: el.value };
    `;
    return this.execute(code2, options2);
  }
  /**
   * Wait for an element to appear
   */
  async waitForElement(selector, timeout = 1e4, options2 = {}) {
    const code2 = `
      return new Promise((resolve, reject) => {
        const el = document.querySelector(${JSON.stringify(selector)});
        if (el) {
          resolve({ found: true, element: el.tagName.toLowerCase() });
          return;
        }
        
        const observer = new MutationObserver(() => {
          const el = document.querySelector(${JSON.stringify(selector)});
          if (el) {
            observer.disconnect();
            resolve({ found: true, element: el.tagName.toLowerCase() });
          }
        });
        
        observer.observe(document.body, { childList: true, subtree: true });
        
        setTimeout(() => {
          observer.disconnect();
          reject(new Error('Timeout waiting for element: ${selector}'));
        }, ${timeout});
      });
    `;
    return this.execute(code2, { ...options2, timeout: timeout + 1e3 });
  }
  /**
   * Wait for an element to disappear (e.g., loading spinner)
   */
  async waitForElementToDisappear(selector, timeout = 1e4, options2 = {}) {
    const code2 = `
      return new Promise((resolve, reject) => {
        const el = document.querySelector(${JSON.stringify(selector)});
        if (!el) {
          resolve({ disappeared: true, wasPresent: false });
          return;
        }
        
        const observer = new MutationObserver(() => {
          const el = document.querySelector(${JSON.stringify(selector)});
          if (!el) {
            observer.disconnect();
            resolve({ disappeared: true, wasPresent: true });
          }
        });
        
        observer.observe(document.body, { childList: true, subtree: true, attributes: true });
        
        setTimeout(() => {
          observer.disconnect();
          const stillExists = !!document.querySelector(${JSON.stringify(selector)});
          if (stillExists) {
            reject(new Error('Timeout waiting for element to disappear: ${selector}'));
          } else {
            resolve({ disappeared: true, wasPresent: true });
          }
        }, ${timeout});
      });
    `;
    return this.execute(code2, { ...options2, timeout: timeout + 1e3 });
  }
  /**
   * Wait for URL to change (SPA navigation)
   */
  async waitForURLChange(expectedPattern, timeout = 1e4, options2 = {}) {
    const patternStr = expectedPattern ? expectedPattern instanceof RegExp ? expectedPattern.source : expectedPattern : null;
    const isRegex = expectedPattern instanceof RegExp;
    const code2 = `
      return new Promise((resolve, reject) => {
        const initialUrl = window.location.href;
        const pattern = ${patternStr ? JSON.stringify(patternStr) : "null"};
        const isRegex = ${isRegex};
        
        const checkUrl = () => {
          const currentUrl = window.location.href;
          if (currentUrl !== initialUrl) {
            if (pattern) {
              const matches = isRegex 
                ? new RegExp(pattern).test(currentUrl)
                : currentUrl.includes(pattern);
              if (matches) {
                return { changed: true, from: initialUrl, to: currentUrl, matched: true };
              }
            } else {
              return { changed: true, from: initialUrl, to: currentUrl };
            }
          }
          return null;
        };
        
        // Check immediately
        const immediate = checkUrl();
        if (immediate) {
          resolve(immediate);
          return;
        }
        
        // Use popstate for history changes
        const onPopState = () => {
          const result = checkUrl();
          if (result) {
            cleanup();
            resolve(result);
          }
        };
        
        // Use MutationObserver for SPA changes that don't trigger popstate
        const observer = new MutationObserver(() => {
          const result = checkUrl();
          if (result) {
            cleanup();
            resolve(result);
          }
        });
        
        const cleanup = () => {
          window.removeEventListener('popstate', onPopState);
          observer.disconnect();
        };
        
        window.addEventListener('popstate', onPopState);
        observer.observe(document.body, { childList: true, subtree: true });
        
        // Also poll periodically for pushState changes
        const pollInterval = setInterval(() => {
          const result = checkUrl();
          if (result) {
            clearInterval(pollInterval);
            cleanup();
            resolve(result);
          }
        }, 100);
        
        setTimeout(() => {
          clearInterval(pollInterval);
          cleanup();
          const currentUrl = window.location.href;
          if (currentUrl !== initialUrl) {
            resolve({ changed: true, from: initialUrl, to: currentUrl, timedOut: false });
          } else {
            reject(new Error('Timeout waiting for URL change'));
          }
        }, ${timeout});
      });
    `;
    return this.execute(code2, { ...options2, timeout: timeout + 1e3 });
  }
  /**
   * Wait for DOM to stabilize (no mutations for a period)
   */
  async waitForDOMStable(stabilityMs = 500, timeout = 1e4, options2 = {}) {
    const code2 = `
      return new Promise((resolve, reject) => {
        let lastMutationTime = Date.now();
        let checkInterval;
        
        const observer = new MutationObserver(() => {
          lastMutationTime = Date.now();
        });
        
        observer.observe(document.body, { 
          childList: true, 
          subtree: true, 
          attributes: true,
          characterData: true 
        });
        
        checkInterval = setInterval(() => {
          const timeSinceLastMutation = Date.now() - lastMutationTime;
          if (timeSinceLastMutation >= ${stabilityMs}) {
            clearInterval(checkInterval);
            observer.disconnect();
            resolve({ stable: true, stableFor: timeSinceLastMutation });
          }
        }, 100);
        
        setTimeout(() => {
          clearInterval(checkInterval);
          observer.disconnect();
          reject(new Error('Timeout waiting for DOM to stabilize'));
        }, ${timeout});
      });
    `;
    return this.execute(code2, { ...options2, timeout: timeout + 1e3 });
  }
  /**
   * Wait for a condition to become true
   */
  async waitForCondition(conditionCode, timeout = 1e4, pollInterval = 100, options2 = {}) {
    const code2 = `
      return new Promise((resolve, reject) => {
        const checkCondition = () => {
          try {
            const result = (function() { ${conditionCode} })();
            return result;
          } catch (e) {
            return false;
          }
        };
        
        // Check immediately
        if (checkCondition()) {
          resolve({ conditionMet: true, immediate: true });
          return;
        }
        
        const interval = setInterval(() => {
          if (checkCondition()) {
            clearInterval(interval);
            resolve({ conditionMet: true, immediate: false });
          }
        }, ${pollInterval});
        
        setTimeout(() => {
          clearInterval(interval);
          reject(new Error('Timeout waiting for condition'));
        }, ${timeout});
      });
    `;
    return this.execute(code2, { ...options2, timeout: timeout + 1e3 });
  }
  /**
   * Wait for network idle (no pending requests)
   */
  async waitForNetworkIdle(idleMs = 500, timeout = 1e4, options2 = {}) {
    const code2 = `
      return new Promise((resolve, reject) => {
        let pendingRequests = 0;
        let lastActivityTime = Date.now();
        
        const originalFetch = window.fetch;
        const originalXHROpen = XMLHttpRequest.prototype.open;
        const originalXHRSend = XMLHttpRequest.prototype.send;
        
        // Track fetch requests
        window.fetch = function(...args) {
          pendingRequests++;
          lastActivityTime = Date.now();
          return originalFetch.apply(this, args).finally(() => {
            pendingRequests--;
            lastActivityTime = Date.now();
          });
        };
        
        // Track XHR requests
        XMLHttpRequest.prototype.open = function(...args) {
          this.__tracked = true;
          return originalXHROpen.apply(this, args);
        };
        
        XMLHttpRequest.prototype.send = function(...args) {
          if (this.__tracked) {
            pendingRequests++;
            lastActivityTime = Date.now();
            this.addEventListener('loadend', () => {
              pendingRequests--;
              lastActivityTime = Date.now();
            });
          }
          return originalXHRSend.apply(this, args);
        };
        
        const cleanup = () => {
          window.fetch = originalFetch;
          XMLHttpRequest.prototype.open = originalXHROpen;
          XMLHttpRequest.prototype.send = originalXHRSend;
        };
        
        const checkInterval = setInterval(() => {
          const timeSinceActivity = Date.now() - lastActivityTime;
          if (pendingRequests === 0 && timeSinceActivity >= ${idleMs}) {
            clearInterval(checkInterval);
            cleanup();
            resolve({ networkIdle: true, idleFor: timeSinceActivity });
          }
        }, 100);
        
        setTimeout(() => {
          clearInterval(checkInterval);
          cleanup();
          if (pendingRequests === 0) {
            resolve({ networkIdle: true, timedOut: true });
          } else {
            reject(new Error('Timeout waiting for network idle, ' + pendingRequests + ' requests pending'));
          }
        }, ${timeout});
      });
    `;
    return this.execute(code2, { ...options2, timeout: timeout + 1e3 });
  }
  /**
   * Scroll to an element or position
   */
  async scroll(target, options2 = {}) {
    if (typeof target === "string") {
      const code2 = `
        const el = document.querySelector(${JSON.stringify(target)});
        if (!el) throw new Error('Element not found: ${target}');
        el.scrollIntoView({ behavior: 'smooth', block: 'center' });
        return { scrolled: true, to: 'element' };
      `;
      return this.execute(code2, options2);
    } else {
      const code2 = `
        window.scrollTo({ left: ${target.x}, top: ${target.y}, behavior: 'smooth' });
        return { scrolled: true, to: { x: ${target.x}, y: ${target.y} } };
      `;
      return this.execute(code2, options2);
    }
  }
  /**
   * Wait for navigation to complete
   */
  async waitForNavigation(timeout = 1e4, options2 = {}) {
    const wc = options2.tabId ? browserTargetService.getWebContents(options2.tabId) : browserTargetService.getActiveWebContents();
    if (!wc || wc.isDestroyed()) {
      return {
        success: false,
        error: "No active webview available",
        duration: 0
      };
    }
    const startTime2 = Date.now();
    return new Promise((resolve) => {
      let resolved = false;
      const cleanup = () => {
        if (!resolved) {
          resolved = true;
          wc.removeListener("did-finish-load", onLoad);
          wc.removeListener("did-fail-load", onFail);
        }
      };
      const onLoad = () => {
        cleanup();
        resolve({
          success: true,
          result: { navigated: true, url: wc.getURL() },
          duration: Date.now() - startTime2
        });
      };
      const onFail = (_, errorCode, errorDescription) => {
        if (errorCode === -3) return;
        cleanup();
        resolve({
          success: false,
          error: `Navigation failed: ${errorDescription}`,
          duration: Date.now() - startTime2
        });
      };
      wc.once("did-finish-load", onLoad);
      wc.once("did-fail-load", onFail);
      setTimeout(() => {
        cleanup();
        resolve({
          success: true,
          result: { navigated: true, timedOut: true },
          duration: Date.now() - startTime2
        });
      }, timeout);
    });
  }
  /**
   * Wait for a delay
   */
  async waitForDelay(ms) {
    const startTime2 = Date.now();
    await new Promise((resolve) => setTimeout(resolve, ms));
    return {
      success: true,
      result: { waited: ms },
      duration: Date.now() - startTime2
    };
  }
  /**
   * Execute a multi-step plan sequentially
   */
  async executeMultiStepPlan(plan, options = {}, onStepComplete) {
    const startTime = Date.now();
    const results = [];
    const collectedData = [];
    const maxIterations = plan.maxIterations ?? 10;
    let iteration = 0;
    let previousResult = null;
    const executeSteps = async () => {
      for (const step of plan.steps) {
        const codeWithContext = `
          const __previousResult = ${JSON.stringify(previousResult)};
          ${step.code}
        `;
        const stepResult = await this.execute(codeWithContext, options);
        results.push({ stepId: step.id, result: stepResult, iteration });
        onStepComplete == null ? void 0 : onStepComplete(step.id, stepResult, iteration);
        if (!stepResult.success && !step.continueOnError) {
          return false;
        }
        previousResult = stepResult.result;
        if (Array.isArray(stepResult.result)) {
          collectedData.push(...stepResult.result);
        } else if (stepResult.result && typeof stepResult.result === "object") {
          collectedData.push(stepResult.result);
        }
        if (step.waitFor === "element" && step.waitSelector) {
          const waitResult = await this.waitForElement(step.waitSelector, step.waitTimeout ?? 5e3, options);
          if (!waitResult.success && !step.continueOnError) {
            results.push({ stepId: `${step.id}_wait`, result: waitResult, iteration });
            return false;
          }
        } else if (step.waitFor === "navigation") {
          const waitResult = await this.waitForNavigation(step.waitTimeout ?? 1e4, options);
          if (!waitResult.success && !step.continueOnError) {
            results.push({ stepId: `${step.id}_wait`, result: waitResult, iteration });
            return false;
          }
        } else if (step.waitFor === "delay") {
          await this.waitForDelay(step.waitTimeout ?? 1e3);
        }
      }
      return true;
    };
    do {
      iteration++;
      const success = await executeSteps();
      if (!success) break;
      if (plan.loopUntil) {
        try {
          const shouldStop = eval(`(function() { const __previousResult = ${JSON.stringify(previousResult)}; return ${plan.loopUntil}; })()`);
          if (shouldStop) break;
        } catch {
          break;
        }
      } else {
        break;
      }
    } while (iteration < maxIterations);
    return {
      success: results.every((r) => {
        var _a3;
        return r.result.success || ((_a3 = plan.steps.find((s) => s.id === r.stepId)) == null ? void 0 : _a3.continueOnError);
      }),
      results,
      collectedData,
      duration: Date.now() - startTime,
      iterations: iteration
    };
  }
};
__publicField2(_CodeExecutorService, "DEFAULT_TIMEOUT", 3e4);
let CodeExecutorService = _CodeExecutorService;
const codeExecutorService = new CodeExecutorService();
const CodeExecutorService$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  CodeExecutorService,
  codeExecutorService
}, Symbol.toStringTag, { value: "Module" }));
function formatResultForAgent(result) {
  if (result === null || result === void 0) {
    return "(no output)";
  }
  if (typeof result === "string") {
    return result;
  }
  if (typeof result === "object") {
    try {
      const jsonString = JSON.stringify(result, null, 2);
      if (jsonString.length > 2e3) {
        return `(Large object, showing first 2000 chars)
${jsonString.substring(0, 2e3)}...`;
      }
      return jsonString;
    } catch (e) {
      return `[Unserializable Object: ${String(result)}]`;
    }
  }
  return String(result);
}
class TerminalIntegrationTool {
  constructor() {
    this.registerTools();
  }
  registerTools() {
    const terminalCommandSchema = object({
      command: string().describe('Natural language command to execute on the current page (e.g., "Extract all product prices", "Click the login button", "Scroll to bottom").'),
      include_explanation: boolean().optional().describe("Whether to include an explanation of the generated code in the response.")
    });
    const terminalCommandTool = {
      name: "browser_terminal_command",
      description: "Execute a natural language command on the current page using the AI Terminal engine. BEST FOR: Complex data extraction, form filling, finding elements by semantic meaning, or when standard selectors fail. The engine analyzes the page, generates robust JavaScript, and executes it safely.",
      schema: terminalCommandSchema,
      requiresApproval: true,
      // Safety: Generating code always carries some risk
      execute: async ({ command, include_explanation }) => {
        try {
          console.log(`[TerminalTool] Executing: "${command}"`);
          let context;
          try {
            context = await domContextService.getContext();
          } catch (e) {
            console.warn("[TerminalTool] Context extraction failed, proceeding without context:", e);
          }
          const genResult = await codeGeneratorService.generate(command, context, {
            includeExplanation: include_explanation
          });
          if (!genResult.success || !genResult.code) {
            return `Failed to generate code: ${genResult.error || "Unknown error"}`;
          }
          const execResult = await codeExecutorService.execute(genResult.code);
          let output = "";
          if (execResult.success) {
            output = `âœ… Execution Successful

Result:
${formatResultForAgent(execResult.result)}`;
            if (JSON.stringify(execResult.result).length > 2e3) {
              output += `

(Note: Result truncated for display. Full data object returned.)`;
            }
          } else {
            output = `âŒ Execution Failed

Error: ${execResult.error}
Stack: ${execResult.stack}`;
          }
          if (include_explanation && genResult.code) {
            output += `

Generated Code:
\`\`\`javascript
${genResult.code}
\`\`\``;
          }
          return output;
        } catch (error) {
          console.error("[TerminalTool] Critical error:", error);
          return `Critical error executing terminal command: ${error.message}`;
        }
      }
    };
    toolRegistry.register(terminalCommandTool);
  }
}
new TerminalIntegrationTool();
class StateManager {
  constructor() {
    __publicField2(this, "stateDir");
    __publicField2(this, "tasks", /* @__PURE__ */ new Map());
    __publicField2(this, "checkpoints", /* @__PURE__ */ new Map());
    this.stateDir = path$3.join(app$1.getPath("userData"), "agent-state");
    this.ensureStateDir();
  }
  async ensureStateDir() {
    try {
      await fs$2.mkdir(this.stateDir, { recursive: true });
    } catch {
    }
  }
  /**
   * Create a new task
   */
  async createTask(taskId, query, plan2) {
    const state = {
      taskId,
      query,
      status: "pending",
      currentStepIndex: 0,
      totalSteps: plan2.steps.length,
      plan: {
        ...plan2,
        steps: plan2.steps.map((step, i2) => ({
          ...step,
          id: step.id || `step-${i2}`,
          status: "pending"
        }))
      },
      results: [],
      context: {},
      createdAt: Date.now(),
      updatedAt: Date.now()
    };
    this.tasks.set(taskId, state);
    await this.persistState(taskId);
    return state;
  }
  /**
   * Get task state
   */
  getTask(taskId) {
    return this.tasks.get(taskId);
  }
  /**
   * Update task status
   */
  async updateTaskStatus(taskId, status, error) {
    const state = this.tasks.get(taskId);
    if (!state) return;
    state.status = status;
    state.updatedAt = Date.now();
    if (error) state.error = error;
    if (status === "completed" || status === "failed") {
      state.completedAt = Date.now();
    }
    await this.persistState(taskId);
  }
  /**
   * Mark step as started
   */
  async startStep(taskId, stepIndex) {
    const state = this.tasks.get(taskId);
    if (!state || stepIndex >= state.plan.steps.length) return;
    state.currentStepIndex = stepIndex;
    state.plan.steps[stepIndex].status = "running";
    state.status = "running";
    state.updatedAt = Date.now();
    await this.persistState(taskId);
  }
  /**
   * Record step completion
   */
  async completeStep(taskId, stepIndex, result) {
    const state = this.tasks.get(taskId);
    if (!state || stepIndex >= state.plan.steps.length) return;
    state.plan.steps[stepIndex].status = result.success ? "completed" : "failed";
    state.results.push({
      stepId: state.plan.steps[stepIndex].id,
      stepIndex,
      success: result.success,
      data: result.data,
      error: result.error,
      startedAt: result.startedAt,
      completedAt: Date.now()
    });
    state.updatedAt = Date.now();
    if (stepIndex > 0 && stepIndex % 5 === 0) {
      await this.createCheckpoint(taskId);
    }
    await this.persistState(taskId);
  }
  /**
   * Update task context (accumulated data across steps)
   */
  async updateContext(taskId, key, value) {
    const state = this.tasks.get(taskId);
    if (!state) return;
    state.context[key] = value;
    state.updatedAt = Date.now();
    await this.persistState(taskId);
  }
  /**
   * Get accumulated context
   */
  getContext(taskId) {
    var _a3;
    return ((_a3 = this.tasks.get(taskId)) == null ? void 0 : _a3.context) ?? {};
  }
  /**
   * Create a checkpoint for resume capability
   */
  async createCheckpoint(taskId) {
    const state = this.tasks.get(taskId);
    if (!state) throw new Error(`Task ${taskId} not found`);
    const checkpoint = {
      taskId,
      stepIndex: state.currentStepIndex,
      state: JSON.parse(JSON.stringify(state)),
      // Deep clone
      timestamp: Date.now()
    };
    const checkpoints = this.checkpoints.get(taskId) ?? [];
    checkpoints.push(checkpoint);
    if (checkpoints.length > 10) {
      checkpoints.shift();
    }
    this.checkpoints.set(taskId, checkpoints);
    await this.persistCheckpoint(checkpoint);
    return checkpoint;
  }
  /**
   * Resume from latest checkpoint
   */
  async resumeFromCheckpoint(taskId) {
    var _a3;
    const checkpoints = this.checkpoints.get(taskId);
    if (!checkpoints || checkpoints.length === 0) {
      const loaded = await this.loadCheckpoints(taskId);
      if (loaded.length === 0) return null;
    }
    const latest = (_a3 = this.checkpoints.get(taskId)) == null ? void 0 : _a3.slice(-1)[0];
    if (!latest) return null;
    const state = JSON.parse(JSON.stringify(latest.state));
    state.status = "running";
    state.updatedAt = Date.now();
    for (let i2 = state.currentStepIndex; i2 < state.plan.steps.length; i2++) {
      if (state.plan.steps[i2].status === "running") {
        state.plan.steps[i2].status = "pending";
      }
    }
    this.tasks.set(taskId, state);
    return state;
  }
  /**
   * Get task progress
   */
  getProgress(taskId) {
    var _a3;
    const state = this.tasks.get(taskId);
    if (!state) return null;
    const completed = state.results.filter((r) => r.success).length;
    return {
      completed,
      total: state.totalSteps,
      percentage: Math.round(completed / state.totalSteps * 100),
      currentStep: ((_a3 = state.plan.steps[state.currentStepIndex]) == null ? void 0 : _a3.description) ?? "Unknown"
    };
  }
  /**
   * List all tasks
   */
  async listTasks(filter) {
    await this.loadAllStates();
    let tasks = Array.from(this.tasks.values());
    if (filter == null ? void 0 : filter.status) {
      tasks = tasks.filter((t2) => t2.status === filter.status);
    }
    return tasks.sort((a, b) => b.updatedAt - a.updatedAt);
  }
  /**
   * Delete a task and its checkpoints
   */
  async deleteTask(taskId) {
    this.tasks.delete(taskId);
    this.checkpoints.delete(taskId);
    try {
      await fs$2.unlink(path$3.join(this.stateDir, `${taskId}.json`));
      await fs$2.unlink(path$3.join(this.stateDir, `${taskId}-checkpoints.json`));
    } catch {
    }
  }
  // Persistence methods
  async persistState(taskId) {
    const state = this.tasks.get(taskId);
    if (!state) return;
    const filePath = path$3.join(this.stateDir, `${taskId}.json`);
    await fs$2.writeFile(filePath, JSON.stringify(state, null, 2));
  }
  async persistCheckpoint(checkpoint) {
    const filePath = path$3.join(this.stateDir, `${checkpoint.taskId}-checkpoints.json`);
    const checkpoints = this.checkpoints.get(checkpoint.taskId) ?? [];
    await fs$2.writeFile(filePath, JSON.stringify(checkpoints, null, 2));
  }
  async loadState(taskId) {
    try {
      const filePath = path$3.join(this.stateDir, `${taskId}.json`);
      const data = await fs$2.readFile(filePath, "utf-8");
      const state = JSON.parse(data);
      this.tasks.set(taskId, state);
      return state;
    } catch {
      return null;
    }
  }
  async loadCheckpoints(taskId) {
    try {
      const filePath = path$3.join(this.stateDir, `${taskId}-checkpoints.json`);
      const data = await fs$2.readFile(filePath, "utf-8");
      const checkpoints = JSON.parse(data);
      this.checkpoints.set(taskId, checkpoints);
      return checkpoints;
    } catch {
      return [];
    }
  }
  async loadAllStates() {
    try {
      const files = await fs$2.readdir(this.stateDir);
      const stateFiles = files.filter((f) => f.endsWith(".json") && !f.includes("-checkpoints"));
      for (const file of stateFiles) {
        const taskId = file.replace(".json", "");
        if (!this.tasks.has(taskId)) {
          await this.loadState(taskId);
        }
      }
    } catch {
    }
  }
}
const stateManager = new StateManager();
class AgentMemory {
  constructor() {
    __publicField2(this, "memoryDir");
    __publicField2(this, "siteLearnings", /* @__PURE__ */ new Map());
    __publicField2(this, "generalMemory", /* @__PURE__ */ new Map());
    __publicField2(this, "sessionContext", /* @__PURE__ */ new Map());
    this.memoryDir = path$3.join(app$1.getPath("userData"), "agent-memory");
    this.initialize();
  }
  async initialize() {
    try {
      await fs$2.mkdir(this.memoryDir, { recursive: true });
      await this.loadMemory();
    } catch {
    }
  }
  /**
   * Record a successful selector for a site
   */
  async learnSelector(domain, purpose, selector, success2) {
    const learning = this.getOrCreateSiteLearning(domain);
    if (!learning.selectors[purpose]) {
      learning.selectors[purpose] = {
        site: domain,
        purpose,
        selectors: [],
        successRate: 0,
        lastUsed: Date.now(),
        useCount: 0
      };
    }
    const pattern = learning.selectors[purpose];
    if (!pattern.selectors.includes(selector)) {
      pattern.selectors.push(selector);
    }
    pattern.useCount++;
    pattern.lastUsed = Date.now();
    if (success2) {
      pattern.successRate = (pattern.successRate * (pattern.useCount - 1) + 1) / pattern.useCount;
    } else {
      pattern.successRate = pattern.successRate * (pattern.useCount - 1) / pattern.useCount;
    }
    await this.persistSiteLearning(domain);
  }
  /**
   * Get best selectors for a purpose on a site
   */
  getSelectors(domain, purpose) {
    const learning = this.siteLearnings.get(domain);
    if (!learning) return [];
    const pattern = learning.selectors[purpose];
    if (!pattern) return [];
    return pattern.selectors;
  }
  /**
   * Record a successful action sequence
   */
  async learnActionSequence(domain, description, actions, success2) {
    const learning = this.getOrCreateSiteLearning(domain);
    let sequence = learning.actionSequences.find(
      (s) => s.description === description
    );
    if (!sequence) {
      sequence = {
        id: `seq-${Date.now()}`,
        description,
        site: domain,
        actions,
        successRate: 0,
        useCount: 0,
        lastUsed: Date.now()
      };
      learning.actionSequences.push(sequence);
    }
    sequence.useCount++;
    sequence.lastUsed = Date.now();
    if (success2) {
      sequence.successRate = (sequence.successRate * (sequence.useCount - 1) + 1) / sequence.useCount;
    } else {
      sequence.successRate = sequence.successRate * (sequence.useCount - 1) / sequence.useCount;
    }
    await this.persistSiteLearning(domain);
  }
  /**
   * Get action sequences for a site
   */
  getActionSequences(domain, description) {
    const learning = this.siteLearnings.get(domain);
    if (!learning) return [];
    let sequences = learning.actionSequences;
    if (description) {
      const lowerDesc = description.toLowerCase();
      sequences = sequences.filter(
        (s) => s.description.toLowerCase().includes(lowerDesc) || lowerDesc.includes(s.description.toLowerCase())
      );
    }
    return sequences.sort((a, b) => {
      const scoreA = a.successRate * 0.7 + a.lastUsed / Date.now() * 0.3;
      const scoreB = b.successRate * 0.7 + b.lastUsed / Date.now() * 0.3;
      return scoreB - scoreA;
    });
  }
  /**
   * Record an error pattern
   */
  async recordError(domain, errorType, errorMessage, solution) {
    const learning = this.getOrCreateSiteLearning(domain);
    let pattern = learning.errorPatterns.find(
      (p) => p.errorType === errorType && p.errorMessage === errorMessage
    );
    if (!pattern) {
      pattern = {
        site: domain,
        errorType,
        errorMessage,
        solution,
        occurrences: 0,
        lastSeen: Date.now()
      };
      learning.errorPatterns.push(pattern);
    }
    pattern.occurrences++;
    pattern.lastSeen = Date.now();
    if (solution) pattern.solution = solution;
    learning.metadata.failedExtractions++;
    await this.persistSiteLearning(domain);
  }
  /**
   * Get known solutions for an error
   */
  getErrorSolution(domain, errorType) {
    const learning = this.siteLearnings.get(domain);
    if (!learning) return null;
    const pattern = learning.errorPatterns.find((p) => p.errorType === errorType);
    return (pattern == null ? void 0 : pattern.solution) ?? null;
  }
  /**
   * Record a site visit
   */
  async recordVisit(domain, success2) {
    const learning = this.getOrCreateSiteLearning(domain);
    learning.metadata.lastVisit = Date.now();
    learning.metadata.visitCount++;
    if (success2) {
      learning.metadata.successfulExtractions++;
    } else {
      learning.metadata.failedExtractions++;
    }
    await this.persistSiteLearning(domain);
  }
  /**
   * Store a general memory entry
   */
  async remember(key, value, type = "fact", confidence = 1) {
    const existing = this.generalMemory.get(key);
    const entry = {
      key,
      value,
      type,
      confidence,
      createdAt: (existing == null ? void 0 : existing.createdAt) ?? Date.now(),
      updatedAt: Date.now(),
      accessCount: ((existing == null ? void 0 : existing.accessCount) ?? 0) + 1
    };
    this.generalMemory.set(key, entry);
    await this.persistGeneralMemory();
  }
  /**
   * Recall a memory entry
   */
  recall(key) {
    const entry = this.generalMemory.get(key);
    if (!entry) return null;
    entry.accessCount++;
    return entry.value;
  }
  /**
   * Search memories by type or pattern
   */
  search(query, type) {
    const results2 = [];
    const lowerQuery = query.toLowerCase();
    for (const entry of this.generalMemory.values()) {
      if (type && entry.type !== type) continue;
      const keyMatch = entry.key.toLowerCase().includes(lowerQuery);
      const valueMatch = JSON.stringify(entry.value).toLowerCase().includes(lowerQuery);
      if (keyMatch || valueMatch) {
        results2.push(entry);
      }
    }
    return results2.sort((a, b) => b.confidence - a.confidence);
  }
  /**
   * Set session context (temporary, not persisted)
   */
  setContext(key, value) {
    this.sessionContext.set(key, value);
  }
  /**
   * Get session context
   */
  getContext(key) {
    return this.sessionContext.get(key) ?? null;
  }
  /**
   * Clear session context
   */
  clearContext() {
    this.sessionContext.clear();
  }
  /**
   * Get site learning summary
   */
  getSiteSummary(domain) {
    const learning = this.siteLearnings.get(domain);
    if (!learning) return null;
    const total = learning.metadata.successfulExtractions + learning.metadata.failedExtractions;
    const successRate = total > 0 ? learning.metadata.successfulExtractions / total : 0;
    return {
      knownSelectors: Object.keys(learning.selectors).length,
      actionSequences: learning.actionSequences.length,
      errorPatterns: learning.errorPatterns.length,
      successRate
    };
  }
  // Helper methods
  getOrCreateSiteLearning(domain) {
    let learning = this.siteLearnings.get(domain);
    if (!learning) {
      learning = {
        domain,
        selectors: {},
        actionSequences: [],
        errorPatterns: [],
        metadata: {
          firstVisit: Date.now(),
          lastVisit: Date.now(),
          visitCount: 0,
          successfulExtractions: 0,
          failedExtractions: 0
        }
      };
      this.siteLearnings.set(domain, learning);
    }
    return learning;
  }
  async persistSiteLearning(domain) {
    const learning = this.siteLearnings.get(domain);
    if (!learning) return;
    const safeDomain = domain.replace(/[^a-z0-9.-]/gi, "_");
    const filePath = path$3.join(this.memoryDir, `site-${safeDomain}.json`);
    await fs$2.writeFile(filePath, JSON.stringify(learning, null, 2));
  }
  async persistGeneralMemory() {
    const entries = Array.from(this.generalMemory.values());
    const filePath = path$3.join(this.memoryDir, "general-memory.json");
    await fs$2.writeFile(filePath, JSON.stringify(entries, null, 2));
  }
  async loadMemory() {
    try {
      const generalPath = path$3.join(this.memoryDir, "general-memory.json");
      try {
        const data = await fs$2.readFile(generalPath, "utf-8");
        const entries = JSON.parse(data);
        for (const entry of entries) {
          this.generalMemory.set(entry.key, entry);
        }
      } catch {
      }
      const files = await fs$2.readdir(this.memoryDir);
      for (const file of files) {
        if (file.startsWith("site-") && file.endsWith(".json")) {
          try {
            const data = await fs$2.readFile(path$3.join(this.memoryDir, file), "utf-8");
            const learning = JSON.parse(data);
            this.siteLearnings.set(learning.domain, learning);
          } catch {
          }
        }
      }
    } catch {
    }
  }
}
const agentMemory = new AgentMemory();
class TabOrchestrator {
  constructor(options2 = {}) {
    __publicField2(this, "tabs", /* @__PURE__ */ new Map());
    __publicField2(this, "options");
    this.options = {
      maxTabs: options2.maxTabs ?? 5,
      tabTimeout: options2.tabTimeout ?? 3e4,
      reuseExistingTabs: options2.reuseExistingTabs ?? true,
      closeTabsAfterUse: options2.closeTabsAfterUse ?? false
    };
  }
  /**
   * Execute tasks across multiple URLs in parallel
   */
  async executeParallel(tasks) {
    const results2 = [];
    const queue2 = [...tasks];
    const activePromises = [];
    while (queue2.length > 0 || activePromises.length > 0) {
      while (queue2.length > 0 && activePromises.length < this.options.maxTabs) {
        const task = queue2.shift();
        const promise = this.executeTask(task).then((result) => {
          results2.push(result);
          const index = activePromises.indexOf(promise);
          if (index > -1) activePromises.splice(index, 1);
          return result;
        });
        activePromises.push(promise);
      }
      if (activePromises.length > 0) {
        await Promise.race(activePromises);
      }
    }
    return results2;
  }
  /**
   * Execute a single task in a tab
   */
  async executeTask(task) {
    var _a3;
    const startTime2 = Date.now();
    let tabId = null;
    try {
      tabId = await this.getOrCreateTab(task.url);
      await this.waitForPageReady(tabId, task.timeout ?? this.options.tabTimeout);
      if ((_a3 = task.actions) == null ? void 0 : _a3.length) {
        for (const action of task.actions) {
          await this.executeAction(tabId, action);
        }
      }
      let data = null;
      if (task.extractionCode) {
        data = await this.extractFromTab(tabId, task.extractionCode);
      }
      const tabInfo = this.tabs.get(tabId);
      if (tabInfo) {
        tabInfo.lastUsedAt = Date.now();
        tabInfo.data = data;
      }
      if (this.options.closeTabsAfterUse) {
        await this.closeTab(tabId);
      }
      return {
        url: task.url,
        tabId,
        success: true,
        data,
        duration: Date.now() - startTime2
      };
    } catch (error) {
      const errorMsg = error instanceof Error ? error.message : String(error);
      if (tabId) {
        const tabInfo = this.tabs.get(tabId);
        if (tabInfo) tabInfo.status = "error";
      }
      return {
        url: task.url,
        tabId: tabId ?? "",
        success: false,
        data: null,
        error: errorMsg,
        duration: Date.now() - startTime2
      };
    }
  }
  /**
   * Get existing tab for URL or create new one
   */
  async getOrCreateTab(url) {
    if (this.options.reuseExistingTabs) {
      const domain = this.extractDomain(url);
      for (const [tabId2, info] of this.tabs) {
        if (info.status === "ready" && this.extractDomain(info.url) === domain) {
          await this.navigateTab(tabId2, url);
          return tabId2;
        }
      }
    }
    const tabId = await agentTabOpenService.openAgentTab({
      url,
      background: true,
      agentCreated: true
    });
    this.tabs.set(tabId, {
      tabId,
      url,
      status: "loading",
      createdAt: Date.now(),
      lastUsedAt: Date.now()
    });
    return tabId;
  }
  /**
   * Navigate a tab to a new URL
   */
  async navigateTab(tabId, url) {
    const webContents2 = browserTargetService.getWebContents(tabId);
    if (!webContents2) throw new Error(`Tab ${tabId} not found`);
    const tabInfo = this.tabs.get(tabId);
    if (tabInfo) {
      tabInfo.url = url;
      tabInfo.status = "loading";
    }
    await webContents2.loadURL(url);
  }
  /**
   * Wait for page to be ready
   */
  async waitForPageReady(tabId, timeout) {
    const startTime2 = Date.now();
    while (Date.now() - startTime2 < timeout) {
      try {
        const webContents2 = browserTargetService.getWebContents(tabId);
        if (!webContents2) throw new Error(`Tab ${tabId} not found`);
        const isLoading = webContents2.isLoading();
        if (!isLoading) {
          const tabInfo = this.tabs.get(tabId);
          if (tabInfo) tabInfo.status = "ready";
          return;
        }
      } catch {
      }
      await this.delay(200);
    }
    throw new Error(`Tab ${tabId} timed out waiting for page ready`);
  }
  /**
   * Execute an action in a tab
   */
  async executeAction(tabId, action) {
    const webContents2 = browserTargetService.getWebContents(tabId);
    if (!webContents2) throw new Error(`Tab ${tabId} not found`);
    switch (action.type) {
      case "click":
        if (!action.selector) throw new Error("Click action requires selector");
        return webContents2.executeJavaScript(`
          const el = document.querySelector(${JSON.stringify(action.selector)});
          if (el) { el.click(); true; } else { false; }
        `);
      case "type":
        if (!action.selector || !action.text) throw new Error("Type action requires selector and text");
        return webContents2.executeJavaScript(`
          const el = document.querySelector(${JSON.stringify(action.selector)});
          if (el) { 
            el.focus(); 
            el.value = ${JSON.stringify(action.text)}; 
            el.dispatchEvent(new Event('input', { bubbles: true }));
            true; 
          } else { false; }
        `);
      case "scroll":
        return webContents2.executeJavaScript(
          action.selector ? `document.querySelector(${JSON.stringify(action.selector)})?.scrollIntoView({ behavior: 'smooth' }); true;` : `window.scrollBy(0, window.innerHeight); true;`
        );
      case "wait":
        await this.delay(action.ms ?? 1e3);
        return true;
      case "extract":
        if (!action.code) throw new Error("Extract action requires code");
        return webContents2.executeJavaScript(action.code);
      default:
        throw new Error(`Unknown action type: ${action.type}`);
    }
  }
  /**
   * Extract data from a tab
   */
  async extractFromTab(tabId, code2) {
    const webContents2 = browserTargetService.getWebContents(tabId);
    if (!webContents2) throw new Error(`Tab ${tabId} not found`);
    return webContents2.executeJavaScript(code2);
  }
  /**
   * Close a tab
   */
  async closeTab(tabId) {
    const win2 = BrowserWindow$1.getAllWindows()[0];
    if (win2) {
      win2.webContents.send("browser:close-tab", { tabId });
    }
    this.tabs.delete(tabId);
  }
  /**
   * Close all managed tabs
   */
  async closeAllTabs() {
    for (const tabId of this.tabs.keys()) {
      await this.closeTab(tabId);
    }
  }
  /**
   * Get all tab info
   */
  getTabInfo() {
    return Array.from(this.tabs.values());
  }
  /**
   * Extract domain from URL
   */
  extractDomain(url) {
    try {
      return new URL(url).hostname;
    } catch {
      return url;
    }
  }
  delay(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }
}
const tabOrchestrator = new TabOrchestrator();
class DataPipeline {
  constructor(config2 = {}) {
    __publicField2(this, "config");
    this.config = config2;
  }
  /**
   * Process raw data through the full pipeline
   */
  async process(rawData) {
    var _a3, _b, _c;
    const stats = {
      inputCount: rawData.length,
      normalizedCount: 0,
      validCount: 0,
      duplicatesRemoved: 0,
      enrichedCount: 0,
      filteredCount: 0,
      outputCount: 0,
      errors: []
    };
    let data = rawData.map(
      (item) => typeof item === "object" && item !== null ? item : { value: item }
    );
    if ((_a3 = this.config.normalizationRules) == null ? void 0 : _a3.length) {
      data = data.map((item) => this.normalize(item));
      stats.normalizedCount = data.length;
    }
    if (this.config.schema) {
      const validated = [];
      for (const item of data) {
        const result = this.config.schema.safeParse(item);
        if (result.success) {
          validated.push(result.data);
        } else {
          stats.errors.push({
            item,
            error: result.error.message
          });
        }
      }
      data = validated;
      stats.validCount = data.length;
    }
    if ((_b = this.config.filters) == null ? void 0 : _b.length) {
      const beforeFilter = data.length;
      for (const filter of this.config.filters) {
        data = data.filter(filter);
      }
      stats.filteredCount = beforeFilter - data.length;
    }
    if (this.config.deduplication) {
      const beforeDedup = data.length;
      data = this.deduplicate(data);
      stats.duplicatesRemoved = beforeDedup - data.length;
    }
    if ((_c = this.config.enrichers) == null ? void 0 : _c.length) {
      const enriched = [];
      for (const item of data) {
        let enrichedItem = { ...item };
        for (const enricher of this.config.enrichers) {
          try {
            enrichedItem = await enricher(enrichedItem);
          } catch (error) {
            stats.errors.push({
              item,
              error: `Enrichment failed: ${error}`
            });
          }
        }
        enriched.push(enrichedItem);
      }
      data = enriched;
      stats.enrichedCount = data.length;
    }
    stats.outputCount = data.length;
    return { data, stats };
  }
  /**
   * Normalize a single item based on rules
   */
  normalize(item) {
    const result = { ...item };
    for (const rule of this.config.normalizationRules ?? []) {
      const value = result[rule.field];
      if (value === void 0 || value === null) continue;
      switch (rule.type) {
        case "price":
          result[rule.field] = this.normalizePrice(String(value));
          break;
        case "date":
          result[rule.field] = this.normalizeDate(String(value));
          break;
        case "name":
          result[rule.field] = this.normalizeName(String(value));
          break;
        case "email":
          result[rule.field] = this.normalizeEmail(String(value));
          break;
        case "phone":
          result[rule.field] = this.normalizePhone(String(value));
          break;
        case "url":
          result[rule.field] = this.normalizeUrl(String(value));
          break;
        case "text":
          result[rule.field] = this.normalizeText(String(value));
          break;
        case "number":
          result[rule.field] = this.normalizeNumber(String(value));
          break;
      }
    }
    return result;
  }
  /**
   * Normalize price strings to numbers
   * Handles: "$1,999.00", "1999 USD", "â‚¬1.999,00", "1999"
   */
  normalizePrice(value) {
    if (!value) return null;
    let cleaned = value.replace(/[$â‚¬Â£Â¥â‚¹]/g, "").trim();
    if (/^\d{1,3}(\.\d{3})*,\d{2}$/.test(cleaned)) {
      cleaned = cleaned.replace(/\./g, "").replace(",", ".");
    }
    cleaned = cleaned.replace(/[^\d.]/g, "");
    const num = parseFloat(cleaned);
    return isNaN(num) ? null : num;
  }
  /**
   * Normalize date strings to ISO format
   */
  normalizeDate(value) {
    if (!value) return null;
    try {
      const date2 = new Date(value);
      if (isNaN(date2.getTime())) return null;
      return date2.toISOString();
    } catch {
      return null;
    }
  }
  /**
   * Normalize names to Title Case
   */
  normalizeName(value) {
    return value.toLowerCase().split(" ").map((word) => word.charAt(0).toUpperCase() + word.slice(1)).join(" ").trim();
  }
  /**
   * Normalize email to lowercase
   */
  normalizeEmail(value) {
    return value.toLowerCase().trim();
  }
  /**
   * Normalize phone numbers to digits only
   */
  normalizePhone(value) {
    return value.replace(/[^\d+]/g, "");
  }
  /**
   * Normalize URLs
   */
  normalizeUrl(value) {
    let url = value.trim();
    if (!url.startsWith("http://") && !url.startsWith("https://")) {
      url = "https://" + url;
    }
    return url;
  }
  /**
   * Normalize text (trim, collapse whitespace)
   */
  normalizeText(value) {
    return value.replace(/\s+/g, " ").trim();
  }
  /**
   * Normalize number strings
   */
  normalizeNumber(value) {
    const num = parseFloat(value.replace(/[^\d.-]/g, ""));
    return isNaN(num) ? null : num;
  }
  /**
   * Deduplicate data based on configuration
   */
  deduplicate(data) {
    const config2 = this.config.deduplication;
    const seen = /* @__PURE__ */ new Map();
    for (const item of data) {
      const key = config2.fields.map((f) => String(item[f] ?? "")).join("|");
      if (!seen.has(key)) {
        seen.set(key, item);
      } else {
        const existing = seen.get(key);
        switch (config2.strategy) {
          case "first":
            break;
          case "last":
            seen.set(key, item);
            break;
          case "merge":
            seen.set(key, { ...existing, ...item });
            break;
          case "highest-quality":
            if (config2.qualityScorer) {
              const existingScore = config2.qualityScorer(existing);
              const newScore = config2.qualityScorer(item);
              if (newScore > existingScore) {
                seen.set(key, item);
              }
            }
            break;
        }
      }
    }
    return Array.from(seen.values());
  }
  /**
   * Export data as CSV
   */
  toCSV(data) {
    if (data.length === 0) return "";
    const headers = Object.keys(data[0]);
    const rows = data.map(
      (item) => headers.map((h) => {
        const val = item[h];
        const str2 = val === null || val === void 0 ? "" : String(val);
        if (str2.includes(",") || str2.includes('"') || str2.includes("\n")) {
          return `"${str2.replace(/"/g, '""')}"`;
        }
        return str2;
      }).join(",")
    );
    return [headers.join(","), ...rows].join("\n");
  }
  /**
   * Export data as JSON
   */
  toJSON(data, pretty = true) {
    return JSON.stringify(data, null, pretty ? 2 : 0);
  }
}
({
  lead: object({
    name: string().min(1),
    email: string().email().optional(),
    phone: string().optional(),
    company: string().optional(),
    title: string().optional(),
    linkedinUrl: string().url().optional(),
    source: string().optional()
  }),
  product: object({
    name: string().min(1),
    price: number().positive().optional(),
    currency: string().optional(),
    url: string().url().optional(),
    imageUrl: string().url().optional(),
    rating: number().min(0).max(5).optional(),
    reviewCount: number().int().nonnegative().optional(),
    inStock: boolean().optional()
  }),
  job: object({
    title: string().min(1),
    company: string().min(1),
    location: string().optional(),
    salary: string().optional(),
    description: string().optional(),
    url: string().url().optional(),
    postedDate: string().optional()
  }),
  article: object({
    title: string().min(1),
    content: string().optional(),
    author: string().optional(),
    publishedDate: string().optional(),
    url: string().url().optional(),
    source: string().optional()
  })
});
const memorySelectorStrategy = async (context) => {
  if (!context.selector) return null;
  const knownSelectors = agentMemory.getSelectors(context.domain, context.action);
  for (const altSelector of knownSelectors) {
    if (altSelector === context.selector) continue;
    try {
      const code2 = `
        const el = document.querySelector(${JSON.stringify(altSelector)});
        if (el) {
          if (${JSON.stringify(context.action)} === 'click') {
            el.click();
            return { success: true, selector: ${JSON.stringify(altSelector)} };
          } else if (${JSON.stringify(context.action)} === 'extract') {
            return { success: true, data: el.textContent, selector: ${JSON.stringify(altSelector)} };
          }
        }
        return null;
      `;
      const result = await codeExecutorService.execute(code2, { timeout: 5e3 });
      if (result.success && result.result) {
        await agentMemory.learnSelector(context.domain, context.action, altSelector, true);
        return {
          success: true,
          data: result.result,
          strategyUsed: "memory_selector",
          newSelector: altSelector
        };
      }
    } catch {
      continue;
    }
  }
  return null;
};
const commonPatternStrategy = async (context) => {
  if (!context.selector) return null;
  const patterns = {
    click: [
      'button:contains("Submit")',
      'input[type="submit"]',
      "a.btn",
      '[role="button"]',
      ".button"
    ],
    extract: [
      "main",
      "article",
      "#content",
      ".content",
      '[role="main"]'
    ],
    type: [
      'input[type="text"]',
      'input:not([type="hidden"])',
      "textarea",
      '[contenteditable="true"]'
    ]
  };
  const fallbacks = patterns[context.action] || [];
  for (const pattern of fallbacks) {
    try {
      const code2 = `
        const el = document.querySelector(${JSON.stringify(pattern)});
        if (el) {
          return { found: true, selector: ${JSON.stringify(pattern)} };
        }
        return null;
      `;
      const result = await codeExecutorService.execute(code2, { timeout: 3e3 });
      if (result.success && result.result) {
        return {
          success: true,
          data: result.result,
          strategyUsed: "common_pattern",
          newSelector: pattern
        };
      }
    } catch {
      continue;
    }
  }
  return null;
};
const textBasedStrategy = async (context) => {
  if (!context.selector) return null;
  const textMatch = context.selector.match(/contains\(["']([^"']+)["']\)/);
  const text = textMatch == null ? void 0 : textMatch[1];
  if (!text) return null;
  try {
    const code2 = `
      const walker = document.createTreeWalker(
        document.body,
        NodeFilter.SHOW_TEXT,
        null,
        false
      );
      
      let node;
      while (node = walker.nextNode()) {
        if (node.textContent.toLowerCase().includes(${JSON.stringify(text.toLowerCase())})) {
          const el = node.parentElement;
          if (el && (el.tagName === 'BUTTON' || el.tagName === 'A' || el.onclick)) {
            return { found: true, element: el.tagName, text: el.textContent.trim() };
          }
        }
      }
      return null;
    `;
    const result = await codeExecutorService.execute(code2, { timeout: 5e3 });
    if (result.success && result.result) {
      return {
        success: true,
        data: result.result,
        strategyUsed: "text_based"
      };
    }
  } catch {
  }
  return null;
};
const waitAndRetryStrategy = async (context) => {
  if (context.attemptCount > 3) return null;
  const waitTime = Math.min(1e3 * Math.pow(2, context.attemptCount), 1e4);
  await new Promise((resolve) => setTimeout(resolve, waitTime));
  if (context.code) {
    try {
      const result = await codeExecutorService.execute(context.code, { timeout: 1e4 });
      if (result.success) {
        return {
          success: true,
          data: result.result,
          strategyUsed: "wait_and_retry"
        };
      }
    } catch {
    }
  }
  return null;
};
const scrollRevealStrategy = async (context) => {
  if (!context.selector) return null;
  try {
    const scrollPositions = [
      "window.scrollTo(0, document.body.scrollHeight / 4)",
      "window.scrollTo(0, document.body.scrollHeight / 2)",
      "window.scrollTo(0, document.body.scrollHeight * 0.75)",
      "window.scrollTo(0, document.body.scrollHeight)"
    ];
    for (const scrollCode of scrollPositions) {
      await codeExecutorService.execute(scrollCode, { timeout: 1e3 });
      await new Promise((resolve) => setTimeout(resolve, 500));
      const checkCode = `
        const el = document.querySelector(${JSON.stringify(context.selector)});
        if (el) {
          const rect = el.getBoundingClientRect();
          if (rect.top >= 0 && rect.bottom <= window.innerHeight) {
            return { found: true, visible: true };
          }
        }
        return null;
      `;
      const result = await codeExecutorService.execute(checkCode, { timeout: 3e3 });
      if (result.success && result.result) {
        return {
          success: true,
          data: result.result,
          strategyUsed: "scroll_reveal"
        };
      }
    }
  } catch {
  }
  return null;
};
const structureAnalysisStrategy = async (context) => {
  if (context.action !== "extract") return null;
  try {
    const code2 = `
      // Analyze page structure and find main content
      const candidates = [
        document.querySelector('main'),
        document.querySelector('article'),
        document.querySelector('[role="main"]'),
        document.querySelector('#content'),
        document.querySelector('.content'),
        document.querySelector('.main'),
      ].filter(Boolean);
      
      if (candidates.length > 0) {
        const main = candidates[0];
        return {
          title: document.title,
          content: main.textContent.slice(0, 5000),
          links: [...main.querySelectorAll('a')].slice(0, 20).map(a => ({
            text: a.textContent.trim(),
            href: a.href
          })),
        };
      }
      
      // Fallback to body
      return {
        title: document.title,
        content: document.body.textContent.slice(0, 3000),
      };
    `;
    const result = await codeExecutorService.execute(code2, { timeout: 1e4 });
    if (result.success && result.result) {
      return {
        success: true,
        data: result.result,
        strategyUsed: "structure_analysis"
      };
    }
  } catch {
  }
  return null;
};
class ErrorRecovery {
  constructor() {
    __publicField2(this, "strategies", [
      waitAndRetryStrategy,
      memorySelectorStrategy,
      scrollRevealStrategy,
      commonPatternStrategy,
      textBasedStrategy,
      structureAnalysisStrategy
    ]);
  }
  /**
   * Attempt to recover from an error using multiple strategies
   */
  async recover(context) {
    console.log(`[ErrorRecovery] Attempting recovery for ${context.action} on ${context.domain}`);
    for (const strategy of this.strategies) {
      try {
        const result = await strategy(context);
        if (result == null ? void 0 : result.success) {
          console.log(`[ErrorRecovery] Success with strategy: ${result.strategyUsed}`);
          if (result.newSelector) {
            await agentMemory.learnSelector(context.domain, context.action, result.newSelector, true);
          }
          return result;
        }
      } catch (error) {
        console.log(`[ErrorRecovery] Strategy failed:`, error);
        continue;
      }
    }
    console.log(`[ErrorRecovery] All strategies exhausted`);
    await agentMemory.recordError(
      context.domain,
      context.action,
      context.error.message
    );
    return {
      success: false,
      data: null,
      strategyUsed: "none"
    };
  }
  /**
   * Add a custom recovery strategy
   */
  addStrategy(strategy, priority = "low") {
    if (priority === "high") {
      this.strategies.unshift(strategy);
    } else {
      this.strategies.push(strategy);
    }
  }
}
const errorRecovery = new ErrorRecovery();
class IntegrationLayer {
  constructor() {
    __publicField2(this, "exportDir");
    this.exportDir = path$3.join(app$1.getPath("documents"), "BrowserAgent", "exports");
    this.ensureExportDir();
  }
  async ensureExportDir() {
    try {
      await fs$2.mkdir(this.exportDir, { recursive: true });
    } catch {
    }
  }
  /**
   * Send data to a webhook
   */
  async sendWebhook(data, config2) {
    try {
      const payload = config2.includeTimestamp ? { timestamp: (/* @__PURE__ */ new Date()).toISOString(), data } : data;
      const response = await fetch(config2.url, {
        method: config2.method || "POST",
        headers: {
          "Content-Type": "application/json",
          ...config2.headers
        },
        body: JSON.stringify(payload)
      });
      if (!response.ok) {
        throw new Error(`Webhook failed: ${response.status} ${response.statusText}`);
      }
      return {
        success: true,
        message: `Webhook sent successfully to ${config2.url}`,
        data: { status: response.status }
      };
    } catch (error) {
      const errorMsg = error instanceof Error ? error.message : String(error);
      return {
        success: false,
        message: `Webhook failed: ${errorMsg}`
      };
    }
  }
  /**
   * Export data to a file
   */
  async exportToFile(data, config2) {
    try {
      const timestamp = (/* @__PURE__ */ new Date()).toISOString().replace(/[:.]/g, "-");
      const filename = config2.filename || `export-${timestamp}`;
      const directory = config2.directory || this.exportDir;
      let content;
      let extension;
      switch (config2.format) {
        case "json":
          content = JSON.stringify(data, null, config2.pretty ? 2 : 0);
          extension = "json";
          break;
        case "csv":
          if (Array.isArray(data)) {
            const pipeline = new DataPipeline({});
            content = pipeline.toCSV(data);
          } else {
            content = String(data);
          }
          extension = "csv";
          break;
        case "txt":
          content = typeof data === "string" ? data : JSON.stringify(data, null, 2);
          extension = "txt";
          break;
        default:
          throw new Error(`Unknown format: ${config2.format}`);
      }
      const filePath = path$3.join(directory, `${filename}.${extension}`);
      await fs$2.mkdir(directory, { recursive: true });
      await fs$2.writeFile(filePath, content, "utf-8");
      return {
        success: true,
        message: `Exported to ${filePath}`,
        data: { path: filePath, size: content.length }
      };
    } catch (error) {
      const errorMsg = error instanceof Error ? error.message : String(error);
      return {
        success: false,
        message: `Export failed: ${errorMsg}`
      };
    }
  }
  /**
   * Copy data to clipboard
   */
  async copyToClipboard(data, format2 = "text") {
    try {
      let content;
      if (format2 === "json") {
        content = JSON.stringify(data, null, 2);
      } else if (typeof data === "string") {
        content = data;
      } else {
        content = JSON.stringify(data);
      }
      clipboard.writeText(content);
      return {
        success: true,
        message: "Copied to clipboard",
        data: { length: content.length }
      };
    } catch (error) {
      const errorMsg = error instanceof Error ? error.message : String(error);
      return {
        success: false,
        message: `Clipboard copy failed: ${errorMsg}`
      };
    }
  }
  /**
   * Show desktop notification
   */
  async showNotification(config2) {
    try {
      if (!Notification.isSupported()) {
        return {
          success: false,
          message: "Notifications not supported on this system"
        };
      }
      const notification = new Notification({
        title: config2.title,
        body: config2.body,
        silent: config2.silent ?? false,
        urgency: config2.urgency ?? "normal"
      });
      notification.show();
      return {
        success: true,
        message: "Notification shown"
      };
    } catch (error) {
      const errorMsg = error instanceof Error ? error.message : String(error);
      return {
        success: false,
        message: `Notification failed: ${errorMsg}`
      };
    }
  }
  /**
   * Read from a local file
   */
  async readFile(filePath) {
    try {
      const content = await fs$2.readFile(filePath, "utf-8");
      let data = content;
      try {
        data = JSON.parse(content);
      } catch {
      }
      return {
        success: true,
        message: `Read ${filePath}`,
        data
      };
    } catch (error) {
      const errorMsg = error instanceof Error ? error.message : String(error);
      return {
        success: false,
        message: `Read failed: ${errorMsg}`
      };
    }
  }
  /**
   * List exported files
   */
  async listExports() {
    try {
      const files = await fs$2.readdir(this.exportDir);
      const fileInfos = await Promise.all(
        files.map(async (file) => {
          const filePath = path$3.join(this.exportDir, file);
          const stats = await fs$2.stat(filePath);
          return {
            name: file,
            path: filePath,
            size: stats.size,
            modified: stats.mtime.toISOString()
          };
        })
      );
      return {
        success: true,
        message: `Found ${files.length} exports`,
        data: fileInfos
      };
    } catch (error) {
      const errorMsg = error instanceof Error ? error.message : String(error);
      return {
        success: false,
        message: `List failed: ${errorMsg}`
      };
    }
  }
  /**
   * Get export directory path
   */
  getExportDirectory() {
    return this.exportDir;
  }
  /**
   * Batch operations - run multiple integrations
   */
  async batch(operations) {
    const results2 = [];
    for (const op of operations) {
      let result;
      switch (op.type) {
        case "webhook":
          result = await this.sendWebhook(op.data, op.config);
          break;
        case "export":
          result = await this.exportToFile(op.data, op.config);
          break;
        case "clipboard":
          result = await this.copyToClipboard(op.data, op.config.format);
          break;
        case "notification":
          result = await this.showNotification(op.config);
          break;
        default:
          result = { success: false, message: `Unknown operation type` };
      }
      results2.push(result);
    }
    return results2;
  }
}
const integrationLayer = new IntegrationLayer();
class WorkflowEngine {
  constructor() {
    __publicField2(this, "currentWorkflow", null);
    __publicField2(this, "variables", {});
    __publicField2(this, "results", {});
    __publicField2(this, "errors", []);
    __publicField2(this, "stepsExecuted", 0);
    __publicField2(this, "aborted", false);
  }
  /**
   * Execute a workflow
   */
  async execute(workflow) {
    const startTime2 = Date.now();
    this.currentWorkflow = workflow;
    this.variables = { ...workflow.variables };
    this.results = {};
    this.errors = [];
    this.stepsExecuted = 0;
    this.aborted = false;
    const taskPlan = {
      explanation: workflow.description,
      steps: workflow.steps.map((s) => ({
        id: s.id,
        action: s.action,
        description: s.description,
        status: "pending"
      }))
    };
    await stateManager.createTask(workflow.id, workflow.name, taskPlan);
    try {
      await this.executeSteps(workflow.steps);
      await stateManager.updateTaskStatus(workflow.id, "completed");
    } catch (error) {
      const errorMsg = error instanceof Error ? error.message : String(error);
      await stateManager.updateTaskStatus(workflow.id, "failed", errorMsg);
    }
    return {
      workflowId: workflow.id,
      success: this.errors.length === 0,
      results: this.results,
      variables: this.variables,
      errors: this.errors,
      duration: Date.now() - startTime2,
      stepsExecuted: this.stepsExecuted
    };
  }
  /**
   * Execute a list of steps sequentially
   */
  async executeSteps(steps) {
    for (const step of steps) {
      if (this.aborted) break;
      await this.executeStep(step);
    }
  }
  /**
   * Execute a single step
   */
  async executeStep(step) {
    if (this.aborted) return null;
    this.stepsExecuted++;
    const startTime2 = Date.now();
    try {
      await stateManager.startStep(this.currentWorkflow.id, this.stepsExecuted - 1);
      let result = null;
      switch (step.action) {
        case "navigate":
          result = await this.executeNavigate(step);
          break;
        case "click":
          result = await this.executeClick(step);
          break;
        case "type":
          result = await this.executeType(step);
          break;
        case "scroll":
          result = await this.executeScroll(step);
          break;
        case "wait":
          result = await this.executeWait(step);
          break;
        case "extract":
          result = await this.executeExtract(step);
          break;
        case "loop":
          result = await this.executeLoop(step);
          break;
        case "condition":
          result = await this.executeCondition(step);
          break;
        case "parallel":
          result = await this.executeParallel(step);
          break;
        case "set_variable":
          result = await this.executeSetVariable(step);
          break;
        case "save_data":
          result = await this.executeSaveData(step);
          break;
        case "notify":
          result = await this.executeNotify(step);
          break;
        default:
          throw new Error(`Unknown action: ${step.action}`);
      }
      this.results[step.id] = result;
      await stateManager.completeStep(this.currentWorkflow.id, this.stepsExecuted - 1, {
        success: true,
        data: result,
        startedAt: startTime2
      });
      return result;
    } catch (error) {
      const errorMsg = error instanceof Error ? error.message : String(error);
      this.errors.push({ stepId: step.id, error: errorMsg });
      await stateManager.completeStep(this.currentWorkflow.id, this.stepsExecuted - 1, {
        success: false,
        data: null,
        error: errorMsg,
        startedAt: startTime2
      });
      if (step.onError === "stop") {
        this.aborted = true;
        throw error;
      } else if (step.onError === "retry" && step.maxRetries) {
        for (let i2 = 0; i2 < step.maxRetries; i2++) {
          try {
            await this.delay(1e3 * (i2 + 1));
            return await this.executeStep({ ...step, maxRetries: 0 });
          } catch {
            continue;
          }
        }
      }
      return null;
    }
  }
  // Action implementations
  async executeNavigate(step) {
    const url = this.interpolate(step.url || "");
    try {
      const target = browserTargetService.getActiveWebContents();
      await target.loadURL(url);
    } catch {
      await agentTabOpenService.openAgentTab({
        url,
        background: false,
        agentCreated: true
      });
    }
    await this.delay(1500);
    return { navigated: true, url };
  }
  async executeClick(step) {
    const selector = this.interpolate(step.selector || "");
    const code2 = `
      const el = document.querySelector(${JSON.stringify(selector)});
      if (el) { el.click(); return { clicked: true }; }
      return { clicked: false };
    `;
    const result = await codeExecutorService.execute(code2, { timeout: 5e3 });
    await this.delay(1e3);
    return result.result;
  }
  async executeType(step) {
    const selector = this.interpolate(step.selector || "");
    const text = this.interpolate(step.text || "");
    const code2 = `
      const el = document.querySelector(${JSON.stringify(selector)});
      if (el) { 
        el.focus(); 
        el.value = ${JSON.stringify(text)}; 
        el.dispatchEvent(new Event('input', { bubbles: true }));
        return { typed: true }; 
      }
      return { typed: false };
    `;
    const result = await codeExecutorService.execute(code2, { timeout: 5e3 });
    return result.result;
  }
  async executeScroll(step) {
    const selector = step.selector ? this.interpolate(step.selector) : null;
    const code2 = selector ? `document.querySelector(${JSON.stringify(selector)})?.scrollIntoView({ behavior: 'smooth' }); return { scrolled: true };` : `window.scrollBy(0, window.innerHeight); return { scrolled: true };`;
    await codeExecutorService.execute(code2, { timeout: 3e3 });
    await this.delay(500);
    return { scrolled: true };
  }
  async executeWait(step) {
    const ms = step.ms || 1e3;
    await this.delay(ms);
    return { waited: ms };
  }
  async executeExtract(step) {
    const code2 = this.interpolate(step.code || "return null;");
    const result = await codeExecutorService.execute(code2, { timeout: 15e3 });
    if (step.variableName) {
      this.variables[step.variableName] = result.result;
    }
    return result.result;
  }
  async executeLoop(step) {
    const results2 = [];
    let iterations = 0;
    if (step.loopType === "count" && step.loopCount) {
      for (let i2 = 0; i2 < step.loopCount; i2++) {
        if (this.aborted) break;
        this.variables["$index"] = i2;
        this.variables["$iteration"] = i2 + 1;
        if (step.loopSteps) {
          await this.executeSteps(step.loopSteps);
        }
        iterations++;
        results2.push(this.results);
      }
    } else if (step.loopType === "while" && step.loopCondition) {
      const maxIterations2 = 100;
      while (iterations < maxIterations2 && !this.aborted) {
        const conditionResult = this.evaluateCondition(step.loopCondition);
        if (!conditionResult) break;
        this.variables["$index"] = iterations;
        this.variables["$iteration"] = iterations + 1;
        if (step.loopSteps) {
          await this.executeSteps(step.loopSteps);
        }
        iterations++;
        results2.push({ ...this.results });
      }
    } else if (step.loopType === "forEach" && step.loopItems) {
      const items = this.variables[step.loopItems];
      if (Array.isArray(items)) {
        for (let i2 = 0; i2 < items.length; i2++) {
          if (this.aborted) break;
          this.variables["$index"] = i2;
          this.variables["$iteration"] = i2 + 1;
          this.variables[step.loopVariable || "$item"] = items[i2];
          if (step.loopSteps) {
            await this.executeSteps(step.loopSteps);
          }
          iterations++;
          results2.push({ ...this.results });
        }
      }
    }
    return { iterations, results: results2 };
  }
  async executeCondition(step) {
    if (!step.condition) return { branch: "none" };
    const conditionResult = this.evaluateCondition(step.condition);
    if (conditionResult && step.thenSteps) {
      await this.executeSteps(step.thenSteps);
      return { branch: "then" };
    } else if (!conditionResult && step.elseSteps) {
      await this.executeSteps(step.elseSteps);
      return { branch: "else" };
    }
    return { branch: "none" };
  }
  async executeParallel(step) {
    if (!step.parallelSteps) return { completed: 0 };
    const promises = step.parallelSteps.map((s) => this.executeStep(s));
    await Promise.all(promises);
    return { completed: step.parallelSteps.length };
  }
  async executeSetVariable(step) {
    if (!step.variableName) return { set: false };
    let value = step.variableValue;
    if (typeof value === "string") {
      value = this.interpolate(value);
    }
    this.variables[step.variableName] = value;
    return { set: true };
  }
  async executeSaveData(step) {
    const key = step.dataKey || "data";
    const data = this.variables[key] || this.results;
    await agentMemory.remember(`workflow:${this.currentWorkflow.id}:${key}`, data, "context");
    return { saved: true };
  }
  async executeNotify(step) {
    const message = this.interpolate(step.text || "Workflow notification");
    console.log(`[Workflow Notification] ${message}`);
    return { notified: true };
  }
  // Helper methods
  interpolate(template) {
    return template.replace(/\{\{(\w+)\}\}/g, (_, key) => {
      const value = this.variables[key];
      return value !== void 0 ? String(value) : `{{${key}}}`;
    });
  }
  evaluateCondition(condition) {
    try {
      const context = { ...this.variables, results: this.results };
      const fn = new Function(...Object.keys(context), `return ${condition};`);
      return Boolean(fn(...Object.values(context)));
    } catch {
      return false;
    }
  }
  delay(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }
  /**
   * Abort the current workflow
   */
  abort() {
    this.aborted = true;
  }
  /**
   * Get current variables
   */
  getVariables() {
    return { ...this.variables };
  }
  /**
   * Get current results
   */
  getResults() {
    return { ...this.results };
  }
}
function createWorkflow(name, description, steps, variables = {}) {
  return {
    id: `workflow-${v4$2()}`,
    name,
    description,
    steps,
    variables,
    createdAt: Date.now()
  };
}
const workflowEngine = new WorkflowEngine();
function getApiKey() {
  return process.env.NVIDIA_API_KEY || null;
}
function createLLM(temperature = 0.3) {
  const apiKey = getApiKey();
  if (!apiKey) throw new Error("NVIDIA_API_KEY not found");
  return new ChatOpenAI({
    apiKey,
    model: "moonshotai/kimi-k2-instruct",
    temperature,
    maxTokens: 4096,
    configuration: { baseURL: "https://integrate.api.nvidia.com/v1" }
  });
}
const CAPABILITIES_PROMPT = `You are an AUTONOMOUS AI agent embedded in a web browser. You COMPLETE tasks independently without asking the user to do things.

## Core Principle
DO NOT tell the user to click things or navigate manually. YOU do it. If a task requires multiple steps (navigate, click, wait, extract), YOU execute ALL of them.

## Your Actions

### navigate
Open a URL in the browser tab.
- Use action: "navigate" with "url" field
- Example: { "action": "navigate", "url": "https://github.com/user", "description": "Open user profile" }

### click  
Click an element on the page.
- Use action: "click" with "selector" field (CSS selector)
- Example: { "action": "click", "selector": "[data-tab='repositories']", "description": "Click Repositories tab" }

### type
Type text into an input field.
- Use action: "type" with "selector" and "text" fields
- Example: { "action": "type", "selector": "input[name='q']", "text": "browser", "description": "Search for browser" }

### extract
Run JavaScript to extract data from the page.
- Use action: "extract" with "code" field
- The code should return the data you need
- Example: { "action": "extract", "code": "return [...document.querySelectorAll('a')].map(a => a.href)", "description": "Get all links" }

### scroll
Scroll the page.
- Use action: "scroll" with optional "selector" field
- Example: { "action": "scroll", "description": "Scroll down to load more content" }

### wait
Wait for page to update after an action.
- Use action: "wait" with optional "ms" field (default 1000ms)
- Example: { "action": "wait", "ms": 2000, "description": "Wait for content to load" }

## Important Rules
1. NEVER tell the user to do something - YOU do it
2. Chain multiple actions to complete complex tasks
3. After clicking/navigating, add a "wait" action before extracting
4. Use robust selectors (data attributes, aria labels, text content)
5. If you need to find something, navigate there first, then extract

## Response Format
Always respond with valid JSON matching the requested schema.`;
class BrowserAgentPipeline {
  constructor() {
    __publicField2(this, "llm");
    this.llm = createLLM();
    this.registerTool();
  }
  registerTool() {
    const schema = object({
      query: string().describe("The user's natural language request about the current page")
    });
    const tool2 = {
      name: "browser_agent",
      description: `Intelligent browser agent that reasons about user requests, plans an approach, executes code if needed, and presents results. Use for: summarizing pages, extracting data, analyzing content, finding information, answering questions about the page, or performing complex multi-step browser tasks.`,
      schema,
      requiresApproval: true,
      execute: async ({ query }) => {
        return this.runPipeline(query);
      }
    };
    toolRegistry.register(tool2);
  }
  /**
   * Run a complex multi-URL task with parallel execution
   * Uses the new infrastructure for state management, parallel tabs, and memory
   */
  async runComplexTask(query, urls, extractionCode) {
    const taskId = `task-${Date.now()}`;
    const startTime2 = Date.now();
    const plan2 = {
      explanation: `Extract data from ${urls.length} URLs`,
      steps: urls.map((url, i2) => ({
        id: `step-${i2}`,
        action: "extract",
        description: `Extract from ${new URL(url).hostname}`,
        status: "pending",
        data: { url }
      }))
    };
    await stateManager.createTask(taskId, query, plan2);
    const tasks = urls.map((url) => ({
      url,
      extractionCode,
      timeout: 3e4
    }));
    const results2 = await tabOrchestrator.executeParallel(tasks);
    for (const result of results2) {
      const domain = new URL(result.url).hostname;
      if (result.success) {
        await agentMemory.recordVisit(domain, true);
        await agentMemory.learnSelector(domain, "extraction", extractionCode, true);
      } else {
        await agentMemory.recordVisit(domain, false);
        await agentMemory.recordError(domain, "extraction_failed", result.error || "Unknown error");
      }
    }
    const pipeline = new DataPipeline({
      deduplication: {
        fields: ["url"],
        strategy: "last"
      }
    });
    const { data: processedData } = await pipeline.process(
      results2.filter((r) => r.success).map((r) => r.data)
    );
    await stateManager.updateTaskStatus(taskId, "completed");
    return {
      taskId,
      results: processedData,
      stats: {
        success: results2.filter((r) => r.success).length,
        failed: results2.filter((r) => !r.success).length,
        duration: Date.now() - startTime2
      }
    };
  }
  /**
   * Resume a previously started task from checkpoint
   */
  async resumeTask(taskId) {
    return stateManager.resumeFromCheckpoint(taskId);
  }
  /**
   * Get task progress
   */
  getTaskProgress(taskId) {
    return stateManager.getProgress(taskId);
  }
  /**
   * Run a structured workflow
   */
  async runWorkflow(name, description, steps, variables = {}) {
    const workflow = createWorkflow(name, description, steps, variables);
    return workflowEngine.execute(workflow);
  }
  /**
   * Export extracted data to file
   */
  async exportData(data, format2 = "json", filename) {
    return integrationLayer.exportToFile(data, { format: format2, filename, pretty: true });
  }
  /**
   * Send data to webhook
   */
  async sendToWebhook(data, webhookUrl) {
    return integrationLayer.sendWebhook(data, { url: webhookUrl, includeTimestamp: true });
  }
  /**
   * Show desktop notification
   */
  async notify(title, body) {
    return integrationLayer.showNotification({ title, body });
  }
  /**
   * Attempt error recovery for a failed action
   */
  async attemptRecovery(action, selector, code2, error, domain) {
    return errorRecovery.recover({
      action,
      selector,
      code: code2,
      error,
      attemptCount: 1,
      domain
    });
  }
  /**
   * Main pipeline execution
   */
  async runPipeline(query) {
    var _a3, _b;
    const startTime2 = Date.now();
    let output = "";
    try {
      const pageContext = await this.getPageContext();
      output += "## ðŸ§  Reasoning\n";
      const reasoning = await this.reason(query, pageContext);
      output += `${reasoning.understanding}

`;
      output += "## ðŸ“‹ Plan\n";
      const plan2 = await this.plan(query, reasoning, pageContext);
      output += `${plan2.explanation}
`;
      plan2.steps.forEach((step, i2) => {
        output += `${i2 + 1}. ${step.description}
`;
      });
      output += "\n";
      let executionData = null;
      const hasExecutableSteps = plan2.steps.some(
        (s) => s.code || s.url || s.action === "click" || s.action === "type" || s.action === "scroll" || s.action === "wait" || s.action === "extract"
      );
      if (reasoning.requiresExecution && hasExecutableSteps) {
        output += "## âš¡ Execution\n";
        const execResults = [];
        for (const step of plan2.steps) {
          try {
            if (step.action === "navigate" && step.url) {
              try {
                const target = browserTargetService.getActiveWebContents();
                await target.loadURL(step.url);
                output += `âœ… ${step.description}
`;
                execResults.push({ success: true, data: `Navigated to ${step.url}` });
              } catch {
                const tabId = await agentTabOpenService.openAgentTab({
                  url: step.url,
                  background: false,
                  agentCreated: true
                });
                output += `âœ… ${step.description}
`;
                execResults.push({ success: true, data: `Opened ${step.url} in tab ${tabId}` });
              }
              await new Promise((r) => setTimeout(r, 1500));
              continue;
            }
            if (step.action === "click" && step.selector) {
              const selector = step.selector;
              const clickCode = `
                const el = document.querySelector(${JSON.stringify(selector)});
                if (el) { el.click(); return { clicked: true, selector: ${JSON.stringify(selector)} }; }
                else { return { clicked: false, error: 'Element not found: ' + ${JSON.stringify(selector)} }; }
              `;
              const result = await codeExecutorService.execute(clickCode, { timeout: 5e3 });
              if (result.success && ((_a3 = result.result) == null ? void 0 : _a3.clicked)) {
                output += `âœ… ${step.description}
`;
                execResults.push({ success: true, data: result.result });
              } else {
                output += `âŒ ${step.description}: Element not found
`;
                execResults.push({ success: false, data: null, error: "Element not found" });
              }
              await new Promise((r) => setTimeout(r, 1e3));
              continue;
            }
            if (step.action === "type" && step.selector && step.text) {
              const selector = step.selector;
              const text = step.text;
              const typeCode = `
                const el = document.querySelector(${JSON.stringify(selector)});
                if (el) { 
                  el.focus(); 
                  el.value = ${JSON.stringify(text)}; 
                  el.dispatchEvent(new Event('input', { bubbles: true }));
                  return { typed: true }; 
                }
                return { typed: false, error: 'Input not found' };
              `;
              const result = await codeExecutorService.execute(typeCode, { timeout: 5e3 });
              if (result.success && ((_b = result.result) == null ? void 0 : _b.typed)) {
                output += `âœ… ${step.description}
`;
                execResults.push({ success: true, data: result.result });
              } else {
                output += `âŒ ${step.description}: Input not found
`;
                execResults.push({ success: false, data: null, error: "Input not found" });
              }
              continue;
            }
            if (step.action === "scroll") {
              const selector = step.selector;
              const scrollCode = selector ? `document.querySelector(${JSON.stringify(selector)})?.scrollIntoView({ behavior: 'smooth' }); return { scrolled: true };` : `window.scrollBy(0, window.innerHeight); return { scrolled: true };`;
              await codeExecutorService.execute(scrollCode, { timeout: 3e3 });
              output += `âœ… ${step.description}
`;
              execResults.push({ success: true, data: { scrolled: true } });
              await new Promise((r) => setTimeout(r, 500));
              continue;
            }
            if (step.action === "wait") {
              const ms = step.ms || 1e3;
              await new Promise((r) => setTimeout(r, ms));
              output += `âœ… ${step.description}
`;
              execResults.push({ success: true, data: { waited: ms } });
              continue;
            }
            if (step.action === "extract" || step.code) {
              const code2 = step.code || step.code;
              if (code2) {
                await new Promise((r) => setTimeout(r, 500));
                let sanitizedCode = code2.replace(/window\.open\s*\([^)]*\)\s*;?/g, "/* removed */").replace(/window\.location\s*=\s*[^;]+;?/g, "/* removed */").replace(/window\.location\.href\s*=\s*[^;]+;?/g, "/* removed */");
                const result = await codeExecutorService.execute(sanitizedCode, { timeout: 15e3 });
                execResults.push({
                  success: result.success,
                  data: result.result,
                  error: result.error
                });
                if (!result.success) {
                  output += `âŒ ${step.description}: ${result.error}
`;
                } else {
                  output += `âœ… ${step.description}
`;
                }
              }
              continue;
            }
          } catch (stepError) {
            output += `âŒ ${step.description}: ${stepError.message}
`;
            execResults.push({ success: false, data: null, error: stepError.message });
          }
        }
        executionData = execResults.length === 1 ? execResults[0].data : execResults.map((r) => r.data);
        output += "\n";
      }
      output += "## ðŸ’¬ Response\n";
      const presentation = await this.present(query, reasoning, executionData, pageContext);
      output += presentation.response;
      const duration2 = Date.now() - startTime2;
      output += `

---
*Completed in ${duration2}ms*`;
      return output;
    } catch (error) {
      console.error("[BrowserAgentPipeline] Error:", error);
      return `${output}

âŒ Pipeline Error: ${error.message}`;
    }
  }
  /**
   * Get current page context for the LLM (gracefully handles no active webview)
   */
  async getPageContext() {
    var _a3, _b, _c, _d, _e, _f;
    try {
      const context = await domContextService.getContext();
      return `Current Page:
- URL: ${context.url}
- Title: ${context.title}
- Buttons: ${((_b = (_a3 = context.interactiveElements) == null ? void 0 : _a3.buttons) == null ? void 0 : _b.length) || 0}
- Links: ${((_d = (_c = context.interactiveElements) == null ? void 0 : _c.links) == null ? void 0 : _d.length) || 0}
- Inputs: ${((_f = (_e = context.interactiveElements) == null ? void 0 : _e.inputs) == null ? void 0 : _f.length) || 0}`;
    } catch {
      return "No page currently open. You can navigate to a URL.";
    }
  }
  /**
   * Step 1: REASON - Understand the user's request
   */
  async reason(query, pageContext) {
    const prompt = `Analyze this user request.

${pageContext}

User Request: "${query}"

Respond with JSON:
{
  "understanding": "Brief explanation of what the user wants (1-2 sentences)",
  "intent": "categorize as: navigate | extract_data | summarize | find_info | interact | analyze | question",
  "requiresExecution": true/false (true if this needs navigation OR code execution)
}

IMPORTANT: If the user wants to open/go to/visit a URL or website, set intent to "navigate" and requiresExecution to TRUE.`;
    try {
      const response = await this.llm.invoke([
        new SystemMessage(CAPABILITIES_PROMPT),
        new HumanMessage(prompt)
      ]);
      const content = typeof response.content === "string" ? response.content : JSON.stringify(response.content);
      const jsonMatch = content.match(/\{[\s\S]*\}/);
      if (jsonMatch) {
        return JSON.parse(jsonMatch[0]);
      }
      const isNavigation = /\b(open|go to|navigate|visit|take me to)\b/i.test(query);
      return {
        understanding: `User wants to: ${query}`,
        intent: isNavigation ? "navigate" : "extract_data",
        requiresExecution: true
      };
    } catch (error) {
      console.error("[Reason] Error:", error);
      const isNavigation = /\b(open|go to|navigate|visit|take me to)\b/i.test(query);
      return {
        understanding: `Processing request: ${query}`,
        intent: isNavigation ? "navigate" : "extract_data",
        requiresExecution: true
      };
    }
  }
  /**
   * Step 2: PLAN - Decide how to approach the task
   */
  async plan(query, reasoning, pageContext) {
    const prompt = `Create an execution plan for this browser task. YOU will execute ALL steps - do NOT tell the user to do anything.

${pageContext}

User Request: "${query}"
Understanding: ${reasoning.understanding}
Intent: ${reasoning.intent}

## Available Actions

1. **navigate** - Open a URL
   { "action": "navigate", "url": "https://...", "description": "..." }

2. **click** - Click an element  
   { "action": "click", "selector": "CSS selector", "description": "..." }

3. **type** - Type into an input
   { "action": "type", "selector": "CSS selector", "text": "text to type", "description": "..." }

4. **scroll** - Scroll the page
   { "action": "scroll", "description": "..." }

5. **wait** - Wait for page to update
   { "action": "wait", "ms": 1500, "description": "..." }

6. **extract** - Run JS to get data
   { "action": "extract", "code": "return document.title;", "description": "..." }

## Rules
- Chain multiple actions to complete complex tasks
- After navigate/click, add a wait before extract
- Use robust selectors (text content, aria-label, data-* attributes)
- NEVER tell user to do something manually - YOU do it

## Known Selectors for Common Sites

### GitHub
- Repositories tab: \`a[data-tab-item="repositories"]\` or \`nav a:contains("Repositories")\`
- Repository list items: \`#user-repositories-list li\` or \`div[data-filterable-for="your-repos-filter"] li\`
- Repository names: \`#user-repositories-list h3 a\` or \`a[itemprop="name codeRepository"]\`
- Stars count: \`a[href$="/stargazers"] span\`

### Google
- Search input: \`input[name="q"]\` or \`textarea[name="q"]\`
- Search results: \`div.g\` or \`div[data-sokoban-container]\`

### Amazon
- Search input: \`#twotabsearchtextbox\`
- Product items: \`div[data-component-type="s-search-result"]\`
- Product title: \`h2 a span\`
- Price: \`span.a-price span.a-offscreen\`

Respond with JSON:
{
  "explanation": "Brief approach (1 sentence)",
  "steps": [
    { "action": "...", "description": "...", ... }
  ]
}`;
    try {
      const response = await this.llm.invoke([
        new SystemMessage(CAPABILITIES_PROMPT),
        new HumanMessage(prompt)
      ]);
      const content = typeof response.content === "string" ? response.content : JSON.stringify(response.content);
      const jsonMatch = content.match(/\{[\s\S]*\}/);
      if (jsonMatch) {
        const parsed = JSON.parse(jsonMatch[0]);
        return parsed;
      }
      if (reasoning.intent === "navigate") {
        const url = this.extractUrlFromQuery(query);
        if (url) {
          return {
            explanation: `Navigate to ${url}`,
            steps: [{ action: "navigate", description: `Open ${url}`, url }]
          };
        }
      }
      return {
        explanation: "Will extract content from the page",
        steps: [{
          action: "extract",
          description: "Extract page content",
          code: "return document.body.innerText;"
        }]
      };
    } catch (error) {
      console.error("[Plan] Error:", error);
      if (reasoning.intent === "navigate") {
        const url = this.extractUrlFromQuery(query);
        if (url) {
          return {
            explanation: `Navigate to ${url}`,
            steps: [{ action: "navigate", description: `Open ${url}`, url }]
          };
        }
      }
      return {
        explanation: "Fallback: extracting page text",
        steps: [{
          action: "extract",
          description: "Get page text",
          code: "return document.body.innerText;"
        }]
      };
    }
  }
  /**
   * Extract URL from a navigation query
   */
  extractUrlFromQuery(query) {
    const sites = {
      youtube: "https://www.youtube.com",
      google: "https://www.google.com",
      github: "https://www.github.com",
      twitter: "https://www.twitter.com",
      x: "https://www.x.com",
      facebook: "https://www.facebook.com",
      reddit: "https://www.reddit.com",
      linkedin: "https://www.linkedin.com",
      amazon: "https://www.amazon.com",
      netflix: "https://www.netflix.com",
      wikipedia: "https://www.wikipedia.org"
    };
    const lowerQuery = query.toLowerCase();
    for (const [name, url] of Object.entries(sites)) {
      if (lowerQuery.includes(name)) {
        return url;
      }
    }
    const urlMatch = query.match(/https?:\/\/[^\s]+/i);
    if (urlMatch) return urlMatch[0];
    const domainMatch = query.match(/\b([a-z0-9-]+\.(com|org|net|io|co|dev|app))\b/i);
    if (domainMatch) return `https://${domainMatch[1]}`;
    return null;
  }
  /**
   * Step 4: PRESENT - Formulate the final response
   */
  async present(query, reasoning, executionData, pageContext) {
    let dataStr = "";
    if (executionData !== null && executionData !== void 0) {
      if (typeof executionData === "string") {
        dataStr = executionData.length > 8e3 ? executionData.substring(0, 8e3) + "...(truncated)" : executionData;
      } else {
        try {
          const json = JSON.stringify(executionData, null, 2);
          dataStr = json.length > 8e3 ? json.substring(0, 8e3) + "...(truncated)" : json;
        } catch {
          dataStr = String(executionData);
        }
      }
    }
    const prompt = `Generate a helpful response for the user based on the data collected.

${pageContext}

User Request: "${query}"
Intent: ${reasoning.intent}

Data Collected:
${dataStr || "(No data collected - respond based on page context)"}

Instructions:
- Directly answer the user's question or fulfill their request
- Be concise but complete
- Format appropriately (use markdown if helpful)
- If summarizing, highlight key points
- If listing data, organize it clearly

Respond with JSON:
{
  "response": "Your helpful response to the user",
  "format": "text|list|table|code|mixed"
}`;
    try {
      const response = await this.llm.invoke([
        new SystemMessage("You are a helpful assistant. Respond with the requested JSON format."),
        new HumanMessage(prompt)
      ]);
      const content = typeof response.content === "string" ? response.content : JSON.stringify(response.content);
      const jsonMatch = content.match(/\{[\s\S]*\}/);
      if (jsonMatch) {
        return JSON.parse(jsonMatch[0]);
      }
      return {
        response: content,
        format: "text"
      };
    } catch (error) {
      console.error("[Present] Error:", error);
      return {
        response: dataStr || "Unable to generate response",
        format: "text"
      };
    }
  }
}
const browserAgentPipeline = new BrowserAgentPipeline();
const BrowserAgentPipeline$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BrowserAgentPipeline,
  browserAgentPipeline
}, Symbol.toStringTag, { value: "Module" }));
const { app, BrowserWindow, ipcMain, webContents } = electron;
const planMemory = new PlanMemory();
const __dirname$1 = path__default$1.dirname(fileURLToPath(import.meta.url));
process.env.APP_ROOT = path__default$1.join(__dirname$1, "..");
const VITE_DEV_SERVER_URL = process.env["VITE_DEV_SERVER_URL"];
const MAIN_DIST = path__default$1.join(process.env.APP_ROOT, "dist-electron");
const RENDERER_DIST = path__default$1.join(process.env.APP_ROOT, "dist");
process.env.VITE_PUBLIC = VITE_DEV_SERVER_URL ? path__default$1.join(process.env.APP_ROOT, "public") : RENDERER_DIST;
let win;
const newTabDashboardService = new NewTabDashboardService(new DummyAeroCoreDataSource());
let newTabDashboardTimer = null;
let auditMaintenanceTimer = null;
const SESSION_VERSION = 1;
const SESSION_FILE = "session_state.json";
async function loadSessionState() {
  try {
    const filePath = path__default$1.join(app.getPath("userData"), SESSION_FILE);
    const raw = await fs$3.readFile(filePath, "utf8");
    const data = JSON.parse(raw);
    if (data.version !== SESSION_VERSION) return null;
    return data;
  } catch {
    return null;
  }
}
async function saveSessionState(state) {
  try {
    const filePath = path__default$1.join(app.getPath("userData"), SESSION_FILE);
    await fs$3.writeFile(filePath, JSON.stringify(state, null, 2), "utf8");
  } catch (err) {
    console.error("[Session] Failed to save session state:", err);
  }
}
function getWindowState() {
  if (!win) return null;
  const bounds = win.getBounds();
  return {
    x: bounds.x,
    y: bounds.y,
    width: bounds.width,
    height: bounds.height,
    isMaximized: win.isMaximized()
  };
}
const pendingApprovals = /* @__PURE__ */ new Map();
const APPROVAL_TIMEOUT_MS = 3e4;
let chatHistoryKey = null;
async function loadOrGenerateChatHistoryKey() {
  if (chatHistoryKey) return chatHistoryKey;
  let keyHex = await vaultService.getSecret("chat_history_key");
  if (!keyHex) {
    keyHex = crypto$2.randomBytes(32).toString("hex");
    await vaultService.setSecret("chat_history_key", keyHex);
  }
  chatHistoryKey = Buffer.from(keyHex, "hex");
  return chatHistoryKey;
}
async function encryptChatHistory(text) {
  const key = await loadOrGenerateChatHistoryKey();
  const iv = crypto$2.randomBytes(16);
  const cipher = crypto$2.createCipheriv("aes-256-cbc", key, iv);
  let encrypted = cipher.update(text);
  encrypted = Buffer.concat([encrypted, cipher.final()]);
  return iv.toString("hex") + ":" + encrypted.toString("hex");
}
async function decryptChatHistory(payload) {
  const key = await loadOrGenerateChatHistoryKey();
  const parts = String(payload ?? "").split(":");
  const ivHex = parts.shift() ?? "";
  const dataHex = parts.join(":");
  const iv = Buffer.from(ivHex, "hex");
  const encryptedText = Buffer.from(dataHex, "hex");
  const decipher = crypto$2.createDecipheriv("aes-256-cbc", key, iv);
  let decrypted = decipher.update(encryptedText);
  decrypted = Buffer.concat([decrypted, decipher.final()]);
  return decrypted.toString();
}
async function createWindow(sessionState) {
  const defaultWidth = 1200;
  const defaultHeight = 800;
  const windowState = (sessionState == null ? void 0 : sessionState.windowState) ?? {
    width: defaultWidth,
    height: defaultHeight,
    isMaximized: false
  };
  win = new BrowserWindow({
    icon: path__default$1.join(process.env.VITE_PUBLIC, "electron-vite.svg"),
    x: windowState.x,
    y: windowState.y,
    width: windowState.width,
    height: windowState.height,
    webPreferences: {
      preload: path__default$1.join(__dirname$1, "preload.mjs"),
      webviewTag: true
    }
  });
  if (windowState.isMaximized) {
    win.maximize();
  }
  win.on("close", async () => {
    const state = getWindowState();
    if (state) {
      await saveSessionState({
        lastSessionTime: Date.now(),
        windowState: state,
        version: SESSION_VERSION
      });
    }
  });
  const saveInterval = setInterval(async () => {
    const state = getWindowState();
    if (state) {
      await saveSessionState({
        lastSessionTime: Date.now(),
        windowState: state,
        version: SESSION_VERSION
      });
    }
  }, 3e4);
  win.on("closed", () => {
    clearInterval(saveInterval);
  });
  win.webContents.on("did-finish-load", () => {
    win == null ? void 0 : win.webContents.send("main-process-message", (/* @__PURE__ */ new Date()).toLocaleString());
    if (sessionState) {
      win == null ? void 0 : win.webContents.send("session:restored", {
        lastSessionTime: sessionState.lastSessionTime,
        restoredAt: Date.now()
      });
    }
  });
  if (VITE_DEV_SERVER_URL) {
    win.loadURL(VITE_DEV_SERVER_URL).catch((e) => {
      console.error("Failed to load dev server URL:", e);
    });
    win.webContents.openDevTools();
  } else {
    win.loadFile(path__default$1.join(RENDERER_DIST, "index.html"));
  }
}
if (process.env.ENABLE_ELECTRON_REMOTE_DEBUGGING === "true") {
  app.commandLine.appendSwitch("remote-debugging-port", "9222");
}
app.on("window-all-closed", () => {
  if (process.platform !== "darwin") {
    app.quit();
    win = null;
  }
});
app.on("activate", async () => {
  if (BrowserWindow.getAllWindows().length === 0) {
    const sessionState = await loadSessionState();
    createWindow(sessionState);
  }
});
app.whenReady().then(async () => {
  const sessionState = await loadSessionState();
  console.log("[Session] Loaded session state:", sessionState ? `last session ${new Date(sessionState.lastSessionTime).toISOString()}` : "no previous session");
  const policyService = new PolicyService(auditService, telemetryService);
  toolRegistry.setPolicyService(policyService);
  policyService.init({ remotePolicyUrl: process.env.POLICY_REMOTE_URL || void 0 }).catch(() => void 0);
  ipcMain.handle("policy:status", async () => {
    return policyService.getRemotePolicyStatus();
  });
  ipcMain.handle("policy:sync-state", async () => {
    return policyService.getSyncState();
  });
  ipcMain.handle("policy:sync", async (_event, url) => {
    const targetUrl = typeof url === "string" && url.trim() ? url.trim() : process.env.POLICY_REMOTE_URL || "";
    if (!targetUrl) return { success: false, error: "No policy URL provided" };
    try {
      const bundle = await policyService.fetchRemotePolicies(targetUrl);
      return { success: true, bundle };
    } catch (err) {
      return { success: false, error: err.message || "Sync failed" };
    }
  });
  ipcMain.handle("policy:configure", async (_event, cfg) => {
    if (!cfg.url || typeof cfg.url !== "string") {
      return { success: false, error: "Policy URL is required" };
    }
    return policyService.configureRemotePolicy(cfg.url, cfg.authToken);
  });
  ipcMain.handle("policy:set-auth-token", async (_event, token) => {
    if (!token || typeof token !== "string") {
      return { success: false, error: "Token is required" };
    }
    await policyService.setAuthToken(token);
    return { success: true };
  });
  ipcMain.handle("policy:clear-auth-token", async () => {
    await policyService.clearAuthToken();
    return { success: true };
  });
  ipcMain.handle("policy:get-admin-message", async () => {
    return { message: policyService.getAdminMessage() };
  });
  ipcMain.handle("policy:set-dev-override", async (_event, enabled, token) => {
    const ok = await policyService.setDeveloperOverride(Boolean(enabled), token);
    return { success: ok };
  });
  ipcMain.handle("identity:get-session", async () => {
    return await identityService.getSession();
  });
  ipcMain.handle("identity:login", async () => {
    const profile = await identityService.loginWithPopup();
    return profile;
  });
  ipcMain.handle("identity:logout", async () => {
    await identityService.clearSession();
    return { success: true };
  });
  ipcMain.handle("identity:get-access-token", async () => {
    return await identityService.getAccessToken();
  });
  newTabDashboardService.init().then(() => {
    if (newTabDashboardTimer) clearInterval(newTabDashboardTimer);
    newTabDashboardTimer = setInterval(async () => {
      try {
        const next = await newTabDashboardService.tick();
        for (const w of BrowserWindow.getAllWindows()) {
          if (!w || w.isDestroyed()) continue;
          try {
            w.webContents.send("newtab:dashboard-update", next);
          } catch {
          }
        }
      } catch {
      }
    }, 3500);
  }).catch(() => void 0);
  ipcMain.handle("newtab:dashboard-snapshot", async () => {
    return newTabDashboardService.getSnapshot();
  });
  ipcMain.handle("chatHistory:get", async () => {
    const filePath = path__default$1.join(app.getPath("userData"), "chat_history.json.enc");
    try {
      const raw = await fs$3.readFile(filePath, "utf8");
      const json = await decryptChatHistory(raw);
      const parsed = JSON.parse(json);
      return Array.isArray(parsed) ? parsed : [];
    } catch {
      return [];
    }
  });
  ipcMain.handle("chatHistory:set", async (_event, messages) => {
    const filePath = path__default$1.join(app.getPath("userData"), "chat_history.json.enc");
    const arr2 = Array.isArray(messages) ? messages : [];
    const capped = arr2.slice(-200);
    const json = JSON.stringify(capped);
    const enc = await encryptChatHistory(json);
    await fs$3.writeFile(filePath, enc, "utf8");
    return { success: true };
  });
  ipcMain.handle("chatHistory:clear", async () => {
    const filePath = path__default$1.join(app.getPath("userData"), "chat_history.json.enc");
    try {
      await fs$3.unlink(filePath);
    } catch {
    }
    return { success: true };
  });
  ipcMain.on("agent:approval-response", (event, payload) => {
    var _a3;
    const requestId = payload == null ? void 0 : payload.requestId;
    const approved = Boolean(payload == null ? void 0 : payload.approved);
    if (typeof requestId !== "string") return;
    const pending = pendingApprovals.get(requestId);
    if (!pending) return;
    if (((_a3 = event.sender) == null ? void 0 : _a3.id) !== pending.requesterWebContentsId) return;
    clearTimeout(pending.timeout);
    pendingApprovals.delete(requestId);
    pending.resolve(approved ? true : { approved: false, reason: "denied" });
  });
  toolRegistry.setApprovalHandler(async (toolName, args) => {
    const runId = agentRunContext.getRunId();
    const requesterWebContentsId = agentRunContext.getRequesterWebContentsId();
    const permissionMode = agentRunContext.getPermissionMode();
    if (permissionMode === "yolo") return true;
    if (!requesterWebContentsId) return false;
    const wc = webContents.fromId(requesterWebContentsId);
    if (!wc || wc.isDestroyed()) return false;
    const requestId = v4$2();
    const createdAt = Date.now();
    wc.send("agent:request-approval", { requestId, toolName, args, runId, timeoutMs: APPROVAL_TIMEOUT_MS });
    return await new Promise((resolve) => {
      const timeout = setTimeout(() => {
        pendingApprovals.delete(requestId);
        try {
          const still = webContents.fromId(requesterWebContentsId);
          if (still && !still.isDestroyed()) {
            still.send("agent:approval-timeout", { requestId, toolName, runId });
          }
        } catch {
        }
        resolve({ approved: false, reason: "timeout" });
      }, APPROVAL_TIMEOUT_MS);
      pendingApprovals.set(requestId, {
        requestId,
        runId,
        toolName,
        requesterWebContentsId,
        createdAt,
        timeout,
        resolve
      });
    });
  });
  ipcMain.handle("browser:webview-register", async (_, { tabId, webContentsId }) => {
    browserTargetService.registerWebview(tabId, webContentsId);
  });
  ipcMain.on("browser:activate-tab", async (_event, payload) => {
    const win2 = BrowserWindow.getAllWindows()[0];
    if (win2 && (payload == null ? void 0 : payload.tabId)) {
      win2.webContents.send("browser:activate-tab", { tabId: payload.tabId });
    }
  });
  ipcMain.handle("browser:active-tab", async (_, { tabId }) => {
    browserTargetService.setActiveTab(tabId ?? null);
  });
  ipcMain.handle("vault:set", async (_, account, secret) => {
    return await vaultService.setSecret(account, secret);
  });
  ipcMain.handle("vault:get", async (_, account) => {
    return await vaultService.getSecret(account);
  });
  ipcMain.handle("vault:delete", async (_, account) => {
    return await vaultService.deleteSecret(account);
  });
  ipcMain.handle("audit:get-logs", async (_, limit2) => {
    const rows = auditService.getLogs(typeof limit2 === "number" ? limit2 : 100);
    return rows.map((row) => {
      const details = (() => {
        try {
          return JSON.parse(row.details);
        } catch {
          return row.details;
        }
      })();
      return { ...row, details };
    });
  });
  ipcMain.handle("audit:verify-chain", async (_event, limit2) => {
    const n = typeof limit2 === "number" ? limit2 : void 0;
    return auditService.verifyHashChain(n);
  });
  ipcMain.handle("audit:ship-now", async (_event, limit2) => {
    const n = typeof limit2 === "number" ? limit2 : 200;
    return await auditService.shipPendingLogs(n);
  });
  ipcMain.handle("audit:rotate-now", async (_event, retentionDays2) => {
    const n = typeof retentionDays2 === "number" ? retentionDays2 : 30;
    return await auditService.rotateLogs(n);
  });
  if (auditMaintenanceTimer) clearInterval(auditMaintenanceTimer);
  const shipIntervalMs = (() => {
    const raw = process.env.AUDIT_SHIP_INTERVAL_MS;
    const n = raw ? Number(raw) : NaN;
    if (Number.isFinite(n) && n > 5e3) return n;
    return 6e4;
  })();
  const retentionDays = (() => {
    const raw = process.env.AUDIT_RETENTION_DAYS;
    const n = raw ? Number(raw) : NaN;
    if (Number.isFinite(n) && n > 0) return n;
    return 30;
  })();
  auditMaintenanceTimer = setInterval(async () => {
    try {
      await auditService.shipPendingLogs(200);
    } catch {
    }
    try {
      await auditService.rotateLogs(retentionDays);
    } catch {
    }
  }, shipIntervalMs);
  ipcMain.handle("agent:feedback", async (_event, payload) => {
    const p = payload;
    const id = p == null ? void 0 : p.skillId;
    if (typeof id !== "string") return false;
    const label = p == null ? void 0 : p.label;
    const version2 = p == null ? void 0 : p.version;
    const successVal = p == null ? void 0 : p.success;
    if (label === "worked" || label === "failed" || label === "partial") {
      const v = typeof version2 === "number" ? version2 : void 0;
      if (typeof taskKnowledgeService.recordFeedback === "function") {
        taskKnowledgeService.recordFeedback(
          id,
          label,
          v
        );
        return true;
      }
      taskKnowledgeService.recordOutcome(id, label === "worked");
      return true;
    }
    if (typeof successVal === "boolean") {
      taskKnowledgeService.recordOutcome(id, successVal);
      return true;
    }
    return false;
  });
  ipcMain.handle("telemetry:export", async () => {
    const exportPath = path__default$1.join(app.getPath("userData"), "trajectories_export.json");
    const count = await telemetryService.exportTrajectories(exportPath);
    return { success: true, count, path: exportPath };
  });
  ipcMain.handle("benchmark:runSuite", async (_, filter) => {
    const results2 = await benchmarkService.runSuite(filter);
    return results2;
  });
  ipcMain.handle("agent:set-auto-learn", async (_, enabled) => {
    benchmarkService.setAutoLearn(enabled);
    return { success: true, enabled };
  });
  ipcMain.handle("benchmark:runSuiteWithFlag", async (_, filter, enableActionsPolicy) => {
    const results2 = await benchmarkService.runSuite(filter, enableActionsPolicy);
    return results2;
  });
  ipcMain.handle("benchmark:exportTrajectories", async (_, results2) => {
    const filePath = await benchmarkService.exportTrajectories(results2);
    return { success: true, path: filePath };
  });
  ipcMain.handle("terminal:getContext", async () => {
    const { domContextService: domContextService2 } = await Promise.resolve().then(() => DOMContextService$1);
    return domContextService2.getContext();
  });
  ipcMain.handle("terminal:getMinimalContext", async () => {
    const { domContextService: domContextService2 } = await Promise.resolve().then(() => DOMContextService$1);
    return domContextService2.getMinimalContext();
  });
  ipcMain.handle("terminal:executeCode", async (_, code2, options2) => {
    const { codeExecutorService: codeExecutorService2 } = await Promise.resolve().then(() => CodeExecutorService$1);
    return codeExecutorService2.execute(code2, options2);
  });
  ipcMain.handle("terminal:evaluate", async (_, expression) => {
    const { codeExecutorService: codeExecutorService2 } = await Promise.resolve().then(() => CodeExecutorService$1);
    return codeExecutorService2.evaluate(expression);
  });
  ipcMain.handle("terminal:queryDOM", async (_, selector) => {
    const { codeExecutorService: codeExecutorService2 } = await Promise.resolve().then(() => CodeExecutorService$1);
    return codeExecutorService2.queryDOM(selector);
  });
  ipcMain.handle("terminal:click", async (_, selector) => {
    const { codeExecutorService: codeExecutorService2 } = await Promise.resolve().then(() => CodeExecutorService$1);
    return codeExecutorService2.click(selector);
  });
  ipcMain.handle("terminal:type", async (_, selector, text) => {
    const { codeExecutorService: codeExecutorService2 } = await Promise.resolve().then(() => CodeExecutorService$1);
    return codeExecutorService2.type(selector, text);
  });
  ipcMain.handle("terminal:waitForElementToDisappear", async (_, selector, timeout) => {
    const { codeExecutorService: codeExecutorService2 } = await Promise.resolve().then(() => CodeExecutorService$1);
    return codeExecutorService2.waitForElementToDisappear(selector, timeout);
  });
  ipcMain.handle("terminal:waitForURLChange", async (_, pattern, timeout) => {
    const { codeExecutorService: codeExecutorService2 } = await Promise.resolve().then(() => CodeExecutorService$1);
    return codeExecutorService2.waitForURLChange(pattern, timeout);
  });
  ipcMain.handle("terminal:waitForDOMStable", async (_, stabilityMs, timeout) => {
    const { codeExecutorService: codeExecutorService2 } = await Promise.resolve().then(() => CodeExecutorService$1);
    return codeExecutorService2.waitForDOMStable(stabilityMs, timeout);
  });
  ipcMain.handle("terminal:waitForCondition", async (_, conditionCode, timeout, pollInterval) => {
    const { codeExecutorService: codeExecutorService2 } = await Promise.resolve().then(() => CodeExecutorService$1);
    return codeExecutorService2.waitForCondition(conditionCode, timeout, pollInterval);
  });
  ipcMain.handle("terminal:waitForNetworkIdle", async (_, idleMs, timeout) => {
    const { codeExecutorService: codeExecutorService2 } = await Promise.resolve().then(() => CodeExecutorService$1);
    return codeExecutorService2.waitForNetworkIdle(idleMs, timeout);
  });
  ipcMain.handle("monitor:create", async (_, config2) => {
    const { pageMonitorService } = await import("./PageMonitorService-B27POWTa.js");
    return pageMonitorService.createMonitor(config2);
  });
  ipcMain.handle("monitor:getAll", async () => {
    const { pageMonitorService } = await import("./PageMonitorService-B27POWTa.js");
    return pageMonitorService.getMonitors();
  });
  ipcMain.handle("monitor:get", async (_, id) => {
    const { pageMonitorService } = await import("./PageMonitorService-B27POWTa.js");
    return pageMonitorService.getMonitor(id);
  });
  ipcMain.handle("monitor:pause", async (_, id) => {
    const { pageMonitorService } = await import("./PageMonitorService-B27POWTa.js");
    return pageMonitorService.pauseMonitor(id);
  });
  ipcMain.handle("monitor:resume", async (_, id) => {
    const { pageMonitorService } = await import("./PageMonitorService-B27POWTa.js");
    return pageMonitorService.resumeMonitor(id);
  });
  ipcMain.handle("monitor:delete", async (_, id) => {
    const { pageMonitorService } = await import("./PageMonitorService-B27POWTa.js");
    return pageMonitorService.deleteMonitor(id);
  });
  ipcMain.handle("monitor:reset", async (_, id) => {
    const { pageMonitorService } = await import("./PageMonitorService-B27POWTa.js");
    return pageMonitorService.resetMonitor(id);
  });
  ipcMain.handle("monitor:check", async (_, id) => {
    const { pageMonitorService } = await import("./PageMonitorService-B27POWTa.js");
    return pageMonitorService.checkMonitor(id);
  });
  ipcMain.handle("telemetry:getTerminalLogs", async (_, limit2) => {
    const { telemetryService: telemetryService2 } = await Promise.resolve().then(() => TelemetryService$1);
    return telemetryService2.getTerminalLogs(limit2);
  });
  ipcMain.handle("telemetry:getTerminalStats", async () => {
    const { telemetryService: telemetryService2 } = await Promise.resolve().then(() => TelemetryService$1);
    return telemetryService2.getTerminalStats();
  });
  ipcMain.handle("telemetry:exportTerminalLogs", async (_, outputPath) => {
    const { telemetryService: telemetryService2 } = await Promise.resolve().then(() => TelemetryService$1);
    return telemetryService2.exportTerminalLogs(outputPath);
  });
  ipcMain.handle("telemetry:clearTerminalLogs", async () => {
    const { telemetryService: telemetryService2 } = await Promise.resolve().then(() => TelemetryService$1);
    return telemetryService2.clearTerminalLogs();
  });
  ipcMain.handle("scripts:save", async (_, config2) => {
    const { scriptLibraryService } = await import("./ScriptLibraryService-BmOSSIXU.js");
    return scriptLibraryService.saveScript(config2);
  });
  ipcMain.handle("scripts:getAll", async () => {
    const { scriptLibraryService } = await import("./ScriptLibraryService-BmOSSIXU.js");
    return scriptLibraryService.getScripts();
  });
  ipcMain.handle("scripts:get", async (_, id) => {
    const { scriptLibraryService } = await import("./ScriptLibraryService-BmOSSIXU.js");
    return scriptLibraryService.getScript(id);
  });
  ipcMain.handle("scripts:update", async (_, id, updates) => {
    const { scriptLibraryService } = await import("./ScriptLibraryService-BmOSSIXU.js");
    return scriptLibraryService.updateScript(id, updates);
  });
  ipcMain.handle("scripts:delete", async (_, id) => {
    const { scriptLibraryService } = await import("./ScriptLibraryService-BmOSSIXU.js");
    return scriptLibraryService.deleteScript(id);
  });
  ipcMain.handle("scripts:recordUsage", async (_, id) => {
    const { scriptLibraryService } = await import("./ScriptLibraryService-BmOSSIXU.js");
    return scriptLibraryService.recordUsage(id);
  });
  ipcMain.handle("scripts:suggestForUrl", async (_, url) => {
    const { scriptLibraryService } = await import("./ScriptLibraryService-BmOSSIXU.js");
    return scriptLibraryService.suggestForUrl(url);
  });
  ipcMain.handle("scripts:search", async (_, query) => {
    const { scriptLibraryService } = await import("./ScriptLibraryService-BmOSSIXU.js");
    return scriptLibraryService.search(query);
  });
  ipcMain.handle("scripts:generateName", async (_, command) => {
    const { scriptLibraryService } = await import("./ScriptLibraryService-BmOSSIXU.js");
    return scriptLibraryService.generateName(command);
  });
  ipcMain.handle("terminal:generateCode", async (_, command, options2) => {
    const { codeGeneratorService: codeGeneratorService2 } = await Promise.resolve().then(() => CodeGeneratorService$1);
    return codeGeneratorService2.generate(command, void 0, options2);
  });
  let activeStreamAbort = null;
  ipcMain.handle("terminal:generateCodeStream", async (event, command) => {
    const { codeGeneratorService: codeGeneratorService2 } = await Promise.resolve().then(() => CodeGeneratorService$1);
    activeStreamAbort = new AbortController();
    try {
      const generator = codeGeneratorService2.generateStream(command);
      for await (const chunk of generator) {
        if (activeStreamAbort == null ? void 0 : activeStreamAbort.signal.aborted) {
          event.sender.send("terminal:streamToken", { type: "cancelled", content: "" });
          break;
        }
        event.sender.send("terminal:streamToken", chunk);
        if (chunk.type === "done" || chunk.type === "error") {
          break;
        }
      }
    } catch (err) {
      event.sender.send("terminal:streamToken", {
        type: "error",
        content: err instanceof Error ? err.message : String(err)
      });
    } finally {
      activeStreamAbort = null;
    }
    return { started: true };
  });
  ipcMain.handle("terminal:cancelStream", async () => {
    if (activeStreamAbort) {
      activeStreamAbort.abort();
      return { cancelled: true };
    }
    return { cancelled: false };
  });
  ipcMain.handle("terminal:generateCodeWithRetry", async (_, command, previousCode, error) => {
    const { codeGeneratorService: codeGeneratorService2 } = await Promise.resolve().then(() => CodeGeneratorService$1);
    return codeGeneratorService2.generateWithRetry(command, previousCode, error);
  });
  ipcMain.handle("terminal:generateMultiStepPlan", async (_, command) => {
    const { codeGeneratorService: codeGeneratorService2 } = await Promise.resolve().then(() => CodeGeneratorService$1);
    return codeGeneratorService2.generateMultiStepPlan(command);
  });
  ipcMain.handle("terminal:executeMultiStepPlan", async (event, plan2) => {
    const { codeExecutorService: codeExecutorService2 } = await Promise.resolve().then(() => CodeExecutorService$1);
    return codeExecutorService2.executeMultiStepPlan(plan2, {}, (stepId, result, iteration2) => {
      event.sender.send("terminal:step", {
        phase: "multiStep",
        status: result.success ? "done" : "error",
        data: { stepId, iteration: iteration2, result: result.result },
        error: result.error
      });
    });
  });
  ipcMain.handle("terminal:isMultiStepCommand", async (_, command) => {
    const { codeGeneratorService: codeGeneratorService2 } = await Promise.resolve().then(() => CodeGeneratorService$1);
    return codeGeneratorService2.isMultiStepCommand(command);
  });
  ipcMain.handle("terminal:agent", async (event, query) => {
    const { browserAgentPipeline: browserAgentPipeline2 } = await Promise.resolve().then(() => BrowserAgentPipeline$1);
    event.sender.send("terminal:step", { phase: "agent", status: "running", message: "Starting agentic pipeline..." });
    try {
      const result = await browserAgentPipeline2.runPipeline(query);
      event.sender.send("terminal:step", { phase: "agent", status: "done" });
      return { success: true, result };
    } catch (err) {
      const errorMsg = err instanceof Error ? err.message : String(err);
      event.sender.send("terminal:step", { phase: "agent", status: "error", error: errorMsg });
      return { success: false, error: errorMsg };
    }
  });
  ipcMain.handle("terminal:run", async (event, command, options2) => {
    const startTime2 = Date.now();
    const maxRetries = (options2 == null ? void 0 : options2.maxRetries) ?? 2;
    const { domContextService: domContextService2 } = await Promise.resolve().then(() => DOMContextService$1);
    const { codeGeneratorService: codeGeneratorService2 } = await Promise.resolve().then(() => CodeGeneratorService$1);
    const { codeExecutorService: codeExecutorService2 } = await Promise.resolve().then(() => CodeExecutorService$1);
    let context;
    try {
      event.sender.send("terminal:step", { phase: "context", status: "running" });
      context = await domContextService2.getContext();
      event.sender.send("terminal:step", { phase: "context", status: "done", data: { url: context.url, title: context.title } });
    } catch (err) {
      const errorMsg = err instanceof Error ? err.message : String(err);
      event.sender.send("terminal:step", { phase: "context", status: "error", error: errorMsg });
      return {
        success: false,
        error: `Failed to get page context: ${errorMsg}`,
        duration: Date.now() - startTime2,
        retryCount: 0
      };
    }
    let generatedCode;
    try {
      event.sender.send("terminal:step", { phase: "codegen", status: "running" });
      const codeResult = await codeGeneratorService2.generate(command, context);
      if (!codeResult.success || !codeResult.code) {
        throw new Error(codeResult.error || "Code generation failed");
      }
      generatedCode = codeResult.code;
      event.sender.send("terminal:step", { phase: "codegen", status: "done", data: { code: generatedCode } });
    } catch (err) {
      const errorMsg = err instanceof Error ? err.message : String(err);
      event.sender.send("terminal:step", { phase: "codegen", status: "error", error: errorMsg });
      return {
        success: false,
        error: `Failed to generate code: ${errorMsg}`,
        duration: Date.now() - startTime2,
        retryCount: 0
      };
    }
    event.sender.send("terminal:step", { phase: "execute", status: "running" });
    let execResult = await codeExecutorService2.execute(generatedCode);
    let retryCount = 0;
    const errorHistory = [];
    while (!execResult.success && (options2 == null ? void 0 : options2.autoRetry) !== false && retryCount < maxRetries) {
      retryCount++;
      const currentError = execResult.error || "Unknown error";
      errorHistory.push(currentError);
      event.sender.send("terminal:step", {
        phase: "retry",
        status: "running",
        data: {
          error: currentError,
          attempt: retryCount,
          maxRetries,
          analysis: `Attempt ${retryCount}/${maxRetries}: Analyzing error and generating fix...`
        }
      });
      const retryResult = await codeGeneratorService2.generateWithRetry(
        command,
        generatedCode,
        currentError,
        context
      );
      if (retryResult.success && retryResult.code) {
        generatedCode = retryResult.code;
        event.sender.send("terminal:step", {
          phase: "codegen",
          status: "done",
          data: { code: retryResult.code, isRetry: true, attempt: retryCount }
        });
        event.sender.send("terminal:step", { phase: "execute", status: "running" });
        execResult = await codeExecutorService2.execute(retryResult.code);
      } else {
        event.sender.send("terminal:step", {
          phase: "retry",
          status: "error",
          data: { attempt: retryCount },
          error: retryResult.error || "Failed to generate fix"
        });
        break;
      }
    }
    event.sender.send("terminal:step", {
      phase: "execute",
      status: execResult.success ? "done" : "error",
      data: execResult.success ? { result: execResult.result } : { errorHistory },
      error: execResult.error
    });
    const { telemetryService: telemetryService2 } = await Promise.resolve().then(() => TelemetryService$1);
    const contextHash = context ? Buffer.from(JSON.stringify({ url: context.url, title: context.title })).toString("base64").slice(0, 16) : void 0;
    await telemetryService2.logTerminalExecution({
      id: `exec-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`,
      timestamp: Date.now(),
      command,
      code: generatedCode,
      success: execResult.success,
      result: execResult.success ? execResult.result : void 0,
      error: execResult.error,
      duration: Date.now() - startTime2,
      contextHash,
      url: context == null ? void 0 : context.url,
      retryCount
    }).catch((err) => console.error("[Telemetry] Failed to log execution:", err));
    return {
      success: execResult.success,
      code: generatedCode,
      result: execResult.result,
      error: execResult.error,
      stack: execResult.stack,
      duration: Date.now() - startTime2,
      retryCount,
      errorHistory: execResult.success ? void 0 : errorHistory
    };
  });
  ipcMain.handle("agent:get-saved-plans", async () => {
    return planMemory.getPlans();
  });
  ipcMain.handle("agent:save-plan", async (_event, taskId, plan2) => {
    await planMemory.savePlan(taskId, plan2);
    return { success: true };
  });
  ipcMain.handle("agent:delete-plan", async (_event, taskId) => {
    await planMemory.deletePlan(taskId);
    return { success: true };
  });
  ipcMain.handle("agent:chat", async (event, message) => {
    const runId = v4$2();
    try {
      event.sender.send("agent:step", {
        type: "observation",
        content: `Run started: ${runId}`,
        metadata: { runId, ts: (/* @__PURE__ */ new Date()).toISOString() }
      });
    } catch {
    }
    let url;
    let domain;
    try {
      const activeWebview = browserTargetService.getActiveWebContents();
      if (activeWebview && !activeWebview.isDestroyed()) {
        url = activeWebview.getURL();
        if (url) {
          try {
            const urlObj = new URL(url);
            domain = urlObj.hostname;
            if (urlObj.port) {
              domain += `:${urlObj.port}`;
            }
          } catch {
          }
        }
      }
    } catch {
    }
    try {
      await telemetryService.emit({
        eventId: v4$2(),
        runId,
        ts: (/* @__PURE__ */ new Date()).toISOString(),
        type: "agent_run_start",
        name: "agent:chat",
        data: { messageLength: String(message ?? "").length }
      });
    } catch {
    }
    await auditService.log({
      actor: "user",
      action: "chat_message",
      details: { message, runId },
      status: "success"
    });
    agentService.setStepHandler((step) => {
      event.sender.send("agent:step", step);
      try {
        const rawMetadata = step == null ? void 0 : step.metadata;
        const toolName = rawMetadata == null ? void 0 : rawMetadata.tool;
        const args = rawMetadata == null ? void 0 : rawMetadata.args;
        const stepContent = String((step == null ? void 0 : step.content) ?? "");
        const contentLength = stepContent.length;
        const contentHash = crypto$2.createHash("sha256").update(stepContent).digest("hex");
        const contentPreview = contentLength > 2e3 ? stepContent.slice(0, 2e3) : stepContent;
        const argsJson = (() => {
          try {
            return JSON.stringify(args ?? null);
          } catch {
            return "[unserializable_args]";
          }
        })();
        const argsHash = crypto$2.createHash("sha256").update(argsJson).digest("hex");
        const sanitizedMetadata = rawMetadata ? {
          ...rawMetadata,
          ...args !== void 0 ? { args: void 0, argsHash } : null
        } : void 0;
        auditService.log({
          actor: "agent",
          action: "agent_step",
          details: {
            runId,
            type: step == null ? void 0 : step.type,
            toolName,
            contentPreview,
            contentLength,
            contentHash,
            argsHash: args !== void 0 ? argsHash : void 0,
            metadata: sanitizedMetadata
          },
          status: "success"
        }).catch(() => void 0);
      } catch {
      }
    });
    agentService.setTokenHandler((token) => {
      event.sender.send("agent:token", token);
    });
    let browserContext = "Current browser state: No active tab";
    try {
      const wc = browserTargetService.getActiveWebContents();
      const url2 = wc.getURL();
      const title = wc.getTitle();
      browserContext = `Current browser state: URL="${url2}", Title="${title}"`;
    } catch (err) {
    }
    let response = "";
    try {
      const permissionMode = agentService.getPermissionMode();
      response = await agentRunContext.run(
        { runId, requesterWebContentsId: event.sender.id, browserContext: { url, domain }, permissionMode },
        async () => {
          return await agentService.chat(message, browserContext);
        }
      );
    } finally {
      try {
        await telemetryService.emit({
          eventId: v4$2(),
          runId,
          ts: (/* @__PURE__ */ new Date()).toISOString(),
          type: "agent_run_end",
          name: "agent:chat",
          data: { responseLength: response.length }
        });
      } catch {
      }
    }
    await auditService.log({
      actor: "agent",
      action: "chat_response",
      details: { response, runId },
      status: "success"
    });
    return response;
  });
  ipcMain.handle("agent:reset-conversation", async () => {
    agentService.resetConversation();
    return { success: true };
  });
  ipcMain.handle("agent:get-models", async () => {
    return AVAILABLE_MODELS;
  });
  ipcMain.handle("agent:get-llm-config", async () => {
    return agentService.getLLMConfig();
  });
  ipcMain.handle("agent:set-llm-config", async (_event, cfg) => {
    await agentService.setLLMConfig(cfg ?? {});
    return { success: true };
  });
  ipcMain.handle("agent:get-current-model", async () => {
    return agentService.getCurrentModelId();
  });
  ipcMain.handle("agent:set-model", async (_, modelId) => {
    agentService.setModel(modelId);
    return { success: true, modelId };
  });
  ipcMain.handle("agent:set-mode", async (_, mode) => {
    agentService.setAgentMode(mode);
    return { success: true };
  });
  ipcMain.handle("agent:get-mode", async () => {
    return agentService.getAgentMode();
  });
  ipcMain.handle("agent:set-permission-mode", async (_, mode) => {
    agentService.setPermissionMode(mode);
    return { success: true };
  });
  ipcMain.handle("agent:get-permission-mode", async () => {
    return agentService.getPermissionMode();
  });
  ipcMain.handle("agent:test-connection", async (_event, cfg) => {
    var _a3, _b, _c;
    const { baseUrl, apiKey, model } = cfg;
    try {
      const controller = new AbortController();
      const timeout = setTimeout(() => controller.abort(), 1e4);
      const response = await fetch(`${baseUrl}/chat/completions`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          ...apiKey ? { "Authorization": `Bearer ${apiKey}` } : {}
        },
        body: JSON.stringify({
          model,
          messages: [{ role: "user", content: 'Say "ok" and nothing else.' }],
          max_tokens: 10,
          temperature: 0
        }),
        signal: controller.signal
      });
      clearTimeout(timeout);
      if (!response.ok) {
        const errorText = await response.text().catch(() => "Unknown error");
        return { success: false, error: `HTTP ${response.status}: ${errorText.slice(0, 200)}` };
      }
      const data = await response.json();
      const content = ((_c = (_b = (_a3 = data == null ? void 0 : data.choices) == null ? void 0 : _a3[0]) == null ? void 0 : _b.message) == null ? void 0 : _c.content) || "";
      return { success: true, response: content.slice(0, 100), model: (data == null ? void 0 : data.model) || model };
    } catch (err) {
      if (err.name === "AbortError") {
        return { success: false, error: "Connection timed out (10s)" };
      }
      return { success: false, error: err.message || "Connection failed" };
    }
  });
  ipcMain.handle("agent:list-remote-models", async (_event, cfg) => {
    const { baseUrl, apiKey } = cfg;
    try {
      const response = await fetch(`${baseUrl}/models`, {
        method: "GET",
        headers: {
          "Content-Type": "application/json",
          ...apiKey ? { "Authorization": `Bearer ${apiKey}` } : {}
        }
      });
      if (!response.ok) {
        return { success: false, error: `HTTP ${response.status}`, models: [] };
      }
      const data = await response.json();
      const models = ((data == null ? void 0 : data.data) || (data == null ? void 0 : data.models) || []).map((m) => ({
        id: m.id || m.name || m,
        name: m.name || m.id || m
      }));
      return { success: true, models };
    } catch (err) {
      return { success: false, error: err.message, models: [] };
    }
  });
  ipcMain.handle("session:get-info", async () => {
    const state = await loadSessionState();
    return state ? {
      lastSessionTime: state.lastSessionTime,
      hasSession: true
    } : {
      lastSessionTime: null,
      hasSession: false
    };
  });
  ipcMain.handle("session:clear", async () => {
    try {
      const filePath = path__default$1.join(app.getPath("userData"), SESSION_FILE);
      await fs$3.unlink(filePath);
      return { success: true };
    } catch {
      return { success: false };
    }
  });
  ipcMain.handle("browser:navigate-tab", async (_, url) => {
    const win2 = BrowserWindow.getAllWindows()[0];
    if (win2) {
      win2.webContents.send("browser:navigate-to", url);
      return { success: true, url };
    }
    return { success: false, error: "No window found" };
  });
  createWindow(sessionState);
});
export {
  MAIN_DIST as M,
  RENDERER_DIST as R,
  VITE_DEV_SERVER_URL as V,
  browserTargetService as b,
  v4$2 as v
};
